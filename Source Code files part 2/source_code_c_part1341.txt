= p_tracker->p_prev;

  /* if not first on the list */
  if (p_tracker->p_prev)
    p_tracker->p_prev->p_next = p_tracker->p_next;
  else
    pInstance->API.pTracker = p_tracker->p_next;

  MemFree (p_tracker);
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   find_tracker_by_txchannel
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
Tracker_T *
find_tracker_by_txchannel (struct InstanceStruct *pInstance, DWORD dwChannel, API_TRACKER_CH_ALLOC_T ChannelAlloc)
{
  register Tracker_T *p_tracker;

  ASSERT (pInstance != NULL);

  for (p_tracker = pInstance->API.pTracker;p_tracker;p_tracker = p_tracker->p_next)
  {
    if (p_tracker->u.Channel.TxChannel    == dwChannel &&
        p_tracker->u.Channel.ChannelAlloc == ChannelAlloc)
    {
      return p_tracker;
    }
  }

  return NULL;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   find_tracker_by_rxchannel
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
Tracker_T *
find_tracker_by_rxchannel (struct InstanceStruct *pInstance, DWORD dwChannel, API_TRACKER_CH_ALLOC_T ChannelAlloc)
{
  register Tracker_T *p_tracker;

  ASSERT (pInstance != NULL);

  for (p_tracker = pInstance->API.pTracker;p_tracker;p_tracker = p_tracker->p_next)
  {
    if (p_tracker->u.Channel.RxChannel    == dwChannel &&
        p_tracker->u.Channel.ChannelAlloc == ChannelAlloc)
    {
      return p_tracker;
    }
  }

  return NULL;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   find_tracker_by_pointer
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
Tracker_T *
find_tracker_by_pointer (struct InstanceStruct *pInstance, Tracker_T *p_tracker_look)
{
  Tracker_T *p_tracker;

  ASSERT (pInstance != NULL);

  for (p_tracker = pInstance->API.pTracker;
       ((p_tracker) && (p_tracker != p_tracker_look));
       p_tracker = p_tracker->p_next);

  return p_tracker;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   find_tracker_by_type
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUMES:     table MUST be locked before this call on this call ..
 *
 *****************************************************************************/
Tracker_T *
find_tracker_by_type (struct InstanceStruct *pInstance,
                      API_TRACKER_T tracker_type,
                      Tracker_T *p_tracker_start)
{
  Tracker_T *p_tracker;

  ASSERT (pInstance != NULL);
  if (p_tracker_start)
    p_tracker = p_tracker_start;
  else
    p_tracker = pInstance->API.pTracker;

  for (;
       ((p_tracker) && (p_tracker->TrackerType != tracker_type));
       p_tracker = p_tracker->p_next);

  return p_tracker;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   set_capability -
 *
 * DESCRIPTION:
 *              NOTE: capid in the TotCap structure is
 *                    ignored.
 *
 * RETURN:
 *              NewCapId            if no error
 *              H245_INVALID_CAPID  if error
 *
 * ASSUMES:
 *              Assumes the H245_INST_T is valid and has been checked
 *
 *****************************************************************************/
void del_mux_cap(struct TerminalCapabilitySet *pTermCapSet)
{
  if (pTermCapSet->bit_mask & multiplexCapability_present)
  {
    switch (pTermCapSet->multiplexCapability.choice)
    {
    case MltplxCpblty_nonStandard_chosen:
      FreeNonStandardParameter(&pTermCapSet->multiplexCapability.u.MltplxCpblty_nonStandard);
      break;

    case h222Capability_chosen:
      FreeH222Cap(&pTermCapSet->multiplexCapability.u.h222Capability);
      break;

    case h2250Capability_chosen:
      FreeH2250Cap(&pTermCapSet->multiplexCapability.u.h2250Capability);
      break;

    } // switch
    pTermCapSet->bit_mask &= ~multiplexCapability_present;
  }
} // del_mux_cap()

HRESULT set_mux_cap(struct InstanceStruct        *pInstance,
                    struct TerminalCapabilitySet *pTermCapSet,
                    H245_TOTCAP_T                *pTotCap)
{
  HRESULT                   lError;

  switch (pTotCap->ClientType)
  {
  case H245_CLIENT_MUX_NONSTD:
    H245TRACE(pInstance->dwInst,4,"API:set_mux_cap - NONSTD");
    lError = CopyNonStandardParameter(&pTermCapSet->multiplexCapability.u.MltplxCpblty_nonStandard,
                                        &pTotCap->Cap.H245Mux_NONSTD);
    if (lError != H245_ERROR_OK)
      return lError;
    pTermCapSet->multiplexCapability.choice = MltplxCpblty_nonStandard_chosen;
    break;

  case H245_CLIENT_MUX_H222:
    H245TRACE(pInstance->dwInst,4,"API:set_mux_cap - H222");
    lError = CopyH222Cap(&pTermCapSet->multiplexCapability.u.h222Capability,
                           &pTotCap->Cap.H245Mux_H222);
    if (lError != H245_ERROR_OK)
      return lError;
    pTermCapSet->multiplexCapability.choice = h222Capability_chosen;
    break;

  case H245_CLIENT_MUX_H223:
    H245TRACE(pInstance->dwInst,4,"API:set_mux_cap - H223");
    pTermCapSet->multiplexCapability.u.h223Capability = pTotCap->Cap.H245Mux_H223;
    pTermCapSet->multiplexCapability.choice = h223Capability_chosen;
    break;

  case H245_CLIENT_MUX_VGMUX:
    H245TRACE(pInstance->dwInst,4,"API:set_mux_cap - VGMUX");
    pTermCapSet->multiplexCapability.u.v76Capability = pTotCap->Cap.H245Mux_VGMUX;
    pTermCapSet->multiplexCapability.choice = v76Capability_chosen;
    break;

  case H245_CLIENT_MUX_H2250:
    H245TRACE(pInstance->dwInst,4,"API:set_mux_cap - H2250");
    lError = CopyH2250Cap(&pTermCapSet->multiplexCapability.u.h2250Capability,
                          &pTotCap->Cap.H245Mux_H2250);
    if (lError != H245_ERROR_OK)
      return lError;
    pTermCapSet->multiplexCapability.choice = h2250Capability_chosen;
    break;

  default:
    H245TRACE(pInstance->dwInst,1,"API:set_mux_cap - Unrecognized Client Type %d", pTotCap->ClientType);
    return H245_ERROR_NOSUP;
  }

  pTermCapSet->bit_mask |= multiplexCapability_present;
  return H245_ERROR_OK;
} // set_mux_cap()

HRESULT
set_capability (
                struct InstanceStruct        *pInstance,
                struct TerminalCapabilitySet *pTermCapSet,
                H245_TOTCAP_T                *pTotCap         /* tot capability for update*/
                )
{
  CapabilityTableEntry         *pCapEntry;
  Capability                   *pCapability;
  CapabilityTableLink           pCapLink;
  HRESULT                       lError;

  ASSERT(pInstance   != NULL);
  ASSERT(pTermCapSet != NULL);
  ASSERT(pTotCap     != NULL);

  /* if the table entry is currently in the table, */
  /* then  delete it and add a new entry with the same entry number */
  pCapLink = find_capid_by_entrynumber (pTermCapSet, pTotCap->CapId);
  if (pCapLink)
  {
    del_cap_link (pTermCapSet, pCapLink);
  } /* if pCapLink */

  /* allocate an entry for the new terminal capbaility  */
  pCapLink = alloc_link_cap_entry (pTermCapSet);
  if (pCapLink == NULL)
  {
    return H245_ERROR_NOMEM;
  }

  /* make it easier to deal with the Asn1 structures */
  pCapEntry   = &pCapLink->value;
  pCapability = &pCapEntry->capability;
  pCapability->choice = 0;
  switch (pTotCap->DataType)
  {
  case H245_DATA_NONSTD:
    pCapability->choice = Capability_nonStandard_chosen;
    break;

  case H245_DATA_VIDEO:
    switch (pTotCap->Dir)
    {
    case H245_CAPDIR_RMTTX:
    case H245_CAPDIR_LCLTX:
      pCapability->choice = transmitVideoCapability_chosen;
      break;
    case H245_CAPDIR_RMTRX:
    case H245_CAPDIR_LCLRX:
      pCapability->choice = receiveVideoCapability_chosen;
      break;
    case H245_CAPDIR_RMTRXTX:
    case H245_CAPDIR_LCLRXTX:
      pCapability->choice = rcvAndTrnsmtVdCpblty_chosen;
      break;
    } // switch (Dir)
    break;

  case H245_DATA_AUDIO:
    switch (pTotCap->Dir)
    {
    case H245_CAPDIR_RMTTX:
    case H245_CAPDIR_LCLTX:
      pCapability->choice = transmitAudioCapability_chosen;
      break;
    case H245_CAPDIR_RMTRX:
    case H245_CAPDIR_LCLRX:
      pCapability->choice = receiveAudioCapability_chosen;
      break;
    case H245_CAPDIR_RMTRXTX:
    case H245_CAPDIR_LCLRXTX:
      pCapability->choice = rcvAndTrnsmtAdCpblty_chosen;
      break;
    } // switch (Dir)
    break;

  case H245_DATA_DATA:
    switch (pTotCap->Dir)
    {
    case H245_CAPDIR_RMTTX:
    case H245_CAPDIR_LCLTX:
      pCapability->choice = trnsmtDtApplctnCpblty_chosen;
      break;
    case H245_CAPDIR_RMTRX:
    case H245_CAPDIR_LCLRX:
      pCapability->choice = rcvDtApplctnCpblty_chosen;
      break;
    case H245_CAPDIR_RMTRXTX:
    case H245_CAPDIR_LCLRXTX:
      pCapability->choice = rATDACy_chosen;
      break;
    } // switch (Dir)
    break;

  case H245_DATA_ENCRYPT_D:
    switch (pTotCap->Dir)
    {
    case H245_CAPDIR_RMTTX:
    case H245_CAPDIR_LCLTX:
      pCapability->choice = h233EncryptnTrnsmtCpblty_chosen;
      break;
    case H245_CAPDIR_RMTRX:
    case H245_CAPDIR_LCLRX:
      pCapability->choice = h233EncryptnRcvCpblty_chosen;
      break;
    } // switch (Dir)
    break;

  case H245_DATA_CONFERENCE:
    pCapability->choice = conferenceCapability_chosen;
    break;

  } // switch (DataType)

  /* if error occured, free cap, unlock, and return */
  if (pCapability->choice == 0)
  {
    H245TRACE(pInstance->dwInst,1,"API:set_capability -> Invalid capability");
    del_cap_link (pTermCapSet, pCapLink);
    return H245_ERROR_PARAM;
  }

  /* load total cap into Capability Set */
  /* if load cap returns error, free cap, unlock, and return */
  lError = load_cap(pCapability, pTotCap);
  if (lError != H245_ERROR_OK)
  {
    del_cap_link (pTermCapSet, pCapLink);
    return lError;
  }

  /* mark the entry as in use */
  pCapEntry->bit_mask = capability_present;
  pCapEntry->capabilityTableEntryNumber = pTotCap->CapId;

  /* set termcapTable  present */
  pTermCapSet->bit_mask |= capabilityTable_present;

  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   build_object_id
 *
 * DESCRIPTION
 *
 * RETURN:      linked list of Object ID structures
 *
 * ASSUMES:     Input string is a valid "<n>.<n>.<n>..."
 *
 *****************************************************************************/
static POBJECTID
build_object_id (const char *p_str)
{
  POBJECTID p_obj_id             = NULL;
  POBJECTID p_obj_id_first       = NULL;
  POBJECTID p_obj_id_lst         = NULL;
  int    value = 0;
  int    fset = FALSE;

  /* if no sting.. forget it */

  if (!p_str)
    return NULL;

  H245TRACE(0,20,"API:Object Id %s",p_str);

  /* while there is a string left.. */

  while (*p_str != '\0')
    {
      /* while there is a string left, and it's not a '.' */

      value = 0;
      fset = FALSE;

      while ((*p_str != '\0') && (*p_str != '.'))
        {
          fset = TRUE;
          value = value*10+(*p_str-'0');
          p_str++;
        }
      /* must ahve been a "." or an end string */

      if (fset)
        {
          if (*p_str != '\0')
            p_str++;

          /* allocate the first object */
          if (!(p_obj_id = (POBJECTID) MemAlloc (sizeof(*p_obj_id))))
            {
              free_object_id (p_obj_id_first);

              return NULL;

            } /* if alloc failes */

          /* if first objected allocated */
          if (!p_obj_id_first)
            p_obj_id_first = p_obj_id;
          else
            p_obj_id_lst->next = p_obj_id;

          p_obj_id->value = (unsigned short) value;
          p_obj_id->next = NULL;
          p_obj_id_lst = p_obj_id;
        }

    } /* while  */

  return p_obj_id_first;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   free_mux_table_list - recursively free mux table list
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
void free_mux_table_list (H245_MUX_TABLE_T *p_mux_tbl)
{
  if (!p_mux_tbl)
    return;

  free_mux_table_list (p_mux_tbl->pNext);
  free_mux_el_list (p_mux_tbl->pMuxTblEntryElem);
  MemFree (p_mux_tbl);
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   free_mux_el_list - recursively free mux element list
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
void free_mux_el_list (H245_MUX_ENTRY_ELEMENT_T *p_mux_el)
{
  if (!p_mux_el)
    return;

  if (p_mux_el->Kind == H245_MUX_ENTRY_ELEMENT)
    free_mux_el_list (p_mux_el->u.pMuxTblEntryElem);

  free_mux_el_list (p_mux_el->pNext);
  MemFree (p_mux_el);
}
/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   api_init ()
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUMES:
 *
 *****************************************************************************/
HRESULT
api_init (struct InstanceStruct *pInstance)
{
  ASSERT (pInstance != NULL);

  H245TRACE(pInstance->dwInst,10,"API:api_init <-");

  /**************************/
  /* Terminal Cap TABLE     */
  /**************************/
  pInstance->API.PDU_LocalTermCap.choice = MltmdSystmCntrlMssg_rqst_chosen;
  pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.choice =
    terminalCapabilitySet_chosen;
  pInstance->API.PDU_RemoteTermCap.choice = MltmdSystmCntrlMssg_rqst_chosen;
  pInstance->API.PDU_RemoteTermCap.u.MltmdSystmCntrlMssg_rqst.choice =
    terminalCapabilitySet_chosen;

  /**************************/
  /* MULTIPLEX TABLE CAP's  */
  /**************************/

  switch (pInstance->Configuration)
    {
    case H245_CONF_H324:
      {
        H223Capability *p_H223;
        /* set h223 capabilities */
        pInstance->API.PDU_LocalTermCap.
          u.MltmdSystmCntrlMssg_rqst.
            u.terminalCapabilitySet.multiplexCapability.choice =
              h223Capability_chosen;

        p_H223 = &(pInstance->API.PDU_LocalTermCap.
                   u.MltmdSystmCntrlMssg_rqst.
                    u.terminalCapabilitySet.multiplexCapability.
                     u.h223Capability);

        /* (TBC) how do we communicate this to the API */
        /* booleans.. */
        p_H223->transportWithI_frames;
        p_H223-> videoWithAL1 = FALSE;
        p_H223-> videoWithAL2 = FALSE;
        p_H223-> videoWithAL3 = TRUE;
        p_H223-> audioWithAL1 = FALSE;
        p_H223-> audioWithAL2 = TRUE;
        p_H223-> audioWithAL3 = FALSE;
        p_H223-> dataWithAL1 = FALSE;
        p_H223-> dataWithAL2 = FALSE;
        p_H223-> dataWithAL3 = FALSE;
        /* ushort's */
        p_H223-> maximumAl2SDUSize = 2048;
        p_H223-> maximumAl3SDUSize = 2048;
        p_H223-> maximumDelayJitter = 0;
        /* enhanced/Basic */
        p_H223->h223MultiplexTableCapability.choice = h223MltplxTblCpblty_bsc_chosen;
      }
      break;
    case H245_CONF_H323:
      break;
    case H245_CONF_H310:
    case H245_CONF_GVD:
    default:
      return H245_ERROR_NOSUP;
      break;

    } /* switch */

  /* setup Object Id for Terminal Cap Set */
  /* (TBC) where do we get/set the protocolIdentifier */
  pInstance->API.PDU_LocalTermCap.
    u.MltmdSystmCntrlMssg_rqst.
      u.terminalCapabilitySet.protocolIdentifier = build_object_id (H245_PROTOID);

  pInstance->API.MasterSlave = APIMS_Undef;
  pInstance->API.SystemState = APIST_Inited;

  pInstance->API.LocalCapIdNum = H245_MAX_CAPID + 1;
  pInstance->API.LocalCapDescIdNum = 0;

  H245TRACE(pInstance->dwInst,10,"API:api_init -> OK");
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   api_deinit ()
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUMES:
 *
 *****************************************************************************/
HRESULT
api_deinit (struct InstanceStruct *pInstance)
{
  Tracker_T *pTracker;
  int        nCount;

  H245TRACE(pInstance->dwInst,10,"API:api_deinit <-");

  /* free structures and act on outstanding links in structure */
#ifndef NDEBUG
  dump_tracker(pInstance);
#endif
  free_object_id (pInstance->API.PDU_LocalTermCap.
                  u.MltmdSystmCntrlMssg_rqst.
                  u.terminalCapabilitySet.protocolIdentifier);

  /* free simultaneous capabilities */
  for (nCount = 0; nCount < 256; ++nCount)
  {
    if (pInstance->API.PDU_LocalTermCap.TERMCAPSET.capabilityDescriptors.value[nCount].smltnsCpblts)
      dealloc_simultaneous_cap (&pInstance->API.PDU_LocalTermCap.TERMCAPSET.capabilityDescriptors.value[nCount]);
    if (pInstance->API.PDU_RemoteTermCap.TERMCAPSET.capabilityDescriptors.value[nCount].smltnsCpblts)
      dealloc_simultaneous_cap (&pInstance->API.PDU_RemoteTermCap.TERMCAPSET.capabilityDescriptors.value[nCount]);
  }

  /* free capabilities */
  del_mux_cap(&pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet);
  del_mux_cap(&pInstance->API.PDU_RemoteTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet);
  dealloc_link_cap_list ( &pInstance->API.PDU_LocalTermCap.TERMCAPSET);
  dealloc_link_cap_list ( &pInstance->API.PDU_RemoteTermCap.TERMCAPSET);

  while ((pTracker = pInstance->API.pTracker) != NULL)
  {
    H245TRACE(pInstance->dwInst,1,"API:api_deinit -> %s Tracker Still Pending",
              map_tracker_type(pTracker->TrackerType));
    unlink_dealloc_tracker (pInstance, pTracker);
  }

  H245TRACE(pInstance->dwInst,10,"API:api_deinit -> OK");
  return H245_ERROR_OK;
}

#if defined(_DEBUG)

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   map_api_error ()
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUMES:
 *
 *****************************************************************************/

LPSTR map_api_error (HRESULT lError)
{
  static TCHAR szBuf[128];

  switch (lError)
  {
  case  H245_ERROR_OK:                  return "H245_ERROR_OK";
  case  H245_ERROR_INVALID_DATA_FORMAT: return "H245_ERROR_INVALID_DATA_FORMAT";
  case  H245_ERROR_NOMEM:               return "H245_ERROR_NOMEM";
  case  H245_ERROR_NOSUP:               return "H245_ERROR_NOSUP";
  case  H245_ERROR_PARAM:               return "H245_ERROR_PARAM";
  case  H245_ERROR_ALREADY_INIT:        return "H245_ERROR_ALREADY_INIT";
  case  H245_ERROR_NOT_CONNECTED:       return "H245_ERROR_NOT_CONNECTED";



  case  H245_ERROR_NORESOURCE:          return "H245_ERROR_NORESOURCE";
  case  H245_ERROR_NOTIMP:              return "H245_ERROR_NOTIMP";
  case  H245_ERROR_SUBSYS:              return "H245_ERROR_SUBSYS";
  case  H245_ERROR_FATAL:               return "H245_ERROR_FATAL";
  case  H245_ERROR_MAXTBL:              return "H245_ERROR_MAXTBL";
  case  H245_ERROR_CHANNEL_INUSE:       return "H245_ERROR_CHANNEL_INUSE";
  case  H245_ERROR_INVALID_CAPID:       return "H245_ERROR_INVALID_CAPID";
  case  H245_ERROR_INVALID_OP:          return "H245_ERROR_INVALID_OP";
  case  H245_ERROR_UNKNOWN:             return "H245_ERROR_UNKNOWN";
  case  H245_ERROR_NOBANDWIDTH:         return "H245_ERROR_NOBANDWIDTH";
  case  H245_ERROR_LOSTCON:             return "H245_ERROR_LOSTCON";
  case  H245_ERROR_INVALID_MUXTBLENTRY: return "H245_ERROR_INVALID_MUXTBLENTRY";
  case  H245_ERROR_INVALID_INST:        return "H245_ERROR_INVALID_INST";
  case  H245_ERROR_INPROCESS:           return "H245_ERROR_INPROCESS";
  case  H245_ERROR_INVALID_STATE:       return "H245_ERROR_INVALID_STATE";
  case  H245_ERROR_TIMEOUT:             return "H245_ERROR_TIMEOUT";
  case  H245_ERROR_INVALID_CHANNEL:     return "H245_ERROR_INVALID_CHANNEL";
  case  H245_ERROR_INVALID_CAPDESCID:   return "H245_ERROR_INVALID_CAPDESCID";
  case  H245_ERROR_CANCELED:            return "H245_ERROR_CANCELED";
  case  H245_ERROR_MUXELEMENT_DEPTH:    return "H245_ERROR_MUXELEMENT_DEPTH";
  case  H245_ERROR_MUXELEMENT_WIDTH:    return "H245_ERROR_MUXELEMENT_WIDTH";
  case  H245_ERROR_ASN1:                return "H245_ERROR_ASN1";
  case  H245_ERROR_NO_MUX_CAPS:         return "H245_ERROR_NO_MUX_CAPS";
  case  H245_ERROR_NO_CAPDESC:          return "H245_ERROR_NO_CAPDESC";
  default:
    wsprintf (szBuf,"**** UNKNOWN ERROR *** %d (0x%x)",lError,lError);
    return szBuf;
  }
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   map_fsm_event -
 *
 * DESpCRIPTION:
 *
 * RETURN:
 *
 * ASSUMES:
 *
 *****************************************************************************/
LPSTR map_fsm_event (DWORD event)
{
  static TCHAR szBuf[128];

  switch (event)
  {
  case  H245_IND_MSTSLV:                 return "H245_IND_MSTSLV";
  case  H245_IND_CAP:                    return "H245_IND_CAP";
  case  H245_IND_OPEN:                   return "H245_IND_OPEN";
  case  H245_IND_OPEN_CONF:              return "H245_IND_OPEN_CONF";
  case  H245_IND_CLOSE:                  return "H245_IND_CLOSE";
  case  H245_IND_REQ_CLOSE:              return "H245_IND_REQ_CLOSE";
  case  H245_IND_MUX_TBL:                return "H245_IND_MUX_TBL";
  case  H245_IND_MTSE_RELEASE:           return "H245_IND_MTSE_RELEASE";
  case  H245_IND_RMESE:                  return "H245_IND_RMESE";
  case  H245_IND_RMESE_RELEASE:          return "H245_IND_RMESE_RELEASE";
  case  H245_IND_MRSE:                   return "H245_IND_MRSE";
  case  H245_IND_MRSE_RELEASE:           return "H245_IND_MRSE_RELEASE";
  case  H245_IND_MLSE:                   return "H245_IND_MLSE";
  case  H245_IND_MLSE_RELEASE:           return "H245_IND_MLSE_RELEASE";
  case  H245_IND_NONSTANDARD_REQUEST:    return "H245_IND_NONSTANDARD_REQUEST";
  case  H245_IND_NONSTANDARD_RESPONSE:   return "H245_IND_NONSTANDARD_RESPONSE";
  case  H245_IND_NONSTANDARD_COMMAND:    return "H245_IND_NONSTANDARD_COMMAND";
  case  H245_IND_NONSTANDARD:            return "H245_IND_NONSTANDARD";
  case  H245_IND_MISC_COMMAND:           return "H245_IND_MISC_COMMAND";
  case  H245_IND_MISC:                   return "H245_IND_MISC";
  case  H245_IND_COMM_MODE_REQUEST:      return "H245_IND_COMM_MODE_REQUEST";
  case  H245_IND_COMM_MODE_RESPONSE:     return "H245_IND_COMM_MODE_RESPONSE";
  case  H245_IND_COMM_MODE_COMMAND:      return "H245_IND_COMM_MODE_COMMAND";
  case  H245_IND_CONFERENCE_REQUEST:     return "H245_IND_CONFERENCE_REQUEST";
  case  H245_IND_CONFERENCE_RESPONSE:    return "H245_IND_CONFERENCE_RESPONSE";
  case  H245_IND_CONFERENCE_COMMAND:     return "H245_IND_CONFERENCE_COMMAND";
  case  H245_IND_CONFERENCE:             return "H245_IND_CONFERENCE";
  case  H245_IND_SEND_TERMCAP:           return "H245_IND_SEND_TERMCAP";
  case  H245_IND_ENCRYPTION:             return "H245_IND_ENCRYPTION";
  case  H245_IND_FLOW_CONTROL:           return "H245_IND_FLOW_CONTROL";
  case  H245_IND_ENDSESSION:             return "H245_IND_ENDSESSION";
  case  H245_IND_FUNCTION_NOT_UNDERSTOOD:return "H245_IND_FUNCTION_NOT_UNDERSTOOD:";
  case  H245_IND_JITTER:                 return "H245_IND_JITTER";
  case  H245_IND_H223_SKEW:              return "H245_IND_H223_SKEW";
  case  H245_IND_NEW_ATM_VC:             return "H245_IND_NEW_ATM_VC";
  case  H245_IND_USERINPUT:              return "H245_IND_USERINPUT";
  case  H245_IND_H2250_MAX_SKEW:         return "H245_IND_H2250_MAX_SKEW";
  case  H245_IND_MC_LOCATION:            return "H245_IND_MC_LOCATION";
  case  H245_IND_VENDOR_ID:              return "H245_IND_VENDOR_ID";
  case  H245_IND_FUNCTION_NOT_SUPPORTED: return "H245_IND_FUNCTION_NOT_SUPPORTED";
  case  H245_IND_H223_RECONFIG:          return "H245_IND_H223_RECONFIG";
  case  H245_IND_H223_RECONFIG_ACK:      return "H245_IND_H223_RECONFIG_ACK";
  case  H245_IND_H223_RECONFIG_REJECT:   return "H245_IND_H223_RECONFIG_REJECT";
  case  H245_CONF_INIT_MSTSLV:           return "H245_CONF_INIT_MSTSLV";
  case  H245_CONF_SEND_TERMCAP:          return "H245_CONF_SEND_TERMCAP";
  case  H245_CONF_OPEN:                  return "H245_CONF_OPEN";
  case  H245_CONF_NEEDRSP_OPEN:          return "H245_CONF_NEEDRSP_OPEN";
  case  H245_CONF_CLOSE:                 return "H245_CONF_CLOSE";
  case  H245_CONF_REQ_CLOSE:             return "H245_CONF_REQ_CLOSE";
  case  H245_CONF_MUXTBL_SND:            return "H245_CONF_MUXTBL_SND";
  case  H245_CONF_RMESE:                 return "H245_CONF_RMESE";
  case  H245_CONF_RMESE_REJECT:          return "H245_CONF_RMESE_REJECT";
  case  H245_CONF_RMESE_EXPIRED:         return "H245_CONF_RMESE_EXPIRED";
  case  H245_CONF_MRSE:                  return "H245_CONF_MRSE";
  case  H245_CONF_MRSE_REJECT:           return "H245_CONF_MRSE_REJECT";
  case  H245_CONF_MRSE_EXPIRED:          return "H245_CONF_MRSE_EXPIRED";
  case  H245_CONF_MLSE:                  return "H245_CONF_MLSE";
  case  H245_CONF_MLSE_REJECT:           return "H245_CONF_MLSE_REJECT";
  case  H245_CONF_MLSE_EXPIRED:          return "H245_CONF_MLSE_EXPIRED";
  case  H245_CONF_RTDSE:                 return "H245_CONF_RTDSE";
  case  H245_CONF_RTDSE_EXPIRED:         return "H245_CONF_RTDSE_EXPIRED";
  default:
    wsprintf (szBuf,"**** UNKNOWN EVENT *** %d (0x%x)",event,event);
    return szBuf;
  }
}

LPSTR map_tracker_type (API_TRACKER_T tracker_type)
{
  static TCHAR szBuf[128];

  switch (tracker_type)
  {
  case  API_TERMCAP_T:       return "API_TERMCAP_T";
  case  API_OPEN_CHANNEL_T:  return "API_OPEN_CHANNEL_T";
  case  API_CLOSE_CHANNEL_T: return "API_CLOSE_CHANNEL_T";
  case  API_MSTSLV_T:        return "API_MSTSLV_T";
  case  API_SEND_MUX_T:      return "API_SEND_MUX_T";
  case  API_RECV_MUX_T:      return "API_RECV_MUX_T";
  default:
    wsprintf (szBuf,"**** UNKNOWN TRACKER TYPE *** %d (0x%x)",tracker_type,tracker_type);
    return szBuf;
  }
}

#endif // (_DEBUG)

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\ccutils.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/ccutils.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.40  $
 *	$Date:   31 Jan 1997 20:36:02  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

HRESULT InitializeLock(				PLOCK					pLock);

HRESULT DeleteLock(					PLOCK					pLock);

HRESULT AcquireLock(				PLOCK					pLock);

HRESULT AcquireTimedLock(			PLOCK					pLock,
									DWORD					dwTimeout,
									BOOL					*pbTimedOut);

HRESULT RelinquishLock(				PLOCK					pLock);

BOOL EqualConferenceIDs(			PCC_CONFERENCEID		pConferenceID1,
									PCC_CONFERENCEID		pConferenceID2);

BOOL EqualAddrs(					PCC_ADDR				pAddr1,
									PCC_ADDR				pAddr2);

HRESULT ValidateOctetString(		PCC_OCTETSTRING			pOctetString);

HRESULT CopyOctetString(			PCC_OCTETSTRING			*ppDest,
									PCC_OCTETSTRING			pSource);

HRESULT FreeOctetString(			PCC_OCTETSTRING			pOctetString);

HRESULT CopySeparateStack(			H245_ACCESS_T			**ppDest,
									H245_ACCESS_T			*pSource);

HRESULT FreeSeparateStack(			H245_ACCESS_T			*pSeparateStack);

HRESULT ValidateNonStandardData(	PCC_NONSTANDARDDATA		pNonStandardData);

HRESULT CopyNonStandardData(		PCC_NONSTANDARDDATA		*ppDest,
									PCC_NONSTANDARDDATA		pSource);

HRESULT FreeNonStandardData(		PCC_NONSTANDARDDATA		pNonStandardData);

HRESULT ValidateVendorInfo(			PCC_VENDORINFO			pVendorInfo);

HRESULT CopyVendorInfo(				PCC_VENDORINFO			*ppDest,
									PCC_VENDORINFO			pSource);

HRESULT FreeVendorInfo(				PCC_VENDORINFO			pVendorInfo);

HRESULT ValidateTermCapList(		PCC_TERMCAPLIST			pTermCapList);

HRESULT ValidateTermCapDescriptors(	PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors,
									PCC_TERMCAPLIST			pTermCapList);

HRESULT ValidateAddr(				PCC_ADDR				pAddr);

HRESULT CopyAddr(					PCC_ADDR				*ppDest,
									PCC_ADDR				pSource);

HRESULT FreeAddr(					PCC_ADDR				pAddr);

HRESULT SetQ931Port(				PCC_ADDR				pAddr);

HRESULT ValidateDisplay(			PWSTR					pszDisplay);

HRESULT CopyDisplay(				PWSTR					*ppDest,
									PWSTR					pSource);

HRESULT FreeDisplay(				PWSTR					pszDisplay);

HRESULT ValidateTerminalID(			PCC_OCTETSTRING			pTerminalID);

HRESULT CopyTerminalID(				PCC_OCTETSTRING			*ppDest,
									PCC_OCTETSTRING			pSource);

HRESULT FreeTerminalID(				PCC_OCTETSTRING			pTerminalID);

HRESULT SetTerminalType(			TRISTATE				tsMultipointController,
									BYTE					*pbTerminalType);

HRESULT CopyH245TermCapList(		PCC_TERMCAPLIST			*ppDest,
									PCC_TERMCAPLIST			pSource);

HRESULT CopyH245TermCapDescriptors(	PCC_TERMCAPDESCRIPTORS	*ppDest,
									PCC_TERMCAPDESCRIPTORS	pSource);

HRESULT CreateH245DefaultTermCapDescriptors(
									PCC_TERMCAPDESCRIPTORS	*ppDest,
									PCC_TERMCAPLIST			pTermCapList);

HRESULT DestroyH245TermCap(			PPCC_TERMCAP			ppTermCap);

HRESULT UnregisterTermCapListFromH245(		
									PCONFERENCE				pConference,
									PCC_TERMCAPLIST			pTermCapList);

HRESULT DestroyH245TermCapList(		PCC_TERMCAPLIST			*ppTermCapList);

HRESULT UnregisterTermCapDescriptorsFromH245(
									PCONFERENCE				pConference,
									PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors);

HRESULT DestroyH245TermCapDescriptors(
									PCC_TERMCAPDESCRIPTORS	*ppTermCapDescriptors);

HRESULT HostToH245IPNetwork(		BYTE					*NetworkArray,
									DWORD					dwAddr);

HRESULT H245IPNetworkToHost(		DWORD					*pdwAddr,
									BYTE					*NetworkArray);

HRESULT ProcessRemoteHangup(		CC_HCALL				hCall,
									HQ931CALL				hQ931Initiator,
									BYTE					bHangupReason);

HRESULT DefaultSessionTableConstructor(
									CC_HCONFERENCE			hConference,
									DWORD_PTR   			dwConferenceToken,
									BOOL					bCreate,
									BOOL					*pbSessionTableChanged,
									WORD					wListCount,
									PCC_TERMCAPLIST			pTermCapList[],
									PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors[],
									PCC_SESSIONTABLE		*ppSessionTable);

HRESULT DefaultTermCapConstructor(	CC_HCONFERENCE					hConference,
									DWORD_PTR						dwConferenceToken,
									BOOL							bCreate,
									BOOL							*pbTermCapsChanged,
									WORD							wListCount,
									PCC_TERMCAPLIST					pInTermCapList[],
									PCC_TERMCAPDESCRIPTORS			pInTermCapDescriptors[],
									PCC_TERMCAPLIST					*ppOutTermCapList,
									PCC_TERMCAPDESCRIPTORS			*ppOutTermCapDescriptors);

HRESULT AcceptCall(					PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT PlaceCall(					PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT SendTermCaps(				PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT SessionTableToH245CommunicationTable(
									PCC_SESSIONTABLE		pSessionTable,
									H245_COMM_MODE_ENTRY_T	*pH245CommunicationTable[],
									BYTE					*pbCommunicationTableCount);

HRESULT H245CommunicationTableToSessionTable(
									H245_COMM_MODE_ENTRY_T	H245CommunicationTable[],
									BYTE					bCommunicationTableCount,
									PCC_SESSIONTABLE		*ppSessionTable);

HRESULT FreeH245CommunicationTable(	H245_COMM_MODE_ENTRY_T	H245CommunicationTable[],
									BYTE					bCommunicationTableCount);

HRESULT CreateConferenceSessionTable(
									PCONFERENCE				pConference,
									BOOL					*pbSessionTableChanged);

HRESULT FreeConferenceSessionTable(	PCONFERENCE				pConference);

HRESULT CreateConferenceTermCaps(	PCONFERENCE				pConference,
									BOOL					*pbTermCapsChanged);

HRESULT FreeConferenceTermCaps(		PCONFERENCE				pConference);

HRESULT EnqueueRequest(				PCALL_QUEUE				*ppQueueHead,
									CC_HCALL				hEnqueuedCall);

HRESULT DequeueRequest(				PCALL_QUEUE				*ppQueueHead,
									PCC_HCALL				phEnqueuedCall);

HRESULT DequeueSpecificRequest(		PCALL_QUEUE				*ppQueueHead,
									CC_HCALL				hEnqueuedCall);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\ccmain.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/ccmain.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.81  $
 *	$Date:   31 Jan 1997 13:13:50  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#include <winerror.h>
#ifdef GATEKEEPER
#include "gkiman.h"
#endif // GATEKEEPER


#define MASTER_SLAVE_RETRY_MAX 10

typedef struct {
#ifdef _DEBUG
	CRITICAL_SECTION	LockInfoLock;
	WORD				wLockCount;
	WORD				wNumQueuedThreads;
	HANDLE				hOwningThread;
#endif
	HANDLE				Lock;
} LOCK, *PLOCK;

typedef struct {
	LOCK				Lock;
	WORD				wNumThreads;
} THREADCOUNT;

typedef enum {
	INITIALIZING_STATE,
	OPERATIONAL_STATE,
	SHUTDOWN_STATE
} CALL_CONTROL_STATE;

// The following typedef is not in callcont.h because it is only used internally
typedef DWORD	HHANGUP, *PHHANGUP;

typedef enum {
	TS_FALSE,
	TS_TRUE,
	TS_UNKNOWN
} TRISTATE;

typedef enum {
	UNCONNECTED_MODE,
	POINT_TO_POINT_MODE,
	MULTIPOINT_MODE
} CONFMODE;

typedef enum {
	NEVER_ATTACHED,	// Endpoint has never been attached to the conference
	ATTACHED,		// Endpoint is currently attached to the conference
	DETACHED		// Endpoint was once attached to the conference, but is now detached
} ATTACHSTATE;

typedef struct CallQueue_t {
	CC_HCALL			hCall;
	struct CallQueue_t	*pNext;
	struct CallQueue_t	*pPrev;
} CALL_QUEUE, *PCALL_QUEUE;

#define NUM_TERMINAL_ALLOCATION_SLOTS	24		// 24*sizeof(BYTE) = 192 = max. terminal number
#define NUM_CHANNEL_ALLOCATION_SLOTS	32		// 32*sizeof(BYTE) = 256 = max. channel number

typedef enum {
	TERMINAL_ID_INVALID,
	TERMINAL_ID_REQUESTED,
	TERMINAL_ID_VALID
} TERMINALIDSTATE;

typedef struct {
	TERMINALIDSTATE			TerminalIDState;
	CC_PARTICIPANTINFO		ParticipantInfo;
	PCALL_QUEUE				pEnqueuedRequestsForTerminalID; // list of calls waiting to get this peer's terminal ID
} PARTICIPANTINFO, *PPARTICIPANTINFO;


typedef struct Conference_t {
	CC_HCONFERENCE			hConference;		// handle for this conference object
	CC_CONFERENCEID			ConferenceID;		// conference ID (0 => conference ID has not
												//   been established)
	PARTICIPANTINFO			LocalParticipantInfo;
	BYTE					TerminalNumberAllocation[NUM_TERMINAL_ALLOCATION_SLOTS];
	BYTE					ChannelNumberAllocation[NUM_CHANNEL_ALLOCATION_SLOTS];
	BOOL					bDeferredDelete;
	BOOL					bMultipointCapable;
	BOOL					bForceMC;
	BOOL					bAutoAccept;
	ATTACHSTATE				LocalEndpointAttached;
	BOOL					bDynamicConferenceID;
	BOOL					bDynamicTerminalID;
	PCC_TERMCAP				pLocalH245H2250MuxCapability;
	PCC_TERMCAPLIST			pLocalH245TermCapList;			// terminal capabilities
	PCC_TERMCAPDESCRIPTORS	pLocalH245TermCapDescriptors;	// terminal capability descriptors
	BOOL					bSessionTableInternallyConstructed;  // TRUE => session table must be
												// deallocated by Call Control; FALSE => must be
												// deallocated by SessionTableConstructor
	PCC_SESSIONTABLE		pSessionTable;
	PCC_TERMCAP				pConferenceH245H2250MuxCapability;
	PCC_TERMCAPLIST			pConferenceTermCapList;
	PCC_TERMCAPDESCRIPTORS	pConferenceTermCapDescriptors;
	DWORD_PTR				dwConferenceToken;	// conference token specified by user in
												//   CreateConference()
	CC_SESSIONTABLE_CONSTRUCTOR SessionTableConstructor;
	CC_TERMCAP_CONSTRUCTOR	TermCapConstructor;
	CC_CONFERENCE_CALLBACK	ConferenceCallback;	// conference callback location
	CC_CONFERENCE_CALLBACK	SaveConferenceCallback;	// saved copy of the conference callback location
	struct Call_t			*pEnqueuedCalls;
	struct Call_t			*pPlacedCalls;
	struct Call_t			*pEstablishedCalls;
	struct Call_t			*pVirtualCalls;
	struct Channel_t		*pChannels;
	TRISTATE				tsMultipointController;
	TRISTATE				tsMaster;
	CONFMODE				ConferenceMode;
	PCC_ADDR				pMultipointControllerAddr;
	PCC_VENDORINFO			pVendorInfo;
	PCALL_QUEUE				pEnqueuedRequestModeCalls;
	BOOL					bInTable;
	struct Conference_t		*pNextInTable;
	struct Conference_t		*pPrevInTable;
	LOCK					Lock;
} CONFERENCE, *PCONFERENCE, **PPCONFERENCE;

// State of call object
typedef enum {
	INCOMING,		// incoming call request has been received,
					//   but not yet accepted or rejected
	ENQUEUED,		// call has been enqueued on conference for later placement
	PLACED,			// call has been placed, awaiting RINGING, CONNECT or RELEASECOMPLETE
	RINGING,		// RINGING received, awaiting CONNECT or RELEASECOMPLETE
	TERMCAP,		// CONNECT received or incoming call accepted,
					//   awaiting completion of terminal capability exchange
	CALL_COMPLETE	// call placement complete (either success or failure)
} CALLSTATE;

typedef enum {
	NEED_TO_SEND_TERMCAP,
	AWAITING_TERMCAP,
	AWAITING_ACK,
	TERMCAP_COMPLETE
} TERMCAPSTATE;

typedef enum {
	MASTER_SLAVE_NOT_STARTED,
	MASTER_SLAVE_IN_PROGRESS,
	MASTER_SLAVE_COMPLETE
} MASTERSLAVESTATE;

typedef enum {
	CALLER,
	CALLEE,
	VIRTUAL,
	THIRD_PARTY_INVITOR,
	THIRD_PARTY_INTERMEDIARY	// we're the MC in a third party invite
} CALLTYPE;

typedef struct Call_t {
	CC_HCALL				hCall;
	CC_HCONFERENCE			hConference;
	HQ931CALL				hQ931Call;
	HQ931CALL				hQ931CallInvitor;		// Invitor in third party invite
	PPARTICIPANTINFO		pPeerParticipantInfo;
	BOOL					bMarkedForDeletion;
	PCC_NONSTANDARDDATA		pLocalNonStandardData;
	PCC_NONSTANDARDDATA		pPeerNonStandardData;
	PCC_ADDR				pQ931LocalConnectAddr;
	PCC_ADDR				pQ931PeerConnectAddr;
	PCC_ADDR				pQ931DestinationAddr;
	PCC_ADDR				pSourceCallSignalAddress;
	PCC_TERMCAPLIST			pPeerH245TermCapList;
	PCC_TERMCAP				pPeerH245H2250MuxCapability;
	PCC_TERMCAPDESCRIPTORS	pPeerH245TermCapDescriptors;
	PCC_ALIASNAMES			pLocalAliasNames;
	PCC_ALIASNAMES			pPeerAliasNames;
	PCC_ALIASNAMES			pPeerExtraAliasNames;
	PCC_ALIASITEM			pPeerExtension;
	PWSTR					pszLocalDisplay;
	PWSTR					pszPeerDisplay;
	PCC_VENDORINFO			pPeerVendorInfo;
	DWORD_PTR				dwUserToken;
	TERMCAPSTATE			OutgoingTermCapState;	// NEED_TO_SEND_TERMCAP, AWAITING_ACK, or
													// TERMCAP_COMPLETE
	TERMCAPSTATE			IncomingTermCapState;	// AWAITING_TERMCAP or TERMCAP_COMPLETE
	MASTERSLAVESTATE		MasterSlaveState;
	struct Call_t			*pNext;
	struct Call_t			*pPrev;
	CALLSTATE				CallState;
	CALLTYPE				CallType;
	BOOL					bCallerIsMC;
	CC_CONFERENCEID			ConferenceID;
	BOOL					bLinkEstablished;
	H245_INST_T				H245Instance;
	DWORD					dwH245PhysicalID;
	WORD					wMasterSlaveRetry;
	GUID                    CallIdentifier;
#ifdef GATEKEEPER
   GKICALL           GkiCall;
#endif // GATEKEEPER
	BOOL					bInTable;
	struct Call_t			*pNextInTable;
	struct Call_t			*pPrevInTable;
	LOCK					Lock;
} CALL, *PCALL, **PPCALL;

// Channel types must be bit maps
#define TX_CHANNEL			0x01
#define RX_CHANNEL			0x02
#define TXRX_CHANNEL		0x04	// bi-directional channel
#define PROXY_CHANNEL		0x08
#define ALL_CHANNELS		(TX_CHANNEL | RX_CHANNEL | TXRX_CHANNEL | PROXY_CHANNEL)

typedef struct Channel_t {
	CC_HCHANNEL				hChannel;
	CC_HCONFERENCE			hConference;
	DWORD_PTR				dwUserToken;
	BYTE					bSessionID;
	BYTE					bAssociatedSessionID;
	WORD					wLocalChannelNumber;
	WORD					wRemoteChannelNumber;
	BOOL					bMultipointChannel;
	WORD					wNumOutstandingRequests;
	PCC_TERMCAP				pTxH245TermCap;
	PCC_TERMCAP				pRxH245TermCap;
	H245_MUX_T				*pTxMuxTable;
	H245_MUX_T				*pRxMuxTable;
	H245_ACCESS_T			*pSeparateStack;
	CC_HCALL				hCall;
	BYTE					bChannelType;
	BOOL					bCallbackInvoked;
	TRISTATE				tsAccepted;
	PCALL_QUEUE				pCloseRequests;
	PCC_ADDR				pLocalRTPAddr;
	PCC_ADDR				pLocalRTCPAddr;
	PCC_ADDR				pPeerRTPAddr;
	PCC_ADDR				pPeerRTCPAddr;
	DWORD                   dwChannelBitRate;
	BOOL					bLocallyOpened;
	struct Channel_t		*pNext;
	struct Channel_t		*pPrev;
	BOOL					bInTable;
	struct Channel_t		*pNextInTable;
	struct Channel_t		*pPrevInTable;
	LOCK					Lock;
} CHANNEL, *PCHANNEL, **PPCHANNEL;

typedef struct Listen_t {
	CC_HLISTEN				hListen;
	CC_ADDR					ListenAddr;
	DWORD_PTR				dwListenToken;
	CC_LISTEN_CALLBACK		ListenCallback;
	HQ931LISTEN				hQ931Listen;
	PCC_ALIASNAMES			pLocalAliasNames;	// local alias names
	BOOL					bInTable;
	struct Listen_t			*pNextInTable;
	struct Listen_t			*pPrevInTable;
	LOCK					Lock;
} LISTEN, *PLISTEN, **PPLISTEN;

typedef struct Hangup_t {
	HHANGUP					hHangup;
	CC_HCONFERENCE			hConference;
	DWORD_PTR				dwUserToken;
	WORD					wNumCalls;
	BOOL					bInTable;
	struct Hangup_t			*pNextInTable;
	struct Hangup_t			*pPrevInTable;
	LOCK					Lock;
} HANGUP, *PHANGUP, **PPHANGUP;

#ifdef FORCE_SERIALIZE_CALL_CONTROL
#define EnterCallControlTop()      {CCLOCK_AcquireLock();}

#define LeaveCallControlTop(f)     {CCLOCK_RelinquishLock(); \
                                    return f;}
#define EnterCallControl()
#define HResultLeaveCallControl(f) {return f;}
#define DWLeaveCallControl(f)      {return f;}

#else
#define EnterCallControlTop()  EnterCallControl()
#define LeaveCallControlTop(f) HResultLeaveCallControl(f)

#define EnterCallControl()         {AcquireLock(&ThreadCount.Lock); \
									ThreadCount.wNumThreads++; \
									RelinquishLock(&ThreadCount.Lock);}

#define NullLeaveCallControl()     {AcquireLock(&ThreadCount.Lock); \
									ThreadCount.wNumThreads--; \
									RelinquishLock(&ThreadCount.Lock); \
                                    return;}

#define HResultLeaveCallControl(f) {HRESULT stat; \
	                                stat = f; \
									AcquireLock(&ThreadCount.Lock); \
				                    ThreadCount.wNumThreads--; \
									RelinquishLock(&ThreadCount.Lock); \
                                    return stat;}

#define DWLeaveCallControl(f)      {DWORD	stat; \
	                                stat = f; \
									AcquireLock(&ThreadCount.Lock); \
				                    ThreadCount.wNumThreads--; \
									RelinquishLock(&ThreadCount.Lock); \
                                    return stat;}
#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\ccutils.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/ccutils.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.107  $
 *	$Date:   04 Mar 1997 17:34:44  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#include "precomp.h"

#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "apierror.h"
#include "ccmain.h"
#include "chanman.h"
#include "confman.h"
#include "callman.h"
#include "q931man.h"
#include "userman.h"
#include "ccutils.h"
#include "linkapi.h"
#include "h245man.h"

extern CC_CONFERENCEID	InvalidConferenceID;



HANDLE ghCCLock = NULL;
HRESULT InitializeCCLock(VOID)
{
    ASSERT(ghCCLock == NULL);
    ghCCLock = CreateMutex(NULL, FALSE, NULL);	
    if(ghCCLock == NULL)
    {
        return CC_INTERNAL_ERROR;
	}
	else
	{
		return CC_OK;
    }
}
VOID UnInitializeCCLock()
{
    ASSERT(ghCCLock);
    if(ghCCLock)
    {
        CloseHandle(ghCCLock);
    }
}

VOID CCLOCK_AcquireLock()
{
    DWORD dwStatus;
    ASSERT(ghCCLock);
    dwStatus = WaitForSingleObject(ghCCLock, INFINITE);

  	if ((dwStatus != WAIT_OBJECT_0) && (dwStatus != WAIT_TIMEOUT))
  	{
		ASSERT(0);
	}
}

VOID CCLOCK_RelinquishLock()
{
    ASSERT(ghCCLock);
    ReleaseMutex(ghCCLock);
}

HRESULT InitializeLock(				PLOCK					pLock)
{
	ASSERT(pLock != NULL);

#ifdef _DEBUG
	InitializeCriticalSection(&pLock->LockInfoLock);
	pLock->wLockCount = 0;
	pLock->wNumQueuedThreads = 0;
	pLock->hOwningThread = 0;
#endif

        pLock->Lock = CreateMutex(NULL, // security attributes
							  FALSE,	// initial owner
							  NULL);	// name

	if (pLock->Lock == NULL) {
#ifdef _DEBUG
		DeleteCriticalSection(&pLock->LockInfoLock);
#endif
		return CC_INTERNAL_ERROR;
	} else
		return CC_OK;
}



HRESULT DeleteLock(					PLOCK					pLock)
{
	ASSERT(pLock != NULL);

#ifdef _DEBUG
	DeleteCriticalSection(&pLock->LockInfoLock);
#endif

	if (CloseHandle(pLock->Lock) == TRUE)
		return CC_OK;
	else
		return CC_INTERNAL_ERROR;
}



HRESULT AcquireLock(				PLOCK					pLock)
{
HRESULT	status;

	ASSERT(pLock != NULL);
	
	status = AcquireTimedLock(pLock, INFINITE, NULL);
	return status;
}



HRESULT AcquireTimedLock(			PLOCK					pLock,
									DWORD					dwTimeout,
									BOOL					*pbTimedOut)
{
DWORD	dwStatus;

	ASSERT(pLock != NULL);

#ifdef _DEBUG
	EnterCriticalSection(&pLock->LockInfoLock);
	(pLock->wNumQueuedThreads)++;
	LeaveCriticalSection(&pLock->LockInfoLock);
#endif

	dwStatus = WaitForSingleObject(pLock->Lock, dwTimeout);

#ifdef _DEBUG
	EnterCriticalSection(&pLock->LockInfoLock);
	(pLock->wNumQueuedThreads)--;
	(pLock->wLockCount)++;
	pLock->hOwningThread = GetCurrentThread();
	LeaveCriticalSection(&pLock->LockInfoLock);
#endif

	if ((dwStatus != WAIT_OBJECT_0) && (dwStatus != WAIT_TIMEOUT))
		return CC_INTERNAL_ERROR;

	if (dwStatus == WAIT_TIMEOUT) {
		if (pbTimedOut != NULL) {
			*pbTimedOut = TRUE;
		}
	} else {
		if (pbTimedOut != NULL) {
			*pbTimedOut = FALSE;
		}
	}
	return CC_OK;
}



HRESULT RelinquishLock(				PLOCK					pLock)
{
	ASSERT(pLock != NULL);

#ifdef _DEBUG
	EnterCriticalSection(&pLock->LockInfoLock);
	(pLock->wLockCount)--;
	if (pLock->wLockCount == 0)
		pLock->hOwningThread = 0;
	LeaveCriticalSection(&pLock->LockInfoLock);
#endif

	if (ReleaseMutex(pLock->Lock) == TRUE)
		return CC_OK;
	else
		return CC_INTERNAL_ERROR;
}



HRESULT ValidateOctetString(		PCC_OCTETSTRING			pOctetString)
{
	if (pOctetString == NULL)
		return CC_OK;
	if ((pOctetString->wOctetStringLength > 0) &&
		(pOctetString->pOctetString == NULL))
		return CC_BAD_PARAM;
	return CC_OK;
}



HRESULT CopyOctetString(			PCC_OCTETSTRING			*ppDest,
									PCC_OCTETSTRING			pSource)
{
	ASSERT(ppDest != NULL);

    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }
    *ppDest = (PCC_OCTETSTRING)MemAlloc(sizeof(CC_OCTETSTRING));
    if (*ppDest == NULL)
        return CC_NO_MEMORY;
	(*ppDest)->wOctetStringLength = pSource->wOctetStringLength;
	if ((pSource->wOctetStringLength == 0) ||
		(pSource->pOctetString == NULL)) {
		pSource->wOctetStringLength = 0;
		(*ppDest)->pOctetString = NULL;
	} else {
		(*ppDest)->pOctetString = (BYTE *)MemAlloc(pSource->wOctetStringLength);
		if ((*ppDest)->pOctetString == NULL) {
			MemFree(*ppDest);
			*ppDest = NULL;
			return CC_NO_MEMORY;
		}
		memcpy((*ppDest)->pOctetString, pSource->pOctetString, pSource->wOctetStringLength);
	}
    return CC_OK;
}



HRESULT FreeOctetString(			PCC_OCTETSTRING			pOctetString)
{
	if (pOctetString == NULL)
		return CC_OK;
	if ((pOctetString->wOctetStringLength > 0) &&
		(pOctetString->pOctetString != NULL))
		MemFree(pOctetString->pOctetString);
	MemFree(pOctetString);
	return CC_OK;
}



HRESULT CopySeparateStack(			H245_ACCESS_T			**ppDest,
									H245_ACCESS_T			*pSource)
{
	ASSERT(ppDest != NULL);

    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }

	// We currently can't handle IP source route addresses,
	// since this address format contains embedded pointers
	// that cannot simply be copied
	if ((pSource->networkAddress.choice == localAreaAddress_chosen) &&
		(pSource->networkAddress.u.localAreaAddress.choice == unicastAddress_chosen) &&
		(pSource->networkAddress.u.localAreaAddress.u.unicastAddress.choice == iPSourceRouteAddress_chosen))
		return CC_NOT_IMPLEMENTED;

    *ppDest = (H245_ACCESS_T *)MemAlloc(sizeof(H245_ACCESS_T));
    if (*ppDest == NULL)
        return CC_NO_MEMORY;

	**ppDest = *pSource;
    return CC_OK;
}



HRESULT FreeSeparateStack(			H245_ACCESS_T			*pSeparateStack)
{
	if (pSeparateStack == NULL)
		return CC_OK;
	MemFree(pSeparateStack);
	return CC_OK;
}



HRESULT ValidateNonStandardData(	PCC_NONSTANDARDDATA		pNonStandardData)
{
	if (pNonStandardData == NULL)
		return CC_OK;
	return ValidateOctetString(&pNonStandardData->sData);
}



HRESULT CopyNonStandardData(		PCC_NONSTANDARDDATA		*ppDest,
									PCC_NONSTANDARDDATA		pSource)
{
	ASSERT(ppDest != NULL);

    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }
    *ppDest = (PCC_NONSTANDARDDATA)MemAlloc(sizeof(CC_NONSTANDARDDATA));
    if (*ppDest == NULL)
        return CC_NO_MEMORY;
	**ppDest = *pSource;
	if ((pSource->sData.wOctetStringLength == 0) ||
		(pSource->sData.pOctetString == NULL)) {
		(*ppDest)->sData.wOctetStringLength = 0;
		(*ppDest)->sData.pOctetString = NULL;
	} else {
		(*ppDest)->sData.pOctetString = (BYTE *)MemAlloc(pSource->sData.wOctetStringLength);
		if ((*ppDest)->sData.pOctetString == NULL) {
			MemFree(*ppDest);
			return CC_NO_MEMORY;
		}
		memcpy((*ppDest)->sData.pOctetString,
			   pSource->sData.pOctetString,
			   pSource->sData.wOctetStringLength);
	}
    return CC_OK;
}



HRESULT FreeNonStandardData(		PCC_NONSTANDARDDATA		pNonStandardData)
{
	if (pNonStandardData == NULL)
		return CC_OK;
	if ((pNonStandardData->sData.wOctetStringLength > 0) &&
		(pNonStandardData->sData.pOctetString != NULL))
		MemFree(pNonStandardData->sData.pOctetString);
	MemFree(pNonStandardData);
	return CC_OK;
}



HRESULT ValidateVendorInfo(			PCC_VENDORINFO			pVendorInfo)
{
HRESULT		status;

	if (pVendorInfo == NULL)
		return CC_OK;
	status = ValidateOctetString(pVendorInfo->pProductNumber);
	if (status != CC_OK)
		return status;
	status = ValidateOctetString(pVendorInfo->pVersionNumber);
	return status;
}



HRESULT CopyVendorInfo(				PCC_VENDORINFO			*ppDest,
									PCC_VENDORINFO			pSource)
{
HRESULT		status;

	ASSERT(ppDest != NULL);

    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }
    *ppDest = (PCC_VENDORINFO)MemAlloc(sizeof(CC_VENDORINFO));
    if (*ppDest == NULL)
        return CC_NO_MEMORY;
	**ppDest = *pSource;
	status = CopyOctetString(&(*ppDest)->pProductNumber, pSource->pProductNumber);
	if (status != CC_OK) {
		MemFree(*ppDest);
		return status;
	}
	status = CopyOctetString(&(*ppDest)->pVersionNumber, pSource->pVersionNumber);
	if (status != CC_OK) {
		FreeOctetString((*ppDest)->pProductNumber);
		MemFree(*ppDest);
		return status;
	}
    return CC_OK;
}



HRESULT FreeVendorInfo(				PCC_VENDORINFO			pVendorInfo)
{
	if (pVendorInfo == NULL)
		return CC_OK;
	FreeOctetString(pVendorInfo->pProductNumber);
	FreeOctetString(pVendorInfo->pVersionNumber);
	MemFree(pVendorInfo);
	return CC_OK;
}



BOOL EqualConferenceIDs(			PCC_CONFERENCEID		pConferenceID1,
									PCC_CONFERENCEID		pConferenceID2)
{
	ASSERT(pConferenceID1 != NULL);
	ASSERT(pConferenceID2 != NULL);

	if (memcmp(pConferenceID1->buffer,
	           pConferenceID2->buffer,
			   sizeof(pConferenceID1->buffer)) == 0)
		return TRUE;
	else
		return FALSE;
}



BOOL EqualAddrs(					PCC_ADDR				pAddr1,
									PCC_ADDR				pAddr2)
{
	ASSERT(pAddr1 != NULL);
	ASSERT(pAddr2 != NULL);

	if (pAddr1->nAddrType != pAddr2->nAddrType)
		return FALSE;

	if (pAddr1->bMulticast != pAddr2->bMulticast)
		return FALSE;

	switch (pAddr1->nAddrType) {
		case CC_IP_DOMAIN_NAME:
			if ((pAddr1->Addr.IP_DomainName.wPort == pAddr2->Addr.IP_DomainName.wPort) &&
			    (wcscmp(pAddr1->Addr.IP_DomainName.cAddr, pAddr2->Addr.IP_DomainName.cAddr) == 0))
				return TRUE;
			else
				return FALSE;
		case CC_IP_DOT:
			if ((pAddr1->Addr.IP_Dot.wPort == pAddr2->Addr.IP_Dot.wPort) &&
			    (wcscmp(pAddr1->Addr.IP_Dot.cAddr, pAddr2->Addr.IP_Dot.cAddr) == 0))
				return TRUE;
			else
				return FALSE;
		case CC_IP_BINARY:
			if ((pAddr1->Addr.IP_Binary.wPort == pAddr2->Addr.IP_Binary.wPort) &&
			    (pAddr1->Addr.IP_Binary.dwAddr == pAddr2->Addr.IP_Binary.dwAddr))
				return TRUE;
			else
				return FALSE;
		default:
			ASSERT(0);
			return FALSE;
	}
}



HRESULT ValidateTermCapList(		PCC_TERMCAPLIST			pTermCapList)
{
unsigned    i, j;

	if (pTermCapList == NULL)
		return CC_OK;

	for (i = 0; i < pTermCapList->wLength; i++)
		if (pTermCapList->pTermCapArray[i] == NULL)
		return CC_BAD_PARAM;

	// make sure that all capability IDs are unique
	for (i = 0; i < pTermCapList->wLength; i++) {
		for (j = i + 1; j < pTermCapList->wLength; j++) {
			if (pTermCapList->pTermCapArray[i]->CapId == pTermCapList->pTermCapArray[j]->CapId)
				return CC_BAD_PARAM;
		}
		if ((pTermCapList->pTermCapArray[i]->CapId == H245_INVALID_CAPID) ||
			(pTermCapList->pTermCapArray[i]->CapId == 0))
			return CC_BAD_PARAM;
	}
	return CC_OK;
}



HRESULT ValidateTermCapDescriptors(	PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors,
									PCC_TERMCAPLIST			pTermCapList)
{
WORD				i, j, k, l;
H245_TOTCAPDESC_T	*pTermCapDescriptor;
H245_SIMCAP_T		*pSimCaps;

	if (pTermCapDescriptors == NULL)
		return CC_OK;

	for (i = 0; i < pTermCapDescriptors->wLength; i++) {
		pTermCapDescriptor = pTermCapDescriptors->pTermCapDescriptorArray[i];
		if ((pTermCapDescriptor->CapDescId > 255) ||
			(pTermCapDescriptor->CapDesc.Length == 0) ||
			(pTermCapDescriptor->CapDesc.Length > H245_MAX_SIMCAPS))
			return CC_BAD_PARAM;
		for (j = i + 1; j < pTermCapDescriptors->wLength; j++) {
			if (pTermCapDescriptor->CapDescId ==
				pTermCapDescriptors->pTermCapDescriptorArray[j]->CapDescId) {
				return CC_BAD_PARAM;
			}
		}
		for (j = 0; j < pTermCapDescriptor->CapDesc.Length; j++) {
			pSimCaps = &(pTermCapDescriptor->CapDesc.SimCapArray[j]);
			if ((pSimCaps->Length == 0) ||
				(pSimCaps->Length > H245_MAX_ALTCAPS))
				return CC_BAD_PARAM;
			for (k = 0; k < pSimCaps->Length; k++) {
				for (l = 0; l < pTermCapList->wLength; l++) {
					if (pSimCaps->AltCaps[k] ==
						pTermCapList->pTermCapArray[l]->CapId)
						break;
				}
				if (l == pTermCapList->wLength)
					// the capability descriptor contains a capability ID
					// which is not present in the capability table
					return CC_BAD_PARAM;
			}
		}
	}
	return CC_OK;
}



HRESULT ValidateAddr(				PCC_ADDR				pAddr)
{
	if (pAddr == NULL)
		return CC_OK;
	if ((pAddr->nAddrType != CC_IP_DOMAIN_NAME) &&
		(pAddr->nAddrType != CC_IP_DOT) &&
		(pAddr->nAddrType != CC_IP_BINARY))
		return CC_BAD_PARAM;
	return CC_OK;
}



HRESULT CopyAddr(					PCC_ADDR				*ppDest,
									PCC_ADDR				pSource)
{
	ASSERT(ppDest != NULL);

    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }
    *ppDest = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
    if (*ppDest == NULL)
        return CC_NO_MEMORY;
    **ppDest = *pSource;
    return CC_OK;
}



HRESULT FreeAddr(					PCC_ADDR				pAddr)
{
    if (pAddr == NULL)
        return CC_OK;
    MemFree(pAddr);
    return CC_OK;
}



HRESULT SetQ931Port(				PCC_ADDR				pAddr)
{
	if (pAddr == NULL)
		return CC_OK;
	switch (pAddr->nAddrType) {
		case CC_IP_DOMAIN_NAME:
			if (pAddr->Addr.IP_DomainName.wPort == 0)
				pAddr->Addr.IP_DomainName.wPort = CC_H323_HOST_CALL;
			return CC_OK;
		case CC_IP_DOT:
			if (pAddr->Addr.IP_Dot.wPort == 0)
				pAddr->Addr.IP_Dot.wPort = CC_H323_HOST_CALL;
			return CC_OK;
		case CC_IP_BINARY:
			if (pAddr->Addr.IP_Binary.wPort == 0)
				pAddr->Addr.IP_Binary.wPort = CC_H323_HOST_CALL;
			return CC_OK;
	}

	ASSERT(0);
	return CC_INTERNAL_ERROR;
}



HRESULT ValidateDisplay(			PWSTR					pszDisplay)
{
	return CC_OK;
}



HRESULT CopyDisplay(				PWSTR					*ppDest,
									PWSTR					pSource)
{
	ASSERT(ppDest != NULL);

    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }
    *ppDest = (WCHAR *)MemAlloc((wcslen(pSource)+1)*sizeof(WCHAR));
    if (*ppDest == NULL)
        return CC_NO_MEMORY;
	wcscpy(*ppDest, pSource);
    return CC_OK;
}



HRESULT FreeDisplay(				PWSTR					pszDisplay)
{
	MemFree(pszDisplay);
	return CC_OK;
}



HRESULT ValidateTerminalID(			PCC_OCTETSTRING			pTerminalID)
{
	return ValidateOctetString(pTerminalID);
}



HRESULT CopyTerminalID(				PCC_OCTETSTRING			*ppDest,
									PCC_OCTETSTRING			pSource)
{
	ASSERT(ppDest != NULL);

    return CopyOctetString(ppDest, pSource);
}



HRESULT FreeTerminalID(				PCC_OCTETSTRING			pTerminalID)
{
    return FreeOctetString(pTerminalID);
}



HRESULT SetTerminalType(			TRISTATE				tsMultipointController,
									BYTE					*pbTerminalType)
{
	switch (tsMultipointController) {
		case TS_TRUE:
			*pbTerminalType = 240;
			break;
		case TS_UNKNOWN:
			*pbTerminalType = 70;
			break;
		case TS_FALSE:
			*pbTerminalType = 50;
			break;
		default:
			ASSERT(0);
			*pbTerminalType = 0;
			break;
	}
	return CC_OK;
}



HRESULT CopyH245TermCapList(		PCC_TERMCAPLIST			*ppDest,
									PCC_TERMCAPLIST			pSource)
{
WORD	i;
HRESULT	status;

	ASSERT(ppDest != NULL);

    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }

	*ppDest = (PCC_TERMCAPLIST)MemAlloc(sizeof(CC_TERMCAPLIST));
	if (*ppDest == NULL)
		return CC_NO_MEMORY;

	(*ppDest)->wLength = pSource->wLength;
	(*ppDest)->pTermCapArray =
		(PPCC_TERMCAP)MemAlloc(sizeof(PCC_TERMCAP) * pSource->wLength);
	if ((*ppDest)->pTermCapArray == NULL) {
		(*ppDest)->wLength = 0;
		DestroyH245TermCapList(ppDest);
		return CC_NO_MEMORY;
	}
	for (i = 0; i < pSource->wLength; i++) {
		status = H245CopyCap(&((*ppDest)->pTermCapArray[i]), pSource->pTermCapArray[i]);
		if (status != H245_ERROR_OK) {
			(*ppDest)->wLength = i;
			DestroyH245TermCapList(ppDest);
			return status;
		}
	}
	return CC_OK;
}



HRESULT CopyH245TermCapDescriptors(	PCC_TERMCAPDESCRIPTORS	*ppDest,
									PCC_TERMCAPDESCRIPTORS	pSource)
{
WORD		i;
HRESULT		status;

	ASSERT(ppDest != NULL);

    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }

	(*ppDest) = (PCC_TERMCAPDESCRIPTORS)MemAlloc(sizeof(CC_TERMCAPDESCRIPTORS));
	if (*ppDest == NULL)
		return CC_NO_MEMORY;

	(*ppDest)->wLength = pSource->wLength;
	(*ppDest)->pTermCapDescriptorArray = (H245_TOTCAPDESC_T **)MemAlloc(sizeof(H245_TOTCAPDESC_T *) *
			                                                pSource->wLength);
	if ((*ppDest)->pTermCapDescriptorArray == NULL) {
		(*ppDest)->wLength = 0;
		DestroyH245TermCapDescriptors(ppDest);
		return CC_NO_MEMORY;
	}

	for (i = 0; i < pSource->wLength; i++) {
		status = H245CopyCapDescriptor(&((*ppDest)->pTermCapDescriptorArray[i]),
									   pSource->pTermCapDescriptorArray[i]);
		if (status != H245_ERROR_OK) {
			(*ppDest)->wLength = i;
			DestroyH245TermCapDescriptors(ppDest);
			return status;	
		}
	}
	return CC_OK;
}



HRESULT CreateH245DefaultTermCapDescriptors(
									PCC_TERMCAPDESCRIPTORS	*ppDest,
									PCC_TERMCAPLIST			pTermCapList)
{
H245_TOTCAPDESC_T	TermCapDescriptor;
WORD				i;
HRESULT				status;

	ASSERT(ppDest != NULL);

	if (pTermCapList == NULL) {
		*ppDest = NULL;
        return CC_OK;
    }

	*ppDest = (PCC_TERMCAPDESCRIPTORS)MemAlloc(sizeof(CC_TERMCAPDESCRIPTORS));
	if (*ppDest == NULL)
		return CC_NO_MEMORY;

	if (pTermCapList->wLength == 0) {
		(*ppDest)->wLength = 0;
		(*ppDest)->pTermCapDescriptorArray = NULL;
		return CC_OK;
	}

	(*ppDest)->wLength = 1;
	(*ppDest)->pTermCapDescriptorArray = (H245_TOTCAPDESC_T **)MemAlloc(sizeof(H245_TOTCAPDESC_T *));
	if ((*ppDest)->pTermCapDescriptorArray == NULL) {
		(*ppDest)->wLength = 0;
		DestroyH245TermCapDescriptors(ppDest);
		return CC_NO_MEMORY;
	}

	TermCapDescriptor.CapDesc.Length = pTermCapList->wLength;
	TermCapDescriptor.CapDescId = 0;

	for (i = 0; i < pTermCapList->wLength; i++) {
		TermCapDescriptor.CapDesc.SimCapArray[i].Length = 1;
		TermCapDescriptor.CapDesc.SimCapArray[i].AltCaps[0] =
			pTermCapList->pTermCapArray[i]->CapId;
	}

	status = H245CopyCapDescriptor(&((*ppDest)->pTermCapDescriptorArray[0]),
								   &TermCapDescriptor);
	if (status != H245_ERROR_OK) {
		(*ppDest)->wLength = 0;
		DestroyH245TermCapDescriptors(ppDest);
		return status;	
	}
	return CC_OK;
}



HRESULT DestroyH245TermCap(			PPCC_TERMCAP			ppTermCap)
{
	ASSERT(ppTermCap != NULL);

	if (*ppTermCap == NULL)
		return CC_OK;

	H245FreeCap(*ppTermCap);
	*ppTermCap = NULL;
	return CC_OK;
}



HRESULT UnregisterTermCapListFromH245(
									PCONFERENCE				pConference,
									PCC_TERMCAPLIST			pTermCapList)
{
WORD		i, j;
PCALL		pCall;
PCC_HCALL	CallList;
WORD		wNumCalls;
HRESULT		status;
HRESULT		SaveStatus;

	ASSERT(pConference != NULL);

	if (pTermCapList == NULL)
		return CC_OK;

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);

	SaveStatus = CC_OK;
	for (i = 0; i < pTermCapList->wLength; i++) {
		ASSERT(pTermCapList->pTermCapArray[i] != NULL);
		for (j = 0; j < wNumCalls; j++) {
			if (LockCall(CallList[j], &pCall) == CC_OK) {
				status = H245DelLocalCap(pCall->H245Instance,
								         pTermCapList->pTermCapArray[i]->CapId);
				if (status != CC_OK)
					SaveStatus = status;
				UnlockCall(pCall);
			}
		}
	}
	if (CallList != NULL)
		MemFree(CallList);
	return SaveStatus;
}



HRESULT DestroyH245TermCapList(		PCC_TERMCAPLIST			*ppTermCapList)
{
WORD		i;

	ASSERT(ppTermCapList != NULL);

	if (*ppTermCapList == NULL)
		return CC_OK;

	for (i = 0; i < (*ppTermCapList)->wLength; i++) {
		ASSERT((*ppTermCapList)->pTermCapArray[i] != NULL);
	H245FreeCap((*ppTermCapList)->pTermCapArray[i]);
	}
	if ((*ppTermCapList)->pTermCapArray != NULL)
		MemFree((*ppTermCapList)->pTermCapArray);
	MemFree(*ppTermCapList);
	*ppTermCapList = NULL;
	return CC_OK;
}



HRESULT UnregisterTermCapDescriptorsFromH245(
									PCONFERENCE				pConference,
									PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors)
{
WORD		i, j;
PCALL		pCall;
PCC_HCALL	CallList;
WORD		wNumCalls;
HRESULT		status;
HRESULT		SaveStatus;

	ASSERT(pConference != NULL);

	if (pTermCapDescriptors == NULL)
		return CC_OK;

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);

	SaveStatus = CC_OK;
	for (i = 0; i < pTermCapDescriptors->wLength; i++) {
		ASSERT(pTermCapDescriptors->pTermCapDescriptorArray[i] != NULL);
		for (j = 0; j < wNumCalls; j++) {
			if (LockCall(CallList[j], &pCall) == CC_OK) {
				status = H245DelCapDescriptor(pCall->H245Instance,
									          pTermCapDescriptors->pTermCapDescriptorArray[i]->CapDescId);
				if (status != CC_OK)
					SaveStatus = status;
				UnlockCall(pCall);
			}
		}
	}
	if (CallList != NULL)
		MemFree(CallList);
	return SaveStatus;
}



HRESULT DestroyH245TermCapDescriptors(	PCC_TERMCAPDESCRIPTORS	*ppTermCapDescriptors)
{
WORD				i;

	ASSERT(ppTermCapDescriptors != NULL);

	if (*ppTermCapDescriptors == NULL)
		return CC_OK;

	for (i = 0; i < (*ppTermCapDescriptors)->wLength; i++) {
		ASSERT((*ppTermCapDescriptors)->pTermCapDescriptorArray[i] != NULL);
		H245FreeCapDescriptor((*ppTermCapDescriptors)->pTermCapDescriptorArray[i]);
	}
	if ((*ppTermCapDescriptors)->pTermCapDescriptorArray != NULL)
		MemFree((*ppTermCapDescriptors)->pTermCapDescriptorArray);
	MemFree(*ppTermCapDescriptors);
	*ppTermCapDescriptors = NULL;
	return CC_OK;
}



HRESULT HostToH245IPNetwork(		BYTE					*NetworkArray,
									DWORD					dwAddr)
{
	if (NetworkArray == NULL) {
		ASSERT(0);
		return CC_BAD_PARAM;
	}

	NetworkArray[0] = HIBYTE(HIWORD(dwAddr));
	NetworkArray[1] = LOBYTE(HIWORD(dwAddr));
	NetworkArray[2] = HIBYTE(LOWORD(dwAddr));
	NetworkArray[3] = LOBYTE(LOWORD(dwAddr));

	return CC_OK;
}



HRESULT H245IPNetworkToHost(		DWORD					*pdwAddr,
									BYTE					*NetworkArray)
{
	if ((pdwAddr == NULL) || (NetworkArray == NULL)) {
		ASSERT(0);
		return CC_BAD_PARAM;
	}

	*pdwAddr = NetworkArray[0] * 0x01000000 +
		       NetworkArray[1] * 0x00010000 +
			   NetworkArray[2] * 0x00000100 +
			   NetworkArray[3] * 0x00000001;

	return CC_OK;
}



HRESULT ProcessRemoteHangup(		CC_HCALL				hCall,
									HQ931CALL				hQ931Initiator,
									BYTE					bHangupReason)
{
PCALL								pCall;
CC_HCONFERENCE						hConference;
PCONFERENCE							pConference;
HRESULT								status;
HQ931CALL							hQ931Call;
H245_INST_T							H245Instance;
PCHANNEL							pChannel;
WORD								wNumChannels;
PCC_HCHANNEL						ChannelList;
WORD								i;
WORD								wNumCalls;
PCC_HCALL							CallList;
PCALL								pOldCall;
CC_CONNECT_CALLBACK_PARAMS			ConnectCallbackParams;
CC_PEER_DROP_CALLBACK_PARAMS		PeerDropCallbackParams;
CC_PEER_CHANGE_CAP_CALLBACK_PARAMS	PeerChangeCapCallbackParams;
BOOL								bConferenceTermCapsChanged;
HRESULT								CallbackStatus;

	if (hCall == CC_INVALID_HANDLE)
		return CC_BAD_PARAM;

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		return CC_BAD_PARAM;

	hConference = pCall->hConference;
	hQ931Call = pCall->hQ931Call;
	H245Instance = pCall->H245Instance;
	PeerDropCallbackParams.hCall = pCall->hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		PeerDropCallbackParams.TerminalLabel.bMCUNumber = 255;
		PeerDropCallbackParams.TerminalLabel.bTerminalNumber = 255;
		PeerDropCallbackParams.pPeerTerminalID = NULL;
	} else {
		PeerDropCallbackParams.TerminalLabel = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
		if (pCall->pPeerParticipantInfo->TerminalIDState == TERMINAL_ID_VALID)
			PeerDropCallbackParams.pPeerTerminalID = &pCall->pPeerParticipantInfo->ParticipantInfo.TerminalID;
		else
			PeerDropCallbackParams.pPeerTerminalID = NULL;
	}

	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE))
		CreateConferenceTermCaps(pConference, &bConferenceTermCapsChanged);
	else
		bConferenceTermCapsChanged = FALSE;

	// Remove all TX, RX and PROXY channels associated with this call
	EnumerateChannelsInConference(&wNumChannels,
								  &ChannelList,
								  pConference,
								  TX_CHANNEL | RX_CHANNEL | PROXY_CHANNEL);
	for (i = 0; i < wNumChannels; i++) {
		if (LockChannel(ChannelList[i], &pChannel) == CC_OK) {
			if (pChannel->hCall == hCall)
				FreeChannel(pChannel);
			else
				UnlockChannel(pChannel);
		}
	}
	if (ChannelList != NULL)
		MemFree(ChannelList);

	switch (bHangupReason)
	{
	case CC_REJECT_NORMAL_CALL_CLEARING:
		CallbackStatus = CC_OK;
		break;
	case CC_REJECT_GATEKEEPER_TERMINATED:
		CallbackStatus = CC_GATEKEEPER_REFUSED;
		bHangupReason = CC_REJECT_NORMAL_CALL_CLEARING;
		break;
	default:
		CallbackStatus = CC_PEER_REJECT;
	} // switch

	if (pCall->CallType == THIRD_PARTY_INVITOR) {
		MarkCallForDeletion(pCall);

		ConnectCallbackParams.pNonStandardData = pCall->pPeerNonStandardData;
		ConnectCallbackParams.pszPeerDisplay = pCall->pszPeerDisplay;
		ConnectCallbackParams.bRejectReason = bHangupReason;
		ConnectCallbackParams.pTermCapList = pCall->pPeerH245TermCapList;
		ConnectCallbackParams.pH2250MuxCapability = pCall->pPeerH245H2250MuxCapability;
		ConnectCallbackParams.pTermCapDescriptors = pCall->pPeerH245TermCapDescriptors;
		ConnectCallbackParams.pLocalAddr = pCall->pQ931LocalConnectAddr;
 		if (pCall->pQ931DestinationAddr == NULL)
			ConnectCallbackParams.pPeerAddr = pCall->pQ931PeerConnectAddr;
		else
			ConnectCallbackParams.pPeerAddr = pCall->pQ931DestinationAddr;
		ConnectCallbackParams.pVendorInfo = pCall->pPeerVendorInfo;
		ConnectCallbackParams.bMultipointConference = TRUE;
		ConnectCallbackParams.pConferenceID = &pConference->ConferenceID;
		ConnectCallbackParams.pMCAddress = pConference->pMultipointControllerAddr;
		ConnectCallbackParams.pAlternateAddress = NULL;
		ConnectCallbackParams.dwUserToken = pCall->dwUserToken;
		InvokeUserConferenceCallback(pConference,
									 CC_CONNECT_INDICATION,
									 CallbackStatus,
									 &ConnectCallbackParams);
		// Need to validate the conference and call handles; the associated
		// objects may have been deleted during user callback on this thread
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		Q931Hangup(hQ931Call, bHangupReason);
		return CC_OK;
	}

	if (pCall->CallType == THIRD_PARTY_INTERMEDIARY) {
		if ((hQ931Initiator == pCall->hQ931CallInvitor) &&
		    (hQ931Initiator != CC_INVALID_HANDLE)) {
			pCall->hQ931CallInvitor = CC_INVALID_HANDLE;
			UnlockCall(pCall);
			UnlockConference(pConference);
			return CC_OK;
		} else {
			if (pCall->CallState != CALL_COMPLETE) {
				if (pCall->hQ931CallInvitor != CC_INVALID_HANDLE)
					Q931Hangup(pCall->hQ931CallInvitor, CC_REJECT_UNDEFINED_REASON);
				if (ValidateCall(hCall) == CC_OK)
					Q931Hangup(pCall->hQ931Call, bHangupReason);
			}
		}
	}

	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE)) {
		if (pCall->pPeerParticipantInfo != NULL) {
			EnumerateCallsInConference(&wNumCalls,
									   &CallList,
									   pConference,
									   ESTABLISHED_CALL);
			for (i = 0; i < wNumCalls; i++) {
				if (CallList[i] != hCall) {
					if (LockCall(CallList[i], &pOldCall) == CC_OK) {
						if (pCall->pPeerParticipantInfo != NULL)
							H245ConferenceIndication(
											 pOldCall->H245Instance,
											 H245_IND_TERMINAL_LEFT,	// Indication Type
											 0,							// SBE number; ignored here
											 pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,	// MCU number
											 pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber);
						if (bConferenceTermCapsChanged)
							// Send new term caps
							SendTermCaps(pOldCall, pConference);
						UnlockCall(pOldCall);
					}
				}
			}
			if (CallList != NULL)
				MemFree(CallList);
		}

		InvokeUserConferenceCallback(pConference,
						 CC_PEER_DROP_INDICATION,
						 CC_OK,
						 &PeerDropCallbackParams);
		
		if (ValidateCall(hCall) == CC_OK)
			FreeCall(pCall);

		if (ValidateConference(hConference) == CC_OK) {
			if (bConferenceTermCapsChanged) {
				// Generate CC_PEER_CHANGE_CAP callback
				PeerChangeCapCallbackParams.pTermCapList =
					pConference->pConferenceTermCapList;
				PeerChangeCapCallbackParams.pH2250MuxCapability =
					pConference->pConferenceH245H2250MuxCapability;
				PeerChangeCapCallbackParams.pTermCapDescriptors =
					pConference->pConferenceTermCapDescriptors;
				InvokeUserConferenceCallback(pConference,
											 CC_PEER_CHANGE_CAP_INDICATION,
											 CC_OK,
											 &PeerChangeCapCallbackParams);
			}
		}

		if (ValidateConference(hConference) == CC_OK) {
			if (pConference->bDeferredDelete) {
				ASSERT(pConference->LocalEndpointAttached == DETACHED);
				EnumerateCallsInConference(&wNumCalls, NULL, pConference, ALL_CALLS);
				if (wNumCalls == 0) {
					FreeConference(pConference);
					return CC_OK;
				}
			}
			UnlockConference(pConference);
		}
		return CC_OK;
	} else {
		status = EnumerateChannelsInConference(&wNumChannels,
			                                   &ChannelList,
											   pConference,
											   ALL_CHANNELS);
		if (status == CC_OK) {
			// free all the channels
			for (i = 0; i < wNumChannels; i++) {
				if (LockChannel(ChannelList[i], &pChannel) == CC_OK)
					// Notice that since we're going to hangup, we don't need to
					// close any channels
					FreeChannel(pChannel);	
			}
			if (ChannelList != NULL)
				MemFree(ChannelList);
		}

		if (H245Instance != H245_INVALID_ID)
			status = H245ShutDown(H245Instance);
		else
			status = H245_ERROR_OK;
	
		if (status == H245_ERROR_OK) {
			status = Q931Hangup(hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);
			// Q931Hangup may legitimately return CS_BAD_PARAM, because the Q.931 call object
			// may have been deleted at this point
			if (status == CS_BAD_PARAM)
				status = CC_OK;
		} else
			Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);

		if (pConference->bDeferredDelete) {
			ASSERT(pConference->LocalEndpointAttached == DETACHED);
			FreeConference(pConference);
		} else {
			ReInitializeConference(pConference);

			InvokeUserConferenceCallback(pConference,
										 CC_CONFERENCE_TERMINATION_INDICATION,
										 CallbackStatus,
										 NULL);

			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
		}
		return CC_OK;
	}
	// We should never reach this point
	ASSERT(0);
}



HRESULT DefaultSessionTableConstructor(
									CC_HCONFERENCE			hConference,
									DWORD_PTR				dwConferenceToken,
									BOOL					bCreate,
									BOOL					*pbSessionTableChanged,
									WORD					wListCount,
									PCC_TERMCAPLIST			pTermCapList[],
									PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors[],
									PCC_SESSIONTABLE		*ppSessionTable)
{
WORD			i;
HRESULT			status;
PCONFERENCE		pConference;
WORD			wNumChannels;
PCC_HCHANNEL	ChannelList;
PCHANNEL		pChannel;
WORD			wNumCalls;
PCC_HCALL		CallList;
PCALL			pCall;
BYTE			bSessionID;
WORD			wPort;
DWORD			dwAddr;
WCHAR			szSessionDescription[100];
WCHAR			ss[10];

	ASSERT(hConference != CC_INVALID_HANDLE);
	ASSERT(ppSessionTable != NULL);
	
	if (*ppSessionTable != NULL) {
		for (i = 0; i < (*ppSessionTable)->wLength; i++) {
			if ((*ppSessionTable)->SessionInfoArray[i].pTermCap != NULL)
				H245FreeCap((*ppSessionTable)->SessionInfoArray[i].pTermCap);
			FreeAddr((*ppSessionTable)->SessionInfoArray[i].pRTPAddr);
			FreeAddr((*ppSessionTable)->SessionInfoArray[i].pRTCPAddr);
		}
		if ((*ppSessionTable)->SessionInfoArray != NULL)
			MemFree((*ppSessionTable)->SessionInfoArray);
		MemFree(*ppSessionTable);
		*ppSessionTable = NULL;
	}

	if (bCreate == FALSE)
		return CC_OK;

	*ppSessionTable = NULL;
	if (pbSessionTableChanged != NULL)
		*pbSessionTableChanged = FALSE;

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		return status;

	if ((pConference->ConferenceMode == UNCONNECTED_MODE) ||
	    (pConference->ConferenceMode == POINT_TO_POINT_MODE)) {
		UnlockConference(pConference);
		return CC_BAD_PARAM;
	}

	// pConference->ConferenceMode == MULTIPOINT_MODE
	// Create one session entry for each open channel on this conference

	bSessionID = 1;
	wPort = 2050;

	// Set dwAddr
	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
	if (wNumCalls == 0) {
		UnlockConference(pConference);
		return CC_INTERNAL_ERROR;
	}

	status = LockCall(CallList[0], &pCall);
	if (status != CC_OK) {
		MemFree(CallList);
		UnlockConference(pConference);
		return status;
	}

	if (pCall->pQ931LocalConnectAddr == NULL) {
		MemFree(CallList);
		UnlockCall(pCall);
		UnlockConference(pConference);
		return CC_INTERNAL_ERROR;
	}

	if (pCall->pQ931LocalConnectAddr->nAddrType != CC_IP_BINARY) {
		MemFree(CallList);
		UnlockCall(pCall);
		UnlockConference(pConference);
		return CC_INTERNAL_ERROR;
	}

	// Construct dwAddr from one of the unicast Q.931 addresses by setting the high
	// nibble of the Q.931 address to 0xE
	dwAddr = (pCall->pQ931LocalConnectAddr->Addr.IP_Binary.dwAddr & 0xEFFFFFFF) | 0xE0000000;

	UnlockCall(pCall);
	MemFree(CallList);
	
	EnumerateChannelsInConference(&wNumChannels, &ChannelList, pConference, TX_CHANNEL);
	
	*ppSessionTable = (PCC_SESSIONTABLE)MemAlloc(sizeof(CC_SESSIONTABLE));
	if (*ppSessionTable == NULL) {
		MemFree(ChannelList);
		UnlockConference(pConference);
		return CC_NO_MEMORY;
	}
	(*ppSessionTable)->wLength = wNumChannels;
	if (wNumChannels == 0)
		(*ppSessionTable)->SessionInfoArray = NULL;
	else {
		(*ppSessionTable)->SessionInfoArray =
			(PCC_SESSIONINFO)MemAlloc(sizeof(CC_SESSIONINFO) * wNumChannels);
		if ((*ppSessionTable)->SessionInfoArray == NULL) {
			MemFree(ChannelList);
			UnlockConference(pConference);
			(*ppSessionTable)->wLength = 0;
			DefaultSessionTableConstructor(
								hConference,
								dwConferenceToken,
								FALSE,	// bCreate,
								NULL,	// pbSessionTableChanged,
								0,		// wListCount,
								NULL,	// pTermCapList[],
								NULL,	// pTermCapDescriptors[],
								ppSessionTable);
			return CC_NO_MEMORY;
		}
		for (i = 0; i < wNumChannels; i++) {
			(*ppSessionTable)->SessionInfoArray[i].bSessionID = bSessionID++;

			(*ppSessionTable)->SessionInfoArray[i].bAssociatedSessionID = 0;

			wcscpy(szSessionDescription, L"Session ");
			_itow((int)(*ppSessionTable)->SessionInfoArray[i].bSessionID,
				  ss, 10);
			wcscat(szSessionDescription, ss);
	
			(*ppSessionTable)->SessionInfoArray[i].SessionDescription.wOctetStringLength =
				(WORD)((wcslen(szSessionDescription)+1)*sizeof(WCHAR));
			(*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString =
				(BYTE *)MemAlloc((*ppSessionTable)->SessionInfoArray[i].SessionDescription.wOctetStringLength);
			if ((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString == NULL) {
				MemFree(ChannelList);
				UnlockConference(pConference);
				(*ppSessionTable)->wLength = i;
				DefaultSessionTableConstructor(
								hConference,
								dwConferenceToken,
								FALSE,	// bCreate,
								NULL,	// pbSessionTableChanged,
								0,		// wListCount,
								NULL,	// pTermCapList[],
								NULL,	// pTermCapDescriptors[],
								ppSessionTable);
				return CC_NO_MEMORY;
			}
			memcpy((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString,
				    szSessionDescription,
					(*ppSessionTable)->SessionInfoArray[i].SessionDescription.wOctetStringLength);
			
			status = LockChannel(ChannelList[i], &pChannel);
			if (status != CC_OK) {
				MemFree((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString);
				MemFree(ChannelList);
				UnlockConference(pConference);
				(*ppSessionTable)->wLength = i;
				DefaultSessionTableConstructor(
								hConference,
								dwConferenceToken,
								FALSE,	// bCreate,
								NULL,	// pbSessionTableChanged,
								0,		// wListCount,
								NULL,	// pTermCapList[],
								NULL,	// pTermCapDescriptors[],
								ppSessionTable);
				return CC_NO_MEMORY;
			}
			status = H245CopyCap(&(*ppSessionTable)->SessionInfoArray[i].pTermCap,
				                 pChannel->pTxH245TermCap);
			UnlockChannel(pChannel);
			if (status != H245_ERROR_OK) {
				MemFree((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString);
				MemFree(ChannelList);
				UnlockConference(pConference);
				(*ppSessionTable)->wLength = i;
				DefaultSessionTableConstructor(
								hConference,
								dwConferenceToken,
								FALSE,	// bCreate,
								NULL,	// pbSessionTableChanged,
								0,		// wListCount,
								NULL,	// pTermCapList[],
								NULL,	// pTermCapDescriptors[],
								ppSessionTable);
				return status;
			}
			
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr =
				(PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
			if ((*ppSessionTable)->SessionInfoArray[i].pRTPAddr == NULL) {
				H245FreeCap((*ppSessionTable)->SessionInfoArray[i].pTermCap);
				MemFree((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString);
				MemFree(ChannelList);
				UnlockConference(pConference);
				(*ppSessionTable)->wLength = i;
				DefaultSessionTableConstructor(
								hConference,
								dwConferenceToken,
								FALSE,	// bCreate,
								NULL,	// pbSessionTableChanged,
								0,		// wListCount,
								NULL,	// pTermCapList[],
								NULL,	// pTermCapDescriptors[],
								ppSessionTable);
				return CC_NO_MEMORY;
			}
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->nAddrType = CC_IP_BINARY;
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->bMulticast = TRUE;
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->Addr.IP_Binary.wPort = wPort++;
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->Addr.IP_Binary.dwAddr = dwAddr;
			
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr =
				(PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
			if ((*ppSessionTable)->SessionInfoArray[i].pRTCPAddr == NULL) {
				H245FreeCap((*ppSessionTable)->SessionInfoArray[i].pTermCap);
				FreeAddr((*ppSessionTable)->SessionInfoArray[i].pRTPAddr);
				MemFree((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString);
				MemFree(ChannelList);
				UnlockConference(pConference);
				(*ppSessionTable)->wLength = i;
				DefaultSessionTableConstructor(
								hConference,
								dwConferenceToken,
								FALSE,	// bCreate,
								NULL,	// pbSessionTableChanged,
								0,		// wListCount,
								NULL,	// pTermCapList[],
								NULL,	// pTermCapDescriptors[],
								ppSessionTable);
				return CC_NO_MEMORY;
			}
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->nAddrType = CC_IP_BINARY;
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->bMulticast = TRUE;
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->Addr.IP_Binary.wPort = wPort++;
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->Addr.IP_Binary.dwAddr = dwAddr;
		}
	}

	MemFree(ChannelList);
	UnlockConference(pConference);
	if (pbSessionTableChanged != NULL)
		*pbSessionTableChanged = TRUE;

	return CC_OK;
}



HRESULT DefaultTermCapConstructor(	CC_HCONFERENCE					hConference,
									DWORD_PTR						dwConferenceToken,
									BOOL							bCreate,
									BOOL							*pbTermCapsChanged,
									WORD							wListCount,
									PCC_TERMCAPLIST					pInTermCapList[],
									PCC_TERMCAPDESCRIPTORS			pInTermCapDescriptors[],
									PCC_TERMCAPLIST					*ppOutTermCapList,
									PCC_TERMCAPDESCRIPTORS			*ppOutTermCapDescriptors)
{
HRESULT				status;
PCONFERENCE			pConference;
WORD				wNumChannels;
PCC_HCHANNEL		ChannelList;
WORD				i;
PCHANNEL			pChannel;

	ASSERT(hConference != CC_INVALID_HANDLE);
	ASSERT(ppOutTermCapList != NULL);
	ASSERT(ppOutTermCapDescriptors != NULL);
	
	if (*ppOutTermCapList != NULL) {
		DestroyH245TermCapList(ppOutTermCapList);
		*ppOutTermCapList = NULL;
	}

	if (*ppOutTermCapDescriptors != NULL) {
		DestroyH245TermCapDescriptors(ppOutTermCapDescriptors);
		*ppOutTermCapDescriptors = NULL;
	}
	
	if (bCreate == FALSE)
		return CC_OK;

	*ppOutTermCapList = NULL;
	*ppOutTermCapDescriptors = NULL;
	if (pbTermCapsChanged != NULL)
		*pbTermCapsChanged = FALSE;

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		return status;

	if (pConference->LocalEndpointAttached == NEVER_ATTACHED) {
		// Copy the local term caps to the conference term caps
		status = CopyH245TermCapList(ppOutTermCapList, pConference->pLocalH245TermCapList);
		if (status != CC_OK) {
			UnlockConference(pConference);
			return CC_NO_MEMORY;
		}

		// Copy the local term cap descriptors to the conference term cap descriptors
		status = CopyH245TermCapDescriptors(ppOutTermCapDescriptors, pConference->pLocalH245TermCapDescriptors);
		if (status != CC_OK) {
			UnlockConference(pConference);
			return CC_NO_MEMORY;
		}
	} else { // pConference->LocalEndpointAttached != NEVER_ATTACHED
		// Create one term cap entry for each open channel on this conference
		
		EnumerateChannelsInConference(&wNumChannels, &ChannelList, pConference, TX_CHANNEL);

		*ppOutTermCapList = (PCC_TERMCAPLIST)MemAlloc(sizeof(CC_TERMCAPLIST));
		if (*ppOutTermCapList == NULL) {
			MemFree(ChannelList);
			UnlockConference(pConference);
			return CC_NO_MEMORY;
		}
		(*ppOutTermCapList)->wLength = wNumChannels;
		if (wNumChannels == 0)
			(*ppOutTermCapList)->pTermCapArray = NULL;
		else {
			(*ppOutTermCapList)->pTermCapArray =
				(PPCC_TERMCAP)MemAlloc(sizeof(PCC_TERMCAP) * wNumChannels);
			if ((*ppOutTermCapList)->pTermCapArray == NULL) {
				MemFree(ChannelList);
				UnlockConference(pConference);
				(*ppOutTermCapList)->wLength = 0;
				DefaultTermCapConstructor(
										hConference,
										dwConferenceToken,
										FALSE,		// bCreate
										NULL,		// pbTermCapsChanged
										0,			// wListCount
										NULL,		// pInTermCapList[]
										NULL,		// pInTermCapDescriptors[]
										ppOutTermCapList,
										ppOutTermCapDescriptors);
				return CC_NO_MEMORY;
			}
			for (i = 0; i < wNumChannels; i++) {
				status = LockChannel(ChannelList[i], &pChannel);
				if (status != CC_OK) {
					MemFree(ChannelList);
					UnlockConference(pConference);
					(*ppOutTermCapList)->wLength = i;
					DefaultTermCapConstructor(
										hConference,
										dwConferenceToken,
										FALSE,		// bCreate
										NULL,		// pbTermCapsChanged
										0,			// wListCount
										NULL,		// pInTermCapList[]
										NULL,		// pInTermCapDescriptors[]
										ppOutTermCapList,
										ppOutTermCapDescriptors);
					return CC_NO_MEMORY;
				}
				status = H245CopyCap(&((*ppOutTermCapList)->pTermCapArray[i]),
									 pChannel->pTxH245TermCap);
				UnlockChannel(pChannel);
				if (status != H245_ERROR_OK) {
					MemFree(ChannelList);
					UnlockConference(pConference);
					(*ppOutTermCapList)->wLength = i;
					DefaultTermCapConstructor(
										hConference,
										dwConferenceToken,
										FALSE,		// bCreate
										NULL,		// pbTermCapsChanged
										0,			// wListCount
										NULL,		// pInTermCapList[]
										NULL,		// pInTermCapDescriptors[]
										ppOutTermCapList,
										ppOutTermCapDescriptors);
					return status;
				}

				(*ppOutTermCapList)->pTermCapArray[i]->Dir = H245_CAPDIR_LCLRXTX;
				(*ppOutTermCapList)->pTermCapArray[i]->CapId = (WORD)(i+1);
			}
		}

		MemFree(ChannelList);
		UnlockConference(pConference);

		// create a new descriptor list
		status = CreateH245DefaultTermCapDescriptors(ppOutTermCapDescriptors,
													 *ppOutTermCapList);
		if (status != CC_OK) {
			DefaultTermCapConstructor(
							hConference,
							dwConferenceToken,
							FALSE,		// bCreate
							NULL,		// pbTermCapsChanged
							0,			// wListCount
							NULL,		// pInTermCapList[]
							NULL,		// pInTermCapDescriptors[]
							ppOutTermCapList,
							ppOutTermCapDescriptors);
			return CC_NO_MEMORY;
		}
	}  // pConference->LocalEndpointAttached != NEVER_ATTACHED

	if (pbTermCapsChanged != NULL)
		*pbTermCapsChanged = TRUE;

	return CC_OK;
}



HRESULT AcceptCall(					PCALL					pCall,
									PCONFERENCE				pConference)
{
HRESULT				status;
CC_HCALL			hCall;
CC_HCONFERENCE		hConference;
HQ931CALL			hQ931Call;
CC_CONFERENCEID		ConferenceID;
BYTE				bTerminalType;
CC_ADDR				H245Addr;
H245_INST_T			H245Instance;
PCC_VENDORINFO		pVendorInfo;
PCC_NONSTANDARDDATA	pNonStandardData;
PWSTR				pszDisplay;
CC_ENDPOINTTYPE		DestinationEndpointType;
TRISTATE			tsMultipointController;
DWORD               dwLinkLayerPhysicalId;

	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);

	hCall = pCall->hCall;
	hConference = pConference->hConference;
	hQ931Call = pCall->hQ931Call;
	ConferenceID = pCall->ConferenceID;
	pCall->hConference = pConference->hConference;

	status = CopyNonStandardData(&pNonStandardData, pCall->pLocalNonStandardData);
	if (status != CC_OK) {
		UnlockConference(pConference);
		FreeCall(pCall);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		return status;
	}

	status = CopyVendorInfo(&pVendorInfo, pConference->pVendorInfo);
	if (status != CC_OK) {
		UnlockConference(pConference);
		FreeCall(pCall);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		FreeNonStandardData(pNonStandardData);
		return status;
	}

	status = CopyDisplay(&pszDisplay, pCall->pszLocalDisplay);
	if (status != CC_OK) {
		UnlockConference(pConference);
		FreeCall(pCall);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		FreeNonStandardData(pNonStandardData);
		FreeVendorInfo(pVendorInfo);
		return status;
	}

	status = MakeH245PhysicalID(&pCall->dwH245PhysicalID);
	if (status != CC_OK) {
		UnlockConference(pConference);
		FreeCall(pCall);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		FreeNonStandardData(pNonStandardData);
		FreeVendorInfo(pVendorInfo);
		FreeDisplay(pszDisplay);
		return status;
	}

	if (pCall->bCallerIsMC) {
		ASSERT(pConference->tsMultipointController != TS_TRUE);
		ASSERT(pConference->bMultipointCapable == TRUE);
		tsMultipointController = TS_FALSE;
	} else
		tsMultipointController = pConference->tsMultipointController;

    //MULTITHREAD
    //Use a tmp ID so we don't clobber the chosen H245Id.
    //   H245Id=>
    //   <= linkLayerId
    dwLinkLayerPhysicalId = INVALID_PHYS_ID;

	SetTerminalType(tsMultipointController, &bTerminalType);
	pCall->H245Instance = H245Init(H245_CONF_H323,			// configuration
                                   pCall->dwH245PhysicalID,    // H245 physical ID
                                   &dwLinkLayerPhysicalId,     // the link layer ID is returned
								   hCall,					// dwPreserved
								   (H245_CONF_IND_CALLBACK_T)H245Callback, // callback
								   bTerminalType);			
	if (pCall->H245Instance == H245_INVALID_ID) {
		// H245 initialization failure
		UnlockConference(pConference);
		FreeCall(pCall);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		FreeNonStandardData(pNonStandardData);
		FreeVendorInfo(pVendorInfo);
		FreeDisplay(pszDisplay);
		return CC_INTERNAL_ERROR;
	}

	H245Instance = pCall->H245Instance;

	// Set the H.245 TCP/IP address to the same IP address on which
	// the Q.931 connection was made; this ensures that if the host
	// is multi-homed, the H.245 will be made on the same IP address
	// as the Q.931 connection.  Set the initial H.245 port to zero,
	// so that it will be dynamically determined.
	ASSERT(pCall->pQ931LocalConnectAddr != NULL);
	H245Addr = *pCall->pQ931LocalConnectAddr;

	switch (pCall->pQ931LocalConnectAddr->nAddrType) {
		case CC_IP_DOMAIN_NAME:
			H245Addr.Addr.IP_DomainName.wPort = 0;
			break;
		case CC_IP_DOT:
			H245Addr.Addr.IP_Dot.wPort = 0;
			break;
		case CC_IP_BINARY:
			H245Addr.Addr.IP_Binary.wPort = 0;
			break;
		default:
			ASSERT(0);
			UnlockConference(pConference);
			FreeCall(pCall);
			H245ShutDown(H245Instance);
			Q931RejectCall(hQ931Call,				// Q931 call handle
						   CC_REJECT_UNDEFINED_REASON,	// reject reason
						   &ConferenceID,
						   NULL,					// alternate address
						   pNonStandardData);		// non-standard data
			FreeNonStandardData(pNonStandardData);
			FreeVendorInfo(pVendorInfo);
			FreeDisplay(pszDisplay);
			return CC_INTERNAL_ERROR;
	}

    status = linkLayerListen(&dwLinkLayerPhysicalId,
							 H245Instance,
							 &H245Addr,
							 NULL);
	if (status != NOERROR) {
		UnlockConference(pConference);
		FreeCall(pCall);
		H245ShutDown(H245Instance);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		FreeNonStandardData(pNonStandardData);
		FreeVendorInfo(pVendorInfo);
		FreeDisplay(pszDisplay);
		return status;
	}

	UnlockConference(pConference);
	UnlockCall(pCall);

	DestinationEndpointType.pVendorInfo = pVendorInfo;
	DestinationEndpointType.bIsTerminal = TRUE;
	DestinationEndpointType.bIsGateway = FALSE;

	status = Q931AcceptCall(hQ931Call,
							pszDisplay,
							pNonStandardData,	// non-standard data
							&DestinationEndpointType,
							&H245Addr,		// H245 address
							hCall);			// user token
	FreeNonStandardData(pNonStandardData);
	FreeVendorInfo(pVendorInfo);
	FreeDisplay(pszDisplay);
	if (status != CS_OK) {
		if (LockCall(hCall, &pCall) == CC_OK)
			FreeCall(pCall);
		H245ShutDown(H245Instance);
		return status;
	}
	
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		if (LockCall(hCall, &pCall) == CC_OK)
			FreeCall(pCall);
		H245ShutDown(H245Instance);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		return status;
	}

	pCall->CallState = TERMCAP;
	pConference->ConferenceID = pCall->ConferenceID;

	status = AddPlacedCallToConference(pCall, pConference);
	if (status != CC_OK) {
		UnlockConference(pConference);
		FreeCall(pCall);
		H245ShutDown(H245Instance);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		return status;
	}

	status = SendTermCaps(pCall, pConference);
	if (status != CC_OK) {
		UnlockConference(pConference);
		FreeCall(pCall);
		H245ShutDown(H245Instance);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		return status;
	}
	
	pCall->OutgoingTermCapState = AWAITING_ACK;

	if (pCall->MasterSlaveState == MASTER_SLAVE_NOT_STARTED) {
		status = H245InitMasterSlave(H245Instance,
			                         H245Instance);	// returned as dwTransId in the callback
		if (status != H245_ERROR_OK) {
			UnlockConference(pConference);
			FreeCall(pCall);
			H245ShutDown(H245Instance);
			Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
			return status;
		}
		pCall->MasterSlaveState = MASTER_SLAVE_IN_PROGRESS;
	}

	if (pCall->bCallerIsMC) {
		pConference->tsMultipointController = TS_FALSE;
		pConference->ConferenceMode = MULTIPOINT_MODE;
	}

	UnlockConference(pConference);
	UnlockCall(pCall);
	return CC_OK;
}



HRESULT PlaceCall(					PCALL					pCall,
									PCONFERENCE				pConference)
{
CC_HCALL			hCall;
HRESULT				status;
WORD				wGoal;
HQ931CALL			hQ931Call;
PCC_ALIASNAMES		pCallerAliasNames;
PCC_ALIASNAMES		pCalleeAliasNames;
PCC_ALIASNAMES		pCalleeExtraAliasNames;
PCC_ALIASITEM		pCalleeExtension;
PCC_VENDORINFO		pVendorInfo;
PWSTR				pszDisplay;
PCC_NONSTANDARDDATA	pNonStandardData;
WORD				wNumCalls;
PCC_ADDR			pConnectAddr;
PCC_ADDR			pDestinationAddr;
CC_ADDR				SourceAddr;
CC_ENDPOINTTYPE		SourceEndpointType;
BOOL				bCallerIsMC;
WORD				wCallType;

	ASSERT(pCall != NULL);

	hCall = pCall->hCall;

	if (pCall->CallState == ENQUEUED) {
		// Enqueue the call on the conference object and HResultLeaveCallControl.
		// There will be exactly one placed call for this conference,
		// which is in the process of being placed.  If this call placement
		// completes successfully, all enqueued calls will then be placed.
		// If this call placement fails or is terminated, one enqueued call
		// will be placed
		status = AddEnqueuedCallToConference(pCall, pConference);
		return status;
	}
	
	// CallState == PLACED
	EnumerateCallsInConference(&wNumCalls,
		                       NULL,
		                       pConference,
							   PLACED_CALL | ESTABLISHED_CALL);
	if (EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID))
		wGoal = CSG_CREATE;
	else if ((wNumCalls == 0) && (pConference->tsMultipointController != TS_TRUE))
		wGoal = CSG_JOIN;
	else
		wGoal = CSG_INVITE;

	status = AddPlacedCallToConference(pCall, pConference);
	if (status != CC_OK)
		return status;

	status = CopyAddr(&pConnectAddr, pCall->pQ931PeerConnectAddr);
	if (status != CC_OK)
		return status;
	
	status = CopyAddr(&pDestinationAddr, pCall->pQ931DestinationAddr);
	if (status != CC_OK) {
		FreeAddr(pConnectAddr);
		return status;
	}

	status = Q931CopyAliasNames(&pCallerAliasNames, pCall->pLocalAliasNames);
	if (status != CS_OK) {
		FreeAddr(pConnectAddr);
		FreeAddr(pDestinationAddr);
		return status;
	}

	status = CopyVendorInfo(&pVendorInfo, pConference->pVendorInfo);
	if (status != CC_OK) {
		FreeAddr(pConnectAddr);
		FreeAddr(pDestinationAddr);
		Q931FreeAliasNames(pCallerAliasNames);
		return status;
	}
	
	status = CopyDisplay(&pszDisplay, pCall->pszLocalDisplay);
	if (status != CC_OK) {
		FreeAddr(pConnectAddr);
		FreeAddr(pDestinationAddr);
		Q931FreeAliasNames(pCallerAliasNames);
		FreeVendorInfo(pVendorInfo);
		return status;
	}
	
	status = Q931CopyAliasNames(&pCalleeAliasNames, pCall->pPeerAliasNames);
	if (status != CS_OK) {
		FreeAddr(pConnectAddr);
		FreeAddr(pDestinationAddr);
		Q931FreeAliasNames(pCallerAliasNames);
		FreeVendorInfo(pVendorInfo);
		FreeDisplay(pszDisplay);
		return status;
	}
	
	status = Q931CopyAliasNames(&pCalleeExtraAliasNames,
							    pCall->pPeerExtraAliasNames);
	if (status != CS_OK) {
		FreeAddr(pConnectAddr);
		FreeAddr(pDestinationAddr);
		Q931FreeAliasNames(pCallerAliasNames);
		FreeVendorInfo(pVendorInfo);
		FreeDisplay(pszDisplay);
		Q931FreeAliasNames(pCalleeAliasNames);
		return status;
	}

	status = Q931CopyAliasItem(&pCalleeExtension,
							   pCall->pPeerExtension);
	if (status != CS_OK) {
		FreeAddr(pConnectAddr);
		FreeAddr(pDestinationAddr);
		Q931FreeAliasNames(pCallerAliasNames);
		FreeVendorInfo(pVendorInfo);
		FreeDisplay(pszDisplay);
		Q931FreeAliasNames(pCalleeAliasNames);
		Q931FreeAliasNames(pCalleeExtraAliasNames);
		return status;
	}

	status = CopyNonStandardData(&pNonStandardData, pCall->pLocalNonStandardData);
	if (status != CC_OK) {
		FreeAddr(pConnectAddr);
		FreeAddr(pDestinationAddr);
		Q931FreeAliasNames(pCallerAliasNames);
		FreeVendorInfo(pVendorInfo);
		FreeDisplay(pszDisplay);
		Q931FreeAliasNames(pCalleeAliasNames);
		Q931FreeAliasNames(pCalleeExtraAliasNames);
		Q931FreeAliasItem(pCalleeExtension);
		return status;
	}

	bCallerIsMC = (pConference->tsMultipointController == TS_TRUE ? TRUE : FALSE);
	// Note that if pConference->ConferenceMode == POINT_TO_POINT_MODE, this call attempt
	// will result in a multipoint call if successful, so set the wCallType accordingly
	wCallType = (WORD)((pConference->ConferenceMode == UNCONNECTED_MODE) ? CC_CALLTYPE_PT_PT : CC_CALLTYPE_N_N);

	SourceEndpointType.pVendorInfo = pVendorInfo;
	SourceEndpointType.bIsTerminal = TRUE;
	SourceEndpointType.bIsGateway = FALSE;

	// Cause our local Q.931 connect address to be placed in the
	// Q.931 setup-UUIE sourceAddress field
	SourceAddr.nAddrType = CC_IP_BINARY;
	SourceAddr.bMulticast = FALSE;
	SourceAddr.Addr.IP_Binary.dwAddr = 0;
	SourceAddr.Addr.IP_Binary.wPort = 0;

	status = Q931PlaceCall(&hQ931Call,				// Q931 call handle
		                   pszDisplay,
	                       pCallerAliasNames,
						   pCalleeAliasNames,
                           pCalleeExtraAliasNames,	// pCalleeExtraAliasNames
                           pCalleeExtension,		// pCalleeExtension
		                   pNonStandardData,		// non-standard data
						   &SourceEndpointType,
                           NULL, // pszCalledPartyNumber
						   pConnectAddr,
						   pDestinationAddr,
						   &SourceAddr,				// source address
						   bCallerIsMC,
						   &pCall->ConferenceID,	// conference ID
						   wGoal,
						   wCallType,
						   hCall,					// user token
						   (Q931_CALLBACK)Q931Callback, 	// callback
#ifdef GATEKEEPER
                           pCall->GkiCall.usCRV,        // CRV
                           &pCall->CallIdentifier);     // H.225 CallIdentifier
#else
                           0,                           // CRV
                           &pCall->CallIdentifier);     // H.225 CallIdentifier

#endif GATEKEEPER
	FreeAddr(pConnectAddr);
	FreeAddr(pDestinationAddr);
	Q931FreeAliasNames(pCallerAliasNames);
	FreeVendorInfo(pVendorInfo);
	FreeDisplay(pszDisplay);
	Q931FreeAliasNames(pCalleeAliasNames);
	Q931FreeAliasNames(pCalleeExtraAliasNames);
	Q931FreeAliasItem(pCalleeExtension);
	FreeNonStandardData(pNonStandardData);
	if (status != CS_OK)
		return status;
	
	pCall->hQ931Call = hQ931Call;
	return CC_OK;
}



HRESULT SendTermCaps(				PCALL					pCall,
									PCONFERENCE				pConference)
{
HRESULT					status;
WORD					i;
H245_TOTCAPDESC_T		*pTermCapDescriptor;
PCC_TERMCAP				pH2250MuxCapability;
PCC_TERMCAPLIST			pTermCapList;
PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors;

	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);

	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE)) {
		pH2250MuxCapability = pConference->pConferenceH245H2250MuxCapability;
		pTermCapList = pConference->pConferenceTermCapList;
		pTermCapDescriptors = pConference->pConferenceTermCapDescriptors;
	} else {
		pH2250MuxCapability = pConference->pLocalH245H2250MuxCapability;
		pTermCapList = pConference->pLocalH245TermCapList;
		pTermCapDescriptors = pConference->pLocalH245TermCapDescriptors;
	}

	ASSERT(pH2250MuxCapability != NULL);
	ASSERT(pTermCapList != NULL);
	ASSERT(pTermCapDescriptors != NULL);

	// First send out the H.225.0 capability
	status = H245SetLocalCap(pCall->H245Instance,
							 pH2250MuxCapability,
							 &pH2250MuxCapability->CapId);
	ASSERT(pH2250MuxCapability->CapId == 0);
	if (status != H245_ERROR_OK)
		return status;

	// Now send out the terminal capabilities
	for (i = 0; i < pTermCapList->wLength; i++) {
		status = H245SetLocalCap(pCall->H245Instance,
		                         pTermCapList->pTermCapArray[i],
							     &pTermCapList->pTermCapArray[i]->CapId);
		if (status != H245_ERROR_OK)
			return status;
	}

	// Finally send out the capability descriptors
	for (i = 0; i < pTermCapDescriptors->wLength; i++) {
		pTermCapDescriptor = pTermCapDescriptors->pTermCapDescriptorArray[i];
		status = H245SetCapDescriptor(pCall->H245Instance,
		                              &pTermCapDescriptor->CapDesc,
								      &pTermCapDescriptor->CapDescId);
		if (status != H245_ERROR_OK)
			return status;
	}

	status = H245SendTermCaps(pCall->H245Instance,
		                      pCall->H245Instance);	// returned as dwTransId in the callback
	return status;
}



HRESULT SessionTableToH245CommunicationTable(
									PCC_SESSIONTABLE		pSessionTable,
									H245_COMM_MODE_ENTRY_T	*pH245CommunicationTable[],
									BYTE					*pbCommunicationTableCount)
{
WORD	i, j;
WORD	wStringLength;

	ASSERT(pH245CommunicationTable != NULL);
	ASSERT(pbCommunicationTableCount != NULL);

	if ((pSessionTable == NULL) || (pSessionTable->wLength == 0)) {
		*pH245CommunicationTable = NULL;
		*pbCommunicationTableCount = 0;
		return CC_OK;
	}

	if (pSessionTable->SessionInfoArray == NULL) {
		*pH245CommunicationTable = NULL;
		*pbCommunicationTableCount = 0;
		return CC_BAD_PARAM;
	}

	*pH245CommunicationTable = (H245_COMM_MODE_ENTRY_T *)MemAlloc(sizeof(H245_COMM_MODE_ENTRY_T) * pSessionTable->wLength);
	if (*pH245CommunicationTable == NULL) {
		*pbCommunicationTableCount = 0;
		return CC_NO_MEMORY;
	}

	*pbCommunicationTableCount = (BYTE)pSessionTable->wLength;

	for (i = 0; i < pSessionTable->wLength; i++) {
		(*pH245CommunicationTable)[i].pNonStandard = NULL;
		(*pH245CommunicationTable)[i].sessionID = pSessionTable->SessionInfoArray[i].bSessionID;
		if (pSessionTable->SessionInfoArray[i].bAssociatedSessionID == 0)
			(*pH245CommunicationTable)[i].associatedSessionIDPresent = FALSE;
		else {
			(*pH245CommunicationTable)[i].associatedSessionIDPresent = TRUE;
			(*pH245CommunicationTable)[i].associatedSessionID = pSessionTable->SessionInfoArray[i].bAssociatedSessionID;
		}
		(*pH245CommunicationTable)[i].terminalLabelPresent = FALSE;
		wStringLength = pSessionTable->SessionInfoArray[i].SessionDescription.wOctetStringLength;
		if (wStringLength > 0) {
			(*pH245CommunicationTable)[i].pSessionDescription = (unsigned short *)MemAlloc(sizeof(unsigned short) * wStringLength);
			if ((*pH245CommunicationTable)[i].pSessionDescription == NULL) {
				for (j = 0; j < i; j++)
					MemFree((*pH245CommunicationTable)[j].pSessionDescription);
				MemFree(*pH245CommunicationTable);
				*pbCommunicationTableCount = 0;
				return CC_NO_MEMORY;
			}
			memcpy((*pH245CommunicationTable)[i].pSessionDescription,
				   pSessionTable->SessionInfoArray[i].SessionDescription.pOctetString,
				   wStringLength);
		} else
			(*pH245CommunicationTable)[i].pSessionDescription = NULL;
		(*pH245CommunicationTable)[i].wSessionDescriptionLength = wStringLength;
		(*pH245CommunicationTable)[i].dataType = *pSessionTable->SessionInfoArray[i].pTermCap;
		if (pSessionTable->SessionInfoArray[i].pRTPAddr == NULL)
			(*pH245CommunicationTable)[i].mediaChannelPresent = FALSE;
		else {
			if (pSessionTable->SessionInfoArray[i].pRTPAddr->nAddrType != CC_IP_BINARY) {
			for (j = 0; j <= i; j++)
				if ((*pH245CommunicationTable)[j].pSessionDescription != NULL)
					MemFree((*pH245CommunicationTable)[j].pSessionDescription);
				MemFree(*pH245CommunicationTable);
				*pbCommunicationTableCount = 0;
				return CC_BAD_PARAM;
			}
			if (pSessionTable->SessionInfoArray[i].pRTPAddr->bMulticast)
				(*pH245CommunicationTable)[i].mediaChannel.type = H245_IP_MULTICAST;
			else
				(*pH245CommunicationTable)[i].mediaChannel.type = H245_IP_UNICAST;
			(*pH245CommunicationTable)[i].mediaChannel.u.ip.tsapIdentifier =
				pSessionTable->SessionInfoArray[i].pRTPAddr->Addr.IP_Binary.wPort;
			HostToH245IPNetwork((*pH245CommunicationTable)[i].mediaChannel.u.ip.network,
								pSessionTable->SessionInfoArray[i].pRTPAddr->Addr.IP_Binary.dwAddr);
			(*pH245CommunicationTable)[i].mediaChannelPresent = TRUE;
		}
		if (pSessionTable->SessionInfoArray[i].pRTCPAddr == NULL)
			(*pH245CommunicationTable)[i].mediaControlChannelPresent = FALSE;
		else {
			if (pSessionTable->SessionInfoArray[i].pRTCPAddr->nAddrType != CC_IP_BINARY) {
			for (j = 0; j <= i; j++)
				if ((*pH245CommunicationTable)[j].pSessionDescription != NULL)
					MemFree((*pH245CommunicationTable)[j].pSessionDescription);
				MemFree(*pH245CommunicationTable);
				*pbCommunicationTableCount = 0;
				return CC_BAD_PARAM;
			}
			if (pSessionTable->SessionInfoArray[i].pRTCPAddr->bMulticast)
				(*pH245CommunicationTable)[i].mediaControlChannel.type = H245_IP_MULTICAST;
			else
				(*pH245CommunicationTable)[i].mediaControlChannel.type = H245_IP_UNICAST;
			(*pH245CommunicationTable)[i].mediaControlChannel.u.ip.tsapIdentifier =
				pSessionTable->SessionInfoArray[i].pRTCPAddr->Addr.IP_Binary.wPort;
			HostToH245IPNetwork((*pH245CommunicationTable)[i].mediaControlChannel.u.ip.network,
								pSessionTable->SessionInfoArray[i].pRTCPAddr->Addr.IP_Binary.dwAddr);
			(*pH245CommunicationTable)[i].mediaControlChannelPresent = TRUE;
		}
		(*pH245CommunicationTable)[i].mediaGuaranteed = FALSE;
		(*pH245CommunicationTable)[i].mediaGuaranteedPresent = TRUE;
		(*pH245CommunicationTable)[i].mediaControlGuaranteed = FALSE;
		(*pH245CommunicationTable)[i].mediaControlGuaranteedPresent = TRUE;
	}

	return CC_OK;
}



HRESULT H245CommunicationTableToSessionTable(
									H245_COMM_MODE_ENTRY_T	H245CommunicationTable[],
									BYTE					bCommunicationTableCount,
									PCC_SESSIONTABLE		*ppSessionTable)
{
WORD	i, j;
HRESULT	status;

	ASSERT(ppSessionTable != NULL);

	if (H245CommunicationTable == NULL)
		if (bCommunicationTableCount == 0) {
			*ppSessionTable = NULL;
			return CC_OK;
		} else
			return CC_BAD_PARAM;
	else
		if (bCommunicationTableCount == 0)
			return CC_BAD_PARAM;

	*ppSessionTable = (PCC_SESSIONTABLE)MemAlloc(sizeof(CC_SESSIONTABLE));
	if (*ppSessionTable == NULL)
		return CC_NO_MEMORY;

	(*ppSessionTable)->wLength = bCommunicationTableCount;

	(*ppSessionTable)->SessionInfoArray = (PCC_SESSIONINFO)MemAlloc(sizeof(CC_SESSIONINFO) * bCommunicationTableCount);
	if ((*ppSessionTable)->SessionInfoArray == NULL) {
		MemFree(*ppSessionTable);
		*ppSessionTable = NULL;
		return CC_NO_MEMORY;
	}

	for (i = 0; i < bCommunicationTableCount; i++) {
		(*ppSessionTable)->SessionInfoArray[i].bSessionID = H245CommunicationTable[i].sessionID;
		if (H245CommunicationTable[i].associatedSessionIDPresent)
			(*ppSessionTable)->SessionInfoArray[i].bAssociatedSessionID =
				H245CommunicationTable[i].associatedSessionID;
		else
			(*ppSessionTable)->SessionInfoArray[i].bAssociatedSessionID = 0;
		(*ppSessionTable)->SessionInfoArray[i].SessionDescription.wOctetStringLength =
			H245CommunicationTable[i].wSessionDescriptionLength;
		if ((*ppSessionTable)->SessionInfoArray[i].SessionDescription.wOctetStringLength == 0)
			(*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString = NULL;
		else {
			(*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString =
				(BYTE *)MemAlloc(H245CommunicationTable[i].wSessionDescriptionLength);
			if ((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString == NULL) {
				for (j = 0; j < i; j++) {
					H245FreeCap((*ppSessionTable)->SessionInfoArray[j].pTermCap);
					if ((*ppSessionTable)->SessionInfoArray[j].pRTPAddr != NULL)
						MemFree((*ppSessionTable)->SessionInfoArray[j].pRTPAddr);
					if ((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr != NULL)
						MemFree((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr);
				}
				MemFree((*ppSessionTable)->SessionInfoArray);
				MemFree(*ppSessionTable);
				return CC_NO_MEMORY;
			}
			memcpy((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString,
				   H245CommunicationTable[i].pSessionDescription,
				   H245CommunicationTable[i].wSessionDescriptionLength);
		}
		status = H245CopyCap(&(*ppSessionTable)->SessionInfoArray[i].pTermCap,
							 &H245CommunicationTable[i].dataType);
		if (status != H245_ERROR_OK) {
			if ((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString != NULL)
				MemFree((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString);
			for (j = 0; j < i; j++) {
				H245FreeCap((*ppSessionTable)->SessionInfoArray[j].pTermCap);
				if ((*ppSessionTable)->SessionInfoArray[j].pRTPAddr != NULL)
					MemFree((*ppSessionTable)->SessionInfoArray[j].pRTPAddr);
				if ((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr != NULL)
					MemFree((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr);
			}
			MemFree((*ppSessionTable)->SessionInfoArray);
			MemFree(*ppSessionTable);
			return status;
		}
		if ((H245CommunicationTable[i].mediaChannelPresent) &&
		    ((H245CommunicationTable[i].mediaChannel.type == H245_IP_MULTICAST) ||
		     (H245CommunicationTable[i].mediaChannel.type == H245_IP_UNICAST))) {
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
			if ((*ppSessionTable)->SessionInfoArray[i].pRTPAddr == NULL) {
				if ((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString != NULL)
					MemFree((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString);
				H245FreeCap((*ppSessionTable)->SessionInfoArray[i].pTermCap);
				for (j = 0; j < i; j++) {
					H245FreeCap((*ppSessionTable)->SessionInfoArray[j].pTermCap);
					if ((*ppSessionTable)->SessionInfoArray[j].pRTPAddr != NULL)
						MemFree((*ppSessionTable)->SessionInfoArray[j].pRTPAddr);
					if ((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr != NULL)
						MemFree((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr);
				}
				MemFree((*ppSessionTable)->SessionInfoArray);
				MemFree(*ppSessionTable);
				return CC_NO_MEMORY;
			}
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->nAddrType = CC_IP_BINARY;
			if (H245CommunicationTable[i].mediaChannel.type == H245_IP_MULTICAST)
				(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->bMulticast = TRUE;
			else
				(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->bMulticast = FALSE;
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->Addr.IP_Binary.wPort =
				H245CommunicationTable[i].mediaChannel.u.ip.tsapIdentifier;
			H245IPNetworkToHost(&(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->Addr.IP_Binary.dwAddr,
								H245CommunicationTable[i].mediaChannel.u.ip.network);
		} else
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr = NULL;
 		if ((H245CommunicationTable[i].mediaControlChannelPresent) &&
		    ((H245CommunicationTable[i].mediaControlChannel.type == H245_IP_MULTICAST) ||
		     (H245CommunicationTable[i].mediaControlChannel.type == H245_IP_UNICAST))) {
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
			if ((*ppSessionTable)->SessionInfoArray[i].pRTCPAddr == NULL) {
				if ((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString != NULL)
					MemFree((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString);
				H245FreeCap((*ppSessionTable)->SessionInfoArray[i].pTermCap);
				if ((*ppSessionTable)->SessionInfoArray[i].pRTPAddr != NULL)
					MemFree((*ppSessionTable)->SessionInfoArray[i].pRTPAddr);
				for (j = 0; j < i; j++) {
					H245FreeCap((*ppSessionTable)->SessionInfoArray[j].pTermCap);
					if ((*ppSessionTable)->SessionInfoArray[j].pRTPAddr != NULL)
						MemFree((*ppSessionTable)->SessionInfoArray[j].pRTPAddr);
					if ((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr != NULL)
						MemFree((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr);
				}
				MemFree((*ppSessionTable)->SessionInfoArray);
				MemFree(*ppSessionTable);
				return CC_NO_MEMORY;
			}
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->nAddrType = CC_IP_BINARY;
			if (H245CommunicationTable[i].mediaChannel.type == H245_IP_MULTICAST)
				(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->bMulticast = TRUE;
			else
				(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->bMulticast = FALSE;
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->Addr.IP_Binary.wPort =
				H245CommunicationTable[i].mediaControlChannel.u.ip.tsapIdentifier;
			H245IPNetworkToHost(&(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->Addr.IP_Binary.dwAddr,
								H245CommunicationTable[i].mediaControlChannel.u.ip.network);
		} else
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr = NULL;
	}
	return CC_OK;
}



HRESULT FreeH245CommunicationTable(	H245_COMM_MODE_ENTRY_T	H245CommunicationTable[],
									BYTE					bCommunicationTableCount)
{
WORD	i;

	if (H245CommunicationTable == NULL)
		if (bCommunicationTableCount == 0)
			return CC_OK;
		else
			return CC_BAD_PARAM;
	else
		if (bCommunicationTableCount == 0)
			return CC_BAD_PARAM;

	for (i = 0; i < bCommunicationTableCount; i++)
		if (H245CommunicationTable[i].pSessionDescription != NULL)
			MemFree(H245CommunicationTable[i].pSessionDescription);
	MemFree(H245CommunicationTable);
	return CC_OK;
}



HRESULT _PrepareTermCapLists(		PCONFERENCE				pConference,
									WORD					*pwListCount,
									PCC_TERMCAPLIST			**ppTermCapList,
									PCC_TERMCAPDESCRIPTORS	**ppTermCapDescriptorList,
									PCALL					*pCallList[])
{
WORD		i;
WORD		wNumCalls;
WORD		wOffset;
PCC_HCALL	CallList;
PCALL		pCall;

	ASSERT(pConference != NULL);
	ASSERT(pwListCount != NULL);
	ASSERT(ppTermCapList != NULL);
	ASSERT(ppTermCapDescriptorList != NULL);
	ASSERT(pCallList != NULL);

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);

	if ((pConference->LocalEndpointAttached == DETACHED) && (wNumCalls > 0))
		wOffset = 0;
	else
		// LocalEndpointAttached is either UNATTACHED or ATTACHED, or there are no calls
		// in the conference; in the latter case, we need to have some term caps in
		// order to form the conference term cap set (which cannot be empty)
		wOffset = 1;

	*pwListCount = (WORD)(wNumCalls + wOffset);

	*ppTermCapList = (PCC_TERMCAPLIST *)MemAlloc(sizeof(PCC_TERMCAPLIST) * (*pwListCount));
	if (*ppTermCapList == NULL) {
		MemFree(CallList);
		return CC_NO_MEMORY;
	}

	*ppTermCapDescriptorList = (PCC_TERMCAPDESCRIPTORS *)MemAlloc(sizeof(PCC_TERMCAPDESCRIPTORS) * (*pwListCount));
	if (*ppTermCapDescriptorList == NULL) {
		MemFree(CallList);
		MemFree(*ppTermCapList);
		return CC_NO_MEMORY;
	}

	*pCallList = (PCALL *)MemAlloc(sizeof(PCALL) * (*pwListCount));
	if (*pCallList == NULL) {
		MemFree(CallList);
		MemFree(*ppTermCapList);
		MemFree(*ppTermCapDescriptorList);
		return CC_NO_MEMORY;
	}

	// Fill in pTermCapList and pTermCapDescriptorList
	if (wOffset == 1) {
		// The local endpoint is attached to the conference, so fill in the first
		// slot in both lists with the local term cap and descriptor lists
		(*ppTermCapList)[0] = pConference->pLocalH245TermCapList;
		(*ppTermCapDescriptorList)[0] = pConference->pLocalH245TermCapDescriptors;
	}
	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			(*ppTermCapList)[i+wOffset] = pCall->pPeerH245TermCapList;
			(*ppTermCapDescriptorList)[i+wOffset] = pCall->pPeerH245TermCapDescriptors;
			(*pCallList)[i] = pCall;
		} else {
			(*ppTermCapList)[i+wOffset] = NULL;
			(*ppTermCapDescriptorList)[i+wOffset] = NULL;
			(*pCallList)[i] = NULL;
		}
	}
	for (i = 0; i < wOffset; i++)
		(*pCallList)[wNumCalls+i] = NULL;
	MemFree(CallList);
	return CC_OK;
}



HRESULT _FreeTermCapLists(			WORD					wListCount,
									PCC_TERMCAPLIST			*pTermCapList,
									PCC_TERMCAPDESCRIPTORS	*pTermCapDescriptorList,
									PCALL					pCallList[])
{
WORD	i;

	for (i = 0; i < wListCount; i++)
		if (pCallList[i] != NULL)
			UnlockCall(pCallList[i]);
	if (pTermCapList != NULL)
		MemFree(pTermCapList);
	if (pTermCapDescriptorList != NULL)
		MemFree(pTermCapDescriptorList);
	MemFree(pCallList);
	return CC_OK;
}



HRESULT CreateConferenceSessionTable(
									PCONFERENCE				pConference,
									BOOL					*pbSessionTableChanged)
{
HRESULT					status;
PCALL					*pCallList;
PCC_TERMCAPLIST			*pTermCapList;
PCC_TERMCAPDESCRIPTORS	*pTermCapDescriptorList;
WORD					wListCount;

	ASSERT(pConference != NULL);

	if (pConference->bSessionTableInternallyConstructed == TRUE) {
		status = FreeConferenceSessionTable(pConference);
		if (status != CC_OK)
			return status;
		pConference->bSessionTableInternallyConstructed = FALSE;
	}

	status = _PrepareTermCapLists(pConference,
								  &wListCount,
								  &pTermCapList,
								  &pTermCapDescriptorList,
								  &pCallList);
	if (status != CC_OK)
		return status;

	status = pConference->SessionTableConstructor(
									pConference->hConference,
									pConference->dwConferenceToken,
									TRUE,		// bCreate
									pbSessionTableChanged,
									wListCount,
									pTermCapList,
									pTermCapDescriptorList,
									&pConference->pSessionTable);

	_FreeTermCapLists(wListCount,
					  pTermCapList,
					  pTermCapDescriptorList,
					  pCallList);
	return status;
}



HRESULT FreeConferenceSessionTable(	PCONFERENCE				pConference)
{
HRESULT	status;

	ASSERT(pConference != NULL);

	if (pConference->bSessionTableInternallyConstructed)
		status = DefaultSessionTableConstructor(
									pConference->hConference,
									pConference->dwConferenceToken,
									FALSE,		// bCreate
									NULL,		// pbSessionTableChanged
									0,			// wListCount
									NULL,		// pTermCapList[]
									NULL,		// pTermCapDescriptors[]
									&pConference->pSessionTable);
	else
		status = pConference->SessionTableConstructor(
									pConference->hConference,
									pConference->dwConferenceToken,
									FALSE,		// bCreate
									NULL,		// pbSessionTableChanged
									0,			// wListCount
									NULL,		// pTermCapList[]
									NULL,		// pTermCapDescriptors[]
									&pConference->pSessionTable);
	pConference->pSessionTable = NULL;
	return status;
}



HRESULT CreateConferenceTermCaps(	PCONFERENCE				pConference,
									BOOL					*pbTermCapsChanged)
{
HRESULT					status;
WORD					wListCount;
PCALL					*pCallList;
PCC_TERMCAPLIST			*pInTermCapList;
PCC_TERMCAPDESCRIPTORS	*pInTermCapDescriptors;

	ASSERT(pConference != NULL);

	if (pConference->pConferenceH245H2250MuxCapability != NULL)
		H245FreeCap(pConference->pConferenceH245H2250MuxCapability);

	ASSERT(pConference->pLocalH245H2250MuxCapability != NULL);
	status = H245CopyCap(&pConference->pConferenceH245H2250MuxCapability,
						 pConference->pLocalH245H2250MuxCapability);
	if (status != H245_ERROR_OK)
		return status;

	status = _PrepareTermCapLists(pConference,
								  &wListCount,
								  &pInTermCapList,
								  &pInTermCapDescriptors,
								  &pCallList);
	if (status != CC_OK)
		return status;

	status = UnregisterTermCapListFromH245(pConference,
										   pConference->pConferenceTermCapList);
	if (status != CC_OK)
		return status;

	status = UnregisterTermCapDescriptorsFromH245(pConference,
												  pConference->pConferenceTermCapDescriptors);
	if (status != CC_OK)
		return status;

	status = pConference->TermCapConstructor(
									pConference->hConference,
									pConference->dwConferenceToken,
									TRUE,		// bCreate
									pbTermCapsChanged,
									wListCount,
									pInTermCapList,
									pInTermCapDescriptors,
									&pConference->pConferenceTermCapList,
									&pConference->pConferenceTermCapDescriptors);

	_FreeTermCapLists(wListCount,
					  pInTermCapList,
					  pInTermCapDescriptors,
					  pCallList);
	return status;
}



HRESULT FreeConferenceTermCaps(		PCONFERENCE				pConference)
{
HRESULT	status;

	ASSERT(pConference != NULL);

	status = pConference->TermCapConstructor(
									pConference->hConference,
									pConference->dwConferenceToken,
									FALSE,		// bCreate
									NULL,		// pbTermCapsChanged
									0,			// wListCount
									NULL,		// pInTermCapList[]
									NULL,		// pInTermCapDescriptors[]
									&pConference->pConferenceTermCapList,
									&pConference->pConferenceTermCapDescriptors);
	pConference->pConferenceTermCapList = NULL;
	pConference->pConferenceTermCapDescriptors = NULL;
	return status;
}



HRESULT FindEnqueuedRequest(		PCALL_QUEUE				pQueueHead,
									CC_HCALL				hEnqueuedCall)
{
PCALL_QUEUE	pQueueItem;

	ASSERT(hEnqueuedCall != CC_INVALID_HANDLE);

	pQueueItem = pQueueHead;

	while (pQueueItem != NULL) {
		if (pQueueItem->hCall == hEnqueuedCall)
			break;
		pQueueItem = pQueueItem->pNext;
	}
	if (pQueueItem == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT EnqueueRequest(				PCALL_QUEUE				*ppQueueHead,
									CC_HCALL				hEnqueuedCall)
{
PCALL_QUEUE	pQueueItem;

	ASSERT(ppQueueHead != NULL);
	ASSERT(hEnqueuedCall != CC_INVALID_HANDLE);

	// Make sure we're not enqueuing a duplicate request
	pQueueItem = *ppQueueHead;
	while (pQueueItem != NULL) {
		if (pQueueItem->hCall == hEnqueuedCall)
			return CC_OK;
		pQueueItem = pQueueItem->pNext;
	}

	pQueueItem = (PCALL_QUEUE)MemAlloc(sizeof(CALL_QUEUE));
	if (pQueueItem == NULL)
		return CC_NO_MEMORY;
	pQueueItem->hCall = hEnqueuedCall;
	pQueueItem->pPrev = NULL;
	pQueueItem->pNext = *ppQueueHead;
	if (*ppQueueHead != NULL)
		(*ppQueueHead)->pPrev = pQueueItem;
	*ppQueueHead = pQueueItem;
	return CC_OK;
}



HRESULT DequeueRequest(				PCALL_QUEUE				*ppQueueHead,
									PCC_HCALL				phEnqueuedCall)

{
PCALL_QUEUE	pQueueItem;

	ASSERT(ppQueueHead != NULL);

	if (phEnqueuedCall != NULL)
		*phEnqueuedCall = CC_INVALID_HANDLE;

	if (*ppQueueHead == NULL)
		return CC_BAD_PARAM;

	pQueueItem = *ppQueueHead;
	*ppQueueHead = (*ppQueueHead)->pNext;
	if (*ppQueueHead != NULL)
		(*ppQueueHead)->pPrev = NULL;

	if (phEnqueuedCall != NULL)
		*phEnqueuedCall = pQueueItem->hCall;
	MemFree(pQueueItem);
	return CC_OK;
}



HRESULT DequeueSpecificRequest(		PCALL_QUEUE				*ppQueueHead,
									CC_HCALL				hEnqueuedCall)
{
PCALL_QUEUE	pQueueItem;

	ASSERT(ppQueueHead != NULL);
	ASSERT(hEnqueuedCall != CC_INVALID_HANDLE);

	pQueueItem = *ppQueueHead;
	while (pQueueItem != NULL)
		if (pQueueItem->hCall == hEnqueuedCall)
			break;
		else
			pQueueItem = pQueueItem->pNext;

	if (pQueueItem == NULL)
		return CC_BAD_PARAM;

	if (pQueueItem->pNext != NULL)
		pQueueItem->pNext->pPrev = pQueueItem->pPrev;
	if (pQueueItem->pPrev == NULL)
		*ppQueueHead = pQueueItem->pNext;
	else
		pQueueItem->pPrev->pNext = pQueueItem->pNext;

	MemFree(pQueueItem);
	return CC_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\chanman.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/chanman.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.43  $
 *	$Date:   04 Mar 1997 17:35:04  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#include "precomp.h"

#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "ccutils.h"
#include "listman.h"
#include "q931man.h"
#include "userman.h"
#include "callman.h"
#include "confman.h"
#include "chanman.h"


static BOOL			bChannelInited = FALSE;

static struct {
	PCHANNEL			pHead;
	LOCK				Lock;
} ChannelTable;

static struct {
	CC_HCHANNEL			hChannel;
	LOCK				Lock;
} ChannelHandle;



HRESULT InitChannelManager()
{
	ASSERT(bChannelInited == FALSE);

	ChannelTable.pHead = NULL;
	InitializeLock(&ChannelTable.Lock);

	ChannelHandle.hChannel = CC_INVALID_HANDLE + 1;
	InitializeLock(&ChannelHandle.Lock);

	bChannelInited = TRUE;
	return CC_OK;
}



HRESULT DeInitChannelManager()
{
PCHANNEL	pChannel;
PCHANNEL	pNextChannel;

	if (bChannelInited == FALSE)
		return CC_OK;

	pChannel = ChannelTable.pHead;
	while (pChannel != NULL) {
		AcquireLock(&pChannel->Lock);
		pNextChannel = pChannel->pNextInTable;
		FreeChannel(pChannel);
		pChannel = pNextChannel;
	}

	DeleteLock(&ChannelHandle.Lock);
	DeleteLock(&ChannelTable.Lock);
	bChannelInited = FALSE;
	return CC_OK;
}



HRESULT _AddChannelToTable(			PCHANNEL				pChannel)
{
	ASSERT(pChannel != NULL);
	ASSERT(pChannel->hChannel != CC_INVALID_HANDLE);
	ASSERT(pChannel->bInTable == FALSE);

	AcquireLock(&ChannelTable.Lock);

	pChannel->pNextInTable = ChannelTable.pHead;
	pChannel->pPrevInTable = NULL;
	if (ChannelTable.pHead != NULL)
		ChannelTable.pHead->pPrevInTable = pChannel;
	ChannelTable.pHead = pChannel;

	pChannel->bInTable = TRUE;

	RelinquishLock(&ChannelTable.Lock);
	return CC_OK;
}



HRESULT _RemoveChannelFromTable(	PCHANNEL				pChannel)
{
CC_HCHANNEL		hChannel;
BOOL			bTimedOut;

	ASSERT(pChannel != NULL);
	ASSERT(pChannel->bInTable == TRUE);

	// Caller must have a lock on the channel object;
	// in order to avoid deadlock, we must:
	//   1. unlock the channel object,
	//   2. lock the ChannelTable,
	//   3. locate the channel object in the ChannelTable (note that
	//      after step 2, the channel object may be deleted from the
	//      ChannelTable by another thread),
	//   4. lock the channel object (someone else may have the lock)
	//   5. remove the channel object from the ChannelTable,
	//   6. unlock the ChannelTable
	//
	// The caller can now safely unlock and destroy the channel object,
	// since no other thread will be able to find the object (its been
	// removed from the ChannelTable), and therefore no other thread will
	// be able to lock it.

	// Save the channel handle; its the only way to look up
	// the channel object in the ChannelTable. Note that we
	// can't use pChannel to find the channel object, since
	// pChannel may be free'd up, and another channel object
	// allocated at the same address
	hChannel = pChannel->hChannel;

	// step 1
	RelinquishLock(&pChannel->Lock);

step2:
	// step 2
	AcquireLock(&ChannelTable.Lock);

	// step 3
	pChannel = ChannelTable.pHead;
	while ((pChannel != NULL) && (pChannel->hChannel != hChannel))
		pChannel = pChannel->pNextInTable;

	if (pChannel != NULL) {
		// step 4
		AcquireTimedLock(&pChannel->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ChannelTable.Lock);
			Sleep(0);
			goto step2;
		}
		// step 5
		if (pChannel->pPrevInTable == NULL)
			ChannelTable.pHead = pChannel->pNextInTable;
		else
			pChannel->pPrevInTable->pNextInTable = pChannel->pNextInTable;

		if (pChannel->pNextInTable != NULL)
			pChannel->pNextInTable->pPrevInTable = pChannel->pPrevInTable;

		pChannel->pPrevInTable = NULL;
		pChannel->pNextInTable = NULL;
		pChannel->bInTable = FALSE;
	}

	// step 6
	RelinquishLock(&ChannelTable.Lock);

	if (pChannel == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT _MakeChannelHandle(			PCC_HCHANNEL			phChannel)
{
	AcquireLock(&ChannelHandle.Lock);
	*phChannel = ChannelHandle.hChannel++;
	RelinquishLock(&ChannelHandle.Lock);
	return CC_OK;
}


HRESULT AllocAndLockChannel(		PCC_HCHANNEL			phChannel,
									PCONFERENCE				pConference,
									CC_HCALL				hCall,
									PCC_TERMCAP				pTxTermCap,
									PCC_TERMCAP				pRxTermCap,
									H245_MUX_T				*pTxMuxTable,
									H245_MUX_T				*pRxMuxTable,
									H245_ACCESS_T			*pSeparateStack,
									DWORD_PTR				dwUserToken,
									BYTE					bChannelType,
									BYTE					bSessionID,
									BYTE					bAssociatedSessionID,
									WORD					wRemoteChannelNumber,
									PCC_ADDR				pLocalRTPAddr,
									PCC_ADDR				pLocalRTCPAddr,
									PCC_ADDR				pPeerRTPAddr,
									PCC_ADDR				pPeerRTCPAddr,
									BOOL					bLocallyOpened,
									PPCHANNEL				ppChannel)
{
HRESULT		status;
	
	ASSERT(bChannelInited == TRUE);

	// all parameters should have been validated by the caller
	ASSERT(phChannel != NULL);
	ASSERT(pConference != NULL);
	ASSERT((bChannelType == TX_CHANNEL) ||
		   (bChannelType == RX_CHANNEL) ||
		   (bChannelType == TXRX_CHANNEL) ||
		   (bChannelType == PROXY_CHANNEL));
	ASSERT(ppChannel != NULL);

	// set phChannel now, in case we encounter an error
	*phChannel = CC_INVALID_HANDLE;

	*ppChannel = (PCHANNEL)MemAlloc(sizeof(CHANNEL));
	if (*ppChannel == NULL)
		return CC_NO_MEMORY;

	(*ppChannel)->bInTable = FALSE;
	(*ppChannel)->bMultipointChannel = FALSE;
	(*ppChannel)->hCall = hCall;
	(*ppChannel)->wNumOutstandingRequests = 0;
	(*ppChannel)->pTxH245TermCap = NULL;
	(*ppChannel)->pRxH245TermCap = NULL;
	(*ppChannel)->pTxMuxTable = NULL;
	(*ppChannel)->pRxMuxTable = NULL;
	(*ppChannel)->pSeparateStack = NULL;
	(*ppChannel)->pCloseRequests = NULL;
	(*ppChannel)->pLocalRTPAddr = NULL;
	(*ppChannel)->pLocalRTCPAddr = NULL;
	(*ppChannel)->pPeerRTPAddr = NULL;
	(*ppChannel)->pPeerRTCPAddr = NULL;
	(*ppChannel)->dwUserToken = dwUserToken;
	(*ppChannel)->hConference = pConference->hConference;
	(*ppChannel)->bSessionID = bSessionID;
	(*ppChannel)->bAssociatedSessionID = bAssociatedSessionID;
	(*ppChannel)->wLocalChannelNumber = 0;
	(*ppChannel)->wRemoteChannelNumber = 0;
	(*ppChannel)->bLocallyOpened = bLocallyOpened;
	(*ppChannel)->pNextInTable = NULL;
	(*ppChannel)->pPrevInTable = NULL;
	(*ppChannel)->pNext = NULL;
	(*ppChannel)->pPrev = NULL;
	
	InitializeLock(&(*ppChannel)->Lock);
	AcquireLock(&(*ppChannel)->Lock);

	status = _MakeChannelHandle(&(*ppChannel)->hChannel);
	if (status != CC_OK) {
		FreeChannel(*ppChannel);
		return status;
	}

	if (bLocallyOpened == TRUE)
		(*ppChannel)->tsAccepted = TS_TRUE;
	else
		(*ppChannel)->tsAccepted = TS_UNKNOWN;

	if (pTxMuxTable != NULL) {
		(*ppChannel)->pTxMuxTable = (H245_MUX_T *)MemAlloc(sizeof(H245_MUX_T));
		if ((*ppChannel)->pTxMuxTable == NULL) {
			FreeChannel(*ppChannel);
			return CC_NO_MEMORY;
		}
		*(*ppChannel)->pTxMuxTable = *pTxMuxTable;
	}

	if (pRxMuxTable != NULL) {
		(*ppChannel)->pRxMuxTable = (H245_MUX_T *)MemAlloc(sizeof(H245_MUX_T));
		if ((*ppChannel)->pRxMuxTable == NULL) {
			FreeChannel(*ppChannel);
			return CC_NO_MEMORY;
		}
		*(*ppChannel)->pRxMuxTable = *pRxMuxTable;
	}

	if (pSeparateStack != NULL) {
		status = CopySeparateStack(&(*ppChannel)->pSeparateStack,
								   pSeparateStack);
		if (status != CC_OK) {
			FreeChannel(*ppChannel);
			return status;
		}
	}

	(*ppChannel)->bChannelType = bChannelType;
	(*ppChannel)->bCallbackInvoked = FALSE;
	if (pTxTermCap != NULL) {
		status = H245CopyCap(&(*ppChannel)->pTxH245TermCap, pTxTermCap);
		if (status != H245_ERROR_OK) {
			FreeChannel(*ppChannel);
			return status;
		}
	}
	if (pRxTermCap != NULL) {
		status = H245CopyCap(&(*ppChannel)->pRxH245TermCap, pRxTermCap);
		if (status != H245_ERROR_OK) {
			FreeChannel(*ppChannel);
			return status;
		}
	}
	if (pLocalRTPAddr != NULL) {
		(*ppChannel)->pLocalRTPAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
		if ((*ppChannel)->pLocalRTPAddr == NULL) {
			FreeChannel(*ppChannel);
			return CC_NO_MEMORY;
		}
		*(*ppChannel)->pLocalRTPAddr = *pLocalRTPAddr;
	}
	if (pLocalRTCPAddr != NULL) {
		(*ppChannel)->pLocalRTCPAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
		if ((*ppChannel)->pLocalRTCPAddr == NULL) {
			FreeChannel(*ppChannel);
			return CC_NO_MEMORY;
		}
		*(*ppChannel)->pLocalRTCPAddr = *pLocalRTCPAddr;
	}
	if (pPeerRTPAddr != NULL) {
		(*ppChannel)->pPeerRTPAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
		if ((*ppChannel)->pPeerRTPAddr == NULL) {
			FreeChannel(*ppChannel);
			return CC_NO_MEMORY;
		}
		*(*ppChannel)->pPeerRTPAddr = *pPeerRTPAddr;
	}
	if (pPeerRTCPAddr != NULL) {
		(*ppChannel)->pPeerRTCPAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
		if ((*ppChannel)->pPeerRTCPAddr == NULL) {
			FreeChannel(*ppChannel);
			return CC_NO_MEMORY;
		}
		*(*ppChannel)->pPeerRTCPAddr = *pPeerRTCPAddr;
	}
	
	*phChannel = (*ppChannel)->hChannel;

	// add the conference to the conference table
	status = _AddChannelToTable(*ppChannel);
	if (status != CC_OK) {
		FreeChannel(*ppChannel);
		return status;
	}

	switch (bChannelType) {
		case TX_CHANNEL:			
			status = AllocateChannelNumber(pConference, &(*ppChannel)->wLocalChannelNumber);
			if (status != CC_OK) {
				FreeChannel(*ppChannel);
				return status;
			}
			(*ppChannel)->wRemoteChannelNumber = 0;
			break;

		case RX_CHANNEL:
			(*ppChannel)->wLocalChannelNumber = 0;
			(*ppChannel)->wRemoteChannelNumber = wRemoteChannelNumber;
			break;

		case TXRX_CHANNEL:
			status = AllocateChannelNumber(pConference, &(*ppChannel)->wLocalChannelNumber);
			if (status != CC_OK) {
				FreeChannel(*ppChannel);
				return status;
			}
			if (bLocallyOpened)
				(*ppChannel)->wRemoteChannelNumber = 0;
			else
				(*ppChannel)->wRemoteChannelNumber = wRemoteChannelNumber;
			break;

		case PROXY_CHANNEL:
			status = AllocateChannelNumber(pConference, &(*ppChannel)->wLocalChannelNumber);
			if (status != CC_OK) {
				FreeChannel(*ppChannel);
				return status;
			}
			(*ppChannel)->wRemoteChannelNumber = wRemoteChannelNumber;
			break;

		default:
			ASSERT(0);
			break;
	}
	
	return CC_OK;
}



HRESULT AddLocalAddrPairToChannel(	PCC_ADDR				pRTPAddr,
									PCC_ADDR				pRTCPAddr,
									PCHANNEL				pChannel)
{
	ASSERT(pChannel != NULL);

	if (pRTPAddr != NULL) {
		if (pChannel->pLocalRTPAddr == NULL) {
			pChannel->pLocalRTPAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
			if (pChannel->pLocalRTPAddr == NULL)
				return CC_NO_MEMORY;
		}
		*pChannel->pLocalRTPAddr = *pRTPAddr;
	}

	if (pRTCPAddr != NULL) {
		if (pChannel->pLocalRTCPAddr == NULL) {
			pChannel->pLocalRTCPAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
			if (pChannel->pLocalRTCPAddr == NULL)
				return CC_NO_MEMORY;
		}
		*pChannel->pLocalRTCPAddr = *pRTCPAddr;
	}

	return CC_OK;
}



HRESULT AddSeparateStackToChannel(	H245_ACCESS_T			*pSeparateStack,
									PCHANNEL				pChannel)
{
	ASSERT(pSeparateStack != NULL);
	ASSERT(pChannel != NULL);

	if (pChannel->pSeparateStack != NULL)
		return CC_BAD_PARAM;

	pChannel->pSeparateStack = (H245_ACCESS_T *)MemAlloc(sizeof(H245_ACCESS_T));
	if (pChannel->pSeparateStack == NULL)
		return CC_NO_MEMORY;
	*pChannel->pSeparateStack = *pSeparateStack;
	return CC_OK;
}



// Caller must have a lock on the channel object
HRESULT FreeChannel(				PCHANNEL				pChannel)
{
HRESULT				status;
CC_HCHANNEL			hChannel;
PCONFERENCE			pConference;

	ASSERT(pChannel != NULL);

	// caller must have a lock on the channel object,
	// so there's no need to re-lock it
	
	hChannel = pChannel->hChannel;
	if (pChannel->hConference != CC_INVALID_HANDLE) {
		UnlockChannel(pChannel);
		status = LockChannelAndConference(hChannel, &pChannel, &pConference);
		if (status != CC_OK)
			return status;
	}

	if (pChannel->bInTable == TRUE)
		if (_RemoveChannelFromTable(pChannel) == CC_BAD_PARAM)
			// the channel object was deleted by another thread,
			// so just return CC_OK
			return CC_OK;

	if (pChannel->hConference != CC_INVALID_HANDLE)
		RemoveChannelFromConference(pChannel, pConference);

	if (pChannel->pSeparateStack != NULL)
		FreeSeparateStack(pChannel->pSeparateStack);

	if (pChannel->pTxMuxTable != NULL)
		MemFree(pChannel->pTxMuxTable);

	if (pChannel->pRxMuxTable != NULL)
		MemFree(pChannel->pRxMuxTable);

	if (pChannel->pTxH245TermCap != NULL)
		H245FreeCap(pChannel->pTxH245TermCap);

	if (pChannel->pRxH245TermCap != NULL)
		H245FreeCap(pChannel->pRxH245TermCap);

	while (DequeueRequest(&pChannel->pCloseRequests, NULL) == CC_OK);

	if (pChannel->pLocalRTPAddr != NULL)
		MemFree(pChannel->pLocalRTPAddr);

	if (pChannel->pLocalRTCPAddr != NULL)
		MemFree(pChannel->pLocalRTCPAddr);

	if (pChannel->pPeerRTPAddr != NULL)
		MemFree(pChannel->pPeerRTPAddr);

	if (pChannel->pPeerRTCPAddr != NULL)
		MemFree(pChannel->pPeerRTCPAddr);

	if (pChannel->wLocalChannelNumber != 0) {
		FreeChannelNumber(pConference, pChannel->wLocalChannelNumber);
	}

	if (pChannel->hConference != CC_INVALID_HANDLE)
		UnlockConference(pConference);

	// Since the channel object has been removed from the ChannelTable,
	// no other thread will be able to find the channel object and obtain
	// a lock, so its safe to unlock the channel object and delete it here
	RelinquishLock(&pChannel->Lock);
	DeleteLock(&pChannel->Lock);
	MemFree(pChannel);
	return CC_OK;
}



HRESULT LockChannel(				CC_HCHANNEL				hChannel,
									PPCHANNEL				ppChannel)
{
BOOL	bTimedOut;

	ASSERT(hChannel != CC_INVALID_HANDLE);
	ASSERT(ppChannel != NULL);

step1:
	AcquireLock(&ChannelTable.Lock);

	*ppChannel = ChannelTable.pHead;
	while ((*ppChannel != NULL) && ((*ppChannel)->hChannel != hChannel))
		*ppChannel = (*ppChannel)->pNextInTable;

	if (*ppChannel != NULL) {
		AcquireTimedLock(&(*ppChannel)->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ChannelTable.Lock);
			Sleep(0);
			goto step1;
		}
	}

	RelinquishLock(&ChannelTable.Lock);

	if (*ppChannel == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT LockChannelAndConference(	CC_HCHANNEL				hChannel,
									PPCHANNEL				ppChannel,
									PPCONFERENCE			ppConference)
{
HRESULT			status;
CC_HCONFERENCE	hConference;

	ASSERT(hChannel != CC_INVALID_HANDLE);
	ASSERT(ppChannel != NULL);
	ASSERT(ppConference != NULL);

	status = LockChannel(hChannel, ppChannel);
	if (status != CC_OK)
		return status;
	
	if ((*ppChannel)->hConference == CC_INVALID_HANDLE) {
		UnlockChannel(*ppChannel);
		return CC_BAD_PARAM;
	}

	hConference = (*ppChannel)->hConference;
	UnlockChannel(*ppChannel);

	status = LockConference(hConference, ppConference);
	if (status != CC_OK)
		return status;

	status = LockChannel(hChannel, ppChannel);
	if (status != CC_OK) {
		UnlockConference(*ppConference);
		return status;
	}
	
	return CC_OK;
}



HRESULT ValidateChannel(			CC_HCHANNEL				hChannel)
{
PCHANNEL	pChannel;

	ASSERT(hChannel != CC_INVALID_HANDLE);

	AcquireLock(&ChannelTable.Lock);

	pChannel = ChannelTable.pHead;
	while ((pChannel != NULL) && (pChannel->hChannel != hChannel))
		pChannel = pChannel->pNextInTable;

	RelinquishLock(&ChannelTable.Lock);

	if (pChannel == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT UnlockChannel(				PCHANNEL				pChannel)
{
	ASSERT(pChannel != NULL);

	RelinquishLock(&pChannel->Lock);
	return CC_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\coder.hpp ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1997 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *																	   *
 *	$Archive:   S:\sturgeon\src\include\vcs\coder.hpv  $
 *
 *	$Revision:   1.4  $
 *	$Date:   16 Jan 1997 15:25:06  $
 *
 *	$Author:   BPOLING  $
 *
 *	$Log:   S:\sturgeon\src\include\vcs\coder.hpv  $
// 
//    Rev 1.4   16 Jan 1997 15:25:06   BPOLING
// changed copyrights to 1997
// 
//    Rev 1.3   18 Dec 1996 21:49:58   BPOLING
// builds with msdev and for windows only
// 
//    Rev 1.2   09 Dec 1996 14:13:54   EHOWARDX
// Updated copyright notice.
 * 
 *    Rev 1.1   15 Nov 1996 16:16:14   BPOLING
 * vcs header added.
 *                                                                     *
 ***********************************************************************
 *																	   *
 *	coder.hpp														   *
 *																	   * 
 *	PURPOSE:	Encode/Decode ANS.1 Gatekeeper PDU using the ANS.1     *
 *				compiler functions.									   *
 *																	   *
 *	FUNCTIONS:														   *
 *																	   *
 *	COMMENTS: 														   *
 *																	   *
 ***********************************************************************/

/************************************************************************
 * 						Include Files		           				   	*
 ***********************************************************************/

/************************************************************************
 * 						Manifest Constants								*
 ***********************************************************************/
																			
/************************************************************************
*						GLOBAL VARIABLES								*
************************************************************************/

/************************************************************************
 * 						Class Definitions								*
 ***********************************************************************/

#ifndef _CODER_HPP
#define _CODER_HPP

#include "av_asn1.h"
#include "gk_asn1.h"

extern "C" {
int GK_InitWorld(ASN1_CODER_INFO *pWorld);
int GK_TermWorld(ASN1_CODER_INFO *pWorld);
int GK_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, ASN1_BUF *pBuf);
int GK_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, ASN1_BUF *pBuf);
}

//  DEBUG OPTIONS
#define CODER_DEBUG		  0x00000001
#define CODER_SUPER_DEBUG 0x00000002

// Coder Error Messages

#define CODER_NOERROR 0
#define CODER_ERROR   1

// Protocol version information
#define ITU_T			0
#define RECOMMENDATION	0
#define SERIES			8     // H225.0
#define RECOMM_NUMBER   2250
#define VERSION         0
#define ADDITIONAL      2


// typedef struct InfoRequestResponse_perCallInfo      SEQPERCALLINFO, *PSEQPERCALLINFO;

typedef struct _seqtransadds{
    struct _seqtransadds  	*next;
    TransportAddress 		value;
} SEQTRANSADDS, *PSEQTRANSADDS;

typedef struct _seqaliasadds {
    struct _seqaliasadds  	*next;
    AliasAddress    		value;
} SEQALIASADDS, *PSEQALIASADDS;

class Coder{

private:
	ASN1_CODER_INFO		m_World;
	CRITICAL_SECTION	m_critSec;

public:
	struct ObjectID_ m_protocolIdentifier1,m_protocolIdentifier2,m_protocolIdentifier3,
		             m_protocolIdentifier4,m_protocolIdentifier5,m_protocolIdentifier6;

public:
	Coder();
	~Coder();

	int InitCoder();
	// Creates an OssBuf
	int Encode(RasMessage *pInputData, ASN1_BUF *pOutputOssBuf);
	// Create memory to hold decoded OssBuf
	// For H323 this is a rasStruct
	int Decode(ASN1_BUF *pInputOssBuf, RasMessage **pOutputData);
	// Used to free buffer created by decode
	int Free(RasMessage *pData);
	// Used to free buffer created by encode
	void Free(ASN1_BUF Asn1Buf);
	// Returns the sequence number out of any RasMessage
	// Returns zero on error
	RequestSeqNum GetSequenceNumber(RasMessage *prasStruct);
	RequestSeqNum SetSequenceNumber(RasMessage &rasStruct,RequestSeqNum reqNum);
	// Returns a pointer EndpointIdentifier for any RasMessage
	// NULL for RasMessage that have no EndpointIdentifier
	EndpointIdentifier *GetEndpointID(RasMessage *prasStruct);
	// Returns a pointer to a valid H323 protocolIdentifier linked list 
	// when a valid Rasmessage is passed in and sets the protocol Identifier
	// item in RasMessages that have an protocol Identifier
	// If in an RasMessage that doesn't have a protocol identifer is passed in,
	// NULL is returned.
	ProtocolIdentifier SetProtocolIdentifier(RasMessage &rasStruct);
	// Returns TRUE if protocols match, FALSE - otherwise
	BOOL VerifyProtocolIdentifier(RasMessage &rasStruct);
	// finds the requested protocol rasAddress and copies it
	DWORD CopyRasAddress(TransportAddress *pDestAddress, RasMessage *prasStruct, unsigned short choice);
	DWORD CopyRasAddress(TransportAddress *pDestAddress, PSEQTRANSADDS pSrcSeqRasAddress, unsigned short choice);
	// finds the requested protocol callSignalAddress and copies it
	DWORD CopyCallSignal(TransportAddress *pCallSignalAddress, RasMessage *prasStruct, unsigned short choice);
	DWORD CopyCallSignal(TransportAddress *pDestCallSignalAddress, PSEQTRANSADDS pSrcSeqCSAAddress, unsigned short choice);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\chanman.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/chanman.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.20  $
 *	$Date:   31 Jan 1997 13:44:24  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

HRESULT InitChannelManager();

HRESULT DeInitChannelManager();

HRESULT AllocAndLockChannel(		PCC_HCHANNEL			phChannel,
									PCONFERENCE				pConference,
									CC_HCALL				hCall,
									PCC_TERMCAP				pTxTermCap,
									PCC_TERMCAP				pRxTermCap,
									H245_MUX_T				*pTxMuxTable,
									H245_MUX_T				*pRxMuxTable,
									H245_ACCESS_T			*pSeparateStack,
									DWORD_PTR				dwUserToken,
									BYTE					bChannelType,
									BYTE					bSessionID,
									BYTE					bAssociatedSessionID,
									WORD					wRemoteChannelNumber,
									PCC_ADDR				pLocalRTPAddr,
									PCC_ADDR				pLocalRTCPAddr,
									PCC_ADDR				pPeerRTPAddr,
									PCC_ADDR				pPeerRTCPAddr,
									BOOL					bLocallyOpened,
									PPCHANNEL				ppChannel);

HRESULT AddLocalAddrPairToChannel(	PCC_ADDR				pRTPAddr,
									PCC_ADDR				pRTCPAddr,
									PCHANNEL				pChannel);

HRESULT AddSeparateStackToChannel(	H245_ACCESS_T			*pSeparateStack,
									PCHANNEL				pChannel);

HRESULT FreeChannel(				PCHANNEL				pChannel);

HRESULT LockChannel(				CC_HCHANNEL				hChannel,
									PPCHANNEL				ppChannel);

HRESULT LockChannelAndConference(	CC_HCHANNEL				hChannel,
									PPCHANNEL				ppChannel,
									PPCONFERENCE			ppConference);

HRESULT ValidateChannel(			CC_HCHANNEL				hChannel);

HRESULT UnlockChannel(				PCHANNEL				pChannel);


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\confman.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/confman.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.39  $
 *	$Date:   31 Jan 1997 13:44:26  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

// Call types must be bit maps
#define ENQUEUED_CALL		0x01
#define PLACED_CALL			0x02
#define ESTABLISHED_CALL	0x04
#define VIRTUAL_CALL		0x08
#define REAL_CALLS			(ENQUEUED_CALL | PLACED_CALL | ESTABLISHED_CALL)
#define ALL_CALLS			(REAL_CALLS | VIRTUAL_CALL)

HRESULT InitConferenceManager();

HRESULT DeInitConferenceManager();

HRESULT AllocateTerminalNumber(		PCONFERENCE				pConference,
									H245_TERMINAL_LABEL_T	*pH245TerminalLabel);

HRESULT FreeTerminalNumber(			PCONFERENCE				pConference,
									BYTE					bTerminalNumber);

HRESULT AllocateChannelNumber(		PCONFERENCE				pConference,
									WORD					*pwChannelNumber);

HRESULT FreeChannelNumber(			PCONFERENCE				pConference,
									WORD					wChannelNumber);

HRESULT AllocAndLockConference(		PCC_HCONFERENCE			phConference,
									PCC_CONFERENCEID		pConferenceID,
									BOOL					bMultipointCapable,
									BOOL					bForceMultipointController,
									PCC_TERMCAPLIST			pLocalTermCapList,
									PCC_TERMCAPDESCRIPTORS	pLocalTermCapDescriptors,
									PCC_VENDORINFO			pVendorInfo,
									PCC_OCTETSTRING			pTerminalID,
									DWORD_PTR				dwConferenceToken,
									CC_SESSIONTABLE_CONSTRUCTOR SessionTableConstructor,
									CC_TERMCAP_CONSTRUCTOR	TermCapConstructor,
									CC_CONFERENCE_CALLBACK	ConferenceCallback,
									PPCONFERENCE			ppConference);

HRESULT RemoveCallFromConference(	PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT RemoveEnqueuedCallFromConference(
									PCONFERENCE				pConference,
									PCC_HCALL				phCall);

HRESULT RemoveChannelFromConference(PCHANNEL				pChannel,
									PCONFERENCE				pConference);

HRESULT AddEnqueuedCallToConference(PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT AddPlacedCallToConference(	PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT AddEstablishedCallToConference(
									PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT AddVirtualCallToConference(	PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT AddChannelToConference(		PCHANNEL				pChannel,
									PCONFERENCE				pConference);

HRESULT FreeConference(				PCONFERENCE				pConference);

HRESULT LockConference(				CC_HCONFERENCE			hConference,
									PPCONFERENCE			ppConference);

HRESULT LockConferenceEx(			CC_HCONFERENCE			hConference,
									PPCONFERENCE			ppConference,
									TRISTATE				tsDeferredDelete);

HRESULT ValidateConference(			CC_HCONFERENCE			hConference);

HRESULT LockConferenceID(			PCC_CONFERENCEID		pConferenceID,
									PPCONFERENCE			ppConference);

HRESULT FindChannelInConference(	WORD					wChannel,
									BOOL					bLocalChannel,
									BYTE					bChannelType,
									CC_HCALL				hCall,
									PCC_HCHANNEL			phChannel,
									PCONFERENCE				pConference);

HRESULT EnumerateConferences(		PWORD					pwNumConferences,
									CC_HCONFERENCE			ConferenceList[]);

HRESULT EnumerateCallsInConference(	WORD					*pwNumCalls,
									PCC_HCALL				pCallList[],
									PCONFERENCE				pConference,
									BYTE					bCallType);

HRESULT EnumerateChannelsInConference(
									WORD					*pwNumChannels,
									PCC_HCHANNEL			pChannelList[],
									PCONFERENCE				pConference,
									BYTE					bChannelType);

HRESULT EnumerateTerminalLabelsInConference(
									WORD					*pwNumTerminalLabels,
									H245_TERMINAL_LABEL_T   *pH245TerminalLabelList[],
									PCONFERENCE				pConference);

HRESULT UnlockConference(			PCONFERENCE				pConference);

HRESULT AsynchronousDestroyConference(
									CC_HCONFERENCE			hConference,
									BOOL					bAutoAccept);

HRESULT FindPeerParticipantInfo(	H245_TERMINAL_LABEL_T	H245TerminalLabel,
									PCONFERENCE				pConference,
									BYTE					bCallType,
									PCALL					*ppCall);

HRESULT ReInitializeConference(		PCONFERENCE				pConference);


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\api_dwn.c ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  AUTHOR: cjutzi (Curt Jutzi) Intel Corporation
 *
 *  $Workfile:   api_dwn.c  $
 *  $Revision:   1.45  $
 *  $Modtime:   05 Mar 1997 09:53:36  $
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/api_dwn.c_v  $
 *
 *    Rev 1.45   05 Mar 1997 09:56:04   MANDREWS
 * Fixed compiler warning in release mode.
 *
 *    Rev 1.44   04 Mar 1997 17:33:26   MANDREWS
 * H245CopyCap() and H245CopyCapDescriptor() now return HRESULTs.
 *
 *    Rev 1.43   26 Feb 1997 11:12:06   MANDREWS
 * Fixed problem in assigning dynamic term cap IDs; the dynamic IDs were
 * overlapping with static IDs.
 *
 *    Rev 1.42   Feb 24 1997 18:30:18   tomitowx
 * multiple modedescriptor support
 *
 *    Rev 1.41   07 Feb 1997 15:33:58   EHOWARDX
 * Changed H245DelCapDescriptor to match changes to set_cap_descriptor.
 *
 *    Rev 1.40   27 Jan 1997 12:40:16   MANDREWS
 *
 * Fixed warnings.
 *
 *    Rev 1.39   09 Jan 1997 19:17:04   EHOWARDX
 *
 * Initialize lError to H245_ERROR_OK to prevent "may be uninitialized"
 * warning.
 *
 *    Rev 1.38   19 Dec 1996 17:18:50   EHOWARDX
 * Changed to use h245asn1.h definitions instead of _setof3 and _setof8.
 *
 *    Rev 1.37   12 Dec 1996 15:57:22   EHOWARDX
 * Master Slave Determination kludge.
 *
 *    Rev 1.36   11 Dec 1996 13:55:44   SBELL1
 * Changed H245Init parameters.
 *
 *    Rev 1.35   17 Oct 1996 18:17:36   EHOWARDX
 * Changed general string to always be Unicode.
 *
 *    Rev 1.34   14 Oct 1996 14:01:26   EHOWARDX
 * Unicode changes.
 *
 *    Rev 1.33   11 Oct 1996 15:19:56   EHOWARDX
 * Fixed H245CopyCap() bug.
 *
 *    Rev 1.32   28 Aug 1996 11:37:10   EHOWARDX
 * const changes.
 *
 *    Rev 1.31   19 Aug 1996 16:28:36   EHOWARDX
 * H245CommunicationModeResponse/H245CommunicationModeCommand bug fixes.
 *
 *    Rev 1.30   15 Aug 1996 15:19:46   EHOWARDX
 * First pass at new H245_COMM_MODE_ENTRY_T requested by Mike Andrews.
 * Use at your own risk!
 *
 *    Rev 1.29   08 Aug 1996 16:02:58   EHOWARDX
 *
 * Eliminated api_vers.h.
 * Changed H245Init Debug trace to eliminate API_VERSION.
 *
 *    Rev 1.28   19 Jul 1996 12:48:22   EHOWARDX
 *
 * Multipoint clean-up.
 *
 *    Rev 1.27   01 Jul 1996 22:13:42   EHOWARDX
 *
 * Added Conference and CommunicationMode structures and functions.
 *
 *    Rev 1.26   18 Jun 1996 14:53:16   EHOWARDX
 * Eliminated Channel parameter to MaintenanceLoopRelease.
 * Made Multiplex Capability mandatory -- H245SendTermCaps now returns
 * H245_ERROR_NO_MUX_CAPS if no Multiplex Capability has been defined.
 *
 *    Rev 1.25   14 Jun 1996 18:57:38   EHOWARDX
 * Geneva update.
 *
 *    Rev 1.24   10 Jun 1996 16:59:02   EHOWARDX
 * Moved init/shutdown of submodules to CreateInstance/InstanceUnlock.
 *
 *    Rev 1.23   06 Jun 1996 18:50:10   EHOWARDX
 * Equivalent of H.324 bugs #808 and 875 fixed.
 *
 *    Rev 1.22   05 Jun 1996 17:16:48   EHOWARDX
 * MaintenanceLoop bug fix.
 *
 *    Rev 1.21   04 Jun 1996 13:56:42   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.20   30 May 1996 23:38:52   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.19   29 May 1996 16:08:04   unknown
 * Fixed bug in copying nonstandard identifiers.
 *
 *    Rev 1.18   29 May 1996 15:19:48   EHOWARDX
 * Change to use HRESULT.
 *
 *    Rev 1.17   28 May 1996 14:25:12   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.16   21 May 1996 15:46:54   EHOWARDX
 * Fixed bugs in NonStandard messages using object identifier.
 *
 *    Rev 1.15   20 May 1996 22:17:54   EHOWARDX
 * Completed NonStandard Message and H.225.0 Maximum Skew indication
 * implementation. Added ASN.1 validation to H245SetLocalCap and
 * H245SetCapDescriptor. Check-in from Microsoft drop on 17-May-96.
 *
 *    Rev 1.14   20 May 1996 14:35:12   EHOWARDX
 * Got rid of asynchronous H245EndConnection/H245ShutDown stuff...
 *
 *    Rev 1.13   17 May 1996 14:53:38   EHOWARDX
 * Added calls to StartSystemClose() and EndSystemClose().
 *
 *    Rev 1.12   16 May 1996 19:40:30   EHOWARDX
 * Fixed multiplex capability bug.
 *
 *    Rev 1.11   16 May 1996 16:36:10   EHOWARDX
 * Fixed typo in H245SetCapDescriptor.
 *
 *    Rev 1.10   16 May 1996 16:14:06   EHOWARDX
 * Fixed backwards-compatibility problem in H245SetLocalCap
 * (CapId of zero should result in dynamically-allocated cap id being used)
 *
 *    Rev 1.9   16 May 1996 16:03:44   EHOWARDX
 * Fixed typo in H245SetCapDescriptor.
 *
 *    Rev 1.8   16 May 1996 15:58:32   EHOWARDX
 * Fine-tuning H245SetLocalCap/H245DelLocalCap/H245SetCapDescriptor/
 * H245DelCapDescriptor behaviour.
 *
 *    Rev 1.7   15 May 1996 21:49:46   unknown
 * Added call to InstanceLock() to increment lock count before call
 * to InstanceDelete() in H245EndConnectionPhase2().
 *
 *    Rev 1.6   15 May 1996 19:54:02   unknown
 * Fixed H245SetCapDescriptor.
 *
 *    Rev 1.5   14 May 1996 16:56:22   EHOWARDX
 * Last minute change from H245_IND_CAPDESC_T to H245_TOTCAPDESC_T.
 * H245EnumCaps() callback now uses H245_TOTCAPDESC_T instead
 * of separate H245_CAPDESCID_T and H245_CAPDESC_T for consistency.
 *
 *    Rev 1.4   14 May 1996 15:55:44   EHOWARDX
 * Added mux cap handling to H245DelLocalCap.
 *
 *    Rev 1.3   14 May 1996 14:06:06   EHOWARDX
 * Fixed abort from H245EnumCaps - if Cap Callback returns non-zero,
 * Cap Desc Callback is never called.
 *
 *    Rev 1.2   13 May 1996 23:16:42   EHOWARDX
 * Fixed remote terminal capability handling.
 *
 *    Rev 1.1   11 May 1996 20:32:52   EHOWARDX
 * Checking in for the night...
 *
 *    Rev 1.0   09 May 1996 21:06:06   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.25.1.10   09 May 1996 19:31:02   EHOWARDX
 * Redesigned thread locking logic.
 * Added new API functions.
 *
 *    Rev 1.25.1.9   01 May 1996 19:31:16   EHOWARDX
 * Added H245CopyCap(), H245FreeCap(), H245CopyMux(), H245FreeMux().
 * Changed H2250_xxx definitions for H.225.0 address types to H245_xxx.
 *
 *    Rev 1.25.1.8   27 Apr 1996 21:09:20   EHOWARDX
 * Changed Channel Numbers to words, added H.225.0 support.
 *
 *    Rev 1.25.1.7   25 Apr 1996 20:06:26   EHOWARDX
 * Moved setting of EndSessionPdu in EndSessionPhase1 to before call to api_fs
 *
 *    Rev 1.25.1.6   25 Apr 1996 17:57:00   EHOWARDX
 * Added dwTxPort argument to H245OpenChannel().
 *
 *    Rev 1.25.1.5   25 Apr 1996 16:51:00   EHOWARDX
 * Function changes as per H.245 API Changes spec.
 *
 *    Rev 1.25.1.4   24 Apr 1996 20:54:32   EHOWARDX
 * Added new OpenLogicalChannelAck/OpenLogicalChannelReject support.
 *
 *    Rev 1.25.1.3   19 Apr 1996 12:54:40   EHOWARDX
 * Updated to 1.30
 *
 *    Rev 1.25.1.2   15 Apr 1996 15:10:48   EHOWARDX
 * Updated to match Curt's current version.
 *
 *    Rev 1.25.1.1   03 Apr 1996 17:12:50   EHOWARDX
 * Integrated latest H.323 changes.
 *
 *    Rev 1.25.1.0   03 Apr 1996 15:53:42   cjutzi
 * Branched for H.323.
 *
 *    Rev 1.20   27 Mar 1996 15:25:34   cjutzi
 * - fixed a bug from this morning checkin dynamically allocating
 *   pdu's.. free_mux_tbl was getting called after pdu was free'd..
 *   this was a problem since the mux table pointer was in the pdu
 *
 *    Rev 1.19   27 Mar 1996 08:37:08   cjutzi
 *
 * - removed PDU from stack.. made them dynamically allocated
 *
 *    Rev 1.18   20 Mar 1996 14:47:32   cjutzi
 * - added ERROR H245_ERROR_NO_CAPDESC to SendTermCaps.
 *
 *    Rev 1.17   18 Mar 1996 15:23:16   cjutzi
 *
 *
 *
 *    Rev 1.16   13 Mar 1996 09:15:44   cjutzi
 *
 * - changed LLPCRITICAL_SECTION to CRITICAL_SECTION *
 *
 *    Rev 1.15   12 Mar 1996 15:51:48   cjutzi
 *
 * - implemented locking
 * - fixed callback bug w/ clenaup on term caps..
 * - implemented End Session
 * - fixed shutdown
 *
 *    Rev 1.14   08 Mar 1996 14:02:48   cjutzi
 *
 * - removed H245SetSimultaneous stuff..
 * - added H245SetCapDescriptor Stuff..
 * - completeed MuxTable Entry Stuff.
 * - required H223 -or- some portion of MuxCapbilities to be
 *   there before you issue SendCaps..
 * - NOTE: need to inforce the Simultaneous capabilities in
 *   the same mannor..
 *
 *    Rev 1.13   05 Mar 1996 17:35:38   cjutzi
 *
 * - implemented SendMultiplexTable..
 * - removed bcopy/bzero and changed free call
 * - added master slave indication
 *
 *    Rev 1.12   01 Mar 1996 13:48:24   cjutzi
 *
 * - added hani's new fsm id's
 * - added some support for release on close request.
 *
 *    Rev 1.11   29 Feb 1996 17:27:10   cjutzi
 *
 * - bi-directional channel working..
 *
 *    Rev 1.10   29 Feb 1996 08:35:52   cjutzi
 *
 * - added p_ossWorld to initialization
 *
 *    Rev 1.9   27 Feb 1996 13:30:18   cjutzi
 *
 * - fixed master slave problem with conf_ind and tracker type
 * - removed RSP_LCSE in close channel resp
 *
 *    Rev 1.8   26 Feb 1996 17:23:18   cjutzi
 *
 * - MiscCommand API added
 * - Fixed Assert for H245Init.. was not NULL'n out the pointers for the
 *   context blocks..
 *
 *    Rev 1.7   26 Feb 1996 11:05:16   cjutzi
 *
 * - added simultaneous caps.. and fixed bugs..
 *   lot's of changes..
 *
 *    Rev 1.6   16 Feb 1996 13:01:08   cjutzi
 *
 * - got open / close / request close working in both directions.
 *
 *    Rev 1.5   15 Feb 1996 14:42:54   cjutzi
 *
 * - fixed trace level bind w/ Instance.. no other change but had to
 *   add when h245deb.c when in..
 *
 *
 *    Rev 1.4   15 Feb 1996 10:50:54   cjutzi
 *
 * - termcaps working
 * - changed API interface for MUX_T
 * - changed callback or IND_OPEN
 * - changed constants IND_OPEN/IND_OPEN_NEEDRSP etc..
 * - cleaned up the open.. (not complete yet.. )
 *
 *    Rev 1.3   09 Feb 1996 16:58:36   cjutzi
 *
 * - cleanup.. and some fixes..
 * - added and or changed headers to reflect the log of changes
 *
 *****************************************************************************/

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/****                                                                   *****/
/****                   NOTES TO THE READER                             *****/
/****                                                                   *****/
/**** This program has been put together using a a screen which is      *****/
/**** wider than 80 characters.. It is best if a similar screen size is *****/
/**** used.. Of course emacs is my preference but 80 col screens will   *****/
/**** cause you much frustration..                                      *****/
/****                                                                   *****/
/**** Tabs are set to 8                                                 *****/
/****                                                                   *****/
/**** NOTE:                                                             *****/
/****           Headers are documented, however they may or may not     *****/
/****   coorispond to reality.  See the H245Spec.doc from Intel for the *****/
/****   current :-> H245 specification                                  *****/
/****                                                                   *****/
/**** DISCLAMER:                                                        *****/
/****                                                                   *****/
/****   Since this code wasn't developed in Word 7.0, I am fully        *****/
/****   responsable for all spelling mistakes in the comments. Please   *****/
/****   disregard the spelling mistakes.. or fix them, if you are       *****/
/****   currently modifying the code.                                   *****/
/****                                                                   *****/
/****                           - Thankyou                              *****/
/****                                                                   *****/
/****                                   Curt Jutzi                      *****/
/****                                   Oregon, USA                     *****/
/****                                                                   *****/
/****************************************************************************/
/****************************************************************************/
/****************************************************************************/

#ifndef STRICT
#define STRICT
#endif

#include "precomp.h"

/***********************/
/*    H245 INCLUDES    */
/***********************/
#define H245DLL_EXPORT
#include "h245api.h"
#include "h245com.h"
#include "h245sys.x"

#include "api_util.x"
#include "pdu.x"
#include "fsmexpor.h"
#include "api_debu.x"
#include "sr_api.h"
#include "h245deb.x"



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245Init
 *
 * DESCRIPTION
 *
 *       H245_INST_T  H245Init (
 *                              H245_CONF_T               Configuration,
 *                              DWORD                     dwH245PhysId,
 *                              DWORD                     dwLinkLayerPhysId,
 *                              DWORD                     dwPreserved,
 *                              H245_CONF_IND_CALLBACK_T  Callback
 *                              )
 *      Description:
 *
 *              Called to create an H.245 instance and its related sublayers
 *              (e.g., SRP). This function must be called before any other
 *              API calls may be called  The current H.245 implementation can
 *              only have, at most, one client. Therefore H245Init can only be
 *              called once per physical ID.
 *      Input
 *
 *              Configuration   Indicates the type of configuration the client
 *                              wishes to establish, e.g.  H.324, H.323, H.310,
 *                              or DSVD.
 *              dwH245PhysId    Parameter identifying the H245 entry
 *              pdwLinkLayerPhysId
 *                              Output parameter identifying the linkLayer
 *                              entry.
 *              dwPreserved     Parameter that may be used by H.245 client to
 *                              provide context, passed back to client in all
 *                              confirms and indications.
 *              Callback        Callback routine supplied by the client which
 *                              will be used by the H.245 subsystem to convey
 *                              confirm and indication messages back to the
 *                              client.
 *      Call Type:
 *
 *              Synchronous
 *
 *      Return Values:
 *
 *              Return value of 0 indicates Failure
 *              Return value of non 0 is a valid H245_INST_T
 *
 *      Errors:
 *              N/A
 *
 *      See Also:
 *              H245EndSession
 *              H245Shutdown
 *
 *
 *****************************************************************************/

H245DLL H245_INST_T
H245Init                (
                         H245_CONFIG_T            Configuration,
                         unsigned long            dwH245PhysId,
                         unsigned long            *pdwLinkLayerPhysId,
                         DWORD_PTR                dwPreserved,
                         H245_CONF_IND_CALLBACK_T CallBack,
                         unsigned char            byTerminalType
                        )
{
  register struct InstanceStruct *pInstance;
  HRESULT                         lError;

  H245TRACE(dwH245PhysId,4,"H245Init(%d, 0x%x, 0x%x, 0x%x, %d) <-",
            Configuration, dwH245PhysId, dwPreserved, CallBack, byTerminalType);

  switch (Configuration)
  {
  case H245_CONF_H324:
  case H245_CONF_H323:
    break;

  default:
    H245TRACE(dwH245PhysId,1,"H245Init -> Invalid Configuration %d", Configuration);
    return H245_INVALID_ID;
  } // switch

  if (CallBack == NULL)
  {
    H245TRACE(dwH245PhysId,1,"H245Init -> Null CallBack");
    return H245_INVALID_ID;
  }

  /* see if this physical identifier has been initialized already */
  // Send down H245PhysId that was input.
  pInstance = InstanceCreate(dwH245PhysId, Configuration);
  if (pInstance == NULL)
  {
    return H245_INVALID_ID;
  }

  // Get the linkLayer PhysId.
  *pdwLinkLayerPhysId = pInstance->SendReceive.hLinkLayerInstance;

  // Initialize instance API structure
  pInstance->API.dwPreserved     = dwPreserved;
  pInstance->API.ConfIndCallBack = CallBack;

  // Initialize instance FSM structure
  pInstance->StateMachine.sv_TT     = byTerminalType;
  pInstance->StateMachine.sv_STATUS = INDETERMINATE;

  H245TRACE(pInstance->dwInst,4,"H245Init -> %d", pInstance->dwInst);
  lError = pInstance->dwInst;
  InstanceUnlock(pInstance);
  return lError;
} // H245Init()


/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245EndSession
 *
 * DESCRIPTION
 *
 *              Yes.. this should be explained.. Since Send Receive needs
 *              to flush some buffers and send out an End Session.. what we've
 *              hopefully done is a 2 phase shut down...
 *
 *              call StartSessionClose which initiates the flush..
 *              when flush is complete EndSessionPhase1 is called..
 *              The end session pdu is then placed in the send queue..
 *              When the End Session Pdu is sent.. the EndSession Phase
 *              2 is called, and the result is sent up to the client..
 *
 *              Hope that helps..
 *
 *
 *      HRESULT H245EndSession ( H245_INST_T           dwInst,
 *                                 H245_ENDSESSION_T     Mode,
 *                                 H245_NONSTANDARD_T   *pNonStd (*optional*)
 *                               )
 *
 *      Description:
 *              Called to shutdown the peer to peer session between this H.245
 *              session and the remote peers H.245 layer.
 *
 *              It will terminate by issuing an EndSession command to the
 *              remote side and call end session for all the H.245 subsystems.
 *              All resources are returned; therefore no further action is
 *              permitted, except H245ShutDown until another H245Init API call
 *              is made.
 *
 *      input
 *              dwInst          Instance handle returned by H245Init
 *              Mode            Mode which the client wishes to terminat
 *                              the session
 *              pNonStd         If the mode is non standard this is the non
 *                              standard parameter passes to the remote client.
 *                              This parameter is optional, and should be set
 *                              to NULL if not used
 *
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_PARAM
 *              H245_ERROR_INVALID_INST
 *              H245_ERROR_NOT_CONNECTED
 *      See Also:
 *              H245Shutdown
 *              H245Init
 *
 *****************************************************************************/

H245DLL HRESULT
H245EndSession          (
                         H245_INST_T                    dwInst,
                         H245_ENDSESSION_T              Mode,
                         const H245_NONSTANDARD_PARAMETER_T * pNonStd
                        )
{
  register struct InstanceStruct *pInstance;
  register MltmdSystmCntrlMssg   *pPdu;
  HRESULT                          lError;

  H245TRACE (dwInst,4,"H245EndSession <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245EndSession -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  /* system should be in either connecting or connected */

  switch (pInstance->API.SystemState)
  {
  case APIST_Connecting:
  case APIST_Connected:
    break;

  default:
    H245TRACE (dwInst,1,"H245EndSession -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
    InstanceUnlock(pInstance);
    return H245_ERROR_NOT_CONNECTED;
  }

  // Allocate the PDU buffer
  pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    H245TRACE (dwInst,1,"H245EndSession -> %s",map_api_error(H245_ERROR_NOMEM));
    InstanceUnlock(pInstance);
    return H245_ERROR_NOMEM;
  }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  // Build the PDU
  lError = pdu_cmd_end_session (pPdu, Mode, pNonStd);

  if (lError == H245_ERROR_OK)
  {
    // Send the PDU
    lError = FsmOutgoing(pInstance, pPdu, 0);
  }

  // Free the PDU buffer
  MemFree(pPdu);

  if (lError != H245_ERROR_OK)
  {
    H245TRACE (dwInst,1,"H245EndSession -> %s",map_api_error(lError));
  }
  else
  {
    H245TRACE (dwInst,4,"H245EndSession -> OK");
    pInstance->API.SystemState = APIST_Disconnected;
  }
  InstanceUnlock(pInstance);
  return lError;
} // H245EndSession()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245ShutDown
 *
 * DESCRIPTION
 *
 *      HRESULT  H245Shutdown ( H245_INST_T      dwInst);
 *
 *      Description:
 *
 *              Called to terminate the specified instance of H.245. If there
 *              is currently an active session (see H245Init) then the H.245
 *              subsystem will issue an EndSession to the other side and wait
 *              for H.245 sublayer termination notifications before it queues
 *              Callback confirm.
 *
 *              This call will force the client to issue another H245Init
 *              before it can use any of the H.245 API functions.
 *
 *      Input
 *              dwInst                  Instance handle returned by H245Init
 *
 *      Call Type:
 *              asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_INVALID_INST dwInst is not a valid instance handle
 *
 *      See Also:
 *              H245Init
 *
 *****************************************************************************/

H245DLL HRESULT
H245ShutDown            (H245_INST_T            dwInst)
{
  register struct InstanceStruct *pInstance;
  register HRESULT                lError;

  H245TRACE (dwInst,4,"H245ShutDown <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245ShutDown -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  switch (pInstance->API.SystemState)
  {
  case APIST_Connecting:
  case APIST_Connected:
    lError = H245EndSession(dwInst,H245_ENDSESSION_DISCONNECT,NULL);
    break;

  default:
    lError = H245_ERROR_OK;
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245ShutDown -> %s", map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245ShutDown -> OK");
  InstanceDelete  (pInstance);
  return H245_ERROR_OK;
} // H245ShutDown()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245InitMasterSlave
 *
 * DESCRIPTION
 *
 *      HRESULT  H245InitMasterSlave ( H245_INST_T       dwInst,
 *                                    DWORD              dwTransId )
 *
 *      Description:
 *              Called to initiate the H.245 master slave negotiation.
 *              Upon completion of the negotiation the local client will
 *              receive an H245_CONF_INIT_MSTSLV message indicating the
 *              result of the negotiation.
 *      Input
 *              dwInst          Instance handle returned by
 *                              H245GetInstanceId
 *              dwTransId       User supplied object used to identify this
 *                              request in the asynchronous response to
 *                              this call.
 *
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Callbacks:
 *              H245_CONF_INIT_MSTSLV
 *
 *      Errors:
 *              H245_ERROR_OK           Master Slave Determination started
 *              H245_ERROR_INPROCESS    Master Slave Determination currently
 *                                      in process
 *              H245_ERROR_NOMEM
 *              H245_ERROR_INPROCESS    In process
 *              H245_ERROR_INVALID_INST dwInst is not a valid instance handle
 *
 *      See Also:
 *              H245Init
 *
 *      callbacks
 *              H245_IND_MSTSLV
 *
 *
 *****************************************************************************/

H245DLL HRESULT
H245InitMasterSlave     (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId
                        )
{
  struct InstanceStruct *pInstance;
  Tracker_T             *pTracker;
  HRESULT               lError;
  MltmdSystmCntrlMssg   *pPdu = NULL;

  /* check for valid instance handle */

  H245TRACE (dwInst,4,"H245InitMasterSlave <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245InitMasterSlave -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* if the transaction is in process.. tell client */
  if (pInstance->API.MasterSlave == APIMS_InProcess)
    {
      H245TRACE (dwInst,1,"H245InitMasterSlave -> %s",map_api_error(H245_ERROR_INPROCESS));
      InstanceUnlock(pInstance);
      return H245_ERROR_INPROCESS;
    }

  /* if the transaction is already complete */
  if (pInstance->API.MasterSlave != APIMS_Undef)
  {
    if (pInstance->API.ConfIndCallBack)
    {
      H245_CONF_IND_T    confirm_ind_event;
      confirm_ind_event.Kind = H245_CONF;
      confirm_ind_event.u.Confirm.Confirm       = H245_CONF_INIT_MSTSLV;
      confirm_ind_event.u.Confirm.dwPreserved   = pInstance->API.dwPreserved;
      confirm_ind_event.u.Confirm.dwTransId     = dwTransId;
      confirm_ind_event.u.Confirm.Error         = H245_ERROR_OK;
      confirm_ind_event.u.Confirm.u.ConfMstSlv  =
        (pInstance->API.MasterSlave == APIMS_Master) ? H245_MASTER : H245_SLAVE;
      (*pInstance->API.ConfIndCallBack)(&confirm_ind_event, NULL);
    }
    H245TRACE (dwInst,4,"H245InitMasterSlave -> OK");
    InstanceUnlock(pInstance);
    return H245_ERROR_OK;
  }

  /* get somthing to keep track of what the heck you're doing.. */
  if (!(pTracker = alloc_link_tracker (pInstance,
                                        API_MSTSLV_T,
                                        dwTransId,
                                        API_ST_WAIT_RMTACK,
                                        API_CH_ALLOC_UNDEF,
                                        API_CH_TYPE_UNDEF,
                                        0,
                                        H245_INVALID_CHANNEL,
                                        H245_INVALID_CHANNEL,
                                        0)))
    {
      H245TRACE(dwInst,1,"H245InitMasterSlave -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }

  if (!(pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(MltmdSystmCntrlMssg))))
    {
      H245TRACE (dwInst,1,"H245InitMasterSlave -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }

  /* set master slave in process */
  pInstance->API.SystemState = APIST_Connecting;
  pInstance->API.MasterSlave = APIMS_InProcess;

  memset(pPdu, 0, sizeof(*pPdu));
  pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
  pPdu->u.MltmdSystmCntrlMssg_rqst.choice = masterSlaveDetermination_chosen;

  lError = FsmOutgoing(pInstance, pPdu, (DWORD_PTR)pTracker);
  MemFree(pPdu);
  if (lError != H245_ERROR_OK)
  {
    unlink_dealloc_tracker (pInstance, pTracker);
    H245TRACE (dwInst,1,"H245InitMasterSlave -> %s",map_api_error(lError));
  }
  else
    H245TRACE (dwInst,4,"H245InitMasterSlave -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245InitMasterSlave()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245SetLocalCap
 *
 * DESCRIPTION
 *
 *       HRESULT H245SetLocalCap (
 *                              H245_INST_T      dwInst,
 *                              H245_TOTCAP_T   *pTotCap,
 *                              H245_CAPID_T    *pCapId
 *                              )
 *
 *      Description:
 *              This function allows the client to define a specific
 *              capability to the H.245 subsystem. When this function is
 *              called a new capability entry is made in the local capability
 *              table.  The returned value in *pCapId can be used by the client
 *              to refer to that registered capability.  NULL in the *pCapId
 *              is valid.
 *
 *              This call is used for both client (Audio / Video / Data / Mux)
 *              capabilities.  It is not used for setting capability descriptors.
 *
 *      Note:
 *              7 This function does not communicate this update to the
 *                remote peer until the client calls H245SendTermCaps.
 *              7 pTotCap->CapId is of no significance in this call.
 *
 *              pTotCap->CapId is of no significance in this call and should
 *              be set to 0
 *
 *              if DataType of H245_DATA_MUX  is used  (i.e. in setting the
 *              mux table capabilities) No capid is returned, and it can not
 *              be used in H245SetCapDescritptor  api call.
 *
 *      Input
 *              dwInst  Instance handle returned by GetInstanceId
 *                      pTotCap Capability set defining the capability
 *
 *              Note:   pTotCap->CapId is of no significance in this call.
 *
 *      output
 *              pCapId  Capability id which client can use to reference
 *                      this capability in the H.245 subsystem.  This can
 *                      be NULL, in this case nothing is returned.
 *
 *      Call Type:
 *              Synchronous
 *
 *      Return Values:
 *              If pCap is not null, the local cap table id is returned
 *              to the client in this parameter.
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_PARAM        There was an invalid parameter passed
 *              H245_ERROR_MAXTBL       Entry not made because local cap table
 *                                      is full
 *              H245_ERROR_INVALID_INST dwInst is not a valid instance handle
 *
 *      See Also:
 *              H245DelLocalCap
 *              H245EnumCaps
 *              H245SetCapDescriptor
 *
 *
 * ASSUMPTION:
 *                      pTotCap->CapId  will be set to H245_INVALID_CAPID
 *                      pTotCap->Dir    will be set
 *
 *****************************************************************************/

H245DLL HRESULT
H245SetLocalCap         (
                         H245_INST_T            dwInst,
                         H245_TOTCAP_T *        pTotCap,
                         H245_CAPID_T  *        pCapId
                        )
{
  register struct InstanceStruct *pInstance;
  struct TerminalCapabilitySet   *pTermCapSet;
  HRESULT                          lError;

  H245TRACE (dwInst,4,"H245SetLocalCap <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245SetLocalCap -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  /* check for valid parameters */
  if (pTotCap == NULL ||
      pCapId  == NULL ||
	  ((*pCapId > H245_MAX_CAPID) && (*pCapId != H245_INVALID_CAPID)) ||
      pTotCap->Dir < H245_CAPDIR_LCLRX   ||
      pTotCap->Dir > H245_CAPDIR_LCLRXTX ||
      pTotCap->ClientType < H245_CLIENT_NONSTD ||
      pTotCap->ClientType > H245_CLIENT_MUX_H2250)
  {
    H245TRACE (dwInst,1,"H245SetLocalCap -> %s",map_api_error(H245_ERROR_PARAM));
    InstanceUnlock(pInstance);
    return H245_ERROR_PARAM;
  }

  pTermCapSet = &pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet;

  // Don't trust the user filled-in data type!
  pTotCap->DataType = DataTypeMap[pTotCap->ClientType];

  /* if it's a MUX type handle here */
  if (pTotCap->DataType == H245_DATA_MUX)
  {
    // Add multiplex capability
    if (pTermCapSet->bit_mask & multiplexCapability_present)
    {
      del_mux_cap(pTermCapSet);
    }

    *pCapId = pTotCap->CapId = 0;
    lError = set_mux_cap(pInstance, pTermCapSet, pTotCap);

#if defined(_DEBUG)
    if (lError == H245_ERROR_OK)
    {
      // Validate mux capability
      if (check_pdu(pInstance, &pInstance->API.PDU_LocalTermCap))
      {
        // Bad mux capability - delete it
        del_mux_cap(pTermCapSet);
        lError = H245_ERROR_ASN1;
      }
    }
#endif // (DEBUG)
  }
  else if (*pCapId == 0 || *pCapId == H245_INVALID_CAPID)
  {
    // Assign the next never-used cap id
    if (pInstance->API.LocalCapIdNum == H245_INVALID_CAPID)
    {
      // All possible capability identifiers have been assigned
      H245TRACE (dwInst,1,"H245SetLocalCap -> %s",map_api_error(H245_ERROR_MAXTBL));
      InstanceUnlock(pInstance);
      return H245_ERROR_MAXTBL;
    }
    *pCapId = pInstance->API.LocalCapIdNum;

    /* insert in the new capability in the local capability set table */
    pTotCap->CapId = *pCapId;
    lError = set_capability(pInstance, pTermCapSet, pTotCap);

#if defined(_DEBUG)
    if (lError == H245_ERROR_OK)
    {
      // Validate capability
      if (check_pdu(pInstance, &pInstance->API.PDU_LocalTermCap))
      {
        // Bad capability - delete it
        H245DelLocalCap(dwInst, *pCapId);
        lError = H245_ERROR_ASN1;
      }
    }
#endif // (DEBUG)

    if (lError == H245_ERROR_OK)
      pInstance->API.LocalCapIdNum++;
  }
  else
  {
    /* insert in the new capability in the local capability set table */
    pTotCap->CapId = *pCapId;
    lError = set_capability(pInstance, pTermCapSet, pTotCap);

#if defined(_DEBUG)
    if (lError == H245_ERROR_OK)
    {
      // Validate capability
      if (check_pdu(pInstance, &pInstance->API.PDU_LocalTermCap))
      {
        // Bad capability - delete it
        H245DelLocalCap(dwInst, *pCapId);
        lError = H245_ERROR_ASN1;
      }
    }
#endif // (DEBUG)
  }

  if (lError != H245_ERROR_OK)
  {
    H245TRACE (dwInst,1,"H245SetLocalCap -> %s",map_api_error(lError));
    pTotCap->CapId = *pCapId = H245_INVALID_CAPID;
  }
  else
  {
    H245TRACE (dwInst,4,"H245SetLocalCap -> OK");
  }
  InstanceUnlock(pInstance);
  return lError;
} // H245SetLocalCap()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245DelLocalCap
 *
 * DESCRIPTION  Delete Local Cap simply disables the cap.. it
 *              will not be updated until the client issues
 *              H245SendTermCaps
 *
 *
 *       HRESULT H245DelLocalCap(
 *                              H245_INST_T     dwInst,
 *                              H245_CAPID_T    CapId
 *                              )
 *
 *      Description:
 *              This function allows the client to delete a specific
 *              capability id in the H.245 subsystem.
 *
 *              Note: This function does not communicate this update
 *              to the remote peer until the client calls H245SendTermCaps.
 *
 *      Input
 *              dwInst  Instance handle returned by H245GetInstanceId
 *              CapId   Cap Id the client wishes to remove from the
 *              capability table.
 *
 *              If an error occurs no action is taken and the CapId the
 *              client wished to delete is not changed.
 *
 *      Call Type:
 *              Synchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Errors:
 *              H245_ERROR_OK           Capability deleted
 *              H245_ERROR_INVALID_INST dwInst is not a valid instance handle
 *
 *      See Also:
 *              H245SetLocalCap
 *              H245SendTermCaps
 *              H245EnumCaps
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245DelLocalCap         (
                         H245_INST_T            dwInst,
                         H245_CAPID_T           CapId
                        )
{
  register struct InstanceStruct *pInstance;
  struct TerminalCapabilitySet   *pTermCapSet;
  CapabilityTableLink             pCapLink;
  HRESULT                         lError = H245_ERROR_OK;

  H245TRACE (dwInst,4,"H245DelLocalCap <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245DelLocalCap -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pTermCapSet = &pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet;

  if (CapId == 0)
  {
    // Delete multiplex capability
    del_mux_cap(pTermCapSet);
  }
  else
  {
    /* (TBC) if I delete my capability id.. what about simultaneous caps ?? */
    /* should I go through the list and deactivate them ??                */
    pCapLink = find_capid_by_entrynumber (pTermCapSet, CapId);
    if (pCapLink)
    {
      // Delete terminal capability
      disable_cap_link (pCapLink);
    }
    else
    {
      lError = H245_ERROR_PARAM;
    }
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245DelLocalCap -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245DelLocalCap -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245DelLocalCap()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245SetCapDescriptor
 *
 * DESCRIPTION
 *
 *      HRESULT H245SetCapDescriptor (
 *                                  H245_INST_T       dwInst,
 *                                  H245_CAPDESC_T   *pCapDesc,
 *                                  H245_CAPDESCID_T *pCapDescId (* Optional *)
 *                                  )
 *      Description:
 *              This procedure is called to set local capability descriptors.
 *              It will return a capability descriptor id in the parameter
 *              *pCapDescId if it is non null.
 *
 *              Note:
 *                These capabilities are communicated via the H245SendTermCaps
 *                API call.  Any updates to the CapDescriptor table (either
 *                additions or deletions ) will not be communicated to the
 *                remote side until the H245SendTermCaps call is made.
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              CapDesc         This is the capability Descriptor you wish
 *                              to set
 *      Output
 *              pCapDescId      optional: Capability id that will be returned.
 *
 *      Call Type:
 *              Synchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_INVALID_CAPID Capid used in CapDesc was not
 *                                       registred
 *              H245_ERROR_MAXTB         Out of table space to store Descriptor
 *              H245_ERROR_PARAM         Descriptor is too long or not valid
 *              H245_ERROR_NOMEM
 *              H245_ERROR_INVALID_INST
 *
 *      See Also:
 *              H245DelCapDescriptor
 *              H245SendTermCaps
 *
 * ASSUMES:
 *              SimCapId is the array entry point in the apabilityDescriptors
 *              array.. this has a limitation, in that you can never wrap the
 *              array at 256.. this will be cleaned up when array is turned into
 *              linked list.
 *
 *****************************************************************************/

H245DLL HRESULT
H245SetCapDescriptor    (
                         H245_INST_T            dwInst,
                         H245_CAPDESC_T        *pCapDesc,
                         H245_CAPDESCID_T      *pCapDescId
                        )
{
  register struct InstanceStruct *pInstance;
  HRESULT                          lError;

  H245TRACE (dwInst,4,"H245SetCapDescriptor <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245SetCapDescriptor -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  /* must have capdescriptor &&   */
  /* length must be less than 256 */
  if (pCapDesc == NULL ||
      pCapDesc->Length >= 256 ||
      pCapDescId == NULL)
  {
    H245TRACE (dwInst,1,"H245SetCapDescriptor -> %s",map_api_error(H245_ERROR_PARAM));
    InstanceUnlock(pInstance);
    return H245_ERROR_PARAM;
  }

  if (*pCapDescId >= 256)
  {
    // Assign the next never-used cap id
    if (pInstance->API.LocalCapDescIdNum >= 256)
    {
      // All possible capability identifiers have been assigned
      H245TRACE (dwInst,1,"H245CapDescriptor -> %s",map_api_error(H245_ERROR_MAXTBL));
      InstanceUnlock(pInstance);
      return H245_ERROR_MAXTBL;
    }
    *pCapDescId = pInstance->API.LocalCapDescIdNum;

    /* insert in the new capability descriptor in the local capability descriptor table */
    lError = set_cap_descriptor(pInstance, pCapDesc, pCapDescId,
                                  &pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet);
#if defined(_DEBUG)
    if (lError == H245_ERROR_OK)
    {
      // Validate Capability Descriptor
      if (check_pdu(pInstance, &pInstance->API.PDU_LocalTermCap))
      {
        // Capability Descriptor Invalid - delete it
        H245DelCapDescriptor(dwInst, *pCapDescId);
        lError = H245_ERROR_ASN1;
      }
    }
#endif // (DEBUG)
    if (lError == H245_ERROR_OK)
      pInstance->API.LocalCapDescIdNum++;
  }
  else
  {
    /* insert in the new capability in the local capability set table */
    lError = set_cap_descriptor(pInstance, pCapDesc, pCapDescId,
                                  &pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet);
#if defined(_DEBUG)
    if (lError == H245_ERROR_OK)
    {
      // Validate Capability Descriptor
      if (check_pdu(pInstance, &pInstance->API.PDU_LocalTermCap))
      {
        // Capability Descriptor Invalid - delete it
        H245DelCapDescriptor(dwInst, *pCapDescId);
        lError = H245_ERROR_ASN1;
      }
    }
#endif // (DEBUG)
  }

  if (lError != H245_ERROR_OK)
  {
    H245TRACE (dwInst,1,"H245CapDescriptor -> %s",map_api_error(lError));
    *pCapDescId = H245_INVALID_CAPDESCID;
  }
  else
  {
    H245TRACE (dwInst,4,"H245CapDescriptor -> OK");
  }
  InstanceUnlock(pInstance);
  return lError;
} // H245SetCapDescriptor()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245DelCapDescriptor
 *
 * DESCRIPTION
 *
 *       HRESULT H245DelCapDescriptor (
 *                                   H245_INST_T          dwInst,
 *                                   H245_CAPDESCID_T     CapDescId
 *                                   )
 *      Description:
 *              This procedure is called to delete local capability descriptors.
 *
 *              Note:
 *                      These capabilities are communicated via the
 *                      H245SendTermCaps API call.  Any updates to the
 *                      CapDescriptor table (either additions or deletions )
 *                      will not be communicated to the remote side until the
 *                      H245SendTermCaps call is made.
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              CapDescId       This is the capability Descriptor you wish
 *                              to delete
 *      Call Type:
 *              Synchronous
 *
 *      Return Values:
 *              See Errors
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_INVALID_INST
 *
 *      See Also:
 *              H245SetCapDescriptor
 *              H245SendTermCaps
 *
 * ASSUMES:
 *
 *              SimCapId is the array entry point in the apabilityDescriptors
 *              array.. this has a limitation, in that you can never wrap the
 *              array at 256.. this will be cleaned up when array is turned into
 *              linked list.
 *
 *
 *****************************************************************************/

H245DLL HRESULT
H245DelCapDescriptor    (
                         H245_INST_T            dwInst,
                         H245_CAPDESCID_T       CapDescId
                        )
{
  register struct InstanceStruct *pInstance;
  CapabilityDescriptor           *p_cap_desc;
  struct TerminalCapabilitySet   *pTermCapSet;
  unsigned int                    uId;
  H245TRACE (dwInst,4,"H245DelCapDescriptor <-");

  if (CapDescId >= 256)
  {
    H245TRACE(dwInst,1,"API:H24DelCapDescriptor -> Invalid cap desc id %d",CapDescId);
    return H245_ERROR_INVALID_CAPDESCID;
  }

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"API:H24DelCapDescriptor -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  /* get pointer to Capability Descriptor */
  p_cap_desc = NULL;
  pTermCapSet = &pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet;
  for (uId = 0; uId < pTermCapSet->capabilityDescriptors.count; ++uId)
  {
    if (pTermCapSet->capabilityDescriptors.value[uId].capabilityDescriptorNumber == CapDescId)
    {
      p_cap_desc = &pTermCapSet->capabilityDescriptors.value[uId];
      break;
    }
  }
  if (p_cap_desc == NULL ||
      p_cap_desc->smltnsCpblts == NULL ||
      (p_cap_desc->bit_mask & smltnsCpblts_present) == 0)
  {
    H245TRACE(dwInst,1,"API:H24DelCapDescriptor -> Invalid cap desc id %d",CapDescId);
    InstanceUnlock(pInstance);
    return H245_ERROR_INVALID_CAPDESCID;
  }

  /* free up the list */
  dealloc_simultaneous_cap (p_cap_desc);

  /* (TBC) what if you've removed the last simultaneous cap ? */

  /* in this case.. the count does not go down.. it simply    */
  /* removes the cap descriptor bit from the table..          */

  H245TRACE (dwInst,4,"H245DelCapDescriptor -> OK");
  InstanceUnlock(pInstance);
  return H245_ERROR_OK;
} // H245DelCapDescriptor()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245SendTermCaps
 *
 * DESCRIPTION
 *
 *      HRESULT
 *      H245SendTermCaps (
 *                      H245_INST_T             dwInst,
 *                      DWORD                   dwTransId
 *                      )
 *
 *      Description:
 *
 *              Called to send terminal capabilities to the remote H.245 peer.
 *              When remote capabilities are receive the client will be
 *              notified by the H245_IND_CAP indication. When remote side has
 *              acknowledged the local terminal capabilities and has responded
 *              with their terminal capabilities the client will receive an
 *              H245_CONF_ TERMCAP.  Between H245Init and H245SendTermCap the
 *              client may call H245SetLocalCap to register capabilities.
 *              These capabilities will not be registered to the remote side
 *              until H245SendTermCap has been called.
 *
 *              Note: As required by the H245 specification, Mutliplex
 *                    capabilities, and Capability descriptors must be
 *                    loaded before the first capability PDU is sent.
 *
 *                    Once H245SendTermCap is called, any subsequent calls to
 *                    H245SetLocalTermCap will result in that capability being
 *                    communicated to the remote H.245 peer.
 *
 *      Input
 *              dwInst                  Instance handle returned by
 *                                      H245GetInstanceId
 *              dwTransId               User supplied object used to identify
 *                                      this request in the asynchronous
 *                                      response to this call.
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Callbacks:
 *              H245_CONF_TERMCAP
 *
 *      Errors:
 *              H245_ERROR_OK           Function succeeded
 *              H245_ERROR_NOMEM
 *              H245_ERROR_INVALID_INST dwInst is not a valid instance handle
 *              H245_ERROR_NO_MUX_CAPS  no Mux capabilities have been set yet
 *              H245_ERROR_NO_CAPDESC   no Capability Descriptors have been set
 *
 *      See Also:
 *              H245SetLocalCap
 *              H245Init
 *
 *      callbacks
 *
 *              H245_IND_CAP
 *              H245_IND_CAPDESC
 *              H245_IND_CAP_DEL
 *              H245_IND_CAPDESC_DEL
 *
 *
 *****************************************************************************/

H245DLL HRESULT
H245SendTermCaps        (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId
                        )
{
  struct InstanceStruct  *pInstance;
  Tracker_T              *pTracker;
  HRESULT                 lError;
  unsigned char			  TermCapData = TRUE;
  struct TerminalCapabilitySet_capabilityTable  TermCap = {0};

  H245TRACE(dwInst,4,"H245SendTermCaps <-");

  /* check for valid instance handle */

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE(dwInst,1,"H245SendTermCaps -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* must have mux parameters set */
  if ((pInstance->API.PDU_LocalTermCap.TERMCAPSET.bit_mask & multiplexCapability_present) == 0)
    {
      H245TRACE(dwInst,1,"H245SendTermCaps -> %s",map_api_error(H245_ERROR_NO_MUX_CAPS));
      InstanceUnlock(pInstance);
      return H245_ERROR_NO_MUX_CAPS;
    }

  /* must have capability descriptors set */
  if (!(pInstance->API.PDU_LocalTermCap.TERMCAPSET.bit_mask & capabilityDescriptors_present))
    {
      H245TRACE(dwInst,1,"H245SendTermCaps -> %s",map_api_error(H245_ERROR_NO_CAPDESC));
      InstanceUnlock(pInstance);
      return H245_ERROR_NO_CAPDESC;
    }

  if (!(pTracker = alloc_link_tracker (pInstance,
                                        API_TERMCAP_T,
                                        dwTransId,
                                        API_ST_WAIT_RMTACK,
                                        API_CH_ALLOC_UNDEF,
                                        API_CH_TYPE_UNDEF,
                                        0,
                                        H245_INVALID_CHANNEL, H245_INVALID_CHANNEL,
                                        0)))
    {
      H245TRACE(dwInst,1,"H245SendTermCaps -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }

  pdu_req_termcap_set (&pInstance->API.PDU_LocalTermCap, 0);
  TermCap.next = pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.capabilityTable;
  pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.capabilityTable = &TermCap;
  TermCap.value.bit_mask = capability_present;
  TermCap.value.capabilityTableEntryNumber = pInstance->API.LocalCapIdNum;
  TermCap.value.capability.choice = Capability_nonStandard_chosen;
  TermCap.value.capability.u.Capability_nonStandard.nonStandardIdentifier.choice = h221NonStandard_chosen;
  TermCap.value.capability.u.Capability_nonStandard.nonStandardIdentifier.u.h221NonStandard.t35CountryCode	 = 0xB5;
  TermCap.value.capability.u.Capability_nonStandard.nonStandardIdentifier.u.h221NonStandard.t35Extension	 = 0x42;
  TermCap.value.capability.u.Capability_nonStandard.nonStandardIdentifier.u.h221NonStandard.manufacturerCode = 0x8080;
  TermCap.value.capability.u.Capability_nonStandard.data.value  = &TermCapData;
  TermCap.value.capability.u.Capability_nonStandard.data.length = sizeof(TermCapData);
  lError = FsmOutgoing(pInstance, &pInstance->API.PDU_LocalTermCap, (DWORD_PTR)pTracker);
  pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.capabilityTable = TermCap.next;

  if (lError != H245_ERROR_OK)
    H245TRACE(dwInst,1,"H245SendTermCaps -> %s",map_api_error(lError));
  else
    H245TRACE(dwInst,4,"H245SendTermCaps -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245SendTermCaps()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245EnumCaps
 *
 * DESCRIPTION
 *
 *      HRESULT  H245EnumCaps (
 *                           DWORD                       dwInst,
 *                           DWORD                       dwTransId,
 *                           H245_CAPDIR_T               Direction,
 *                           H245_DATA_T                 DataType,
 *                           H245_CLIENT_T               ClientType,
 *                           H245_CAP_CALLBACK_T         CallBack
 *                           )
 *
 *
 *      Callback:
 *              CallBack (
 *                             DWORD                      dwTransId,
 *                             H245_TOTCAP_T             *pTotCap,
 *                       )
 *
 *      Description:
 *
 *              This function calls the H.245 client back for every
 *              capability as defined in the API call that complies with the
 *              request.  If the DataType parameter is set to 0 all of the
 *              caps types are returned (either local or remote based on the
 *              Direction parameter) no mater what is in the ClientType
 *              parameter. If the ClientType parameter is 0, it will return
 *              all of the capabilities of the given DataType.
 *
 *              The user supplied call back is called within the context of
 *              the call, therefor the call will be considered synchronous.
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              Direction       Local/Remote Receive, Transmit, or Receive and
 *                              Transmit
 *              DataType        Type of data (Audio, Video, Data, etc.)
 *              ClientType      Client type (H.262, G.711. etc. ).
 *              dwTransId       User supplied object used to identify this
 *                              request in the callback.
 *
 *      CallBack Output
 *              dwTransId       Identical to dwTransId passed in H245EnumCaps
 *                              pTotCap Pointer one of the capabilities.
 *
 *              Note: TotCap parameter must be copied in the callback.  This
 *                    data structure is reused for each callback.
 *
 *      Call Type:
 *              Synchronous Callback - i.e. called back in the context of
 *                              the API call
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_PARAM        One or more parameters were invalid
 *              H245_ERROR_INVALID_INST dwInst is not a valid instance handle.
 *
 *      See Also:
 *              H245SetLocalCap
 *              H245ReplLocalCap
 *
 *      callback
 *
 *              H245_IND_CAP
 *              H245_IND_CAPDESC
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245EnumCaps            (
                         H245_INST_T              dwInst,
                         DWORD_PTR                dwTransId,
                         H245_CAPDIR_T            Direction,
                         H245_DATA_T              DataType,
                         H245_CLIENT_T            ClientType,
                         H245_CAP_CALLBACK_T      pfCapCallback,
                         H245_CAPDESC_CALLBACK_T  pfCapDescCallback
                        )
{
  register struct InstanceStruct *pInstance;
  struct TerminalCapabilitySet   *pTermCapSet;
  CapabilityTableLink             pCapLink;
  int                             lcl_rmt;
  H245_TOTCAP_T                   totcap;
  int                             nResult = 0;

  H245TRACE (dwInst,4,"H245EnumCaps <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245EnumCaps -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* check for callback routine */
  if (pfCapCallback == NULL && pfCapDescCallback == NULL)
    {
      H245TRACE (dwInst,1,"H245EnumCaps -> %s",map_api_error(H245_ERROR_PARAM));
      InstanceUnlock(pInstance);
      return H245_ERROR_PARAM;
    }

  /* ok... check the direction.. either remote or local caps.. */
  switch (Direction)
  {
  case H245_CAPDIR_RMTRX:
  case H245_CAPDIR_RMTTX:
  case H245_CAPDIR_RMTRXTX:
    pTermCapSet = &pInstance->API.PDU_RemoteTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet;
    lcl_rmt = H245_REMOTE;
    break;

  case H245_CAPDIR_LCLRX:
  case H245_CAPDIR_LCLTX:
  case H245_CAPDIR_LCLRXTX:
    pTermCapSet = &pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet;
    lcl_rmt = H245_LOCAL;
    break;

  /* must be either local or remote */
  // case H245_CAPDIR_DONTCARE:
  default:
    H245TRACE (dwInst,1,"H245EnumCaps -> %s",map_api_error(H245_ERROR_PARAM));
    InstanceUnlock(pInstance);
    return H245_ERROR_PARAM;
  }

  if (pfCapCallback)
  {
    if (pTermCapSet->bit_mask & multiplexCapability_present &&
        build_totcap_from_mux(&totcap, &pTermCapSet->multiplexCapability, Direction) == H245_ERROR_OK)
    {
      (*pfCapCallback)(dwTransId, &totcap);
    }

    if (ClientType == H245_CLIENT_DONTCARE)
    {
      if (DataType == H245_DATA_DONTCARE)
      {
        for (pCapLink = pTermCapSet->capabilityTable; pCapLink && nResult == 0; pCapLink = pCapLink->next)
        {
          /* if capability is present */
          if (pCapLink->value.bit_mask & capability_present &&
              build_totcap_from_captbl(&totcap, pCapLink, lcl_rmt) == H245_ERROR_OK)
          {
            nResult = (*pfCapCallback)(dwTransId, &totcap);
          }
        } // for
      } // if
      else
      {
        for (pCapLink = pTermCapSet->capabilityTable; pCapLink && nResult == 0; pCapLink = pCapLink->next)
        {
          /* if capability is present */
          if (pCapLink->value.bit_mask & capability_present &&
              build_totcap_from_captbl(&totcap, pCapLink, lcl_rmt) == H245_ERROR_OK &&
              totcap.DataType == DataType)
          {
            nResult = (*pfCapCallback)(dwTransId, &totcap);
          }
        } // for
      } // else
    } // if
    else
    {
      if (DataType == H245_DATA_DONTCARE)
      {
        for (pCapLink = pTermCapSet->capabilityTable; pCapLink && nResult == 0; pCapLink = pCapLink->next)
        {
          /* if capability is present */
          if (pCapLink->value.bit_mask & capability_present &&
              build_totcap_from_captbl(&totcap, pCapLink, lcl_rmt) == H245_ERROR_OK &&
              totcap.ClientType == ClientType)
          {
            nResult = (*pfCapCallback)(dwTransId, &totcap);
          } /* if cap match */
        } // for
      } // if
      else
      {
        for (pCapLink = pTermCapSet->capabilityTable; pCapLink && nResult == 0; pCapLink = pCapLink->next)
        {
          /* if capability is present */
          if (pCapLink->value.bit_mask & capability_present &&
              build_totcap_from_captbl(&totcap,pCapLink,lcl_rmt) == H245_ERROR_OK &&
              totcap.ClientType == ClientType &&
              totcap.DataType   == DataType)
          {
            nResult = (*pfCapCallback)(dwTransId, &totcap);
          }
        } // for
      } // else
    } // else
  } // if (pfCapCallback)

  if (pfCapDescCallback)
  {
    // Convert CapabilityDescriptor format to H245_CAPDESC_T format
    unsigned int                uCapDesc;
    register SmltnsCpbltsLink   pSimCap;
    register unsigned int       uAltCap;
    H245_TOTCAPDESC_T           TotCapDesc;

    for (uCapDesc = 0;
         uCapDesc < pTermCapSet->capabilityDescriptors.count && nResult == 0;
         ++uCapDesc)
    {
      if (pTermCapSet->capabilityDescriptors.value[uCapDesc].bit_mask & smltnsCpblts_present)
      {
        ASSERT(pTermCapSet->capabilityDescriptors.value[uCapDesc].capabilityDescriptorNumber <= 256);
        TotCapDesc.CapDesc.Length = 0;
        pSimCap = pTermCapSet->capabilityDescriptors.value[uCapDesc].smltnsCpblts;
        ASSERT(pSimCap != NULL);
        while (pSimCap)
        {
          if (TotCapDesc.CapDesc.Length >= H245_MAX_SIMCAPS)
          {
            H245TRACE (dwInst,1,"H245EnumCaps -> Number of simutaneous capabilities exceeds H245_MAX_SIMCAPS");
            InstanceUnlock(pInstance);
            return H245_ERROR_MAXTBL;
          }
          if (pSimCap->value.count > H245_MAX_ALTCAPS)
          {
            H245TRACE (dwInst,1,"H245EnumCaps -> Number of alternative capabilities exceeds H245_MAX_ALTCAPS");
            InstanceUnlock(pInstance);
            return H245_ERROR_MAXTBL;
          }
          TotCapDesc.CapDesc.SimCapArray[TotCapDesc.CapDesc.Length].Length = (WORD) pSimCap->value.count;
          for (uAltCap = 0; uAltCap < pSimCap->value.count; ++uAltCap)
          {
            TotCapDesc.CapDesc.SimCapArray[TotCapDesc.CapDesc.Length].AltCaps[uAltCap] = pSimCap->value.value[uAltCap];
          }
          TotCapDesc.CapDesc.Length++;
          pSimCap = pSimCap->next;
        } // while
        TotCapDesc.CapDescId = pTermCapSet->capabilityDescriptors.value[uCapDesc].capabilityDescriptorNumber;
        nResult = pfCapDescCallback(dwTransId, &TotCapDesc);
      } // if
    } // for
  } // if (pfCapDescCallback)

  H245TRACE (dwInst,4,"H245EnumCaps -> OK");
  InstanceUnlock(pInstance);
  return H245_ERROR_OK;
} // H245EnumCaps()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245GetCaps
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

static H245_TOTCAP_T * *      ppTotCapGlobal;
static unsigned long          dwTotCapLen;
static unsigned long          dwTotCapMax;
static H245_TOTCAPDESC_T * *  ppCapDescGlobal;
static unsigned long          dwCapDescLen;
static unsigned long          dwCapDescMax;
static HRESULT                dwGetCapsError;

static int
GetCapsCapCallback(DWORD_PTR dwTransId, H245_TOTCAP_T *pTotCap)
{
  H245_TOTCAP_T *pNewCap;

  if (dwGetCapsError == H245_ERROR_OK)
  {
    if (dwTotCapLen >= dwTotCapMax)
    {
      dwGetCapsError = H245_ERROR_MAXTBL;
    }
    else
    {
      dwGetCapsError = H245CopyCap(&pNewCap, pTotCap);
      if (dwGetCapsError == H245_ERROR_OK)
      {
        *ppTotCapGlobal++ = pNewCap;
        ++dwTotCapLen;
      }
    }
  }

  return 0;
} // GetCapsCapCallback()

static int
GetCapsCapDescCallback(DWORD_PTR dwTransId, H245_TOTCAPDESC_T *pCapDesc)
{
  H245_TOTCAPDESC_T *pNewCapDesc;

  if (dwGetCapsError == H245_ERROR_OK)
  {
    if (dwCapDescLen >= dwCapDescMax)
    {
      dwGetCapsError = H245_ERROR_MAXTBL;
    }
    else
    {
      dwGetCapsError = H245CopyCapDescriptor(&pNewCapDesc,pCapDesc);
      {
        *ppCapDescGlobal++ = pNewCapDesc;
        ++dwCapDescLen;
      }
    }
  }

  return 0;
} // GetCapsCapDescCallback()

H245DLL HRESULT
H245GetCaps             (
                         H245_INST_T            dwInst,
                         H245_CAPDIR_T          Direction,
                         H245_DATA_T            DataType,
                         H245_CLIENT_T          ClientType,
                         H245_TOTCAP_T * *      ppTotCap,
                         unsigned long *        pdwTotCapLen,
                         H245_TOTCAPDESC_T * *  ppCapDesc,
                         unsigned long *        pdwCapDescLen
                        )
{
  register struct InstanceStruct *pInstance;
  H245_CAP_CALLBACK_T           CapCallback;
  H245_CAPDESC_CALLBACK_T       CapDescCallback;

  H245TRACE (dwInst,4,"H245GetCaps <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245GetCaps -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  dwTotCapLen     = 0;
  if (ppTotCap == NULL || pdwTotCapLen == NULL || *pdwTotCapLen == 0)
  {
    CapCallback = NULL;
  }
  else
  {
    CapCallback     = GetCapsCapCallback;
    ppTotCapGlobal  = ppTotCap;
    dwTotCapMax     = *pdwTotCapLen;
  }

  dwCapDescLen    = 0;
  if (ppCapDesc == NULL || pdwCapDescLen == NULL || *pdwCapDescLen == 0)
  {
    CapDescCallback = NULL;
  }
  else
  {
    CapDescCallback = GetCapsCapDescCallback;
    ppCapDescGlobal = ppCapDesc;
    dwCapDescMax    = *pdwCapDescLen;
  }

  /* check parameters */
  if (CapCallback == NULL && CapDescCallback == NULL)
  {
    H245TRACE (dwInst,1,"H245GetCaps -> %s",map_api_error(H245_ERROR_PARAM));
    InstanceUnlock(pInstance);
    return H245_ERROR_PARAM;
  }

  dwGetCapsError = H245_ERROR_OK;
  H245EnumCaps(dwInst,
               0,
               Direction,
               DataType,
               ClientType,
               CapCallback,
               CapDescCallback);

  if (pdwTotCapLen)
    *pdwTotCapLen = dwTotCapLen;
  if (pdwCapDescLen)
    *pdwCapDescLen = dwCapDescLen;
  if (dwGetCapsError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245GetCaps -> %s", map_api_error(dwGetCapsError));
  else
    H245TRACE (dwInst,4,"H245GetCaps -> OK");
  InstanceUnlock(pInstance);
  return H245_ERROR_OK;
} // H245GetCaps()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245CopyCap
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CopyCap             (H245_TOTCAP_T			**ppDestTotCap,
						 const H245_TOTCAP_T	*pTotCap)
{
  POBJECTID               pObjectTo;
  POBJECTID               pObjectFrom;
  HRESULT				  Status;

  if (ppDestTotCap == NULL)
	  return H245_ERROR_PARAM;

  *ppDestTotCap = NULL;

  if (pTotCap == NULL)
	  return H245_ERROR_PARAM;

  switch (pTotCap->ClientType)
  {
  case H245_CLIENT_NONSTD:
  case H245_CLIENT_VID_NONSTD:
  case H245_CLIENT_AUD_NONSTD:
  case H245_CLIENT_MUX_NONSTD:
    if (pTotCap->Cap.H245_NonStd.nonStandardIdentifier.choice == object_chosen)
    {
      *ppDestTotCap = MemAlloc(sizeof(*pTotCap) +
        pTotCap->Cap.H245_NonStd.data.length +
        ObjectIdLength(&pTotCap->Cap.H245_NonStd.nonStandardIdentifier) * sizeof(OBJECTID));
    }
    else
    {
      *ppDestTotCap = MemAlloc(sizeof(*pTotCap) +
        pTotCap->Cap.H245_NonStd.data.length);
    }
	if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;

    **ppDestTotCap = *pTotCap;
    if (pTotCap->Cap.H245_NonStd.data.length != 0)
    {
      (*ppDestTotCap)->Cap.H245_NonStd.data.value = (unsigned char *)(*ppDestTotCap + 1);
      memcpy((*ppDestTotCap)->Cap.H245_NonStd.data.value,
             pTotCap->Cap.H245_NonStd.data.value,
             pTotCap->Cap.H245_NonStd.data.length);
    }
    else
    {
      (*ppDestTotCap)->Cap.H245_NonStd.data.value = NULL;
    }
    if (pTotCap->Cap.H245_NonStd.nonStandardIdentifier.choice == object_chosen &&
        pTotCap->Cap.H245_NonStd.nonStandardIdentifier.u.object != NULL)
    {
      pObjectTo = (POBJECTID)(((unsigned char *)(*ppDestTotCap + 1)) +
        pTotCap->Cap.H245_NonStd.data.length);
      (*ppDestTotCap)->Cap.H245_NonStd.nonStandardIdentifier.u.object = pObjectTo;
      pObjectFrom = pTotCap->Cap.H245_NonStd.nonStandardIdentifier.u.object;
      do
      {
        pObjectTo->value = pObjectFrom->value;
        pObjectTo->next  = pObjectTo + 1;
        ++pObjectTo;
      } while ((pObjectFrom = pObjectFrom->next) != NULL);
      --pObjectTo;
      pObjectTo->next = NULL;
    }
    break;

  case H245_CLIENT_DAT_NONSTD:
    if (pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier.choice == object_chosen)
    {
      *ppDestTotCap = MemAlloc(sizeof(*pTotCap) +
        pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.length +
        ObjectIdLength(&pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier) * sizeof(OBJECTID));
    }
    else
    {
      *ppDestTotCap = MemAlloc(sizeof(*pTotCap) +
        pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.length);
    }
	if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;

    **ppDestTotCap = *pTotCap;
    if (pTotCap->Cap.H245_NonStd.data.length != 0)
    {
      (*ppDestTotCap)->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.value =
        (unsigned char *)(*ppDestTotCap + 1);
      memcpy((*ppDestTotCap)->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.value,
             pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.value,
             pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.length);
    }
    else
    {
      (*ppDestTotCap)->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.value = NULL;
    }
    if (pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier.choice == object_chosen &&
        pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier.u.object != NULL)
    {
      pObjectTo = (POBJECTID)(((unsigned char *)(*ppDestTotCap + 1)) +
        pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.length);
      (*ppDestTotCap)->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier.u.object = pObjectTo;
      pObjectFrom = pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier.u.object;
      do
      {
        pObjectTo->value = pObjectFrom->value;
        pObjectTo->next  = pObjectTo + 1;
        ++pObjectTo;
      } while ((pObjectFrom = pObjectFrom->next) != NULL);
      --pObjectTo;
      pObjectTo->next = NULL;
    }
    break;

  case H245_CLIENT_DAT_T120:
  case H245_CLIENT_DAT_DSMCC:
  case H245_CLIENT_DAT_USERDATA:
  case H245_CLIENT_DAT_T434:
  case H245_CLIENT_DAT_H224:
  case H245_CLIENT_DAT_H222:
    if (pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      if (pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.nonStandardIdentifier.choice == object_chosen)
      {
        *ppDestTotCap = MemAlloc(sizeof(*pTotCap) +
          pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.length +
          ObjectIdLength(&pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.nonStandardIdentifier) * sizeof(OBJECTID));
      }
      else
      {
        *ppDestTotCap = MemAlloc(sizeof(*pTotCap) +
          pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.length);
      }
	  if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;

      **ppDestTotCap = *pTotCap;
      if (pTotCap->Cap.H245_NonStd.data.length != 0)
      {
        (*ppDestTotCap)->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.value =
          (unsigned char *)(*ppDestTotCap + 1);
        memcpy((*ppDestTotCap)->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.value,
               pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.value,
               pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.length);
      }
      else
      {
        (*ppDestTotCap)->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.value = NULL;
      }
      if (pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.nonStandardIdentifier.choice == object_chosen &&
          pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.nonStandardIdentifier.u.object != NULL)
      {
        pObjectTo = (POBJECTID)(((unsigned char *)(*ppDestTotCap + 1)) +
          pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.length);
        (*ppDestTotCap)->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.nonStandardIdentifier.u.object = pObjectTo;
        pObjectFrom = pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.nonStandardIdentifier.u.object;
        do
        {
          pObjectTo->value = pObjectFrom->value;
          pObjectTo->next  = pObjectTo + 1;
          ++pObjectTo;
        } while ((pObjectFrom = pObjectFrom->next) != NULL);
        --pObjectTo;
        pObjectTo->next = NULL;
      }
    }
    else
    {
      *ppDestTotCap = MemAlloc(sizeof(*pTotCap));
	  if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;
      **ppDestTotCap = *pTotCap;
    }
    break;

  case H245_CLIENT_CONFERENCE:
  {
    NonStandardDataLink pList;
    NonStandardDataLink pFrom;
    NonStandardDataLink pTo;

	// Initialize Status here to prevent compiler warning "returning a possibly
	// uninitialized value"
	Status = H245_ERROR_NOMEM;

    *ppDestTotCap = MemAlloc(sizeof(*pTotCap));
	if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;

    **ppDestTotCap = *pTotCap;

    pList = NULL;
    (*ppDestTotCap)->Cap.H245Conference.nonStandardData = NULL;
    pFrom = pTotCap->Cap.H245Conference.nonStandardData;
    while (pFrom)
    {
      pTo = MemAlloc(sizeof(*pTo));
	  if (pTo == NULL)
		  Status = H245_ERROR_NOMEM;

      if (pTo != NULL)
      {
        Status = CopyNonStandardParameter(&pTo->value, &pFrom->value);
		if (Status != H245_ERROR_OK)
        {
          MemFree(pTo);
          pTo = NULL;
        }
      }
      if (pTo == NULL)
      {
        while (pList)
        {
          pTo = pList;
          pList = pList->next;
          FreeNonStandardParameter(&pTo->value);
          MemFree(pTo);
        }
        MemFree(*ppDestTotCap);
		*ppDestTotCap = NULL;
        return Status;
      }
      pTo->next = pList;
      pList = pTo;
      pFrom = pFrom->next;
    } // while
    while (pList)
    {
      pTo = pList;
      pList = pList->next;
      pTo->next = (*ppDestTotCap)->Cap.H245Conference.nonStandardData;
      (*ppDestTotCap)->Cap.H245Conference.nonStandardData = pTo;
    } // while
    break;
  }

  case H245_CLIENT_MUX_H222:
  {
    VCCapabilityLink pList = NULL;
    VCCapabilityLink pFrom;
    VCCapabilityLink pTo;

    *ppDestTotCap = MemAlloc(sizeof(*pTotCap));
	if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;

    **ppDestTotCap = *pTotCap;
    (*ppDestTotCap)->Cap.H245Mux_H222.vcCapability = NULL;
    pFrom = pTotCap->Cap.H245Mux_H222.vcCapability;
    while (pFrom)
    {
      pTo = MemAlloc(sizeof(*pTo));
      if (pTo == NULL)
      {
        while (pList)
        {
          pTo = pList;
          pList = pList->next;
          MemFree(pTo);
        }
        MemFree(*ppDestTotCap);
        *ppDestTotCap = NULL;
        return H245_ERROR_NOMEM;
      }
      pTo->value = pFrom->value;
      pTo->next = pList;
      pList = pTo;
      pFrom = pFrom->next;
    } // while
    while (pList)
    {
      pTo = pList;
      pList = pList->next;
      pTo->next = (*ppDestTotCap)->Cap.H245Mux_H222.vcCapability;
      (*ppDestTotCap)->Cap.H245Mux_H222.vcCapability = pList;
    } // while
    break;
  }

  case H245_CLIENT_MUX_H2250:
    *ppDestTotCap = MemAlloc(sizeof(*pTotCap));
	if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;

    **ppDestTotCap = *pTotCap;
    Status = CopyH2250Cap(&(*ppDestTotCap)->Cap.H245Mux_H2250, &pTotCap->Cap.H245Mux_H2250);
    if (Status != H245_ERROR_OK)
	{
      MemFree(*ppDestTotCap);
	  *ppDestTotCap = NULL;
	  return Status;
    }
    break;

  default:
    *ppDestTotCap = MemAlloc(sizeof(*pTotCap));
	if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;
    **ppDestTotCap = *pTotCap;
  } // switch

  return H245_ERROR_OK;
} // H245CopyCap()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245FreeCap
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245FreeCap             (H245_TOTCAP_T *        pTotCap)
{
  if (pTotCap == NULL)
  {
    return H245_ERROR_PARAM;
  }

  switch (pTotCap->ClientType)
  {
  case H245_CLIENT_CONFERENCE:
    {
      NonStandardDataLink pList;
      NonStandardDataLink pTo;

      pList = pTotCap->Cap.H245Conference.nonStandardData;
      while (pList)
      {
        pTo = pList;
        pList = pList->next;
        FreeNonStandardParameter(&pTo->value);
        MemFree(pTo);
      }
    }
    break;

  case H245_CLIENT_MUX_H222:
    {
      VCCapabilityLink pList;
      VCCapabilityLink pTo;

      pList = pTotCap->Cap.H245Mux_H222.vcCapability;
      while (pList)
      {
        pTo = pList;
        pList = pList->next;
        MemFree(pTo);
      }
    }
    break;

  case H245_CLIENT_MUX_H2250:
    FreeH2250Cap(&pTotCap->Cap.H245Mux_H2250);
    break;

  } // switch
  MemFree(pTotCap);
  return 0;
} // H245FreeCap()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245CopyCapDescriptor
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CopyCapDescriptor   (H245_TOTCAPDESC_T			**ppDestCapDesc,
						 const H245_TOTCAPDESC_T	*pCapDesc)
{
  if (ppDestCapDesc == NULL)
	  return H245_ERROR_PARAM;

  *ppDestCapDesc = NULL;

  if (pCapDesc == NULL)
	  return H245_ERROR_PARAM;

  *ppDestCapDesc = MemAlloc(sizeof(**ppDestCapDesc));
  if (*ppDestCapDesc == NULL)
	  return H245_ERROR_NOMEM;

  **ppDestCapDesc = *pCapDesc;
  return H245_ERROR_OK;
} // H245CopyCapDescriptor()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245FreeCapDescriptor
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245FreeCapDescriptor   (H245_TOTCAPDESC_T *    pCapDesc)
{
  if (pCapDesc == NULL)
  {
    return H245_ERROR_PARAM;
  }

  MemFree(pCapDesc);
  return 0;
} // H245FreeCapDescriptor()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245CopyMux
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL H245_MUX_T *
H245CopyMux             (const H245_MUX_T *           pMux)
{
  register unsigned int   uLength;
  register H245_MUX_T    *pNew;
  H2250LCPs_nnStndrdLink  pList;
  H2250LCPs_nnStndrdLink  pFrom;
  H2250LCPs_nnStndrdLink  pTo;

  switch (pMux->Kind)
  {
  case H245_H222:
    uLength = sizeof(*pMux) +
      pMux->u.H222.programDescriptors.length +
      pMux->u.H222.streamDescriptors.length;
    pNew = MemAlloc(uLength);
    if (pNew != NULL)
    {
      *pNew = *pMux;
      if (pMux->u.H222.programDescriptors.length != 0)
      {
        pNew->u.H222.programDescriptors.value = (unsigned char *)(pNew + 1);
        memcpy(pNew->u.H222.programDescriptors.value,
               pMux->u.H222.programDescriptors.value,
               pMux->u.H222.programDescriptors.length);
      }
      else
      {
        pNew->u.H222.programDescriptors.value = NULL;
      }

      if (pMux->u.H222.streamDescriptors.length != 0)
      {
        pNew->u.H222.streamDescriptors.value = ((unsigned char *)pNew) +
          (uLength - pMux->u.H222.streamDescriptors.length);
        memcpy(pNew->u.H222.streamDescriptors.value,
               pMux->u.H222.streamDescriptors.value,
               pMux->u.H222.streamDescriptors.length);
      }
      else
      {
        pNew->u.H222.streamDescriptors.value = NULL;
      }
    }
    break;

  case H245_H223:
    pNew = MemAlloc(sizeof(*pMux) + pMux->u.H223.H223_NONSTD.data.length);
    if (pNew != NULL)
    {
      *pNew = *pMux;
      if (pMux->u.H223.H223_NONSTD.data.length != 0)
      {
        pNew->u.H223.H223_NONSTD.data.value = (unsigned char *)(pNew + 1);
        memcpy(pNew->u.H223.H223_NONSTD.data.value,
               pMux->u.H223.H223_NONSTD.data.value,
               pMux->u.H223.H223_NONSTD.data.length);
      }
      else
      {
        pNew->u.H223.H223_NONSTD.data.value = NULL;
      }
    }
    break;

  case H245_H2250:
  case H245_H2250ACK:
    // Caveat: assumes nonstandard list, mediaChannel and mediaControlChannel
    //         in same place in both structures
    if (pMux->u.H2250.mediaChannelPresent &&
        (pMux->u.H2250.mediaChannel.type == H245_IPSSR_UNICAST ||
         pMux->u.H2250.mediaChannel.type == H245_IPLSR_UNICAST) &&
        pMux->u.H2250.mediaChannel.u.ipSourceRoute.route != NULL &&
        pMux->u.H2250.mediaChannel.u.ipSourceRoute.dwCount != 0)
    {
      if (pMux->u.H2250.mediaControlChannelPresent &&
          (pMux->u.H2250.mediaControlChannel.type == H245_IPSSR_UNICAST ||
           pMux->u.H2250.mediaControlChannel.type == H245_IPLSR_UNICAST) &&
          pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.route != NULL &&
          pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.dwCount != 0)
      {
        unsigned int          uLength2;
        uLength  = pMux->u.H2250.mediaChannel.u.ipSourceRoute.dwCount << 2;
        uLength2 = pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.dwCount << 2;
        pNew = MemAlloc(sizeof(*pMux) + uLength + uLength2);
        if (pNew != NULL)
        {
          *pNew = *pMux;
          pNew->u.H2250.mediaChannel.u.ipSourceRoute.route = (unsigned char *) (pNew + 1);
          pNew->u.H2250.mediaControlChannel.u.ipSourceRoute.route =
            pNew->u.H2250.mediaChannel.u.ipSourceRoute.route + uLength;
          memcpy(pNew->u.H2250.mediaChannel.u.ipSourceRoute.route,
                 pMux->u.H2250.mediaChannel.u.ipSourceRoute.route,
                 uLength);
          memcpy(pNew->u.H2250.mediaControlChannel.u.ipSourceRoute.route,
                 pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.route,
                 uLength2);
        }
      }
      else
      {
        uLength = pMux->u.H2250.mediaChannel.u.ipSourceRoute.dwCount << 2;
        pNew = MemAlloc(sizeof(*pMux) + uLength);
        if (pNew != NULL)
        {
          *pNew = *pMux;
          pNew->u.H2250.mediaChannel.u.ipSourceRoute.route = (unsigned char *) (pNew + 1);
          memcpy(pNew->u.H2250.mediaChannel.u.ipSourceRoute.route,
                 pMux->u.H2250.mediaChannel.u.ipSourceRoute.route,
                 uLength);
        }
      }
    }
    else if (pMux->u.H2250.mediaControlChannelPresent &&
             (pMux->u.H2250.mediaControlChannel.type == H245_IPSSR_UNICAST ||
              pMux->u.H2250.mediaControlChannel.type == H245_IPLSR_UNICAST) &&
             pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.route != NULL &&
             pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.dwCount != 0)
    {
      uLength = pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.dwCount << 2;
      pNew = MemAlloc(sizeof(*pMux) + uLength);
      if (pNew != NULL)
      {
        *pNew = *pMux;
        pNew->u.H2250.mediaControlChannel.u.ipSourceRoute.route = (unsigned char *) (pNew + 1);
        memcpy(pNew->u.H2250.mediaControlChannel.u.ipSourceRoute.route,
               pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.route,
               uLength);
      }
    }
    else
    {
      pNew = MemAlloc(sizeof(*pMux));
      if (pNew != NULL)
      {
        *pNew = *pMux;
      }
    }
    pList = NULL;
    pNew->u.H2250.nonStandardList = NULL;
    pFrom = pMux->u.H2250.nonStandardList;
    while (pFrom)
    {
      pTo = MemAlloc(sizeof(*pTo));
      if (pTo != NULL)
      {
        if (CopyNonStandardParameter(&pTo->value, &pFrom->value) != H245_ERROR_OK)
        {
          MemFree(pTo);
          pTo = NULL;
        }
      }
      if (pTo == NULL)
      {
        while (pList)
        {
          pTo = pList;
          pList = pList->next;
          FreeNonStandardParameter(&pTo->value);
          MemFree(pTo);
        }
        MemFree(pNew);
        return NULL;
      }
      pTo->next = pList;
      pList = pTo;
      pFrom = pFrom->next;
    } // while
    while (pList)
    {
      pTo = pList;
      pList = pList->next;
      pTo->next = pNew->u.H2250.nonStandardList;
      pNew->u.H2250.nonStandardList = pTo;
    } // while
    break;

//  case H245_VGMUX:
 default:
    pNew = MemAlloc(sizeof(*pMux));
    if (pNew != NULL)
    {
      *pNew = *pMux;
    }
  } // switch

  return pNew;
} // H245CopyMux()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245FreeMux
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245FreeMux             (H245_MUX_T *           pMux)
{
  H2250LCPs_nnStndrdLink      pLink;

  if (pMux == NULL)
  {
    return H245_ERROR_PARAM;
  }

  switch (pMux->Kind)
  {
  case H245_H2250:
  case H245_H2250ACK:
    // Caveat: assumes nonstandard list is in same place in both structures
    while (pMux->u.H2250.nonStandardList)
    {
      pLink = pMux->u.H2250.nonStandardList;
      pMux->u.H2250.nonStandardList = pLink->next;
      FreeNonStandardParameter(&pLink->value);
      MemFree(pLink);
    }
    break;
  } // switch

  MemFree(pMux);
  return 0;
} // H245FreeMux()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245OpenChannel
 *
 * DESCRIPTION
 *
 *      HRESULT H245OpenChannel (
 *                              H245_INST_T      dwInst,
 *                              DWORD            dwTransId,
 *                              DWORD            dwTxChannel,
 *                              H245_TOTCAP_T   *pTxMode,
 *                              H245_MUX_T      *pTxMux,
 *                              H245_TOTCAP_T   *pRxMode, (* bi-dir only *)
 *                              H245_MUX_T      *pRxMux   (* bi-dir only *)
 *                              )
 *
 *      Description:
 *              This function is called to open either a uni-directional,
 *              or a bi-directional channel.  The  mode to the remote peer
 *              will be designated by the *pTxMode.. To open a bi-directional
 *              channel the client selects a non-null receive mode ( *pRxMode).
 *              This mode  indicates to  the remote peer its transmit mode.
 *              For  uni-directional channels the *pRxMode must be NULL.
 *
 *              The dwTxChannel parameter indicates which forward logical
 *              channel the H.245 will open.  If this is a bi-directional
 *              channel open, the confirm will indicate the logical channel
 *              specified in the open request by the remote terminal
 *
 *              The pMux parameter will contain a pointer to H.223, H.222,
 *              VGMUX, or other logical channel parameters depending on the
 *              system configuration. (see H245_H223_LOGICAL_PARAM).  This
 *              may be NULL for some clients.
 *
 *      Note:
 *              7 pTxMode->CapId is of no significance in this call.
 *                      It is not used
 *              7 pRxMode->CapId is of no significance in this call.
 *                      It is not used
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              dwTransId       User supplied object used to identify this
 *                              request in the asynchronous confirm to this
 *                              call.
 *              dwTxChannel     Logical Channel number for forward (Transmit)
 *                              Channel
 *              pTxMode         The capability (mode) used for transmission
 *                              to the remote peer.
 *                              Note: pTxMode->CapId is ignored
 *              pTxMux          The formward logical channel parameters
 *                              for H.223, H.222, VGMUX, etc.
 *              pRxMode         Optional: Transmit mode specified for the
 *                              remote terminal. This is used only for
 *                              Bi-directional Channel opens and must be set
 *                              to NULL if opening a Uni-directional channel.
 *                              Note: pRxMode->CapId is ignored
 *              pRxMux          Optional : The reverse logical channel
 *                              parameters for H.223, H.222, VGMUX, etc. or
 *                              NULL.
 *
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Callback:
 *              H245_CONF_OPEN
 *              H245_CONF_NEEDRSP_OPEN  Bi-Directional Channels only
 *                                      waiting for confirm.
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_PARAM                One or more parameters were
 *                                              invalid
 *              H245_ERROR_BANDWIDTH_OVERFLOW   Open would exceed bandwidth
 *                                              limitations
 *              H245_ERROR_NOMEM
 *              H245_ERROR_NORESOURCE           Out of resources, too many
 *                                              open channels or outside scope
 *                                              of simultaneous capabilities.
 *              H245_ERROR_INVALID_INST         dwInst is not a valid instance
 *                                              handle
 *              H245_ERROR_INVALID_STATE        Not in the proper state to
 *                                              issue open
 *              H245_ERROR_CHANNEL_INUSE        Channel is currently open
 *
 *      See Also:
 *              H245CloseChannel
 *              H245OpenChannelIndResp
 *              H245OpenChannelConfResp
 *
 *      callback
 *
 *              H245_CONF_OPEN
 *              H245_CONF_NEEDRSP_OPEN
 *              H245_IND_OPEN_CONF
 *
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245OpenChannel         (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
                         H245_CHANNEL_T         wTxChannel,
                         const H245_TOTCAP_T *  pTxMode,
                         const H245_MUX_T    *  pTxMux,
                         H245_PORT_T            dwTxPort,       // optional
                         const H245_TOTCAP_T *  pRxMode,        // bi-dir only
                         const H245_MUX_T    *  pRxMux,         // bi-dir only
                         const H245_ACCESS_T *  pSeparateStack  // optional
                        )
{
  register struct InstanceStruct *pInstance;
  HRESULT                         lError;
  Tracker_T                      *pTracker;
  MltmdSystmCntrlMssg            *pPdu;

  H245TRACE (dwInst,4,"H245OpenChannel <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */
  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }
  /* must have performed Master Slave Negotiation at this point */
  if (pInstance->Configuration == H245_CONF_H324 &&
      pInstance->API.MasterSlave != APIMS_Master &&
      pInstance->API.MasterSlave != APIMS_Slave)
    {
      H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(H245_ERROR_INVALID_STATE));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_STATE;
    }

  pTracker = find_tracker_by_txchannel (pInstance, wTxChannel, API_CH_ALLOC_LCL);

  /* channel is currently in use */
  if (pTracker)
    {
      H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(H245_ERROR_CHANNEL_INUSE));
      InstanceUnlock(pInstance);
      return H245_ERROR_CHANNEL_INUSE;
    }

  if (!(pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(MltmdSystmCntrlMssg))))
    {
      H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(*pPdu));

  /* lock in the transmit side..                        */
  /* wait until OpenChannelConfResp to setup RxChannel  */

  lError = pdu_req_open_channel(pPdu,
                                  wTxChannel,
                                  dwTxPort,        /* forward port */
                                  pTxMode,
                                  pTxMux,
                                  pRxMode,
                                  pRxMux,
                                  pSeparateStack);
  if (lError != H245_ERROR_OK)
    {
      H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(lError));
      free_pdu_req_open_channel(pPdu, pTxMode, pRxMode);
      InstanceUnlock(pInstance);
      return lError;
    }

  /* if allocation error */

  if (!(pTracker = alloc_link_tracker (pInstance,
                                        API_OPEN_CHANNEL_T,
                                        dwTransId,
                                        API_ST_WAIT_RMTACK,
                                        API_CH_ALLOC_LCL,
                                        (pRxMode?API_CH_TYPE_BI:API_CH_TYPE_UNI),
                                        pTxMode->DataType,
                                        wTxChannel, H245_INVALID_CHANNEL,
                                        0)))
  {
    H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(H245_ERROR_NOMEM));
      free_pdu_req_open_channel(pPdu, pTxMode, pRxMode);
    InstanceUnlock(pInstance);
    return H245_ERROR_NOMEM;
  }

  lError = FsmOutgoing(pInstance, pPdu, (DWORD_PTR)pTracker);
  free_pdu_req_open_channel(pPdu, pTxMode, pRxMode);

  if (lError != H245_ERROR_OK)
  {
    unlink_dealloc_tracker (pInstance, pTracker);
    H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(lError));
  }
  else
    H245TRACE (dwInst,4,"H245OpenChannel -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245OpenChannel()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245OpenChannelAccept
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245OpenChannelAccept   (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
                         H245_CHANNEL_T         wRxChannel,     // RxChannel from IND_OPEN
                         const H245_MUX_T *     pRxMux,         // optional H2250LogicalChannelAckParameters
                         H245_CHANNEL_T         wTxChannel,     // bi-dir only
                         const H245_MUX_T *     pTxMux,         // bi-dir only optional H2250LogicalChannelParameters
                         H245_PORT_T            dwTxPort,       // bi-dir only optional
                         const H245_ACCESS_T *  pSeparateStack  // optional
                        )
{
  register struct InstanceStruct *pInstance;
  Tracker_T *           pTracker;
  MltmdSystmCntrlMssg * pPdu;
  HRESULT               lError;

  H245TRACE (dwInst,4,"H245OpenChannelAccept <- wRxChannel=%d wTxChannel=%d",
             wRxChannel, wTxChannel);

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */
  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* if channel not found in tracker list */
  /* note that it looks for given channel given who alloced it */
  pTracker = find_tracker_by_rxchannel (pInstance, wRxChannel, API_CH_ALLOC_RMT);

  /* not locking tracker.. since no indication will come in until I issue the request */
  if (!pTracker)
    {
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(H245_ERROR_INVALID_OP));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_OP;
    }

  /* if not open.. invalid op */
  if (pTracker->TrackerType != API_OPEN_CHANNEL_T)
    {
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(H245_ERROR_INVALID_OP));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_OP;
    }

  /*       if was uni open w/ TxChannel set.. error     */
  /* -or -                                              */
  /*       if was bi open w/ !TxChannel set.. error     */

  /* AND it wasn't a reject                             */

  if (pTracker->u.Channel.ChannelType == API_CH_TYPE_BI && wTxChannel == 0)
    {
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(H245_ERROR_PARAM));
      InstanceUnlock(pInstance);
      return H245_ERROR_PARAM;
    }

  /* for debug */
  ASSERT (pTracker->u.Channel.RxChannel == wRxChannel);
  ASSERT (pTracker->u.Channel.ChannelAlloc == API_CH_ALLOC_RMT);

  /* check state.. must be returning.. */
  if (pTracker->State != API_ST_WAIT_LCLACK)
    {
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(H245_ERROR_INVALID_STATE));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_STATE;
    }

  /* setup tracker object for new transaction */
  pTracker->TransId = dwTransId;

  pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
    {
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(*pPdu));


  switch (pTracker->u.Channel.ChannelType)
    {
    case API_CH_TYPE_UNI:
      pTracker->State = API_ST_IDLE;
      pTracker->u.Channel.TxChannel = 0;
      lError = pdu_rsp_open_logical_channel_ack(pPdu,
                                                wRxChannel,
                                                pRxMux,
                                                0,
                                                NULL,
                                                dwTxPort,
                                                pSeparateStack);
      if (lError != H245_ERROR_OK)
      {
        // If parameter error, we don't want to deallocate tracker
        MemFree (pPdu);
        InstanceUnlock(pInstance);
        return lError;
      }
      lError = FsmOutgoing(pInstance, pPdu, (DWORD_PTR)pTracker);
      break;

    case API_CH_TYPE_BI:
      pTracker->State = API_ST_WAIT_CONF;       /* waiting for confirmation */
      pTracker->u.Channel.TxChannel = wTxChannel;
      lError = pdu_rsp_open_logical_channel_ack(pPdu,
                                                wRxChannel,
                                                pRxMux,
                                                wTxChannel,
                                                pTxMux,
                                                dwTxPort,
                                                pSeparateStack);
      if (lError != H245_ERROR_OK)
      {
        // If parameter error, we don't want to deallocate tracker
        MemFree (pPdu);
        InstanceUnlock(pInstance);
        return lError;
      }
      lError = FsmOutgoing(pInstance, pPdu, (DWORD_PTR)pTracker);
      break;

    default:
      H245TRACE (dwInst,1,"H245OpenChannelAccept: Invalid Tracker Channel Type %d",
                 pTracker->u.Channel.ChannelType);
      lError = H245_ERROR_FATAL;
    } // switch

  MemFree (pPdu);

  switch (lError)
  {
  case H245_ERROR_OK:
    H245TRACE (dwInst,4,"H245OpenChannelAccept -> OK");
    break;

  default:
    // Deallocate tracker object for all errors except parameter error
    unlink_dealloc_tracker (pInstance, pTracker);

    // Fall-through to next case is intentional

  case H245_ERROR_PARAM:
      // If parameter error, we don't want to deallocate tracker
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(lError));
  } // switch

  InstanceUnlock(pInstance);
  return lError;
} // H245OpenChannelAccept()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245OpenChannelReject
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245OpenChannelReject   (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wRxChannel, // RxChannel from IND_OPEN
                         unsigned short         wCause
                        )
{
  register struct InstanceStruct *pInstance;
  Tracker_T *           pTracker;
  MltmdSystmCntrlMssg * pPdu;
  HRESULT               lError;

  H245TRACE (dwInst,4,"H245OpenChannelReject <- wRxChannel=%d", wRxChannel);

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245OpenChannelReject -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */
  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245OpenChannelReject -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* if channel not found in tracker list */
  /* note that it looks for given channel given who alloced it */
  pTracker = find_tracker_by_rxchannel (pInstance, wRxChannel, API_CH_ALLOC_RMT);

  /* not locking tracker.. since no indication will come in until I issue the request */
  /* if not open.. invalid op */
  if (pTracker == NULL || pTracker->TrackerType != API_OPEN_CHANNEL_T)
    {
      H245TRACE (dwInst,1,"H245OpenChannelReject -> %s",map_api_error(H245_ERROR_INVALID_OP));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_OP;
    }

  /* for debug */
  ASSERT (pTracker->u.Channel.RxChannel == wRxChannel);
  ASSERT (pTracker->u.Channel.ChannelAlloc == API_CH_ALLOC_RMT);

  /* check state.. must be returning.. */
  if (pTracker->State != API_ST_WAIT_LCLACK)
    {
      H245TRACE (dwInst,1,"H245OpenChannelReject -> %s",map_api_error(H245_ERROR_INVALID_STATE));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_STATE;
    }

  pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
    {
      H245TRACE (dwInst,1,"H245OpenChannelReject -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(*pPdu));

  pdu_rsp_open_logical_channel_rej(pPdu, wRxChannel, wCause);

  switch (pTracker->u.Channel.ChannelType)
    {
    case API_CH_TYPE_UNI:
      lError = FsmOutgoing(pInstance, pPdu, (DWORD_PTR)pTracker);
      break;

    case API_CH_TYPE_BI:
      lError = FsmOutgoing(pInstance, pPdu, (DWORD_PTR)pTracker);
      break;

    default:
      H245TRACE (dwInst,1,"H245OpenChannelReject: Invalid Tracker Channel Type %d",
                 pTracker->u.Channel.ChannelType);
      lError = H245_ERROR_FATAL;
    } // switch

  MemFree (pPdu);
  unlink_dealloc_tracker (pInstance, pTracker);

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245OpenChannelReject -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245OpenChannelReject -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245OpenChannelReject()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245CloseChannel
 *
 * DESCRIPTION
 *
 *      HRESULT H245CloseChannel (
 *                              H245_INST_T     dwInst,
 *                              DWORD           dwTransId,
 *                              DWORD           wTxChannel,
 *                              )
 *      Description:
 *              Called to close a channel upon which the client previously
 *              issued an OpenChannel request.
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              dwTransId       User supplied object used to identify this
 *                              request in the asynchronous confirm to this
 *                              call.
 *              wChannel        Logical Channel Number to close
 *
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Callbacks:
 *              H245_CONF_CLOSE
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_PARAM        wChannel is not a locally opened
 *                                      channel
 *              H245_ERROR_INVALID_INST dwInst is not a valid intance handle
 *              H245_ERROR_NOT_CONNECTED
 *              H245_ERROR_INVALID_CHANNEL
 *              H245_ERROR_INVALID_OP   Can not perform this operation on
 *                                      this channel.(See H245CloseChannelReq)
 *      See Also:
 *              H245OpenChannel
 *              H245OpenChannelIndResp
 *              H245OpenChannelConfResp
 *              H245CloseChannelReq
 *
 *      callback
 *              H245_CONF_CLOSE
 *
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CloseChannel        (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
                         H245_CHANNEL_T         wTxChannel
                        )
{
  register struct InstanceStruct *pInstance;
  Tracker_T             *pTracker;
  DWORD                  error;
  MltmdSystmCntrlMssg   *pPdu;

  H245TRACE (dwInst,4,"H245CloseChannel <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245CloseChannel -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */
  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245CloseChannel -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* if channel not found in tracker list */
  /* note that it looks for given channel given who alloced it */
  pTracker = find_tracker_by_txchannel (pInstance, wTxChannel, API_CH_ALLOC_LCL);
  /* not locking tracker.. since no indication will come in until I issue the request */
  if (!pTracker)
    {
      H245TRACE (dwInst,1,"H245CloseChannel -> %s",map_api_error(H245_ERROR_INVALID_CHANNEL));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_CHANNEL;
    }

  /* setup new tracker state */
  pTracker->State = API_ST_WAIT_RMTACK;
  pTracker->TrackerType = API_CLOSE_CHANNEL_T;
  pTracker->TransId = dwTransId;

  if (!(pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(MltmdSystmCntrlMssg))))
    {
      H245TRACE (dwInst,1,"H245CloseChannel -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  /* ok.. get pdu */
  pdu_req_close_logical_channel(pPdu, wTxChannel, 0/* user */);

  error = FsmOutgoing(pInstance, pPdu, (DWORD_PTR)pTracker);
  MemFree (pPdu);

  /* error.. so deallocate tracker structure */
  if (error != H245_ERROR_OK)
  {
    unlink_dealloc_tracker (pInstance, pTracker);
    H245TRACE (dwInst,1,"H245CloseChannel -> %s",map_api_error(error));
  }
  else
  {
    H245TRACE (dwInst,4,"H245CloseChannel -> OK");
  }
  InstanceUnlock(pInstance);
  return H245_ERROR_OK;
} // H245CloseChannel()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245CloseChannelReq
 *
 * DESCRIPTION
 *
 *      HRESULT H245CloseChannelReq (
 *                                 H245_INST_T          dwInst,
 *                                 DWORD                dwTransId,
 *                                 DWORD                wChannel,
 *                                 )
 *      Description:
 *              Called to request the remote peer to close a logical channel
 *              it previously opened
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              dwTransId       User supplied object used to identify this
 *                              request in the asynchronous confirm to this
 *                              call
 *              wChannel        Logical Channel Number to close
 *
 *              Note: This is only asking permission.  Even if the Close
 *              Request is accepted the channel still has to be closed from
 *              the remote side.  (i.e. this does not close the channel it
 *              only asked the remote side it issue a close)
 *
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Callbacks:
 *              H245_CONF_CLOSE
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_PARAM                wChannel is not a channel
 *                                              opened by remote peer
 *              H245_ERROR_INVALID_INST         dwInst is not a valid instance
 *                                              handle
 *              H245_ERROR_NOT_CONNECTED
 *              H245_ERROR_INVALID_CHANNEL
 *              H245_ERROR_INVALID_OP           Can not perform this operation
 *                                              on this channel
 *                                              (see H245CloseChannel)
 *      See Also:
 *              H245OpenChannel
 *              H245OpenChannelIndResp
 *              H245OpenChannelConfResp
 *              H245CloseChannel
 *
 *      callback
 *
 *              H245_CONF_CLOSE
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CloseChannelReq     (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
                         H245_CHANNEL_T         wRxChannel
                        )
{
  register struct InstanceStruct *pInstance;
  Tracker_T             *pTracker;
  DWORD                  error;
  MltmdSystmCntrlMssg   *pPdu;

  H245TRACE (dwInst,4,"H245CloseChannelReq <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245CloseChannelReq -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */
  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245CloseChannelReq -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* if channel not found in tracker list */
  /* note that it looks for given channel given who alloced it */
  pTracker = find_tracker_by_rxchannel (pInstance, wRxChannel, API_CH_ALLOC_RMT);
  /* not locking tracker.. since no indication will come in until I issue the request */
  if (!pTracker)
    {
      H245TRACE (dwInst,1,"H245CloseChannelReq -> %s",map_api_error(H245_ERROR_INVALID_OP));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_OP;
    }

  /*  verify state of tracker */
  pTracker->State = API_ST_WAIT_RMTACK;
  pTracker->TrackerType = API_CLOSE_CHANNEL_T;
  pTracker->TransId = dwTransId;

  if (!(pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(MltmdSystmCntrlMssg))))
    {
      H245TRACE (dwInst,1,"H245CloseChannelReq -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  /* ok.. get pdu */
  pdu_req_request_close_channel(pPdu, wRxChannel);

  error = FsmOutgoing(pInstance, pPdu, (DWORD_PTR)pTracker);
  MemFree (pPdu);
  if (error != H245_ERROR_OK)
  {
    unlink_dealloc_tracker (pInstance, pTracker);
    H245TRACE (dwInst,1,"H245CloseChannelReq -> %s",map_api_error(error));
  }
  else
    H245TRACE (dwInst,4,"H245CloseChannelReq -> OK");
  InstanceUnlock(pInstance);
  return error;
} // H245CloseChannelReq()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245CloseChannelReqResp
 *
 * DESCRIPTION
 *
 *      HRESULT H245CloseChannelReqResp (
 *                                      H245_INST_T     dwInst,
 *                                      H245_ACC_REJ_T  AccRej,
 *                                      DWORD           wChannel
 *                                      )
 *
 *      Description:
 *              This routine is called to accept or reject a
 *              RequestChannelClose (H245_IND_REQ_CLOSE indication) from the
 *              remote peer. The channel must have been locally opened.  The
 *              parameter AccRej is H245_ACC to accept or H245_REJ to reject
 *              the close.  The local client should follow this response with
 *              a H245CloseChannel call.
 *
 *              If there was a Release CloseChannelRequest event that
 *              occurred during this transaction there error code returned
 *              will be H245_ERROR_CANCELED.  This indicates to the H.245
 *              client that no action should be taken.
 *
 *      Input
 *              dwInst          Instance handle returned by H245GetInstanceId
 *              AccRej          this parameter contains either H245_ACC or
 *                              H245_REJ.  This indicates to H.245 which
 *                              action to take.
 *              wChannel        Logical Channel Number to close
 *
 *      Call Type:
 *              Synchronous
 *
 *      Return Values:
 *              See Errors
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_PARAM
 *              H245_ERROR_NOMEM
 *              H245_ERROR_INVALID_CHANNEL
 *              H245_ERROR_INVALID_OP   Can not perform this operation on this
 *                                      channel (see H245CloseChannel)
 *              H245_ERROR_INVALID_INST dwInst is not a valid instance handle
 *              H245_ERROR_CANCELED     if release was received during the
 *                                      processing of this request..
 *      See Also:
 *              H245CloseChannel
 *
 *      callback
 *
 *              H245_IND_REQ_CLOSE
 *              H245_IND_CLOSE
 *
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CloseChannelReqResp (
                         H245_INST_T            dwInst,
                         H245_ACC_REJ_T         AccRej,
                         H245_CHANNEL_T         wChannel
                        )
{
  register struct InstanceStruct *pInstance;
  Tracker_T             *pTracker;
  DWORD                  error;
  MltmdSystmCntrlMssg   *pPdu;

  H245TRACE (dwInst,4,"H245CloseChannelReqResp <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245CloseChannelReqResp -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */

  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245CloseChannelReqResp -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* if channel not found in tracker list */
  /* note that it looks for given channel given who alloced it */
  pTracker = find_tracker_by_txchannel (pInstance, wChannel,  API_CH_ALLOC_LCL);

  /* not locking tracker.. since no indication will come in until I issue the request */
  if (!pTracker)
    {
      H245TRACE (dwInst,1,"H245CloseChannelReqResp -> %s",map_api_error(H245_ERROR_INVALID_OP));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_OP;
    }

  /* if the request was canceled.. tell useer */
  if (pTracker->State == API_ST_WAIT_LCLACK_CANCEL)
    {
      H245TRACE (dwInst,1,"H245CloseChannelReqResp -> %s",map_api_error(H245_ERROR_CANCELED));
      InstanceUnlock(pInstance);
      return H245_ERROR_CANCELED;
    }

  /* verify state of tracker */
  if ((pTracker->State != API_ST_WAIT_LCLACK) ||
      (pTracker->TrackerType != API_CLOSE_CHANNEL_T))
    {
      H245TRACE (dwInst,1,"H245CloseChannelReqResp -> %s",map_api_error(H245_ERROR_INVALID_OP));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_OP;
    }

  /* set the state to idle.. expect this side to close the channel next */
  pTracker->State = API_ST_IDLE;

  if (!(pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(MltmdSystmCntrlMssg))))
    {
      H245TRACE (dwInst,1,"H245CloseChannelReqResp -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  /* ok.. get pdu */
  if (AccRej == H245_ACC)
  {
    pTracker = NULL;
    pdu_rsp_request_channel_close_ack(pPdu, wChannel);
  }
  else
  {
    pdu_rsp_request_channel_close_rej(pPdu, wChannel, AccRej);
  }

  error = FsmOutgoing(pInstance, pPdu, (DWORD_PTR)pTracker);
  MemFree (pPdu);
  if (error != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245CloseChannelReqResp -> %s",map_api_error(error));
  else
    H245TRACE (dwInst,4,"H245CloseChannelReqResp ->");
  InstanceUnlock(pInstance);
  return error;
} // H245CloseChannelReqResp()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245SendLocalMuxTable
 *
 * DESCRIPTION
 *
 *      HRESULT H245SendLocalMuxTable (
 *                                    H245_INST_T        dwInst,
 *                                    DWORD              dwTransId,
 *                                    H245_MUX_TABLE_T  *pMuxTbl
 *                                    )
 *      Description:
 *              This routine is called to send a mux table to the remote
 *              side. The remote side can either reject or accept each mux
 *              table entry in a message. The confirm is sent back to the
 *              calling H.245 client based on the acceptance or non
 *              acceptance of each Mux table entry with H245_CONF_MUXTBL_SND.
 *
 *              This is a fairly dangerous call, since the mux table
 *              structure is a linked lise of mux table entries.  Invalid
 *              data structures could cause an access error. Example code is
 *              supplied in the appendix.
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              dwTransId       User supplied object used to identify
 *                              this request in the asynchronous
 *                              confirm to this call.
 *      pMuxTbl Mux table entry structure
 *
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Callbacks:
 *              H245_CONF_MUXTBLSND
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_INVALID_MUXTBLENTRY
 *              H245_ERROR_PARAM
 *              H245_ERROR_INVALID_INST
 *              H245_ERROR_NOT_CONNECTED
 *              H245_ERROR_NOMEM
 *
 *      See Also:
 *              APPENDIX Examples
 *
 *      callback
 *
 *              H245_CONF_MUXTBL_SND
 *
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245SendLocalMuxTable   (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
                         H245_MUX_TABLE_T      *pMuxTable
                        )
{
  register struct InstanceStruct *pInstance;
  HRESULT                 lError;
  Tracker_T              *pTracker;
  MltmdSystmCntrlMssg    *pPdu;

  H245TRACE (dwInst,4,"H245SendLocalMuxTable <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245endLocalMuxTable -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */
  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245endLocalMuxTable  -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* make sure parameters ar ok.. */
  if (!pMuxTable)
    {
      H245TRACE (dwInst,1,"H245endLocalMuxTable  -> %s",map_api_error(H245_ERROR_PARAM));
      InstanceUnlock(pInstance);
      return H245_ERROR_PARAM;
    }

  /* allocate tracker for event */
  pTracker = alloc_link_tracker (pInstance,
                                  API_SEND_MUX_T,
                                  dwTransId,
                                  API_ST_WAIT_RMTACK,
                                  API_CH_ALLOC_UNDEF,
                                  API_CH_TYPE_UNDEF,
                                  0,
                                  H245_INVALID_CHANNEL, H245_INVALID_CHANNEL,
                                  0);
  if (pTracker == NULL)
  {
    H245TRACE(dwInst,1,"H245SendLocalMuxTable -> %s",map_api_error(H245_ERROR_NOMEM));
    InstanceUnlock(pInstance);
    return H245_ERROR_NOMEM;
  }

  // Allocate PDU buffer
  pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(MltmdSystmCntrlMssg));
  if (pPdu == NULL)
  {
    H245TRACE (dwInst,1,"H245SendLocalMuxTable -> %s",H245_ERROR_NOMEM);
    InstanceUnlock(pInstance);
    return H245_ERROR_NOMEM;
  }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  lError = pdu_req_send_mux_table(pInstance,
                                  pPdu,
                                  pMuxTable,
                                  0,
                                  &pTracker->u.MuxEntryCount);
  if (lError == H245_ERROR_OK)
  {
    lError = FsmOutgoing(pInstance, pPdu, (DWORD_PTR)pTracker);

    /* free the list just built */
    free_mux_desc_list(pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.multiplexEntryDescriptors);
  }

  /* free the pdu */
  MemFree (pPdu);

  if (lError != H245_ERROR_OK)
  {
    unlink_dealloc_tracker (pInstance, pTracker);
    H245TRACE (dwInst,1,"H245SendLocalMuxTable -> %s",map_api_error(lError));
  }
  else
    H245TRACE (dwInst,4,"H245SendLocalMuxTable -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245SendLocalMuxTable()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245MuxTableIndResp
 *
 * DESCRIPTION
 *
 *      HRESULT H245MuxTableIndResp (
 *                                  H45_INST_T          dwInst,
 *                                  H245_ACC_REJ_MUX_T  AccRejMux,
 *                                  DWORD               Count
 *                                  )
 *      Description:
 *              This procedure is called to either accept or reject mux
 *              table entries sent up in the H245_IND_MUX_TBL indication.
 *
 *      Input
 *              dwInst                  Instance handle returned by H245Init
 *              AccRejMux               Accept Reject Mux structure
 *              Count                   number of entries in the structure
 *
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_INVALID_MUXTBLENTRY
 *              H245_ERROR_PARAM
 *              H245_ERROR_INVALID_INST
 *              H245_ERROR_INVALID_OP
 *              H245_ERROR_NOT_CONNECTED
 *              H245_ERROR_NOMEM
 *      See Also:
 *              H245SendLocalMuxTable
 *
 *      callback
 *
 *              H245_IND_MUX_TBL
 *
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245MuxTableIndResp     (
                         H245_INST_T            dwInst,
                         H245_ACC_REJ_MUX_T     AccRejMux,
                         unsigned long          dwCount
                        )
{
  register struct InstanceStruct *pInstance;
  DWORD                   ii;
  Tracker_T              *pTracker;
  MltmdSystmCntrlMssg    *pPdu;

  H245TRACE (dwInst,4,"H245MuxTableIndResp <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245MuxTableIndResp -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */

  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245MuxTableIndResp  -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* look for tracker.. */
  pTracker = NULL;
  pTracker = find_tracker_by_type (pInstance, API_RECV_MUX_T, pTracker);

  /* if tracker not found.. issue invalid op */
  if (!pTracker)
    {
      H245TRACE (dwInst,1,"H245MuxTableIndResp -> %s",map_api_error(H245_ERROR_INVALID_OP));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_OP;
    }

  ASSERT (pTracker->State == API_ST_WAIT_LCLACK);

  /* can't ack or reject more than you got */
  if ((dwCount > pTracker->u.MuxEntryCount) ||
      (dwCount > 15))
    {
      H245TRACE (dwInst,1,"H245MuxTableIndResp -> %s",map_api_error(H245_ERROR_PARAM));
      InstanceUnlock(pInstance);
      return H245_ERROR_PARAM;
    }

  /* verify the mux table entry id's */
  for (ii=0;ii<dwCount;ii++)
    {
      if ((AccRejMux[ii].MuxEntryId > 15) ||
          (AccRejMux[ii].MuxEntryId <= 0))
        {
          H245TRACE (dwInst,1,"H245MuxTableIndResp -> %s",map_api_error(H245_ERROR_PARAM));
          InstanceUnlock(pInstance);
          return H245_ERROR_PARAM;
        }
    }

  if (!(pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(MltmdSystmCntrlMssg))))
    {
      H245TRACE (dwInst,1,"H245MuxTableIndResp -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  /* if there are any rejects in the list.. send reject */
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));
  if (pdu_rsp_mux_table_rej (pPdu,0,AccRejMux,dwCount) == H245_ERROR_OK)
    FsmOutgoing(pInstance, pPdu, 0);

  /* if there are any accepts in the list.. send accept */
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));
  if (pdu_rsp_mux_table_ack (pPdu,0,AccRejMux,dwCount) == H245_ERROR_OK)
    FsmOutgoing(pInstance, pPdu, 0);

  /* if we've acked all the entries */
  if (!(pTracker->u.MuxEntryCount -= dwCount))
    unlink_dealloc_tracker (pInstance, pTracker);

  MemFree (pPdu);
  H245TRACE (dwInst,4,"H245MuxTableIndResp -> %s",H245_ERROR_OK);
  InstanceUnlock(pInstance);
  return H245_ERROR_OK;

} // H245MuxTableIndResp()



#if 0

/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245MiscCommand
 *
 * DESCRIPTION
 *
 *      HRESULT H245MiscCommand (
 *                              H245_INST_T      dwInst,
 *                              DWORD            wChannel,
 *                              H245_MISC_T     *pMisc
 *                              )
 *      Description:
 *              Send a Misc. command to the remote side (see H245_MISC_T
 *              data Structure)
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              wChannel        Logical Channel Number
 *              pMisc           pointer to a misc. command structure
 *
 *      Call Type:
 *              Synchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_NOT_CONNECTED
 *              H245_ERROR_INVALID_CHANNEL
 *              H245_ERROR_NOMEM
 *              H245_ERROR_PARAM
 *              H245_ERROR_INVALID_INST
 *
 *      callback
 *
 *              H245_IND_MISC
 *
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT H245MiscCommand (
                         H245_INST_T            dwInst,
                         WORD                   wChannel,
                         H245_MISC_T            *pMisc
                        )
{
  register struct InstanceStruct *pInstance;
  HRESULT               lError;
  MltmdSystmCntrlMssg   *pPdu;

  H245TRACE (dwInst,4,"H245MiscCommand <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245MiscCommand -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }
  /* system should be in connected state */

  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245MiscCommand -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* if the channel can not be found */
  if (!find_tracker_by_txchannel(pInstance, wChannel, API_CH_ALLOC_LCL) &&
      !find_tracker_by_rxchannel(pInstance, wChannel, API_CH_ALLOC_RMT))
    {
      H245TRACE (dwInst,1,"H245MiscCommand -> %s",map_api_error(H245_ERROR_INVALID_CHANNEL));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_CHANNEL;
    }

  if (!(pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(MltmdSystmCntrlMssg))))
    {
      H245TRACE (dwInst,1,"H245MiscCommand -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  /* budld pdu for misc command */
  pdu_cmd_misc (pPdu, pMisc, wChannel);

  lError = FsmOutgoing(pInstance, pPdu, 0);
  MemFree (pPdu);
  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245MiscCommand -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245MiscCommand -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245MiscCommand()

#endif


/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245RequestMultiplexEntry
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245RequestMultiplexEntry (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;
  DWORD                           dwIndex;

  H245TRACE (dwInst,4,"H245RequestMultiplexEntry <-");

  if (pwMultiplexTableEntryNumbers == NULL || dwCount < 1 || dwCount > 15)
  {
    H245TRACE (dwInst,1,"H245RequestMultiplexEntry -> %s",map_api_error(H245_ERROR_PARAM));
    return H245_ERROR_PARAM;
  }
  for (dwIndex = 0; dwIndex < dwCount; ++dwIndex)
  {
     if (pwMultiplexTableEntryNumbers[dwIndex] < 1 ||
         pwMultiplexTableEntryNumbers[dwIndex] > 15)
     {
       H245TRACE (dwInst,1,"H245RequestMultiplexEntry -> %s",map_api_error(H245_ERROR_PARAM));
       return H245_ERROR_PARAM;
     }
  }

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245RequestMultiplexEntry -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.choice = requestMultiplexEntry_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMultiplexEntry.entryNumbers.count = (WORD)dwCount;
    for (dwIndex = 0; dwIndex < dwCount; ++dwIndex)
    {
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMultiplexEntry.entryNumbers.value[dwIndex] =
        (MultiplexTableEntryNumber) pwMultiplexTableEntryNumbers[dwIndex];
    }

    lError = FsmOutgoing(pInstance, pPdu, dwTransId);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245RequestMultiplexEntry -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245RequestMultiplexEntry -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245RequestMultiplexEntry()


/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245RequestMultiplexEntryAck
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245RequestMultiplexEntryAck (
                         H245_INST_T            dwInst,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;
  DWORD                           dwIndex;

  H245TRACE (dwInst,4,"H245RequestMultiplexEntryAck <-");

  if (pwMultiplexTableEntryNumbers == NULL || dwCount < 1 || dwCount > 15)
  {
    H245TRACE (dwInst,1,"H245RequestMultiplexEntryAck -> %s",map_api_error(H245_ERROR_PARAM));
    return H245_ERROR_PARAM;
  }

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245RequestMultiplexEntryAck -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = requestMultiplexEntryAck_chosen;
    pPdu->u.MSCMg_rspns.u.requestMultiplexEntryAck.entryNumbers.count = (WORD)dwCount;
    for (dwIndex = 0; dwIndex < dwCount; ++dwIndex)
    {
      pPdu->u.MSCMg_rspns.u.requestMultiplexEntryAck.entryNumbers.value[dwIndex] =
        (MultiplexTableEntryNumber) pwMultiplexTableEntryNumbers[dwIndex];
    }

    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245RequestMultiplexEntryAck -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245RequestMultiplexEntryAck -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245RequestMultiplexEntryAck()


/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245RequestMultiplexEntryReject
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245RequestMultiplexEntryReject (
                         H245_INST_T            dwInst,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;
  DWORD                           dwIndex;

  H245TRACE (dwInst,4,"H245RequestMultiplexEntryReject <-");

  if (pwMultiplexTableEntryNumbers == NULL || dwCount < 1 || dwCount > 15)
  {
    H245TRACE (dwInst,1,"H245RequestMultiplexEntryReject -> %s",map_api_error(H245_ERROR_PARAM));
    return H245_ERROR_PARAM;
  }

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245RequestMultiplexEntryReject -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = rqstMltplxEntryRjct_chosen;
    pPdu->u.MSCMg_rspns.u.rqstMltplxEntryRjct.rejectionDescriptions.count = (WORD)dwCount;
    for (dwIndex = 0; dwIndex < dwCount; ++dwIndex)
    {
      pPdu->u.MSCMg_rspns.u.rqstMltplxEntryRjct.rejectionDescriptions.value[dwIndex].multiplexTableEntryNumber =
        (MultiplexTableEntryNumber) pwMultiplexTableEntryNumbers[dwIndex];
      pPdu->u.MSCMg_rspns.u.rqstMltplxEntryRjct.rejectionDescriptions.value[dwIndex].cause.choice = RMERDs_cs_unspcfdCs_chosen;
    }

    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245RequestMultiplexEntryReject -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245RequestMultiplexEntryReject -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245RequestMultiplexEntryReject()


/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245RequestMode
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245RequestMode         (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
//                         const ModeElement *    pModeElements,
//tomitowoju@intel.com
						 ModeDescription 		ModeDescriptions[],
//tomitowoju@intel.com
                         unsigned long          dwCount
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;
  RequestedModesLink              pLink;
  RequestedModesLink              pLink_First;
  DWORD                           dwIndex;
// tomitowoju@intel.com
  ULONG ulPDUsize;
// tomitowoju@intel.com

  H245TRACE (dwInst,4,"H245RequestMode <-");

//tomitowoju@intel.com							
//  if (pModeElements == NULL || dwCount == 0 || dwCount > 256)
  if (ModeDescriptions == NULL || dwCount == 0 || dwCount > 256)
//tomitowoju@intel.com							
  {
    H245TRACE (dwInst,1,"H245RequestMode -> %s",map_api_error(H245_ERROR_PARAM));
    return H245_ERROR_PARAM;
  }

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245RequestMode -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

//tomitowoju@intel.com							
//  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu) + sizeof(*pLink));
  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu) + (sizeof(*pLink)*(dwCount)));
//tomitowoju@intel.com
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
	USHORT usModeDescIndex =0;
	
    memset(pPdu, 0, sizeof(*pPdu));

    pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.choice = requestMode_chosen;
//tomitowoju@intel.com
//    pLink = (RequestedModesLink)(pPdu + 1);
    pLink = (RequestedModesLink)(pPdu + usModeDescIndex+1);
//tomitowoju@intel.com

//tomitowoju@intel.com
//    pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMode.requestedModes = pLink;
//tomitowoju@intel.com

//tomitowoju@intel.com
	pLink_First = pLink;
//tomitowoju@intel.com
// --> linked list of mode descriptions ... up to 1..256
//tomitowoju@intel.com
     while(usModeDescIndex<=(dwCount-1))
	 {
//tomitowoju@intel.com

			//tomitowoju@intel.com
		 //	pLink->next = NULL;
			//tomitowoju@intel.com



		//  --> number of actual mode-elements associated with this mode description
			//tomitowoju@intel.com
		//		pLink->value.count = (WORD)dwCount;
				pLink->value.count = (WORD)ModeDescriptions[usModeDescIndex].count;
			//tomitowoju@intel.com

//				for (dwIndex = 0; dwIndex < dwCount; ++dwIndex)
				for (dwIndex = 0; dwIndex < ModeDescriptions[usModeDescIndex].count; ++dwIndex)
				{
			//tomitowoju@intel.com
			//      pLink->value.value[dwIndex] = pModeElements[dwIndex];
				  pLink->value.value[dwIndex] = ModeDescriptions[usModeDescIndex].value[dwIndex];
			//tomitowoju@intel.com
				}
			//tomitowoju@intel.com
			usModeDescIndex++;
			if(usModeDescIndex<=(dwCount-1))
			{
		 	pLink->next = (RequestedModesLink)(pPdu + usModeDescIndex+1);
			pLink = pLink->next;
			pLink->next = NULL;
			}
			//tomitowoju@intel.com


//tomitowoju@intel.com
	 }
//tomitowoju@intel.com

//tomitowoju@intel.com
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMode.requestedModes = pLink_First;
//tomitowoju@intel.com
	//--
	 ulPDUsize = (sizeof(*pPdu) + (sizeof(*pLink)*(dwCount)));
	//--
    lError = FsmOutgoing(pInstance, pPdu, dwTransId);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245RequestMode -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245RequestMode -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245RequestMode()





/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245RequestModeAck
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245RequestModeAck      (
                         H245_INST_T            dwInst,
                         unsigned short         wResponse
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245RequestModeAck <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245RequestModeAck -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = requestModeAck_chosen;
    pPdu->u.MSCMg_rspns.u.requestModeAck.response.choice = wResponse;

    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245RequestModeAck -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245RequestModeAck -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245RequestModeAck()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245RequestModeReject
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245RequestModeReject   (
                         H245_INST_T            dwInst,
                         unsigned short         wCause
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245RequestModeReject <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245RequestModeReject -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = requestModeReject_chosen;
    pPdu->u.MSCMg_rspns.u.requestModeReject.cause.choice = wCause;

    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245RequestModeReject -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245RequestModeReject -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245RequestModeReject()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245RoundTripDelayRequest
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245RoundTripDelayRequest (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245RoundTripDelayRequest <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245RoundTripDelayRequest -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.choice = roundTripDelayRequest_chosen;

    lError = FsmOutgoing(pInstance, pPdu, dwTransId);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245RoundTripDelayRequest -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245RoundTripDelayRequest -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245RoundTripDelayRequest()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245MaintenanceLoop
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245MaintenanceLoop     (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
                         H245_LOOP_TYPE_T       dwLoopType,
                         H245_CHANNEL_T         wChannel
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245MaintenanceLoop <-");

  if (dwLoopType < systemLoop_chosen ||
      dwLoopType > logicalChannelLoop_chosen ||
      (dwLoopType != systemLoop_chosen && wChannel == 0))
  {
    H245TRACE (dwInst,1,"H245MaintenanceLoop -> %s",map_api_error(H245_ERROR_PARAM));
    return H245_ERROR_PARAM;
  }

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245MaintenanceLoop -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.choice = maintenanceLoopRequest_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice = (WORD)dwLoopType;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.u.mediaLoop = wChannel;

    lError = FsmOutgoing(pInstance, pPdu, dwTransId);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245MaintenanceLoop -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245MaintenanceLoop -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245MaintenanceLoop()


/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245MaintenanceLoopRelease
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245MaintenanceLoopRelease (H245_INST_T         dwInst)
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245MaintenanceLoopRelease <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245MaintenanceLoopRelease -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_cmmnd_chosen;
    pPdu->u.MSCMg_cmmnd.choice = mntnncLpOffCmmnd_chosen;

    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245MaintenanceLoopRelease -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245MaintenanceLoopRelease -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245MaintenanceLoopRelease()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245MaintenanceLoopAccept
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245MaintenanceLoopAccept (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wChannel
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245MaintenanceLoopAccept <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245MaintenanceLoopAccept -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = maintenanceLoopAck_chosen;
    pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.u.mediaLoop = wChannel;

    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245MaintenanceLoopAccept -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245MaintenanceLoopAccept -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245MaintenanceLoopAccept()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245MaintenanceLoopReject
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245MaintenanceLoopReject (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wChannel,
                         unsigned short         wCause
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245MaintenanceLoopReject <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245MaintenanceLoopReject -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = maintenanceLoopReject_chosen;
    pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.u.mediaLoop = wChannel;
    pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.cause.choice = wCause;

    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245MaintenanceLoopReject -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245MaintenanceLoopReject -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245MaintenanceLoopReject()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245NonStandardObject
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245NonStandardObject   (
                         H245_INST_T            dwInst,
                         H245_MESSAGE_TYPE_T    MessageType,
                         const unsigned char *  pData,
                         unsigned long          dwDataLength,
                         const unsigned short * pwObjectId,
                         unsigned long          dwObjectIdLength
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;
  POBJECTID                       pObject;

  H245TRACE (dwInst,4,"H245NonStandardObject <-");

  if (pData == NULL || dwDataLength == 0 || pwObjectId == NULL || dwObjectIdLength == 0)
  {
    H245TRACE (dwInst,1,"H245NonStandardObject -> %s",map_api_error(H245_ERROR_PARAM));
    return H245_ERROR_PARAM;
  }

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245NonStandardObject -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu) + dwObjectIdLength * sizeof(*pObject));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    switch (MessageType)
    {
    case H245_MESSAGE_REQUEST:
      pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
      pPdu->u.MltmdSystmCntrlMssg_rqst.choice = RqstMssg_nonStandard_chosen;
      break;

    case H245_MESSAGE_RESPONSE:
      pPdu->choice = MSCMg_rspns_chosen;
      pPdu->u.MSCMg_rspns.choice = RspnsMssg_nonStandard_chosen;
      break;

    case H245_MESSAGE_COMMAND:
      pPdu->choice = MSCMg_cmmnd_chosen;
      pPdu->u.MSCMg_cmmnd.choice = CmmndMssg_nonStandard_chosen;
      break;

    case H245_MESSAGE_INDICATION:
      pPdu->choice = indication_chosen;
      pPdu->u.indication.choice = IndctnMssg_nonStandard_chosen;
      break;

    default:
      H245TRACE (dwInst,1,"H245NonStandardObject -> %s",map_api_error(H245_ERROR_PARAM));
      InstanceUnlock(pInstance);
      return H245_ERROR_PARAM;
    } // switch

    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.data.length = (WORD)dwDataLength;
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.data.value  = (unsigned char *)pData;
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.choice = object_chosen;

    // Copy the object identifier
    pObject = (POBJECTID) (pPdu + 1);
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.object = pObject;
    do
    {
      pObject->next = pObject + 1;
      pObject->value = *pwObjectId++;
      ++pObject;
    } while (--dwObjectIdLength);

    // Null terminate the linked list
    --pObject;
    pObject->next = NULL;

    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245NonStandardObject -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245NonStandardObject -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245NonStandardObject()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245NonStandardH221
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245NonStandardH221     (
                         H245_INST_T            dwInst,
                         H245_MESSAGE_TYPE_T    MessageType,
                         const unsigned char *  pData,
                         unsigned long          dwDataLength,
                         unsigned char          byCountryCode,
                         unsigned char          byExtension,
                         unsigned short         wManufacturerCode
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245NonStandard221 <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245NonStandardH221 -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    switch (MessageType)
    {
    case H245_MESSAGE_REQUEST:
      pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
      pPdu->u.MltmdSystmCntrlMssg_rqst.choice = RqstMssg_nonStandard_chosen;
      break;

    case H245_MESSAGE_RESPONSE:
      pPdu->choice = MSCMg_rspns_chosen;
      pPdu->u.MSCMg_rspns.choice = RspnsMssg_nonStandard_chosen;
      break;

    case H245_MESSAGE_COMMAND:
      pPdu->choice = MSCMg_cmmnd_chosen;
      pPdu->u.MSCMg_cmmnd.choice = CmmndMssg_nonStandard_chosen;
      break;

    case H245_MESSAGE_INDICATION:
      pPdu->choice = indication_chosen;
      pPdu->u.indication.choice = IndctnMssg_nonStandard_chosen;
      break;

    default:
      H245TRACE (dwInst,1,"H245NonStandardH221 -> %s",map_api_error(H245_ERROR_PARAM));
      InstanceUnlock(pInstance);
      return H245_ERROR_PARAM;
    } // switch

    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.data.length = (WORD)dwDataLength;
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.data.value  = (unsigned char *)pData;
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.choice = h221NonStandard_chosen;

    // Fill in the H.221 identifier
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.h221NonStandard.t35CountryCode   = byCountryCode;
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.h221NonStandard.t35Extension     = byExtension;
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.h221NonStandard.manufacturerCode = wManufacturerCode;
    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245NonStandardH221 -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245NonStandardH221 -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245NonStandardH221



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245CommunicationModeRequest
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CommunicationModeRequest(H245_INST_T            dwInst)
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245CommunicationModeRequest <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245CommunicationModeRequest -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.choice = communicationModeRequest_chosen;
    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245CommunicationModeRequest -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245CommunicationModeRequest -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245CommunicationModeRequest



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245CommunicationModeResponse
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CommunicationModeResponse(
                         H245_INST_T            dwInst,
                         const H245_COMM_MODE_ENTRY_T *pTable,
                         unsigned char          byTableCount
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError = H245_ERROR_OK;
  CommunicationModeTableLink      pLink;
  unsigned int                    uIndex;

  H245TRACE (dwInst,4,"H245CommunicationModeResponse <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245CommunicationModeResponse -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu) + byTableCount * sizeof(*pLink));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = cmmnctnMdRspns_chosen;
    pPdu->u.MSCMg_rspns.u.cmmnctnMdRspns.choice = communicationModeTable_chosen;
    pLink = (CommunicationModeTableLink)(pPdu + 1);
    pPdu->u.MSCMg_rspns.u.cmmnctnMdRspns.u.communicationModeTable = pLink;
    for (uIndex = 0; uIndex < byTableCount; ++uIndex)
    {
      pLink[uIndex].next = &pLink[uIndex + 1];
      lError = SetupCommModeEntry(&pLink[uIndex].value, &pTable[uIndex]);
      if (lError != H245_ERROR_OK)
         break;
    }
    pLink[byTableCount - 1].next = NULL;
    if (lError == H245_ERROR_OK)
    {
      lError = FsmOutgoing(pInstance, pPdu, 0);
    }
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245CommunicationModeResponse -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245CommunicationModeResponse -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245CommunicationModeResponse()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245CommunicationModeCommand
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CommunicationModeCommand(
                         H245_INST_T            dwInst,
                         const H245_COMM_MODE_ENTRY_T *pTable,
                         unsigned char          byTableCount
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError = H245_ERROR_OK;
  CommunicationModeCommandLink    pLink;
  unsigned int                    uIndex;

  H245TRACE (dwInst,4,"H245CommunicationModeCommand <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245CommunicationModeCommand -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu) + byTableCount * sizeof(*pLink));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_cmmnd_chosen;
    pPdu->u.MSCMg_cmmnd.choice = communicationModeCommand_chosen;
    pLink = (CommunicationModeCommandLink)(pPdu + 1);
    pPdu->u.MSCMg_cmmnd.u.communicationModeCommand.communicationModeTable = pLink;
    for (uIndex = 0; uIndex < byTableCount; ++uIndex)
    {
      pLink[uIndex].next = &pLink[uIndex + 1];
      lError = SetupCommModeEntry(&pLink[uIndex].value, &pTable[uIndex]);
      if (lError != H245_ERROR_OK)
         break;
    }
    pLink[byTableCount - 1].next = NULL;
    if (lError == H245_ERROR_OK)
    {
      lError = FsmOutgoing(pInstance, pPdu, 0);
    }
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245CommunicationModeCommand -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245CommunicationModeCommand -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245CommunicationModeCommand()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245ConferenceRequest
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245ConferenceRequest   (
                         H245_INST_T            dwInst,
                         H245_CONFER_REQ_ENUM_T RequestType,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245ConferenceRequest <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245ConferenceRequest -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.choice = conferenceRequest_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.conferenceRequest.choice = (WORD)RequestType;
    switch (RequestType)
    {
    case dropTerminal_chosen:
    case requestTerminalID_chosen:
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.conferenceRequest.u.dropTerminal.mcuNumber      = byMcuNumber;
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.conferenceRequest.u.dropTerminal.terminalNumber = byTerminalNumber;

      // Fall-through to next case is intentional

    case terminalListRequest_chosen:
    case makeMeChair_chosen:
    case cancelMakeMeChair_chosen:
    case enterH243Password_chosen:
    case enterH243TerminalID_chosen:
    case enterH243ConferenceID_chosen:
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    default:
      lError = H245_ERROR_PARAM;
    } // switch
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245ConferenceRequest -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245ConferenceRequest -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245ConferenceRequest()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245ConferenceResponse
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245ConferenceResponse  (
                         H245_INST_T            dwInst,
                         H245_CONFER_RSP_ENUM_T ResponseType,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber,
                         const unsigned char   *pOctetString,
                         unsigned char          byOctetStringLength,
                         const TerminalLabel   *pTerminalList,
                         unsigned short         wTerminalListCount
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;
  unsigned                        uIndex;

  H245TRACE (dwInst,4,"H245ConferenceResponse <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245ConferenceResponse -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = conferenceResponse_chosen;
    pPdu->u.MSCMg_rspns.u.conferenceResponse.choice = (WORD)ResponseType;
    switch (ResponseType)
    {
    case mCTerminalIDResponse_chosen:
    case terminalIDResponse_chosen:
    case conferenceIDResponse_chosen:
    case passwordResponse_chosen:
      if (pOctetString == NULL ||
          byOctetStringLength == 0 ||
          byOctetStringLength > 128)
      {
          H245TRACE (dwInst,1,"H245ConferenceResponse -> %s",map_api_error(H245_ERROR_PARAM));
          return H245_ERROR_PARAM;
      }
      pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalLabel.mcuNumber      = byMcuNumber;
      pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalLabel.terminalNumber = byTerminalNumber;
      pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalID.length            = byOctetStringLength;
      memcpy(pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalID.value,
             pOctetString,
             byOctetStringLength);

      // Fall-through to next case is intentional

    case videoCommandReject_chosen:
    case terminalDropReject_chosen:
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    case terminalListResponse_chosen:
      if (pTerminalList == NULL ||
          wTerminalListCount == 0 ||
          wTerminalListCount > 256)
      {
          H245TRACE (dwInst,1,"H245ConferenceResponse -> %s",map_api_error(H245_ERROR_PARAM));
          return H245_ERROR_PARAM;
      }
      pPdu->u.MSCMg_rspns.u.conferenceResponse.u.terminalListResponse.count = wTerminalListCount;
      for (uIndex = 0; uIndex < wTerminalListCount; ++uIndex)
      {
        pPdu->u.MSCMg_rspns.u.conferenceResponse.u.terminalListResponse.value[uIndex] =
          pTerminalList[uIndex];
      }
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    case H245_RSP_DENIED_CHAIR_TOKEN:
      pPdu->u.MSCMg_rspns.u.conferenceResponse.choice = makeMeChairResponse_chosen;
      pPdu->u.MSCMg_rspns.u.conferenceResponse.u.makeMeChairResponse.choice = deniedChairToken_chosen;
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    case H245_RSP_GRANTED_CHAIR_TOKEN:
      pPdu->u.MSCMg_rspns.u.conferenceResponse.choice = makeMeChairResponse_chosen;
      pPdu->u.MSCMg_rspns.u.conferenceResponse.u.makeMeChairResponse.choice = grantedChairToken_chosen;
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    default:
      lError = H245_ERROR_PARAM;
    } // switch
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245ConferenceResponse -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245ConferenceResponse -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245ConferenceResponse()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245ConferenceCommand
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245ConferenceCommand   (
                         H245_INST_T            dwInst,
                         H245_CONFER_CMD_ENUM_T CommandType,
                         H245_CHANNEL_T         Channel,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245ConferenceCommand <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245ConferenceCommand -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_cmmnd_chosen;
    pPdu->u.MSCMg_cmmnd.choice = conferenceCommand_chosen;
    pPdu->u.MSCMg_cmmnd.u.conferenceCommand.choice = (WORD)CommandType;
    switch (CommandType)
    {
    case brdcstMyLgclChnnl_chosen:
    case cnclBrdcstMyLgclChnnl_chosen:
      pPdu->u.MSCMg_cmmnd.u.conferenceCommand.u.brdcstMyLgclChnnl = Channel;
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    case ConferenceCommand_makeTerminalBroadcaster_chosen:
    case ConferenceCommand_sendThisSource_chosen:
      pPdu->u.MSCMg_cmmnd.u.conferenceCommand.u.makeTerminalBroadcaster.mcuNumber      = byMcuNumber;
      pPdu->u.MSCMg_cmmnd.u.conferenceCommand.u.makeTerminalBroadcaster.terminalNumber = byTerminalNumber;

      // Fall-through to next case is intentional

    case cnclMkTrmnlBrdcstr_chosen:
    case cancelSendThisSource_chosen:
    case dropConference_chosen:
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    default:
      lError = H245_ERROR_PARAM;
    } // switch
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245ConferenceCommand -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245ConferenceCommand -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245ConferenceCommand()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245ConferenceIndication
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245ConferenceIndication(
                         H245_INST_T            dwInst,
                         H245_CONFER_IND_ENUM_T IndicationType,
                         unsigned char          bySbeNumber,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245ConferenceIndication <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245ConferenceIndication -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = indication_chosen;
    pPdu->u.indication.choice = conferenceIndication_chosen;
    pPdu->u.indication.u.conferenceIndication.choice = (WORD)IndicationType;
    switch (IndicationType)
    {
    case sbeNumber_chosen:
      pPdu->u.indication.u.conferenceIndication.u.sbeNumber = bySbeNumber;
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    case terminalNumberAssign_chosen:
    case terminalJoinedConference_chosen:
    case terminalLeftConference_chosen:
    case terminalYouAreSeeing_chosen:
      pPdu->u.indication.u.conferenceIndication.u.terminalNumberAssign.mcuNumber      = byMcuNumber;
      pPdu->u.indication.u.conferenceIndication.u.terminalNumberAssign.terminalNumber = byTerminalNumber;

      // Fall-through to next case is intentional

    case seenByAtLeastOneOther_chosen:
    case cnclSnByAtLstOnOthr_chosen:
    case seenByAll_chosen:
    case cancelSeenByAll_chosen:
    case requestForFloor_chosen:
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    default:
      lError = H245_ERROR_PARAM;
    } // switch
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245ConferenceIndication -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245ConferenceIndication -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245ConferenceIndication()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245UserInput
 *
 * DESCRIPTION
 *
 *      HRESULT H245UserInput (
 *                           H245_INST_T                         dwInst,
 *                           char                               *pGenString,
 *                           H245_NONSTANDARD_PARAMETER_T       *pNonStd
 *                           )
 *      Description:
 *
 *              Send a User Input indiation to the remote side.  One of the
 *              two parameters must be set (pGenString, pNonStd).  The client
 *              can either send a string or a NonStandard parameter set to the
 *              remote client.  Only one of the two parameters can contain a
 *              value.  The other is required to be NULL.
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              pGenString      choice: String to be sent to remote
 *                              side in accordance with T.51 specification.
 *              pNonStd         choice: NonStandard Parameter
 *
 *      Call Type:
 *              Synchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_NOT_CONNECTED
 *              H245_ERROR_NOMEM
 *              H245_ERROR_PARAM
 *
 *      callback
 *              H245_IND_USERINPUT
 *
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245UserInput           (
                         H245_INST_T                    dwInst,
                         const WCHAR *                        pGenString,
                         const H245_NONSTANDARD_PARAMETER_T * pNonStd
                        )
{
  register struct InstanceStruct *pInstance;
  HRESULT               lError;
  MltmdSystmCntrlMssg   *pPdu;
#if 1
  int                   nLength;
  char *                pszGeneral = NULL;
#endif

  H245TRACE (dwInst,4,"H245UserInput <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245UserInput -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */
  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245UserInput -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(MltmdSystmCntrlMssg));
  if (pPdu == NULL)
    {
      H245TRACE (dwInst,1,"H245UserInput -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  /* build PDU */
#if 1
  if (pGenString)
  {
    nLength = WideCharToMultiByte(CP_ACP,     // code page
                                  0,          // dwFlags
                                  pGenString, // Unicode string
                                  -1,         // Unicode string length (bytes)
                                  NULL,       // ASCII string
                                  0,          // max ASCII string length
                                  NULL,       // default character
                                  NULL);     // default character used
    pszGeneral = MemAlloc(nLength);
    if (pszGeneral == NULL)
    {
      H245TRACE (dwInst,1,"H245UserInput -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
    nLength = WideCharToMultiByte(CP_ACP,       // code page
                                  0,            // dwFlags
                                  pGenString,   // Unicode string
                                  -1,           // Unicode string length (bytes)
                                  pszGeneral,   // ASCII string
                                  nLength,      // max ASCII string length
                                  NULL,         // default character
                                  NULL);        // default character used
    lError = pdu_ind_usrinpt (pPdu, NULL, pszGeneral);
  }
  else
  {
    lError = pdu_ind_usrinpt (pPdu, pNonStd, NULL);
  }
#else
    lError = pdu_ind_usrinpt (pPdu, pNonStd, pGenString);
#endif
  if (lError == H245_ERROR_OK)
    lError = FsmOutgoing(pInstance, pPdu, 0);
#if 1
  if (pszGeneral)
    MemFree(pszGeneral);
#endif
  MemFree (pPdu);
  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245UserInput -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245UserInput -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245UserInput()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245FlowControl
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245FlowControl         (
                         H245_INST_T            dwInst,
                         H245_SCOPE_T           Scope,
                         H245_CHANNEL_T         Channel,       // only used if Scope is H245_SCOPE_CHANNEL_NUMBER
                         unsigned short         wResourceID,   // only used if Scope is H245_SCOPE_RESOURCE_ID
                         unsigned long          dwRestriction  // H245_NO_RESTRICTION if no restriction
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245FlowControl <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245FlowControl -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_cmmnd_chosen;
    pPdu->u.MSCMg_cmmnd.choice = flowControlCommand_chosen;
    pPdu->u.MSCMg_cmmnd.u.flowControlCommand.scope.choice = (WORD)Scope;
    if (dwRestriction == H245_NO_RESTRICTION)
    {
      pPdu->u.MSCMg_cmmnd.u.flowControlCommand.restriction.choice = noRestriction_chosen;
    }
    else
    {
      pPdu->u.MSCMg_cmmnd.u.flowControlCommand.restriction.choice = maximumBitRate_chosen;
      pPdu->u.MSCMg_cmmnd.u.flowControlCommand.restriction.u.maximumBitRate = dwRestriction;
    }
    switch (Scope)
    {
    case FCCd_scp_lgclChnnlNmbr_chosen:
      pPdu->u.MSCMg_cmmnd.u.flowControlCommand.scope.u.FCCd_scp_lgclChnnlNmbr = Channel;
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    case FlwCntrlCmmnd_scp_rsrcID_chosen:
      pPdu->u.MSCMg_cmmnd.u.flowControlCommand.scope.u.FlwCntrlCmmnd_scp_rsrcID = wResourceID;

      // Fall-through to next case

    case FCCd_scp_whlMltplx_chosen:
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    default:
      lError = H245_ERROR_PARAM;
    } // switch
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245FlowControl -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245FlowControl -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245FlowControl()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245H223SkewIndication
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245H223SkewIndication  (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wLogicalChannelNumber1,
                         H245_CHANNEL_T         wLogicalChannelNumber2,
                         unsigned short         wSkew
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245H223SkewIndication <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245H223SkewIndication -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = indication_chosen;
    pPdu->u.indication.choice = h223SkewIndication_chosen;
    pPdu->u.indication.u.h223SkewIndication.logicalChannelNumber1 = wLogicalChannelNumber1;
    pPdu->u.indication.u.h223SkewIndication.logicalChannelNumber2 = wLogicalChannelNumber2;
    pPdu->u.indication.u.h223SkewIndication.skew                  = wSkew;
    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245H223SkewIndication -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245H223SkewIndication -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245H223SkewIndication()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245H2250MaximumSkewIndication
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245H2250MaximumSkewIndication(
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wLogicalChannelNumber1,
                         H245_CHANNEL_T         wLogicalChannelNumber2,
                         unsigned short         wMaximumSkew
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245H2250MaximumSkewIndication <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245H2250MaximumSkewIndication -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = indication_chosen;
    pPdu->u.indication.choice = h2250MxmmSkwIndctn_chosen;
    pPdu->u.indication.u.h2250MxmmSkwIndctn.logicalChannelNumber1 = wLogicalChannelNumber1;
    pPdu->u.indication.u.h2250MxmmSkwIndctn.logicalChannelNumber2 = wLogicalChannelNumber2;
    pPdu->u.indication.u.h2250MxmmSkwIndctn.maximumSkew           = wMaximumSkew;
    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245H2250MaximumSkewIndication -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245H2250MaximumSkewIndication -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245H2250MaximumSkewIndication()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245MCLocationIndication
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245MCLocationIndication(
                         H245_INST_T                dwInst,
                         const H245_TRANSPORT_ADDRESS_T * pSignalAddress
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245MCLocationIndication <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245MCLocationIndication -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = indication_chosen;
    pPdu->u.indication.choice = mcLocationIndication_chosen;
    lError = SetupTransportAddress(&pPdu->u.indication.u.mcLocationIndication.signalAddress,
                                   pSignalAddress);
    if (lError == H245_ERROR_OK)
    {
      lError = FsmOutgoing(pInstance, pPdu, 0);
    }
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245MCLocationIndication -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245MCLocationIndication -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245MCLocationIndication()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245VendorIdentification
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245VendorIdentification(
                         H245_INST_T            dwInst,
                         const H245_NONSTANDID_T *pIdentifier,
                         const unsigned char   *pProductNumber,
                         unsigned char          byProductNumberLength,
                         const unsigned char   *pVersionNumber,
                         unsigned char          byVersionNumberLength
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245VendorIdentification <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245VendorIdentification -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = indication_chosen;
    pPdu->u.indication.choice = vendorIdentification_chosen;
    pPdu->u.indication.u.vendorIdentification.bit_mask = 0;
    pPdu->u.indication.u.vendorIdentification.vendor = *pIdentifier;
    if (pProductNumber != NULL && byProductNumberLength != 0)
    {
      pPdu->u.indication.u.vendorIdentification.bit_mask |= productNumber_present;
      pPdu->u.indication.u.vendorIdentification.productNumber.length = byProductNumberLength;
      memcpy(pPdu->u.indication.u.vendorIdentification.productNumber.value,
             pProductNumber,
             byProductNumberLength);
    }
    if (pVersionNumber != NULL && byVersionNumberLength != 0)
    {
      pPdu->u.indication.u.vendorIdentification.bit_mask |= versionNumber_present;
      pPdu->u.indication.u.vendorIdentification.versionNumber.length = byVersionNumberLength;
      memcpy(pPdu->u.indication.u.vendorIdentification.versionNumber.value,
             pVersionNumber,
             byVersionNumberLength);
    }
    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245VendorIdentification -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245VendorIdentification -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245VendorIdentification()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245SendPDU
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245SendPDU             (
                         H245_INST_T            dwInst,
                         PDU_T *                pPdu
                        )
{
  register struct InstanceStruct *pInstance;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245SendPDU <-");

  // Check for valid instance handle
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245SendPDU -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  lError = FsmOutgoing(pInstance, pPdu, 0);
  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245SendPDU -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245SendPDU -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245SendPDU()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245SystemControl
 *
 * DESCRIPTION
 *
 *      HRESULT H245SystemControl
 *                              (       H245_INST_T     dwInst,
 *                                      DWORD           Request ,
 *                                      VOID            *pData
 *                              )
 *
 *      Description:
 *                      This function should not be used by clients who
 *                      normally interface to the H.245 subsystem.  It is
 *                      defined here to help during development and debug
 *                      of the H.245 subsystem.
 *
 *                      This is a roll your own.. and can do what
 *                      ever the user needs.. It's a hook to allow
 *                      IOCTL (unix) calls that can either be
 *                      passed to lower stack elements (AT&T Streams IOCTL
 *                      would be an example - :) or simply to get or put
 *                      information to the H245 SubSytem.
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              Request         Requested system control
 *              pData           In the case of sending information
 *                              down to H.245 this is an input
 *                              parameter, and it's data format
 *                              is determined by the Request.
 *      output
 *              pData           In the case of retrieving information
 *                              from  H.245 this can be an output
 *                              parameter, and it's data format is
 *                              determined by the Request.  It may not
 *                              have valid data if the request is a
 *                              synchronous request. (See Request Options).
 *      Call Type:
 *
 *              Synchronous
 *
 *      Request Options:
 *
 *        H245_SYSCON_GET_STATS    Retrieves Statistics
 *                                 from H.245 subsystem
 *                                 parameter pData = &H245_SYSCON_STAT_T
 *        H245_ SYSCON_RESET_STATS Resets the statistics
 *                                 pData = NULL
 *        H245_SYS_TRACE           Set Trace Level
 *                                 pData = &DWORD (Trace Level)
 *
 *      Return Values:
 *              See Request Options
 *
 *      Errors:
 *              H245_ERROR_OK
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245SystemControl       (
                         H245_INST_T            dwInst,
                         unsigned long          dwRequest,
                         void   *               pData
                        )
{
  HRESULT                         lError;
  DWORD                           dwTemp;

  H245TRACE(dwInst,4,"H245SystemControl <-");

  if (dwRequest == H245_SYSCON_DUMP_TRACKER)
  {
    register struct InstanceStruct *pInstance = InstanceLock(dwInst);
    if (pInstance == NULL)
    {
      lError = H245_ERROR_INVALID_INST;
    }
    else
    {
      dump_tracker(pInstance);
      InstanceUnlock(pInstance);
      lError = H245_ERROR_OK;
    }
  }
  else if (pData == NULL)
  {
    lError = H245_ERROR_PARAM;
  }
  else
  {
    lError = H245_ERROR_OK;
    switch (dwRequest)
      {
      case H245_SYSCON_GET_FSM_N100:
        *((DWORD *)pData) = (DWORD) uN100;
        H245TRACE(dwInst,20,"H245SystemControl: Get N100 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T101:
        *((DWORD *)pData) = (DWORD) uT101;
        H245TRACE(dwInst,20,"H245SystemControl: Get T101 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T102:
        *((DWORD *)pData) = (DWORD) uT102;
        H245TRACE(dwInst,20,"H245SystemControl: Get T102 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T103:
        *((DWORD *)pData) = (DWORD) uT103;
        H245TRACE(dwInst,20,"H245SystemControl: Get T103 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T104:
        *((DWORD *)pData) = (DWORD) uT104;
        H245TRACE(dwInst,20,"H245SystemControl: Get T104 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T105:
        *((DWORD *)pData) = (DWORD) uT105;
        H245TRACE(dwInst,20,"H245SystemControl: Get T105 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T106:
        *((DWORD *)pData) = (DWORD) uT106;
        H245TRACE(dwInst,20,"H245SystemControl: Get T106 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T107:
        *((DWORD *)pData) = (DWORD) uT107;
        H245TRACE(dwInst,20,"H245SystemControl: Get T107 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T108:
        *((DWORD *)pData) = (DWORD) uT108;
        H245TRACE(dwInst,20,"H245SystemControl: Get T108 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T109:
        *((DWORD *)pData) = (DWORD) uT109;
        H245TRACE(dwInst,20,"H245SystemControl: Get T109 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_SET_FSM_N100:
        dwTemp = (DWORD) uN100;
        uN100  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set N100 = %d",uN100);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T101:
        dwTemp = (DWORD) uT101;
        uT101  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T101 = %d",uT101);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T102:
        dwTemp = (DWORD) uT102;
        uT102  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T102 = %d",uT102);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T103:
        dwTemp = (DWORD) uT103;
        uT103  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T103 = %d",uT103);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T104:
        dwTemp = (DWORD) uT104;
        uT104  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T104 = %d",uT104);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T105:
        dwTemp = (DWORD) uT105;
        uT105  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T105 = %d",uT105);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T106:
        dwTemp = (DWORD) uT106;
        uT106  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T106 = %d",uT106);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T107:
        dwTemp = (DWORD) uT107;
        uT107  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T107 = %d",uT107);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T108:
        dwTemp = (DWORD) uT108;
        uT108  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T108 = %d",uT108);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T109:
        dwTemp = (DWORD) uT109;
        uT109  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T109 = %d",uT109);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_TRACE_LVL:
        dwTemp = TraceLevel;
        TraceLevel = *(DWORD *)pData;
        H245TRACE(dwInst,20,"H245SystemControl: Set TraceLevel = %d",TraceLevel);
        *((DWORD *)pData) = dwTemp;
        break;

      default:
        lError = H245_ERROR_NOTIMP;
    } // switch
  } // else

  if (lError != H245_ERROR_OK)
    H245TRACE(dwInst,1,"H245SystemControl -> %s",map_api_error(lError));
  else
    H245TRACE(dwInst,4,"H245SystemControl -> OK");
  return lError;
} // H245SystemControl()

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\coder.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*																		*
*	$Archive:   S:\sturgeon\src\gkpdu\vcs\coder.cpv  $
*																		*
*	$Revision:   1.5  $
*	$Date:   24 Jan 1997 19:38:44  $
*																		*
*	$Author:   BPOLING  $
*
*	$Log:   S:\sturgeon\src\gkpdu\vcs\coder.cpv  $
//
//    Rev 1.5   24 Jan 1997 19:38:44   BPOLING
// remove string include files, not needed.
//
//    Rev 1.2   18 Dec 1996 21:49:12   BPOLING
// builds with msdev and for windows only
//
//    Rev 1.1   15 Nov 1996 16:17:44   BPOLING
// added vcs headers.
*
*************************************************************************
*																		*
*	CODER.CPP															*
*																		*
*	PURPOSE:															*
*																		*
*	FUNCTIONS:															*
*																		*
*	COMMENTS: 															*
*																		*
*																		*
*************************************************************************
*																		*
*	$History: CODER.CPP													*
*																		*
*																		*
************************************************************************/

/************************************************************************
 * 							Include Files           				   	*
 ***********************************************************************/

#include "precomp.h"

#ifdef __cplusplus
extern "C" {
#endif /*__cplusplus*/

#include   "h225asn.h"
#include   "coder.hpp"

#ifdef __cplusplus
}
#endif /*__cplusplus*/

/************************************************************************
 * 							Local Manifest Constants					*
 ***********************************************************************/
																			
/************************************************************************
*						GLOBAL VARIABLES								*
************************************************************************/


/************************************************************************
 * 							Local Private Data						   	*
 ***********************************************************************/

/************************************************************************
 * 								Start of Code							*
 ***********************************************************************/


Coder::Coder(){
}

Coder::~Coder(){

	EnterCriticalSection(&m_critSec);
	GK_TermWorld(&m_World);
	LeaveCriticalSection(&m_critSec);
	DeleteCriticalSection(&m_critSec);
}

// initializes the oss library.
// the oss library provide ASN.1 encoding / decoding libraries.
//

int Coder::InitCoder()
{

    int	iError = 0;
	m_protocolIdentifier1.next = &m_protocolIdentifier2;
	m_protocolIdentifier1.value = ITU_T;
	m_protocolIdentifier2.next = &m_protocolIdentifier3;
	m_protocolIdentifier2.value = RECOMMENDATION;
	m_protocolIdentifier3.next = &m_protocolIdentifier4;
	m_protocolIdentifier3.value = SERIES;
	m_protocolIdentifier4.next = &m_protocolIdentifier5;
	m_protocolIdentifier4.value = RECOMM_NUMBER;
	m_protocolIdentifier5.next = &m_protocolIdentifier6;
	m_protocolIdentifier5.value = VERSION;
	m_protocolIdentifier6.next = NULL;
	m_protocolIdentifier6.value = ADDITIONAL;
	InitializeCriticalSection(&m_critSec);
	
	// Call TELES Library initialization routine
    EnterCriticalSection(&m_critSec);
    iError = GK_InitWorld(&m_World);
	LeaveCriticalSection(&m_critSec);

	return iError;
}

// ASN.1 Encode a H.323 PDU
// Take a H.323 structure and returns a H.323 PDU
//
int Coder::	Encode(RasMessage *pInputData, ASN1_BUF *pOutputOssBuf){
	int iError;

	// initialize encoding buffer structure values
	pOutputOssBuf->value = NULL;
	pOutputOssBuf->length = 0;

	// encode pdu
	EnterCriticalSection(&m_critSec);
    iError = GK_Encode(&m_World,
                       (void *)pInputData,
                       RasMessage_PDU,
                       pOutputOssBuf);
	LeaveCriticalSection(&m_critSec);
    return iError;
}


int Coder::Decode(ASN1_BUF *pInputOssBuf, RasMessage **pOutputData){
	int iError;

	// NULL tells decoder to malloc memory for RasMessage
	// user must free this memory by calling Coder::FreePDU()
	 *pOutputData = NULL;
	
	// decode the pdu
	EnterCriticalSection(&m_critSec);
    iError = GK_Decode(&m_World,
                       (void **)pOutputData,
                       RasMessage_PDU,
                       pInputOssBuf);
	LeaveCriticalSection(&m_critSec);
	return iError;
}

// Used to free buffer created by decode
int Coder::Free(RasMessage *pData){
	int iError;

	EnterCriticalSection(&m_critSec);
//	iError = freePDU(&m_World,RasMessage_PDU,pData, GKPDU_Module);
	iError = freePDU(&m_World,RasMessage_PDU,pData, H225ASN_Module);
	LeaveCriticalSection(&m_critSec);
	return iError;
}

// Used to free buffer created by encode
void Coder::Free(ASN1_BUF Asn1Buf){
	EnterCriticalSection(&m_critSec);
	//GKPDU_Module->encfree(m_World.pEncInfo,(void *)(Asn1Buf.value));
	ASN1_FreeEncoded(m_World.pEncInfo,(void *)(Asn1Buf.value));
	LeaveCriticalSection(&m_critSec);
}


RequestSeqNum Coder::GetSequenceNumber(RasMessage *prasStruct){
	
	RequestSeqNum rNum = 0;

	switch(prasStruct->choice){
		case gatekeeperRequest_chosen:
			return prasStruct->u.gatekeeperRequest.requestSeqNum;
		case gatekeeperConfirm_chosen:
			return prasStruct->u.gatekeeperConfirm.requestSeqNum;
		case gatekeeperReject_chosen:
			return prasStruct->u.gatekeeperReject.requestSeqNum;
		case registrationRequest_chosen:
			return prasStruct->u.registrationRequest.requestSeqNum;
		case registrationConfirm_chosen:
			return prasStruct->u.registrationConfirm.requestSeqNum;
		case registrationReject_chosen:
			return prasStruct->u.registrationReject.requestSeqNum;
		case unregistrationRequest_chosen:
			return prasStruct->u.unregistrationRequest.requestSeqNum;
		case unregistrationConfirm_chosen:
			return prasStruct->u.unregistrationConfirm.requestSeqNum;
		case unregistrationReject_chosen:
			return prasStruct->u.unregistrationReject.requestSeqNum;
		case admissionRequest_chosen:
			return prasStruct->u.admissionRequest.requestSeqNum;
		case admissionConfirm_chosen:
			return prasStruct->u.admissionConfirm.requestSeqNum;
		case admissionReject_chosen:
			return prasStruct->u.admissionReject.requestSeqNum;
		case bandwidthRequest_chosen:
			return prasStruct->u.bandwidthRequest.requestSeqNum;
		case bandwidthConfirm_chosen:
			return prasStruct->u.bandwidthConfirm.requestSeqNum;
		case bandwidthReject_chosen:
			return prasStruct->u.bandwidthReject.requestSeqNum;
		case disengageRequest_chosen:
			return prasStruct->u.disengageRequest.requestSeqNum;
		case disengageConfirm_chosen:
			return prasStruct->u.disengageConfirm.requestSeqNum;
		case disengageReject_chosen:
			return prasStruct->u.disengageReject.requestSeqNum;
		case locationRequest_chosen:
			return prasStruct->u.locationRequest.requestSeqNum;
		case locationConfirm_chosen:
			return prasStruct->u.locationConfirm.requestSeqNum;
		case locationReject_chosen:
			return prasStruct->u.locationReject.requestSeqNum;
		case infoRequest_chosen:
			return prasStruct->u.infoRequest.requestSeqNum;
		case infoRequestResponse_chosen:
			return prasStruct->u.infoRequestResponse.requestSeqNum;
		case nonStandardMessage_chosen:
			return prasStruct->u.nonStandardMessage.requestSeqNum;
		case unknownMessageResponse_chosen:
			return prasStruct->u.unknownMessageResponse.requestSeqNum;
		default:
			return rNum;
	}

	return rNum;

}


RequestSeqNum Coder::SetSequenceNumber(RasMessage &rasStruct,RequestSeqNum reqNum){
	
	RequestSeqNum rNum = 0;

	switch(rasStruct.choice){
		case gatekeeperRequest_chosen:
			return (rasStruct.u.gatekeeperRequest.requestSeqNum = reqNum);
		case gatekeeperConfirm_chosen:
			return (rasStruct.u.gatekeeperConfirm.requestSeqNum = reqNum);
		case gatekeeperReject_chosen:
			return (rasStruct.u.gatekeeperReject.requestSeqNum = reqNum);
		case registrationRequest_chosen:
			return  (rasStruct.u.registrationRequest.requestSeqNum = reqNum);
		case registrationConfirm_chosen:
			return  (rasStruct.u.registrationConfirm.requestSeqNum = reqNum);
		case registrationReject_chosen:
			return  (rasStruct.u.registrationReject.requestSeqNum = reqNum);
		case unregistrationRequest_chosen:
			return  (rasStruct.u.unregistrationRequest.requestSeqNum = reqNum);
		case unregistrationConfirm_chosen:
			return  (rasStruct.u.unregistrationConfirm.requestSeqNum = reqNum);
		case unregistrationReject_chosen:
			return  (rasStruct.u.unregistrationReject.requestSeqNum = reqNum);
		case admissionRequest_chosen:
			return  (rasStruct.u.admissionRequest.requestSeqNum = reqNum);
		case admissionConfirm_chosen:
			return  (rasStruct.u.admissionConfirm.requestSeqNum = reqNum);
		case admissionReject_chosen:
			return  (rasStruct.u.admissionReject.requestSeqNum = reqNum);
		case bandwidthRequest_chosen:
			return  (rasStruct.u.bandwidthRequest.requestSeqNum = reqNum);
		case bandwidthConfirm_chosen:
			return  (rasStruct.u.bandwidthConfirm.requestSeqNum = reqNum);
		case bandwidthReject_chosen:
			return  (rasStruct.u.bandwidthReject.requestSeqNum = reqNum);
		case disengageRequest_chosen:
			return  (rasStruct.u.disengageRequest.requestSeqNum = reqNum);
		case disengageConfirm_chosen:
			return  (rasStruct.u.disengageConfirm.requestSeqNum = reqNum);
		case disengageReject_chosen:
			return  (rasStruct.u.disengageReject.requestSeqNum = reqNum);
		case locationRequest_chosen:
			return  (rasStruct.u.locationRequest.requestSeqNum = reqNum);
		case locationConfirm_chosen:
			return  (rasStruct.u.locationConfirm.requestSeqNum = reqNum);
		case locationReject_chosen:
			return  (rasStruct.u.locationReject.requestSeqNum = reqNum);
		case infoRequest_chosen:
			return  (rasStruct.u.infoRequest.requestSeqNum = reqNum);
		case infoRequestResponse_chosen:
			return  (rasStruct.u.infoRequestResponse.requestSeqNum = reqNum);
		case nonStandardMessage_chosen:
			return  (rasStruct.u.nonStandardMessage.requestSeqNum = reqNum);
		case unknownMessageResponse_chosen:
			return  (rasStruct.u.unknownMessageResponse.requestSeqNum = reqNum);
		default:
			return (rNum);
	}

	return rNum;

}


// Returns a pointer EndpointIdentifier for any RasMessage
// NULL for RasMessage that have no EndpointIdentifier
EndpointIdentifier *Coder::GetEndpointID(RasMessage *prasStruct)
{

	switch(prasStruct->choice){
		// Message with endpointID
		case registrationConfirm_chosen:
			return &(prasStruct->u.registrationConfirm.endpointIdentifier);
		case unregistrationRequest_chosen:
			// Optional
			return &(prasStruct->u.unregistrationRequest.URt_endpntIdntfr);
		case admissionRequest_chosen:
			return &(prasStruct->u.admissionRequest.endpointIdentifier);
		case bandwidthRequest_chosen:
			return &(prasStruct->u.bandwidthRequest.endpointIdentifier);
		case disengageRequest_chosen:
			return &(prasStruct->u.disengageRequest.endpointIdentifier);
		case infoRequestResponse_chosen:
			return &(prasStruct->u.infoRequestResponse.endpointIdentifier);
 		case locationRequest_chosen:
			// Optional
			return &(prasStruct->u.locationRequest.LctnRqst_endpntIdntfr);

		// Messages without an endpointID
		default:
		case gatekeeperRequest_chosen:
		case gatekeeperConfirm_chosen:
		case gatekeeperReject_chosen:
		case registrationRequest_chosen:
		case nonStandardMessage_chosen:
		case unknownMessageResponse_chosen:
		case registrationReject_chosen:
		case unregistrationConfirm_chosen:
		case unregistrationReject_chosen:
		case admissionConfirm_chosen:
		case admissionReject_chosen:
		case bandwidthReject_chosen:
		case bandwidthConfirm_chosen:
		case disengageConfirm_chosen:
		case disengageReject_chosen:
		case locationConfirm_chosen:
		case locationReject_chosen:
		case infoRequest_chosen:
			return NULL;
	}

	return NULL;


}


ProtocolIdentifier Coder::SetProtocolIdentifier(RasMessage &rasStruct){
	
	switch(rasStruct.choice){
		case gatekeeperRequest_chosen:
			return (rasStruct.u.gatekeeperRequest.protocolIdentifier = &m_protocolIdentifier1);
		case gatekeeperConfirm_chosen:
			return (rasStruct.u.gatekeeperConfirm.protocolIdentifier = &m_protocolIdentifier1);
		case gatekeeperReject_chosen:
			return (rasStruct.u.gatekeeperReject.protocolIdentifier = &m_protocolIdentifier1);
		case registrationRequest_chosen:
			return  (rasStruct.u.registrationRequest.protocolIdentifier = &m_protocolIdentifier1);
		case registrationConfirm_chosen:
			return  (rasStruct.u.registrationConfirm.protocolIdentifier = &m_protocolIdentifier1);
		case registrationReject_chosen:
			return  (rasStruct.u.registrationReject.protocolIdentifier = &m_protocolIdentifier1);

		case unregistrationRequest_chosen:
		case unregistrationConfirm_chosen:
		case unregistrationReject_chosen:
		case admissionRequest_chosen:
		case admissionConfirm_chosen:
		case admissionReject_chosen:
		case bandwidthRequest_chosen:
		case bandwidthConfirm_chosen:
		case bandwidthReject_chosen:
		case disengageRequest_chosen:
		case disengageConfirm_chosen:
		case disengageReject_chosen:
		case locationRequest_chosen:
		case locationConfirm_chosen:
		case locationReject_chosen:
		case infoRequest_chosen:
		case infoRequestResponse_chosen:
		case nonStandardMessage_chosen:
		case unknownMessageResponse_chosen:
		default:
			return NULL;
	}
	return NULL;
}

// Returns TRUE if protocols match, FALSE - otherwise
BOOL Coder::VerifyProtocolIdentifier(RasMessage &rasStruct){
	struct ObjectID_ *pprotID;
	struct ObjectID_ *pmprotID = &m_protocolIdentifier1;

	switch(rasStruct.choice){
		case gatekeeperRequest_chosen:
			{
			pprotID = rasStruct.u.gatekeeperRequest.protocolIdentifier;
			break;
			}
		case gatekeeperConfirm_chosen:
			{
			pprotID = rasStruct.u.gatekeeperConfirm.protocolIdentifier;
			break;
			}
		case gatekeeperReject_chosen:
			{
			pprotID = rasStruct.u.gatekeeperReject.protocolIdentifier;
			break;
			}
		case registrationRequest_chosen:
			{
			pprotID = rasStruct.u.registrationRequest.protocolIdentifier;
			break;
			}
		case registrationConfirm_chosen:
			{
			pprotID = rasStruct.u.registrationConfirm.protocolIdentifier;
			break;
			}
		case registrationReject_chosen:
			{
			pprotID = rasStruct.u.registrationReject.protocolIdentifier;
			break;
			}

		case unregistrationRequest_chosen:
		case unregistrationConfirm_chosen:
		case unregistrationReject_chosen:
		case admissionRequest_chosen:
		case admissionConfirm_chosen:
		case admissionReject_chosen:
		case bandwidthRequest_chosen:
		case bandwidthConfirm_chosen:
		case bandwidthReject_chosen:
		case disengageRequest_chosen:
		case disengageConfirm_chosen:
		case disengageReject_chosen:
		case locationRequest_chosen:
		case locationConfirm_chosen:
		case locationReject_chosen:
		case infoRequest_chosen:
		case infoRequestResponse_chosen:
		case nonStandardMessage_chosen:
		case unknownMessageResponse_chosen:
		default:
			return TRUE; // if no protocolIdentifier -> return TRUE by default;
	}

    while (!pprotID && !pmprotID)
	{
		if (pprotID->value != pmprotID->value)
			return FALSE;
		
		pprotID = pprotID->next;
		pmprotID = pmprotID->next;
	}

	if (!pprotID && !pmprotID)
		 return TRUE;
	else return FALSE;
}

// finds the requested protocol rasAddress and copies it
DWORD Coder::CopyRasAddress(TransportAddress *pDestAddress, PSEQTRANSADDS pSrcSeqRasAddress, unsigned short choice)
{
	if(!pDestAddress) return ASN1_ERR_BADARGS;

	// choice 0 just grabs first address
	if(choice)
	{
		while(pSrcSeqRasAddress)
		{
			if(pSrcSeqRasAddress->value.choice == choice) break;
			pSrcSeqRasAddress = pSrcSeqRasAddress->next;
		}
	}

	if(pSrcSeqRasAddress)
	{
		CopyMemory(pDestAddress,&(pSrcSeqRasAddress->value),sizeof(TransportAddress));
	}
	else
	{
		return ASN1_ERR_BADARGS;
	}

	return ASN1_SUCCESS;
}

DWORD Coder::CopyRasAddress(TransportAddress *pDestAddress, RasMessage *prasStruct, unsigned short choice)
{
	PSEQTRANSADDS pSeqTransAdd;

	if(!pDestAddress) return ASN1_ERR_BADARGS;

	if(prasStruct->choice != registrationRequest_chosen)
		return ASN1_ERR_BADARGS;

	pSeqTransAdd = (PSEQTRANSADDS) prasStruct->u.registrationRequest.rasAddress;

	while(pSeqTransAdd)
	{
		if(pSeqTransAdd->value.choice == choice) break;
		pSeqTransAdd = pSeqTransAdd->next;
	}

	if(pSeqTransAdd)
	{
		CopyMemory(pDestAddress,&(pSeqTransAdd->value),sizeof(TransportAddress));
	}
	else
	{
		return ASN1_ERR_BADARGS;
	}

	return ASN1_SUCCESS;
}

// finds the requested protocol callSignalAddress and copies it
DWORD Coder::CopyCallSignal(TransportAddress *pDestCallSignalAddress, PSEQTRANSADDS pSrcSeqCSAAddress, unsigned short choice)
{
	if(!pDestCallSignalAddress) return ASN1_ERR_BADARGS;

	while(pSrcSeqCSAAddress)
	{
		if(pSrcSeqCSAAddress->value.choice == choice) break;
		pSrcSeqCSAAddress = pSrcSeqCSAAddress->next;
	}

	if(pSrcSeqCSAAddress)
	{
		CopyMemory(pDestCallSignalAddress,&(pSrcSeqCSAAddress->value),sizeof(TransportAddress));
	}
	else
	{
		return ASN1_ERR_BADARGS;
	}

	return ASN1_SUCCESS;
}

DWORD Coder::CopyCallSignal(TransportAddress *pCallSignalAddress, RasMessage *prasStruct, unsigned short choice)
{
	PSEQTRANSADDS pSeqTransAdd;

	if(!pCallSignalAddress) return ASN1_ERR_BADARGS;

	if(prasStruct->choice != registrationRequest_chosen)
		return ASN1_ERR_BADARGS;

	pSeqTransAdd = (PSEQTRANSADDS) prasStruct->u.registrationRequest.callSignalAddress;

	while(pSeqTransAdd)
	{
		if(pSeqTransAdd->value.choice == choice) break;
		pSeqTransAdd = pSeqTransAdd->next;
	}

	if(pSeqTransAdd)
	{
		CopyMemory(pCallSignalAddress,&(pSeqTransAdd->value),sizeof(TransportAddress));
	}
	else
	{
		return ASN1_ERR_BADARGS;
	}

	return ASN1_SUCCESS;
}



// THE FOLLOWING IS ADDED FOR TELES ASN.1 INTEGRATION

extern "C" {

int GK_InitWorld(ASN1_CODER_INFO *pWorld)
{
    int rc;

    ZeroMemory(pWorld, sizeof(*pWorld));

    if (H225ASN_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    rc = ASN1_CreateEncoder(
                H225ASN_Module,           // ptr to mdule
                &(pWorld->pEncInfo),    // ptr to encoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
    if (rc == ASN1_SUCCESS)
    {
        ASSERT(pWorld->pEncInfo != NULL);
        rc = ASN1_CreateDecoder(
                H225ASN_Module,           // ptr to mdule
                &(pWorld->pDecInfo),    // ptr to decoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
        ASSERT(pWorld->pDecInfo != NULL);
    }

    if (rc != ASN1_SUCCESS)
    {
        GK_TermWorld(pWorld);
    }

    return rc;
}

int GK_TermWorld(ASN1_CODER_INFO *pWorld)
{
    if (H225ASN_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    ASN1_CloseEncoder(pWorld->pEncInfo);
    ASN1_CloseDecoder(pWorld->pDecInfo);

    ZeroMemory(pWorld, sizeof(*pWorld));

    return ASN1_SUCCESS;
}

int GK_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, ASN1_BUF *pBuf)
{
	int rc;
    ASN1encoding_t pEncInfo = pWorld->pEncInfo;
    BOOL fBufferSupplied = (pBuf->value != NULL) && (pBuf->length != 0);
    DWORD dwFlags = fBufferSupplied ? ASN1ENCODE_SETBUFFER : ASN1ENCODE_ALLOCATEBUFFER;

	// clean up out parameters
    if (! fBufferSupplied)
    {
        pBuf->length = 0;
        pBuf->value = NULL;
    }

    rc = ASN1_Encode(
                    pEncInfo,                   // ptr to encoder info
                    pStruct,                    // pdu data structure
                    nPDU,                       // pdu id
                    dwFlags,                    // flags
                    pBuf->value,                // buffer
                    pBuf->length);              // buffer size if provided
    if (ASN1_SUCCEEDED(rc))
    {
        if (fBufferSupplied)
        {
            ASSERT(pBuf->value == pEncInfo->buf);
            ASSERT(pBuf->length >= pEncInfo->len);
        }
        else
        {
            pBuf->value = pEncInfo->buf;             // buffer to encode into
        }
        pBuf->length = pEncInfo->len;        // len of encoded data in buffer
    }
    else
    {
		ASSERT(FALSE);
    }
    return rc;
}

int GK_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, ASN1_BUF *pBuf)
{
    ASN1decoding_t pDecInfo = pWorld->pDecInfo;
    BYTE *pEncoded = pBuf->value;
    ULONG cbEncodedSize = pBuf->length;

    int rc = ASN1_Decode(
                    pDecInfo,                   // ptr to encoder info
                    ppStruct,                   // pdu data structure
                    nPDU,                       // pdu id
                    ASN1DECODE_SETBUFFER,       // flags
                    pEncoded,                   // do not provide buffer
                    cbEncodedSize);             // buffer size if provided
    if (ASN1_SUCCEEDED(rc))
    {
        ASSERT(pDecInfo->pos > pDecInfo->buf);
        pBuf->length -= (ULONG)(pDecInfo->pos - pDecInfo->buf);
        pBuf->value = pDecInfo->pos;
    }
    else
    {
		ASSERT(FALSE);
        *ppStruct = NULL;
    }
    return rc;
}

} // extern "C"

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\cpls.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

#ifndef __CPLS_H
#define __CPLS_H

#include <limits.h>

#ifdef WIN32
    #include <precomp.h>
	#include "port32.h"
#endif

#ifdef _WINDOWS
	#ifndef _MSWINDOWS_
		#define _MSWINDOWS_
	#endif
#endif

typedef int HLOG;                          

#ifndef FALSE
	#define FALSE   0
#endif

#ifndef TRUE
	#define TRUE    1
#endif
#ifdef WIN32
	#ifdef BUILDING_CPLS_DLL
		#define CPLS_FAREXPORT __declspec(dllexport)
		#define CPLS_EXPORT __declspec(dllexport)
	#else
		#define CPLS_FAREXPORT __declspec(dllimport)
		#define CPLS_EXPORT __declspec(dllimport)
	#endif
	#ifndef EXPORT
		#define EXPORT
	#endif	// EXPORT
#elif _MSWINDOWS_
	#ifndef CALLBACK
		#define CALLBACK _far _pascal
	#endif
	#ifdef BUILDING_CPLS_DLL
		#define CPLS_FAREXPORT _far _export _pascal
		#define CPLS_EXPORT _export
	#else
		#define CPLS_FAREXPORT _far _pascal
		#define CPLS_EXPORT
	#endif
	#ifndef EXPORT
		#define EXPORT _export
	#endif	// EXPORT
	#ifndef FAR
		#define FAR _far
	#endif
#else    
	#ifndef CALLBACK
		#define CALLBACK      
	#endif
	#define CPLS_FAREXPORT
	#ifndef EXPORT
		#define EXPORT  
	#endif
	#ifndef FAR
		#define FAR
	#endif
#endif  // _MSWINDOWS_  


typedef int BOOL;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef const char FAR* CPLProtocol;
typedef int CPLProtocolID;

#define CONFIG_FILENAME "CPLS.INI"    // internal use only

// Pre-defined event and event category constants.
//
#define String_Event USHRT_MAX
#define Binary_Event USHRT_MAX-1

#define String_Category USHRT_MAX
#define Binary_Category USHRT_MAX-1

#ifdef __cplusplus      
	class CProtocolLog;
	class CProtocolEvent;
	typedef CProtocolEvent FAR* (CALLBACK *CPLEventGenesisProc)( 
															BYTE FAR* pObject,              // in
															CProtocolLog FAR* pSourceLog,   // in
															BOOL bCopyObject );             // in
extern "C"{

// This first one is only for C++ clients...
void CPLS_FAREXPORT CPLRegisterEventGenesisProc( CPLProtocolID ProtocolID, CPLEventGenesisProc pfnGenesisProc );

#endif  // __cplusplus

// Possible file mode values for CPLOpen().
//
#define CPLS_CREATE 0		// Will overwrite an existing file.
#define CPLS_APPEND 1		// Will append to an existing file, or create a new one.

/////////////////////////////////////////////////////////////////////////////
// 					PROTOCOL LOGGING FUNCTIONS
//
// Here is the sequence of functions to call for use of a protocol logger:
//		1) CPLInitialize() or CPLINTInitialize()
//		2) CPLOpen()
//		3) CPLOutput*() or CPLINTOutput*() -- repeat as necessary
//		4) CPLClose()
//		5) CPLUninitialize()
//
// CPLInitialize() - Creates a protocol logger.
// CPLINTInitialize() - The version of CPLInitialize() which must be called
//		by clients which will be calling the CPLINTOuptut*() functions within
//		interrupt context.  CPLINTInitialize may not be called within
//		interrupt context.
// CPLUninitialize() - Releases a protocol logger.  This must be called for
//		every initialized logger before shutdown in order to free associated
//		memory.
// CPLOpen() - Associates a protocol logger with a file (output stream).
// CPLClose() - Releases a logger's usage of a stream.  This function does
//		not block.  A "close" event is placed on the event queue of the
//		stream.  Release of the stream occurs when this "close" event is
//		serviced.
// CPLOutputDebug() - 
// CPLINTOutputDebug() - The version of CPLOutputDebug() safely callable
//		within interrupt context.
// CPLOutputAscii() - 
// CPLINTOutputAscii() - The version of CPLOutputAscii() safely callable
//		within interrupt context.
// CPLOutput() - 
// CPLINTOutput() - The version of CPLOutput() safely callable
//		within interrupt context.
// CPLFlush() - Flushes all events to the stream of the specified logger.
//		Blocks until the flush is complete.
// CPLINTFlush() -  The version of CPLFlush() safely callable within
//		interrupt context.  This version does not block.  A "flush" message
//		is sent to CPLS.  The flush occurs when this flush message is
//		serviced.
// CPLFlushAndClose() -
// CPLEnable() - Enables or disables protocol logging at runtime.
// CPLEnableAsync() - Sets synchronous or asynchronous logging output mode.
//		CURRENTLY NOT SUPPORTED.
// CPLLogAscii() - 
// CPLINTLogAscii() - The version of CPLLogAscii() safely callable
//		within interrupt context.
//
// Only these functions may be called from within interrupt context:
//		CPLINTOutputDebug()
//		CPLINTOutputAscii()
//		CPLINTOutput()
//		CPLINTFlush()
//		CPLEnable()
//		CPLINTLogAscii()
/////////////////////////////////////////////////////////////////////////////
CPLProtocolID CPLS_FAREXPORT WINAPI CPLInitialize( CPLProtocol Protocol );

CPLProtocolID CPLS_FAREXPORT CPLINTInitialize( CPLProtocol Protocol );

int  CPLS_FAREXPORT WINAPI CPLUninitialize( HLOG hlog );

HLOG CPLS_FAREXPORT WINAPI CPLOpen( CPLProtocolID ProtocolID, 
							const char FAR* szName, 
							int FileMode );
HLOG CPLS_FAREXPORT CPLINTOpen( CPLProtocolID ProtocolID, 
							const char FAR* szName, 
							int FileMode );
int  CPLS_FAREXPORT WINAPI CPLClose( HLOG hLog );

int  CPLS_FAREXPORT CPLOutputDebug( HLOG hLog, 
							const char FAR* szString );
int  CPLS_FAREXPORT CPLINTOutputDebug( HLOG hLog, 
							const char FAR* szString );

int  CPLS_FAREXPORT CPLOutputAscii( HLOG hLog, 
							WORD EventID, 
							const char FAR* szEvent, 
							BYTE FAR* pData, 
							int nDataBytes, 
							WORD EventCategory, 
							unsigned long UserData );
int  CPLS_FAREXPORT CPLINTOutputAscii( HLOG hLog, 
							WORD EventID, 
							const char FAR* szEvent, 
							BYTE FAR* pData, 
							int nDataBytes, 
							WORD EventCategory, 
							unsigned long UserData );

int  CPLS_FAREXPORT WINAPI CPLOutput( HLOG hLog, 
							BYTE FAR* pData, 
							int nDataBytes,
							unsigned long UserData );
int  CPLS_FAREXPORT CPLINTOutput( HLOG hLog, 
							BYTE FAR* pData, 
							int nDataBytes,
							unsigned long UserData );

int  CPLS_FAREXPORT CPLFlush( HLOG hLog );
int  CPLS_FAREXPORT CPLINTFlush( HLOG hLog );
int  CPLS_FAREXPORT CPLFlushAndClose( HLOG hLog );

void CPLS_FAREXPORT CPLEnable( BOOL bEnable );
//void CPLS_FAREXPORT CPLEnableAsync( BOOL bEnable );

#ifdef __cplusplus
};      // extern "C"
#endif  // __cplusplus

#define CPLLogAscii( hLog, \
				EventID, \
				pData, \
				nDataBytes, \
				EventCategory, \
				UserData ) \
		CPLOutputAscii( hLog, EventID, #EventID, pData, nDataBytes, EventCategory, UserData )

#define CPLINTLogAscii( hLog, \
				EventID, \
				pData, \
				nDataBytes, \
				EventCategory, \
				UserData ) \
		CPLINTOutputAscii( hLog, EventID, #EventID, pData, nDataBytes, EventCategory, UserData )
		
#endif  // __CPLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\confman.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/confman.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.91  $
 *	$Date:   04 Mar 1997 17:35:06  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#include "precomp.h"

#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "confman.h"
#include "ccutils.h"
#include "chanman.h"
#include "callman.h"


static BOOL		bConferenceInited = FALSE;

static struct {
	PCONFERENCE			pHead;
	LOCK				Lock;
} ConferenceTable;

static struct {
	CC_HCONFERENCE		hConference;
	LOCK				Lock;
} ConferenceHandle;


CC_CONFERENCEID	 InvalidConferenceID;



HRESULT InitConferenceManager()
{
	ASSERT(bConferenceInited == FALSE);

	ConferenceTable.pHead = NULL;
	InitializeLock(&ConferenceTable.Lock);

	ConferenceHandle.hConference = CC_INVALID_HANDLE + 1;
	InitializeLock(&ConferenceHandle.Lock);

	memset(&InvalidConferenceID, 0, sizeof(InvalidConferenceID));

	bConferenceInited = TRUE;
	return CC_OK;
}



HRESULT DeInitConferenceManager()
{
PCONFERENCE	pConference;
PCONFERENCE	pNextConference;

	if (bConferenceInited == FALSE)
		return CC_OK;

	pConference = ConferenceTable.pHead;
	while (pConference != NULL) {
		AcquireLock(&pConference->Lock);
		pNextConference = pConference->pNextInTable;
		FreeConference(pConference);
		pConference = pNextConference;
	}

	DeleteLock(&ConferenceHandle.Lock);
	DeleteLock(&ConferenceTable.Lock);
	bConferenceInited = FALSE;
	return CC_OK;
}



HRESULT _CreateLocalH245H2250MuxCapability(
									PCONFERENCE				pConference)
{
HRESULT				status;
CC_TERMCAP			TermCap;
struct MultipointCapability_mediaDistributionCapability		RXMediaDistributionCapability;
struct MultipointCapability_mediaDistributionCapability		TXMediaDistributionCapability;
struct MultipointCapability_mediaDistributionCapability		RXTXMediaDistributionCapability;

	ASSERT(pConference != NULL);

	if (pConference->pLocalH245H2250MuxCapability != NULL)
		H245FreeCap(pConference->pLocalH245H2250MuxCapability);

	TermCap.Dir = H245_CAPDIR_LCLRXTX;
	TermCap.DataType = H245_DATA_MUX;
	TermCap.ClientType = H245_CLIENT_MUX_H2250;
	TermCap.CapId = 0;  // CapId = 0 is a special case for mux capabilities
	TermCap.Cap.H245Mux_H2250.bit_mask = 0;
	TermCap.Cap.H245Mux_H2250.maximumAudioDelayJitter = 60;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.multicastCapability = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.multiUniCastConference = FALSE;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability = &RXMediaDistributionCapability;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->next = NULL;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.bit_mask = 0;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.centralizedControl = FALSE;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.distributedControl = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.centralizedAudio = FALSE;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.distributedAudio = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.centralizedVideo = FALSE;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.distributedVideo = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.centralizedData = NULL;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.distributedData = NULL;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.multicastCapability = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.multiUniCastConference = FALSE;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability = &TXMediaDistributionCapability;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->next = NULL;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.bit_mask = 0;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.centralizedControl = FALSE;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.distributedControl = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.centralizedAudio = FALSE;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.distributedAudio = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.centralizedVideo = FALSE;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.distributedVideo = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.centralizedData = NULL;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.distributedData = NULL;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.multicastCapability = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.multiUniCastConference = FALSE;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability = &RXTXMediaDistributionCapability;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->next = NULL;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.bit_mask = 0;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.centralizedControl = FALSE;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.distributedControl = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.centralizedAudio = FALSE;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.distributedAudio = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.centralizedVideo = FALSE;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.distributedVideo = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.centralizedData = NULL;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.distributedData = NULL;
	TermCap.Cap.H245Mux_H2250.mcCapability.centralizedConferenceMC = FALSE;
	TermCap.Cap.H245Mux_H2250.mcCapability.decentralizedConferenceMC = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.rtcpVideoControlCapability = FALSE;
	TermCap.Cap.H245Mux_H2250.mediaPacketizationCapability.bit_mask = 0;
	TermCap.Cap.H245Mux_H2250.mediaPacketizationCapability.h261aVideoPacketization = FALSE;
	
	status = H245CopyCap(&pConference->pLocalH245H2250MuxCapability,
						 &TermCap);
					
	return status;
}



HRESULT _AddConferenceToTable(		PCONFERENCE				pConference)
{
PCONFERENCE	pCurrent;

	ASSERT(pConference != NULL);
	ASSERT(pConference->hConference != CC_INVALID_HANDLE);
	ASSERT(pConference->bInTable == FALSE);

	AcquireLock(&ConferenceTable.Lock);

	// If a valid non-zero conference ID was specified, make sure
	// there's not a duplicate in the conference table
	if (!EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID)) {
		pCurrent = ConferenceTable.pHead;
		while (pCurrent != NULL) {
			if (EqualConferenceIDs(&pCurrent->ConferenceID,
				                   &pConference->ConferenceID)) {
				RelinquishLock(&ConferenceTable.Lock);
				return CC_DUPLICATE_CONFERENCE_ID;
			}
			pCurrent = pCurrent->pNextInTable;
		}
	}

	pConference->pNextInTable = ConferenceTable.pHead;
	pConference->pPrevInTable = NULL;
	if (ConferenceTable.pHead != NULL)
		ConferenceTable.pHead->pPrevInTable = pConference;
	ConferenceTable.pHead = pConference;

	pConference->bInTable = TRUE;

	RelinquishLock(&ConferenceTable.Lock);
	return CC_OK;
}



HRESULT _RemoveConferenceFromTable(	PCONFERENCE				pConference)
{
CC_HCONFERENCE	hConference;
BOOL			bTimedOut;

	ASSERT(pConference != NULL);
	ASSERT(pConference->bInTable == TRUE);

	// Caller must have a lock on the conference object;
	// in order to avoid deadlock, we must:
	//   1. unlock the conference object,
	//   2. lock the ConferenceTable,
	//   3. locate the conference object in the ConferenceTable (note that
	//      after step 2, the conference object may be deleted from the
	//      ConferenceTable by another thread),
	//   4. lock the conference object (someone else may have the lock)
	//   5. remove the conference object from the ConferenceTable,
	//   6. unlock the ConferenceTable
	//
	// The caller can now safely unlock and destroy the conference object,
	// since no other thread will be able to find the object (its been
	// removed from the ConferenceTable), and therefore no other thread will
	// be able to lock it.

	// Save the conference handle; its the only way to look up
	// the conference object in the ConferenceTable. Note that we
	// can't use pConference to find the conference object, since
	// pConference may be free'd up, and another conference object
	// allocated at the same address
	hConference = pConference->hConference;

	// step 1
	RelinquishLock(&pConference->Lock);

step2:
	// step 2
	AcquireLock(&ConferenceTable.Lock);

	// step 3
	pConference = ConferenceTable.pHead;
	while ((pConference != NULL) && (pConference->hConference != hConference))
		pConference = pConference->pNextInTable;

	if (pConference != NULL) {
		// step 4
		AcquireTimedLock(&pConference->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ConferenceTable.Lock);
			Sleep(0);
			goto step2;
		}
		// step 5
		if (pConference->pPrevInTable == NULL)
			ConferenceTable.pHead = pConference->pNextInTable;
		else
			pConference->pPrevInTable->pNextInTable = pConference->pNextInTable;

		if (pConference->pNextInTable != NULL)
			pConference->pNextInTable->pPrevInTable = pConference->pPrevInTable;

		pConference->pNextInTable = NULL;
		pConference->pPrevInTable = NULL;
		pConference->bInTable = FALSE;
	}

	// step 6
	RelinquishLock(&ConferenceTable.Lock);

	if (pConference == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT _MakeConferenceHandle(		PCC_HCONFERENCE			phConference)
{
	AcquireLock(&ConferenceHandle.Lock);
	*phConference = ConferenceHandle.hConference++;
	RelinquishLock(&ConferenceHandle.Lock);
	return CC_OK;
}



HRESULT AllocateTerminalNumber(		PCONFERENCE				pConference,
									H245_TERMINAL_LABEL_T	*pH245TerminalLabel)
{
unsigned	i, j;
BYTE	bMask;

	ASSERT(pConference != NULL);
	ASSERT(pH245TerminalLabel != NULL);
	ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
	ASSERT(pConference->tsMultipointController == TS_TRUE);
	
	for (i = 0; i < NUM_TERMINAL_ALLOCATION_SLOTS; i++) {
		bMask = 0x01;
		if (pConference->TerminalNumberAllocation[i] != 0xFF) {
			for (j = 0; j < 8; j++) {
				if ((pConference->TerminalNumberAllocation[i] & bMask) == 0) {
					pConference->TerminalNumberAllocation[i] |= bMask;
					pH245TerminalLabel->mcuNumber = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber;
					pH245TerminalLabel->terminalNumber = (TerminalNumber)((i * 8) + j + 1);
					return CC_OK;
				}
				bMask *= 2;
			}
		}
	}
	// No more terminal numbers are available for this conference
	return CC_BAD_PARAM;
}



HRESULT FreeTerminalNumber(			PCONFERENCE				pConference,
									BYTE					bTerminalNumber)
{
unsigned	i, j;
BYTE	bMask;

	ASSERT(pConference != NULL);

	if (bTerminalNumber > NUM_TERMINAL_ALLOCATION_SLOTS * 8)
		return CC_BAD_PARAM;

	--bTerminalNumber;
	i = bTerminalNumber / 8;
	j = bTerminalNumber % 8;
	bMask = (BYTE)(0x01 << j);
	if ((pConference->TerminalNumberAllocation[i] & bMask) == 0)
		return CC_BAD_PARAM;
	pConference->TerminalNumberAllocation[i] &= ~bMask;
	return CC_OK;
}



HRESULT AllocateChannelNumber(		PCONFERENCE				pConference,
									WORD					*pwChannelNumber)
{
unsigned    i, j;
BYTE	bMask;

	ASSERT(pConference != NULL);
	ASSERT(pwChannelNumber != NULL);

	for (i = 0; i < NUM_CHANNEL_ALLOCATION_SLOTS; i++) {
		bMask = 0x01;
		if (pConference->ChannelNumberAllocation[i] != 0xFF) {
			for (j = 0; j < 8; j++) {
				if ((pConference->ChannelNumberAllocation[i] & bMask) == 0) {
					pConference->ChannelNumberAllocation[i] |= bMask;
					*pwChannelNumber = (WORD) (((i * 8) + j) +
						               (pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber << 8));
					return CC_OK;
				}
				bMask *= 2;
			}
		}
	}
	// No more channel numbers are available for this conference
	*pwChannelNumber = 0;
	return CC_BAD_PARAM;
}



HRESULT FreeChannelNumber(			PCONFERENCE				pConference,
									WORD					wChannelNumber)
{
unsigned    i, j;
BYTE	bMask;

	ASSERT(pConference != NULL);

	wChannelNumber &= 0xFF;

	if ((wChannelNumber > NUM_CHANNEL_ALLOCATION_SLOTS * 8) ||
		(wChannelNumber == 0))
		return CC_BAD_PARAM;

	i = wChannelNumber / 8;
	j = wChannelNumber % 8;
	bMask = (BYTE)(0x01 << j);
	if ((pConference->ChannelNumberAllocation[i] & bMask) == 0)
		return CC_BAD_PARAM;
	pConference->ChannelNumberAllocation[i] &= ~bMask;
	return CC_OK;
}



HRESULT AllocAndLockConference(		PCC_HCONFERENCE			phConference,
									PCC_CONFERENCEID		pConferenceID,
									BOOL					bMultipointCapable,
									BOOL					bForceMultipointController,
									PCC_TERMCAPLIST			pLocalTermCapList,
									PCC_TERMCAPDESCRIPTORS	pLocalTermCapDescriptors,
									PCC_VENDORINFO			pVendorInfo,
									PCC_OCTETSTRING			pTerminalID,
									DWORD_PTR   			dwConferenceToken,
									CC_SESSIONTABLE_CONSTRUCTOR SessionTableConstructor,
									CC_TERMCAP_CONSTRUCTOR	TermCapConstructor,
									CC_CONFERENCE_CALLBACK	ConferenceCallback,
									PPCONFERENCE			ppConference)

{
WORD				i;
HRESULT				status;
TRISTATE			tsMultipointController;
	
	ASSERT(bConferenceInited == TRUE);

	// all parameters should have been validated by the caller
	ASSERT(phConference != NULL);
	ASSERT(pLocalTermCapList != NULL);
#ifdef _DEBUG
	if (pLocalTermCapList->wLength != 0)
		ASSERT(pLocalTermCapList->pTermCapArray != NULL);

	for (i = 0; i < pLocalTermCapList->wLength; i++)
		ASSERT(pLocalTermCapList->pTermCapArray[i] != NULL);

	if (pLocalTermCapDescriptors != NULL) {
		ASSERT(pLocalTermCapDescriptors->pTermCapDescriptorArray != NULL);
		for (i = 0; i < pLocalTermCapDescriptors->wLength; i++)
			ASSERT(pLocalTermCapDescriptors->pTermCapDescriptorArray[i] != NULL);
	}
#endif
	ASSERT(pVendorInfo != NULL);
	ASSERT(SessionTableConstructor != NULL);
	ASSERT(TermCapConstructor != NULL);
	ASSERT(ConferenceCallback != NULL);
	ASSERT(ppConference != NULL);

	// set phConference now, in case we encounter an error
	*phConference = CC_INVALID_HANDLE;

	*ppConference = (PCONFERENCE)MemAlloc(sizeof(CONFERENCE));
	if (*ppConference == NULL)
		return CC_NO_MEMORY;

	if (bForceMultipointController == TRUE)
		tsMultipointController = TS_TRUE;
	else if (bMultipointCapable == TRUE)
		tsMultipointController = TS_UNKNOWN;
	else
		tsMultipointController = TS_FALSE;

	(*ppConference)->bInTable = FALSE;
	(*ppConference)->LocalParticipantInfo.TerminalIDState = TERMINAL_ID_INVALID;
	(*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber = 1;
	(*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber = 255;
	(*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString = NULL;
	(*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength = 0;
 	(*ppConference)->LocalParticipantInfo.pEnqueuedRequestsForTerminalID = NULL;

	for (i = 0; i < NUM_TERMINAL_ALLOCATION_SLOTS; i++)
		(*ppConference)->TerminalNumberAllocation[i] = 0;
	// Channel 0 is reserved for the H.245 control channel
	(*ppConference)->ChannelNumberAllocation[0] = 0x01;
	for (i = 1; i < NUM_CHANNEL_ALLOCATION_SLOTS; i++)
		(*ppConference)->ChannelNumberAllocation[i] = 0;
	(*ppConference)->bMultipointCapable = bMultipointCapable;
	(*ppConference)->bForceMC = bForceMultipointController;
	(*ppConference)->SessionTableConstructor = SessionTableConstructor;
	(*ppConference)->TermCapConstructor = TermCapConstructor;
	(*ppConference)->dwConferenceToken = dwConferenceToken;
	(*ppConference)->bDeferredDelete = FALSE;
	(*ppConference)->bAutoAccept = FALSE;  // ignored unless ConferenceCallback is NULL
	(*ppConference)->LocalEndpointAttached = NEVER_ATTACHED;
	(*ppConference)->ConferenceCallback = ConferenceCallback;
	(*ppConference)->SaveConferenceCallback = ConferenceCallback;
	(*ppConference)->bSessionTableInternallyConstructed = FALSE;
	(*ppConference)->pSessionTable = NULL;
	(*ppConference)->pConferenceH245H2250MuxCapability = NULL;
	(*ppConference)->pConferenceTermCapList = NULL;
	(*ppConference)->pConferenceTermCapDescriptors = NULL;
	(*ppConference)->pLocalH245H2250MuxCapability = NULL;
	(*ppConference)->pLocalH245TermCapList = NULL;
	(*ppConference)->pLocalH245TermCapDescriptors = NULL;
	(*ppConference)->pEnqueuedCalls = NULL;
	(*ppConference)->pPlacedCalls = NULL;
	(*ppConference)->pEstablishedCalls = NULL;
	(*ppConference)->pVirtualCalls = NULL;
	(*ppConference)->pChannels = NULL;
	(*ppConference)->tsMultipointController = tsMultipointController;
	(*ppConference)->tsMaster = TS_UNKNOWN;
	(*ppConference)->pMultipointControllerAddr = NULL;
	(*ppConference)->ConferenceMode = UNCONNECTED_MODE;
	(*ppConference)->pVendorInfo = NULL;
	(*ppConference)->pEnqueuedRequestModeCalls = NULL;
	(*ppConference)->pNextInTable = NULL;
	(*ppConference)->pPrevInTable = NULL;
	
	if (pConferenceID == NULL) {
		pConferenceID = &InvalidConferenceID;
		(*ppConference)->bDynamicConferenceID = TRUE;
	} else
		(*ppConference)->bDynamicConferenceID = FALSE;

	(*ppConference)->ConferenceID = *pConferenceID;

	InitializeLock(&(*ppConference)->Lock);
	AcquireLock(&(*ppConference)->Lock);
	
	status = _MakeConferenceHandle(&(*ppConference)->hConference);
	if (status != CC_OK) {
		FreeConference(*ppConference);
		return status;
	}
	
	if (pTerminalID != NULL) {
		(*ppConference)->bDynamicTerminalID = FALSE;
		(*ppConference)->LocalParticipantInfo.TerminalIDState = TERMINAL_ID_VALID;
		(*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength =
			pTerminalID->wOctetStringLength;
		(*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString =
			(BYTE *)MemAlloc(pTerminalID->wOctetStringLength);
		if ((*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString == NULL) {
			FreeConference(*ppConference);
			return CC_NO_MEMORY;
		}
		memcpy((*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString,
			   pTerminalID->pOctetString,
			   pTerminalID->wOctetStringLength);
	} else {
		(*ppConference)->bDynamicTerminalID = TRUE;
	}

	status = _CreateLocalH245H2250MuxCapability(*ppConference);
	if (status != CC_OK) {
		FreeConference(*ppConference);
		return status;
	}

	// make a local copy of pTermCapList
	status = CopyH245TermCapList(&(*ppConference)->pLocalH245TermCapList,
								 pLocalTermCapList);
	if (status != CC_OK) {
		FreeConference(*ppConference);
		return CC_NO_MEMORY;
	}

	// create a new descriptor list if one was not supplied
	if (pLocalTermCapDescriptors == NULL)
		status = CreateH245DefaultTermCapDescriptors(&(*ppConference)->pLocalH245TermCapDescriptors,
									                 (*ppConference)->pLocalH245TermCapList);
	else
		// make a local copy of pTermCapDescriptors
		status = CopyH245TermCapDescriptors(&(*ppConference)->pLocalH245TermCapDescriptors,
											pLocalTermCapDescriptors);

	if (status != CC_OK) {
		FreeConference(*ppConference);
		return CC_NO_MEMORY;
	}

	status = CopyVendorInfo(&((*ppConference)->pVendorInfo), pVendorInfo);
	if (status != CC_OK) {
		FreeConference(*ppConference);
		return status;
	}

	*phConference = (*ppConference)->hConference;

	// add the conference to the conference table
	status = _AddConferenceToTable(*ppConference);
	if (status != CC_OK)
		FreeConference(*ppConference);

	// CreateConferenceTermCaps() must be called after _AddConferenceToTable(),
	// since it will re-lock the conference object
	if ((*ppConference)->tsMultipointController == TS_TRUE) {
		status = CreateConferenceTermCaps(*ppConference, NULL);
		if (status != CC_OK) {
			FreeConference(*ppConference);
			return status;
		}
	}
	
	return status;
}



HRESULT RemoveCallFromConference(	PCALL					pCall,
									PCONFERENCE				pConference)
{
	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);
	// The call object must have been removed from the call table
	// prior to removing it from the associated conference object.
	// This assures us that no other thread is waiting for a lock on it.
	ASSERT(pCall->bInTable == FALSE);

	if (pCall->pPrev == NULL) {
		// the call object is either at the head of the enqueued call list,
		// the head of the placed call list, the head of the established
		// call list, the head of the virtual call list, or is detached
		// from the conference
		if (pConference->pEnqueuedCalls == pCall)
			// The call is on the enqueued call list
			pConference->pEnqueuedCalls = pCall->pNext;
		else if (pConference->pPlacedCalls == pCall)
			// the call is on the placed call list
			pConference->pPlacedCalls = pCall->pNext;
		else if (pConference->pEstablishedCalls == pCall)
			// the call is on the established call list
			pConference->pEstablishedCalls = pCall->pNext;
		else if (pConference->pVirtualCalls == pCall)
			pConference->pVirtualCalls = pCall->pNext;
	} else
		pCall->pPrev->pNext = pCall->pNext;

	if (pCall->pNext != NULL)
		pCall->pNext->pPrev = pCall->pPrev;

	pCall->pNext = NULL;
	pCall->pPrev = NULL;

	return CC_OK;
}



HRESULT RemoveEnqueuedCallFromConference(
									PCONFERENCE				pConference,
									PCC_HCALL				phCall)
{
	ASSERT(pConference != NULL);
	ASSERT(phCall != NULL);

	if (pConference->pEnqueuedCalls == NULL) {
		// No enqueued calls; this is not an error, since the caller can't tell
		// whether there are any enqueued calls in this conference
		*phCall = CC_INVALID_HANDLE;
		return CC_OK;
	}

	// Move the call object from the enqueued call list to the placed
	// call list.

	// Note that another thread may have a lock on the enqueued call
	// object, and may be trying to delete it; they will first need to
	// lock the conference object (which this thread has locked), remove
	// the call object from the enqueued call list, then free the call object.
	// We are therefore safe in creating a pointer to the call object, although
	// we may not examine or change any of its contents other than hCall (read-only),
	// pNext and pPrev.
	
	*phCall = pConference->pEnqueuedCalls->hCall;
	pConference->pEnqueuedCalls = pConference->pEnqueuedCalls->pNext;
	if (pConference->pEnqueuedCalls != NULL)
		pConference->pEnqueuedCalls->pPrev = NULL;
	return CC_OK;
}



HRESULT RemoveChannelFromConference(PCHANNEL				pChannel,
									PCONFERENCE				pConference)
{
	ASSERT(pChannel != NULL);
	ASSERT(pConference != NULL);

	// The channel object must have been removed from the channel table
	// prior to removing it from the associated conference object.
	// This assures us that no other thread is waiting for a lock on it.
	ASSERT(pChannel->bInTable == FALSE);

	if (pChannel->pPrev == NULL) {
		// the channel object is at the head of the channel list,
		// or has been detached from the conference
		if (pConference->pChannels == pChannel)
			pConference->pChannels = pChannel->pNext;
	} else
		pChannel->pPrev->pNext = pChannel->pNext;

	if (pChannel->pNext != NULL)
		pChannel->pNext->pPrev = pChannel->pPrev;

	pChannel->pNext = NULL;
	pChannel->pPrev = NULL;

	return CC_OK;
}



HRESULT AddEnqueuedCallToConference(PCALL					pCall,
									PCONFERENCE				pConference)
{
	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);
	ASSERT(EqualConferenceIDs(&pCall->ConferenceID, &InvalidConferenceID));
	ASSERT(EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID));
	ASSERT(pConference->pPlacedCalls != NULL);
	// Call cannot already be associated with the conference
	ASSERT(pCall->pNext == NULL);
	ASSERT(pCall->pPrev == NULL);

	pCall->hConference = pConference->hConference;

	pCall->pNext = pConference->pEnqueuedCalls;
	pCall->pPrev = NULL;
	if (pConference->pEnqueuedCalls != NULL) {
		ASSERT(pConference->pEnqueuedCalls->pPrev == NULL);
		pConference->pEnqueuedCalls->pPrev = pCall;
	}
	pConference->pEnqueuedCalls = pCall;
	return CC_OK;
}



HRESULT AddPlacedCallToConference(	PCALL					pCall,
									PCONFERENCE				pConference)
{
	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);

	if (EqualConferenceIDs(&pConference->ConferenceID,
			               &InvalidConferenceID)) {
		// If a conference ID has not been assigned, but there are
		// placed or enqueued calls on the conference, the conference ID
		// will be assigned by a callee when the first of these calls completes.
		// Since pCall has an assigned conference ID (which will differ from
		// the ID to be assigned to this conference), we cannot assign pCall
		// to this conference.
		ASSERT(pConference->pEstablishedCalls == NULL);
		if (pConference->pPlacedCalls != NULL)
			return CC_BAD_PARAM;
		else
			pConference->ConferenceID = pCall->ConferenceID;
	} else
		if (!EqualConferenceIDs(&pConference->ConferenceID,
			                    &pCall->ConferenceID))
			return CC_BAD_PARAM;

	pCall->hConference = pConference->hConference;

	// Unlink pCall from pConference, if necessary
	if (pCall->pPrev == NULL) {
		// pCall is at the head of either the enqueued call list,
		// the placed call list, or the established call list, or
		// is not yet associated with the conference object
		if (pConference->pEnqueuedCalls == pCall)
			pConference->pEnqueuedCalls = pCall->pNext;
		else if (pConference->pPlacedCalls == pCall)
			pConference->pPlacedCalls = pCall->pNext;
		else if (pConference->pEstablishedCalls == pCall)
			pConference->pEstablishedCalls = pCall->pNext;
	} else
		pCall->pPrev->pNext = pCall->pNext;

	if (pCall->pNext != NULL)
		pCall->pNext->pPrev = pCall->pPrev;

	// Now link pCall into the placed call list
	pCall->pNext = pConference->pPlacedCalls;
	pCall->pPrev = NULL;
	if (pConference->pPlacedCalls != NULL) {
		ASSERT(pConference->pPlacedCalls->pPrev == NULL);
		pConference->pPlacedCalls->pPrev = pCall;
	}
	pConference->pPlacedCalls = pCall;
	return CC_OK;
}



HRESULT AddEstablishedCallToConference(
									PCALL					pCall,
									PCONFERENCE				pConference)
{
	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);
	ASSERT((EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID)) ||
		   (EqualConferenceIDs(&pCall->ConferenceID, &pConference->ConferenceID)));

	if (EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID)) {
		// If a conference ID has not been assigned, but there are
		// placed or enqueued calls on the conference, the conference ID
		// will be assigned by a callee when the first of these calls completes.
		// Since pCall has an assigned conference ID (which will differ from
		// the ID to be assigned to this conference), we cannot assign pCall
		// to this conference.
		ASSERT(pConference->pEstablishedCalls == NULL);
		pConference->ConferenceID = pCall->ConferenceID;
	} else if (!EqualConferenceIDs(&pConference->ConferenceID, &pCall->ConferenceID))
		return CC_BAD_PARAM;

	pCall->hConference = pConference->hConference;

	// Unlink pCall from pConference, if necessary
	if (pCall->pPrev == NULL) {
		// pCall is at the head of either the enqueued call list,
		// the placed call list, or the established call list, or
		// is not yet associated with the conference object
		if (pConference->pEnqueuedCalls == pCall)
			pConference->pEnqueuedCalls = pCall->pNext;
		else if (pConference->pPlacedCalls == pCall)
			pConference->pPlacedCalls = pCall->pNext;
		else if (pConference->pEstablishedCalls == pCall)
			pConference->pEstablishedCalls = pCall->pNext;
	} else
		pCall->pPrev->pNext = pCall->pNext;

	if (pCall->pNext != NULL)
		pCall->pNext->pPrev = pCall->pPrev;
	
	// Now link pCall into the established call list
	pCall->pNext = pConference->pEstablishedCalls;
	pCall->pPrev = NULL;
	if (pConference->pEstablishedCalls != NULL) {
		ASSERT(pConference->pEstablishedCalls->pPrev == NULL);
		pConference->pEstablishedCalls->pPrev = pCall;
	}
	pConference->pEstablishedCalls = pCall;
	return CC_OK;
}



HRESULT AddVirtualCallToConference(	PCALL					pCall,
									PCONFERENCE				pConference)
{
	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);
	// this is a bogus ASSERT --- ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
	ASSERT(pConference->tsMultipointController == TS_FALSE);
	// Call cannot already be associated with the conference
	ASSERT(pCall->pNext == NULL);
	ASSERT(pCall->pPrev == NULL);

	pCall->hConference = pConference->hConference;

	pCall->pNext = pConference->pVirtualCalls;
	pCall->pPrev = NULL;
	if (pConference->pVirtualCalls != NULL) {
		ASSERT(pConference->pVirtualCalls->pPrev == NULL);
		pConference->pVirtualCalls->pPrev = pCall;
	}
	pConference->pVirtualCalls = pCall;
	return CC_OK;
}



HRESULT AddChannelToConference(		PCHANNEL				pChannel,
									PCONFERENCE				pConference)
{
PPCHANNEL	ppChannel;

	ASSERT(pChannel != NULL);
	ASSERT((pChannel->bChannelType == TX_CHANNEL) ||
		   (pChannel->bChannelType == RX_CHANNEL) ||
		   (pChannel->bChannelType == TXRX_CHANNEL) ||
		   (pChannel->bChannelType == PROXY_CHANNEL));
	ASSERT(pConference != NULL);
	ASSERT(pChannel->hConference == pConference->hConference);
	ASSERT(pChannel->pNext == NULL);
	ASSERT(pChannel->pPrev == NULL);
	ASSERT(pConference->ConferenceMode != UNCONNECTED_MODE);

	if (pConference->pEstablishedCalls == NULL)
		// Can't open a channel unless we have at least one established call
		return CC_BAD_PARAM;

	ppChannel = &pConference->pChannels;

	pChannel->pNext = *ppChannel;
	pChannel->pPrev = NULL;
	if (*ppChannel != NULL) {
		ASSERT((*ppChannel)->pPrev == NULL);
		(*ppChannel)->pPrev = pChannel;
	}
	*ppChannel = pChannel;
	if (pConference->ConferenceMode == POINT_TO_POINT_MODE)
		pChannel->bMultipointChannel = FALSE;
	else
		pChannel->bMultipointChannel = TRUE;
	return CC_OK;
}



// Caller must have a lock on the conference object
// There must be no calls on this conference object
// (previous calls must have been cleared by calling Hangup())
HRESULT FreeConference(			PCONFERENCE				pConference)
{
CC_HCONFERENCE		hConference;
PCALL				pVirtualCall;
WORD				wNumCalls;
WORD				i;
PCC_HCALL			CallList;
WORD				wNumChannels;
PCC_HCHANNEL		ChannelList;
PCHANNEL			pChannel;

	ASSERT(pConference != NULL);
	ASSERT(pConference->pEnqueuedCalls == NULL);
	ASSERT(pConference->pPlacedCalls == NULL);
	ASSERT(pConference->pEstablishedCalls == NULL);
	
	// caller must have a lock on the conference object,
	// so there's no need to re-lock it
	
	hConference = pConference->hConference;

	if (pConference->bInTable == TRUE)
		if (_RemoveConferenceFromTable(pConference) == CC_BAD_PARAM)
			// the conference object was deleted by another thread,
			// so just return CC_OK
			return CC_OK;

	if (pConference->pLocalH245H2250MuxCapability != NULL)
		H245FreeCap(pConference->pLocalH245H2250MuxCapability);

	// free up the LocalTermCapList elements
	DestroyH245TermCapList(&pConference->pLocalH245TermCapList);

	// free up the local terminal capability descriptors
	DestroyH245TermCapDescriptors(&pConference->pLocalH245TermCapDescriptors);

	if (pConference->pMultipointControllerAddr != NULL)
		MemFree(pConference->pMultipointControllerAddr);

	if (pConference->pVendorInfo != NULL)
		FreeVendorInfo(pConference->pVendorInfo);

	if (pConference->pSessionTable != NULL)
		FreeConferenceSessionTable(pConference);

	if (pConference->pConferenceH245H2250MuxCapability != NULL)
		H245FreeCap(pConference->pConferenceH245H2250MuxCapability);

	if ((pConference->pConferenceTermCapList != NULL) ||
		(pConference->pConferenceTermCapDescriptors != NULL))
		FreeConferenceTermCaps(pConference);

	if (pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString != NULL)
	{
		MemFree(pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString);
		pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString = NULL;
		pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength = 0;
	}
	while (DequeueRequest(&pConference->LocalParticipantInfo.pEnqueuedRequestsForTerminalID, NULL) == CC_OK);

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, VIRTUAL_CALL);
	for (i = 0; i < wNumCalls; i++)
		if (LockCall(CallList[i], &pVirtualCall) == CC_OK)
			FreeCall(pVirtualCall);
	if (CallList != NULL)
		MemFree(CallList);

	EnumerateChannelsInConference(&wNumChannels, &ChannelList, pConference, ALL_CHANNELS);
	for (i = 0; i < wNumChannels; i++)
		if (LockChannel(ChannelList[i], &pChannel) == CC_OK)
		FreeChannel(pChannel);
	if (ChannelList != NULL)
		MemFree(ChannelList);

	while (DequeueRequest(&pConference->pEnqueuedRequestModeCalls, NULL) == CC_OK);

	// since the conference object has been removed from the ConferenceTable,
	// no other thread will be able to find the conference object and obtain
	// a lock, so its safe to unlock the conference object and delete it here
	RelinquishLock(&pConference->Lock);
	DeleteLock(&pConference->Lock);
	MemFree(pConference);
	return CC_OK;
}



HRESULT LockConference(				CC_HCONFERENCE			hConference,
									PPCONFERENCE			ppConference)
{
BOOL	bTimedOut;

	ASSERT(hConference != CC_INVALID_HANDLE);
	ASSERT(ppConference != NULL);

step1:
	AcquireLock(&ConferenceTable.Lock);

	*ppConference = ConferenceTable.pHead;
	while ((*ppConference != NULL) && ((*ppConference)->hConference != hConference))
		*ppConference = (*ppConference)->pNextInTable;

	if (*ppConference != NULL) {
		AcquireTimedLock(&(*ppConference)->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ConferenceTable.Lock);
			Sleep(0);
			goto step1;
		}
	}

	RelinquishLock(&ConferenceTable.Lock);

	if (*ppConference == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT LockConferenceEx(			CC_HCONFERENCE			hConference,
									PPCONFERENCE			ppConference,
									TRISTATE				tsDeferredDelete)
{
BOOL	bTimedOut;

	ASSERT(hConference != CC_INVALID_HANDLE);
	ASSERT(ppConference != NULL);

step1:
	AcquireLock(&ConferenceTable.Lock);

	*ppConference = ConferenceTable.pHead;
	while ((*ppConference != NULL) && ((*ppConference)->hConference != hConference))
		*ppConference = (*ppConference)->pNextInTable;

	if (*ppConference != NULL) {
		AcquireTimedLock(&(*ppConference)->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ConferenceTable.Lock);
			Sleep(0);
			goto step1;
		}
		if (tsDeferredDelete == TS_TRUE) {
			if ((*ppConference)->bDeferredDelete != TRUE) {
				RelinquishLock(&(*ppConference)->Lock);
				*ppConference = NULL;
			}
		} else if (tsDeferredDelete == TS_FALSE) {
			if ((*ppConference)->bDeferredDelete != FALSE) {
				RelinquishLock(&(*ppConference)->Lock);
				*ppConference = NULL;
			}
		}
	}

	RelinquishLock(&ConferenceTable.Lock);

	if (*ppConference == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT ValidateConference(			CC_HCONFERENCE			hConference)
{
PCONFERENCE	pConference;

	ASSERT(hConference != CC_INVALID_HANDLE);

	AcquireLock(&ConferenceTable.Lock);

	pConference = ConferenceTable.pHead;
	while ((pConference != NULL) && (pConference->hConference != hConference))
		pConference = pConference->pNextInTable;

	RelinquishLock(&ConferenceTable.Lock);

	if (pConference == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT LockConferenceID(			PCC_CONFERENCEID		pConferenceID,
									PPCONFERENCE			ppConference)
{
BOOL	bTimedOut;

	ASSERT(!EqualConferenceIDs(pConferenceID, &InvalidConferenceID));
	ASSERT(ppConference != NULL);
	// There may be many conference objects in the table with unassigned
	// conference IDs (ConferenceID = InvalidConferenceID).  The caller may
	// never ask us to search for an unassigned conference ID.

step1:
	AcquireLock(&ConferenceTable.Lock);

	*ppConference = ConferenceTable.pHead;
	while ((*ppConference != NULL) &&
		   (!EqualConferenceIDs(&(*ppConference)->ConferenceID, pConferenceID)))
		*ppConference = (*ppConference)->pNextInTable;

	if (*ppConference != NULL) {
		AcquireTimedLock(&(*ppConference)->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ConferenceTable.Lock);
			Sleep(0);
			goto step1;
		}
	}

	RelinquishLock(&ConferenceTable.Lock);

	if (*ppConference == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT FindChannelInConference(	WORD					wChannel,
									BOOL					bLocalChannel,
									BYTE					bChannelType,
									CC_HCALL				hCall,
									PCC_HCHANNEL			phChannel,
									PCONFERENCE				pConference)
{
PCHANNEL	pChannel;
WORD		wChannelNumber;

	ASSERT(wChannel != 0);
	ASSERT(phChannel != NULL);
	ASSERT(pConference != NULL);

	*phChannel = CC_INVALID_HANDLE;

	pChannel = pConference->pChannels;
	while (pChannel != NULL) {
		if (bLocalChannel)
			wChannelNumber = pChannel->wLocalChannelNumber;
		else
			wChannelNumber = pChannel->wRemoteChannelNumber;
		if ((wChannelNumber == wChannel) &&
		    ((pChannel->bChannelType & bChannelType) != 0) &&
		    ((hCall == CC_INVALID_HANDLE) ||
		    (pChannel->hCall == hCall)))
			break;
		pChannel = pChannel->pNext;
	}
	if (pChannel == NULL)
		return CC_BAD_PARAM;
	*phChannel = pChannel->hChannel;
	return CC_OK;
}



HRESULT EnumerateConferences(		PWORD					pwNumConferences,
									CC_HCONFERENCE			ConferenceList[])
{
WORD		wIndexLimit;
PCONFERENCE	pConference;


	if ((*pwNumConferences != 0) && (ConferenceList == NULL))
		return CC_BAD_PARAM;
	if ((*pwNumConferences == 0) && (ConferenceList != NULL))
		return CC_BAD_PARAM;

	wIndexLimit = *pwNumConferences;
	*pwNumConferences = 0;

	AcquireLock(&ConferenceTable.Lock);

	pConference = ConferenceTable.pHead;
	while (pConference != NULL) {
		if (*pwNumConferences < wIndexLimit)
			ConferenceList[*pwNumConferences] = pConference->hConference;
		(*pwNumConferences)++;
		pConference = pConference->pNextInTable;
	}

	RelinquishLock(&ConferenceTable.Lock);

	return CC_OK;
}



HRESULT EnumerateCallsInConference(	WORD					*pwNumCalls,
									PCC_HCALL				pCallList[],
									PCONFERENCE				pConference,
									BYTE					bCallType)
{
WORD	i;
PCALL	pCall;

	ASSERT(pwNumCalls != NULL);
	ASSERT(pConference != NULL);

	*pwNumCalls = 0;

	if (bCallType & ENQUEUED_CALL) {
		pCall = pConference->pEnqueuedCalls;
		while (pCall != NULL) {
			(*pwNumCalls)++;
			pCall = pCall->pNext;
		}
	}

	if (bCallType & PLACED_CALL) {
		pCall = pConference->pPlacedCalls;
		while (pCall != NULL) {
			(*pwNumCalls)++;
			pCall = pCall->pNext;
		}
	}

	if (bCallType & ESTABLISHED_CALL) {
		pCall = pConference->pEstablishedCalls;
		while (pCall != NULL) {
			(*pwNumCalls)++;
			pCall = pCall->pNext;
		}
	}

	if (bCallType & VIRTUAL_CALL) {
		pCall = pConference->pVirtualCalls;
		while (pCall != NULL) {
			(*pwNumCalls)++;
			pCall = pCall->pNext;
		}
	}

	if (pCallList == NULL)
		return CC_OK;

	if (*pwNumCalls == 0) {
		*pCallList = NULL;
		return CC_OK;
	}

	*pCallList = (PCC_HCALL)MemAlloc(sizeof(CC_HCALL) * (*pwNumCalls));
	if (*pCallList == NULL)
		return CC_NO_MEMORY;

	i = 0;

	if (bCallType & ENQUEUED_CALL) {
		pCall = pConference->pEnqueuedCalls;
		while (pCall != NULL) {
			(*pCallList)[i] = pCall->hCall;
			i++;
			pCall = pCall->pNext;
		}
	}

	if (bCallType & PLACED_CALL) {
		pCall = pConference->pPlacedCalls;
		while (pCall != NULL) {
			(*pCallList)[i] = pCall->hCall;
			i++;
			pCall = pCall->pNext;
		}
	}

	if (bCallType & ESTABLISHED_CALL) {
		pCall = pConference->pEstablishedCalls;
		while (pCall != NULL) {
			(*pCallList)[i] = pCall->hCall;
			i++;
			pCall = pCall->pNext;
		}
	}

	if (bCallType & VIRTUAL_CALL) {
		pCall = pConference->pVirtualCalls;
		while (pCall != NULL) {
			(*pCallList)[i] = pCall->hCall;
			i++;
			pCall = pCall->pNext;
		}
	}
	return CC_OK;
}



HRESULT EnumerateChannelsInConference(
									WORD					*pwNumChannels,
									PCC_HCHANNEL			pChannelList[],
									PCONFERENCE				pConference,
									BYTE					bChannelType)
{
WORD		i;
PCHANNEL	pChannel;

	ASSERT(pwNumChannels != NULL);
	ASSERT(pConference != NULL);

	*pwNumChannels = 0;

	pChannel = pConference->pChannels;

	while (pChannel != NULL) {
		if (pChannel->bChannelType & bChannelType)
			(*pwNumChannels)++;
		pChannel = pChannel->pNext;
	}

	if (pChannelList == NULL)
		return CC_OK;

	if (*pwNumChannels == 0) {
		*pChannelList = NULL;
		return CC_OK;
	}

	*pChannelList = (PCC_HCHANNEL)MemAlloc(sizeof(CC_HCHANNEL) * (*pwNumChannels));
	if (*pChannelList == NULL)
		return CC_NO_MEMORY;

	i = 0;
	pChannel = pConference->pChannels;
		
	while (pChannel != NULL) {
		if (pChannel->bChannelType & bChannelType) {
			(*pChannelList)[i] = pChannel->hChannel;
			i++;
		}
		pChannel = pChannel->pNext;
	}

	return CC_OK;
}



HRESULT EnumerateTerminalLabelsInConference(
									WORD					*pwNumTerminalLabels,
									H245_TERMINAL_LABEL_T   *pH245TerminalLabelList[],
									PCONFERENCE				pConference)
{
WORD	i, j;
WORD	wIndex;
BYTE	bMask;

	ASSERT(pwNumTerminalLabels != NULL);
	ASSERT(pConference != NULL);

	// First count the number of known terminals
	*pwNumTerminalLabels = 0;
	for (i = 0; i < NUM_TERMINAL_ALLOCATION_SLOTS; i++) {
		if (pConference->TerminalNumberAllocation[i] != 0) {
			bMask = 0x01;
			for (j = 0; j < 8; j++) {
				if ((pConference->TerminalNumberAllocation[i] & bMask) != 0)
					(*pwNumTerminalLabels)++;
				bMask *= 2;
			}
		}
	}
	if (pConference->LocalEndpointAttached == ATTACHED)
		(*pwNumTerminalLabels)++;

	if (pH245TerminalLabelList == NULL)
		return CC_OK;

	if (*pwNumTerminalLabels == 0)
		*pH245TerminalLabelList = NULL;

	*pH245TerminalLabelList = (H245_TERMINAL_LABEL_T *)MemAlloc(sizeof(H245_TERMINAL_LABEL_T) *
												       (*pwNumTerminalLabels));
	if (*pH245TerminalLabelList == NULL)
		return CC_NO_MEMORY;

	wIndex = 0;
	for (i = 0; i < NUM_TERMINAL_ALLOCATION_SLOTS; i++) {
		if (pConference->TerminalNumberAllocation[i] != 0) {
			bMask = 0x01;
			for (j = 0; j < 8; j++) {
				if ((pConference->TerminalNumberAllocation[i] & bMask) != 0) {
					(*pH245TerminalLabelList)[wIndex].mcuNumber = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber;
					(*pH245TerminalLabelList)[wIndex].terminalNumber = (TerminalNumber) ((i * 8) + j + 1);
					wIndex++;
				}	
				bMask *= 2;
			}
		}
	}
	if (pConference->LocalEndpointAttached == ATTACHED) {
		(*pH245TerminalLabelList)[wIndex].mcuNumber = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber;
		(*pH245TerminalLabelList)[wIndex].terminalNumber = 0;
	}
	return CC_OK;
}



HRESULT UnlockConference(			PCONFERENCE				pConference)
{
	ASSERT(pConference != NULL);

	RelinquishLock(&pConference->Lock);
	return CC_OK;
}



HRESULT AsynchronousDestroyConference(
									CC_HCONFERENCE			hConference,
									BOOL					bAutoAccept)
{
HRESULT			status;
PCONFERENCE		pConference;
WORD			wNumCalls;
WORD			wNumChannels;
WORD			i;
PCHANNEL		pChannel;
PCC_HCHANNEL	ChannelList;

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		return status;

	status = EnumerateCallsInConference(&wNumCalls, NULL, pConference, REAL_CALLS);
	if (status != CC_OK) {
		UnlockConference(pConference);
		return status;
	}

	// This is an illegal call if:
	// 1. The local endpoint is currently attached;
	// 2. The local endpoint has never been attached, but is in the
	// process of placing a call
	if ((pConference->LocalEndpointAttached == ATTACHED) ||
	    ((pConference->LocalEndpointAttached == NEVER_ATTACHED) &&
		 (wNumCalls > 0))) {
		UnlockConference(pConference);
		return CC_BAD_PARAM;
	}

	pConference->ConferenceCallback = NULL;

	// can't destroy a conference if there are active calls
	if (wNumCalls != 0) {
		pConference->bDeferredDelete = TRUE;
		pConference->bAutoAccept = bAutoAccept;
		UnlockConference(pConference);
		return CC_OK;
	}

	status = EnumerateChannelsInConference(&wNumChannels,
		                                   &ChannelList,
										   pConference,
										   ALL_CHANNELS);
	if (status != CC_OK) {
		UnlockConference(pConference);
		return status;
	}

	// free all the channels
	for (i = 0; i < wNumChannels; i++) {
		if (LockChannel(ChannelList[i], &pChannel) == CC_OK)
			// Notice that since we're going to hangup, we don't need to
			// close any channels
			FreeChannel(pChannel);
	}

	if (ChannelList != NULL)
		MemFree(ChannelList);

	FreeConference(pConference);
	
	return CC_OK;
}



HRESULT FindPeerParticipantInfo(	H245_TERMINAL_LABEL_T	H245TerminalLabel,
									PCONFERENCE				pConference,
									BYTE					bCallType,
									PCALL					*ppCall)
{
WORD		wNumCalls;
PCC_HCALL	CallList;
WORD		i;
HRESULT		status;

	ASSERT(pConference != NULL);
	ASSERT(ppCall != NULL);

	status = EnumerateCallsInConference(&wNumCalls,
										&CallList,
										pConference,
										bCallType);
	if (status != CC_OK)
		return status;

	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], ppCall) == CC_OK) {
			if ((*ppCall)->pPeerParticipantInfo != NULL)
				if (((*ppCall)->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber ==
					 H245TerminalLabel.mcuNumber) &&
					((*ppCall)->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber ==
					 H245TerminalLabel.terminalNumber)) {
						MemFree(CallList);
						return CC_OK;
					}
			UnlockCall(*ppCall);
		}
	}
	if (CallList != NULL)
		MemFree(CallList);
	*ppCall = NULL;
	return CC_BAD_PARAM;
}



HRESULT ReInitializeConference(		PCONFERENCE				pConference)
{
PCALL				pCall;
WORD				wNumCalls;
WORD				i;
PCC_HCALL			CallList;
PCHANNEL			pChannel;
WORD				wNumChannels;
PCC_HCHANNEL		ChannelList;
HRESULT				status;

	ASSERT(pConference != NULL);

	if (pConference->bDynamicConferenceID == TRUE)
		pConference->ConferenceID = InvalidConferenceID;
	
	pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber = 1;
	pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber = 255;
	if (pConference->bDynamicTerminalID == TRUE) {
		pConference->LocalParticipantInfo.TerminalIDState = TERMINAL_ID_INVALID;
		if(pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString != NULL)
		{
		    MemFree(pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString);
    		pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString = NULL;
	    	pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength = 0;
	    }
	}
	while (DequeueRequest(&pConference->LocalParticipantInfo.pEnqueuedRequestsForTerminalID, NULL) == CC_OK);
	for (i = 0; i < NUM_TERMINAL_ALLOCATION_SLOTS; i++)
		pConference->TerminalNumberAllocation[i] = 0;
	// Channel 0 is reserved for the H.245 control channel
	pConference->ChannelNumberAllocation[0] = 0x01;
	for (i = 1; i < NUM_CHANNEL_ALLOCATION_SLOTS; i++)
		pConference->ChannelNumberAllocation[i] = 0;
	pConference->bDeferredDelete = FALSE;
	pConference->bAutoAccept = FALSE;  // ignored unless ConferenceCallback is NULL	
	pConference->LocalEndpointAttached = NEVER_ATTACHED;
	if (pConference->pSessionTable != NULL)
		FreeConferenceSessionTable(pConference);
	_CreateLocalH245H2250MuxCapability(pConference);
	if (pConference->pConferenceH245H2250MuxCapability != NULL) {
		H245FreeCap(pConference->pConferenceH245H2250MuxCapability);
		pConference->pConferenceH245H2250MuxCapability = NULL;
	}
	if ((pConference->pConferenceTermCapList != NULL) ||
		(pConference->pConferenceTermCapDescriptors != NULL))
		FreeConferenceTermCaps(pConference);
	pConference->bSessionTableInternallyConstructed = FALSE;
	pConference->ConferenceCallback = pConference->SaveConferenceCallback;

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ALL_CALLS);
	for (i = 0; i < wNumCalls; i++)
		if (LockCall(CallList[i], &pCall) == CC_OK)
			FreeCall(pCall);
	if (CallList != NULL)
		MemFree(CallList);

	EnumerateChannelsInConference(&wNumChannels, &ChannelList, pConference, ALL_CHANNELS);
	for (i = 0; i < wNumChannels; i++)
		if (LockChannel(ChannelList[i], &pChannel) == CC_OK)
			FreeChannel(pChannel);
	if (ChannelList != NULL)
		MemFree(ChannelList);

	if (pConference->bForceMC == TRUE)
		pConference->tsMultipointController = TS_TRUE;
	else if (pConference->bMultipointCapable == TRUE)
		pConference->tsMultipointController = TS_UNKNOWN;
	else
		pConference->tsMultipointController = TS_FALSE;
	pConference->tsMaster = TS_UNKNOWN;
	pConference->ConferenceMode = UNCONNECTED_MODE;
	if (pConference->pMultipointControllerAddr != NULL) {
		MemFree(pConference->pMultipointControllerAddr);
		pConference->pMultipointControllerAddr = NULL;
	}

	while (DequeueRequest(&pConference->pEnqueuedRequestModeCalls, NULL) == CC_OK);

	if (pConference->tsMultipointController == TS_TRUE)
		status = CreateConferenceTermCaps(pConference, NULL);
	else
		status = CC_OK;

	return status;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\dcall.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\dcall.cpv  $
*																		*
*	$Revision:   1.12  $
*	$Date:   25 Feb 1997 11:46:24  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\dcall.cpv  $
// 
//    Rev 1.12   25 Feb 1997 11:46:24   CHULME
// Memset CallInfo structure to zero to avoid unwanted data
// 
//    Rev 1.11   17 Jan 1997 15:53:50   CHULME
// Put debug variables on conditional compile to avoid release warnings
// 
//    Rev 1.10   17 Jan 1997 09:01:22   CHULME
// Changed reg.h to gkreg.h to avoid name conflict with inc directory
// 
//    Rev 1.9   10 Jan 1997 17:42:04   CHULME
// Added CRV and conferenceID to CallReturnInfo structure
// 
//    Rev 1.8   10 Jan 1997 16:13:36   CHULME
// Removed MFC dependency
// 
//    Rev 1.7   20 Dec 1996 16:38:58   CHULME
// Removed extraneous debug statements
// 
//    Rev 1.6   20 Dec 1996 14:08:32   CHULME
// Swapped send and recv addresses in infoRequestResponse
// 
//    Rev 1.5   19 Dec 1996 19:11:54   CHULME
// Set originator bit in IRR
// 
//    Rev 1.4   19 Dec 1996 17:59:52   CHULME
// Use dest addr from ACF in IRR if call made with just Alias
// 
//    Rev 1.3   17 Dec 1996 18:22:24   CHULME
// Switch src and destination fields on ARQ for Callee
// 
//    Rev 1.2   02 Dec 1996 23:50:52   CHULME
// Added premptive synchronization code
// 
//    Rev 1.1   22 Nov 1996 15:21:20   CHULME
// Added VCS log to the header
*************************************************************************/

// dcall.cpp : Provides the implementation for the CCall class
//

#include "precomp.h"

#include <process.h>
#include "GKICOM.H"
#include "dspider.h"
#include "dgkilit.h"
#include "DGKIPROT.H"
#include "gksocket.h"
#include "GKREG.H"
#include "dcall.h"
#include "GATEKPR.H"
#include "h225asn.h"
#include "coder.hpp"
#include "dgkiext.h"
#include <objbase.h>
#include "iras.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCall construction

CCall::CCall()
{
	// ABSTRACT:  The constructor for the CCall class will initialize
	//            the member variables.  
	// AUTHOR:    Colin Hulme

#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_CONDES, "CCall::CCall()\n", 0);

	memset(&m_CallIdentifier, 0, sizeof(m_CallIdentifier));
	memset(&m_callType, 0, sizeof(CallType));
	m_pRemoteInfo = 0;
	memset(&m_RemoteCallSignalAddress, 0, sizeof(TransportAddress));
	m_pDestExtraCallInfo = 0;
	memset(&m_LocalCallSignalAddress, 0, sizeof(TransportAddress));
	m_bandWidth = 0;
	m_callReferenceValue = 0;
	memset(&m_conferenceID, 0, sizeof(ConferenceIdentifier));
	m_activeMC = 0;
	m_answerCall = 0;

	m_usTimeTilStatus = DEFAULT_STATUS_PERIOD;	// Reset on ACF
	m_uRetryResetCount = GKCALL_RETRY_INTERVAL_SECONDS;
	m_uRetryCountdown =GKCALL_RETRY_INTERVAL_SECONDS;
	m_uMaxRetryCount = GKCALL_RETRY_MAX;
	
	m_CFbandWidth = 0;

	m_CallReturnInfo.hCall = 0;
	memset(&m_CallReturnInfo.callModel, 0, sizeof(CallModel));
	memset(&m_CallReturnInfo.destCallSignalAddress, 0, sizeof(TransportAddress));
	m_CallReturnInfo.bandWidth = 0;
	m_CallReturnInfo.callReferenceValue = 0;
	memset(&m_CallReturnInfo.conferenceID, 0, sizeof(ConferenceIdentifier));

	m_CallReturnInfo.wError = 0;

	m_CFirrFrequency = 0;

	m_State = GK_ADM_PENDING;
	SPIDER_TRACE(SP_STATE, "m_State = GK_ADM_PENDING (%X)\n", this);

	m_pRasMessage = 0;
	m_usRetryCount = 0;
}

/////////////////////////////////////////////////////////////////////////////
// CCall destruction

CCall::~CCall()
{
	// ABSTRACT:  The destructor for the CCall class must free the
	//            memory allocated for the Alias addresses.  It does this by 
	//            deleting the structures and walking the link list.
	// AUTHOR:    Colin Hulme

	SeqAliasAddr	*pAA1, *pAA2;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_CONDES, "CCall::~CCall()\n", 0);

	m_CallReturnInfo.hCall = 0;	// Delete self reference

	// Delete allocated memory for sequence of alias addresses
	pAA1 = m_pRemoteInfo;
	while (pAA1 != 0)
	{
		pAA2 = pAA1->next;
		if (pAA1->value.choice == h323_ID_chosen)
		{
			SPIDER_TRACE(SP_NEWDEL, "del pAA1->value.u.h323_ID.value = %X\n", pAA1->value.u.h323_ID.value);
			delete pAA1->value.u.h323_ID.value;
		}
		SPIDER_TRACE(SP_NEWDEL, "del pAA1 = %X\n", pAA1);
		delete pAA1;
		pAA1 = pAA2;
	}

	pAA1 = m_pDestExtraCallInfo;
	while (pAA1 != 0)
	{
		pAA2 = pAA1->next;
		if (pAA1->value.choice == h323_ID_chosen)
		{
			SPIDER_TRACE(SP_NEWDEL, "del pAA1->value.u.h323_ID.value = %X\n", pAA1->value.u.h323_ID.value);
			delete pAA1->value.u.h323_ID.value;
		}
		SPIDER_TRACE(SP_NEWDEL, "del pAA1 = %X\n", pAA1);
		delete pAA1;
		pAA1 = pAA2;
	}

	// Delete memory for last RAS message if still allocated
	if (m_pRasMessage)
	{
		SPIDER_TRACE(SP_NEWDEL, "del m_pRasMessage = %X\n", m_pRasMessage);
		delete m_pRasMessage;
		m_pRasMessage = 0;
	}
}

HRESULT 
CCall::AddRemoteInfo(AliasAddress& rvalue)
{
	// ABSTRACT:  This procedure is called to add an alias address
	//            to the link list of alias addresses.  This will
	//            be called for each alias on receiving a GKI_AdmissionRequest.
	//            A local copy is made to avoid reliance on the client
	//            keeping the memory valid.
	//            This procedure returns 0 if successful and non-zero 
	//            for a failure.
	// AUTHOR:    Colin Hulme

	SeqAliasAddr	*p1;
	unsigned short	uIdx;
	unsigned short	*pus;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CRegistration::AddRemoteInfo(%X)\n", rvalue.choice);

	if (m_pRemoteInfo == 0)	// First one in the list
	{
		m_pRemoteInfo = new SeqAliasAddr;
		SPIDER_TRACE(SP_NEWDEL, "new m_pRemoteInfo = %X\n", m_pRemoteInfo);
		if (m_pRemoteInfo == 0)
			return (GKI_NO_MEMORY);
		memset(m_pRemoteInfo, 0, sizeof(SeqAliasAddr));
		p1 = m_pRemoteInfo;
	}
	else 
	{
		for (p1 = m_pRemoteInfo; p1->next != 0; p1 = p1->next)
			;						// walk the list til last entry
		p1->next = new SeqAliasAddr;
		SPIDER_TRACE(SP_NEWDEL, "new p1->next = %X\n", p1->next);
		if (p1->next == 0)
			return (GKI_NO_MEMORY);
		memset(p1->next, 0, sizeof(SeqAliasAddr));
		p1 = p1->next;
	}
	p1->next = 0;					// initialize new structure fields
	p1->value = rvalue;
	if (p1->value.choice == h323_ID_chosen)
	{
		pus = new unsigned short[p1->value.u.h323_ID.length];
		SPIDER_TRACE(SP_NEWDEL, "new pus = %X\n", pus);
		if (pus == 0)
			return (GKI_NO_MEMORY);
		memset(pus, 0, sizeof(unsigned short) * p1->value.u.h323_ID.length);
		for (uIdx = 0; uIdx < p1->value.u.h323_ID.length; uIdx++)
			*(pus + uIdx) = *(p1->value.u.h323_ID.value + uIdx);
		p1->value.u.h323_ID.value = pus;
	}
	return (GKI_OK);
}

HRESULT 
CCall::AddDestExtraCallInfo(AliasAddress& rvalue)
{
	// ABSTRACT:  This procedure is called to add an alias address
	//            to the link list of alias addresses.  This will
	//            be called for each alias on receiving a GKI_AdmissionRequest.
	//            A local copy is made to avoid reliance on the client
	//            keeping the memory valid.
	//            This procedure returns 0 if successful and non-zero 
	//            for a failure.
	// AUTHOR:    Colin Hulme

	SeqAliasAddr	*p1;
	unsigned short	uIdx;
	unsigned short	*pus;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CRegistration::AddDestExtraCallInfo(%X)\n", rvalue.choice);

	if (m_pDestExtraCallInfo == 0)	// First one in the list
	{
		m_pDestExtraCallInfo = new SeqAliasAddr;
		SPIDER_TRACE(SP_NEWDEL, "new m_pDestExtraCallInfo = %X\n", m_pDestExtraCallInfo);
		if (m_pDestExtraCallInfo == 0)
			return (GKI_NO_MEMORY);
		memset(m_pDestExtraCallInfo, 0, sizeof(SeqAliasAddr));
		p1 = m_pDestExtraCallInfo;
	}
	else 
	{
		for (p1 = m_pDestExtraCallInfo; p1->next != 0; p1 = p1->next)
			;						// walk the list til last entry
		p1->next = new SeqAliasAddr;
		SPIDER_TRACE(SP_NEWDEL, "new p1->next = %X\n", p1->next);
		if (p1->next == 0)
			return (GKI_NO_MEMORY);
		memset(p1->next, 0, sizeof(SeqAliasAddr));
		p1 = p1->next;
	}
	p1->next = 0;					// initialize new structure fields
	p1->value = rvalue;
	if (p1->value.choice == h323_ID_chosen)
	{
		pus = new unsigned short[p1->value.u.h323_ID.length];
		SPIDER_TRACE(SP_NEWDEL, "new pus = %X\n", pus);
		if (pus == 0)
			return (GKI_NO_MEMORY);
		memset(pus, 0, sizeof(unsigned short) * p1->value.u.h323_ID.length);
		for (uIdx = 0; uIdx < p1->value.u.h323_ID.length; uIdx++)
			*(pus + uIdx) = *(p1->value.u.h323_ID.value + uIdx);
		p1->value.u.h323_ID.value = pus;
	}
	return (GKI_OK);
}

HRESULT 
CCall::SetLocalCallSignalAddress(unsigned short usCallTransport)
{
	TransportAddress	*pTA;

	pTA = g_pReg->GetTransportAddress(usCallTransport);
	if (pTA == NULL)
		return (GKI_NO_TA_ERROR);
	m_LocalCallSignalAddress = *pTA;
	return (GKI_OK);
}

void 
CCall::SetConferenceID(ConferenceIdentifier *pCID)
{
	if ((pCID == NULL) || (pCID->length == 0))
		GenerateConferenceID();
	else
		m_conferenceID = *pCID;
}

void
CCall::GenerateConferenceID(void)
{
	CoCreateGuid((struct _GUID *)m_conferenceID.value);
	m_conferenceID.length = 16;
}

HRESULT 
CCall::AdmissionRequest(void)
{
	// ABSTRACT:  This procedure will create an AdmissionRequest structure
	//            call the encoder and send the PDU.  If it is successful, it
	//            will return 0, else it will return an error code.  Note:  The
	//            memory allocated for the RAS Message is not freed until either
	//            a response from the gatekeeper or it times out.  This allows
	//            for retransmission without having to rebuild this message.
	// AUTHOR:    Colin Hulme

	ASN1_BUF		Asn1Buf;
	DWORD			dwErrorCode;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CCall::AdmissionRequest()\n", 0);
	ASSERT(g_pCoder);
	if (g_pCoder == NULL)
		return (GKI_NOT_INITIALIZED);	
		
	// Copy call reference value and CRV into the return info structure
	m_CallReturnInfo.callReferenceValue = m_callReferenceValue;
	m_CallReturnInfo.conferenceID = m_conferenceID;

	// Allocate a RasMessage structure and initialized to 0
	m_usRetryCount = 0;
	m_uRetryCountdown = m_uRetryResetCount;

	m_pRasMessage = new RasMessage;
	SPIDER_TRACE(SP_NEWDEL, "new m_pRasMessage = %X\n", m_pRasMessage);
	if (m_pRasMessage == 0)
		return (GKI_NO_MEMORY);
	memset(m_pRasMessage, 0, sizeof(RasMessage));

	// Setup structure fields for AdmissionRequest
	m_pRasMessage->choice = admissionRequest_chosen;
	
	if (m_pDestExtraCallInfo != 0)
		m_pRasMessage->u.admissionRequest.bit_mask |= AdmissionRequest_destExtraCallInfo_present;
	
	m_pRasMessage->u.admissionRequest.requestSeqNum = g_pReg->GetNextSeqNum();
	m_pRasMessage->u.admissionRequest.callType = m_callType;
	m_pRasMessage->u.admissionRequest.endpointIdentifier = g_pReg->GetEndpointIdentifier();
	memcpy(&m_pRasMessage->u.admissionRequest.callIdentifier.guid.value,
		&m_CallIdentifier, sizeof(GUID));
	m_pRasMessage->u.admissionRequest.callIdentifier.guid.length = sizeof(GUID);
	
	m_pRasMessage->u.admissionRequest.bit_mask |= AdmissionRequest_callIdentifier_present;
	
	if (m_answerCall)	// Src & Dest are swapped in callee
	{
		if (g_pReg->GetAlias() != NULL)
		{
			m_pRasMessage->u.admissionRequest.bit_mask 
				|= AdmissionRequest_destinationInfo_present;
		}
		if (m_LocalCallSignalAddress.choice != 0)
		{
			m_pRasMessage->u.admissionRequest.bit_mask 
				|= AdmissionRequest_destCallSignalAddress_present;
		}
		m_pRasMessage->u.admissionRequest.destinationInfo = (PAdmissionRequest_destinationInfo)g_pReg->GetAlias();
		m_pRasMessage->u.admissionRequest.destCallSignalAddress = m_LocalCallSignalAddress;
		m_pRasMessage->u.admissionRequest.srcInfo = (PAdmissionRequest_srcInfo)m_pRemoteInfo;
   		if (m_RemoteCallSignalAddress.choice != 0)
   		{
			m_pRasMessage->u.admissionRequest.bit_mask |= srcCallSignalAddress_present;
			m_pRasMessage->u.admissionRequest.srcCallSignalAddress = m_RemoteCallSignalAddress;
		}
	}
	else
	{
		if (m_pRemoteInfo != 0)
		{
			m_pRasMessage->u.admissionRequest.bit_mask 
				|= AdmissionRequest_destinationInfo_present;
		}
		else if (m_RemoteCallSignalAddress.choice != 0)
		{
			m_pRasMessage->u.admissionRequest.bit_mask 
				|= AdmissionRequest_destCallSignalAddress_present;
			m_pRasMessage->u.admissionRequest.destCallSignalAddress = m_RemoteCallSignalAddress;
		}
		m_pRasMessage->u.admissionRequest.destinationInfo = (PAdmissionRequest_destinationInfo)m_pRemoteInfo;
		m_pRasMessage->u.admissionRequest.srcInfo = (PAdmissionRequest_srcInfo)g_pReg->GetAlias();
	}
	m_pRasMessage->u.admissionRequest.destExtraCallInfo = (PAdmissionRequest_destExtraCallInfo)m_pDestExtraCallInfo;
	m_pRasMessage->u.admissionRequest.bandWidth = m_bandWidth;
	m_pRasMessage->u.admissionRequest.callReferenceValue = m_callReferenceValue;
	m_pRasMessage->u.admissionRequest.conferenceID = m_conferenceID;
	// The following casts are because ASN1_BOOL is a char and BOOL is an int
	// since the values of m_activeMC and m_answerCall are always 0 or 1, the
	// cast to char causes no loss of data
	m_pRasMessage->u.admissionRequest.activeMC = (ASN1_BOOL)m_activeMC;
	m_pRasMessage->u.admissionRequest.answerCall = (ASN1_BOOL)m_answerCall;

#ifdef _DEBUG
    if (dwGKIDLLFlags & SP_DUMPMEM)
        DumpMem(m_pRasMessage, sizeof(RasMessage));
#endif

	// Encode the PDU & send it
	dwErrorCode = g_pCoder->Encode(m_pRasMessage, &Asn1Buf);
	if (dwErrorCode)
		return (GKI_ENCODER_ERROR);

	// Create a backup copy of the encoded PDU if using debug echo support
	if (fGKIEcho)
	{
		pEchoBuff = new char[Asn1Buf.length];
		SPIDER_TRACE(SP_NEWDEL, "new pEchoBuff = %X\n", pEchoBuff);
		if (pEchoBuff == 0)
			return (GKI_NO_MEMORY);
		memcpy(pEchoBuff, (char *)Asn1Buf.value, Asn1Buf.length);
		nEchoLen = Asn1Buf.length;
	}

	SPIDER_TRACE(SP_PDU, "Send ARQ; pCall = %X\n", this);
	if (fGKIDontSend == FALSE)
		if (g_pReg->m_pSocket->Send((char *)Asn1Buf.value, Asn1Buf.length) == SOCKET_ERROR)
			return (GKI_WINSOCK2_ERROR(SOCKET_ERROR));

	// Free the encoder memory
	g_pCoder->Free(Asn1Buf);

	return (GKI_OK);
}

HRESULT 
CCall::BandwidthRequest(void)
{
	// ABSTRACT:  This procedure will create a bandwidthRequest structure
	//            call the encoder and send the PDU.  If it is successful, it
	//            will return 0, else it will return an error code.
	// AUTHOR:    Colin Hulme

	ASN1_BUF		Asn1Buf;
	DWORD			dwErrorCode;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CCall::BandwidthRequest()\n", 0);
	ASSERT(g_pCoder);
	if (g_pCoder == NULL)
		return (GKI_NOT_INITIALIZED);	
		
	// Allocate a RasMessage structure and initialized to 0
	m_usRetryCount = 0;
	m_uRetryCountdown = m_uRetryResetCount;
	
	m_pRasMessage = new RasMessage;
	SPIDER_TRACE(SP_NEWDEL, "new m_pRasMessage = %X\n", m_pRasMessage);
	if (m_pRasMessage == 0)
		return (GKI_NO_MEMORY);
	memset(m_pRasMessage, 0, sizeof(RasMessage));

	// Setup structure fields for BandwidthRequest
	m_pRasMessage->choice = bandwidthRequest_chosen;
	m_pRasMessage->u.bandwidthRequest.bit_mask = callType_present;
	
	m_pRasMessage->u.bandwidthRequest.requestSeqNum = g_pReg->GetNextSeqNum();
	m_pRasMessage->u.bandwidthRequest.endpointIdentifier = g_pReg->GetEndpointIdentifier();
	m_pRasMessage->u.bandwidthRequest.conferenceID = m_conferenceID;
	m_pRasMessage->u.bandwidthRequest.callReferenceValue = m_callReferenceValue;
	m_pRasMessage->u.bandwidthRequest.callType = m_callType;
	m_pRasMessage->u.bandwidthRequest.bandWidth = m_bandWidth;
	memcpy(&m_pRasMessage->u.bandwidthRequest.callIdentifier.guid.value,
		&m_CallIdentifier, sizeof(GUID));
	m_pRasMessage->u.bandwidthRequest.callIdentifier.guid.length = sizeof(GUID);
	
	m_pRasMessage->u.bandwidthRequest.bit_mask 
		|= BandwidthRequest_callIdentifier_present;

#ifdef _DEBUG
    if (dwGKIDLLFlags & SP_DUMPMEM)
        DumpMem(m_pRasMessage, sizeof(RasMessage));
#endif

	// Encode the PDU & send it
	dwErrorCode = g_pCoder->Encode(m_pRasMessage, &Asn1Buf);
	if (dwErrorCode)
		return (GKI_ENCODER_ERROR);

	// Create a backup copy of the encoded PDU if using debug echo support
	if (fGKIEcho)
	{
		pEchoBuff = new char[Asn1Buf.length];
		SPIDER_TRACE(SP_NEWDEL, "new pEchoBuff = %X\n", pEchoBuff);
		if (pEchoBuff == 0)
			return (GKI_NO_MEMORY);
		memcpy(pEchoBuff, (char *)Asn1Buf.value, Asn1Buf.length);
		nEchoLen = Asn1Buf.length;
	}

	m_State = GK_BW_PENDING;
	SPIDER_TRACE(SP_STATE, "m_State = GK_BW_PENDING (%X)\n", this);

	SPIDER_TRACE(SP_PDU, "Send BRQ; pCall = %X\n", this);
	if (fGKIDontSend == FALSE)
		if (g_pReg->m_pSocket->Send((char *)Asn1Buf.value, Asn1Buf.length) == SOCKET_ERROR)
			return (GKI_WINSOCK2_ERROR(SOCKET_ERROR));

	// Free the encoder memory
	g_pCoder->Free(Asn1Buf);

	return (GKI_OK);
}

HRESULT 
CCall::DisengageRequest(void)
{
	// ABSTRACT:  This procedure will create a disengageRequest structure
	//            call the encoder and send the PDU.  If it is successful, it
	//            will return 0, else it will return an error code.
	// AUTHOR:    Colin Hulme

	ASN1_BUF		Asn1Buf;
	DWORD			dwErrorCode;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CCall::DisengageRequest()\n", 0);
	ASSERT(g_pCoder);
	if (g_pCoder == NULL)
		return (GKI_NOT_INITIALIZED);	
		
	// Allocate a RasMessage structure and initialized to 0
	m_usRetryCount = 0;
	m_uRetryCountdown = m_uRetryResetCount;
	
	m_pRasMessage = new RasMessage;
	SPIDER_TRACE(SP_NEWDEL, "new m_pRasMessage = %X\n", m_pRasMessage);
	if (m_pRasMessage == 0)
		return (GKI_NO_MEMORY);
	memset(m_pRasMessage, 0, sizeof(RasMessage));

	// Setup structure fields for DisengageRequest
	m_pRasMessage->choice = disengageRequest_chosen;
	m_pRasMessage->u.disengageRequest.bit_mask = 0;
	
	m_pRasMessage->u.disengageRequest.requestSeqNum = g_pReg->GetNextSeqNum();
	m_pRasMessage->u.disengageRequest.endpointIdentifier = g_pReg->GetEndpointIdentifier();
	m_pRasMessage->u.disengageRequest.conferenceID = m_conferenceID;
	m_pRasMessage->u.disengageRequest.callReferenceValue = m_callReferenceValue;
	m_pRasMessage->u.disengageRequest.disengageReason.choice = normalDrop_chosen;
	memcpy(&m_pRasMessage->u.disengageRequest.callIdentifier.guid.value,
		&m_CallIdentifier, sizeof(GUID));
	m_pRasMessage->u.disengageRequest.callIdentifier.guid.length = sizeof(GUID);
	m_pRasMessage->u.disengageRequest.bit_mask 
		|= DisengageRequest_callIdentifier_present;

#ifdef _DEBUG
	if (dwGKIDLLFlags & SP_DUMPMEM)
		DumpMem(m_pRasMessage, sizeof(RasMessage));
#endif

	// Encode the PDU & send it
	dwErrorCode = g_pCoder->Encode(m_pRasMessage, &Asn1Buf);
	if (dwErrorCode)
		return (GKI_ENCODER_ERROR);

	// Create a backup copy of the encoded PDU if using debug echo support
	if (fGKIEcho)
	{
		pEchoBuff = new char[Asn1Buf.length];
		SPIDER_TRACE(SP_NEWDEL, "new pEchoBuff = %X\n", pEchoBuff);
		if (pEchoBuff == 0)
			return (GKI_NO_MEMORY);
		memcpy(pEchoBuff, (char *)Asn1Buf.value, Asn1Buf.length);
		nEchoLen = Asn1Buf.length;
	}

	m_State = GK_DISENG_PENDING;
	SPIDER_TRACE(SP_STATE, "m_State = GK_DISENG_PENDING (%X)\n", this);

	SPIDER_TRACE(SP_PDU, "Send DRQ; pCall = %X\n", this);
	if (fGKIDontSend == FALSE)
		if (g_pReg->m_pSocket->Send((char *)Asn1Buf.value, Asn1Buf.length) == SOCKET_ERROR)
			return (GKI_WINSOCK2_ERROR(SOCKET_ERROR));

	// Free the encoder memory
	g_pCoder->Free(Asn1Buf);

	return (GKI_OK);
}

HRESULT 
CCall::AdmissionConfirm(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called if an admissionConfirm is 
	//            received.  We must ensure that this matches an outstanding 
	//			  admissionRequest.
	//            It will delete the memory used for the admissionRequest
	//            change the state and notify the user by posting a message.
	//            Additional information contained in the admissionConfirm
	//            is stored in the CCall class.
	// AUTHOR:    Colin Hulme

#ifdef _DEBUG
	unsigned int	nIdx;
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CCall::AdmissionConfirm(%X)\n", pRasMessage);
	ASSERT(g_pCoder && g_pGatekeeper);
	if ((g_pCoder == NULL) && (g_pGatekeeper == NULL))
		return (GKI_NOT_INITIALIZED);	
		
	// Verify we are in the correct state, have an outstanding admissionRequest
	// and the sequence numbers match
	if ((m_State != GK_ADM_PENDING) || 
			(pRasMessage->u.admissionConfirm.requestSeqNum != 
			m_pRasMessage->u.admissionRequest.requestSeqNum))

		return (g_pReg->UnknownMessage(pRasMessage));

	// Delete allocated RasMessage storage
	SPIDER_TRACE(SP_NEWDEL, "del m_pRasMessage = %X\n", m_pRasMessage);
	delete m_pRasMessage;
	m_pRasMessage = 0;

	// Update member variables
	m_State = GK_CALL;
	SPIDER_TRACE(SP_STATE, "m_State = GK_CALL (%X)\n", this);

	if (pRasMessage->u.admissionConfirm.bit_mask & irrFrequency_present)
	{
		m_CFirrFrequency = pRasMessage->u.admissionConfirm.irrFrequency;
		m_usTimeTilStatus = 
				(unsigned short)(((DWORD)m_CFirrFrequency * 1000) / GKR_RETRY_TICK_MS);
		SPIDER_DEBUG(m_usTimeTilStatus);
	}
	else
		m_usTimeTilStatus = 0;		// Don't auto-send status datagrams

	m_CFbandWidth = pRasMessage->u.admissionConfirm.bandWidth;

	m_CallReturnInfo.hCall = this;
	m_CallReturnInfo.callModel = pRasMessage->u.admissionConfirm.callModel;
	m_CallReturnInfo.destCallSignalAddress = pRasMessage->u.admissionConfirm.destCallSignalAddress;
	m_CallReturnInfo.bandWidth = m_CFbandWidth;
	m_CallReturnInfo.wError = 0;

#ifdef _DEBUG
	SPIDER_TRACE(SP_GKI, "PostMessage(hWnd, wBaseMessage + GKI_ADM_CONFIRM, 0, %X)\n", &m_CallReturnInfo);
	wsprintf(szGKDebug, "\thCall=%X\n", m_CallReturnInfo.hCall);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tcallModel=%X\n", m_CallReturnInfo.callModel);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tbandWidth=%X\n", m_CallReturnInfo.bandWidth);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tcallReferenceValue=%X\n", m_CallReturnInfo.callReferenceValue);
	OutputDebugString(szGKDebug);
	OutputDebugString("\tconferenceID=");
	for (nIdx = 0; nIdx < m_CallReturnInfo.conferenceID.length; nIdx++)
	{
		wsprintf(szGKDebug, "%02X", m_CallReturnInfo.conferenceID.value[nIdx]);
		OutputDebugString(szGKDebug);
	}
	wsprintf(szGKDebug, "\n\twError=%X\n", m_CallReturnInfo.wError);
	OutputDebugString(szGKDebug);
#endif
	PostMessage(g_pReg->GetHWnd(), 
			g_pReg->GetBaseMessage() + GKI_ADM_CONFIRM, 
			0, (LPARAM)&m_CallReturnInfo);

	return (GKI_OK);
}

HRESULT 
CCall::AdmissionReject(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called if an admissionReject is 
	//            received.  We must ensure that this matches an outstanding 
	//			  admissionRequest.
	//            It will delete the memory used for the admissionRequest
	//            change the state and notify the user by posting a message
	//            If this function returns GKI_DELETE_CALL, the calling function
	//            will delete the CCall object.
	// AUTHOR:    Colin Hulme

#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CCall::AdmissionReject(%X)\n", pRasMessage);

	// Verify we are in the correct state, have an outstanding admissionRequest
	// and the sequence numbers match
	if ((m_State != GK_ADM_PENDING) || 
			(pRasMessage->u.admissionReject.requestSeqNum != 
			m_pRasMessage->u.admissionRequest.requestSeqNum))

		return (g_pReg->UnknownMessage(pRasMessage));

	// We deliberately don't free the RasMessage memory.  Let the call destructor
	// do it - this provides protection from other requests for this hCall.

	m_State = GK_DISENGAGED;
	SPIDER_TRACE(SP_STATE, "m_State = GK_DISENGAGED (%X)\n", this);

	SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ADM_REJECT, %X, 0)\n", 
									pRasMessage->u.admissionReject.rejectReason.choice);
	PostMessage(g_pReg->GetHWnd(), 
				g_pReg->GetBaseMessage() + GKI_ADM_REJECT, 
				(WORD)pRasMessage->u.admissionReject.rejectReason.choice, 0L);

	return (GKI_DELETE_CALL);
}

HRESULT 
CCall::BandwidthConfirm(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called if a bandwidthConfirm is 
	//            received.  We must ensure that this matches an outstanding 
	//			  bandwidthRequest.
	//            It will delete the memory used for the bandwidthRequest,
	//            change the state and notify the user by posting a message.
	// AUTHOR:    Colin Hulme

#ifdef _DEBUG
	unsigned int	nIdx;
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CCall::BandwidthConfirm(%X)\n", pRasMessage);

	// Verify we are in the correct state, have an outstanding admissionRequest
	// and the sequence numbers match
	if ((m_State != GK_BW_PENDING) || 
			(pRasMessage->u.bandwidthConfirm.requestSeqNum != 
			m_pRasMessage->u.bandwidthRequest.requestSeqNum))

		return (g_pReg->UnknownMessage(pRasMessage));

	// Delete allocated RasMessage storage
	SPIDER_TRACE(SP_NEWDEL, "del m_pRasMessage = %X\n", m_pRasMessage);
	delete m_pRasMessage;
	m_pRasMessage = 0;

	// Update member variables
	m_State = GK_CALL;
	SPIDER_TRACE(SP_STATE, "m_State = GK_CALL (%X)\n", this);
	m_CFbandWidth = pRasMessage->u.bandwidthConfirm.bandWidth;
	m_CallReturnInfo.bandWidth = m_CFbandWidth;

	// Notify user application
#ifdef _DEBUG
	SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_BW_CONFIRM, 0, %X)\n", &m_CallReturnInfo);
	wsprintf(szGKDebug, "\thCall=%X\n", m_CallReturnInfo.hCall);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tcallModel=%X\n", m_CallReturnInfo.callModel);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tbandWidth=%X\n", m_CallReturnInfo.bandWidth);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tcallReferenceValue=%X\n", m_CallReturnInfo.callReferenceValue);
	OutputDebugString(szGKDebug);
	OutputDebugString("\tconferenceID=");
	for (nIdx = 0; nIdx < m_CallReturnInfo.conferenceID.length; nIdx++)
	{
		wsprintf(szGKDebug, "%02X", m_CallReturnInfo.conferenceID.value[nIdx]);
		OutputDebugString(szGKDebug);
	}
	wsprintf(szGKDebug, "\n\twError=%X\n", m_CallReturnInfo.wError);
	OutputDebugString(szGKDebug);
#endif
	PostMessage(g_pReg->GetHWnd(), 
			g_pReg->GetBaseMessage() + GKI_BW_CONFIRM, 0, (LPARAM)&m_CallReturnInfo);

	return (GKI_OK);
}

HRESULT 
CCall::BandwidthReject(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called if a bandwidthReject is 
	//            received.  We must ensure that this matches an outstanding 
	//			  bandwidthRequest.
	//            It will delete the memory used for the bandwidthRequest
	//            change the state and notify the user by posting a message
	// AUTHOR:    Colin Hulme

#ifdef _DEBUG
	unsigned int	nIdx;
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CCall::BandwidthReject(%X)\n", pRasMessage);

	// Verify we are in the correct state, have an outstanding admissionRequest
	// and the sequence numbers match
	if ((m_State != GK_BW_PENDING) || 
			(pRasMessage->u.bandwidthReject.requestSeqNum != 
			m_pRasMessage->u.bandwidthRequest.requestSeqNum))

		return (g_pReg->UnknownMessage(pRasMessage));

	// Delete allocate RasMessage storage
	SPIDER_TRACE(SP_NEWDEL, "del m_pRasMessage = %X\n", m_pRasMessage);
	delete m_pRasMessage;
	m_pRasMessage = 0;

	// Update member variables
	m_State = GK_CALL;
	SPIDER_TRACE(SP_STATE, "m_State = GK_CALL (%X)\n", this);
	m_CFbandWidth = pRasMessage->u.bandwidthReject.allowedBandWidth;
	m_CallReturnInfo.bandWidth = m_CFbandWidth;

	// Notify user application
#ifdef _DEBUG
	SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_BW_REJECT, %X, &m_CallReturnInfo)\n", 
			pRasMessage->u.bandwidthReject.rejectReason.choice);
	wsprintf(szGKDebug, "\thCall=%X\n", m_CallReturnInfo.hCall);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tcallModel=%X\n", m_CallReturnInfo.callModel);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tbandWidth=%X\n", m_CallReturnInfo.bandWidth);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tcallReferenceValue=%X\n", m_CallReturnInfo.callReferenceValue);
	OutputDebugString(szGKDebug);
	OutputDebugString("\tconferenceID=");
	for (nIdx = 0; nIdx < m_CallReturnInfo.conferenceID.length; nIdx++)
	{
		wsprintf(szGKDebug, "%02X", m_CallReturnInfo.conferenceID.value[nIdx]);
		OutputDebugString(szGKDebug);
	}
	wsprintf(szGKDebug, "\n\twError=%X\n", m_CallReturnInfo.wError);
	OutputDebugString(szGKDebug);
#endif
	PostMessage(g_pReg->GetHWnd(), 
			g_pReg->GetBaseMessage() + GKI_BW_REJECT, 
			(WORD)pRasMessage->u.bandwidthReject.rejectReason.choice, 
			(LPARAM)&m_CallReturnInfo);

	return (GKI_OK);
}

HRESULT 
CCall::SendBandwidthConfirm(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called when a bandwidthRequest is
	//            received from the gatekeeper.  It will create the 
	//            bandwidthConfirm structure, encode it and send
	//            it on the net.  It posts a message to the user
	//            notifying them.
	// AUTHOR:    Colin Hulme

	ASN1_BUF		Asn1Buf;
	DWORD			dwErrorCode;
	RasMessage		*pRespRasMessage;
#ifdef _DEBUG
	unsigned int	nIdx;
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CCall::SendBandwidthConfirm(%X)\n", pRasMessage);

	// Verify we are in the correct state
	if (m_State != GK_CALL)
		return (g_pReg->UnknownMessage(pRasMessage));

	// Update member variables
	m_CFbandWidth = pRasMessage->u.bandwidthRequest.bandWidth;
	m_CallReturnInfo.bandWidth = m_CFbandWidth;

	// Allocate a RasMessage structure and initialized to 0
	pRespRasMessage = new RasMessage;
	SPIDER_TRACE(SP_NEWDEL, "new pRespRasMessage = %X\n", pRespRasMessage);
	if (pRespRasMessage == 0)
		return (GKI_NO_MEMORY);
	memset(pRespRasMessage, 0, sizeof(RasMessage));

	// Setup structure fields for BandwidthConfirm
	pRespRasMessage->choice = bandwidthConfirm_chosen;
	pRespRasMessage->u.bandwidthConfirm.requestSeqNum = 
			pRasMessage->u.bandwidthRequest.requestSeqNum;
	pRespRasMessage->u.bandwidthConfirm.bandWidth = 
			pRasMessage->u.bandwidthRequest.bandWidth;

#ifdef _DEBUG
	if (dwGKIDLLFlags & SP_DUMPMEM)
		DumpMem(pRespRasMessage, sizeof(RasMessage));
#endif

	// Encode the PDU & send it
	dwErrorCode = g_pCoder->Encode(pRespRasMessage, &Asn1Buf);
	if (dwErrorCode)
		return (GKI_ENCODER_ERROR);

	SPIDER_TRACE(SP_PDU, "Send BCF; pCall = %X\n", this);
	if (fGKIDontSend == FALSE)
		if (g_pReg->m_pSocket->Send((char *)Asn1Buf.value, Asn1Buf.length) == SOCKET_ERROR)
			return (GKI_WINSOCK2_ERROR(SOCKET_ERROR));

	// Free the encoder memory
	g_pCoder->Free(Asn1Buf);

	// Delete allocated RasMessage storage
	SPIDER_TRACE(SP_NEWDEL, "del pRespRasMessage = %X\n", pRespRasMessage);
	delete pRespRasMessage;

	// Notify user of received bandwidth request
#ifdef _DEBUG
	SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_BW_CONFIRM, 0, %X)\n", 
			&m_CallReturnInfo);
	wsprintf(szGKDebug, "\thCall=%X\n", m_CallReturnInfo.hCall);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tcallModel=%X\n", m_CallReturnInfo.callModel);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tbandWidth=%X\n", m_CallReturnInfo.bandWidth);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tcallReferenceValue=%X\n", m_CallReturnInfo.callReferenceValue);
	OutputDebugString(szGKDebug);
	OutputDebugString("\tconferenceID=");
	for (nIdx = 0; nIdx < m_CallReturnInfo.conferenceID.length; nIdx++)
	{
		wsprintf(szGKDebug, "%02X", m_CallReturnInfo.conferenceID.value[nIdx]);
		OutputDebugString(szGKDebug);
	}
	wsprintf(szGKDebug, "\n\twError=%X\n", m_CallReturnInfo.wError);
	OutputDebugString(szGKDebug);
#endif
	PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_BW_CONFIRM, 
			0, (LPARAM)&m_CallReturnInfo);

	return (GKI_OK);
}

HRESULT
CCall::DisengageConfirm(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called if a disengageConfirm is 
	//            received.  We must ensure that this matches an outstanding 
	//			  disengageRequest.
	//            It will delete the memory used for the disengageRequest,
	//            change the state and notify the user by posting a message.
	//            If this function returns GKI_DELETE_CALL, the calling function
	//            will delete the CCall object.
	// AUTHOR:    Colin Hulme

#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CCall::DisengageConfirm(%X)\n", pRasMessage);

	// Verify we are in the correct state, have an outstanding disengageRequest
	// and the sequence numbers match
	if ((m_State != GK_DISENG_PENDING) || 
			(pRasMessage->u.disengageConfirm.requestSeqNum != 
			m_pRasMessage->u.disengageRequest.requestSeqNum))

		return (g_pReg->UnknownMessage(pRasMessage));

	// We deliberately don't free the RasMessage memory.  Let the call destructor
	// do it - this provides protection from other requests for this hCall.

	// Update member variables
	m_State = GK_DISENGAGED;
	SPIDER_TRACE(SP_STATE, "m_State = GK_DISENGAGED (%X)\n", this);

	// Notify user application
	SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_DISENG_CONFIRM, 0, %X)\n", 
			this);
	PostMessage(g_pReg->GetHWnd(), 
			g_pReg->GetBaseMessage() + GKI_DISENG_CONFIRM, 0, (LPARAM)this);

	return (GKI_DELETE_CALL);
}

HRESULT
CCall::DisengageReject(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called if a disengageReject is 
	//            received.  We must ensure that this matches an outstanding 
	//			  disengageRequest.
	//            It will delete the memory used for the disengageRequest
	//            change the state and notify the user by posting a message
	//            If this function returns GKI_DELETE_CALL, the calling function
	//            will delete the CCall object.
	// AUTHOR:    Colin Hulme

#ifdef _DEBUG
	char			szGKDebug[80];
#endif
	HRESULT			hResult = GKI_OK;

	SPIDER_TRACE(SP_FUNC, "CCall::DisengageReject(%X)\n", pRasMessage);

	// Verify we are in the correct state, have an outstanding disengageRequest
	// and the sequence numbers match
	if ((m_State != GK_DISENG_PENDING) || 
			(pRasMessage->u.disengageReject.requestSeqNum != 
			m_pRasMessage->u.disengageRequest.requestSeqNum))

		return (g_pReg->UnknownMessage(pRasMessage));

	// Update member variables
	switch (pRasMessage->u.disengageReject.rejectReason.choice)
	{
	case requestToDropOther_chosen:		// return to GK_CALL state
		m_State = GK_CALL;
		SPIDER_TRACE(SP_STATE, "m_State = GK_CALL (%X)\n", this);

		// Delete allocate RasMessage storage
		SPIDER_TRACE(SP_NEWDEL, "del m_pRasMessage = %X\n", m_pRasMessage);
		delete m_pRasMessage;
		m_pRasMessage = 0;

		break;
	case DsnggRjctRsn_ntRgstrd_chosen:
	default:
		m_State = GK_DISENGAGED;
		SPIDER_TRACE(SP_STATE, "m_State = GK_DISENGAGED (%X)\n", this);
		hResult = GKI_DELETE_CALL;

		// We deliberately don't free the RasMessage memory.  Let the call destructor
		// do it - this provides protection from other requests for this hCall.
		break;
	}

	// Notify user application
	SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_DISENG_REJECT, %X, hCall)\n", 
									pRasMessage->u.disengageReject.rejectReason.choice);
	PostMessage(g_pReg->GetHWnd(), 
			g_pReg->GetBaseMessage() + GKI_DISENG_REJECT, 
			(WORD)pRasMessage->u.disengageReject.rejectReason.choice, 
			(LPARAM)this);

	return (hResult);
}

HRESULT 
CCall::SendDisengageConfirm(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called when a disengageRequest is
	//            received from the gatekeeper.  It will create the 
	//            disengageConfirm structure, encode it and send
	//            it on the net.  It posts a message to the user
	//            notifying them.
	// AUTHOR:    Colin Hulme

	ASN1_BUF		Asn1Buf;
	DWORD			dwErrorCode;
	RasMessage		*pRespRasMessage;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CCall::SendDisengageConfirm(%X)\n", pRasMessage);
	ASSERT(g_pCoder);
	if (g_pCoder == NULL)
		return (GKI_NOT_INITIALIZED);	
		
	// Verify we are in the correct state
	if (m_State != GK_CALL)
		return (g_pReg->UnknownMessage(pRasMessage));

	// Allocate a RasMessage structure and initialized to 0
	pRespRasMessage = new RasMessage;
	SPIDER_TRACE(SP_NEWDEL, "new pRespRasMessage = %X\n", pRespRasMessage);
	if (pRespRasMessage == 0)
		return (GKI_NO_MEMORY);
	memset(pRespRasMessage, 0, sizeof(RasMessage));

	// Setup structure fields for DisengageConfirm
	pRespRasMessage->choice = disengageConfirm_chosen;
	pRespRasMessage->u.disengageConfirm.requestSeqNum = 
			pRasMessage->u.disengageRequest.requestSeqNum;

#ifdef _DEBUG
	if (dwGKIDLLFlags & SP_DUMPMEM)
		DumpMem(pRespRasMessage, sizeof(RasMessage));
#endif

	// Encode the PDU & send it
	dwErrorCode = g_pCoder->Encode(pRespRasMessage, &Asn1Buf);
	if (dwErrorCode)
		return (GKI_ENCODER_ERROR);

	m_State = GK_DISENGAGED;
	SPIDER_TRACE(SP_STATE, "m_State = GK_DISENGAGED (%X)\n", this);

	SPIDER_TRACE(SP_PDU, "Send DCF; pCall = %X\n", this);
	if (fGKIDontSend == FALSE)
		if (g_pReg->m_pSocket->Send((char *)Asn1Buf.value, Asn1Buf.length) == SOCKET_ERROR)
			return (GKI_WINSOCK2_ERROR(SOCKET_ERROR));

	// Free the encoder memory
	g_pCoder->Free(Asn1Buf);

	// Delete allocated RasMessage storage
	SPIDER_TRACE(SP_NEWDEL, "del pRespRasMessage = %X\n", pRespRasMessage);
	delete pRespRasMessage;

	// Notify user of received disengage request
	SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_DISENG_CONFIRM, 0, %X)\n", 
			this);
	PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_DISENG_CONFIRM, 
			0, (LPARAM)this);

	return (GKI_DELETE_CALL);
}

HRESULT
CCall::Retry(void)
{
	// ABSTRACT:  This function is called by the CRegistration Retry function
	//            at the configured time interval.  It will check if there
	//            are any outstanding PDUs for the Call object
	//            If so, they will be retransmitted.  If the maximum number of
	//            retries has expired, the memory will be cleaned up.
	//            This function will return 0 to the background thread unless
	//            it wants the thread to terminate.  This function will
	//            also send the IRR status datagram for the conference
	//            if the time period has expired.
	// AUTHOR:    Colin Hulme

	ASN1_BUF		Asn1Buf;
	DWORD			dwErrorCode;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif
	HRESULT			hResult = GKI_OK;

//	SPIDER_TRACE(SP_FUNC, "CCall::Retry()\n", 0);
	ASSERT(g_pCoder && g_pGatekeeper);
	if ((g_pCoder == NULL) && (g_pGatekeeper == NULL))
		return (GKI_NOT_INITIALIZED);	
		
	// Check to see if status datagram is required
	if (m_usTimeTilStatus)	// No auto-status if 0
	{
		if (--m_usTimeTilStatus == 0)
		{
			// Reset timer
			m_usTimeTilStatus = 
					(unsigned short)(((DWORD)m_CFirrFrequency * 1000) / GKR_RETRY_TICK_MS);

			hResult = SendInfoRequestResponse(0, 0, TRUE);	// send unsolicited status datagram
			if (hResult != GKI_OK)
				return (hResult);
		}
	}

	// Check to see if PDU retransmission is required
	if (m_pRasMessage && (--m_uRetryCountdown == 0))
	{
		// going to retry, reset countdown
		m_uRetryCountdown = m_uRetryResetCount;

		if (m_usRetryCount <= m_uMaxRetryCount)
		{
			// Encode the PDU & resend it
			dwErrorCode = g_pCoder->Encode(m_pRasMessage, &Asn1Buf);
			if (dwErrorCode)
				return (GKI_ENCODER_ERROR);

			SPIDER_TRACE(SP_PDU, "RESend PDU; pCall = %X\n", this);
			if (fGKIDontSend == FALSE)
				if (g_pReg->m_pSocket->Send((char *)Asn1Buf.value, Asn1Buf.length) == SOCKET_ERROR)
					return (GKI_WINSOCK2_ERROR(SOCKET_ERROR));

			// Free the encoder memory
			g_pCoder->Free(Asn1Buf);
			m_usRetryCount++;
		}
		else	// Retries expired - clean up
		{
			switch (m_pRasMessage->choice)
			{
			case admissionRequest_chosen:
				m_State = GK_DISENGAGED;
				SPIDER_TRACE(SP_STATE, "m_State = GK_DISENGAGED (%X)\n", this);
				hResult = GKI_DELETE_CALL;
				break;
			case bandwidthRequest_chosen:
				m_State = GK_CALL;
				SPIDER_TRACE(SP_STATE, "m_State = GK_CALL (%X)\n", this);
				break;
			case disengageRequest_chosen:
				m_State = GK_DISENGAGED;
				SPIDER_TRACE(SP_STATE, "m_State = GK_DISENGAGED (%X)\n", this);
				hResult = GKI_DELETE_CALL;
				break;
			}
			SPIDER_TRACE(SP_NEWDEL, "del m_pRasMessage = %X\n", m_pRasMessage);
			delete m_pRasMessage;
			m_pRasMessage = 0;

			// Notify user that gatekeeper didn't respond
		#ifdef RETRY_REREG_FOREVER
			SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, GKI_NO_RESPONSE)\n", 0);
			PostMessage(g_pReg->GetHWnd(), 
					g_pReg->GetBaseMessage() + GKI_ERROR, 
					0, GKI_NO_RESPONSE);
		#else
			// end the call as if ARJ occurred
			SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ADM_REJECT, ARJ_TIMEOUT, 0)\n", 0);
			PostMessage(g_pReg->GetHWnd(), 
					g_pReg->GetBaseMessage() + GKI_ADM_REJECT, 
					ARJ_TIMEOUT, 0L);
		#endif
		}
	}

	return (hResult);
}

HRESULT 
CCall::SendInfoRequestResponse(CallInfoStruct *pCallInfo, RasMessage *pRasMessage, BOOL fThisCallOnly)
{
	// ABSTRACT:  This function is called by the Retry thread if this call
	//            is due to report an unsolicited status to the gatekeeper.
	//            It is also called in response to a received IRQ.  In the
	//            case of an IRQ, each active call should chain call the 
	//            next active call.  This allows construction of a link
	//            list of conference information that is then passed to the
	//            CRegistration::SendInfoRequestResponse function for
	//            encapsulation into the IRR message.
	//
	//			  The fThisCallOnly flag determines whether or not to walk the
	//			  chain of calls in generating the response message.
	//
	//			  If fThisCallOnly == TRUE, the chain will not be walked, and
	//			  this routine will call the CRegistration::SendInfoRequestResponse().
	// AUTHOR:    Colin Hulme, Dan Dexter

	CallInfoStruct		CallInfo;
	CallInfoStruct		*pCI;
#ifdef _DEBUG
	char				szGKDebug[80];
#endif
	HRESULT				hResult = GKI_OK;

	SPIDER_TRACE(SP_FUNC, "CCall::SendInfoRequestResponse(%X)\n", pCallInfo);

	memset(&CallInfo, 0, sizeof(CallInfo));
	CallInfo.next = 0;
	CallInfo.value.bit_mask = 0;
	CallInfo.value.callReferenceValue = m_callReferenceValue;
	CallInfo.value.conferenceID = m_conferenceID;
	
	memcpy(&CallInfo.value.callIdentifier.guid.value,
		&m_CallIdentifier, sizeof(GUID));
	CallInfo.value.callIdentifier.guid.length = sizeof(GUID);
	CallInfo.value.bit_mask 
		|= InfoRequestResponse_perCallInfo_Seq_callIdentifier_present;

	CallInfo.value.bit_mask |= originator_present;
	
	CallInfo.value.callSignaling.bit_mask = recvAddress_present;
	CallInfo.value.callSignaling.recvAddress = m_LocalCallSignalAddress;

	if (m_answerCall)	// If I am the callee
	{
 		// look out! if there has not been an ACF, m_CallReturnInfo.destCallSignalAddress
		// is uninitialized.  m_CallReturnInfo.hCall is set only after ACF
		if(m_CallReturnInfo.hCall)
		{
			if (m_RemoteCallSignalAddress.choice)
			{
				CallInfo.value.callSignaling.sendAddress = m_RemoteCallSignalAddress;
				CallInfo.value.callSignaling.bit_mask |= sendAddress_present;
			}
			CallInfo.value.originator = FALSE;
			CallInfo.value.callModel = m_CallReturnInfo.callModel;
		}
		else	
		{
			// we are typically in this path because we got an IRQ after 
			// sending an ARQ. 
			CallInfo.value.callModel.choice = direct_chosen;
		}
	}
	else				// I am the caller
	{
		// look out! if there has not been an ACF, m_CallReturnInfo.destCallSignalAddress
		// is uninitialized.  m_CallReturnInfo.hCall is set only after ACF
		if(m_CallReturnInfo.hCall)
		{
			CallInfo.value.callSignaling.sendAddress = m_CallReturnInfo.destCallSignalAddress;
			CallInfo.value.callSignaling.bit_mask |= sendAddress_present;
			CallInfo.value.originator = TRUE;
			CallInfo.value.callModel = m_CallReturnInfo.callModel;
		}
		else	
		{
			// we are typically in this path because we got an IRQ after 
			// sending an ARQ. 
			CallInfo.value.callModel.choice = direct_chosen;
		}
	}
	CallInfo.value.callType = m_callType;
	CallInfo.value.bandWidth = m_CFbandWidth;


	if (pCallInfo)	// Add to chain of CallInfo structures
	{
		for (pCI = pCallInfo; pCI->next != 0; pCI = pCI->next)
			;
		pCI->next = &CallInfo;
	}
	else			// We're alone - just point to ours
		pCallInfo = &CallInfo;

	// If the IRR is not just for this call, then get the next call
	// and call it's SendInfoRequestResponse() function.  If there are no
	// more calls, or this IRR was only for this call, call
	// g_pReg->SendInfoRequestResponse()
	CCall *pNextCall = NULL;
	if (!fThisCallOnly)
	{
		pNextCall = g_pReg->GetNextCall(this);
	}

	if (pNextCall)
		hResult = pNextCall->SendInfoRequestResponse(pCallInfo, pRasMessage, fThisCallOnly);
	else
		hResult = g_pReg->SendInfoRequestResponse(pCallInfo, pRasMessage);

	return (hResult);
}


//
// MatchSeqNum()
//
// ABSTRACT:
//	This function checks to see if the outstanding RAS request(s) it has
//	match the sequence number passed in.
//
// RETURNS:
//	TRUE if sequence number matches, FALSE otherwise
//
// AUTHOR:	Dan Dexter
BOOL
CCall::MatchSeqNum(RequestSeqNum seqNum)
{
	BOOL bRet = FALSE;
	// If there is no RAS message, this sequence
	// number can't be ours...
	if (!m_pRasMessage)
		return(FALSE);

	// Look at the sequence number in the RAS message and see
	// if it matches.

	switch(m_pRasMessage->choice)
	{
		case gatekeeperRequest_chosen:
			if (m_pRasMessage->u.gatekeeperRequest.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case gatekeeperConfirm_chosen:
			if (m_pRasMessage->u.gatekeeperConfirm.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case gatekeeperReject_chosen:
			if (m_pRasMessage->u.gatekeeperReject.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case registrationRequest_chosen:
			if (m_pRasMessage->u.registrationRequest.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case registrationConfirm_chosen:
			if (m_pRasMessage->u.registrationConfirm.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case registrationReject_chosen:
			if (m_pRasMessage->u.registrationReject.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case unregistrationRequest_chosen:
			if (m_pRasMessage->u.unregistrationRequest.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case unregistrationConfirm_chosen:
			if (m_pRasMessage->u.unregistrationConfirm.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case unregistrationReject_chosen:
			if (m_pRasMessage->u.unregistrationReject.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case admissionRequest_chosen:
			if (m_pRasMessage->u.admissionRequest.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case admissionConfirm_chosen:
			if (m_pRasMessage->u.admissionConfirm.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case admissionReject_chosen:
			if (m_pRasMessage->u.admissionReject.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case bandwidthRequest_chosen:
			if (m_pRasMessage->u.bandwidthRequest.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case bandwidthConfirm_chosen:
			if (m_pRasMessage->u.bandwidthConfirm.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case bandwidthReject_chosen:
			if (m_pRasMessage->u.bandwidthReject.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case disengageRequest_chosen:
			if (m_pRasMessage->u.disengageRequest.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case disengageConfirm_chosen:
			if (m_pRasMessage->u.disengageConfirm.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case disengageReject_chosen:
			if (m_pRasMessage->u.disengageReject.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case locationRequest_chosen:
			if (m_pRasMessage->u.locationRequest.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case locationConfirm_chosen:
			if (m_pRasMessage->u.locationConfirm.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case locationReject_chosen:
			if (m_pRasMessage->u.locationReject.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case infoRequest_chosen:
			if (m_pRasMessage->u.infoRequest.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case infoRequestResponse_chosen:
			if (m_pRasMessage->u.infoRequestResponse.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case nonStandardMessage_chosen:
			if (m_pRasMessage->u.nonStandardMessage.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case unknownMessageResponse_chosen:
			if (m_pRasMessage->u.unknownMessageResponse.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case requestInProgress_chosen:
			if (m_pRasMessage->u.requestInProgress.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case resourcesAvailableIndicate_chosen:
			if (m_pRasMessage->u.resourcesAvailableIndicate.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case resourcesAvailableConfirm_chosen:
			if (m_pRasMessage->u.resourcesAvailableConfirm.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case infoRequestAck_chosen:
			if (m_pRasMessage->u.infoRequestAck.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case infoRequestNak_chosen:
			if (m_pRasMessage->u.infoRequestNak.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		default:
		break;
	}
	return bRet;
}

//
// MatchCRV()
//
// ABSTRACT:
//	This function checks to see if the CallReferenceValue associated
//	with this call object matches the CRV passed in.
//
// RETURNS:
//	TRUE if CRV number matches, FALSE otherwise
//
// AUTHOR:	Dan Dexter
BOOL
CCall::MatchCRV(CallReferenceValue crv)
{
	return(crv == m_callReferenceValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\dgkiprot.h ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\dgkiprot.h_v  $
*																		*
*	$Revision:   1.3  $
*	$Date:   17 Jan 1997 15:54:14  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\dgkiprot.h_v  $
 * 
 *    Rev 1.3   17 Jan 1997 15:54:14   CHULME
 * Put debug function prototype on conditionals to avoid release warnings
 * 
 *    Rev 1.2   10 Jan 1997 16:14:10   CHULME
 * Removed MFC dependency
 * 
 *    Rev 1.1   22 Nov 1996 15:25:06   CHULME
 * Added VCS log to the header
*************************************************************************/

// DGKIPROT.H : header file
//

#ifndef DGKIPROTO_H
#define DGKIPROTO_H

#ifdef _DEBUG
void SpiderWSErrDecode(int nErr);
void DumpMem(void *pv, int nLen);
#endif

void PostReceive(void *);
void Retry(void *);
#ifdef BROADCAST_DISCOVERY
void GKDiscovery(void *);
#endif

#endif	// DGKIPROTO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\dgkilit.h ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\dgkilit.h_v  $
*																		*
*	$Revision:   1.3  $
*	$Date:   08 Feb 1997 12:05:00  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\dgkilit.h_v  $
 * 
 *    Rev 1.3   08 Feb 1997 12:05:00   CHULME
 * Added semaphore related literals for cleanly terminating retry thread
 * 
 *    Rev 1.2   10 Jan 1997 16:14:06   CHULME
 * Removed MFC dependency
 * 
 *    Rev 1.1   22 Nov 1996 15:23:58   CHULME
 * Added VCS log to the header
*************************************************************************/

// dgkilit.h : header file
//

#ifndef DGKILIT_H
#define DGKILIT_H

#define WSVER_MAJOR				1
#define WSVER_MINOR				1

// registration retry constants
#define GKR_RETRY_TICK_MS   1000
#define GKR_RETRY_INTERVAL_SECONDS  5
#define GKR_RETRY_MAX               3

// call retry constants
#define GKCALL_RETRY_INTERVAL_SECONDS  5
#define GKCALL_RETRY_MAX               3

#define DEFAULT_RETRY_MS		5000
#define DEFAULT_MAX_RETRIES		3
#define DEFAULT_STATUS_PERIOD	(1500 * 1000)/GKR_RETRY_TICK_MS

//#define  GKREG_TIMER_ID 100

#define IPADDR_SZ				15
#define IPXADDR_SZ				21

#define GKIP_DISC_MCADDR		"224.0.1.41"
#define GKIP_DISC_PORT			1718
#define GKIP_RAS_PORT			1719

//TBD - Replace with real port numbers
#define GKIPX_DISC_PORT			12
#define GKIPX_RAS_PORT			34

// Thread related defs (in msecs)
#define TIMEOUT_SEMAPHORE			1000
#define TIMEOUT_THREAD				10000 

typedef InfoRequestResponse_perCallInfo_Element CallInfoStruct;

#endif	// DGKILIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\discover.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\discover.cpv  $
*																		*
*	$Revision:   1.10  $
*	$Date:   13 Feb 1997 16:20:44  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\discover.cpv  $
// 
//    Rev 1.10   13 Feb 1997 16:20:44   CHULME
// Moved CGatekeeper::Unlock to end of Discover thread for synchronization
// 
//    Rev 1.9   12 Feb 1997 01:11:00   CHULME
// Redid thread synchronization to use Gatekeeper.Lock
// 
//    Rev 1.8   08 Feb 1997 12:12:06   CHULME
// Changed from using unsigned long to HANDLE for thread handles
// 
//    Rev 1.7   24 Jan 1997 18:36:06   CHULME
// Reverted to rev 1.5
// 
//    Rev 1.5   22 Jan 1997 16:53:06   CHULME
// Reset the gatekeeper reject flag before issuing discovery request
// 
//    Rev 1.4   17 Jan 1997 09:01:54   CHULME
// Changed reg.h to gkreg.h to avoid name conflict with inc directory
// 
//    Rev 1.3   10 Jan 1997 16:14:14   CHULME
// Removed MFC dependency
// 
//    Rev 1.2   22 Nov 1996 15:20:46   CHULME
// Added VCS log to the header
*************************************************************************/

// discovery.cpp : Provides the discovery thread implementation
//
#include "precomp.h"

#include <process.h>
#include "GKICOM.H"
#include "dspider.h"
#include "dgkilit.h"
#include "DGKIPROT.H"
#include "gksocket.h"
#include "GKREG.H"
#include "GATEKPR.H"
#include "h225asn.h"
#include "coder.hpp"
#include "dgkiext.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifdef BROADCAST_DISCOVERY
void 
GKDiscovery(void *pv)
{
	// ABSTRACT:  This function is invoked in a separate thread to
	//            issue a gatekeeper discovery PDU (GRQ) and listen for a
	//            responding GCF and/or GRJ.  If successful, it will then
	//            issue a registration request (RRQ).
	// AUTHOR:    Colin Hulme

	char			szBuffer[512];
	int				nRet;
	ASN1_BUF		Asn1Buf;
	DWORD			dwErrorCode;
	RasMessage		*pRasMessage;
	char			*pDestAddr;
	HANDLE			hThread;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif
	HRESULT			hResult = GKI_OK;

	SPIDER_TRACE(SP_FUNC, "GKDiscovery()\n", 0);
	ASSERT(g_pCoder && g_pGatekeeper);
	if ((g_pCoder == NULL) && (g_pGatekeeper == NULL))
		return;	
		
	g_pGatekeeper->SetRejectFlag(FALSE);	// Reset the reject flag

	// Send Async informational notification to client that we are doing a discovery
	SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_REG_DISCOVERY, 0, 0)\n", 0);
	PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_REG_DISCOVERY, 0, 0);

	// Send a broadcast on the gatekeeper discovery port
	if ((hResult = g_pReg->GatekeeperRequest()) != GKI_OK)
	{
		SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, %X)\n", hResult);
		PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_ERROR, 0, hResult);
	}

	while (hResult == GKI_OK)
	{
		nRet = g_pReg->m_pSocket->ReceiveFrom(szBuffer, 512);

		g_pGatekeeper->Lock();
		if (g_pReg == 0)
		{
			SPIDER_TRACE(SP_THREAD, "Discovery thread exiting\n", 0);
			g_pGatekeeper->Unlock();
			return;
		}

		if (nRet != SOCKET_ERROR)
		{
			if (fGKIEcho && (pEchoBuff != 0))
			{
				if (nEchoLen != nRet)
				{
					SPIDER_TRACE(SP_DEBUG, "*** Received buffer len != Sent buffer len ***\n", 0);
				}
				if (memcmp(szBuffer, pEchoBuff, nEchoLen) == 0)
				{
					SPIDER_TRACE(SP_DEBUG, "Received buffer = Sent buffer\n", 0);
				}
				else
				{
					SPIDER_TRACE(SP_DEBUG, "*** Received buffer != Sent buffer ***\n", 0);
				}
				SPIDER_TRACE(SP_NEWDEL, "del pEchoBuff = %X\n", pEchoBuff);
				delete pEchoBuff;
				pEchoBuff = 0;
				hResult = GKI_EXIT_THREAD;
			}
			else	// Check incoming PDU for GCF or GRJ
			{
				// Setup Asn1Buf for decoder and decode PDU
				Asn1Buf.length = nRet;	// number of bytes received
				Asn1Buf.value = (unsigned char *)szBuffer;
				dwErrorCode = g_pCoder->Decode(&Asn1Buf, &pRasMessage);
				if (dwErrorCode)
				{
					SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, GKI_DECODER_ERROR)\n", 0);
					PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_ERROR, 0, GKI_DECODER_ERROR);
				}

				else
				{
#ifdef _DEBUG
					if (dwGKIDLLFlags & SP_DUMPMEM)
						DumpMem(pRasMessage, sizeof(RasMessage));
#endif
					switch (pRasMessage->choice)
					{
					case gatekeeperConfirm_chosen:
						SPIDER_TRACE(SP_PDU, "Rcv GCF; g_pReg = %X\n", g_pReg);
						hResult = g_pReg->GatekeeperConfirm(pRasMessage);
						if (hResult != GKI_OK)
						{
							SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, %X)\n", hResult);
							PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_ERROR, 0, 
																				hResult);
						}
//////////////////////////////////////////////////////////////////////////////////////////
						else
						{
							pDestAddr = (g_pReg->GetRegistrationTransport() == ipAddress_chosen) ? 
									g_pGatekeeper->GetIPAddress() : g_pGatekeeper->GetIPXAddress();

							// Connect to destination gatekeeper and retrieve RAS port
							if (g_pReg->m_pSocket->Connect(pDestAddr))
							{
								hResult = GKI_WINSOCK2_ERROR(g_pReg->m_pSocket->GetLastError());
								SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, %X)\n", hResult);
								PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_ERROR, 0, hResult);
							}

							// Create RegistrationRequest structure - Encode and send PDU
							if ((hResult = g_pReg->RegistrationRequest(TRUE)) != GKI_OK)
							{
								SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, %X)\n", hResult);
								PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_ERROR, 0, hResult);
							}

							// Post a receive on this socket
							hThread = (HANDLE)_beginthread(PostReceive, 0, 0);
							SPIDER_TRACE(SP_THREAD, "_beginthread(PostReceive, 0, 0); <%X>\n", hThread);
							if (hThread == (HANDLE)-1)
							{
								SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, GKI_NO_THREAD)\n", 0);
								PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_ERROR, 0, GKI_NO_THREAD);
							}
							g_pReg->SetRcvThread(hThread);

							if (hResult == GKI_OK)
								hResult = GKI_GCF_RCV;
						}

						break;
					case gatekeeperReject_chosen:
						SPIDER_TRACE(SP_PDU, "Rcv GRJ; g_pReg = %X\n", g_pReg);
						hResult = g_pReg->GatekeeperReject(pRasMessage);
						if (hResult != GKI_OK)
						{
							SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, %X)\n", hResult);
							PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_ERROR, 0, 
													hResult);
						}
						break;
					default:
						SPIDER_TRACE(SP_PDU, "Rcv %X\n", pRasMessage->choice);
						hResult = g_pReg->UnknownMessage(pRasMessage);
						break;
					}
				}

				// Free the encoder memory
				g_pCoder->Free(pRasMessage);
			}
		}
		else
		{
			// WSAEINTR - returned when socket closed
			//            get out cleanly
			if ((nRet = g_pReg->m_pSocket->GetLastError()) == WSAEINTR)
				hResult = GKI_GCF_RCV;

			else
			{
				hResult = GKI_WINSOCK2_ERROR(nRet);
				SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, %X)\n", hResult);
				PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_ERROR, 0, 
											hResult);
				hResult = GKI_EXIT_THREAD;
			}
		}
		g_pGatekeeper->Unlock();
	}

	// If not successful - need to remove retry thread and registration object
	g_pGatekeeper->Lock();
	if (g_pReg == 0)
	{
		SPIDER_TRACE(SP_THREAD, "Discovery thread exiting\n", 0);
		g_pGatekeeper->Unlock();
		return;
	}

	if (hResult != GKI_GCF_RCV)
	{
		SPIDER_TRACE(SP_NEWDEL, "del g_pReg = %X\n", g_pReg);
		delete g_pReg;
		g_pReg = 0;
	}
	else
		g_pReg->SetDiscThread(0);

	SPIDER_TRACE(SP_THREAD, "GKDiscovery thread exiting\n", 0);
	
	g_pGatekeeper->Unlock();
}
#endif // BROADCAST_DISCOVERY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\dspider.h ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\dspider.h_v  $
*																		*
*	$Revision:   1.2  $
*	$Date:   10 Jan 1997 16:14:18  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\dspider.h_v  $
 * 
 *    Rev 1.2   10 Jan 1997 16:14:18   CHULME
 * Removed MFC dependency
 * 
 *    Rev 1.1   22 Nov 1996 15:24:56   CHULME
 * Added VCS log to the header
*************************************************************************/

// dspider.h : header file
//

#ifndef DSPIDER_H
#define DSPIDER_H

#include "dgkiexp.h"	// need dwGKIDLLFlags

#ifdef _DEBUG
// Constants
const WORD SP_FUNC =	0x1;
const WORD SP_CONDES =	0x2;
const WORD SP_DEBUG =	0x4;
const WORD SP_NEWDEL =	0x8;
const WORD SP_THREAD =  0x10;
const WORD SP_STATE =	0x20;
const WORD SP_DUMPMEM = 0x40;
const WORD SP_XRS =     0x80;
const WORD SP_TEST =    0x100;
const WORD SP_LOGGER =  0x1000;
const WORD SP_PDU =		0x2000;
const WORD SP_WSOCK =	0x4000;
const WORD SP_GKI =		0x8000;

// TRACE Macros
#define SPIDER_TRACE(w, s, n)	if (dwGKIDLLFlags & w) {\
	wsprintf(szGKDebug, "%s,%d: ", __FILE__, __LINE__); \
	OutputDebugString(szGKDebug); \
	wsprintf(szGKDebug, s, n); \
	OutputDebugString(szGKDebug); }
#define SPIDER_DEBUG(n)			if (dwGKIDLLFlags & SP_DEBUG) {\
	wsprintf(szGKDebug, "%s,%d: ", __FILE__, __LINE__); \
	OutputDebugString(szGKDebug); \
	wsprintf(szGKDebug, #n "=%X\n", n); \
	OutputDebugString(szGKDebug); }
#define SPIDER_DEBUGS(n)		if (dwGKIDLLFlags & SP_DEBUG) {\
	wsprintf(szGKDebug, "%s,%d: ", __FILE__, __LINE__); \
	OutputDebugString(szGKDebug); \
	wsprintf(szGKDebug, #n "=%s\n", n); \
	OutputDebugString(szGKDebug); }

#else  // _DEBUG

#define SPIDER_TRACE(w, s, n)
#define SPIDER_DEBUG(n)
#define SPIDER_DEBUGS(s)
#define SpiderWSErrDecode(nRet)


#endif // _DEBUG

#endif // SPIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\debug.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\debug.cpv  $
*																		*
*	$Revision:   1.5  $
*	$Date:   17 Jan 1997 09:01:50  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\debug.cpv  $
// 
//    Rev 1.5   17 Jan 1997 09:01:50   CHULME
// No change.
// 
//    Rev 1.4   10 Jan 1997 16:13:52   CHULME
// Removed MFC dependency
// 
//    Rev 1.3   17 Dec 1996 18:22:20   CHULME
// Switch src and destination fields on ARQ for Callee
// 
//    Rev 1.2   22 Nov 1996 15:22:30   CHULME
// Added VCS log to the header
*************************************************************************/

// Debug.cpp : Contains conditional compiled debug dump routines
//

#include "precomp.h"

#include <winsock.h>
#include "GKICOM.H"
#include "dspider.h"

#ifdef _DEBUG
extern "C" WORD DLL_EXPORT
Dump_GKI_RegistrationRequest(long lVersion, 
							 SeqTransportAddr *pCallSignalAddr, 
							 EndpointType *pTerminalType,
							 SeqAliasAddr *pRgstrtnRqst_trmnlAls, 
							 HWND hWnd,
							 WORD wBaseMessage,
							 unsigned short usRegistrationTransport)
{
	SeqTransportAddr	*ps2;
	SeqAliasAddr		*ps4;
	unsigned short		len, us;
	char				*pc;
	char				szGKDebug[80];

	wsprintf(szGKDebug, "\tlVersion = %X\n", lVersion);
	OutputDebugString(szGKDebug);
	for (ps2 = pCallSignalAddr; ps2 != NULL; ps2 = ps2->next)
	{
		wsprintf(szGKDebug, "\tpCallSignalAddr->value.choice = %X\n", ps2->value.choice);
		OutputDebugString(szGKDebug);
		ASSERT((ps2->value.choice == ipAddress_chosen) || (ps2->value.choice == ipxAddress_chosen));
		switch (ps2->value.choice)
		{
		case ipAddress_chosen:
			len = (unsigned short) ps2->value.u.ipAddress.ip.length;
			wsprintf(szGKDebug, "\tpCallSignalAddr->value.u.ipAddress.ip.length = %X\n", len);
			OutputDebugString(szGKDebug);
			OutputDebugString("\tpCallSignalAddr->value.u.ipAddress.ip.value = ");
			for (us = 0; us < len; us++)
			{
				wsprintf(szGKDebug, "%d.", ps2->value.u.ipAddress.ip.value[us]);
				OutputDebugString(szGKDebug);
			}
			wsprintf(szGKDebug, "\n\tpCallSignalAddr->value.u.ipAddress.port = %X\n",	
					ps2->value.u.ipAddress.port);
			OutputDebugString(szGKDebug);
			break;

		case ipxAddress_chosen:
			len = (unsigned short) ps2->value.u.ipxAddress.node.length;
			wsprintf(szGKDebug, "\tpCallSignalAddr->value.u.ipxAddress.node.length = %X\n", len);
			OutputDebugString(szGKDebug);
			OutputDebugString("\tpCallSignalAddr->value.u.ipxAddress.node.value = ");
			for (us = 0; us < len; us++)
			{
				wsprintf(szGKDebug, "%02X", ps2->value.u.ipxAddress.node.value[us]);
				OutputDebugString(szGKDebug);
			}
			len = (unsigned short) ps2->value.u.ipxAddress.netnum.length;
			wsprintf(szGKDebug, "\n\tpCallSignalAddr->value.u.ipxAddress.netnum.length = %X\n", len);
			OutputDebugString(szGKDebug);
			OutputDebugString("\tpCallSignalAddr->value.u.ipxAddress.netnum.value = ");
			for (us = 0; us < len; us++)
			{
				wsprintf(szGKDebug, "%02X", ps2->value.u.ipxAddress.netnum.value[us]);
				OutputDebugString(szGKDebug);
			}
			len = (unsigned short) ps2->value.u.ipxAddress.port.length;
			wsprintf(szGKDebug, "\n\tpCallSignalAddr->value.u.ipxAddress.port.length = %X\n", len);
			OutputDebugString(szGKDebug);
			OutputDebugString("\tpCallSignalAddr->value.u.ipxAddress.port.value = ");
			for (us = 0; us < len; us++)
			{
				wsprintf(szGKDebug, "%02X", ps2->value.u.ipxAddress.port.value[us]);
				OutputDebugString(szGKDebug);
			}
			OutputDebugString("\n");
			break;
		}
	}

	wsprintf(szGKDebug, "\tpTerminalType->bit_mask = %X\n", pTerminalType->bit_mask);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tpTerminalType->mc = %X\n", pTerminalType->mc);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tpTerminalType->undefinedNode = %X\n", pTerminalType->undefinedNode);
	OutputDebugString(szGKDebug);

	for (ps4 = pRgstrtnRqst_trmnlAls; ps4 != NULL; ps4 = ps4->next)
	{
		wsprintf(szGKDebug, "\tpRgstrtnRqst_trmnlAls->value.choice = %X\n", ps4->value.choice);
		OutputDebugString(szGKDebug);
		ASSERT((ps4->value.choice == e164_chosen) || (ps4->value.choice == h323_ID_chosen));
		switch (ps4->value.choice)
		{
		case e164_chosen:
			OutputDebugString("\tpRgstrtnRqst_trmnlAls->value.u.e164 = ");
			for (pc = ps4->value.u.e164; *pc != 0; pc++)
			{
				wsprintf(szGKDebug, "%c", *pc);
				OutputDebugString(szGKDebug);
			}
			OutputDebugString("\n");
			break;
		case h323_ID_chosen:
			len = (unsigned short) ps4->value.u.h323_ID.length;
			wsprintf(szGKDebug, "\tpRgstrtnRqst_trmnlAls->value.u.h323ID.length = %X\n", len);
			OutputDebugString(szGKDebug);
			OutputDebugString("\tpRgstrtnRqst_trmnlAls->value.u.h323ID.value = ");
			for (us = 0; us < len; us++)
			{
				wsprintf(szGKDebug, "%c", ps4->value.u.h323_ID.value[us]);
				OutputDebugString(szGKDebug);
			}
			OutputDebugString("\n");
			break;
		}
	}
	wsprintf(szGKDebug, "\thWnd = %X\n", hWnd);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\twBaseMessage = %X\n", wBaseMessage);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tRegistrationTransport = %X\n", usRegistrationTransport);
	OutputDebugString(szGKDebug);
	return (0);
}

extern "C" WORD DLL_EXPORT
Dump_GKI_AdmissionRequest(unsigned short		usCallTypeChoice,
						SeqAliasAddr		*pRemoteInfo,
						TransportAddress	*pRemoteCallSignalAddress,
						SeqAliasAddr		*pDestExtraCallInfo,
						BandWidth			bandWidth,
						ConferenceIdentifier	*pConferenceID,
						BOOL				activeMC,
						BOOL				answerCall,
						unsigned short		usCallTransport)
{
	TransportAddress	*ps2;
	SeqAliasAddr		*ps4;
	unsigned short		len, us;
	char				*pc;
	char				szGKDebug[80];

	wsprintf(szGKDebug, "\tusCallTypeChoice = %X\n", usCallTypeChoice);
	OutputDebugString(szGKDebug);

	for (ps4 = pRemoteInfo; ps4 != NULL; ps4 = ps4->next)
	{
		wsprintf(szGKDebug, "\tpRemoteInfo->value.choice = %X\n", ps4->value.choice);
		OutputDebugString(szGKDebug);
		ASSERT((ps4->value.choice == e164_chosen) || (ps4->value.choice == h323_ID_chosen));
		switch (ps4->value.choice)
		{
		case e164_chosen:
			OutputDebugString("\tpRemoteInfo->value.u.e164 = ");
			for (pc = ps4->value.u.e164; *pc != 0; pc++)
			{
				wsprintf(szGKDebug, "%c", *pc);
				OutputDebugString(szGKDebug);
			}
			OutputDebugString("\n");
			break;
		case h323_ID_chosen:
			len = (unsigned short) ps4->value.u.h323_ID.length;
			wsprintf(szGKDebug, "\tpRemoteInfo->value.u.h323ID.length = %X\n", len);
			OutputDebugString(szGKDebug);
			OutputDebugString("\tpRemoteInfo->value.u.h323ID.value = ");
			for (us = 0; us < len; us++)
			{
				wsprintf(szGKDebug, "%c", ps4->value.u.h323_ID.value[us]);
				OutputDebugString(szGKDebug);
			}
			OutputDebugString("\n");
			break;
		}
	}

   ps2 = pRemoteCallSignalAddress;
   if (ps2)
   {
	    wsprintf(szGKDebug, "\tpRemoteCallSignalAddress->choice = %X\n", ps2->choice);
		OutputDebugString(szGKDebug);
	    ASSERT((ps2->choice == ipAddress_chosen) || (ps2->choice == ipxAddress_chosen));
	    switch (ps2->choice)
	    {
	    case ipAddress_chosen:
		    len = (unsigned short) ps2->u.ipAddress.ip.length;
		    wsprintf(szGKDebug, "\tpRemoteCallSignalAddress->u.ipAddress.ip.length = %X\n", len);
			OutputDebugString(szGKDebug);
		    OutputDebugString("\tpRemoteCallSignalAddress->u.ipAddress.ip.value = ");
		    for (us = 0; us < len; us++)
			{
			    wsprintf(szGKDebug, "%d.", ps2->u.ipAddress.ip.value[us]);
				OutputDebugString(szGKDebug);
			}
		    wsprintf(szGKDebug, "\n\tpRemoteCallSignalAddress->u.ipAddress.port = %X\n", 
					ps2->u.ipAddress.port);
			OutputDebugString(szGKDebug);
		    break;

	    case ipxAddress_chosen:
		    len = (unsigned short) ps2->u.ipxAddress.node.length;
		    wsprintf(szGKDebug, "\tpRemoteCallSignalAddress->u.ipxAddress.node.length = %X\n", len);
			OutputDebugString(szGKDebug);
		    OutputDebugString("\tpRemoteCallSignalAddress->u.ipxAddress.node.value = ");
		    for (us = 0; us < len; us++)
			{
			    wsprintf(szGKDebug, "%02X", ps2->u.ipxAddress.node.value[us]);
				OutputDebugString(szGKDebug);
			}
		    len = (unsigned short) ps2->u.ipxAddress.netnum.length;
		    wsprintf(szGKDebug, "\n\tpRemoteCallSignalAddress->u.ipxAddress.netnum.length = %X\n", len);
			OutputDebugString(szGKDebug);
		    OutputDebugString("\tpRemoteCallSignalAddress->u.ipxAddress.netnum.value = ");
		    for (us = 0; us < len; us++)
			{
			    wsprintf(szGKDebug, "%02X", ps2->u.ipxAddress.netnum.value[us]);
				OutputDebugString(szGKDebug);
			}
		    len = (unsigned short) ps2->u.ipxAddress.port.length;
		    wsprintf(szGKDebug, "\n\tpRemoteCallSignalAddress->u.ipxAddress.port.length = %X\n", len);
			OutputDebugString(szGKDebug);
		    OutputDebugString("\tpRemoteCallSignalAddress->u.ipxAddress.port.value = ");
		    for (us = 0; us < len; us++)
			{
			    wsprintf(szGKDebug, "%02X", ps2->u.ipxAddress.port.value[us]);
				OutputDebugString(szGKDebug);
			}
		    OutputDebugString("\n");
		    break;
	    }
    }

	for (ps4 = pDestExtraCallInfo; ps4 != NULL; ps4 = ps4->next)
	{
		wsprintf(szGKDebug, "\tpDestExtraCallInfo->value.choice = %X\n", ps4->value.choice);
		OutputDebugString(szGKDebug);
		ASSERT((ps4->value.choice == e164_chosen) || (ps4->value.choice == h323_ID_chosen));
		switch (ps4->value.choice)
		{
		case e164_chosen:
			OutputDebugString("\tpDestExtraCallInfo->value.u.e164 = ");
			for (pc = ps4->value.u.e164; *pc != 0; pc++)
			{
				wsprintf(szGKDebug, "%c", *pc);
				OutputDebugString(szGKDebug);
			}
			OutputDebugString("\n");
			break;
		case h323_ID_chosen:
			len = (unsigned short) ps4->value.u.h323_ID.length;
			wsprintf(szGKDebug, "\tpDestinationInfo->value.u.h323ID.length = %X\n", len);
			OutputDebugString(szGKDebug);
			OutputDebugString("\tpDestinationInfo->value.u.h323ID.value = ");
			for (us = 0; us < len; us++)
			{
				wsprintf(szGKDebug, "%c", ps4->value.u.h323_ID.value[us]);
				OutputDebugString(szGKDebug);
			}
			OutputDebugString("\n");
			break;
		}
	}

	wsprintf(szGKDebug, "\tbandWidth = %X\n", bandWidth);
	OutputDebugString(szGKDebug);
    if (pConferenceID)
    {
	    wsprintf(szGKDebug, "\tpConferenceID->length = %X\n", pConferenceID->length);
		OutputDebugString(szGKDebug);
	    OutputDebugString("\tpConferenceID->value = ");
	    for (us = 0; us < pConferenceID->length; us++)
		{
		    wsprintf(szGKDebug, "%02X", pConferenceID->value[us]);
			OutputDebugString(szGKDebug);
		}
	    OutputDebugString("\n");
	}
	wsprintf(szGKDebug, "\tactiveMC = %X\n", activeMC);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tanswerCall = %X\n", answerCall);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tusCallTransport = %X\n", usCallTransport);
	OutputDebugString(szGKDebug);
	return (0);
}

extern "C" WORD DLL_EXPORT
Dump_GKI_LocationRequest(SeqAliasAddr *pLocationInfo)
{
	SeqAliasAddr		*ps4;
	unsigned short		len, us;
	char				*pc;
	char				szGKDebug[80];

	for (ps4 = pLocationInfo; ps4 != NULL; ps4 = ps4->next)
	{
		wsprintf(szGKDebug, "\tpLocationInfo->value.choice = %X\n", ps4->value.choice);
		OutputDebugString(szGKDebug);
		ASSERT((ps4->value.choice == e164_chosen) || (ps4->value.choice == h323_ID_chosen));
		switch (ps4->value.choice)
		{
		case e164_chosen:
			OutputDebugString("\tpLocationInfo->value.u.e164 = ");
			for (pc = ps4->value.u.e164; *pc != 0; pc++)
			{
				wsprintf(szGKDebug, "%c", *pc);
				OutputDebugString(szGKDebug);
			}
			OutputDebugString("\n");
			break;
		case h323_ID_chosen:
			len = (unsigned short) ps4->value.u.h323_ID.length;
			wsprintf(szGKDebug, "\tpLocationInfo->value.u.h323ID.length = %X\n", len);
			OutputDebugString(szGKDebug);
			OutputDebugString("\tpLocationInfo->value.u.h323ID.value = ");
			for (us = 0; us < len; us++)
			{
				wsprintf(szGKDebug, "%c", ps4->value.u.h323_ID.value[us]);
				OutputDebugString(szGKDebug);
			}
			OutputDebugString("\n");
			break;
		}
	}
	return (0);
}

void
SpiderWSErrDecode(int nErr)
{

#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_DEBUG(nErr);

	switch (nErr)
	{
	case WSAEINTR:
		OutputDebugString("WSAEINTR\n");
		break; 
	case WSAEBADF:
		OutputDebugString("WSAEBADF\n");
		break; 
	case WSAEACCES:
		OutputDebugString("WSAEACCES\n");
		break;
	case WSAEFAULT:
		OutputDebugString("WSAEFAULT\n");
		break;
	case WSAEINVAL:
		OutputDebugString("WSAEINVAL\n");
		break;
	case WSAEMFILE:
		OutputDebugString("WSAEMFILE\n");
		break;

	case WSAEWOULDBLOCK:
		OutputDebugString("WSAEWOULDBLOCK\n");
		break;    
	case WSAEINPROGRESS:
		OutputDebugString("WSAEINPROGRESS\n");
		break;    
	case WSAEALREADY:
		OutputDebugString("WSAEALREADY\n");
		break;       
	case WSAENOTSOCK:
		OutputDebugString("WSAENOTSOCK\n");
		break;       
	case WSAEDESTADDRREQ:
		OutputDebugString("WSAEDESTADDRREQ\n");
		break;   
	case WSAEMSGSIZE:
		OutputDebugString("WSAEMSGSIZE\n");
		break;       
	case WSAEPROTOTYPE:
		OutputDebugString("WSAEPROTOTYPE\n");
		break;     
	case WSAENOPROTOOPT:
		OutputDebugString("WSAENOPROTOOPT\n");
		break;    
	case WSAEPROTONOSUPPORT:
		OutputDebugString("WSAEPROTONOSUPPORT\n");
		break;
	case WSAESOCKTNOSUPPORT:
		OutputDebugString("WSAESOCKTNOSUPPORT\n");
		break;
	case WSAEOPNOTSUPP:
		OutputDebugString("WSAEOPNOTSUPP\n");
		break;     
	case WSAEPFNOSUPPORT:
		OutputDebugString("WSAEPFNOSUPPORT\n");
		break;   
	case WSAEAFNOSUPPORT:
		OutputDebugString("WSAEAFNOSUPPORT\n");
		break;   
	case WSAEADDRINUSE:
		OutputDebugString("WSAEADDRINUSE\n");
		break;     
	case WSAEADDRNOTAVAIL:
		OutputDebugString("WSAEADDRNOTAVAIL\n");
		break;  
	case WSAENETDOWN:
		OutputDebugString("WSAENETDOWN\n");
		break;       
	case WSAENETUNREACH:
		OutputDebugString("WSAENETUNREACH\n");
		break;    
	case WSAENETRESET:
		OutputDebugString("WSAENETRESET\n");
		break;      
	case WSAECONNABORTED:
		OutputDebugString("WSAECONNABORTED\n");
		break;   
	case WSAECONNRESET:
		OutputDebugString("WSAECONNRESET\n");
		break;     
	case WSAENOBUFS:
		OutputDebugString("WSAENOBUFS\n");
		break;        
	case WSAEISCONN:
		OutputDebugString("WSAEISCONN\n");
		break;        
	case WSAENOTCONN:
		OutputDebugString("WSAENOTCONN\n");
		break;       
	case WSAESHUTDOWN:
		OutputDebugString("WSAESHUTDOWN\n");
		break;      
	case WSAETOOMANYREFS:
		OutputDebugString("WSAETOOMANYREFS\n");
		break;   
	case WSAETIMEDOUT:
		OutputDebugString("WSAETIMEDOUT\n");
		break;      
	case WSAECONNREFUSED:
		OutputDebugString("WSAECONNREFUSED\n");
		break;   
	case WSAELOOP:
		OutputDebugString("WSAELOOP\n");
		break;          
	case WSAENAMETOOLONG:
		OutputDebugString("WSAENAMETOOLONG\n");
		break;   
	case WSAEHOSTDOWN:
		OutputDebugString("WSAEHOSTDOWN\n");
		break;      
	case WSAEHOSTUNREACH:
		OutputDebugString("WSAEHOSTUNREACH\n");
		break;   
	case WSAENOTEMPTY:
		OutputDebugString("WSAENOTEMPTY\n");
		break;      
	case WSAEPROCLIM:
		OutputDebugString("WSAEPROCLIM\n");
		break;       
	case WSAEUSERS:
		OutputDebugString("WSAEUSERS\n");
		break;         
	case WSAEDQUOT:
		OutputDebugString("WSAEDQUOT\n");
		break;         
	case WSAESTALE:
		OutputDebugString("WSAESTALE\n");
		break;         
	case WSAEREMOTE:
		OutputDebugString("WSAEREMOTE\n");
		break;        

	case WSAEDISCON:
		OutputDebugString("WSAEDISCON\n");
		break;        

	case WSASYSNOTREADY:
		OutputDebugString("WSASYSNOTREADY\n");
		break;
	case WSAVERNOTSUPPORTED:
		OutputDebugString("WSAVERNOTSUPPORTED\n");
		break;
	case WSANOTINITIALISED:
		OutputDebugString("WSANOTINITIALISED\n");
		break;
	case WSAHOST_NOT_FOUND:
		OutputDebugString("WSAHOST_NOT_FOUND\n");
		break;
	case WSATRY_AGAIN:
		OutputDebugString("WSATRY_AGAIN\n");
		break;
	case WSANO_RECOVERY:
		OutputDebugString("WSANO_RECOVERY\n");
		break;
	case WSANO_DATA:
		OutputDebugString("WSANO_DATA\n");
		break;
#if 0	// This one is a duplicate of WSANO_DATA
	case WSANO_ADDRESS:
		OutputDebugString("WSANO_ADDRESS\n");
		break;
#endif // 0
	}
}


void 
DumpMem(void *pv, int nLen)
{
	int n, nMax;
	struct {
		char szBytes[16][3];
		char c;
		char szAscii[17];
	} sRecord;
	unsigned char *puc;
	unsigned char uc;
	char				szGKDebug[80];

	puc = (unsigned char *)pv;
	while (nLen)
	{
		memset(&sRecord, ' ', sizeof(sRecord));
		sRecord.szBytes[15][2] = '\0';
		sRecord.szAscii[16] = '\0';

		nMax = (nLen < 16) ? nLen : 16;
		for (n = 0; n < nMax; n++)
		{
			uc = *(puc + n);
			wsprintf(&sRecord.szBytes[n][0], "%02X ", uc);
			sRecord.szAscii[n] = isprint(uc) ? uc : '.';
		}
		wsprintf(szGKDebug, "%X: %s '%s'\n", puc, &sRecord.szBytes[0][0], &sRecord.szAscii[0]);
		OutputDebugString(szGKDebug);
		puc += nMax;
		nLen -= nMax;
	}
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\dgkiexp.h ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\dgkiexp.h_v  $
*																		*
*	$Revision:   1.4  $
*	$Date:   11 Feb 1997 15:35:08  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\dgkiexp.h_v  $
 * 
 *    Rev 1.4   11 Feb 1997 15:35:08   CHULME
 * Added GKI_CleanupRequest function to offload DLL_PROCESS_DETACH
 * 
 *    Rev 1.3   10 Jan 1997 16:13:58   CHULME
 * Removed MFC dependency
 * 
 *    Rev 1.2   17 Dec 1996 18:22:28   CHULME
 * Switch src and destination fields on ARQ for Callee
 * 
 *    Rev 1.1   22 Nov 1996 15:25:14   CHULME
 * Added VCS log to the header
*************************************************************************/

// dgkiexp.h : header file
//

#ifndef DGKIEXP_H
#define DGKIEXP_H
#include "incommon.h"

#ifdef __cplusplus
extern "C" {
#endif

#include "GKICOM.H"

#if(0)  // it's all in one DLL
#define DLL_EXPORT __declspec(dllexport)
#define DLL_IMPORT __declspec(dllimport)
#else
#define DLL_EXPORT
#define DLL_IMPORT
#endif
// ------------------------ Variable Exports --------------------------
extern DLL_EXPORT DWORD	dwGKIDLLFlags;
extern DLL_EXPORT BOOL	fGKIEcho;
extern DLL_EXPORT BOOL  fGKIDontSend;

// ------------------------ Function Exports --------------------------
HRESULT DLL_EXPORT GKI_RegistrationRequest(long				lVersion,
										SeqTransportAddr	*pCallSignalAddr, 
										EndpointType		*pTerminalType,
										SeqAliasAddr		*pRgstrtnRqst_trmnlAls, 
										PCC_VENDORINFO      pVendorInfo,
										HWND				hWnd,
										WORD				wBaseMessage,
										unsigned short		usRegistrationTransport /* = ipAddress_chosen */);

HRESULT DLL_EXPORT GKI_UnregistrationRequest(void);

HRESULT DLL_EXPORT GKI_LocationRequest(SeqAliasAddr			*pLocationInfo);

HRESULT DLL_EXPORT GKI_AdmissionRequest(unsigned short		usCallTypeChoice,
									SeqAliasAddr		*pRemoteInfo,
									TransportAddress	*pRemoteCallSignalAddress,
									SeqAliasAddr		*pDestExtraCallInfo,
									LPGUID				pCallIdentifier,
									BandWidth			bandWidth,
									ConferenceIdentifier	*pConferenceID,
									BOOL				activeMC,
									BOOL				answerCall,
									unsigned short		usCallTransport /* = ipAddress_chosen */);

HRESULT DLL_EXPORT GKI_BandwidthRequest(HANDLE				hModCall, 
									unsigned short		usCallTypeChoice,
									BandWidth			bandWidth);

HRESULT DLL_EXPORT GKI_DisengageRequest(HANDLE hCall);
HRESULT DLL_EXPORT GKI_Initialize(void);
HRESULT DLL_EXPORT GKI_CleanupRequest(void);

#ifdef _DEBUG
WORD DLL_EXPORT Dump_GKI_RegistrationRequest(long		lVersion, 
											SeqTransportAddr	*pCallSignalAddr, 
											EndpointType		*pTerminalType,
											SeqAliasAddr		*pRgstrtnRqst_trmnlAls, 
											HWND				hWnd,
											WORD				wBaseMessage,
											unsigned short		usRegistrationTransport /* = ipAddress_chosen */);

WORD DLL_EXPORT Dump_GKI_AdmissionRequest(unsigned short		usCallTypeChoice,
										SeqAliasAddr		*pRemoteInfo,
										TransportAddress	*pRemoteCallSignalAddress,
										SeqAliasAddr		*pDestExtraCallInfo,
										BandWidth			bandWidth,
										ConferenceIdentifier	*pConferenceID,
										BOOL				activeMC,
										BOOL				answerCall,
										unsigned short		usCallTransport /* = ipAddress_chosen */);

WORD DLL_EXPORT Dump_GKI_LocationRequest(SeqAliasAddr	*pLocationInfo);
#endif // _DEBUG

#ifdef __cplusplus
}
#endif // __cplusplus

#endif	// DGKIEXP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\dcall.h ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\dcall.h_v  $
*																		*
*	$Revision:   1.3  $
*	$Date:   10 Jan 1997 16:13:46  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\dcall.h_v  $
 * 
 *    Rev 1.3   10 Jan 1997 16:13:46   CHULME
 * Removed MFC dependency
 * 
 *    Rev 1.2   17 Dec 1996 18:22:18   CHULME
 * Switch src and destination fields on ARQ for Callee
 * 
 *    Rev 1.1   22 Nov 1996 15:25:10   CHULME
 * Added VCS log to the header
*************************************************************************/

// dcall.h : interface of the CCall class
// See dcall.cpp for the implementation of this class
/////////////////////////////////////////////////////////////////////////////

#ifndef DCALL_H
#define DCALL_H

class CRegistration;

class CCall
{
private:
	CallType				m_callType;
	SeqAliasAddr			*m_pRemoteInfo;
	TransportAddress		m_RemoteCallSignalAddress;
	SeqAliasAddr			*m_pDestExtraCallInfo;
	TransportAddress		m_LocalCallSignalAddress;
	BandWidth				m_bandWidth;
	CallReferenceValue		m_callReferenceValue;
	ConferenceIdentifier	m_conferenceID;
	BOOL					m_activeMC;
	BOOL					m_answerCall;
    GUID                    m_CallIdentifier;
	unsigned short			m_usTimeTilStatus;

	UINT                    m_uRetryResetCount;
	UINT                    m_uRetryCountdown;
	UINT                    m_uMaxRetryCount;
	
	CallReturnInfo			m_CallReturnInfo;
	BandWidth				m_CFbandWidth;
	unsigned short			m_CFirrFrequency;

	enum {
		GK_ADM_PENDING,
		GK_CALL,
		GK_DISENG_PENDING,
		GK_DISENGAGED,
		GK_BW_PENDING
	}						m_State;

	RasMessage				*m_pRasMessage;
	unsigned short			m_usRetryCount;

public:
	CCall();
	~CCall();
	void SetCallIdentifier(LPGUID pID)
	{
        m_CallIdentifier = *pID;
	}
	HANDLE GetHCall(void)
	{
		return (m_CallReturnInfo.hCall);
	}
	void SetCallType(unsigned short usChoice)
	{
		m_callType.choice = usChoice;
	}
	HRESULT AddRemoteInfo(AliasAddress& rvalue);
	void SetRemoteCallSignalAddress(TransportAddress *pTA)
	{
		m_RemoteCallSignalAddress = *pTA;
	}
	HRESULT AddDestExtraCallInfo(AliasAddress& rvalue);
	HRESULT SetLocalCallSignalAddress(unsigned short usCallTransport);
	void SetBandWidth(BandWidth bw)
	{
		m_bandWidth = bw;
	}
	void SetCallReferenceValue(CallReferenceValue crv)
	{
		m_callReferenceValue = crv;
	}
	void SetConferenceID(ConferenceIdentifier *pCID);
	void GenerateConferenceID(void);
	void SetActiveMC(BOOL amc)
	{
		m_activeMC = amc;
	}
	void SetAnswerCall(BOOL ac)
	{
		m_answerCall = ac;
	}
	RasMessage *GetRasMessage(void)
	{
		return (m_pRasMessage);
	}

	HRESULT AdmissionRequest(void);
	HRESULT AdmissionConfirm(RasMessage *pRasMessage);
	HRESULT AdmissionReject(RasMessage *pRasMessage);
	HRESULT BandwidthRequest(void);
	HRESULT BandwidthConfirm(RasMessage *pRasMessage);
	HRESULT BandwidthReject(RasMessage *pRasMessage);
	HRESULT SendBandwidthConfirm(RasMessage *pRasMessage);
	HRESULT DisengageRequest(void);
	HRESULT DisengageConfirm(RasMessage *pRasMessage);
	HRESULT DisengageReject(RasMessage *pRasMessage);
	HRESULT SendDisengageConfirm(RasMessage *pRasMessage);
	HRESULT Retry(void);
	HRESULT SendInfoRequestResponse(CallInfoStruct *pCallInfo, RasMessage *pRasMessage, BOOL fThisCallOnly);
	BOOL MatchSeqNum(RequestSeqNum seqNum);
	BOOL MatchCRV(CallReferenceValue crv);
};

#endif // DCALL_H

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\dgkiext.h ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\dgkiext.h_v  $
*																		*
*	$Revision:   1.2  $
*	$Date:   10 Jan 1997 16:14:02  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\dgkiext.h_v  $
 * 
 *    Rev 1.2   10 Jan 1997 16:14:02   CHULME
 * Removed MFC dependency
 * 
 *    Rev 1.1   22 Nov 1996 15:22:20   CHULME
 * Added VCS log to the header
*************************************************************************/

// dgkiext.h : header file
//

#ifndef DGKIEXT_H
#define DGKIEXT_H

extern CGatekeeper		*g_pGatekeeper;
extern char				*pEchoBuff;
extern int				nEchoLen;
extern CRegistration	*g_pReg;
extern Coder			*g_pCoder;

#endif	// DGKIEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\gatekpr.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\gatekpr.cpv  $
*																		*
*	$Revision:   1.9  $
*	$Date:   19 Feb 1997 13:57:36  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\gatekpr.cpv  $
// 
//    Rev 1.9   19 Feb 1997 13:57:36   CHULME
// Modified DeleteCachedAddress to write all registry settings
// 
//    Rev 1.8   14 Feb 1997 16:41:16   CHULME
// Changed registry key to GKIDLL\2.0 to match GKI version
// 
//    Rev 1.7   17 Jan 1997 12:53:00   CHULME
// Removed UNICODE dependent code
// 
//    Rev 1.6   17 Jan 1997 09:01:58   CHULME
// No change.
// 
//    Rev 1.5   13 Jan 1997 17:01:38   CHULME
// Fixed debug messages for registry cached addresses
// 
//    Rev 1.4   10 Jan 1997 16:14:22   CHULME
// Removed MFC dependency
// 
//    Rev 1.3   20 Dec 1996 16:37:42   CHULME
// Fixed access synchronization with Gatekeeper lock
// 
//    Rev 1.2   19 Dec 1996 19:27:32   CHULME
// Retry count and interval only read/written to registry on DEBUG
// 
//    Rev 1.1   22 Nov 1996 15:24:28   CHULME
// Added VCS log to the header
*************************************************************************/

// gatekeeper.cpp : Provides the implementation for the CGatekeeper class
//

#include "precomp.h"

#include "dspider.h"
#include "dgkilit.h"
#include "GATEKPR.H"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGatekeeper construction

CGatekeeper::CGatekeeper()
:m_dwMCastTTL(1),
m_fRejectReceived(FALSE),
m_dwLockingThread(0)
{
	SetIPAddress("");
	m_GKSockAddr.sin_addr.S_un.S_addr = INADDR_ANY;
	InitializeCriticalSection(&m_CriticalSection);
}

/////////////////////////////////////////////////////////////////////////////
// CGatekeeper destruction

CGatekeeper::~CGatekeeper()
{
	if (m_dwLockingThread)
		Unlock();
	DeleteCriticalSection(&m_CriticalSection);
}


void 
CGatekeeper::Read(void)
{
// ABSTRACT:  This member function will read the gatekeeper addresses and the
//            multicast flag from the Registry and load the member variables
// AUTHOR:    Colin Hulme

	HKEY			hKey;
	DWORD			dwDisposition;
	DWORD			dwType;
	DWORD			dwLen;
	LONG			lRet;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CGatekeeper::Read()\n", 0);

	dwType = REG_SZ;
	lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Conferencing\\GatekeeperDLL"),
				   0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
				   NULL, &hKey, &dwDisposition);
	dwLen =IPADDR_SZ + 1;
	
#if(0)	// don't do the registry hack now that setting the address is exposed
	lRet = RegQueryValueEx(hKey, TEXT("GKIPAddress"), NULL, &dwType, 
					(LPBYTE)m_GKIPAddress, &dwLen);
	SPIDER_DEBUGS(m_GKIPAddress);

	if(m_GKIPAddress[0] != 0)
	{
		m_GKSockAddr.sin_addr.s_addr = inet_addr(m_GKIPAddress);
	}
	
#endif // if(0)
	dwType = REG_DWORD;
	dwLen = sizeof(DWORD);
	RegQueryValueEx(hKey, TEXT("GKMCastTTL"), NULL, &dwType,
					(LPBYTE)&m_dwMCastTTL, &dwLen);
	SPIDER_DEBUG(m_dwMCastTTL);
	
#if(0)
#ifdef _DEBUG
	RegQueryValueEx(hKey, TEXT("GKRetryMS"), NULL, &dwType,
					(LPBYTE)&m_dwRetryMS, &dwLen);
	if (m_dwRetryMS == 0)
		m_dwRetryMS = DEFAULT_RETRY_MS;
	SPIDER_DEBUG(m_dwRetryMS);

	RegQueryValueEx(hKey, TEXT("GKMaxRetries"), NULL, &dwType,
					(LPBYTE)&m_dwMaxRetries, &dwLen);
	if (m_dwMaxRetries == 0)
		m_dwMaxRetries = DEFAULT_MAX_RETRIES;
	SPIDER_DEBUG(m_dwMaxRetries);
#else
	m_dwRetryMS = DEFAULT_RETRY_MS;
	m_dwMaxRetries = DEFAULT_MAX_RETRIES;
#endif //_DEBUG
#endif // if(0)
	RegCloseKey(hKey);
}

void 
CGatekeeper::Write(void)
{
// ABSTRACT:  This member function will write the gatekeeper addresses and the
//            multicast flag to the Registry.
// AUTHOR:    Colin Hulme

	HKEY			hKey;
	DWORD			dwDisposition;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CGatekeeper::Write()\n", 0);

	RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Intel\\GKIDLL\\2.0"),
				   0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
				   NULL, &hKey, &dwDisposition);
	RegSetValueEx(hKey, TEXT("GKIPAddress"), NULL, REG_SZ, 
					(LPBYTE)m_GKIPAddress, lstrlenA(m_GKIPAddress));
#if(0)
#ifdef _DEBUG
	RegSetValueEx(hKey, TEXT("GKMCastTTL"), NULL, REG_DWORD, 
					(LPBYTE)&m_dwMCastTTL, sizeof(DWORD));
	RegSetValueEx(hKey, TEXT("GKRetryMS"), NULL, REG_DWORD,
					(LPBYTE)&m_dwRetryMS, sizeof(DWORD));
	RegSetValueEx(hKey, TEXT("GKMaxRetries"), NULL, REG_DWORD,
					(LPBYTE)&m_dwMaxRetries, sizeof(DWORD));

#endif //_DEBUG
#endif // if(0)
	RegCloseKey(hKey);
}

#ifdef BROADCAST_DISCOVERY		
void
CGatekeeper::DeleteCachedAddresses(void)
{
	// ABSTRACT:  This memeber function will delete the cached gatekeeper
	//            addresses from the Registry
	//AUTHOR:     Colin Hulme

	HKEY			hKey;
	DWORD			dwDisposition;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CGatekeeper::DeleteCachedAddresses()\n", 0);

	RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Intel\\GKIDLL\\2.0"),
				   0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
				   NULL, &hKey, &dwDisposition);
	RegDeleteValue(hKey, "GKIPAddress");
	RegDeleteValue(hKey, "GKIPXAddress");

#ifdef _DEBUG
	RegSetValueEx(hKey, TEXT("GKMCastTTL"), NULL, REG_DWORD, 
					(LPBYTE)&m_dwMCastTTL, sizeof(DWORD));
	RegSetValueEx(hKey, TEXT("GKRetryMS"), NULL, REG_DWORD,
					(LPBYTE)&m_dwRetryMS, sizeof(DWORD));
	RegSetValueEx(hKey, TEXT("GKMaxRetries"), NULL, REG_DWORD,
					(LPBYTE)&m_dwMaxRetries, sizeof(DWORD));
#endif

	RegCloseKey(hKey);
}
#endif //#ifdef BROADCAST_DISCOVERY		

void
CGatekeeper::Lock(void)
{
	EnterCriticalSection(&m_CriticalSection);
	m_dwLockingThread = GetCurrentThreadId();
}

void
CGatekeeper::Unlock(void)
{
	// Assert that the unlock is done by the
	// thread that holds the lock
	ASSERT(m_dwLockingThread == GetCurrentThreadId());
	
	m_dwLockingThread = 0;
	LeaveCriticalSection(&m_CriticalSection);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\fsmexpor.h ===
/***********************************************************************
 *                                                                     *
 * Filename: FSMEXPOR.H                                                *
 * Module:   H245 SubSystem                                            *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   FSMEXPOR.H  $
 * $Revision:   1.6  $
 * $Modtime:   09 Dec 1996 13:40:40  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/FSMEXPOR.H_v  $
 *
 *    Rev 1.6   09 Dec 1996 13:40:44   EHOWARDX
 * Updated copyright notice.
 *
 *    Rev 1.5   19 Jul 1996 12:02:54   EHOWARDX
 * Eliminated event definitions. FSM functions now use same events as API,
 * which are defined in H245API.H.
 *
 *    Rev 1.4   30 May 1996 23:38:14   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.3   29 May 1996 15:21:26   EHOWARDX
 * Change to use HRESULT.
 *
 *    Rev 1.2   28 May 1996 14:09:52   EHOWARDX
 * Tel Aviv update.
 *
 ***********************************************************************/

#include "h245asn1.h"

typedef MltmdSystmCntrlMssg PDU_t;

/* FSM initialization */
HRESULT
Fsm_init    (struct InstanceStruct *pInstance);

/* FSM shutdown */
HRESULT
Fsm_shutdown(struct InstanceStruct *pInstance);

/* Process PDU received from remote peer */
HRESULT
FsmIncoming (struct InstanceStruct *pInstance, PDU_t *pPdu);

/* Process PDU from H.245 client */
HRESULT
FsmOutgoing (struct InstanceStruct *pInstance, PDU_t *pPdu, DWORD_PTR dwTransId);

/* send a confirm to API */
HRESULT
H245FsmConfirm    (PDU_t                 *pPdu,
                   DWORD                  dwEvent,
                   struct InstanceStruct *pInstance,
                   DWORD_PTR              dwTransId,
                   HRESULT                lError);

/* send an indication to API */
HRESULT
H245FsmIndication (PDU_t                 *pPdu,
                   DWORD                  dwEvent,
                   struct InstanceStruct *pInstance,
                   DWORD_PTR              dwTransId,
                   HRESULT                lError);



/*********************************/
/* Errors passed up to the API */
/*********************************/

/* Session initialization indications */
#define SESSION_INIT            2101 /* after first term cap exchange */
#define SESSION_FAILED          2102 /* 1st Term caps failed */

 /* finite state machine is successful */
#define FSM_OK                  0
 /* define one reject for all requests */
#define REJECT                  2100

/* define one timer expiry error for all signallling entities */
#define TIMER_EXPIRY            2200

/* master slave failed */
#define MS_FAILED               2105

/* open unidirectional/bidirectional errors */
#define ERROR_A_INAPPROPRIATE   2106    /* inappropriate message */
#define ERROR_B_INAPPROPRIATE   2107    /* inappropriate message */
#define ERROR_C_INAPPROPRIATE   2108    /* inappropriate message */
#define ERROR_D_TIMEOUT         2109    /* timeout               */
#define ERROR_E_INAPPROPRIATE   2110    /* inappropriate message */
#define ERROR_F_TIMEOUT         2111    /* Timer expiry at incoming BLCSE */

extern unsigned int     uN100;          // Master Slave Determination
extern unsigned int     uT101;          // Capability Exchange
extern unsigned int     uT102;          // Maintenance Loop
extern unsigned int     uT103;          // Logical Channel Signalling
extern unsigned int     uT104;          // H.223 Multiplex Table
extern unsigned int     uT105;          // Round Trip Delay
extern unsigned int     uT106;          // Master Slave Determination
extern unsigned int     uT107;          // Request Multiplex Entry
extern unsigned int     uT108;          // Send Logical Channel
extern unsigned int     uT109;          // Mode Request

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\gatekpr.h ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\gatekpr.h_v  $
*																		*
*	$Revision:   1.5  $
*	$Date:   12 Feb 1997 01:10:56  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\gatekpr.h_v  $
 * 
 *    Rev 1.5   12 Feb 1997 01:10:56   CHULME
 * Redid thread synchronization to use Gatekeeper.Lock
 * 
 *    Rev 1.4   17 Jan 1997 12:52:46   CHULME
 * Removed UNICODE dependent code
 * 
 *    Rev 1.3   10 Jan 1997 16:14:26   CHULME
 * Removed MFC dependency
 * 
 *    Rev 1.2   20 Dec 1996 16:38:30   CHULME
 * Fixed access synchronization with Gatekeeper lock
 * 
 *    Rev 1.1   22 Nov 1996 15:24:22   CHULME
 * Added VCS log to the header
*************************************************************************/

// GATEKPR.H : interface of the CGatekeeper class
// See gatekeeper.cpp for the implementation of this class
/////////////////////////////////////////////////////////////////////////////

#ifndef GATEKEEPER_H
#define GATEKEEPER_H

class CGatekeeper
{
private:
	char				m_GKIPAddress[IPADDR_SZ + 1];
	SOCKADDR_IN         m_GKSockAddr;
	DWORD				m_dwMCastTTL;
	BOOL				m_fRejectReceived;
	CRITICAL_SECTION	m_CriticalSection;
	DWORD				m_dwLockingThread;

public:
	CGatekeeper();
	~CGatekeeper();

	void Read(void);
	void Write(void);
	#ifdef BROADCAST_DISCOVERY		
	void DeleteCachedAddresses(void);
	#endif // #ifdef BROADCAST_DISCOVERY		
	
	PSOCKADDR_IN GetSockAddr(void)
	{
	    if(m_GKSockAddr.sin_addr.S_un.S_addr != INADDR_ANY)
	    {	
	        return(&m_GKSockAddr);
	    }
	    else return NULL;
	}
	char *GetIPAddress(void)
	{
		return(m_GKIPAddress);
	}
	DWORD GetMCastTTL(void)
	{
		return m_dwMCastTTL;
	}
	BOOL GetRejectFlag(void)
	{
		return (m_fRejectReceived);
	}

	void SetIPAddress(char *szAddr)
	{
		if (lstrlenA(szAddr) <= IPADDR_SZ)
		{
			lstrcpyA(m_GKIPAddress, szAddr);
			m_GKSockAddr.sin_addr.s_addr = inet_addr(m_GKIPAddress);
		}
	}
    void SetSockAddr(PSOCKADDR_IN pAddr)
	{
	    if(pAddr && pAddr->sin_addr.S_un.S_addr != INADDR_ANY)
	    {
           m_GKSockAddr = *pAddr;
           lstrcpyA(m_GKIPAddress, inet_ntoa(m_GKSockAddr.sin_addr));
        }
	}
	void SetMCastTTL(DWORD dwttl)
	{
		m_dwMCastTTL = dwttl;
	}
	void SetRejectFlag(BOOL fReject)
	{
		m_fRejectReceived = fReject;
	}
	void Lock(void);
	void Unlock(void);
};

class CGatekeeperLock
{
private:
	CGatekeeper*	m_pGK;
public:
	CGatekeeperLock(CGatekeeper *pGK)
	{
		ASSERT(pGK);
		m_pGK = pGK;
		pGK->Lock();
	}
	~CGatekeeperLock()
	{
		m_pGK->Unlock();
	}
};

#endif // GATEKEEPER_H

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\gkerror.h ===
/***********************************************************************
 *																		*
 *	INTEL CORPORATION PROPRIETARY INFORMATION							*
 *																		*
 *	This software is supplied under the terms of a license			   	*
 *	agreement or non-disclosure agreement with Intel Corporation		*
 *	and may not be copied or disclosed except in accordance	   			*
 *	with the terms of that agreement.									*
 *																		*
 *	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
 *																		*
 *	$Archive:   S:\sturgeon\src\include\vcs\gkerror.h_v  $
 *
 *	$Revision:   1.18  $
 *	$Date:   16 Jan 1997 15:25:06  $
 *
 *	$Author:   BPOLING  $
 *
 *  $Log:   S:\sturgeon\src\include\vcs\gkerror.h_v  $
 * 
 *    Rev 1.18   16 Jan 1997 15:25:06   BPOLING
 * changed copyrights to 1997
 * 
 *    Rev 1.17   19 Dec 1996 18:46:44   BPOLING
 * added error code for no call signal address left in a user.
 * 
 *    Rev 1.16   18 Dec 1996 21:48:16   AKLEMENT
 * Fixed an error code for GWInfo.cpp
 * 
 *    Rev 1.14   18 Dec 1996 17:02:58   AKLEMENT
 * Added more GKInfo error codes.
 * 
 *    Rev 1.13   17 Dec 1996 19:20:02   AKLEMENT
 * Added GWInfo error codes.
 * 
 *    Rev 1.12   11 Dec 1996 13:32:44   AKLEMENT
 * Fixed the Prop Info header.
 * 
 *    Rev 1.11   10 Dec 1996 15:55:02   AKLEMENT
 * Added Resource Reading error define.
 * 
 *    Rev 1.10   10 Dec 1996 01:23:58   BPOLING
 * added a new error code for sending RRJ Undefined Reason.
 * 
 *    Rev 1.9   09 Dec 1996 14:13:34   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.8   04 Dec 1996 10:43:18   BPOLING
 * added a new message id to post to h/i.
 * 
 *    Rev 1.7   04 Dec 1996 10:14:46   BPOLING
 * added error code for invalid ip address
 * 
 *    Rev 1.6   21 Nov 1996 13:06:18   BPOLING
 * added error code for HI PostMessage decoding.
 * 
 *    Rev 1.5   15 Nov 1996 14:38:18   BPOLING
 * vcs log fix.
 *                                                                     * 
 ***********************************************************************/

#ifndef GK_ERROR_H
#define GK_ERROR_H

#define GK_NOERROR					0

// WIN32 system error 000

#define GK_MEMORY_ERROR				1
#define GK_REGCREATEKEY_FAILED 		2
#define GK_GUID_ERROR				3
#define GK_EXCEPTION				4
#define GK_RESOURCE_ERROR			5

// Service related 100

#define GK_INVALID_ARG 				101
#define GK_NOARGS					102
#define GK_STARTSERVICE_FAILED		103
#define GK_EXIT						104

// User Class Errors 200

#define GK_USER_NOTINITIALIZED		201
#define GK_NOUSERFOUND				202
#define GK_EMPTYSEQUENCE			203
#define GK_TRANSPORTNOTFOUND		204
#define GK_ALIASNOTFOUND			205
#define GK_NO_CALLSIG				206

// Engine related Errors 300

#define GK_XRSRESPONSE				301
#define GK_NORESPONSE				303
#define GK_INVALIDMESSAGE			304
#define GK_SENDRRJ_NEEDGRQ			305
#define GK_XRSMESSAGERECEIVED		306
#define GK_NSMMESSAGERECEIVED		307
#define GK_BADENDPOINTID			308
#define GK_SENDGRJ_TERMEX			309
#define GK_SENDRRJ_UNDEFINED		310

// Ras Map related errors 400

#define GK_NORASFOUND		  	401
#define GK_RASFOUND				402
#define GK_DUPLICATERAS			403
#define GK_RAS_NOTINITIALIZED	404
#define GK_RAS_NOT_UNIQUE		405

// Sockets related errors 500

#define GK_NOPORT					501
#define GK_NOHOSTNAME				502
#define GK_UNSUPPORTEDPROTOCOL		503
#define GK_PROTOCOLNOTFOUND			504
#define GK_INVALIDPDUTYPE			505
#define GK_SOCKETSERROR				506
#define GK_RESPONSE					507
#define GK_INVALID_IPADDRESS		508

// Bound Map related errors 600

#define GK_NOBOUNDFOUND				601
#define GK_BOUNDFOUND				602
#define GK_DUPLICATEBOUND			603
#define GK_BOUND_NOTINITIALIZED		604
#define GK_BOUNDLOCKED				607
#define GK_BOUNDNOTLOCKED			608

// CONF Map related errors 700

#define GK_NOCONFFOUND				701
#define GK_CONFFOUND				702
#define GK_DUPLICATECONF			703
#define GK_CONF_NOTINITIALIZED		704
#define GK_NOT_IN_CONF				706
#define GK_INVALID_REQUEST			707
#define GK_CONFDELETE				708
#define GK_CONFCREATEFAILED			709


// PDU Error return codes 800

#define GK_ARJ_REQUEST_DENIED		800
#define GK_ARJ_UNDEFINED_REASON		801

// Alias CMap Errors 900

#define GK_ALIAS_NOTINITIALIZED		900
#define GK_ALIAS_NOT_UNIQUE			901
#define GK_ALIASFOUND				902
#define GK_NOALIASFOUND				903

// Guid Map related errors 1000

#define GK_NOGUIDFOUND				1001
#define GK_GUIDFOUND				1002
#define GK_DUPLICATEGUID			1003
#define GK_GUIDINUSE				1004
#define GK_GUID_NOTINITIALIZED		1005

// Call Sig CMap Errors 1100

#define GK_CALLSIG_NOTINITIALIZED		1100
#define GK_CALLSIG_NOT_UNIQUE			1101
#define GK_CALLSIGFOUND					1102
#define GK_NOCALLSIGFOUND				1103

// Call Errors 1200

#define GK_NOCALLFOUND					1200
#define GK_DIDNOTPURGE					1201
#define GK_CALL_NOTINITIALIZED			1202
#define GK_CALL_CREATE					1203
#define GK_CALL_DELETE					1204
#define GK_CALL_CHANGE					1205
#define GK_CALL_TIMER					1206

// Bandwidth Manager Errors 1300

#define GK_INVALID_BANDWIDTH			1300
#define GK_EXTERNAL_EXCEEDS_INTERNAL	1301
#define GK_NO_AVAILABLE_BANDWIDTH		1302
#define GK_USEDBW_WENT_NEGATIVE			1303
#define GK_LESS_AVAILABLE_BANDWIDTH		1304

// Logger Errors 1400

#define GK_LOGGING_IS_OFF				1400
#define GK_FILE_NOT_OPEN				1401
#define GK_COULD_NOT_OPEN_FILE			1402
#define GK_FILE_ALREADY_OPEN			1403
#define GK_NAME_USED_FOR_LOG			1404
#define GK_COULD_NOT_MAKE_DIR			1405

// GWInfo Errors 1500
#define GK_WRONG_PDU					1500
#define GK_NOT_GATEWAY					1501
#define GK_PROTOCOL_NOT_PRESENT			1502
#define GK_GW_NOT_FOUND					1503
#define GK_GW_NOT_REQUIRED				1504
#define GK_PREFIX_RESERVED				1505
#define GK_NO_DEST_INFO_SPECIFIED		1506

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\gki.cpp ===
/************************************************************************
*                                                                                                                                               *
*       INTEL CORPORATION PROPRIETARY INFORMATION                                                       *
*                                                                                                                                               *
*       This software is supplied under the terms of a license                          *
*       agreement or non-disclosure agreement with Intel Corporation            *
*       and may not be copied or disclosed except in accordance                         *
*       with the terms of that agreement.                                                                       *
*                                                                                                                                               *
*       Copyright (C) 1997 Intel Corp.  All Rights Reserved                                     *
*                                                                                                                                               *
*       $Archive:   S:\sturgeon\src\gki\vcs\gki.cpv  $
*                                                                                                                                               *
*       $Revision:   1.14  $
*       $Date:   28 Feb 1997 15:46:46  $
*                                                                                                                                               *
*       $Author:   CHULME  $
*                                                                                                                                               *
*   $Log:   S:\sturgeon\src\gki\vcs\gki.cpv  $
// 
//    Rev 1.14   28 Feb 1997 15:46:46   CHULME
// In Cleanup - check pReg still valid before waiting for 2nd thread to exit
// 
//    Rev 1.13   14 Feb 1997 16:45:40   CHULME
// Wait for all threads to exit prior to returning from synchronous Cleanup ca
// 
//    Rev 1.12   12 Feb 1997 01:12:38   CHULME
// Redid thread synchronization to use Gatekeeper.Lock
// 
//    Rev 1.11   11 Feb 1997 15:35:32   CHULME
// Added GKI_CleanupRequest function to offload DLL_PROCESS_DETACH
// 
//    Rev 1.10   05 Feb 1997 19:28:18   CHULME
// Remove deletion code from PROCESS_DETACH
// 
//    Rev 1.9   05 Feb 1997 16:53:10   CHULME
// 
//    Rev 1.8   05 Feb 1997 15:25:12   CHULME
// Don't wait for retry thread to exit
// 
//    Rev 1.7   05 Feb 1997 13:50:24   CHULME
// On PROCESS_DETACH - close socket and let retry thread delete pReg
// 
//    Rev 1.6   17 Jan 1997 09:02:00   CHULME
// Changed reg.h to gkreg.h to avoid name conflict with inc directory
// 
//    Rev 1.5   13 Jan 1997 17:01:18   CHULME
// Moved error debug message to error condition
// 
//    Rev 1.4   13 Jan 1997 16:31:20   CHULME
// Changed debug string to 512 - Description can be 256 chars
// 
//    Rev 1.3   13 Jan 1997 14:25:54   EHOWARDX
// Increased size of szGKDebug debug string buffer from 80 to 128 bytes.
// 
//    Rev 1.2   10 Jan 1997 16:14:30   CHULME
// Removed MFC dependency
// 
//    Rev 1.1   22 Nov 1996 14:57:10   CHULME
// Changed the default spider flags, to quit logging raw PDU and XRS
*************************************************************************/

// gki.cpp : Defines the initialization routines for the DLL.
//
#include "precomp.h"

#include <winsock.h>
#include "dgkiexp.h"
#include "dspider.h"
#include "dgkilit.h"
#include "DGKIPROT.H"
#include "GATEKPR.H"
#include "gksocket.h"
#include "GKREG.H"
#include "h225asn.h"
#include "coder.hpp"

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
	// INTEROP
	#include "interop.h"
	#include "rasplog.h"
	LPInteropLogger         RasLogger;
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DLL_EXPORT DWORD        dwGKIDLLFlags = 0xff3f;
DLL_EXPORT BOOL         fGKIEcho = FALSE;
DLL_EXPORT BOOL         fGKIDontSend = FALSE;

char                                            *pEchoBuff = 0;
int                                                     nEchoLen;
CRegistration   *g_pReg = NULL;
Coder 			*g_pCoder = NULL;

/////////////////////////////////////////////////////////////////////////////
// The one and only CGatekeeper object

CGatekeeper *g_pGatekeeper = NULL;


/////////////////////////////////////////////////////////////////////////////
// DLLMain


extern "C" HRESULT DLL_EXPORT
GKI_Initialize(void)
{
	HRESULT hr = GKI_OK;
	int nRet;
	WSADATA wsaData;
	
#ifdef _DEBUG
	char                    szGKDebug[512];
#endif

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
	//INTEROP
	RasLogger = InteropLoad(RASLOG_PROTOCOL);       // found in rasplog.h
#endif

	nRet = WSAStartup(MAKEWORD(WSVER_MAJOR, WSVER_MINOR), &wsaData);
	if (nRet != 0)
	{
		SpiderWSErrDecode(nRet);
		hr = GKI_NOT_INITIALIZED;
		goto ERROR_EXIT;
	}

	if ((HIBYTE(wsaData.wVersion) != WSVER_MINOR) || 
			(LOBYTE(wsaData.wVersion) != WSVER_MAJOR))
	{
		hr = GKI_NOT_INITIALIZED;
		goto WSA_CLEANUP_EXIT;
	}
	g_pGatekeeper = new CGatekeeper;
	
	if(!g_pGatekeeper)
	{
		hr = GKI_NO_MEMORY;
		goto WSA_CLEANUP_EXIT;
	}
	g_pCoder = new Coder; 
	if(!g_pCoder)
	{
		hr = GKI_NO_MEMORY;
		goto WSA_CLEANUP_EXIT;
	}
	// initialize the oss library
	nRet = g_pCoder->InitCoder();
	if (nRet)
	{
		hr = GKI_NOT_INITIALIZED;
		goto WSA_CLEANUP_EXIT;
	}
	
	// Get the gatekeeper information from the registry
	g_pGatekeeper->Read();
	
	return hr;
	
WSA_CLEANUP_EXIT:
	nRet = WSACleanup();
	if (nRet != 0)
	{
		SpiderWSErrDecode(-1);
	}
		
	// fall out to ERROR_EXIT
ERROR_EXIT:
	if(g_pGatekeeper)
		delete g_pGatekeeper;

	if(g_pCoder)
		delete g_pCoder;
		
	g_pGatekeeper = NULL;	
	g_pCoder = NULL;
	return hr;
}

extern "C" HRESULT DLL_EXPORT
GKI_CleanupRequest(void)
{
	// ABSTRACT:  This function is exported.  It is called by the client application
	//            as a precursor to unloading the DLL.  This function is responsible
	//            for all cleanup - This allows us to basically do nothing in the
	//            DllMain DLL_PROCESS_DETACH, which doesn't appear to work as intended.
	// AUTHOR:    Colin Hulme

	int						nRet;
#ifdef _DEBUG
	char                    szGKDebug[512];
#endif

	SPIDER_TRACE(SP_FUNC, "GKI_CleanupRequest()\n", 0);
	SPIDER_TRACE(SP_GKI, "GKI_CleanupRequest()\n", 0);
	if(g_pGatekeeper)	// if initialized
	{
		ASSERT(g_pCoder);	// g_pGatekeeper and g_pCoder come and go as a unit
		
		g_pGatekeeper->Lock();
		if (g_pReg != 0)
		{
			g_pReg->m_pSocket->Close();	// Close socket will terminate the other threads

			g_pGatekeeper->Unlock();
			WaitForSingleObject(g_pReg->GetRcvThread(), TIMEOUT_THREAD);
		#ifdef BROADCAST_DISCOVERY		
			if (g_pReg)
				WaitForSingleObject(g_pReg->GetDiscThread(), TIMEOUT_THREAD);
		#endif // #ifdef BROADCAST_DISCOVERY		
			g_pGatekeeper->Lock();
			if (g_pReg != 0)
			{
				SPIDER_TRACE(SP_NEWDEL, "del g_pReg = %X\n", g_pReg);
				delete g_pReg;
				g_pReg = 0;
			}
		}

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
		//INTEROP
		InteropUnload((LPInteropLogger)RasLogger);
#endif

		SPIDER_TRACE(SP_WSOCK, "WSACleanup()\n", 0);
		nRet = WSACleanup();
		if (nRet != 0)
		{
			SpiderWSErrDecode(-1);
		}

		g_pGatekeeper->Unlock();

		delete g_pGatekeeper;
		delete g_pCoder;		// see ASSERT abovr
		g_pGatekeeper = NULL;	
		g_pCoder = NULL;
	}
	
//	GK_TermModule();

	return (GKI_OK);
}

extern "C" VOID DLL_EXPORT
GKI_SetGKAddress(PSOCKADDR_IN pAddr)
{
    if (!pAddr)
    {
        return;
    }
    g_pGatekeeper->SetSockAddr(pAddr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\fsminit.c ===
/***********************************************************************
 *                                                                     *
 * Filename: fsminit.c                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   FSMINIT.C  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:34:24  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/FSMINIT.C_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:34:38   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   29 May 1996 15:20:16   EHOWARDX
 * Change to use HRESULT.
 * 
 *    Rev 1.0   09 May 1996 21:06:16   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.11.1.3   09 May 1996 19:48:42   EHOWARDX
 * Change TimerExpiryF function arguements.
 * 
 *    Rev 1.11.1.2   15 Apr 1996 10:46:12   EHOWARDX
 * Update.
 *
 *    Rev 1.11.1.1   10 Apr 1996 21:15:38   EHOWARDX
 * Check-in for safety in middle of re-design.
 *
 *    Rev 1.11.1.0   05 Apr 1996 12:32:40   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"



/*
 *  NAME
 *      Fsm_init - allocate and initialize memory for FSM instance
 *
 *
 *  PARAMETERS
 *      INPUT   dwInst      current instance
 *
 *  RETURN VALUE
 *      H245_ERROR_OK           function succeeded
 *      H245_ERROR_ALREADY_INIT FSM instance exists for specified dwInst
 */

HRESULT
Fsm_init(struct InstanceStruct *pInstance)
{
    pInstance->StateMachine.sv_STATUS = INDETERMINATE;
    return H245_ERROR_OK;
}



/*
 *  NAME
 *      Fsm_shutdown - cleanup FSM instance and deallocate instance memory
 *
 *
 *  PARAMETERS
 *      INPUT   dwInst      current instance
 *
 *  RETURN VALUE
 *      H245_ERROR_OK           function succeeded
 *      H245_ERROR_INVALID_INST on FSM instance exists for specified dwInst
 */


HRESULT
Fsm_shutdown(struct InstanceStruct *pInstance)
{
    register int            i;

    for (i = 0; i < NUM_ENTITYS; ++i)
    {
        while (pInstance->StateMachine.Object_tbl[i])
        {
            H245TRACE(pInstance->dwInst, 2, "Fsm_shutdown: deallocating state entity %d", i);
            ObjectDestroy(pInstance->StateMachine.Object_tbl[i]);
        }
    }
    return H245_ERROR_OK;
} // Fsm_shutdown()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\fsmapi.c ===
/***********************************************************************
 *                                                                     *
 * Filename: fsmapi.c                                                  *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   FSMAPI.C  $
 * $Revision:   1.12  $
 * $Modtime:   09 Dec 1996 13:34:24  $
 * $Log L:\mphone\h245\h245env\comm\h245_3\h245_fsm\vcs\src\fsmapi.c_v $
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "h245deb.x"



extern char *EntityName[];



/*
 * This table maps FSM stateless events into H.245 API events
 */
static WORD StatelessTable[NUM_EVENTS - NUM_STATE_EVENTS] =
{
  H245_IND_NONSTANDARD_REQUEST,     // NonStandardRequestPDU
  H245_IND_NONSTANDARD_RESPONSE,    // NonStandardResponsePDU
  H245_IND_NONSTANDARD_COMMAND,     // NonStandardCommandPDU
  H245_IND_NONSTANDARD,             // NonStandardIndicationPDU
  H245_IND_MISC_COMMAND,            // MiscellaneousCommandPDU
  H245_IND_MISC,                    // MiscellaneousIndicationPDU
  H245_IND_COMM_MODE_REQUEST,       // CommunicationModeRequestPDU
  H245_IND_COMM_MODE_RESPONSE,      // CommunicationModeResponsePDU
  H245_IND_COMM_MODE_COMMAND,       // CommunicationModeCommandPDU
  H245_IND_CONFERENCE_REQUEST,      // ConferenceRequestPDU
  H245_IND_CONFERENCE_RESPONSE,     // ConferenceResponsePDU
  H245_IND_CONFERENCE_COMMAND,      // ConferenceCommandPDU
  H245_IND_CONFERENCE,              // ConferenceIndicationPDU
  H245_IND_SEND_TERMCAP,            // SendTerminalCapabilitySetPDU
  H245_IND_ENCRYPTION,              // EncryptionCommandPDU
  H245_IND_FLOW_CONTROL,            // FlowControlCommandPDU
  H245_IND_ENDSESSION,              // EndSessionCommandPDU
  H245_IND_FUNCTION_NOT_UNDERSTOOD, // FunctionNotUnderstoodIndicationPDU
  H245_IND_JITTER,                  // JitterIndicationPDU
  H245_IND_H223_SKEW,               // H223SkewIndicationPDU
  H245_IND_NEW_ATM_VC,              // NewATMVCIndicationPDU
  H245_IND_USERINPUT,               // UserInputIndicationPDU
  H245_IND_H2250_MAX_SKEW,          // H2250MaximumSkewIndicationPDU
  H245_IND_MC_LOCATION,             // MCLocationIndicationPDU
  H245_IND_VENDOR_ID,               // VendorIdentificationIndicationPDU
  H245_IND_FUNCTION_NOT_SUPPORTED,  // FunctionNotSupportedIndicationPDU
};



/*
 * Configurable counter values
 */

unsigned int    uN100 = 10;              // Master Slave Determination



/*
 * Configurable timer values
 */

unsigned int    uT101 = 30000;          // Capability Exchange
unsigned int    uT102 = 30000;          // Maintenance Loop
unsigned int    uT103 = 30000;          // Logical Channel Signalling
unsigned int    uT104 = 30000;          // H.223 Multiplex Table
unsigned int    uT105 = 30000;          // Round Trip Delay
unsigned int    uT106 = 30000;          // Master Slave Determination
unsigned int    uT107 = 30000;          // Request Multiplex Entry
unsigned int    uT108 = 30000;          // Send Logical Channel
unsigned int    uT109 = 30000;          // Mode Request



/*
 *  NAME
 *      ObjectCreate - create an State Entity object
 *
 *
 *  PARAMETERS
 *      INPUT   pInst       Pointer to FSM instance data
 *      INPUT   Entity      State Entity represented by object, e.g. LCSE_OUT
 *      INPUT   Key         Lookup key for distinguish multiple instances of SE
 *      INPUT   dwTransId   Transaction identifier to be sent up to client
 *
 *  RETURN VALUE
 *      pObject     Function succeeded
 *      NULL        Memory allocation failed
 */

Object_t *
ObjectCreate(struct InstanceStruct *pInstance, Entity_t Entity, Key_t Key, DWORD_PTR dwTransId)
{
    register Object_t * pObject;

#if defined(_DEBUG)
    H245TRACE(pInstance->dwInst, 4, "ObjectCreate: Entity=%s(%d) Key=%d dwTransID=0x%p",
              EntityName[Entity], Entity, Key, dwTransId);
#else
    H245TRACE(pInstance->dwInst, 4, "ObjectCreate: Entity=%d Key=%d dwTransID=0x%p",
              Entity, Key, dwTransId);
#endif

    pObject = (Object_t *)MemAlloc(sizeof(*pObject));
    if (pObject == NULL)
    {
        H245TRACE(pInstance->dwInst, 1, "ObjectCreate: FSM Object memory allocation failed");
        return NULL;
    }
    memset(pObject, 0, sizeof(*pObject));

    /* copy primitive variables to my object */
    pObject->pInstance   = pInstance;
    pObject->dwInst      = pInstance->dwInst;
    pObject->dwTransId   = dwTransId;
    pObject->Key         = Key;
    pObject->Entity      = Entity;

    pObject->pNext       = pInstance->StateMachine.Object_tbl[Entity];
    pInstance->StateMachine.Object_tbl[Entity] = pObject;

    return pObject;
} // ObjectCreate()



/*
 *  NAME
 *      ObjectDestroy - deallocate an object created by ObjectCreate()
 *
 *
 *  PARAMETERS
 *  INPUT   pInst       pointer to FSM instance data
 *  INPUT   id          index into the object table
 *
 *  RETURN VALUE
 *      FALSE           object deallocated
 *      TRUE            object not found
 */

int
ObjectDestroy(Object_t *pObject)
{
    struct InstanceStruct * pInstance;
    Object_t *              pSearch;
    Object_t *              pPrev;

    ASSERT(pObject != NULL);
    ASSERT(pObject->uNestLevel == 0);
    ASSERT(pObject->pInstance != NULL);
    pInstance = pObject->pInstance;

#if defined(_DEBUG)
    H245TRACE(pInstance->dwInst, 4, "ObjectDestroy: Entity=%s(%d) Key=%d State=%d",
              EntityName[pObject->Entity], pObject->Entity, pObject->Key, pObject->State);
#else
    H245TRACE(pInstance->dwInst, 4, "ObjectDestroy: Entity=%d Key=%d State=%d",
              pObject->Entity, pObject->Key, pObject->State);
#endif

    if (pObject->dwTimerId)
    {
        H245TRACE(pObject->dwInst, 4, "ObjectDestroy: stoping timer");
        FsmStopTimer(pObject);
    }

    if (pInstance->StateMachine.Object_tbl[pObject->Entity] == NULL)
    {
        H245TRACE(pInstance->dwInst, 1, "ObjectDestroy: no State Entity of specified type found");
        return TRUE;
    }

    if (pInstance->StateMachine.Object_tbl[pObject->Entity] == pObject)
    {
        pInstance->StateMachine.Object_tbl[pObject->Entity] = pObject->pNext;
        MemFree(pObject);
        return FALSE;
    }

    pPrev = pInstance->StateMachine.Object_tbl[pObject->Entity];
    pSearch = pPrev->pNext;
    while (pSearch != NULL)
    {
        if (pSearch == pObject)
        {
            pPrev->pNext = pSearch->pNext;
            MemFree(pObject);
            return FALSE;
        }
        pPrev = pSearch;
        pSearch = pSearch->pNext;
    }

    H245TRACE(pInstance->dwInst, 1, "ObjectDestroy: State Entity not found");
    return TRUE;
} // ObjectDestroy()



/*
 *  NAME
 *      ObjectFind - given parsed information of a PDU, it searches the object table for
 *                         an object with a matching id, type and category
 *
 *
 *  PARAMETERS
 *  INPUT    pInst
 *  INPUT    Category       category of a given PDU
 *  INPUT    Type           type of the PDU
 *  INPUT    pdu_id         unique id shared by PDU and object (usually channel number or sequence number)
 *
 *  RETURN VALUE
 *      pObject   object found
 *      NULL      object not found
 */

Object_t *
ObjectFind(struct InstanceStruct *pInstance, Entity_t Entity, Key_t Key)
{
    register Object_t * pObject;

    ASSERT(Entity < STATELESS);
    pObject = pInstance->StateMachine.Object_tbl[Entity];
    while (pObject != NULL)
    {
        if (pObject->Key == Key)
        {
#if defined(_DEBUG)
            H245TRACE(pInstance->dwInst, 4, "ObjectFind(%s, %d) object found",
                      EntityName[Entity], Key);
#else
            H245TRACE(pInstance->dwInst, 4, "ObjectFind(%d, %d) object found",
                      Entity, Key);
#endif
            return pObject;
        }
        pObject = pObject->pNext;
    }

#if defined(_DEBUG)
    H245TRACE(pInstance->dwInst, 4, "ObjectFind(%s, %d) object not found",
              EntityName[Entity], Key);
#else
    H245TRACE(pInstance->dwInst, 4, "ObjectFind(%d, %d) object not found",
              Entity, Key);
#endif
    return NULL;
} // ObjectFind()



/*
 *  NAME
 *      SendFunctionNotUnderstood - builds and sends Function Not Supported PDU
 *
 *
 *  PARAMETERS
 *      INPUT   dwInst   Current H.245 instance
 *      INPUT   pPdu     Not supported PDU
 *
 *  RETURN VALUE
 *      H245_ERROR_OK
 */


HRESULT
SendFunctionNotUnderstood(struct InstanceStruct *pInstance, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    pOut = MemAlloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        return H245_ERROR_NOMEM;
    }

    switch (pPdu->choice)
    {
    case MltmdSystmCntrlMssg_rqst_chosen:
        pOut->u.indication.u.functionNotUnderstood.choice = FnctnNtUndrstd_request_chosen;
        pOut->u.indication.u.functionNotUnderstood.u.FnctnNtUndrstd_request =
          pPdu->u.MltmdSystmCntrlMssg_rqst;
        break;

    case MSCMg_rspns_chosen:
        pOut->u.indication.u.functionNotUnderstood.choice = FnctnNtUndrstd_response_chosen;
        pOut->u.indication.u.functionNotUnderstood.u.FnctnNtUndrstd_response =
          pPdu->u.MSCMg_rspns;
        break;

    case MSCMg_cmmnd_chosen:
        pOut->u.indication.u.functionNotUnderstood.choice = FnctnNtUndrstd_command_chosen;
        pOut->u.indication.u.functionNotUnderstood.u.FnctnNtUndrstd_command =
          pPdu->u.MSCMg_cmmnd;
        break;

    default:
        // Can't reply to unsupported indication...
        MemFree(pOut);
        return H245_ERROR_OK;
    } // switch (Type)

    pOut->choice = indication_chosen;
    pOut->u.indication.choice = functionNotUnderstood_chosen;
    lError = sendPDU(pInstance, pOut);
    MemFree(pOut);
    return lError;
} // SendFunctionNotUnderstood()



/*
 *  NAME
 *      FsmOutgoing - process outbound PDU
 *
 *
 *  PARAMETERS
 *      INPUT   pInst       Pointer to FSM instance structure
 *      INPUT   pPdu        Pointer to PDU to send
 *      INPUT   dwTransId   Transaction identifier to use for response
 *
 *  RETURN VALUE
 *      Error codes defined in h245com.h
 */

HRESULT
FsmOutgoing(struct InstanceStruct *pInstance, PDU_t *pPdu, DWORD_PTR dwTransId)
{
    HRESULT             lError;
    Entity_t            Entity;
    Event_t             Event;
    Key_t               Key;
    int                 bCreate;
    Object_t *          pObject;

    ASSERT(pInstance != NULL);
    ASSERT(pPdu != NULL);
    H245TRACE(pInstance->dwInst, 4, "FsmOutgoing");

#if defined(_DEBUG)
    if (check_pdu(pInstance, pPdu))
      return H245_ERROR_ASN1;
#endif // (DEBUG)

    lError = PduParseOutgoing(pInstance, pPdu, &Entity, &Event, &Key, &bCreate);
    if (lError != H245_ERROR_OK)
    {
        H245TRACE(pInstance->dwInst, 1,
          "FsmOutgoing: PDU not recognized; Error=%d", lError);
        return lError;
    }

    ASSERT(Entity < NUM_ENTITYS);

    if (Entity == STATELESS)
    {
        H245TRACE(pInstance->dwInst, 4, "FsmOutgoing: Sending stateless PDU");
        return sendPDU(pInstance, pPdu);
    }

    ASSERT(Event < NUM_STATE_EVENTS);

    pObject = ObjectFind(pInstance, Entity, Key);
    if (pObject == NULL)
    {
        if (bCreate == FALSE)
        {
#if defined(_DEBUG)
            H245TRACE(pInstance->dwInst, 1,
                      "FsmOutgoing: State Entity %s(%d) not found; Key=%d",
                      EntityName[Entity], Entity, Key);
#else
            H245TRACE(pInstance->dwInst, 1,
                      "FsmOutgoing: State Entity %d not found; Key=%d",
                      Entity, Key);
#endif
            return H245_ERROR_PARAM;
        }
        pObject = ObjectCreate(pInstance, Entity, Key, dwTransId);
        if (pObject == NULL)
        {
            H245TRACE(pInstance->dwInst, 1, "FsmOutgoing: State Entity memory allocation failed");
            return H245_ERROR_NOMEM;
        }
    }
    else
    {
        pObject->dwTransId = dwTransId;
    }

    return StateMachine(pObject, pPdu, Event);
} // FsmOutgoing()



/*
 *  NAME
 *      FsmIncoming - process inbound PDU
 *
 *
 *  PARAMETERS
 *      INPUT   dwInst      current H.245 instance
 *      INPUT   pPdu        pointer to a PDU structure
 *
 *  RETURN VALUE
 *      error codes defined in h245com.h (not checked)
 */

HRESULT
FsmIncoming(struct InstanceStruct *pInstance, PDU_t *pPdu)
{
    HRESULT             lError;
    Entity_t            Entity;
    Event_t             Event;
    Key_t               Key;
    int                 bCreate;
    Object_t *          pObject;
    Object_t *          pObject1;

    ASSERT(pInstance != NULL);
    ASSERT(pPdu != NULL);
    H245TRACE(pInstance->dwInst, 4, "FsmIncoming");

    lError = PduParseIncoming(pInstance, pPdu, &Entity, &Event, &Key, &bCreate);
    if (lError != H245_ERROR_OK)
    {
        H245TRACE(pInstance->dwInst, 1,
          "FsmIncoming: Received PDU not recognized", lError);
        SendFunctionNotUnderstood(pInstance, pPdu);
        return lError;
    }

    ASSERT(Entity < NUM_ENTITYS);

    if (Entity == STATELESS)
    {
        H245TRACE(pInstance->dwInst, 4, "FsmIncoming: Received stateless PDU");
        return H245FsmIndication(pPdu, (DWORD)StatelessTable[Event - NUM_STATE_EVENTS], pInstance, 0, H245_ERROR_OK);
    }

    ASSERT(Event < NUM_STATE_EVENTS);

    if (Event == MaintenanceLoopOffCommandPDU)
    {
        // Special case MaintenanceLoopOff applies to ALL loops
        ASSERT(Entity == MLSE_IN);
        pObject = pInstance->StateMachine.Object_tbl[Entity];
        if (pObject == NULL)
        {
            return H245_ERROR_OK;
        }
        lError = StateMachine(pObject, pPdu, Event);
        pObject = pInstance->StateMachine.Object_tbl[Entity];
        while (pObject)
        {
            if (pObject->uNestLevel == 0)
            {
                pObject1 = pObject;
                pObject  = pObject->pNext;
                ObjectDestroy(pObject1);
            }
            else
            {
                pObject->State = 0;
                pObject = pObject->pNext;
            }
        }
        return lError;
    } // if

    pObject = ObjectFind(pInstance, Entity, Key);
    if (pObject == NULL)

    {
        if (bCreate == FALSE)
        {
#if defined(_DEBUG)
            H245TRACE(pInstance->dwInst, 1,
                      "FsmIncoming: State Entity %s(%d) not found; Key=%d",
                      EntityName[Entity], Entity, Key);
#else
            H245TRACE(pInstance->dwInst, 1,
                      "FsmIncoming: State Entity %d not found; Key=%d",
                      Entity, Key);
#endif
            return H245_ERROR_PARAM;
        }
        pObject = ObjectCreate(pInstance, Entity, Key, 0);
        if (pObject == NULL)
        {
            H245TRACE(pInstance->dwInst, 1, "FsmIncoming: State Entity memory allocation failed");
            return H245_ERROR_NOMEM;
        }
    }

    return StateMachine(pObject, pPdu, Event);
} // FsmIncoming()


// CAVEAT: Need to save dwInst since StateMachine() might deallocate pObject!
HRESULT
FsmTimerEvent(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, Object_t *pObject, Event_t Event)
{
    ASSERT(pInstance != NULL);
    ASSERT(pObject   != NULL);
    ASSERT(pObject->pInstance == pInstance);
    ASSERT(pObject->dwTimerId == dwTimerId);
    H245TRACE(pInstance->dwInst, 4, "FsmTimerEvent");
    pObject->dwTimerId = 0;
    return StateMachine(pObject, NULL, Event);
} // FsmTimerEvent()

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\fsm.c ===
/***********************************************************************
 *                                                                     *
 * Filename: fsm.c                                                     *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   FSM.C  $
 * $Revision:   1.5  $
 * $Modtime:   09 Dec 1996 13:34:24  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/FSM.C_v  $
 * 
 *    Rev 1.5   09 Dec 1996 13:34:28   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.4   02 Jul 1996 00:09:24   EHOWARDX
 * 
 * Added trace of state after state machine function called.
 * 
 *    Rev 1.3   30 May 1996 23:39:04   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.2   29 May 1996 15:20:12   EHOWARDX
 * Change to use HRESULT.
 * 
 *    Rev 1.1   28 May 1996 14:25:48   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.0   09 May 1996 21:06:12   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.16.1.4   09 May 1996 19:48:34   EHOWARDX
 * Change TimerExpiryF function arguements.
 * 
 *    Rev 1.16.1.3   25 Apr 1996 17:00:18   EHOWARDX
 * Minor fixes.
 * 
 *    Rev 1.16.1.2   15 Apr 1996 10:45:38   EHOWARDX
 * Update.
 *
 *    Rev 1.16.1.1   10 Apr 1996 21:16:06   EHOWARDX
 * Check-in for safety in middle of re-design.
 *
 *    Rev 1.16.1.0   05 Apr 1996 12:21:16   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "openu.h"
#include "openb.h"
#include "rqstcls.h"
#include "termcap.h"
#include "muxentry.h"
#include "rmese.h"
#include "mrse.h"
#include "mlse.h"
#include "mstrslv.h"
#include "rtdse.h"



#if defined(_DEBUG)

// Signalling Entity definitions
char *               EntityName[NUM_ENTITYS] =
{
// Per-channel Signalling Entities
       "LCSE_OUT",  //         0    Uni-directional Logical Channel signalling Signalling Entity - Outbound
       "LCSE_IN",   //         1    Uni-directional Logical Channel signalling Signalling Entity - Inbound
       "BLCSE_OUT", //         2    Bi-directional  Logical Channel signalling Signalling Entity - Outbound
       "BLCSE_IN",  //         3    Bi-directional  Logical Channel signalling Signalling Entity - Inbound
       "CLCSE_OUT", //         4    Close           Logical Channel signalling Signalling Entity - Outbound
       "CLCSE_IN",  //         5    Close           Logical Channel signalling Signalling Entity - Inbound

// Per H.245 Instance Signalling Entities
       "CESE_OUT",  //         6    Capability Exchange Signalling Entity - Out-going
       "CESE_IN",   //         7    Capability Exchange Signalling Entity - In-coming
       "MTSE_OUT",  //         8    Multiplex Table Signalling Entity - Out-going
       "MTSE_IN",   //         9    Multiplex Table Signalling Entity - In-coming
       "RMESE_OUT", //        10    Request Multiplex Entry Signalling Entity - Out-going
       "RMESE_IN",  //        11    Request Multiplex Entry Signalling Entity - In-coming
       "MRSE_OUT",  //        12    Mode Request Signalling Entity - Out-going
       "MRSE_IN",   //        13    Mode Request Signalling Entity - In-coming
       "MLSE_OUT",  //        14    Maintenance Loop Signalling Entity - Out-going
       "MLSE_IN",   //        15    Maintenance Loop Signalling Entity - In-coming
       "MSDSE",     //        16    Master Slave Determination Signalling Entity
       "RTDSE",     //        17    Round Trip Delay Signalling Entity
       "STATELESS", //        18    No state machine associated with PDU
};




// Event definitions
char *               EventName[NUM_EVENTS] =
{
// Out-going Uni-directional Logical Channel (LCSE_OUT) events
       "ReqUEstablish",                 //         0
       "OpenUChAckPDU",                 //         1
       "OpenUChRejectPDU",              //         2
       "CloseUChAckPDU",                //         3
       "ReqURelease",                   //         4
       "T103Expiry",                    //         5

// In-coming Uni-directional Logical Channel (LCSE_IN) events
       "OpenUChPDU",                    //         6
       "CloseUChPDU",                   //         7
       "ResponseUEstablish",            //         8
       "EstablishUReject",              //         9

// Out-going Bi-directional Logical Channel (BLCSE_OUT) events
       "ReqBEstablish",                 //        10
       "OpenBChAckPDU",                 //        11
       "OpenBChRejectPDU",              //        12
       "CloseBChAckPDU",                //        13
       "ReqClsBLCSE",                   //        14
       "RspConfirmBLCSE",               //        15
       "T103OutExpiry",                 //        16

// In-coming Bi-directional Logical Channel (BLCSE_IN) events
       "OpenBChPDU",                    //        17
       "CloseBChPDU",                   //        18
       "ResponseBEstablish",            //        19
       "OpenBChConfirmPDU",             //        20
       "OpenRejectBLCSE",               //        21
       "T103InExpiry",                  //        22

// Out-going Request Close Logical Channel (CLCSE_OUT) events
       "ReqClose",                      //        23
       "ReqChCloseAckPDU",              //        24
       "ReqChCloseRejectPDU",           //        25
       "T108Expiry",                    //        26

// In-coming Request Close Logical Channel (CLCSE_IN) events
       "ReqChClosePDU",                 //        27
       "ReqChCloseReleasePDU",          //        28
       "CLCSE_CLOSE_response",          //        29
       "CLCSE_REJECT_request",          //        30

// Out-going Terminal Capablity Exchange (CESE_OUT) events
       "TransferCapRequest",            //        31
       "TermCapSetAckPDU",              //        32
       "TermCapSetRejectPDU",           //        33
       "T101Expiry",                    //        34

// In-coming Terminal Capablity Exchange (CESE_IN) events
       "TermCapSetPDU",                 //        35
       "TermCapSetReleasePDU",          //        36
       "CESE_TRANSFER_response",        //        37
       "CESE_REJECT_request",           //        38

// Out-going Multiplex Table (MTSE_OUT) events
       "MTSE_TRANSFER_request",         //        39
       "MultiplexEntrySendAckPDU",      //        40
       "MultiplexEntrySendRejectPDU",   //        41
       "T104Expiry",                    //        42

// In-coming Multiplex Table (MTSE_IN) events
       "MultiplexEntrySendPDU",         //        43
       "MultiplexEntrySendReleasePDU",  //        44
       "MTSE_TRANSFER_response",        //        45
       "MTSE_REJECT_request",           //        46

// Out-going Request Multiplex Entry (RMESE_OUT) events
       "RMESE_SEND_request",            //        47
       "RequestMultiplexEntryAckPDU",   //        48
       "RequestMultiplexEntryRejectPDU",//        49
       "T107Expiry",                    //        50

// In-coming Request Multiplex Entry (RMESE_IN) events
       "RequestMultiplexEntryPDU",      //        51
       "RequestMultiplexEntryReleasePDU",//       52
       "RMESE_SEND_response",           //        53
       "RMESE_REJECT_request",          //        54

// Out-going Mode Request (MRSE_OUT) events
       "MRSE_TRANSFER_request",         //        55
       "RequestModeAckPDU",             //        56
       "RequestModeRejectPDU",          //        57
       "T109Expiry",                    //        58

// In-coming Mode Request (MRSE_IN) events
       "RequestModePDU",                //        59
       "RequestModeReleasePDU",         //        60
       "MRSE_TRANSFER_response",        //        61
       "MRSE_REJECT_request",           //        62

// Out-going Maintenance Loop (MLSE_OUT) events
       "MLSE_LOOP_request",             //        63
       "MLSE_OUT_RELEASE_request",      //        64
       "MaintenanceLoopAckPDU",         //        65
       "MaintenanceLoopRejectPDU",      //        66
       "T102Expiry",                    //        67

// In-coming Maintenance Loop (MLSE_IN) events
       "MaintenanceLoopRequestPDU",     //        68
       "MaintenanceLoopOffCommandPDU",  //        69
       "MLSE_LOOP_response",            //        70
       "MLSE_IN_RELEASE_request",       //        71

// Master Slave Determination (MSDSE) events
       "MSDetReq",                      //        72
       "MSDetPDU",                      //        73
       "MSDetAckPDU",                   //        74
       "MSDetRejectPDU",                //        75
       "MSDetReleasePDU",               //        76
       "T106Expiry",                    //        77

// Round Trip Delay Delay (RTDSE) events
       "RTDSE_TRANSFER_request",        //        78
       "RoundTripDelayRequestPDU",      //        79
       "RoundTripDelayResponsePDU",     //        80
       "T105Expiry",                    //        81



// Events with no associated state entity
       "NonStandardRequestPDU",         //        82
       "NonStandardResponsePDU",        //        83
       "NonStandardCommandPDU",         //        84
       "NonStandardIndicationPDU",      //        85
       "MiscellaneousRequestPDU",       //        86
       "MiscellaneousResponsePDU",      //        87
       "MiscellaneousCommandPDU",       //        88
       "MiscellaneousIndicationPDU",    //        89
       "CommunicationModeRequestPDU",   //        90
       "CommunicationModeResponsePDU",  //        91
       "CommunicationModeCommandPDU",   //        92
       "SendTerminalCapabilitySetPDU",  //        93
       "EncryptionCommandPDU",          //        94
       "FlowControlCommandPDU",         //        95
       "EndSessionCommandPDU",          //        96
       "FunctionNotSupportedIndicationPDU",//       97
       "JitterIndicationPDU",           //        98
       "H223SkewIndicationPDU",         //        99
       "NewATMVCIndicationPDU",         //       100
       "UserInputIndicationPDU",        //       101
       "H2250MaximumSkewIndicationPDU", //       102
       "MCLocationIndicationPDU",       //       103
};




// Output function definitions
char *                OutputName[NUM_OUTPUTS] =
{
// Out-going Open Uni-directional Logical Channel (LCSE_OUT) state functions
       "EstablishReleased",             //          0
       "OpenAckAwaitingE",              //          1
       "OpenRejAwaitingE",              //          2
       "ReleaseAwaitingE",              //          3
       "T103AwaitingE",                 //          4
       "ReleaseEstablished",            //          5
       "OpenRejEstablished",            //          6
       "CloseAckEstablished",           //          7
       "CloseAckAwaitingR",             //          8
       "OpenRejAwaitingR",              //          9
       "T103AwaitingR",                 //         10
       "EstablishAwaitingR",            //         11

// In-coming Open Uni-directional Logical Channel (LCSE_IN) state functions
       "OpenReleased",                  //         12
       "CloseReleased",                 //         13
       "ResponseAwaiting",              //         14
       "ReleaseAwaiting",               //         15
       "CloseAwaiting",                 //         16
       "OpenAwaiting",                  //         17
       "CloseEstablished",              //         18
       "OpenEstablished",               //         19

// Out-going Open Bi-directional Logical Channel (BLCSE_OUT) state functions
       "EstablishReqBReleased",         //         20
       "OpenChannelAckBAwaitingE",      //         21
       "OpenChannelRejBAwaitingE",      //         22
       "ReleaseReqBOutAwaitingE",       //         23
       "T103ExpiryBAwaitingE",          //         24
       "ReleaseReqBEstablished",        //         25
       "OpenChannelRejBEstablished",    //         26
       "CloseChannelAckBEstablished",   //         27
       "CloseChannelAckAwaitingR",      //         28
       "OpenChannelRejBAwaitingR",      //         29
       "T103ExpiryBAwaitingR",          //         30
       "EstablishReqAwaitingR",         //         31

// In-coming Open Bi-directional Logical Channel (BLCSE_IN) state functions
       "OpenChannelBReleased",          //         32
       "CloseChannelBReleased",         //         33
       "EstablishResBAwaitingE",        //         34
       "ReleaseReqBInAwaitingE",        //         35
       "CloseChannelBAwaitingE",        //         36
       "OpenChannelBAwaitingE",         //         37
       "OpenChannelConfirmBAwaitingE",  //         38
       "T103ExpiryBAwaitingC",          //         39
       "OpenChannelConfirmBAwaitingC",  //         40
       "CloseChannelBAwaitingC",        //         41
       "OpenChannelBAwaitingC",         //         42
       "CloseChannelBEstablished",      //         43
       "OpenChannelBEstablished",       //         44

// Out-going Request Close Logical Channel (CLCSE_OUT) state functions
       "CloseRequestIdle",              //         45
       "RequestCloseAckAwaitingR",      //         46
       "RequestCloseRejAwaitingR",      //         47
       "T108ExpiryAwaitingR",           //         48

// In-coming Request Close Logical Channel (CLCSE_IN) state functions
       "RequestCloseIdle",              //         49
       "CloseResponseAwaitingR",        //         50
       "RejectRequestAwaitingR",        //         51
       "RequestCloseReleaseAwaitingR",  //         52
       "RequestCloseAwaitingR",         //         53

// Out-going Terminal Capability Exchange (CESE_OUT) state functions
       "RequestCapIdle",                //         54
       "TermCapAckAwaiting",            //         55
       "TermCapRejAwaiting",            //         56
       "T101ExpiryAwaiting",            //         57

// In-coming Terminal Capability Exchange (CESE_IN) state functions
       "TermCapSetIdle",                //         58
       "ResponseCapAwaiting",           //         59
       "RejectCapAwaiting",             //         60
       "TermCapReleaseAwaiting",        //         61
       "TermCapSetAwaiting",            //         62

// Out-going Multiplex Table (MTSE_OUT) state functions
       "MTSE0_TRANSFER_request",        //         63
       "MTSE1_TRANSFER_request",        //         64
       "MTSE1_MultiplexEntrySendAck",   //         65
       "MTSE1_MultiplexEntrySendRej",   //         66
       "MTSE1_T104Expiry",              //         67

// In-coming Multiplex Table (MTSE_IN) state functions
       "MTSE0_MultiplexEntrySend",      //         68
       "MTSE1_MultiplexEntrySend",      //         69
       "MTSE1_MultiplexEntrySendRelease",//        70
       "MTSE1_TRANSFER_response",       //         71
       "MTSE1_REJECT_request",          //         72

// Out-going Request Multiplex Entry (RMESE_OUT) state functions
       "RMESE0_SEND_request",           //         73
       "RMESE1_SEND_request",           //         74
       "RMESE1_RequestMuxEntryAck",     //         75
       "RMESE1_RequestMuxEntryRej",     //         76
       "RMESE1_T107Expiry",             //         77

// In-coming Request Multiplex Entry (RMESE_IN) state functions
       "RMESE0_RequestMuxEntry",        //         78
       "RMESE1_RequestMuxEntry",        //         79
       "RMESE1_RequestMuxEntryRelease", //         80
       "RMESE1_SEND_response",          //         81
       "RMESE1_REJECT_request",         //         82

// Out-going Request Mode (MRSE_OUT) state functions
       "MRSE0_TRANSFER_request",        //         83
       "MRSE1_TRANSFER_request",        //         84
       "MRSE1_RequestModeAck",          //         85
       "MRSE1_RequestModeRej",          //         86
       "MRSE1_T109Expiry",              //         87

// In-coming Request Mode (MRSE_IN) state functions
       "MRSE0_RequestMode",             //         88
       "MRSE1_RequestMode",             //         89
       "MRSE1_RequestModeRelease",      //         90
       "MRSE1_TRANSFER_response",       //         91
       "MRSE1_REJECT_request",          //         92

// Out-going Request Mode (MLSE_OUT) state functions
       "MLSE0_LOOP_request",            //         93
       "MLSE1_MaintenanceLoopAck",      //         94
       "MLSE1_MaintenanceLoopRej",      //         95
       "MLSE1_OUT_RELEASE_request",     //         96
       "MLSE1_T102Expiry",              //         97
       "MLSE2_MaintenanceLoopRej",      //         98
       "MLSE2_OUT_RELEASE_request",     //         99

// In-coming Request Mode (MLSE_IN) state functions
       "MLSE0_MaintenanceLoopRequest",  //        100
       "MLSE1_MaintenanceLoopRequest",  //        101
       "MLSE1_MaintenanceLoopOffCommand",//       102
       "MLSE1_LOOP_response",           //        103
       "MLSE1_IN_RELEASE_request",      //        104
       "MLSE2_MaintenanceLoopRequest",  //        105
       "MLSE2_MaintenanceLoopOffCommand",//       106

// Master Slave Determination (MSDSE) state functions
       "DetRequestIdle",                //        107
       "MSDetIdle",                     //        108
       "MSDetAckOutgoing",              //        109
       "MSDetOutgoing",                 //        110
       "MSDetRejOutgoing",              //        111
       "MSDetReleaseOutgoing",          //        112
       "T106ExpiryOutgoing",            //        113
       "MSDetAckIncoming",              //        114
       "MSDetIncoming",                 //        115
       "MSDetRejIncoming",              //        116
       "MSDetReleaseIncoming",          //        117
       "T106ExpiryIncoming",            //        118

// Round Trip Delay (RTDSE) state functions
       "RTDSE0_TRANSFER_request",       //        119
       "RTDSE0_RoundTripDelayRequest",  //        120
       "RTDSE1_TRANSFER_request",       //        121
       "RTDSE1_RoundTripDelayRequest",  //        122
       "RTDSE1_RoundTripDelayResponse", //        123
       "RTDSE1_T105Expiry",             //        124
};
#endif  // (_DEBUG)



typedef HRESULT (*STATE_FUNCTION)(Object_t *pObject, PDU_t *pPdu);

// Output function defintions
static STATE_FUNCTION StateFun[] =
{
// Out-going Open Uni-directional Logical Channel (LCSE_OUT) state functions
        establishReleased,              //          0
        openAckAwaitingE,               //          1
        openRejAwaitingE,               //          2
        releaseAwaitingE,               //          3
        t103AwaitingE,                  //          4
        releaseEstablished,             //          5
        openRejEstablished,             //          6
        closeAckEstablished,            //          7
        closeAckAwaitingR,              //          8
        openRejAwaitingR,               //          9
        t103AwaitingR,                  //         10
        establishAwaitingR,             //         11

// In-coming Open Uni-directional Logical Channel (LCSE_IN) state functions
        openReleased,                   //         12
        closeReleased,                  //         13
        responseAwaiting,               //         14
        releaseAwaiting,                //         15
        closeAwaiting,                  //         16
        openAwaiting,                   //         17
        closeEstablished,               //         18
        openEstablished,                //         19

// Out-going Open Bi-directional Logical Channel (BLCSE_OUT) state functions
        establishReqBReleased,          //         20
        openChannelAckBAwaitingE,       //         21
        openChannelRejBAwaitingE,       //         22
        releaseReqBOutAwaitingE,        //         23
        t103ExpiryBAwaitingE,           //         24
        releaseReqBEstablished,         //         25
        openChannelRejBEstablished,     //         26
        closeChannelAckBEstablished,    //         27
        closeChannelAckAwaitingR,       //         28
        openChannelRejBAwaitingR,       //         29
        t103ExpiryBAwaitingR,           //         30
        establishReqAwaitingR,          //         31

// In-coming Open Bi-directional Logical Channel (BLCSE_IN) state functions
        openChannelBReleased,           //         32
        closeChannelBReleased,          //         33
        establishResBAwaitingE,         //         34
        releaseReqBInAwaitingE,         //         35
        closeChannelBAwaitingE,         //         36
        openChannelBAwaitingE,          //         37
        openChannelConfirmBAwaitingE,   //         38
        t103ExpiryBAwaitingC,           //         39
        openChannelConfirmBAwaitingC,   //         40
        closeChannelBAwaitingC,         //         41
        openChannelBAwaitingC,          //         42
        closeChannelBEstablished,       //         43
        openChannelBEstablished,        //         44

// Out-going Request Close Logical Channel (CLCSE_OUT) state functions
        closeRequestIdle,               //         45
        requestCloseAckAwaitingR,       //         46
        requestCloseRejAwaitingR,       //         47
        t108ExpiryAwaitingR,            //         48

// In-coming Request Close Logical Channel (CLCSE_IN) state functions
        requestCloseIdle,               //         49
        closeResponseAwaitingR,         //         50
        rejectRequestAwaitingR,         //         51
        requestCloseReleaseAwaitingR,   //         52
        requestCloseAwaitingR,          //         53

// Out-going Terminal Capability Exchange (CESE_OUT) state functions
        requestCapIdle,                 //         54
        termCapAckAwaiting,             //         55
        termCapRejAwaiting,             //         56
        t101ExpiryAwaiting,             //         57

// In-coming Terminal Capability Exchange (CESE_IN) state functions
        termCapSetIdle,                 //         58
        responseCapAwaiting,            //         59
        rejectCapAwaiting,              //         60
        termCapReleaseAwaiting,         //         61
        termCapSetAwaiting,             //         62

// Out-going Multiplex Table (MTSE_OUT) state functions
        MTSE0_TRANSFER_requestF,        //         63
        MTSE1_TRANSFER_requestF,        //         64
        MTSE1_MultiplexEntrySendAckF,   //         65
        MTSE1_MultiplexEntrySendRejF,   //         66
        MTSE1_T104ExpiryF,              //         67

// In-coming Multiplex Table (MTSE_IN) state functions
        MTSE0_MultiplexEntrySendF,      //         68
        MTSE1_MultiplexEntrySendF,      //         69
        MTSE1_MultiplexEntrySendReleaseF,//        70
        MTSE1_TRANSFER_responseF,       //         71
        MTSE1_REJECT_requestF,          //         72

// Out-going Request Multiplex Entry (RMESE_OUT) state functions
        RMESE0_SEND_requestF,           //         73
        RMESE1_SEND_requestF,           //         74
        RMESE1_RequestMuxEntryAckF,     //         75
        RMESE1_RequestMuxEntryRejF,     //         76
        RMESE1_T107ExpiryF,             //         77

// In-coming Request Multiplex Entry (RMESE_IN) state functions
        RMESE0_RequestMuxEntryF,        //         78
        RMESE1_RequestMuxEntryF,        //         79
        RMESE1_RequestMuxEntryReleaseF, //         80
        RMESE1_SEND_responseF,          //         81
        RMESE1_REJECT_requestF,         //         82

// Out-going Request Mode (MRSE_OUT) state functions
        MRSE0_TRANSFER_requestF,        //         83
        MRSE1_TRANSFER_requestF,        //         84
        MRSE1_RequestModeAckF,          //         85
        MRSE1_RequestModeRejF,          //         86
        MRSE1_T109ExpiryF,              //         87

// In-coming Request Mode (MRSE_OUT) state functions
        MRSE0_RequestModeF,             //         88
        MRSE1_RequestModeF,             //         89
        MRSE1_RequestModeReleaseF,      //         90
        MRSE1_TRANSFER_responseF,       //         91
        MRSE1_REJECT_requestF,          //         92

// Out-going Request Mode (MLSE_OUT) state functions
        MLSE0_LOOP_requestF,            //         93
        MLSE1_MaintenanceLoopAckF,      //         94
        MLSE1_MaintenanceLoopRejF,      //         95
        MLSE1_OUT_RELEASE_requestF,     //         96
        MLSE1_T102ExpiryF,              //         97
        MLSE2_MaintenanceLoopRejF,      //         98
        MLSE2_OUT_RELEASE_requestF,     //         99

// In-coming Request Mode (MLSE_IN) state functions
        MLSE0_MaintenanceLoopRequestF,  //        100
        MLSE1_MaintenanceLoopRequestF,  //        101
        MLSE1_MaintenanceLoopOffCommandF,//       102
        MLSE1_LOOP_responseF,           //        103
        MLSE1_IN_RELEASE_requestF,      //        104
        MLSE2_MaintenanceLoopRequestF,  //        105
        MLSE2_MaintenanceLoopOffCommandF,//       106

// Master Slave Determination (MSDSE) state functions
        detRequestIdle,                 //        107
        msDetIdle,                      //        108
        msDetAckOutgoing,               //        109
        msDetOutgoing,                  //        110
        msDetRejOutgoing,               //        111
        msDetReleaseOutgoing,           //        112
        t106ExpiryOutgoing,             //        113
        msDetAckIncoming,               //        114
        msDetIncoming,                  //        115
        msDetRejIncoming,               //        116
        msDetReleaseIncoming,           //        117
        t106ExpiryIncoming,             //        118

// Round Trip Delay (RTDSE) state functions
        RTDSE0_TRANSFER_requestF,       //        119
        RTDSE0_RoundTripDelayRequestF,  //        120
        RTDSE1_TRANSFER_requestF,       //        121
        RTDSE1_RoundTripDelayRequestF,  //        122
        RTDSE1_RoundTripDelayResponseF, //        123
        RTDSE1_T105ExpiryF,             //        124
};



/*********************************************
 *
 * State table for the finite state machine
 *
 *********************************************/

Output_t StateTable[NUM_STATE_EVENTS][MAXSTATES] =
{
// Out-going Uni-directional Logical Channel (LCSE_OUT) events
{EstablishReleased,IGNORE,           IGNORE,             EstablishAwaitingR},  // ReqUEstablish
{IGNORE,           OpenAckAwaitingE, IGNORE,             IGNORE            },  // OpenUChAckPDU
{IGNORE,           OpenRejAwaitingE, OpenRejEstablished, OpenRejAwaitingR  },  // OpenUChRejectPDU
{IGNORE,           IGNORE,           CloseAckEstablished,CloseAckAwaitingR },  // CloseUChAckPDU
{IGNORE,           ReleaseAwaitingE, ReleaseEstablished, IGNORE            },  // ReqURelease
{BAD,              T103AwaitingE,    BAD,                T103AwaitingR     },  // T103Expiry

// In-coming Uni-directional Logical Channel (LCSE_IN) events
{OpenReleased,     OpenAwaiting,     OpenEstablished,    BAD               },  // OpenUChPDU
{CloseReleased,    CloseAwaiting,    CloseEstablished,   BAD               },  // CloseUChPDU
{IGNORE,           ResponseAwaiting, IGNORE,             BAD               },  // ResponseUEstablish
{IGNORE,           ReleaseAwaiting,  IGNORE,             BAD               },  // EstablishUReject

// Out-going Bi-directional Logical Channel (BLCSE_OUT) events
{EstablishReqBReleased,IGNORE,                      IGNORE,                      EstablishReqAwaitingR   },// ReqBEstablish
{IGNORE,               OpenChannelAckBAwaitingE,    IGNORE,                      IGNORE                  },// OpenBChAckPDU
{IGNORE,               OpenChannelRejBAwaitingE,    OpenChannelRejBEstablished,  OpenChannelRejBAwaitingR},// OpenBChRejectPDU
{IGNORE,               IGNORE,                      CloseChannelAckBEstablished, CloseChannelAckAwaitingR},// CloseBChAckPDU
{IGNORE,               ReleaseReqBOutAwaitingE,     ReleaseReqBEstablished,      IGNORE                  },// ReqClsBLCSE
{IGNORE,               IGNORE,                      IGNORE,                      IGNORE                  },// RspConfirmBLCSE
{BAD,                  T103ExpiryBAwaitingE,        BAD,                         T103ExpiryBAwaitingR    },// T103OutExpiry

// In-coming Bi-directional Logical Channel (BLCSE_IN) events
{OpenChannelBReleased, OpenChannelBAwaitingE,       OpenChannelBAwaitingC,       OpenChannelBEstablished },// OpenBChPDU
{CloseChannelBReleased,CloseChannelBAwaitingE,      CloseChannelBAwaitingC,      CloseChannelBEstablished},// CloseBChPDU
{IGNORE,               EstablishResBAwaitingE,      IGNORE,                      IGNORE                  },// ResponseBEstablish
{IGNORE,               OpenChannelConfirmBAwaitingE,OpenChannelConfirmBAwaitingC,IGNORE                  },// OpenBChConfirmPDU
{IGNORE,               ReleaseReqBInAwaitingE,      IGNORE,                      IGNORE                  },// OpenRejectBLCSE
{BAD,                  BAD,                         T103ExpiryBAwaitingC,        BAD                     },// T103InExpiry

// Out-going Request Close Logical Channel (CLCSE_OUT) events
{CloseRequestIdle,              IGNORE,                         BAD,BAD},   // ReqClose
{IGNORE,                        RequestCloseAckAwaitingR,       BAD,BAD},   // ReqChCloseAckPDU
{IGNORE,                        RequestCloseRejAwaitingR,       BAD,BAD},   // ReqChCloseRejectPDU
{BAD,                           T108ExpiryAwaitingR,            BAD,BAD},   // T108Expiry

// In-coming Request Close Logical Channel (CLCSE_IN) events
{RequestCloseIdle,              RequestCloseAwaitingR,          BAD,BAD},   // ReqChClosePDU
{IGNORE,                        RequestCloseReleaseAwaitingR,   BAD,BAD},   // ReqChCloseReleasePDU
{IGNORE,                        CloseResponseAwaitingR,         BAD,BAD},   // CLCSE_CLOSE_response
{IGNORE,                        RejectRequestAwaitingR,         BAD,BAD},   // CLCSE_REJECT_request

// Out-going Terminal Capablity Exchange (CESE_OUT) events
{RequestCapIdle,                IGNORE,                         BAD,BAD},   // TransferCapRequest
{IGNORE,                        TermCapAckAwaiting,             BAD,BAD},   // TermCapSetAckPDU
{IGNORE,                        TermCapRejAwaiting,             BAD,BAD},   // TermCapSetRejectPDU
{BAD,                           T101ExpiryAwaiting,             BAD,BAD},   // T101Expiry

// In-coming Terminal Capablity Exchange (CESE_IN) events
{TermCapSetIdle,                TermCapSetAwaiting,             BAD,BAD},   // TermCapSetPDU
{IGNORE,                        TermCapReleaseAwaiting,         BAD,BAD},   // TermCapSetRelPDU
{IGNORE,                        ResponseCapAwaiting,            BAD,BAD},   // CESE_TRANSFER_response
{IGNORE,                        RejectCapAwaiting,              BAD,BAD},   // CESE_REJECT_request

// Out-going Multiplex Table (MTSE_OUT) events
{MTSE0_TRANSFER_request,        MTSE1_TRANSFER_request,         BAD,BAD},   // TRANSFER_request
{IGNORE,                        MTSE1_MultiplexEntrySendAck,    BAD,BAD},   // MultiplexEntrySendAck
{IGNORE,                        MTSE1_MultiplexEntrySendRej,    BAD,BAD},   // MultiplexEntrySendReject
{BAD,                           MTSE1_T104Expiry,               BAD,BAD},   // T104Expiry

// In-coming Multiplex Table (MTSE_IN) events
{MTSE0_MultiplexEntrySend,      MTSE1_MultiplexEntrySend,       BAD,BAD},   // MultiplexEntrySend
{IGNORE,                        MTSE1_MultiplexEntrySendRelease,BAD,BAD},   // MultiplexEntrySendRelease
{IGNORE,                        MTSE1_TRANSFER_response,        BAD,BAD},   // MTSE_TRANSFER_response
{IGNORE,                        MTSE1_REJECT_request,           BAD,BAD},   // MTSE_REJECT_request

// Out-going Request Multiplex Entry (RMESE_OUT) events
{RMESE0_SEND_request,           RMESE1_SEND_request,            BAD,BAD},   // RMESE_SEND_request
{IGNORE,                        RMESE1_RequestMuxEntryAck,      BAD,BAD},   // RequestMultiplexEntryAck
{IGNORE,                        RMESE1_RequestMuxEntryRej,      BAD,BAD},   // RequestMultiplexEntryReject
{BAD,                           RMESE1_T107Expiry,              BAD,BAD},   // T107Expiry

// In-coming Request Multiplex Entry (RMESE_IN) events
{RMESE0_RequestMuxEntry,        RMESE1_RequestMuxEntry,         BAD,BAD},   // RequestMultiplexEntry
{IGNORE,                        RMESE1_RequestMuxEntryRelease,  BAD,BAD},   // RequestMultiplexEntryRelease
{BAD,                           RMESE1_SEND_response,           BAD,BAD},   // RMESE_SEND_response
{BAD,                           RMESE1_REJECT_request,          BAD,BAD},   // RMESE_REJECT_request

// Out-going Mode Request (MRSE_OUT) events
{MRSE0_TRANSFER_request,        MRSE1_TRANSFER_request,         BAD,BAD},   // MRSE_TRANSFER_request
{IGNORE,                        MRSE1_RequestModeAck,           BAD,BAD},   // RequestModeAck
{IGNORE,                        MRSE1_RequestModeRej,           BAD,BAD},   // RequestModeReject
{BAD,                           MRSE1_T109Expiry,               BAD,BAD},   // T109Expiry

// In-coming Mode Request (MRSE_IN) events
{MRSE0_RequestMode,             MRSE1_RequestMode,              BAD,BAD},   // RequestMode
{IGNORE,                        MRSE1_RequestModeRelease,       BAD,BAD},   // RequestModeRelease
{BAD,                           MRSE1_TRANSFER_response,        BAD,BAD},   // MRSE_TRANSFER_response
{BAD,                           MRSE1_REJECT_request,           BAD,BAD},   // MRSE_REJECT_request

// Out-going Maintenance Loop (MLSE_OUT) events
{MLSE0_LOOP_request,            BAD,                            BAD,                            BAD}, // MLSE_LOOP_request
{BAD,                           MLSE1_OUT_RELEASE_request,      MLSE2_OUT_RELEASE_request,      BAD}, // MLSE_OUT_RELEASE_request
{IGNORE,                        MLSE1_MaintenanceLoopAck,       IGNORE,                         BAD}, // MaintenanceLoopAck
{IGNORE,                        MLSE1_MaintenanceLoopRej,       MLSE2_MaintenanceLoopRej,       BAD}, // MaintenanceLoopReject
{BAD,                           MLSE1_T102Expiry,               BAD,                            BAD}, // T102Expiry

// In-coming Maintenance Loop (MLSE_IN) events
{MLSE0_MaintenanceLoopRequest,  MLSE1_MaintenanceLoopRequest,   MLSE2_MaintenanceLoopRequest,   BAD}, // MaintenanceLoopRequest
{IGNORE,                        MLSE1_MaintenanceLoopOffCommand,MLSE2_MaintenanceLoopOffCommand,BAD}, // MaintenanceLoopOffCommand
{BAD,                           MLSE1_LOOP_response,            BAD,                            BAD}, // MLSE_LOOP_response
{BAD,                           MLSE1_IN_RELEASE_request,       BAD,                            BAD}, // MLSE_IN_RELEASE_request

// Master Slave Determination (MSDSE) events
{DetRequestIdle,                IGNORE,                         IGNORE,              BAD}, // MSDetReq
{MSDetIdle,                     MSDetOutgoing,                  MSDetIncoming,       BAD}, // MSDetPDU
{IGNORE,                        MSDetAckOutgoing,               MSDetAckIncoming,    BAD}, // MSDetAckPDU
{IGNORE,                        MSDetRejOutgoing,               MSDetRejIncoming,    BAD}, // MSDetRejectPDU
{IGNORE,                        MSDetReleaseOutgoing,           MSDetReleaseIncoming,BAD}, // MSDetReleasePDU
{BAD,                           T106ExpiryOutgoing,             T106ExpiryIncoming,  BAD}, // T106Expiry

// Round Trip Delay Delay (RTDSE) events
{RTDSE0_TRANSFER_request,       RTDSE1_TRANSFER_request,        BAD,BAD},   // RTDSE_TRANSFER_request
{RTDSE0_RoundTripDelayRequest,  RTDSE0_RoundTripDelayRequest,   BAD,BAD},   // RoundTripDelayRequest
{IGNORE,                        RTDSE1_RoundTripDelayResponse,  BAD,BAD},   // RoundTripDelayResponse
{BAD,                           RTDSE1_T105Expiry,              BAD,BAD},   // T105Expiry
};



/*
 *  NAME
 *      StateMachine() - engine for finite state machine
 *
 *
 *  PARAMETERS
 *  INPUT       pObject        pointer to an FSM object structure
 *  INTPUT      event         input to the finite state machine
 *
 *  RETURN VALUE
 *   error codes defined in h245api.h
 */

HRESULT
StateMachine(Object_t *pObject, PDU_t *pPdu, Event_t Event)
{
    UINT                uFunction;
    HRESULT             lError;

    ASSERT(pObject != NULL);

    if (Event > NUM_EVENTS)
    {
        H245TRACE(pObject->dwInst, 1, "StateMachine: Invalid Event %d", Event);
        return H245_ERROR_PARAM;
    }

    if (pObject->State > MAXSTATES)
    {
        H245TRACE(pObject->dwInst, 1, "StateMachine: Invalid State %d", pObject->State);
        return H245_ERROR_INVALID_STATE;
    }

    ++(pObject->uNestLevel);

#if defined(_DEBUG)
    H245TRACE(pObject->dwInst, 2, "StateMachine: Entity=%s(%d) State=%d Event=%s(%d)",
              EntityName[pObject->Entity], pObject->Entity,
              pObject->State,
              EventName[Event], Event);
#else
    H245TRACE(pObject->dwInst, 2, "StateMachine: Entity=%d State=%d Event=%d",
              pObject->Entity, pObject->State, Event);
#endif

    uFunction = StateTable[Event][pObject->State];
    if (uFunction < (sizeof (StateFun) / sizeof(StateFun[0])))
    {
        /* indicating a valid transition */
#if defined(_DEBUG)
        H245TRACE(pObject->dwInst, 2, "StateMachine: Function=%s(%d)",
                  OutputName[uFunction], uFunction);
#else   // (_DEBUG)
        H245TRACE(pObject->dwInst, 2, "StateMachine: Function=%d", uFunction);
#endif  // (_DEBUG)

        lError = (*StateFun[uFunction])(pObject, pPdu);

#if defined(_DEBUG)
    H245TRACE(pObject->dwInst, 2, "StateMachine: Entity=%s(%d) New State=%d",
              EntityName[pObject->Entity], pObject->Entity, pObject->State);
#else
    H245TRACE(pObject->dwInst, 2, "StateMachine: Entity=%d New State=%d",
              pObject->Entity, pObject->State);
#endif
    }
    else if (uFunction == IGNORE)
    {
        H245TRACE(pObject->dwInst, 2, "StateMachine: Event ignored");
#if defined(_DEBUG)
        H245TRACE(pObject->dwInst, 2, "StateMachine: Event Ignored; Entity=%s(%d) State=%d Event=%s(%d)",
                  EntityName[pObject->Entity], pObject->Entity,
                  pObject->State,
                  EventName[Event], Event);
#else
        H245TRACE(pObject->dwInst, 2, "StateMachine: Entity=%d State=%d Event=%d",
                  pObject->Entity, pObject->State, Event);
#endif
        lError = H245_ERROR_OK;
    }
    else
    {
#if defined(_DEBUG)
        H245TRACE(pObject->dwInst, 2, "StateMachine: Event Invalid; Entity=%s(%d) State=%d Event=%s(%d)",
                  EntityName[pObject->Entity], pObject->Entity,
                  pObject->State,
                  EventName[Event], Event);
#else
        H245TRACE(pObject->dwInst, 2, "StateMachine: Event Invalid; Entity=%d State=%d Event=%d",
                 pObject->Entity, pObject->State, Event);
#endif
        lError = H245_ERROR_INVALID_STATE;
    }

    if (--(pObject->uNestLevel) == 0 && pObject->State == 0)
    {
        ObjectDestroy(pObject);
    }

    return lError;
} // StateMachine()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\gkiexp.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1997 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *																	   *
 *	$Archive:   S:\sturgeon\src\include\vcs\gkiexp.h_v  $
 *
 *	$Revision:   1.7  $
 *	$Date:   11 Feb 1997 15:37:30  $
 *
 *	$Author:   CHULME  $															*
 *
 *	$Log:   S:\sturgeon\src\include\vcs\gkiexp.h_v  $
 * 
 *    Rev 1.7   11 Feb 1997 15:37:30   CHULME
 * Added GKI_CleanupRequest function
 * 
 *    Rev 1.6   16 Jan 1997 15:25:00   BPOLING
 * changed copyrights to 1997
 * 
 *    Rev 1.5   17 Dec 1996 18:23:36   CHULME
 * Change interface to use Remote rather than destination for AdmissionRequest
 * 
 *    Rev 1.4   09 Dec 1996 14:13:40   EHOWARDX
 * Updated copyright notice.
 *                                                                     * 
 ***********************************************************************/

// gkiexp.h : header file
//

#ifndef GKIEXP_H
#define GKIEXP_H

#ifdef __cplusplus
extern "C" {
#endif

#include "GKICOM.H"

#if(0) // it's all in one DLL, no need for export
#ifndef DLL_EXPORT
#define DLL_EXPORT __declspec(dllexport)
#endif
#ifndef DLL_IMPORT
#define DLL_IMPORT __declspec(dllimport)
#endif
#else
#define DLL_IMPORT
#define DLL_EXPORT
#endif

// ------------------------ Variable Imports --------------------------
extern DLL_IMPORT DWORD dwGKIDLLFlags;
extern DLL_IMPORT BOOL  fGKIEcho;
extern DLL_IMPORT BOOL  fGKIDontSend;
#if 0 //NSMWrap
extern DLL_IMPORT BOOL  fNSMWrapper;
#endif

// ------------------------ Function Imports --------------------------
HRESULT DLL_IMPORT GKI_RegistrationRequest(long             lVersion,
                                    SeqTransportAddr     *pCallSignalAddr, 
                                    EndpointType         *pTerminalType,
                                    SeqAliasAddr         *pAliasAddr, 
    								PCC_VENDORINFO      pVendorInfo,
                                    HWND                 hWnd,
                                    WORD                 wBaseMessage,
                                    unsigned short       usRegistrationTransport /* = ipAddress_chosen */);

HRESULT DLL_IMPORT GKI_UnregistrationRequest(void);

HRESULT DLL_IMPORT GKI_LocationRequest(SeqAliasAddr         *pLocationInfo);

HRESULT DLL_IMPORT GKI_AdmissionRequest(unsigned short      usCallTypeChoice,
                                    SeqAliasAddr         *pRemoteInfo,
                                    TransportAddress     *pRemoteCallSignalAddress,
                                    SeqAliasAddr         *pDestExtraCallInfo,
                                    BandWidth            bandWidth,
                                    ConferenceIdentifier *pConferenceID,
                                    BOOL                 activeMC,
                                    BOOL                 answerCall,
                                    unsigned short       usCallTransport /* = ipAddress_chosen */);

HRESULT DLL_IMPORT GKI_BandwidthRequest(HANDLE              hModCall, 
                                    unsigned short       usCallTypeChoice,
                                    BandWidth            bandWidth);

HRESULT DLL_IMPORT GKI_DisengageRequest(HANDLE hCall);
HRESULT DLL_IMPORT GKI_Initialize(void);
HRESULT DLL_IMPORT GKI_CleanupRequest(void);
VOID DLL_IMPORT GKI_SetGKAddress(PSOCKADDR_IN pAddr);

#ifdef _DEBUG
WORD DLL_IMPORT Dump_GKI_RegistrationRequest(long        lVersion, 
                                    SeqTransportAddr     *pCallSignalAddr, 
                                    EndpointType         *pTerminalType,
                                    SeqAliasAddr         *pAliasAddr, 
                                    HWND                 hWnd,
                                    WORD                 wBaseMessage,
                                    unsigned short       usRegistrationTransport /* = ipAddress_chosen */);

WORD DLL_IMPORT Dump_GKI_LocationRequest(SeqAliasAddr    *pLocationInfo);

WORD DLL_IMPORT Dump_GKI_AdmissionRequest(unsigned short usCallTypeChoice,
                                    SeqAliasAddr         *pDestinationInfo,
                                    TransportAddress     *pDestCallSignalAddress,
                                    SeqAliasAddr         *pDextExtraCallInfo,
                                    BandWidth            bandWidth,
                                    ConferenceIdentifier *pConferenceID,
                                    BOOL                 activeMC,
                                    BOOL                 answerCall,
                                    unsigned short       usCallTransport /* = ipAddress_chosen */);

WORD DLL_IMPORT Dump_GKI_LocationRequest(SeqAliasAddr    *pLocationInfo);
#endif // _DEBUG

#ifdef __cplusplus
}
#endif // __cplusplus

#endif //GKIEXP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\gkierror.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1997 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *																	   *
 *	$Archive:   S:\sturgeon\src\include\vcs\gkierror.h_v  $
 *
 *	$Revision:   1.2  $
 *	$Date:   08 Feb 1997 12:20:14  $
 *
 *	$Author:   CHULME  $
 *
 *  $Log:   S:\sturgeon\src\include\vcs\gkierror.h_v  $
 * 
 *    Rev 1.2   08 Feb 1997 12:20:14   CHULME
 * Added error code for semaphore creation error
 * 
 *    Rev 1.1   16 Jan 1997 15:25:08   BPOLING
 * changed copyrights to 1997
 * 
 *    Rev 1.0   27 Dec 1996 14:37:02   EHOWARDX
 * Initial revision.
 *                                                                     * 
 ***********************************************************************/

// gkicom.h : common includes between gkitest and gki
/////////////////////////////////////////////////////////////////////////////

#ifndef GKIERROR_H
#define GKIERROR_H

// Status codes
#define GKI_EXIT_THREAD_CODE			ERROR_LOCAL_BASE_ID + 1	// not actually error code
#define GKI_REDISCOVER_CODE				ERROR_LOCAL_BASE_ID + 2	// not actually error code
#define GKI_DELETE_CALL_CODE			ERROR_LOCAL_BASE_ID + 3	// not actually error code
#define GKI_GCF_RCV_CODE				ERROR_LOCAL_BASE_ID + 4	// not actually error code

#define GKI_ALREADY_REG_CODE			ERROR_LOCAL_BASE_ID + 0x10
#define GKI_VERSION_ERROR_CODE			ERROR_LOCAL_BASE_ID + 0x11
#define GKI_ENCODER_ERROR_CODE			ERROR_LOCAL_BASE_ID + 0x12
#define GKI_NOT_REG_CODE				ERROR_LOCAL_BASE_ID + 0x13
#define GKI_BUSY_CODE					ERROR_LOCAL_BASE_ID + 0x14
#define GKI_NO_TA_ERROR_CODE			ERROR_LOCAL_BASE_ID + 0x15
#define GKI_NO_RESPONSE_CODE			ERROR_LOCAL_BASE_ID + 0x16
#define GKI_DECODER_ERROR_CODE			ERROR_LOCAL_BASE_ID + 0x17
#define GKI_SEMAPHORE_ERROR_CODE		ERROR_LOCAL_BASE_ID + 0x18
#define GKI_NOT_INITIALIZED_ERROR_CODE	ERROR_LOCAL_BASE_ID + 0x19

#define GKI_OK							NOERROR

#define GKI_EXIT_THREAD					MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS,1,FACILITY_GKI,GKI_EXIT_THREAD_CODE)
#define GKI_REDISCOVER					MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS,1,FACILITY_GKI,GKI_REDISCOVER_CODE)
#define GKI_DELETE_CALL					MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS,1,FACILITY_GKI,GKI_DELETE_CALL_CODE)
#define GKI_GCF_RCV						MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS,1,FACILITY_GKI,GKI_GCF_RCV_CODE)

#define GKI_NO_MEMORY					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,ERROR_OUTOFMEMORY)
#define GKI_NO_THREAD					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,ERROR_TOO_MANY_TCBS)
#define GKI_HANDLE_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,ERROR_INVALID_HANDLE)

#define GKI_ALREADY_REG					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_ALREADY_REG_CODE)
#define GKI_VERSION_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_VERSION_ERROR_CODE)
#define GKI_ENCODER_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_ENCODER_ERROR_CODE)
#define GKI_NOT_REG						MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_NOT_REG_CODE)
#define GKI_BUSY						MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_BUSY_CODE)
#define GKI_NO_TA_ERROR					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_NO_TA_ERROR_CODE)
#define GKI_NO_RESPONSE					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_NO_RESPONSE_CODE)
#define GKI_DECODER_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_DECODER_ERROR_CODE)
#define GKI_SEMAPHORE_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_SEMAPHORE_ERROR_CODE)

#define GKI_WINSOCK2_ERROR(w)			(MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_WINSOCK2,w))
#define GKI_NOT_INITIALIZED				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_NOT_INITIALIZED_ERROR_CODE)

#endif // GKIERROR_H

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\gkicom.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1997 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *																	   *
 *	$Archive:   S:\sturgeon\src\include\vcs\gkicom.h_v  $
 *
 *	$Revision:   1.3  $
 *	$Date:   10 Jan 1997 17:41:10  $
 *
 *	$Author:   CHULME  $
 *
 *  $Log:   S:\sturgeon\src\include\vcs\gkicom.h_v  $
 * 
 *    Rev 1.3   10 Jan 1997 17:41:10   CHULME
 * Changed CallReturnInfo structure to contain CRV and conferenceID
 * 
 *    Rev 1.2   10 Jan 1997 16:06:54   CHULME
 * Removed stdafx.h check for non MFC GKI implementation
 * 
 *    Rev 1.1   27 Dec 1996 14:37:22   EHOWARDX
 * Split out error codes into GKIERROR.H.
 * 
 *    Rev 1.0   11 Dec 1996 14:49:48   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.9   09 Dec 1996 14:13:38   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.8   22 Nov 1996 15:25:44   CHULME
 * Added VCS log to the header
 *                                                                     * 
 ***********************************************************************/

// gkicom.h : common includes between gkitest and gki
/////////////////////////////////////////////////////////////////////////////

#ifndef GKICOM_H
#define GKICOM_H

#include "apierror.h"
#include "gkierror.h"
#include "h225asn.h"
#include "gk_asn1.h"

// The following GKVER_xxx constants define the expiration date of GKI.DLL
#define GKVER_EXPIRE_YEAR          1997
#define GKVER_EXPIRE_MONTH         10
#define GKVER_EXPIRE_DAY           31

typedef struct SeqTransportAddr {
	struct SeqTransportAddr	*next;
	TransportAddress value;
} SeqTransportAddr;

typedef struct SeqAliasAddr {
	struct SeqAliasAddr		*next;
	AliasAddress			value;
} SeqAliasAddr;

typedef struct CallReturnInfo {
	HANDLE					hCall;
	CallModel				callModel;
	TransportAddress		destCallSignalAddress;
	BandWidth				bandWidth;
	CallReferenceValue		callReferenceValue;
	ConferenceIdentifier	conferenceID;
	WORD					wError;
} CallReturnInfo;

// Version Information for GKI Interface
#define GKI_VERSION				21	// TBD - reset to 1 after testing

// wMsg literals - these are added to the wBaseMessage supplied by the user
#define GKI_REG_CONFIRM			1
#define GKI_REG_DISCOVERY		2
#define GKI_REG_REJECT			3
#define GKI_REG_BYPASS			4

#define GKI_UNREG_CONFIRM		5
#define GKI_UNREG_REJECT		6

#define GKI_ADM_CONFIRM			7
#define GKI_ADM_REJECT			8

#define GKI_BW_CONFIRM			9
#define GKI_BW_REJECT			0xa

#define GKI_DISENG_CONFIRM		0xb
#define GKI_DISENG_REJECT		0xc

#define GKI_LOCATION_CONFIRM	0xd
#define GKI_LOCATION_REJECT		0xe

#define GKI_UNREG_REQUEST		0xf

#define GKI_ERROR				0x10
#define MAX_ASYNC_MSGS			0x10

#define HR_SEVERITY_MASK				0x80000000
#define HR_R_MASK						0x40000000
#define HR_C_MASK						0x20000000
#define HR_N_MASK						0x10000000
#define HR_R2_MASK						0x08000000
#define HR_FACILITY_MASK				0x07ff0000
#define HR_CODE_MASK					0x0000ffff

#endif // GKICOM_H

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\gkiloc.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\gkiloc.cpv  $
*																		*
*	$Revision:   1.6  $
*	$Date:   12 Feb 1997 01:11:46  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\gkiloc.cpv  $
// 
//    Rev 1.6   12 Feb 1997 01:11:46   CHULME
// Redid thread synchronization to use Gatekeeper.Lock
// 
//    Rev 1.5   17 Jan 1997 09:02:14   CHULME
// Changed reg.h to gkreg.h to avoid name conflict with inc directory
// 
//    Rev 1.4   10 Jan 1997 16:15:36   CHULME
// Removed MFC dependency
// 
//    Rev 1.3   20 Dec 1996 16:38:20   CHULME
// Fixed access synchronization with Gatekeeper lock
// 
//    Rev 1.2   02 Dec 1996 23:49:52   CHULME
// Added premptive synchronization code
// 
//    Rev 1.1   22 Nov 1996 15:22:02   CHULME
// Added VCS log to the header
*************************************************************************/

// gkilocation.cpp : Handles the GKI_LocationRequest API
//

#include "precomp.h"

#include <process.h>
#include <winsock.h>
#include "GKICOM.H"
#include "dspider.h"
#include "dgkilit.h"
#include "DGKIPROT.H"
#include "GATEKPR.H"
#include "gksocket.h"
#include "GKREG.H"
#include "dcall.h"
#include "h225asn.h"
#include "coder.hpp"
#include "dgkiext.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern "C" HRESULT DLL_EXPORT
GKI_LocationRequest(SeqAliasAddr *pLocationInfo)
{
	// ABSTRACT:  This function is exported.  It is called by the client application
	//            to request the transport address for a terminal that is registered.  
	//            with the supplied alias addresses.  
	// AUTHOR:    Colin Hulme

	SeqAliasAddr	*pAA;
	HRESULT			hResult;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "GKI_LocationRequest()\n", 0);

#ifdef _DEBUG
	if (dwGKIDLLFlags & SP_GKI)
	{
		SPIDER_TRACE(SP_GKI, "GKI_LocationRequest()\n", 0);
		Dump_GKI_LocationRequest(pLocationInfo);
	}
#endif

	// Create a Gatekeeper lock object on the stack
	// It's constructor will lock pGK and when we return
	// from any path, its destructor will unlock pGK
	CGatekeeperLock	GKLock(g_pGatekeeper);
	if (g_pReg == 0)
		return (GKI_NOT_REG);

	// Protect against concurrent PDUs
	if (g_pReg->GetRasMessage() != 0)
		return (GKI_BUSY);

	if (g_pReg->GetState() != CRegistration::GK_REGISTERED)
		return (GKI_NOT_REG);

	// Initialize CRegistration member variables
	for (pAA = pLocationInfo; pAA != 0; pAA = pAA->next)
	{
		if ((hResult = g_pReg->AddLocationInfo(pAA->value)) != GKI_OK)
			return (hResult);
	}

	// Create LocationRequest structure - Encode and send PDU
	if ((hResult = g_pReg->LocationRequest()) != GKI_OK)
		return (hResult);

	return (GKI_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\gkideng.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\gkideng.cpv  $
*																		*
*	$Revision:   1.6  $
*	$Date:   12 Feb 1997 01:12:12  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\gkideng.cpv  $
// 
//    Rev 1.6   12 Feb 1997 01:12:12   CHULME
// Redid thread synchronization to use Gatekeeper.Lock
// 
//    Rev 1.5   17 Jan 1997 09:02:12   CHULME
// Changed reg.h to gkreg.h to avoid name conflict with inc directory
// 
//    Rev 1.4   10 Jan 1997 16:15:32   CHULME
// Removed MFC dependency
// 
//    Rev 1.3   20 Dec 1996 16:38:36   CHULME
// Fixed access synchronization with Gatekeeper lock
// 
//    Rev 1.2   02 Dec 1996 23:49:54   CHULME
// Added premptive synchronization code
// 
//    Rev 1.1   22 Nov 1996 15:20:08   CHULME
// Added VCS log to the header
*************************************************************************/

// gkidisengage.cpp : Handles the GKI_DisengageRequest API
//

#include "precomp.h"

#include <process.h>
#include <winsock.h>
#include "GKICOM.H"
#include "dspider.h"
#include "dgkilit.h"
#include "DGKIPROT.H"
#include "GATEKPR.H"
#include "gksocket.h"
#include "GKREG.H"
#include "dcall.h"
#include "h225asn.h"
#include "coder.hpp"
#include "dgkiext.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern "C" HRESULT DLL_EXPORT
GKI_DisengageRequest(HANDLE hCall)
{
	// ABSTRACT:  This function is exported.  It is called by the client application
	//            to unregister with the Gatekeeper.  The handle supplied by the client
	//            is actually a pointer to the CRegistration object, which will be 
	//            deleted
	// AUTHOR:    Colin Hulme

	HRESULT			hResult;
	CCall			*pCall;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "GKI_DisengageRequest(%X)\n", hCall);
	SPIDER_TRACE(SP_GKI, "GKI_DisengageRequest(%X)\n", hCall);

	// Create a Gatekeeper lock object on the stack
	// It's constructor will lock pGK and when we return
	// from any path, its destructor will unlock pGK
	CGatekeeperLock	GKLock(g_pGatekeeper);
	if (g_pReg == 0)
		return (GKI_NOT_REG);

	if (g_pReg->GetState() != CRegistration::GK_REGISTERED)
		return (GKI_NOT_REG);

	// Validate call pointer
	pCall = (CCall *)hCall;
	if (IsBadReadPtr(pCall, sizeof(CCall)))
		return (GKI_HANDLE_ERROR);
	if (pCall != (CCall *)pCall->GetHCall())
		return (GKI_HANDLE_ERROR);

	// Protect against concurrent PDUs
	if (pCall->GetRasMessage() != 0)
		return (GKI_BUSY);

	// Create DisengageRequest structure - Encode and send PDU
	if ((hResult = pCall->DisengageRequest()) != GKI_OK)
		return (hResult);

	return (GKI_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\gkibw.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\gkibw.cpv  $
*																		*
*	$Revision:   1.6  $
*	$Date:   12 Feb 1997 01:12:16  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\gkibw.cpv  $
// 
//    Rev 1.6   12 Feb 1997 01:12:16   CHULME
// Redid thread synchronization to use Gatekeeper.Lock
// 
//    Rev 1.5   17 Jan 1997 09:02:08   CHULME
// Changed reg.h to gkreg.h to avoid name conflict with inc directory
// 
//    Rev 1.4   10 Jan 1997 16:15:22   CHULME
// Removed MFC dependency
// 
//    Rev 1.3   20 Dec 1996 16:38:24   CHULME
// Fixed access synchronization with Gatekeeper lock
// 
//    Rev 1.2   02 Dec 1996 23:49:48   CHULME
// Added premptive synchronization code
// 
//    Rev 1.1   22 Nov 1996 15:22:22   CHULME
// Added VCS log to the header
*************************************************************************/

// gkibandwidth.cpp : Handles the GKI_BandwidthRequest API
//
#include "precomp.h"

#include <process.h>
#include <winsock.h>
#include "GKICOM.H"
#include "dspider.h"
#include "dgkilit.h"
#include "DGKIPROT.H"
#include "GATEKPR.H"
#include "gksocket.h"
#include "GKREG.H"
#include "dcall.h"
#include "h225asn.h"
#include "coder.hpp"
#include "dgkiext.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern "C" HRESULT DLL_EXPORT 
GKI_BandwidthRequest(HANDLE	hModCall, unsigned short usCallTypeChoice, BandWidth bandWidth)
{
	// ABSTRACT:  This function is exported.  It is called by the client application
	//            to request a change in the bandwidth of an existing conference.
	//            The handle supplied by the client is actually a pointer to the CCall 
	//            object, which will be modified
	// AUTHOR:    Colin Hulme

	HRESULT			hResult;
	CCall			*pCall;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "GKI_BandwidthRequest(%X)\n", hModCall);

#ifdef _DEBUG
	if (dwGKIDLLFlags & SP_GKI)
	{
		SPIDER_TRACE(SP_GKI, "GKI_BandwidthRequest()\n", 0);
		wsprintf(szGKDebug, "\thModCall = %X\n", hModCall);
		OutputDebugString(szGKDebug);
		wsprintf(szGKDebug, "\tusCallTypeChoice = %X\n", usCallTypeChoice);
		OutputDebugString(szGKDebug);
		wsprintf(szGKDebug, "\tbandWidth = %X\n", bandWidth);
		OutputDebugString(szGKDebug);
	}
#endif

	// Create a Gatekeeper lock object on the stack
	// It's constructor will lock pGK and when we return
	// from any path, its destructor will unlock pGK
	CGatekeeperLock	GKLock(g_pGatekeeper);
	if (g_pReg == 0)
		return (GKI_NOT_REG);

	if (g_pReg->GetState() != CRegistration::GK_REGISTERED)
		return (GKI_NOT_REG);

	// Validate call pointer
	pCall = (CCall *)hModCall;
	if (IsBadReadPtr(pCall, sizeof(CCall)))
		return (GKI_HANDLE_ERROR);
	if (pCall != (CCall *)pCall->GetHCall())
		return (GKI_HANDLE_ERROR);

	// Protect against concurrent PDUs
	if (pCall->GetRasMessage() != 0)
		return (GKI_BUSY);

	// Initialize CCall member variables
	pCall->SetCallType(usCallTypeChoice);
	pCall->SetBandWidth(bandWidth);

	// Create BandwidthRequest structure - Encode and send PDU
	if ((hResult = pCall->BandwidthRequest()) != GKI_OK)
		return (hResult);

	return (GKI_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\gkiman.c ===
/****************************************************************************
 *
 * $Archive:   S:\sturgeon\src\callcont\vcs\gkiman.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 * Copyright (c) 1996 Intel Corporation.
 *
 * $Revision:   1.77  $
 * $Date:   05 Mar 1997 14:30:26  $
 * $Author:   SBELL1  $
 *
 * Deliverable:
 *
 * Abstract:
 *
 * Notes:
 *
 *  Much effort has gone into working around the following constraints of
 *  the GKI interface:
 *  1) Only one admission request can be pending at a time. This is because
 *     the hCall is unknown until it completes.
 *  2) Only one bandwidth request per call can be pending at a time.
 *  3) Any pending bandwidth request must complete before issuing a
 *     disengage request.
 *  4) Any calls must be disengaged before issuing a deregistration request.
 *
 ***************************************************************************/
#ifdef GATEKEEPER

#include "precomp.h"

#include "incommon.h"
#include "ccerror.h"
#include "isrg.h"
#include "gkiexp.h"
#include "callman2.h"
#include "cclock.h"
#include "iras.h"
#include "bestintf.h"

#pragma warning ( default : 4115 4201 4214)


#ifdef FORCE_SERIALIZE_CALL_CONTROL
#define EnterCallControlTop()      {CCLOCK_AcquireLock();}

#define LeaveCallControlTop(f)     {HRESULT stat; \
	                                stat = f; \
									CCLOCK_RelinquishLock(); \
                                    return stat;}
#else
#define EnterCallControlTop()
#define LeaveCallControlTop(f) {HRESULT stat; \
	                                stat = f; \
									return stat;}
#endif



#define GKIMAN_BASE             WM_USER

#define MIN_BANDWIDTH           1
#define MAX_BANDWIDTH           (0xFFFFFFFF / 100)

#define GKI_ADMITTING_HANDLE    ((HANDLE)-1)
#define GKI_BYPASS_HANDLE       ((HANDLE)-2)

// GKI Manager state
#define STATE_START                0
#define STATE_CLASS_REGISTERED     1
#define STATE_WINDOW_CREATED       2
#define STATE_REGISTERING          3
#define STATE_REGISTERING_REREG    4
#define STATE_REGISTERING_UNREG    5
#define STATE_REGISTERED           6
#define STATE_ADMITTING            7
#define STATE_ADMITTING_REREG      8
#define STATE_ADMITTING_UNREG      9
#define STATE_DISENGAGING         10
#define STATE_DISENGAGING_REREG   11
#define STATE_UNREGISTERING       12
#define STATE_UNREGISTERING_REREG 13
#define STATE_REG_BYPASS          14



typedef HRESULT (*PGKI_RegistrationRequest)(long             lVersion,
                                    SeqTransportAddr     *pCallSignalAddr,
                                    EndpointType         *pTerminalType,
                                    SeqAliasAddr         *pAliasAddr,
                                    PCC_VENDORINFO       pVendorInfo,
                                    HWND                 hWnd,
                                    WORD                 wBaseMessage,
                                    unsigned short       usRegistrationTransport /* = ipAddress_chosen */);

typedef HRESULT (*PGKI_UnregistrationRequest)(void);

typedef HRESULT (*PGKI_LocationRequest)(SeqAliasAddr         *pLocationInfo);

typedef HRESULT (*PGKI_AdmissionRequest)(unsigned short      usCallTypeChoice,
                                    SeqAliasAddr         *pDestinationInfo,
                                    TransportAddress     *pDestCallSignalAddress,
                                    SeqAliasAddr         *pDextExtraCallInfo,
                       				LPGUID               pCallIdentifier,
                                    BandWidth            bandWidth,
                                    ConferenceIdentifier *pConferenceID,
                                    BOOL                 activeMC,
                                    BOOL                 answerCall,
                                    unsigned short       usCallTransport /* = ipAddress_chosen */);

typedef HRESULT (*PGKI_BandwidthRequest)(HANDLE              hModCall,
                                    unsigned short       usCallTypeChoice,
                                    BandWidth            bandWidth);

typedef HRESULT (*PGKI_DisengageRequest)(HANDLE hCall);
typedef HRESULT (*PGKI_Initialize)(void);
typedef HRESULT (*PGKI_CleanupRequest)(void);

HRESULT Q931CopyAliasNames(PCC_ALIASNAMES *ppTarget, PCC_ALIASNAMES pSource);
HRESULT Q931FreeAliasNames(PCC_ALIASNAMES pSource);
#define CopyAliasNames Q931CopyAliasNames
#define FreeAliasNames Q931FreeAliasNames
HRESULT CopyVendorInfo(				PCC_VENDORINFO			*ppDest,
									PCC_VENDORINFO			pSource);
HRESULT FreeVendorInfo(				PCC_VENDORINFO			pVendorInfo);




typedef struct _LISTEN
{
  struct _LISTEN *  pNext;
  PCC_ALIASNAMES    pAliasNames;
  CC_HLISTEN        hListen;
  DWORD             dwAddr;
  WORD              wPort;
} LISTEN, *PLISTEN;

//
// GKI Manager Global Data
//
CRITICAL_SECTION  GkiLock;
const char      szClassName[]         = "GkiManWndClass";
HWND            hwndGki               = 0;
ATOM            atomGki               = 0;
unsigned int    uGkiState             = STATE_START;
PLISTEN         pListenList           = NULL;
unsigned int    uGkiCalls             = 0;
unsigned int    uPendingDisengages    = 0;


BOOL            fGKConfigured   = FALSE;
BOOL            fGKEnabled      = FALSE;
PCC_ALIASNAMES  gpLocalAliasNames = NULL;
PCC_VENDORINFO  gpVendorInfo = NULL;
DWORD           g_dwMultipointConfiguration = 0;
RASNOTIFYPROC gpRasNotifyProc = NULL;

// HINSTANCE				   hGkiDll					  = 0;
PGKI_RegistrationRequest   pGKI_RegistrationRequest   = NULL;
PGKI_UnregistrationRequest pGKI_UnregistrationRequest = NULL;
PGKI_LocationRequest       pGKI_LocationRequest       = NULL;
PGKI_AdmissionRequest      pGKI_AdmissionRequest      = NULL;
PGKI_BandwidthRequest      pGKI_BandwidthRequest      = NULL;
PGKI_DisengageRequest      pGKI_DisengageRequest      = NULL;
PGKI_CleanupRequest		   pGKI_CleanupRequest        = NULL;
PGKI_Initialize            pGKI_Initialize          = NULL;

HRESULT ValidateCall(CC_HCALL hCall);
HRESULT	LastGkiError = CC_GKI_STATE;

//
// Forward declarations
//
LRESULT APIENTRY GkiWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);



//
// Helper subroutines
//

#ifdef    _DEBUG

typedef struct _GKIMAP
{
  HRESULT       hResult;
  char *        pString;
} GKIMAP;

GKIMAP GkiErrorNames[] =
{
  GKI_OK,               "GKI_OK",
  GKI_EXIT_THREAD,      "GKI_EXIT_THREAD",
  GKI_REDISCOVER,       "GKI_REDISCOVER",
  GKI_DELETE_CALL,      "GKI_DELETE_CALL",
  GKI_GCF_RCV,          "GKI_GCF_RCV",
  GKI_NO_MEMORY,        "GKI_NO_MEMORY",
  GKI_NO_THREAD,        "GKI_NO_THREAD",
  GKI_HANDLE_ERROR,     "GKI_HANDLE_ERROR",
  GKI_ALREADY_REG,      "GKI_ALREADY_REG",
  GKI_VERSION_ERROR,    "GKI_VERSION_ERROR",
  GKI_ENCODER_ERROR,    "GKI_ENCODER_ERROR",
  GKI_NOT_REG,          "GKI_NOT_REG",
  GKI_BUSY,             "GKI_BUSY",
  GKI_NO_TA_ERROR,      "GKI_NO_TA_ERROR",
  GKI_NO_RESPONSE,      "GKI_NO_RESPONSE",
  GKI_DECODER_ERROR,    "GKI_DECODER_ERROR",
};

char *StateNames[] =
{
  "STATE_START",
  "STATE_CLASS_REGISTERED",
  "STATE_WINDOW_CREATED",
  "STATE_REGISTERING",
  "STATE_REGISTERING_REREG",
  "STATE_REGISTERING_UNREG",
  "STATE_REGISTERED",
  "STATE_ADMITTING",
  "STATE_ADMITTING_REREG",
  "STATE_ADMITTING_UNREG",
  "STATE_DISENGAGING",
  "STATE_DISENGAGING_REREG",
  "STATE_UNREGISTERING",
  "STATE_UNREGISTERING_REREG",
  "STATE_REG_BYPASS",
};

char *CallStateNames[] =
{
  "GCS_START",
  "GCS_WAITING",
  "GCS_ADMITTING",
  "GCS_ADMITTING_CLOSE_PENDING",
  "GCS_ADMITTED",
  "GCS_CHANGING",
  "GCS_CHANGING_CLOSE_PENDING",
  "GCS_DISENGAGING",
};

char szBuffer[128];

char * GkiErrorName(char *szFormat, HRESULT hResult)
{
  register int  nIndex = sizeof(GkiErrorNames) / sizeof(GkiErrorNames[0]);
  char          szTemp[32];

  while (nIndex > 0)
  {
    if (GkiErrorNames[--nIndex].hResult == hResult)
    {
      wsprintf(szBuffer, szFormat, GkiErrorNames[nIndex].pString);
      return szBuffer;
    }
  }

  wsprintf(szTemp, "Unknown(0x%x)", hResult);
  wsprintf(szBuffer, szFormat, szTemp);
  return szBuffer;
} // GkiErrorName()

char * StateName(char *szFormat, unsigned uState)
{
  char szTemp[32];
  if (uState < (sizeof(StateNames)/sizeof(StateNames[0])))
  {
    wsprintf(szBuffer, szFormat, StateNames[uState]);
  }
  else
  {
    wsprintf(szTemp, "Unknown(%d)", uState);
    wsprintf(szBuffer, szFormat, szTemp);
  }
  return szBuffer;
} // StateName()

char * CallStateName(char *szFormat, unsigned uCallState)
{
  char szTemp[32];
  if (uCallState <= (sizeof(CallStateNames)/sizeof(CallStateNames[0])))
  {
    wsprintf(szBuffer, szFormat, CallStateNames[uCallState]);
  }
  else
  {
    wsprintf(szTemp, "Unknown(%d)", uCallState);
    wsprintf(szBuffer, szFormat, szTemp);
  }
  return szBuffer;
} // CallStateName()

#else

#define GkiErrorName(x,y)   ""
#define StateName(x,y)      ""
#define CallStateName(x,y)  ""

#endif // _DEBUG



HRESULT MapRegistrationRejectReason(UINT uReason)
{
#if(0)  // this must have been coded by the department of redundancy department
   register HRESULT lReason;
 // TBD - Map reason code into CC_xxx HRESULT
  switch (uReason)
  {
  case discoveryRequired_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case RgstrtnRjctRsn_invldRvsn_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case invalidCallSignalAddress_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case invalidRASAddress_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case duplicateAlias_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case invalidTerminalType_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case RgstrtnRjctRsn_undfndRsn_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case transportNotSupported_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  default:
    lReason = CC_GATEKEEPER_REFUSED;
  } // switch

  return lReason;
#else
    return (MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_GKIREGISTRATION, (LOWORD(uReason))));
#endif
} // MapRegistrationRejectReason()


HRESULT MapUnregistrationRequestReason(UINT uReason)
{
    HRESULT lReason;
    lReason = MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKIUNREGREQ, ERROR_LOCAL_BASE_ID + (LOWORD(uReason)));
    return lReason;
}
HRESULT MapAdmissionRejectReason(register UINT uReason)
{
  register HRESULT lReason;
#if(0)
  // TBD - Map reason code into CC_xxx HRESULT
  switch (uReason)
  {
  case AdmissionRejectReason_calledPartyNotRegistered_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case ARRn_invldPrmssn_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case AdmssnRjctRsn_rqstDnd_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case AdmssnRjctRsn_undfndRsn_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case AdmissionRejectReason_callerNotRegistered_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case AdmissionRejectReason_routeCallToGatekeeper_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case invldEndpntIdntfr_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case AdmssnRjctRsn_rsrcUnvlbl_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  default:
    lReason = CC_GATEKEEPER_REFUSED;
  } // switch
#else// last 8 bits are the reason code
    lReason = MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKIADMISSION, ERROR_LOCAL_BASE_ID + (uReason & 0xff));
#endif
  return lReason;
} // MapAdmissionRejectReason()



HRESULT MapBandwidthRejectReason(register UINT uReason)
{
  register HRESULT lReason;

  // TBD - Map reason code into CC_xxx HRESULT
  switch (uReason)
  {
  case notBound_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case invalidConferenceID_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case BndRjctRsn_invldPrmssn_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case insufficientResources_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case BndRjctRsn_invldRvsn_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case BndRjctRsn_undfndRsn_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  default:
    lReason = CC_GATEKEEPER_REFUSED;
  } // switch

  return lReason;
} // MapBandwidthRejectReason()



/*
 *  NOTES
 *    GkiLock must be locked before calling this routine!
 */

static PLISTEN ListenEnqueue(register PLISTEN pListen)
{
  pListen->pNext = pListenList;
  return pListenList = pListen;
} // ListenEnqueue()



/*
 *  NOTES
 *    GkiLock must be locked before calling this routine!
 */

static PLISTEN ListenDequeue(CC_HLISTEN hListen)
{
  register PLISTEN      pListen = pListenList;
  register PLISTEN      pListenPrev;

  if (pListen)
  {
    if (pListen->hListen == hListen)
    {
      pListenList = pListen->pNext;
    }
    else
    {
      do
      {
        pListenPrev = pListen;
        pListen = pListen->pNext;
      } while (pListen && pListen->hListen != hListen);
      if (pListen)
      {
        pListenPrev->pNext = pListen->pNext;
      }
    }
  }

  return pListen;
} // ListenDequeue()



/*
 *  NOTES
 *    Since the pGkiCall is locked, we don't need a critical section
 *    around the queue manipulation code.
 */

static PBWREQ BwReqEnqueue(register PGKICALL pGkiCall, register PBWREQ pBwReq)
{
  pBwReq->pNext = NULL;
  if (pGkiCall->pBwReqHead)
  {
    pGkiCall->pBwReqTail->pNext = pBwReq;
  }
  else
  {
    pGkiCall->pBwReqHead = pBwReq;
  }
  return pGkiCall->pBwReqTail = pBwReq;
} // BwReqEnqueue()



/*
 *  NOTES
 *    Since the pGkiCall is locked, we don't need a critical section
 *    around the queue manipulation code.
 */

static PBWREQ BwReqDequeue(register PGKICALL pGkiCall)
{
  register PBWREQ pBwReq = pGkiCall->pBwReqHead;
  if (pBwReq)
  {
    pGkiCall->pBwReqHead = pBwReq->pNext;
  }
  return pBwReq;
} // BwReqDequeue()



DWORD GetIpAddress(void)
{
  DWORD dwAddr;
  char szHostName[128];
  if (gethostname(szHostName, sizeof(szHostName)) == 0)
  {
    struct hostent *pHostent;
    pHostent = gethostbyname(szHostName);
    if (pHostent != NULL)
    {
      ASSERT(pHostent->h_addrtype == AF_INET);
      dwAddr = *((DWORD *)pHostent->h_addr_list[0]);
      return ntohl(dwAddr);
    }
  }

  return INADDR_ANY;
} // GetIpAddress()



// Caveat: *pAlias should be initialized to all 0 before calling!

static HRESULT CopyAliasItem(SeqAliasAddr *pAlias, PCC_ALIASITEM pAliasItem)
{
  unsigned int uDigit;
  unsigned int uPrefixLength;
  unsigned int uDataLength;

  if (pAliasItem->pData == NULL || pAliasItem->wDataLength == 0)
    return CC_BAD_PARAM;

  if (pAliasItem->pPrefix)
  {
    // Strip off terminating NULs if included in prefix length
    uPrefixLength = pAliasItem->wPrefixLength;
    while (uPrefixLength && pAliasItem->pPrefix[uPrefixLength - 1] == 0)
      --uPrefixLength;
  }
  else
  {
    uPrefixLength = 0;
  }

  uDataLength = pAliasItem->wDataLength;

  switch (pAliasItem->wType)
  {
  case CC_ALIAS_H323_ID:
    pAlias->value.choice = h323_ID_chosen;
    pAlias->value.u.h323_ID.value = MemAlloc((uPrefixLength + uDataLength) * sizeof(pAliasItem->pData[0]));
    if (pAlias->value.u.h323_ID.value == NULL)
    {
      ISRERROR(ghISRInst, "CopyAliasItem: Could not allocate %d bytes memory",
               (uPrefixLength + uDataLength) * sizeof(pAliasItem->pData[0]));
      return CC_NO_MEMORY;
    }
    if (uPrefixLength)
    {
      memcpy(&pAlias->value.u.h323_ID.value[0],
             pAliasItem->pPrefix,
             uPrefixLength * sizeof(pAliasItem->pPrefix[0]));
      memcpy(&pAlias->value.u.h323_ID.value[uPrefixLength],
             pAliasItem->pData,
             uDataLength * sizeof(pAliasItem->pData[0]));
    }
    else
    {
      memcpy(&pAlias->value.u.h323_ID.value[0],
             pAliasItem->pData,
             uDataLength * sizeof(pAliasItem->pData[0]));
    }
    pAlias->value.u.h323_ID.length = (unsigned short)(uPrefixLength + uDataLength);
    break;

  case CC_ALIAS_H323_PHONE:
    pAlias->value.choice = e164_chosen;
    if (uPrefixLength)
    {
      for (uDigit = 0; uDigit < uPrefixLength; ++uDigit)
      {
        pAlias->value.u.e164[uDigit] = (char)pAliasItem->pPrefix[uDigit];
      }
      for (uDigit = 0; uDigit < uDataLength; ++uDigit)
      {
        pAlias->value.u.e164[uDigit + uPrefixLength] = (char)pAliasItem->pData[uDigit];
      }
    }
    else
    {
      for (uDigit = 0; uDigit < uDataLength; ++uDigit)
      {
        pAlias->value.u.e164[uDigit] = (char)pAliasItem->pData[uDigit];
      }
    }
    break;

  default:
    ISRERROR(ghISRInst, "CopyAliasItem: Bad alias name type %d", pAliasItem->wType);
    return CC_BAD_PARAM;
  } // switch

  return NOERROR;
} // CopyAliasItem()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

static void GkiAllocCall(PGKICALL pGkiCall, HANDLE hGkiCall)
{
  ASSERT(pGkiCall != NULL);
  ASSERT(hGkiCall != 0);
  ASSERT(hGkiCall != GKI_ADMITTING_HANDLE);
  pGkiCall->hGkiCall = hGkiCall;
  pGkiCall->uGkiCallState = GCS_ADMITTED;
  ++uGkiCalls;
  ISRTRACE(ghISRInst, "GkiAllocCall: uGkiCalls = %d", uGkiCalls);
} // GkiAllocCall()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

static HRESULT GkiCancelCall(PGKICALL pGkiCall, void *pConference)
{
  CC_HCALL hCall;

  ASSERT(pGkiCall != NULL);
  pConference = pConference;            // Disable compiler warning
  hCall = pGkiCall->hCall;

  ISRTRACE(ghISRInst, CallStateName("GkiCancelCall <- Call State = %s", pGkiCall->uGkiCallState), 0);

  switch (pGkiCall->uGkiCallState)
  {
  case GCS_START:
    break;

  case GCS_WAITING:
    ASSERT(pGkiCall->hGkiCall == 0);
    if (pGkiCall->bAnswerCall)
      AcceptCallReject(pGkiCall->pCall, pConference, CC_GATEKEEPER_REFUSED);
    else
      PlaceCallReject (pGkiCall->pCall, pConference, CC_GATEKEEPER_REFUSED);
    break;

  case GCS_ADMITTING:
  case GCS_ADMITTING_CLOSE_PENDING:
    ASSERT(pGkiCall->hGkiCall == GKI_ADMITTING_HANDLE);
    if (pGkiCall->bAnswerCall)
      AcceptCallReject(pGkiCall->pCall, pConference, CC_GATEKEEPER_REFUSED);
    else
      PlaceCallReject (pGkiCall->pCall, pConference, CC_GATEKEEPER_REFUSED);
    break;

  case GCS_ADMITTED:
  case GCS_CHANGING:
  case GCS_CHANGING_CLOSE_PENDING:
  case GCS_DISENGAGING:
    ASSERT(pGkiCall->hGkiCall != 0);
    ASSERT(pGkiCall->hGkiCall != GKI_ADMITTING_HANDLE);
    Disengage(pGkiCall->pCall);
    return NOERROR;

  default:
    ISRERROR(ghISRInst, "GkiCancelCall: Invalid call state %d", pGkiCall->uGkiCallState);
  } // switch

  if (ValidateCall(hCall) == NOERROR && pGkiCall->uGkiCallState != GCS_START)
  {
    GkiFreeCall(pGkiCall);
  }

  ISRTRACE(ghISRInst, CallStateName("GkiCancelCall -> Call State = %s", pGkiCall->uGkiCallState), 0);
  return NOERROR;
} // GkiCancelCall()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

static HRESULT GkiCancelAdmitting(PGKICALL pGkiCall, void *pConference)
{
  ASSERT(pGkiCall != NULL);
  pConference = pConference;            // Disable compiler warning

  ISRTRACE(ghISRInst, CallStateName("GkiCancelAdmitting <- Call State = %s", pGkiCall->uGkiCallState), 0);

  switch (pGkiCall->uGkiCallState)
  {
  case GCS_ADMITTING:
    ASSERT(pGkiCall->hGkiCall == GKI_ADMITTING_HANDLE);
    pGkiCall->hGkiCall = 0;
    pGkiCall->uGkiCallState = GCS_WAITING;
    break;

  case GCS_ADMITTING_CLOSE_PENDING:
    ASSERT(pGkiCall->hGkiCall == GKI_ADMITTING_HANDLE);
    GkiFreeCall(pGkiCall);
    break;

  } // switch

  ISRTRACE(ghISRInst, CallStateName("GkiCancelAdmitting -> Call State = %s", pGkiCall->uGkiCallState), 0);
  return NOERROR;
} // GkiCancelAdmitting()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

static HRESULT CheckPendingBandwidth(PGKICALL pGkiCall);

static HRESULT GatekeeperNotFound(PGKICALL pGkiCall, void *pConference)
{
  ASSERT(pGkiCall != NULL);
  ASSERT(pConference != NULL);

  ISRTRACE(ghISRInst, CallStateName("GatekeeperNotFound <- Call State = %s", pGkiCall->uGkiCallState), 0);

  switch (pGkiCall->uGkiCallState)
  {
  case GCS_START:
  case GCS_ADMITTED:
    break;

  case GCS_WAITING:
  case GCS_ADMITTING:
    GkiOpenCall(pGkiCall, pConference);
    break;

  case GCS_ADMITTING_CLOSE_PENDING:
  case GCS_CHANGING_CLOSE_PENDING:
  case GCS_DISENGAGING:
    GkiCloseCall(pGkiCall);
    break;

  case GCS_CHANGING:
    pGkiCall->uGkiCallState = GCS_ADMITTED;
    pGkiCall->uBandwidthAllocated = MAX_BANDWIDTH;
    CheckPendingBandwidth(pGkiCall);
    break;

  default:
    ISRERROR(ghISRInst, "GatekeeperNotFound: Invalid call state %d", pGkiCall->uGkiCallState);
  } // switch

  ISRTRACE(ghISRInst, CallStateName("GatekeeperNotFound -> Call State = %s", pGkiCall->uGkiCallState), 0);
  return NOERROR;
} // GatekeeperNotFound()



/*
 *  NOTES
 *    GkiLock must be locked before calling this routine!
 */

HRESULT GkiRegister(void)
{
  register HRESULT      status = NOERROR;

  ASSERT(pListenList != NULL);

  switch (uGkiState)
  {
  case STATE_START:
    // Register window class
    {
      WNDCLASS wndclass = { 0, GkiWndProc, 0, 0, 0, 0, 0, 0, NULL, szClassName };
      atomGki = RegisterClass(&wndclass);
      if (atomGki == 0)
      {
        status = HRESULT_FROM_WIN32(GetLastError());
        ISRERROR(ghISRInst, "GkiRegister: Error 0x%x registering class", status);
        break;
      }
    }
    uGkiState = STATE_CLASS_REGISTERED;

  // Fall-through to next case

  case STATE_CLASS_REGISTERED:
    // Create window to receive GKI messages
    hwndGki = CreateWindow(szClassName, "", WS_OVERLAPPED, 0, 0, 0, 0, 0, 0, 0, NULL);
    if (hwndGki == 0)
    {
      status = HRESULT_FROM_WIN32(GetLastError());
      ISRERROR(ghISRInst, "GkiRegister: Error 0x%x creating window", status);
      break;
    }
    uGkiState = STATE_WINDOW_CREATED;

    // Fall-through to next case

  case STATE_WINDOW_CREATED:
    {
      PLISTEN           pListen;
      unsigned          uListens    = 0;
      unsigned          uAliasNames = 0;
      SeqTransportAddr *pTransportAddrs;
      SeqAliasAddr     *pAliasAddrs = NULL;
      SeqAliasAddr     *pRegistrationAliasAddrs = NULL;
      PCC_ALIASITEM     pAliasItem;
      unsigned          uIndex;
      unsigned          uDigit;
      EndpointType      TerminalType = {0};

      // Count Transport Addresses and Alias Names
      pListen = pListenList;
      while (pListen)
      {
        // Count the Transport Address
        ++uListens;

        if (pListen->pAliasNames)
        {
          // Count the Alias Names
          uAliasNames += pListen->pAliasNames->wCount;
        }
        pListen = pListen->pNext;
      }

      // if the separately configured alias names exist, override what was
      // in the listen list
      if(gpLocalAliasNames)
      {
        uAliasNames = gpLocalAliasNames->wCount;
      }

      pTransportAddrs = MemAlloc(uListens * sizeof(*pTransportAddrs));
      if (pTransportAddrs == NULL)
      {
        ISRERROR(ghISRInst, "GkiRegister: Could not allocate %d Transport Addresses", uListens);
        return CC_NO_MEMORY;
      }

      if (uAliasNames)
      {
        pAliasAddrs =
            MemAlloc(uAliasNames * sizeof(*pAliasAddrs));
        if (pAliasAddrs == NULL)
        {
          MemFree(pTransportAddrs);
          ISRERROR(ghISRInst, "GkiRegister: Could not allocate %d Alias Addresses", uAliasNames);
          return CC_NO_MEMORY;
        }
      }

      pListen     = pListenList;
      uListens    = 0;
      uAliasNames = 0;
      // if the separately configured alias names exist, override what was
      // in the listen list
      if(gpLocalAliasNames)
      {
          pAliasItem = gpLocalAliasNames->pItems;
          for (uIndex = 0; uIndex < gpLocalAliasNames->wCount; ++uIndex, ++pAliasItem)
          {
            pAliasAddrs[uAliasNames].next = &pAliasAddrs[uAliasNames + 1];
            switch (pAliasItem->wType)
            {
            case CC_ALIAS_H323_ID:
              pAliasAddrs[uAliasNames].value.choice = h323_ID_chosen;
              pAliasAddrs[uAliasNames].value.u.h323_ID.length = pAliasItem->wDataLength;
              pAliasAddrs[uAliasNames].value.u.h323_ID.value  = pAliasItem->pData;
              break;

            case CC_ALIAS_H323_PHONE:
              pAliasAddrs[uAliasNames].value.choice = e164_chosen;
              memset(pAliasAddrs[uAliasNames].value.u.e164, 0, sizeof(pAliasAddrs[uAliasNames].value.u.e164));
              for (uDigit = 0; uDigit < pAliasItem->wDataLength; ++uDigit)
              {
                pAliasAddrs[uAliasNames].value.u.e164[uDigit] = (char)pAliasItem->pData[uDigit];
              }
              break;

            default:
              MemFree(pAliasAddrs);
              ISRERROR(ghISRInst, "GkiRegister: Bad alias name type %d",
                      pAliasItem->wType);
              return CC_BAD_PARAM;
            } // switch
            ++uAliasNames;
          } // for
      }
      while (pListen)
      {
        // Initialize a transport address
        // TBD - throw out duplicates
        pTransportAddrs[uListens].next = &pTransportAddrs[uListens + 1];
        pTransportAddrs[uListens].value.choice = ipAddress_chosen;
        pTransportAddrs[uListens].value.u.ipAddress.ip.length = 4;
        *((DWORD *)pTransportAddrs[uListens].value.u.ipAddress.ip.value) = pListen->dwAddr;
        pTransportAddrs[uListens].value.u.ipAddress.port = pListen->wPort;

        // Add any alias names to list (unless separately configured alias names exist)
        // TBD - throw out duplicates
        if ((gpLocalAliasNames == NULL) && pAliasAddrs && pListen->pAliasNames)
        {
          pAliasItem = pListen->pAliasNames->pItems;
          for (uIndex = 0; uIndex < pListen->pAliasNames->wCount; ++uIndex, ++pAliasItem)
          {
            pAliasAddrs[uAliasNames].next = &pAliasAddrs[uAliasNames + 1];
            switch (pAliasItem->wType)
            {
            case CC_ALIAS_H323_ID:
              pAliasAddrs[uAliasNames].value.choice = h323_ID_chosen;
              pAliasAddrs[uAliasNames].value.u.h323_ID.length = pAliasItem->wDataLength;
              pAliasAddrs[uAliasNames].value.u.h323_ID.value  = pAliasItem->pData;
              break;

            case CC_ALIAS_H323_PHONE:
              pAliasAddrs[uAliasNames].value.choice = e164_chosen;
              memset(pAliasAddrs[uAliasNames].value.u.e164, 0, sizeof(pAliasAddrs[uAliasNames].value.u.e164));
              for (uDigit = 0; uDigit < pAliasItem->wDataLength; ++uDigit)
              {
                pAliasAddrs[uAliasNames].value.u.e164[uDigit] = (char)pAliasItem->pData[uDigit];
              }
              break;

            default:
              MemFree(pAliasAddrs);
              MemFree(pTransportAddrs);
              ISRERROR(ghISRInst, "GkiRegister: Bad alias name type %d",
                      pAliasItem->wType);
              return CC_BAD_PARAM;
            } // switch
            ++uAliasNames;
          } // for
        } // if
        ++uListens;
        pListen = pListen->pNext;
      } // while
      pTransportAddrs[uListens - 1].next = NULL;
      if (pAliasAddrs)
      {
        pAliasAddrs[uAliasNames - 1].next = NULL;
      }

      // Initialize TerminalType
      TerminalType.bit_mask = terminal_present;
      TerminalType.mc = (g_dwMultipointConfiguration)?TRUE:FALSE;

      uGkiState = STATE_REGISTERING;
      ISRTRACE(ghISRInst, "GKI_RegistrationRequest called...", 0);
      status =
        pGKI_RegistrationRequest(GKI_VERSION,       // lVersion
                                 pTransportAddrs,   // pCallSignalAddr
                                 &TerminalType,     // pTerminalType
                                 pAliasAddrs,       // pRgstrtnRgst_trmnlAls
                                 gpVendorInfo,
                                 hwndGki,           // hWnd
                                 GKIMAN_BASE,       // wBaseMessage
                                 ipAddress_chosen); // usRegistrationTransport
      if (status == NOERROR)
      {
        ISRTRACE(ghISRInst, GkiErrorName("GKI_RegistrationRequest returned %s", status), 0);
      }
      else
      {
        ISRERROR(ghISRInst, GkiErrorName("GKI_RegistrationRequest returned %s", status), 0);
        uGkiState = STATE_WINDOW_CREATED;
      }
      if (pAliasAddrs)
        MemFree(pAliasAddrs);
      if (pTransportAddrs)
        MemFree(pTransportAddrs);
    }
    break;

  case STATE_REGISTERING:
  case STATE_REGISTERING_REREG:
  case STATE_REGISTERING_UNREG:
    uGkiState = STATE_REGISTERING_REREG;
    break;

  case STATE_REGISTERED:
    uGkiState = STATE_UNREGISTERING_REREG;
    ISRTRACE(ghISRInst, "GKI_UnregistrationRequest called...", 0);
    status = pGKI_UnregistrationRequest();
    if (status == NOERROR)
    {
      ISRTRACE(ghISRInst, GkiErrorName("GKI_UnregistrationRequest returned %s", status), 0);
    }
    else
    {
      ISRERROR(ghISRInst, GkiErrorName("GKI_UnregistrationRequest returned %s", status), 0);
      uGkiState = STATE_REG_BYPASS;
      ApplyToAllCalls(GatekeeperNotFound);
    }
    break;

  case STATE_ADMITTING:
  case STATE_ADMITTING_REREG:
  case STATE_ADMITTING_UNREG:
    uGkiState = STATE_ADMITTING_REREG;
    break;

  case STATE_DISENGAGING:
    uGkiState = STATE_DISENGAGING_REREG;
    break;

  case STATE_DISENGAGING_REREG:
    break;

  case STATE_UNREGISTERING:
    uGkiState = STATE_UNREGISTERING_REREG;
    break;

  case STATE_UNREGISTERING_REREG:
    break;

  case STATE_REG_BYPASS:
    break;

  default:
    ISRERROR(ghISRInst, "GkiRegister: Invalid state %d", uGkiState);
    status = LastGkiError;
  } // switch

  return status;
} // GkiRegister()



/*
 *  NOTES
 *    GkiLock must be locked before calling this routine!
 */

HRESULT GkiCloseCallNoError(PGKICALL pGkiCall, void *pConference)
{
  ASSERT(GKIExists());
  ASSERT(pGkiCall != NULL);
  pConference = pConference;            // Disable compiler warning
  if (pGkiCall->uGkiCallState != GCS_START)
    GkiCloseCall(pGkiCall);
  return NOERROR;
} // GkiCloseCallNoError()

HRESULT GkiUnregister(void)
{
  register HRESULT      status = NOERROR;
  switch (uGkiState)
  {
  case STATE_REG_BYPASS:
    ApplyToAllCalls(GkiCancelCall);
    uGkiState = STATE_WINDOW_CREATED;
    break;

  case STATE_UNREGISTERING_REREG:
    uGkiState = STATE_UNREGISTERING;
    break;

  case STATE_UNREGISTERING:
    break;

  case STATE_DISENGAGING_REREG:
    if (uGkiCalls != 0 || uPendingDisengages != 0)
    {
      uGkiState = STATE_DISENGAGING;
    }
    else
    {
      uGkiState = STATE_REGISTERED;
      return GkiUnregister();
    }
    break;

  case STATE_DISENGAGING:
    if (uGkiCalls == 0 && uPendingDisengages == 0)
    {
      uGkiState = STATE_REGISTERED;
      return GkiUnregister();
    }
    break;

  case STATE_ADMITTING_UNREG:
  case STATE_ADMITTING_REREG:
  case STATE_ADMITTING:
    uGkiState = STATE_ADMITTING_UNREG;
    break;

  case STATE_REGISTERING_UNREG:
  case STATE_REGISTERING_REREG:
  case STATE_REGISTERING:
    uGkiState = STATE_REGISTERING_UNREG;
    break;

  case STATE_REGISTERED:
    if (uGkiCalls)
    {
      // Issue Disengage Request for every call
      uGkiState = STATE_DISENGAGING;
      ApplyToAllCalls(GkiCloseCallNoError);
      break;

    }
    else
    {
      // Issue Unregistration Request
      uGkiState = STATE_UNREGISTERING;
      ISRTRACE(ghISRInst, "GKI_UnregistrationRequest called...", 0);
      status = pGKI_UnregistrationRequest();
      if (status == NOERROR)
      {
        ISRTRACE(ghISRInst, GkiErrorName("GKI_UnregistrationRequest returned %s", status), 0);
      }
      else
      {
        ISRERROR(ghISRInst, GkiErrorName("GKI_UnregistrationRequest returned %s", status), 0);
        uGkiState = STATE_WINDOW_CREATED;
      }
    }
    break;

  case STATE_WINDOW_CREATED:
  case STATE_CLASS_REGISTERED:
  case STATE_START:
    ISRWARNING(ghISRInst, StateName("GkiUnregister: Already in uninitialized state %s", uGkiState), 0);
    status = LastGkiError;
    break;

  default:
    ISRERROR(ghISRInst, "GkiUnregister: Invalid state %d", uGkiState);
    status = LastGkiError;
  } // switch

  return status;
} // GkiUnregister()



void DeInitGkiManager(void)
{
  register PLISTEN      pListen;

  if(!fGKConfigured)
        return;

  EnterCriticalSection(&GkiLock);

#if 0
  // TBD - When called from DllMain PROCESS_DETACH, this does not work because
  // apparently the socket to the Gatekeeper has already been closed.
  if (uGkiState != STATE_START)
  {
    GkiUnregister();
    uGkiState = STATE_START;
  }
#else
  uGkiState = STATE_START;
#endif

  while (pListenList)
  {
    pListen = pListenList;
    pListenList = pListenList->pNext;
    if (pListen->pAliasNames)
    {
      FreeAliasNames(pListen->pAliasNames);
    }
    MemFree(pListen);
  }

  pGKI_RegistrationRequest   = NULL;
  pGKI_UnregistrationRequest = NULL;
  pGKI_LocationRequest       = NULL;
  pGKI_AdmissionRequest      = NULL;
  pGKI_BandwidthRequest      = NULL;
  pGKI_DisengageRequest      = NULL;
  pGKI_Initialize            = NULL;

  if (pGKI_CleanupRequest)
	  pGKI_CleanupRequest();

  pGKI_CleanupRequest = NULL;

  LeaveCriticalSection(&GkiLock);
  DeleteCriticalSection(&GkiLock);

	if (NULL != hwndGki)
	{
		DestroyWindow(hwndGki);
	}
} // DeInitGkiManager()



HRESULT InitGkiManager(void)
{
    HRESULT hr = CC_GKI_LOAD;
    InitializeCriticalSection(&GkiLock);

    pGKI_RegistrationRequest   = (PGKI_RegistrationRequest)     GKI_RegistrationRequest;
    pGKI_UnregistrationRequest = (PGKI_UnregistrationRequest)   GKI_UnregistrationRequest;
    pGKI_LocationRequest       = (PGKI_LocationRequest)         GKI_LocationRequest;
    pGKI_AdmissionRequest      = (PGKI_AdmissionRequest)        GKI_AdmissionRequest;
    pGKI_BandwidthRequest      = (PGKI_BandwidthRequest)        GKI_BandwidthRequest;
    pGKI_DisengageRequest      = (PGKI_DisengageRequest)        GKI_DisengageRequest;
    pGKI_CleanupRequest        = (PGKI_CleanupRequest)          GKI_CleanupRequest;
    pGKI_Initialize            = (PGKI_Initialize)              GKI_Initialize;

    hr = pGKI_Initialize();
    if(hr != GKI_OK)
    {
        DeleteCriticalSection(&GkiLock);
        DeInitGkiManager();
    }
    else
    {
        fGKConfigured = TRUE;
    }
    return hr;
} // InitGkiManager()



//
// Entry Points
//

HRESULT GkiFreeCall(PGKICALL pGkiCall)
{
  HRESULT               status = NOERROR;
  ASSERT(pGkiCall != NULL);
  ASSERT(pGkiCall->uGkiCallState != GCS_START);
  pGkiCall->hGkiCall = 0;

  while (pGkiCall->pBwReqHead)
  {
    MemFree(BwReqDequeue(pGkiCall));
  }

  if (pGkiCall->pCalleeAliasNames)
  {
	Q931FreeAliasNames(pGkiCall->pCalleeAliasNames);
    pGkiCall->pCalleeAliasNames = NULL;
  }

  if (pGkiCall->pCalleeExtraAliasNames != NULL)
  {
	Q931FreeAliasNames(pGkiCall->pCalleeExtraAliasNames);
    pGkiCall->pCalleeExtraAliasNames = NULL;
  }

  switch (pGkiCall->uGkiCallState)
  {
  case GCS_START:
  case GCS_WAITING:
    break;

  case GCS_ADMITTING:
    ASSERT(uGkiState == STATE_ADMITTING);
    switch (uGkiState)
    {
    case STATE_ADMITTING:
      uGkiState = STATE_REGISTERED;
      break;
    } // switch
    break;

  case GCS_ADMITTING_CLOSE_PENDING:
    ASSERT(uGkiState == STATE_ADMITTING || uGkiState == STATE_ADMITTING_UNREG || uGkiState == STATE_ADMITTING_REREG);
    switch (uGkiState)
    {
    case STATE_ADMITTING:
      uGkiState = STATE_REGISTERED;
      break;
    case STATE_ADMITTING_UNREG:
      uGkiState = STATE_REGISTERED;
      status = GkiUnregister();
      break;
    case STATE_ADMITTING_REREG:
      uGkiState = STATE_REGISTERED;
      status = GkiRegister();
      break;
    } // switch
    break;

  case GCS_ADMITTED:
  case GCS_CHANGING:
  case GCS_CHANGING_CLOSE_PENDING:
  case GCS_DISENGAGING:
    --uGkiCalls;
    ISRTRACE(ghISRInst, "GkiFreeCall: uGkiCalls = %d", uGkiCalls);
    break;

  default:
    ISRERROR(ghISRInst, "GkiFreeCall: Invalid call state %d", pGkiCall->uGkiCallState);
  } // switch

  pGkiCall->uGkiCallState = GCS_START;

  if (uGkiCalls == 0 && uPendingDisengages == 0)
  {
    switch (uGkiState)
    {
    case STATE_DISENGAGING:
      uGkiState = STATE_REGISTERED;
      status = GkiUnregister();
      break;
    case STATE_DISENGAGING_REREG:
      uGkiState = STATE_REGISTERED;
      status = GkiRegister();
      break;
    } // switch

  }

  return status;
} // GkiFreeCall()



HRESULT GkiCloseListen  (CC_HLISTEN hListen)
{
  register PLISTEN      pListen;
  register HRESULT      status;
  ISRTRACE(ghISRInst, StateName("GkiCloseListen <- State = %s", uGkiState), 0);
  EnterCriticalSection(&GkiLock);

  pListen = ListenDequeue(hListen);
  if (pListen == NULL)
  {
    status = CC_GKI_LISTEN_NOT_FOUND;
  }
  else
  {
    if (pListen->pAliasNames)
    {
      FreeAliasNames(pListen->pAliasNames);
    }
    MemFree(pListen);
    if (pListenList)
    {
      status = GkiRegister();
    }
    else
    {
      status = GkiUnregister();
    }
  }

  LeaveCriticalSection(&GkiLock);
  ISRTRACE(ghISRInst, StateName("GkiCloseListen -> State = %s", uGkiState), 0);
  return status;
} // GkiCloseListen()


HRESULT GkiSetVendorConfig(  PCC_VENDORINFO pVendorInfo,
    DWORD dwMultipointConfiguration)
{
    HRESULT status = CC_OK;

    EnterCriticalSection(&GkiLock);
    if(gpVendorInfo)
    {
        FreeVendorInfo(gpVendorInfo);
        gpVendorInfo = NULL;
    }
    if (!pVendorInfo)
    {
        // everything is cleaned up, so return
        LeaveCriticalSection(&GkiLock);
        return status;
    }
    status = CopyVendorInfo(&gpVendorInfo, pVendorInfo);
    if (status != NOERROR)
    {
        ISRERROR(ghISRInst, "GkiSetRegistrationAliases: CopyVendorInfo returned 0x%x", status);
        LeaveCriticalSection(&GkiLock);
        return status;
    }
    g_dwMultipointConfiguration = dwMultipointConfiguration;
    LeaveCriticalSection(&GkiLock);
    return status;
}

HRESULT GkiSetRegistrationAliases(PCC_ALIASNAMES pLocalAliasNames)
{
    HRESULT      status = CC_OK;

    EnterCriticalSection(&GkiLock);
    if(gpLocalAliasNames)
    {
        FreeAliasNames(gpLocalAliasNames);
        gpLocalAliasNames = NULL;
    }
    if (!pLocalAliasNames)
    {
        // everything is cleaned up, so return
        LeaveCriticalSection(&GkiLock);
        return status;
    }
    status = CopyAliasNames(&gpLocalAliasNames, pLocalAliasNames);
    if (status != NOERROR)
    {
        ISRERROR(ghISRInst, "GkiSetRegistrationAliases: CopyAliasNames returned 0x%x", status);
        LeaveCriticalSection(&GkiLock);
        return status;
    }
    LeaveCriticalSection(&GkiLock);
    return status;
}

HRESULT  GkiOpenListen  (CC_HLISTEN hListen, PCC_ALIASNAMES pAliasNames, DWORD dwAddr, WORD wPort)
{
  register PLISTEN      pListen;
  register HRESULT      status = NOERROR;
  ISRTRACE(ghISRInst, StateName("GkiOpenListen <- State = %s", uGkiState), 0);
  EnterCriticalSection(&GkiLock);

  // dwAddr, wPort are in host byte order
  // Check for invalid IP address
  if (dwAddr == INADDR_ANY || dwAddr == INADDR_NONE)
  {
    // this doesn't neccessarily get the correct IP address on a multi-homed
    // machine, but it at least tests to see if IP is configured on this
    // box.
    dwAddr = GetIpAddress();
    if (dwAddr == INADDR_ANY)
    {
         LeaveCriticalSection(&GkiLock);
         return CC_GKI_IP_ADDRESS;
    }
  }

  // Check for invalid alias list
  if (pAliasNames)
  {
    PCC_ALIASITEM       pAliasItem;
    unsigned int        uIndex;

    if (pAliasNames->wCount == 0)
    {
      ISRERROR(ghISRInst, "GkiOpenListen: Alias name wCount == 0", 0);
      return CC_BAD_PARAM;
    }
    pAliasItem = pAliasNames->pItems;
    for (uIndex = 0; uIndex < pAliasNames->wCount; ++uIndex, ++pAliasItem)
    {
      if (pAliasItem->wDataLength == 0 || pAliasItem->pData == NULL)
      {
        // Bad alias item
        ISRERROR(ghISRInst, "GkiOpenListen: Bad alias item (wDataLength = %d)",
                pAliasItem->wDataLength);
        return CC_BAD_PARAM;
      }
    }
  }

  pListen = (PLISTEN)MemAlloc(sizeof(*pListen));
  if (pListen)
  {
    if (pAliasNames)
    {
      status = CopyAliasNames(&pListen->pAliasNames, pAliasNames);
      if (status != NOERROR)
      {
        ISRERROR(ghISRInst, "GkiOpenListen: CopyAliasNames returned 0x%x", status);
        LeaveCriticalSection(&GkiLock);
        return status;
      }
    }
    else
    {
      pListen->pAliasNames = NULL;
    }

    pListen->hListen = hListen;
    pListen->dwAddr  = htonl(dwAddr);
    pListen->wPort   = wPort;
    ListenEnqueue(pListen);
    if(GKIExists())
    {
        status = GkiRegister();
    }
  } // if
  else
  {
    ISRERROR(ghISRInst, "GkiOpenListen: Could not allocate listen structure", 0);
    status = CC_NO_MEMORY;
  } // else

  LeaveCriticalSection(&GkiLock);
  ISRTRACE(ghISRInst, StateName("GkiOpenListen -> State = %s", uGkiState), 0);
  return status;
} // GkiOpenListen()


HRESULT  GkiListenAddr (SOCKADDR_IN* psin)
{

  PLISTEN      pListen = pListenList;
  HRESULT      status = NOERROR;

  SOCKADDR_IN srem;
  SOCKADDR_IN sloc;

  ASSERT(psin);
  ASSERT(pListen != NULL);

  // try and get the best interface given the dwAddr passed in to us
  srem.sin_family = AF_INET;
  srem.sin_port = htons(7); // give echo a try since most GKs are unix-based
  srem.sin_addr.s_addr = psin->sin_addr.s_addr;

  status = NMGetBestInterface(&srem, &sloc);

  if (status == NOERROR)
  {
      EnterCriticalSection(&GkiLock);
      while (pListen)
      {
        pListen->dwAddr  = sloc.sin_addr.s_addr;
        pListen = pListen->pNext;
      }
      LeaveCriticalSection(&GkiLock);
  }
  return status;
} // GkiListenAddr()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

HRESULT GkiCloseCall(PGKICALL pGkiCall)
{
  HRESULT               status = NOERROR;
  ASSERT(GKIExists());
  ASSERT(pGkiCall != NULL);
  ISRTRACE(ghISRInst, CallStateName("GkiCloseCall <- Call State = %s", pGkiCall->uGkiCallState), 0);

  while (pGkiCall->pBwReqHead)
  {
    MemFree(BwReqDequeue(pGkiCall));
  }

  if (pGkiCall->uGkiCallState == GCS_START)
  {
    ISRWARNING(ghISRInst, CallStateName("GkiCloseCall: Call already in state %s", pGkiCall->uGkiCallState), 0);
    status = CC_GKI_CALL_STATE;
  }
  else
  {
    switch (uGkiState)
    {
    case STATE_START:
      break;

    case STATE_REG_BYPASS:
      status = GkiFreeCall(pGkiCall);
      break;

    default:
      switch (pGkiCall->uGkiCallState)
      {
      case GCS_WAITING:
        status = GkiFreeCall(pGkiCall);
        break;

      case GCS_ADMITTING:
        pGkiCall->uGkiCallState = GCS_ADMITTING_CLOSE_PENDING;
        break;

      case GCS_ADMITTING_CLOSE_PENDING:
      case GCS_CHANGING_CLOSE_PENDING:
      case GCS_DISENGAGING:
        ISRWARNING(ghISRInst, CallStateName("GkiCloseCall: Call already in closing state %s", pGkiCall->uGkiCallState), 0);
        status = CC_GKI_CALL_STATE;
        break;

      case GCS_ADMITTED:
        pGkiCall->uGkiCallState = GCS_DISENGAGING;
        ISRTRACE(ghISRInst, "GKI_DisengageRequest called...", 0);
        ++uPendingDisengages;
        status = pGKI_DisengageRequest(pGkiCall->hGkiCall);
        if (status == NOERROR)
        {
          ISRTRACE(ghISRInst, GkiErrorName("GKI_DisengageRequest returned %s", status), 0);
        }
        else
        {
          --uPendingDisengages;
          ISRERROR(ghISRInst, GkiErrorName("GKI_DisengageRequest returned %s", status), 0);
          GkiFreeCall(pGkiCall);
        }
        break;

      case GCS_CHANGING:
        pGkiCall->uGkiCallState = GCS_CHANGING_CLOSE_PENDING;
        break;

      default:
        ISRERROR(ghISRInst, CallStateName("GkiCloseCall: Call in invalid state %s", pGkiCall->uGkiCallState), 0);
        status = CC_GKI_CALL_STATE;
      } // switch
    } // switch
  } // else

  ISRTRACE(ghISRInst, StateName("GkiCloseCall -> State = %s", uGkiState), 0);
  return status;
} // GkiCloseCall()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

static HRESULT BandwidthRejected(PGKICALL pGkiCall, UINT Reason)
{
  HRESULT               status = NOERROR;
  PBWREQ                pBwReq;
  CC_HCALL              hCall;

  ASSERT(pGkiCall != NULL);
  pBwReq = BwReqDequeue(pGkiCall);
  hCall  = pGkiCall->hCall;

  if (pBwReq)
  {
    if ((pGkiCall->uBandwidthUsed + pBwReq->uChannelBandwidth) <= pGkiCall->uBandwidthAllocated)
    {
      if (pBwReq->Type == TX)
      {
        OpenChannelConfirm  (pBwReq->hChannel);
      }
      else
      {
        AcceptChannelConfirm(pBwReq->hChannel);
      }
    }
    else
    {
      if (pBwReq->Type == TX)
      {
        OpenChannelReject   (pBwReq->hChannel, MapBandwidthRejectReason(Reason));
      }
      else
      {
        AcceptChannelReject (pBwReq->hChannel, MapBandwidthRejectReason(Reason));
      }
    }
    MemFree(pBwReq);
    if (ValidateCall(hCall) == NOERROR)
    {
      CheckPendingBandwidth(pGkiCall);
    }
  }

  return status;
} // BandwidthRejected()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

static HRESULT CheckPendingBandwidth(PGKICALL pGkiCall)
{
  HRESULT               status = NOERROR;
  PBWREQ                pBwReq;
  CC_HCALL              hCall;

  ASSERT(pGkiCall != NULL);
  ASSERT(pGkiCall->uGkiCallState == GCS_ADMITTED);
  hCall = pGkiCall->hCall;

  while (pGkiCall->pBwReqHead != NULL &&
         (pGkiCall->uBandwidthUsed + pGkiCall->pBwReqHead->uChannelBandwidth) <= pGkiCall->uBandwidthAllocated)
  {
    pBwReq = BwReqDequeue(pGkiCall);
    ASSERT(pBwReq != NULL);
    pGkiCall->uBandwidthUsed += pBwReq->uChannelBandwidth;
    if (pBwReq->Type == TX)
    {
      OpenChannelConfirm(pBwReq->hChannel);
    }
    else
    {
      AcceptChannelConfirm(pBwReq->hChannel);
    }
    MemFree(pBwReq);
    if (ValidateCall(hCall) != NOERROR)
    {
      return status;
    }
  }

  if (pGkiCall->pBwReqHead != NULL)
  {
    pGkiCall->uGkiCallState = GCS_CHANGING;
    ISRTRACE(ghISRInst, "GKI_BandwidthRequest called...", 0);
    status = pGKI_BandwidthRequest(pGkiCall->hGkiCall,
                                   pGkiCall->usCallTypeChoice,
                                   pGkiCall->uBandwidthUsed + pGkiCall->pBwReqHead->uChannelBandwidth);
    if (status == NOERROR)
    {
      ISRTRACE(ghISRInst, GkiErrorName("GKI_BandwidthRequest returned %s", status), 0);
    }
    else
    {
      ISRERROR(ghISRInst, GkiErrorName("GKI_BandwidthRequest returned %s", status), 0);
      BandwidthRejected(pGkiCall, BndRjctRsn_undfndRsn_chosen);
    }
  }

  return status;
} // CheckPendingBandwidth()



static void FreeAliasList(SeqAliasAddr *pAliasAddrs)
{
  register SeqAliasAddr *pAlias = pAliasAddrs;
  while (pAlias)
  {
    if (pAlias->value.choice == h323_ID_chosen && pAlias->value.u.h323_ID.value)
      MemFree(pAlias->value.u.h323_ID.value);
    pAlias = pAlias->next;
  }
  MemFree(pAlias);
} // FreeAliasList()



/*
 *  NOTES
 *    Must have Call locked before calling!
 *
 *    The following fields in the GKICALL structure must be properly filled
 *    in before calling this function:
 *      pCall                 Pointer back to containing CALL structure.
 *      CallType              Type of call.
 *      uBandwidthRequested   Initial bandwidth for call.
 *      pConferenceId         Pointer to conference ID buffer.
 *      bActiveMC             TRUE if calling party has an active MC.
 *      bAnswerCall           ???
 *      CallIdentifier  the GUID identifying this call. This must be the same
 *                      value as CallIdentifier of the Q.931 messages.
 */

HRESULT GkiOpenCall (PGKICALL pGkiCall, void *pConference)
{
  HRESULT               status = NOERROR;
  CC_HCALL              hCall;
  TransportAddress      DestCallSignalAddress;
  TransportAddress *    pDestCallSignalAddress;
  SeqAliasAddr *        pAliasAddrs;
  SeqAliasAddr *        pExtraAliasAddrs;
  SeqAliasAddr *        pAlias;
  PCC_ALIASITEM         pAliasItem;
  unsigned              uCount;
  unsigned              uIndex;
  ConferenceIdentifier  ConferenceId;

  ASSERT(GKIExists());
  ASSERT(pGkiCall != NULL);
  ASSERT(pConference != NULL);
  ISRTRACE(ghISRInst, StateName("GkiOpenCall <- State = %s", uGkiState), 0);
  EnterCriticalSection(&GkiLock);

  switch (uGkiState)
  {
  case STATE_REG_BYPASS:
    ASSERT(pGkiCall->uGkiCallState == GCS_START || pGkiCall->uGkiCallState == GCS_WAITING || pGkiCall->uGkiCallState == GCS_ADMITTING);
    hCall = pGkiCall->hCall;
    GkiAllocCall(pGkiCall, GKI_BYPASS_HANDLE);
    pGkiCall->uBandwidthAllocated = MAX_BANDWIDTH;
    if (pGkiCall->bAnswerCall)
    {
      status = AcceptCallConfirm(pGkiCall->pCall, pConference);
      if (status == NOERROR && ValidateCall(hCall) == NOERROR)
      {
        CheckPendingBandwidth(pGkiCall);
      }
    }
    else if (pGkiCall->dwIpAddress == 0)
    {
      status = PlaceCallReject  (pGkiCall->pCall, pConference, CC_INVALID_WITHOUT_GATEKEEPER);
    }
    else
    {
      status = PlaceCallConfirm (pGkiCall->pCall, pConference);
      if (status == NOERROR && ValidateCall(hCall) == NOERROR)
      {
        CheckPendingBandwidth(pGkiCall);
      }
    }
    break;

  case STATE_REGISTERING:
  case STATE_REGISTERING_REREG:
  case STATE_ADMITTING:
    pGkiCall->uGkiCallState = GCS_WAITING;
    break;

  case STATE_REGISTERED:
    switch (pGkiCall->CallType)
    {
    case POINT_TO_POINT:
      pGkiCall->usCallTypeChoice = pointToPoint_chosen;
      break;
    case ONE_TO_MANY:
      pGkiCall->usCallTypeChoice = oneToN_chosen;
      break;
    case MANY_TO_ONE:
      pGkiCall->usCallTypeChoice = nToOne_chosen;
      break;
    case MANY_TO_MANY:
      pGkiCall->usCallTypeChoice = nToN_chosen;
      break;
    default:
      LeaveCriticalSection(&GkiLock);
      ISRERROR(ghISRInst, "GkiOpenCall -> Invalid CallType %d", pGkiCall->CallType);
      return CC_BAD_PARAM;
    } // switch

    pDestCallSignalAddress = NULL;
    pAliasAddrs            = NULL;
    pExtraAliasAddrs       = NULL;

    if (pGkiCall->dwIpAddress != 0 && pGkiCall->wPort != 0)
    {
      DestCallSignalAddress.choice = ipAddress_chosen;
      DestCallSignalAddress.u.ipAddress.ip.length = 4;
      *((DWORD *)DestCallSignalAddress.u.ipAddress.ip.value) = pGkiCall->dwIpAddress;
      DestCallSignalAddress.u.ipAddress.port = pGkiCall->wPort;
      pDestCallSignalAddress = &DestCallSignalAddress;
    }

    if (pGkiCall->pCalleeAliasNames)
    {
      uCount = pGkiCall->pCalleeAliasNames->wCount;
      pAliasAddrs = MemAlloc(uCount * sizeof(*pAliasAddrs));
      if (pAliasAddrs == NULL)
      {
        LeaveCriticalSection(&GkiLock);
        ISRERROR(ghISRInst, "GkiOpenCall: Could not allocate %d Alias Addresses", uCount);
        return CC_NO_MEMORY;
      }
      memset(pAliasAddrs, 0, uCount * sizeof(*pAliasAddrs));
      pAlias = pAliasAddrs;
      pAliasItem = pGkiCall->pCalleeAliasNames->pItems;
      for (uIndex = 0; uIndex < uCount; ++uIndex)
      {
        status = CopyAliasItem(pAlias, pAliasItem);
        if (status != NOERROR)
        {
          LeaveCriticalSection(&GkiLock);
          ISRERROR(ghISRInst, "GkiOpenCall: CopyAliasItem returned %d", status);
          FreeAliasList(pAliasAddrs);
	  MemFree(pAliasAddrs);
          return status;
        }
        pAlias->next = pAlias + 1;
        ++pAlias;
        ++pAliasItem;
      } // for
      --pAlias;
      pAlias->next = NULL;
    }

    if (pGkiCall->pCalleeExtraAliasNames)
    {
      uCount = pGkiCall->pCalleeExtraAliasNames->wCount;
      pExtraAliasAddrs = MemAlloc(uCount * sizeof(*pExtraAliasAddrs));
      if (pExtraAliasAddrs == NULL)
      {
        LeaveCriticalSection(&GkiLock);
        ISRERROR(ghISRInst, "GkiOpenCall: Could not allocate %d Alias Addresses", uCount);
        if (pAliasAddrs)
	{
          FreeAliasList(pAliasAddrs);
	  MemFree(pAliasAddrs);
	}
        return CC_NO_MEMORY;
      }
      memset(pExtraAliasAddrs, 0, uCount * sizeof(*pExtraAliasAddrs));
      pAlias = pExtraAliasAddrs;
      pAliasItem = pGkiCall->pCalleeExtraAliasNames->pItems;
      for (uIndex = 0; uIndex < uCount; ++uIndex)
      {
        status = CopyAliasItem(pAlias, pAliasItem);
        if (status != NOERROR)
        {
          LeaveCriticalSection(&GkiLock);
          ISRERROR(ghISRInst, "GkiOpenCall: CopyAliasItem returned %d", status);
          if (pAliasAddrs)
	  {
            FreeAliasList(pAliasAddrs);
	    MemFree(pAliasAddrs);
	  }
          FreeAliasList(pExtraAliasAddrs);
	  MemFree(pExtraAliasAddrs);
          return status;
        }
        pAlias->next = pAlias + 1;
        ++pAlias;
        ++pAliasItem;
      } // for
      --pAlias;
      pAlias->next = NULL;
    }

    if (pGkiCall->uBandwidthRequested < MIN_BANDWIDTH)
    {
      pGkiCall->uBandwidthRequested = MIN_BANDWIDTH;
    }
    ASSERT(pGkiCall->uBandwidthAllocated == 0);
    ASSERT(pGkiCall->uBandwidthUsed == 0);

    memcpy(ConferenceId.value, pGkiCall->pConferenceId, 16);
    if (((DWORD *)pGkiCall->pConferenceId)[0] != 0 ||
        ((DWORD *)pGkiCall->pConferenceId)[1] != 0 ||
        ((DWORD *)pGkiCall->pConferenceId)[2] != 0 ||
        ((DWORD *)pGkiCall->pConferenceId)[3] != 0)
    {
      ConferenceId.length = 16;
    }
    else
    {
      ConferenceId.length = 0;
    }

    pGkiCall->hGkiCall = GKI_ADMITTING_HANDLE;
    if (pDestCallSignalAddress != NULL || pAliasAddrs != NULL)
    {
      uGkiState = STATE_ADMITTING;
      pGkiCall->uGkiCallState = GCS_ADMITTING;
      ISRTRACE(ghISRInst, "GKI_AdmissionRequest called...", 0);
      status = pGKI_AdmissionRequest(pGkiCall->usCallTypeChoice,    // usCallTypeChoice.
                                     pAliasAddrs,                   // pDestinationInfo,
                                     pDestCallSignalAddress,        // pDestCallSignalAddress
                                     pExtraAliasAddrs,              // pDestExtraCallInfo,
                                     &pGkiCall->CallIdentifier,     // H.225 call identifer
                                     pGkiCall->uBandwidthRequested, // bandWidth,
                                     &ConferenceId,                 // pConferenceID,
                                     pGkiCall->bActiveMC,           // activeMC,
                                     pGkiCall->bAnswerCall,         // answerCall,
                                     ipAddress_chosen);             // usCallTransport
      if (status == NOERROR)
      {
        ISRTRACE(ghISRInst, GkiErrorName("GKI_AdmissionRequest returned %s", status), 0);
      }
      else
      {
        ISRERROR(ghISRInst, GkiErrorName("GKI_AdmissionRequest returned %s", status), 0);
      }
    }
    else
    {
      pGkiCall->hGkiCall = 0;
      status = CC_BAD_PARAM;
    }

    if (status != NOERROR)
    {
      uGkiState = STATE_REGISTERED;
      GkiCancelCall(pGkiCall, pConference);
    }

    if (pAliasAddrs)
    {
      FreeAliasList(pAliasAddrs);
      MemFree(pAliasAddrs);
    }

    if (pExtraAliasAddrs)
    {
      FreeAliasList(pExtraAliasAddrs);
      MemFree(pExtraAliasAddrs);
    }
    break;

  case STATE_START:
  case STATE_CLASS_REGISTERED:
  case STATE_WINDOW_CREATED:
    pGkiCall->uGkiCallState = GCS_WAITING;
        // not registered!!! attempt to register or reregister
      status = GkiRegister();
    break;

  default:
    ISRERROR(ghISRInst, StateName("GkiOpenCall: Invalid state %s", uGkiState), 0);
    status = LastGkiError;
  } // switch

  LeaveCriticalSection(&GkiLock);
  ISRTRACE(ghISRInst, CallStateName("GkiOpenCall -> Call State = %s", pGkiCall->uGkiCallState), 0);
  return status;
} // GkiOpenCall()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

HRESULT GkiOpenChannel(PGKICALL pGkiCall, unsigned uChannelBandwidth, CC_HCHANNEL hChannel, CHANNELTYPE Type)
{
  HRESULT               status = NOERROR;
  PBWREQ                pBwReq;
  ASSERT(GKIExists());
  ASSERT(pGkiCall != NULL);
  ISRTRACE(ghISRInst, CallStateName("GkiOpenChannel <- Call State = %s", pGkiCall->uGkiCallState), 0);

  pBwReq = (PBWREQ)MemAlloc(sizeof(*pBwReq));
  if (pBwReq == NULL)
  {
    ISRERROR(ghISRInst, "GkiOpenChannel: Memory allocation failed", 0);
    return CC_NO_MEMORY;
  }

  pBwReq->uChannelBandwidth = uChannelBandwidth / 100;
  pBwReq->hChannel          = hChannel;
  pBwReq->Type              = Type;
  BwReqEnqueue(pGkiCall, pBwReq);
  switch (pGkiCall->uGkiCallState)
  {
  case GCS_WAITING:
  case GCS_ADMITTING:
  case GCS_CHANGING:
    // Must wait for current operation to complete
    break;

  case GCS_ADMITTED:
    status = CheckPendingBandwidth(pGkiCall);
    break;

  default:
    ISRERROR(ghISRInst, "GkiOpenChannel: Invalid call state %d", pGkiCall->uGkiCallState);
    status = CC_GKI_CALL_STATE;
  } // switch

  ISRTRACE(ghISRInst, CallStateName("GkiOpenChannel -> Call State = %s", pGkiCall->uGkiCallState), 0);
  return status;
} // GkiOpenChannel()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

HRESULT GkiCloseChannel(PGKICALL pGkiCall, unsigned uChannelBandwidth, CC_HCHANNEL hChannel)
{
  PBWREQ                pBwReq;
  PBWREQ                pBwReq1;
  ASSERT(GKIExists());
  ASSERT(pGkiCall != NULL);
  ISRTRACE(ghISRInst, CallStateName("GkiCloseChannel <- Call State = %s", pGkiCall->uGkiCallState), 0);

  // If Bandwidth request is still in queue, bandwidth has not been allocated
  pBwReq = pGkiCall->pBwReqHead;
  if (pBwReq)
  {
    if (pBwReq->hChannel == hChannel)
    {
      MemFree(BwReqDequeue(pGkiCall));
      ISRTRACE(ghISRInst, CallStateName("GkiCloseChannel -> Call State = %s", pGkiCall->uGkiCallState), 0);
      return NOERROR;
    }
    while ((pBwReq1 = pBwReq->pNext) != NULL)
    {
      if (pBwReq1->hChannel == hChannel)
      {
        if (pGkiCall->pBwReqTail == pBwReq1)
        {
          pGkiCall->pBwReqTail = pBwReq;
        }
        pBwReq->pNext = pBwReq1->pNext;
        MemFree(pBwReq1);
        ISRTRACE(ghISRInst, CallStateName("GkiCloseChannel -> Call State = %s", pGkiCall->uGkiCallState), 0);
        return NOERROR;
      }
    }
  }

  pGkiCall->uBandwidthUsed -= (uChannelBandwidth / 100);
  ISRTRACE(ghISRInst, CallStateName("GkiCloseChannel -> Call State = %s", pGkiCall->uGkiCallState), 0);
  return NOERROR;
} // GkiCloseChannel()



unsigned GkiGetBandwidth(PGKICALL pGkiCall)
{
  ASSERT(pGkiCall != NULL);
  return pGkiCall->uBandwidthAllocated * 100;
} // GkiGetBandwidth()



//
// GkiWndProc subroutines
//

/*
 *  NOTES
 *    Must have Call locked before calling!
 */

static HRESULT CheckPendingOpen(PGKICALL pGkiCall, void *pConference)
{
  HRESULT               status = NOERROR;

  ASSERT(pGkiCall != NULL);
  ASSERT(pConference != NULL);

  switch (uGkiState)
  {
  case STATE_REGISTERED:
  case STATE_REG_BYPASS:
    // TBD - Can only open 1!!!
    ASSERT(pGkiCall->uGkiCallState != GCS_ADMITTING);
    if (pGkiCall->uGkiCallState == GCS_WAITING)
    {
      status = GkiOpenCall(pGkiCall, pConference);
    }
    break;

  default:
    status = LastGkiError;
  } // switch

  return status;
} // CheckPendingOpen()



static void GkiNoResponse(HWND hWnd)
{
  HRESULT               status;

  switch (uGkiState)
  {
  case STATE_START:
  case STATE_CLASS_REGISTERED:
  case STATE_WINDOW_CREATED:
  case STATE_REG_BYPASS:
    break;

  case STATE_REGISTERING:
  case STATE_REGISTERING_REREG:
  case STATE_REGISTERING_UNREG:
  #if(0)
    why did Intel *DO* this?????
    ISRTRACE(ghISRInst, "GkiWndProc: dummy GKI_REG_REJECT", 0);
    PostMessage(hWnd, GKIMAN_BASE + GKI_REG_REJECT, 0, 0);
  #else
    // there was no response to registration request, assume the GK is not there or dead.
      uGkiState = STATE_REG_BYPASS;
      if(gpRasNotifyProc)
      {
        (gpRasNotifyProc)(RAS_REG_TIMEOUT, 0);
      }
      ApplyToAllCalls(CheckPendingOpen);
  #endif
    break;

  case STATE_ADMITTING:
  case STATE_ADMITTING_REREG:
    ApplyToAllCalls(GkiCancelAdmitting);
    uGkiState = STATE_REGISTERED;

    // Fall-through to next case

  case STATE_REGISTERED:
    if (uGkiCalls == 0)
    {
      GkiRegister();
    }
    else
    {
      uGkiState = STATE_REG_BYPASS;
      ApplyToAllCalls(GatekeeperNotFound);
      ISRTRACE(ghISRInst, "GKI_UnregistrationRequest called...", 0);
      status = pGKI_UnregistrationRequest();
      if (status == NOERROR)
      {
        ISRTRACE(ghISRInst, GkiErrorName("GKI_UnregistrationRequest returned %s", status), 0);
      }
      else
      {
        ISRERROR(ghISRInst, GkiErrorName("GKI_UnregistrationRequest returned %s", status), 0);
      }
    }
    break;

  case STATE_ADMITTING_UNREG:
    ApplyToAllCalls(GkiCancelAdmitting);
    uGkiState = STATE_REGISTERED;
    GkiUnregister();
    break;

  case STATE_DISENGAGING:
    ApplyToAllCalls(GatekeeperNotFound);
    ASSERT(uGkiCalls == 0);
    uGkiState = STATE_REGISTERED;
    GkiUnregister();
    break;

  case STATE_DISENGAGING_REREG:
    ApplyToAllCalls(GatekeeperNotFound);
    ASSERT(uGkiCalls == 0);
    uGkiState = STATE_REGISTERED;
    GkiRegister();
    break;

  case STATE_UNREGISTERING:
  case STATE_UNREGISTERING_REREG:
    ISRTRACE(ghISRInst, "GkiWndProc: dummy GKI_UNREG_CONFIRM", 0);
    PostMessage(hWnd, GKIMAN_BASE + GKI_UNREG_CONFIRM, 0, 0);
    break;

  default:
    ISRERROR(ghISRInst, "GkiWndProc: Bad uGkiState %d", uGkiState);
  } // switch
} // GkiNoResponse()



LRESULT APIENTRY GkiWndProc(
  HWND hWnd,                /* window handle                   */
  UINT message,             /* type of message                 */
  WPARAM wParam,              /* additional information          */
  LPARAM lParam)              /* additional information          */
{
  CallReturnInfo *      pCallReturnInfo;
  PGKICALL              pGkiCall;
  void *                pConference;
  CC_HCALL              hCall;
  CC_HCONFERENCE        hConference;
  HRESULT               status;
  if (message < GKIMAN_BASE)
  {
    return DefWindowProc(hWnd, message, wParam, lParam);
  }

  EnterCallControlTop();

  ISRTRACE(ghISRInst, StateName("GkiWndProc <- State = %s", uGkiState), 0);

  switch (message)
  {
  case GKIMAN_BASE + GKI_REG_CONFIRM:
    ISRTRACE(ghISRInst, "GkiWndProc: GKI_REG_CONFIRM", 0);
    ASSERT(gpRasNotifyProc);  // we should never get messages if
                              // this is not configured
    if(gpRasNotifyProc)
    {
       (gpRasNotifyProc)(RAS_REG_CONFIRM, 0);
    }
    switch (uGkiState)
    {
    case STATE_REGISTERING:
      uGkiState = STATE_REGISTERED;
      ApplyToAllCalls(CheckPendingOpen);
      break;
    case STATE_REGISTERING_REREG:
      uGkiState = STATE_REGISTERED;
      GkiRegister();
      break;
    case STATE_REGISTERING_UNREG:
      uGkiState = STATE_REGISTERED;
      GkiUnregister();
      break;
    default:
      ISRERROR(ghISRInst, StateName("GkiWndProc: GKI_REG_CONFIRM in state %s", uGkiState), 0);
    } // switch
    break;

  case GKIMAN_BASE + GKI_REG_DISCOVERY:
    ISRTRACE(ghISRInst, "GkiWndProc: GKI_REG_DISCOVERY", 0);
    ASSERT(uGkiState == STATE_REGISTERING || uGkiState == STATE_REGISTERING_REREG || uGkiState == STATE_REGISTERING_UNREG);
    break;

  case GKIMAN_BASE + GKI_UNREG_REQUEST:
      //  the GK kicked us out!
      // pass the unregistration request upward
      ASSERT(gpRasNotifyProc);  // we should never get messages if
                                // this is not configured
      if(gpRasNotifyProc)
      {
        (gpRasNotifyProc)(RAS_UNREG_REQ, MapUnregistrationRequestReason((UINT)wParam));
      }
  break;

  case GKIMAN_BASE + GKI_REG_REJECT:
    ISRERROR(ghISRInst, "GkiWndProc: GKI_REG_REJECT Reason = %d", (DWORD)wParam);
    switch (uGkiState)
    {
    case STATE_REGISTERING:
      ApplyToAllCalls(GkiCancelCall);
#if(0)
// leave the listen list intact so that subsequent registration attempts
// will work.
//
      EnterCriticalSection(&GkiLock);
      while (pListenList)
      {
        register PLISTEN pListen = pListenList;
        pListenList = pListen->pNext;
        LeaveCriticalSection(&GkiLock);
        ListenReject(pListen->hListen, MapRegistrationRejectReason((UINT)wParam));
        if (pListen->pAliasNames)
        {
            FreeAliasNames(pListen->pAliasNames);
        }
        MemFree(pListen);
        EnterCriticalSection(&GkiLock);
      }
      LeaveCriticalSection(&GkiLock);
 #endif
      uGkiState = STATE_WINDOW_CREATED;

      // pass the registration reject upward
      ASSERT(gpRasNotifyProc);  // we should never get messages if
                                // this is not configured
      if(gpRasNotifyProc)
      {
        (gpRasNotifyProc)(RAS_REJECTED, MapRegistrationRejectReason((UINT)wParam));
      }

      break;
    case STATE_REGISTERING_REREG:
      uGkiState = STATE_WINDOW_CREATED;
      GkiRegister();
      break;
    case STATE_REGISTERING_UNREG:
      uGkiState = STATE_WINDOW_CREATED;
      GkiUnregister();
      break;
    default:
      ISRERROR(ghISRInst, StateName("GkiWndProc: GKI_REG_REJECT in state %s", uGkiState), 0);
    } // switch
    break;

  case GKIMAN_BASE + GKI_REG_BYPASS:
    ISRTRACE(ghISRInst, "GkiWndProc: GKI_REG_BYPASS", 0);
    switch (uGkiState)
    {
    case STATE_REGISTERING:
    case STATE_REGISTERING_REREG:
      uGkiState = STATE_REG_BYPASS;
      ApplyToAllCalls(CheckPendingOpen);
      break;
    case STATE_REGISTERING_UNREG:
      uGkiState = STATE_WINDOW_CREATED;
      GkiUnregister();
      break;
    default:
      ISRERROR(ghISRInst, StateName("GkiWndProc: GKI_REG_BYPASS in state %s", uGkiState), 0);
    } // switch
    break;

  case GKIMAN_BASE + GKI_UNREG_CONFIRM:
    ISRTRACE(ghISRInst, "GkiWndProc: GKI_UNREG_CONFIRM", 0);
    ASSERT(gpRasNotifyProc);  // we should never get messages if
                              // this is not configured
    if(gpRasNotifyProc)
    {
        (gpRasNotifyProc)(RAS_UNREG_CONFIRM, 0);
    }

    switch (uGkiState)
    {
    case STATE_REGISTERING:
    case STATE_REGISTERING_REREG:
    case STATE_REGISTERED:
    case STATE_ADMITTING:
    case STATE_ADMITTING_REREG:
    case STATE_DISENGAGING_REREG:
    case STATE_UNREGISTERING_REREG:
      uGkiState = STATE_WINDOW_CREATED;
      GkiRegister();
      break;

    default:
      ISRERROR(ghISRInst, StateName("GkiWndProc: GKI_UNREG_CONFIRM in state %s", uGkiState), 0);

      // Fall through to next case

    case STATE_ADMITTING_UNREG:
    case STATE_DISENGAGING:
      ApplyToAllCalls(GkiCancelCall);

      // Fall-through to next case

    case STATE_REGISTERING_UNREG:
    case STATE_UNREGISTERING:
      uGkiState = STATE_WINDOW_CREATED;

      // Fall-through to next case

    case STATE_CLASS_REGISTERED:
    case STATE_WINDOW_CREATED:

      // Fall-through to next case

    case STATE_START:
    case STATE_REG_BYPASS:
      break;

    } // switch
    break;

  case GKIMAN_BASE + GKI_UNREG_REJECT:
    ISRERROR(ghISRInst, "GkiWndProc: GKI_UNREG_REJECT Reason = %d", (DWORD)wParam);
    switch (uGkiState)
    {
    case STATE_UNREGISTERING:
      uGkiState = STATE_WINDOW_CREATED;
      GkiUnregister();
      break;
    case STATE_UNREGISTERING_REREG:
      uGkiState = STATE_WINDOW_CREATED;
      GkiRegister();
      break;
    default:
      ISRWARNING(ghISRInst, StateName("GkiWndProc: GKI_UNREG_REJECT in state %s", uGkiState), 0);
    } // switch
    break;

  case GKIMAN_BASE + GKI_ADM_CONFIRM:
    ISRTRACE(ghISRInst, "GkiWndProc: GKI_ADM_CONFIRM", 0);
    switch (uGkiState)
    {
    case STATE_ADMITTING:
      uGkiState = STATE_REGISTERED;
      pCallReturnInfo = (CallReturnInfo *) lParam;
      if (LockGkiCallAndConference(GKI_ADMITTING_HANDLE, &pGkiCall, &pConference, &hCall, &hConference) == NOERROR)
      {
        ISRTRACE(ghISRInst, CallStateName("GkiWndProc: Call State = %s", pGkiCall->uGkiCallState), 0);
        pGkiCall->usCallModelChoice   = pCallReturnInfo->callModel.choice;
        pGkiCall->uBandwidthAllocated = pCallReturnInfo->bandWidth;
        pGkiCall->usCRV = pCallReturnInfo->callReferenceValue;
        memcpy(pGkiCall->pConferenceId, pCallReturnInfo->conferenceID.value, 16);
        switch (pGkiCall->uGkiCallState)
        {
        case GCS_ADMITTING:
          GkiAllocCall(pGkiCall, pCallReturnInfo->hCall);
          if (pGkiCall->bAnswerCall)
          {
            status = AcceptCallConfirm(pGkiCall->pCall, pConference);
          }
          else
          {
            ASSERT(pCallReturnInfo->destCallSignalAddress.choice == ipAddress_chosen);
            pGkiCall->dwIpAddress = *((DWORD *)pCallReturnInfo->destCallSignalAddress.u.ipAddress.ip.value);
            pGkiCall->wPort = pCallReturnInfo->destCallSignalAddress.u.ipAddress.port;
            status = PlaceCallConfirm(pGkiCall->pCall, pConference);
          }
          if (status == NOERROR && ValidateCall(hCall) == NOERROR)
            CheckPendingBandwidth(pGkiCall);
          break;

        case GCS_ADMITTING_CLOSE_PENDING:
          GkiAllocCall(pGkiCall, pCallReturnInfo->hCall);
          GkiCloseCall(pGkiCall);
          break;

        default:
          ISRWARNING(ghISRInst, CallStateName("GkiWndProc: GKI_ADM_CONFIRM in call state %s", pGkiCall->uGkiCallState), 0);
        } // switch
        UnlockGkiCallAndConference(pGkiCall, pConference, hCall, hConference);
      } // if
      else
      {
        ISRWARNING(ghISRInst, "GkiWndProc: GKI_ADM_CONFIRM handle not found", 0);
      }
      ApplyToAllCalls(CheckPendingOpen);
      break;

    case STATE_ADMITTING_UNREG:
      uGkiState = STATE_REGISTERED;
      GkiUnregister();
      break;

    default:
        ISRWARNING(ghISRInst, StateName("GkiWndProc: GKI_ADM_CONFIRM in state %s", uGkiState), 0);
    } // switch
    break;

  case GKIMAN_BASE + GKI_ADM_REJECT:
    ISRERROR(ghISRInst, "GkiWndProc: GKI_ADM_REJECT Reason = %d", (DWORD)wParam);
    switch (uGkiState)
    {
    case STATE_ADMITTING:
      pCallReturnInfo = (CallReturnInfo *) lParam;
      if (LockGkiCallAndConference(GKI_ADMITTING_HANDLE, &pGkiCall, &pConference, &hCall, &hConference) == NOERROR)
      {
		ASSERT(pGkiCall->uGkiCallState == GCS_ADMITTING);
        switch (wParam)
        {
        case AdmissionRejectReason_calledPartyNotRegistered_chosen:
          if (pGkiCall->bAnswerCall)
          {
            // The gateway has gone away and come back without our notice!
            GkiCancelAdmitting(pGkiCall, pConference);
            uGkiState = STATE_REGISTERED;
            GkiRegister();
            ISRTRACE(ghISRInst, StateName("GkiWndProc -> State = %s", uGkiState), 0);
            LeaveCallControlTop(0);
          }
          break;
        case AdmissionRejectReason_callerNotRegistered_chosen:
          if (pGkiCall->bAnswerCall == FALSE)
          {
            // The gateway has gone away and come back without our notice!
            GkiCancelAdmitting(pGkiCall, pConference);
            uGkiState = STATE_REGISTERED;
            GkiRegister();
            ISRTRACE(ghISRInst, StateName("GkiWndProc -> State = %s", uGkiState), 0);
            LeaveCallControlTop(0);
          }
        } // switch
        GkiFreeCall(pGkiCall);
        if (pGkiCall->bAnswerCall)
          AcceptCallReject(pGkiCall->pCall, pConference, MapAdmissionRejectReason((UINT)wParam));
        else
          PlaceCallReject (pGkiCall->pCall, pConference, MapAdmissionRejectReason((UINT)wParam));
        UnlockGkiCallAndConference(pGkiCall, pConference, hCall, hConference);
      } // if
      else
      {
        ISRWARNING(ghISRInst, "GkiWndProc: GKI_ADM_REJECT handle not found", 0);
      }
      uGkiState = STATE_REGISTERED;
      ApplyToAllCalls(CheckPendingOpen);
      break;

    case STATE_ADMITTING_REREG:
      pCallReturnInfo = (CallReturnInfo *) lParam;
      if (LockGkiCallAndConference(GKI_ADMITTING_HANDLE, &pGkiCall, &pConference, &hCall, &hConference) == NOERROR)
      {
		ASSERT(pGkiCall->uGkiCallState == GCS_ADMITTING_CLOSE_PENDING);
        GkiFreeCall(pGkiCall);
        if (pGkiCall->bAnswerCall)
        {
          AcceptCallReject(pGkiCall->pCall, pConference, MapAdmissionRejectReason((UINT)wParam));
        }
        else
        {
          PlaceCallReject (pGkiCall->pCall, pConference, MapAdmissionRejectReason((UINT)wParam));
        }
        UnlockGkiCallAndConference(pGkiCall, pConference, hCall, hConference);
      } // if
      else
      {
        ISRWARNING(ghISRInst, "GkiWndProc: GKI_ADM_REJECT handle not found", 0);
      }
      uGkiState = STATE_REGISTERED;
      GkiRegister();
      break;

    case STATE_ADMITTING_UNREG:
      pCallReturnInfo = (CallReturnInfo *) lParam;
      if (LockGkiCallAndConference(GKI_ADMITTING_HANDLE, &pGkiCall, &pConference, &hCall, &hConference) == NOERROR)
      {
		ASSERT(pGkiCall->uGkiCallState == GCS_ADMITTING_CLOSE_PENDING);
        GkiFreeCall(pGkiCall);
        if (pGkiCall->bAnswerCall)
        {
          AcceptCallReject(pGkiCall->pCall, pConference, MapAdmissionRejectReason((UINT)wParam));
        }
        else
        {
          PlaceCallReject (pGkiCall->pCall, pConference, MapAdmissionRejectReason((UINT)wParam));
        }
        UnlockGkiCallAndConference(pGkiCall, pConference, hCall, hConference);
      } // if
      else
      {
        ISRWARNING(ghISRInst, "GkiWndProc: GKI_ADM_REJECT handle not found", 0);
      }
      uGkiState = STATE_REGISTERED;
      GkiUnregister();
      break;

    default:
        ISRWARNING(ghISRInst, StateName("GkiWndProc: GKI_ADM_REJECT in state %s", uGkiState), 0);
    } // switch
    break;

  case GKIMAN_BASE + GKI_BW_CONFIRM:
    ISRTRACE(ghISRInst, "GkiWndProc: GKI_BW_CONFIRM", 0);
    switch (uGkiState)
    {
    case STATE_REGISTERED:
      pCallReturnInfo = (CallReturnInfo *) lParam;
      if (LockGkiCallAndConference(pCallReturnInfo->hCall, &pGkiCall, &pConference, &hCall, &hConference) == NOERROR)
      {
        ISRTRACE(ghISRInst, CallStateName("GkiWndProc: Call State = %s", pGkiCall->uGkiCallState), 0);
        pGkiCall->uBandwidthAllocated = pCallReturnInfo->bandWidth;
        switch (pGkiCall->uGkiCallState)
        {
        case GCS_ADMITTED:
          if (pGkiCall->uBandwidthUsed < pGkiCall->uBandwidthAllocated)
          {
            BandwidthShrunk(pGkiCall->pCall,
                            pConference,
                            pGkiCall->uBandwidthAllocated,
                            ((long)pGkiCall->uBandwidthAllocated) - ((long)pGkiCall->uBandwidthUsed));
          }
          break;

        case GCS_CHANGING:
          pGkiCall->uGkiCallState = GCS_ADMITTED;
          CheckPendingBandwidth(pGkiCall);
          break;

        case GCS_CHANGING_CLOSE_PENDING:
          pGkiCall->uGkiCallState = GCS_ADMITTED;
          GkiCloseCall(pGkiCall);
          break;

        default:
          ISRWARNING(ghISRInst, CallStateName("GkiWndProc: GKI_BW_CONFIRM in call state %s", pGkiCall->uGkiCallState), 0);
        } // switch
        UnlockGkiCallAndConference(pGkiCall, pConference, hCall, hConference);
      } // if
      else
      {
        ISRWARNING(ghISRInst, "GkiWndProc: GKI_BW_CONFIRM handle not found", 0);
      } // else
      break;

    default:
      ISRERROR(ghISRInst, StateName("GkiWndProc: GKI_BW_CONFIRM in GKI state %s", uGkiState), 0);
    } // switch
    break;

  case GKIMAN_BASE + GKI_BW_REJECT:
    ISRERROR(ghISRInst, "GkiWndProc: GKI_BW_REJECT Reason = %d", (DWORD)wParam);
    switch (uGkiState)
    {
    case STATE_REGISTERED:
      pCallReturnInfo = (CallReturnInfo *) lParam;
      if (LockGkiCallAndConference(pCallReturnInfo->hCall, &pGkiCall, &pConference, &hCall, &hConference) == NOERROR)
      {
        ISRTRACE(ghISRInst, CallStateName("GkiWndProc: Call State = %s", pGkiCall->uGkiCallState), 0);
        pGkiCall->uBandwidthAllocated = pCallReturnInfo->bandWidth;
        switch (pGkiCall->uGkiCallState)
        {
        case GCS_CHANGING:
          pGkiCall->uGkiCallState = GCS_ADMITTED;
          BandwidthRejected(pGkiCall, (UINT)wParam);
          if (ValidateCall(hCall) == NOERROR)
          {
            CheckPendingBandwidth(pGkiCall);
          }
          break;

        case GCS_CHANGING_CLOSE_PENDING:
          pGkiCall->uGkiCallState = GCS_ADMITTED;
          GkiCloseCall(pGkiCall);
          break;

        default:
          ISRERROR(ghISRInst, CallStateName("GkiWndProc: GKI_BW_REJECT in state %s", pGkiCall->uGkiCallState), 0);
        } // switch
        UnlockGkiCallAndConference(pGkiCall, pConference, hCall, hConference);
      } // if
      else
      {
        ISRWARNING(ghISRInst, "GkiWndProc: GKI_BW_REJECT handle not found", 0);
      }
      break;

    default:
      ISRERROR(ghISRInst, StateName("GkiWndProc: GKI_BW_REJECT in state %s", uGkiState), 0);
    } // switch
    break;

  case GKIMAN_BASE + GKI_DISENG_CONFIRM:
    ISRTRACE(ghISRInst, "GkiWndProc: GKI_DISENG_CONFIRM", 0);
    if (LockGkiCall((HANDLE)lParam, &pGkiCall) == NOERROR)
    {
      ISRTRACE(ghISRInst, CallStateName("GkiWndProc: Call State = %s", pGkiCall->uGkiCallState), 0);
      switch (pGkiCall->uGkiCallState)
      {
      case GCS_DISENGAGING:
        --uPendingDisengages;
        break;

      default:
        ISRWARNING(ghISRInst, CallStateName("GkiWndProc: GKI_DISENG_CONFIRM in call state %s", pGkiCall->uGkiCallState), 0);
      } // switch
      GkiFreeCall(pGkiCall);
      Disengage(pGkiCall->pCall);
    } // if
    else if (uPendingDisengages != 0)
    {
      --uPendingDisengages;
      if (uPendingDisengages == 0)
      {
        switch (uGkiState)
        {
        case STATE_DISENGAGING:
          uGkiState = STATE_REGISTERED;
          GkiUnregister();
          break;
        case STATE_DISENGAGING_REREG:
          uGkiState = STATE_REGISTERED;
          GkiRegister();
          break;
        } // switch

      } // if
    } // else if
    else
    {
      ISRWARNING(ghISRInst, "GkiWndProc: GKI_DISENG_CONFIRM handle not found", 0);
    }
    break;

  case GKIMAN_BASE + GKI_DISENG_REJECT:
    ISRERROR(ghISRInst, "GkiWndProc: GKI_DISENG_REJECT Reason = %d", (DWORD)wParam);
    if (LockGkiCall((HANDLE)lParam, &pGkiCall) == NOERROR)
    {
      ISRTRACE(ghISRInst, CallStateName("GkiWndProc: Call State = %s", pGkiCall->uGkiCallState), 0);
      switch (pGkiCall->uGkiCallState)
      {
      case GCS_DISENGAGING:
        // Pretend we received a Disengage Confirm
        --uPendingDisengages;
        break;

      default:
        ISRERROR(ghISRInst, CallStateName("GkiWndProc: GKI_DISENG_REJECT in call state %s", pGkiCall->uGkiCallState), 0);
      } // switch
      GkiFreeCall(pGkiCall);
      Disengage(pGkiCall->pCall);
    } // if
    else if (uPendingDisengages != 0)
    {
      // Pretend we received a Disengage Confirm
      --uPendingDisengages;
      if (uPendingDisengages == 0)
      {
        switch (uGkiState)
        {
        case STATE_DISENGAGING:
          uGkiState = STATE_REGISTERED;
          GkiUnregister();
          break;
        case STATE_DISENGAGING_REREG:
          uGkiState = STATE_REGISTERED;
          GkiRegister();
          break;
        } // switch

      } // if
    } // else if
    else
    {
      ISRWARNING(ghISRInst, "GkiWndProc: GKI_DISENG_REJECT handle not found", 0);
    }
    break;

  case GKIMAN_BASE + GKI_LOCATION_CONFIRM:
    ISRTRACE(ghISRInst, "GkiWndProc: GKI_LOCATION_CONFIRM", 0);
    break;

  case GKIMAN_BASE + GKI_LOCATION_REJECT:
    ISRERROR(ghISRInst, "GkiWndProc: GKI_LOCATION_REJECT Reason = %d", (DWORD)wParam);
    break;

  case GKIMAN_BASE + GKI_ERROR:
    ISRERROR(ghISRInst, GkiErrorName("GkiWndProc: GKI_ERROR %s %%d", (HRESULT)lParam), (DWORD)wParam);
    switch (lParam)
    {
    case GKI_NO_RESPONSE:
	  LastGkiError = (HRESULT)lParam;
      GkiNoResponse(hWnd);
      break;
#if 1
// TEMPORARY KLUDGE FOR WINSOCK 2 BETA 1.6 OPERATION
	case MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_WINSOCK,0xffff):
      uGkiState = STATE_REG_BYPASS;
      ApplyToAllCalls(CheckPendingOpen);
	  break;
#endif
    default:
	  LastGkiError = (HRESULT)lParam;
      GkiUnregister();
    } // switch
    break;

  default:
    ISRERROR(ghISRInst, "Unknown message %d", message);
  } // switch

  ISRTRACE(ghISRInst, StateName("GkiWndProc -> State = %s", uGkiState), 0);
  LeaveCallControlTop(0);
} // GkiWndProc()


// because the ASN.1 header files are not exposed and there is a redefinition of
// RAS reason codes, make sure that the mapping is correct.  The functions herien
// assume equality and don't actually do any remapping.

// break the build if the definitions don't match !!!

#if (discoveryRequired_chosen != RRJ_DISCOVERY_REQ)
	#error "Registration reject reason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if (RegistrationRejectReason_invalidRevision_chosen != RRJ_INVALID_REVISION)
	#error "Registration reject reason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if (invalidCallSignalAddress_chosen != RRJ_INVALID_CALL_ADDR)
	#error "Registration reject reason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if (invalidRASAddress_chosen != RRJ_INVALID_RAS_ADDR)
	#error "Registration reject reason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if (duplicateAlias_chosen != RRJ_DUPLICATE_ALIAS)
	#error "Registration reject reason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if (invalidTerminalType_chosen != RRJ_INVALID_TERMINAL_TYPE)
	#error "Registration reject reason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if (RegistrationRejectReason_undefinedReason_chosen != RRJ_UNDEFINED)
	#error "Registration reject reason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if (transportNotSupported_chosen != RRJ_TRANSPORT_NOT_SUPPORTED)
	#error "Registration reject reason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if (transportQOSNotSupported_chosen != RRJ_TRANSPORT_QOS_NOT_SUPPORTED)
	#error "Registration reject reason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if (RegistrationRejectReason_resourceUnavailable_chosen != RRJ_RESOURCE_UNAVAILABLE)
	#error "Registration reject reason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if (invalidAlias_chosen != RRJ_INVALID_ALIAS)
	#error "Registration reject reason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if (RegistrationRejectReason_securityDenial_chosen != RRJ_SECURITY_DENIAL)
	#error "Registration reject reason code definitions mismatch!! GO back and FIX IT!!"
#endif
// reason codes for GK initiated URQ
#if(reregistrationRequired_chosen != URQ_REREG_REQUIRED)
    #error "UnregRequestReason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if(ttlExpired_chosen != URQ_TTL_EXPIRED)
    #error "UnregRequestReason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if(UnregRequestReason_securityDenial_chosen != URQ_SECURITY_DENIAL)
    #error "UnregRequestReason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if(UnregRequestReason_undefinedReason_chosen != URQ_UNDEFINED)
    #error "UnregRequestReason code definitions mismatch!! GO back and FIX IT!!"
#endif

#if(AdmissionRejectReason_calledPartyNotRegistered_chosen != ARJ_CALLEE_NOT_REGISTERED)
 #error "AdmissionRejectReason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if(AdmissionRejectReason_invalidPermission_chosen != ARJ_INVALID_PERMISSION)
 #error "AdmissionRejectReason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if(AdmissionRejectReason_requestDenied_chosen != ARJ_REQUEST_DENIED)
 #error "AdmissionRejectReason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if(AdmissionRejectReason_undefinedReason_chosen != ARJ_UNDEFINED)
 #error "AdmissionRejectReason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if(AdmissionRejectReason_callerNotRegistered_chosen != ARJ_CALLER_NOT_REGISTERED)
 #error "AdmissionRejectReason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if(AdmissionRejectReason_routeCallToGatekeeper_chosen != ARJ_ROUTE_TO_GK)
 #error "AdmissionRejectReason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if(invalidEndpointIdentifier_chosen != ARJ_INVALID_ENDPOINT_ID)
 #error "AdmissionRejectReason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if(AdmissionRejectReason_resourceUnavailable_chosen != ARJ_RESOURCE_UNAVAILABLE)
 #error "AdmissionRejectReason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if(AdmissionRejectReason_securityDenial_chosen != ARJ_SECURTY_DENIAL)
 #error "AdmissionRejectReason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if(qosControlNotSupported_chosen != ARJ_QOS_CONTROL_NOT_SUPPORTED)
 #error "AdmissionRejectReason code definitions mismatch!! GO back and FIX IT!!"
#endif
#if(incompleteAddress_chosen != ARJ_INCOMPLETE_ADDRESS)
 #error "AdmissionRejectReason code definitions mismatch!! GO back and FIX IT!!"
#endif

#if(reregistrationRequired_chosen != URQ_REREG_REQUIRED)
 #error "UnregistrationRequest code definitions mismatch!! GO back and FIX IT!!"
#endif
#if(ttlExpired_chosen != URQ_TTL_EXPIRED)
 #error "UnregistrationRequest code definitions mismatch!! GO back and FIX IT!!"
#endif
#if(UnregRequestReason_securityDenial_chosen != URQ_SECURITY_DENIAL)
 #error "UnregistrationRequest code definitions mismatch!! GO back and FIX IT!!"
#endif
#if(UnregRequestReason_undefinedReason_chosen != URQ_UNDEFINED)
 #error "UnregistrationRequest code definitions mismatch!! GO back and FIX IT!!"
#endif

#else  // GATEKEEPER
static char ch;	// Kludge around warning C4206: nonstandard extension used : translation unit is empty
#endif // GATEKEEPER




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\gkiadm.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\gkiadm.cpv  $
*																		*
*	$Revision:   1.9  $
*	$Date:   12 Feb 1997 01:12:06  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\gkiadm.cpv  $
// 
//    Rev 1.9   12 Feb 1997 01:12:06   CHULME
// Redid thread synchronization to use Gatekeeper.Lock
// 
//    Rev 1.8   17 Jan 1997 09:02:04   CHULME
// Changed reg.h to gkreg.h to avoid name conflict with inc directory
// 
//    Rev 1.7   10 Jan 1997 16:15:12   CHULME
// Removed MFC dependency
// 
//    Rev 1.6   20 Dec 1996 16:38:34   CHULME
// Fixed access synchronization with Gatekeeper lock
// 
//    Rev 1.5   17 Dec 1996 18:21:58   CHULME
// Switch src and destination fields on ARQ for Callee
// 
//    Rev 1.4   02 Dec 1996 23:49:32   CHULME
// Added premptive synchronization code
// 
//    Rev 1.3   22 Nov 1996 15:24:18   CHULME
// Added VCS log to the header
*************************************************************************/

// gkiadmission.cpp : Handles the GKI_AdmissionRequest API
//

#include "precomp.h"

#include <process.h>
#include <winsock.h>
#include "GKICOM.H"
#include "dspider.h"
#include "dgkilit.h"
#include "DGKIPROT.H"
#include "GATEKPR.H"
#include "gksocket.h"
#include "GKREG.H"
#include "dcall.h"
#include "h225asn.h"
#include "coder.hpp"
#include "dgkiext.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern "C" HRESULT DLL_EXPORT
GKI_AdmissionRequest(unsigned short		usCallTypeChoice,
					SeqAliasAddr		*pRemoteInfo,
					TransportAddress	*pRemoteCallSignalAddress,
					SeqAliasAddr		*pDestExtraCallInfo,
					LPGUID				pCallIdentifier,
					BandWidth			bandWidth,
					ConferenceIdentifier	*pConferenceID,
					BOOL				activeMC,
					BOOL				answerCall,
					unsigned short		usCallTransport)
{
	// ABSTRACT:  This function is exported.  It is called by the client application
	//            to request bandwidth for a conference.  It will create a CCall
	//            object to track all pertanent information.  The handle returned
	//            to the client asynchronously will actually be a pointer to this
	//            object.
	// AUTHOR:    Colin Hulme

	CCall			*pCall;
	SeqAliasAddr	*pAA;
	HRESULT			hResult;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "GKI_AdmissionRequest()\n", 0);

#ifdef _DEBUG
	if (dwGKIDLLFlags & SP_GKI)
	{
		SPIDER_TRACE(SP_GKI, "GKI_AdmissionRequest()\n", 0);
		Dump_GKI_AdmissionRequest(usCallTypeChoice,
									pRemoteInfo,
									pRemoteCallSignalAddress, 
									pDestExtraCallInfo,
									bandWidth,
									pConferenceID,
									activeMC,
									answerCall,
									usCallTransport);
	}
#endif
	
	// Create a Gatekeeper lock object on the stack
	// It's constructor will lock pGK and when we return
	// from any path, its destructor will unlock pGK
	CGatekeeperLock	GKLock(g_pGatekeeper);
	if (g_pReg == 0)
		return (GKI_NOT_REG);

	if (g_pReg->GetState() != CRegistration::GK_REGISTERED)
		return (GKI_NOT_REG);
		
	ASSERT(pCallIdentifier);
	ASSERT((usCallTransport == ipAddress_chosen) ||(usCallTransport == ipxAddress_chosen));

	// Create a call object
	pCall = new CCall;

	SPIDER_TRACE(SP_NEWDEL, "new pCall = %X\n", pCall);
	if (pCall == 0)
		return (GKI_NO_MEMORY);

	pCall->SetCallType(usCallTypeChoice);
	pCall->SetCallIdentifier(pCallIdentifier);
	
	// Add this call to our call list
	g_pReg->AddCall(pCall);

	for (pAA = pRemoteInfo; pAA != 0; pAA = pAA->next)
	{
		if ((hResult = pCall->AddRemoteInfo(pAA->value)) != GKI_OK)
		{
			g_pReg->DeleteCall(pCall);
			return (hResult);
		}
	}

	if (pRemoteCallSignalAddress)
		pCall->SetRemoteCallSignalAddress(pRemoteCallSignalAddress);

	for (pAA = pDestExtraCallInfo; pAA != 0; pAA = pAA->next)
	{
		if ((hResult = pCall->AddDestExtraCallInfo(pAA->value)) != GKI_OK)
		{
			g_pReg->DeleteCall(pCall);
			return (hResult);
		}
	}

	if ((hResult = pCall->SetLocalCallSignalAddress(usCallTransport)) != GKI_OK)
	{
		g_pReg->DeleteCall(pCall);
		return (hResult);
	}

	pCall->SetBandWidth(bandWidth);
	pCall->SetCallReferenceValue(g_pReg->GetNextCRV());
	pCall->SetConferenceID(pConferenceID);
	pCall->SetActiveMC(activeMC);
	pCall->SetAnswerCall(answerCall);

	// Create AdmissionRequest structure - Encode and send PDU
	if ((hResult = pCall->AdmissionRequest()) != GKI_OK)
	{
		g_pReg->DeleteCall(pCall);
		return (hResult);
	}

	return (GKI_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\gkiman.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/gkiman.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1996 Intel Corporation.
 *
 *	$Revision:   1.19  $
 *	$Date:   27 Jan 1997 16:29:40  $
 *	$Author:   EHOWARDX  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *
 *	Notes:
 *
 ***************************************************************************/

#ifdef GATEKEEPER

#ifndef GKIMAN_H
#define GKIMAN_H

//extern HINSTANCE hGkiDll;
extern BOOL fGKConfigured;
extern BOOL fGKEnabled;
#define GKIExists() (fGKConfigured && fGKEnabled)

typedef enum _CHANNELTYPE
{
  TX,
  RX
} CHANNELTYPE;

typedef struct _BWREQ
{
  struct _BWREQ *   pNext;
  unsigned int      uChannelBandwidth;
  CC_HCHANNEL       hChannel;
  CHANNELTYPE       Type;
} BWREQ, *PBWREQ;

typedef enum _CALLTYPE
{
  POINT_TO_POINT  = 1,
  ONE_TO_MANY,
  MANY_TO_ONE,
  MANY_TO_MANY
} CALLTYPE;

typedef struct _GKICALL
{
  struct _GKICALL * pNext;
  struct _BWREQ *   pBwReqHead;
  struct _BWREQ *   pBwReqTail;
  unsigned int      uGkiCallState;
#define GCS_START                   0
#define GCS_WAITING                 1
#define GCS_ADMITTING               2
#define GCS_ADMITTING_CLOSE_PENDING 3
#define GCS_ADMITTED                4
#define GCS_CHANGING                5
#define GCS_CHANGING_CLOSE_PENDING  6
#define GCS_DISENGAGING             7
  void *            pCall;
  CALLTYPE          CallType;
  unsigned int      uBandwidthRequested;
  unsigned int      uBandwidthAllocated;
  unsigned int      uBandwidthUsed;
  unsigned char     *pConferenceId;
  BOOL              bConferenceIdPresent;
  BOOL              bActiveMC;
  BOOL              bAnswerCall;
  BOOL              bGatekeeperRouted;
  HANDLE            hGkiCall;
  CC_HCALL          hCall;
  DWORD             dwIpAddress;
  unsigned short    wPort;
  unsigned short    usCallModelChoice;
  unsigned short    usCallTypeChoice;
  unsigned short    usCRV;
  PCC_ALIASNAMES    pCalleeAliasNames;
  PCC_ALIASNAMES    pCalleeExtraAliasNames;
  GUID              CallIdentifier;
} GKICALL, *PGKICALL, **PPGKICALL;

HRESULT GkiSetRegistrationAliases(PCC_ALIASNAMES pLocalAliasNames);
HRESULT GkiSetVendorConfig( PCC_VENDORINFO pVendorInfo,
    DWORD dwMultipointConfiguration);
HRESULT GkiOpenListen  (CC_HLISTEN hListen, PCC_ALIASNAMES pAliasNames, DWORD dwAddr, WORD wPort);
HRESULT GkiListenAddr (SOCKADDR_IN* psin);
HRESULT GkiCloseListen (CC_HLISTEN hListen);
HRESULT GkiOpenCall    (PGKICALL pGkiCall, void *pConference);
HRESULT GkiCloseCall   (PGKICALL pGkiCall);
HRESULT GkiFreeCall    (PGKICALL pGkiCall);
HRESULT GkiOpenChannel (PGKICALL pGkiCall, unsigned uChannelBandwidth, CC_HCHANNEL hChannel, CHANNELTYPE Type);
HRESULT GkiCloseChannel(PGKICALL pGkiCall, unsigned uChannelBandwidth, CC_HCHANNEL hChannel);

#endif // GKIMAN_H

#endif // GATEKEEPER

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\gkireg.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\gkireg.cpv  $
*																		*
*	$Revision:   1.13  $
*	$Date:   14 Feb 1997 16:44:06  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\gkireg.cpv  $
//
//    Rev 1.13   14 Feb 1997 16:44:06   CHULME
// If fail to create semaphore - delete registration object before returning
//
//    Rev 1.12   12 Feb 1997 01:11:06   CHULME
// Redid thread synchronization to use Gatekeeper.Lock
//
//    Rev 1.11   08 Feb 1997 12:14:02   CHULME
// Added semaphore creation for later terminating the retry thread
//
//    Rev 1.10   24 Jan 1997 18:30:00   CHULME
// Reverted to rev 1.8
//
//    Rev 1.8   22 Jan 1997 20:46:08   EHOWARDX
// Work-around for race condition that may result in
// GKI_RegistrationRequest returning GKI_ALREADY_REG.
//
//    Rev 1.7   17 Jan 1997 09:02:16   CHULME
// Changed reg.h to gkreg.h to avoid name conflict with inc directory
//
//    Rev 1.6   10 Jan 1997 16:15:40   CHULME
// Removed MFC dependency
//
//    Rev 1.5   20 Dec 1996 16:38:28   CHULME
// Fixed access synchronization with Gatekeeper lock
//
//    Rev 1.4   13 Dec 1996 14:26:04   CHULME
// Fixed access error on thread synchronization
//
//    Rev 1.3   02 Dec 1996 23:50:50   CHULME
// Added premptive synchronization code
//
//    Rev 1.2   22 Nov 1996 15:22:24   CHULME
// Added VCS log to the header
*************************************************************************/

// gkiregistration.cpp : Handles the GKI_RegistrationRequest API
//

#include "precomp.h"

#include <process.h>
#include <winsock.h>
#include "GKICOM.H"
#include "dspider.h"
#include "dgkilit.h"
#include "DGKIPROT.H"
#include "GATEKPR.H"
#include "gksocket.h"
#include "GKREG.H"
#include "h225asn.h"
#include "coder.hpp"
#include "dgkiext.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern "C" HRESULT DLL_EXPORT
GKI_RegistrationRequest(long lVersion,
					   SeqTransportAddr *pCallSignalAddr,
					   EndpointType *pTerminalType,
					   SeqAliasAddr *pRgstrtnRqst_trmnlAls,
	 				   PCC_VENDORINFO      pVendorInfo,
					   HWND hWnd,
					   WORD wBaseMessage,
					   unsigned short usRegistrationTransport)
{
	// ABSTRACT:  This function is exported.  It is called by the client application
	//            to register with the Gatekeeper.  It will create a CRegistration
	//            object to track all pertanent information.
	// AUTHOR:    Colin Hulme

	int					nAddrFam;
	int					nRet;
	HRESULT				hResult;
	//char				*pDestAddr;
	PSOCKADDR_IN 		pDestAddr;
	SeqTransportAddr	*pTA;
	SeqAliasAddr		*pAA;
	HANDLE				hThread;
#ifdef _DEBUG
	char				szGKDebug[80];
#endif
	BOOL				fRAS = FALSE;

	SPIDER_TRACE(SP_FUNC, "GKI_RegistrationRequest(%x)\n", usRegistrationTransport);
	ASSERT(g_pGatekeeper);
	if(g_pGatekeeper == NULL)
		return (GKI_NOT_INITIALIZED);	
		
#ifdef _DEBUG
	if (dwGKIDLLFlags & SP_GKI)
	{
		SPIDER_TRACE(SP_GKI, "GKI_RegistrationRequest()\n", 0);
		Dump_GKI_RegistrationRequest(lVersion,
									pCallSignalAddr,
									pTerminalType,
									pRgstrtnRqst_trmnlAls,
									hWnd,
									wBaseMessage,
									usRegistrationTransport);
	}
#endif

	// Check if there is already a registration

	// Create a Gatekeeper lock object on the stack
	// It's constructor will lock pGK and when we return
	// from any path, its destructor will unlock pGK
	CGatekeeperLock	GKLock(g_pGatekeeper);
	if (g_pReg)
	{
		if (g_pReg->GetRasMessage() != 0)
			return (GKI_BUSY);
		else
			return (GKI_ALREADY_REG);
	}

	if (lVersion != GKI_VERSION)
		return (GKI_VERSION_ERROR);

	ASSERT((usRegistrationTransport == ipAddress_chosen) ||(usRegistrationTransport == ipxAddress_chosen));

	// Create a registration object
	g_pReg = new CRegistration;
	SPIDER_TRACE(SP_NEWDEL, "new g_pReg = %X\n", g_pReg);
	if (g_pReg == 0)
		return (GKI_NO_MEMORY);
#if(0)
	// Create the semaphore used to signal the retry thread to exit
	g_pReg->m_hRetrySemaphore = CreateSemaphore(NULL,0,1,NULL);
	if(!g_pReg->m_hRetrySemaphore){
		SPIDER_TRACE(SP_NEWDEL, "del g_pReg = %X\n", g_pReg);
		delete g_pReg;
		g_pReg = 0;
		return (GKI_SEMAPHORE_ERROR);
	}
#endif

	// Create a socket and bind to a local address
	g_pReg->m_pSocket = new CGKSocket;
	SPIDER_TRACE(SP_NEWDEL, "new g_pReg->m_pSocket = %X\n", g_pReg->m_pSocket);
	if (g_pReg->m_pSocket == 0)
	{
		SPIDER_TRACE(SP_NEWDEL, "del g_pReg = %X\n", g_pReg);
		delete g_pReg;
		g_pReg = 0;
		return (GKI_NO_MEMORY);
	}

	ASSERT(usRegistrationTransport == ipAddress_chosen);
	if(usRegistrationTransport != ipAddress_chosen)
	{
		delete g_pReg;
		g_pReg = 0;
		return (GKI_NO_MEMORY);
	}
	nAddrFam =  PF_INET;
	pDestAddr = g_pGatekeeper->GetSockAddr();

	if ((nRet = g_pReg->m_pSocket->Create(nAddrFam, 0)) != 0)
	{
		SPIDER_TRACE(SP_NEWDEL, "del g_pReg = %X\n", g_pReg);
		delete g_pReg;
		g_pReg = 0;
		return (GKI_WINSOCK2_ERROR(nRet));
	}

	// Initialize registration member variables
	for (pTA = pCallSignalAddr; pTA != 0; pTA = pTA->next)
	{
		if ((hResult = g_pReg->AddCallSignalAddr(pTA->value)) != GKI_OK)
		{
			SPIDER_TRACE(SP_NEWDEL, "del g_pReg = %X\n", g_pReg);
			delete g_pReg;
			g_pReg = 0;
			return (hResult);
		}
		// if the transport type of the address being registered is the same as
		// the transport type of the gatekeeper, set RAS address
		if (pTA->value.choice == usRegistrationTransport)
		{
			if ((hResult = g_pReg->AddRASAddr(pTA->value, g_pReg->m_pSocket->GetPort())) != GKI_OK)
			{
				SPIDER_TRACE(SP_NEWDEL, "del g_pReg = %X\n", g_pReg);
				delete g_pReg;
				g_pReg = 0;
				return (hResult);
			}
			else
				fRAS = TRUE;
		}
	}
	if(pVendorInfo)
	{
		hResult = g_pReg->AddVendorInfo(pVendorInfo);
	}

	if (fRAS == FALSE)		// No RAS address registered for this transport
	{
		SPIDER_TRACE(SP_NEWDEL, "del g_pReg = %X\n", g_pReg);
		delete g_pReg;
		g_pReg = 0;
		return (GKI_NO_TA_ERROR);
	}

	g_pReg->SetTerminalType(pTerminalType);
	for (pAA = pRgstrtnRqst_trmnlAls; pAA != 0; pAA = pAA->next)
	{
		if ((hResult = g_pReg->AddAliasAddr(pAA->value)) != GKI_OK)
		{
			SPIDER_TRACE(SP_NEWDEL, "del g_pReg = %X\n", g_pReg);
			delete g_pReg;
			g_pReg = 0;
			return (hResult);
		}
	}
	g_pReg->SetHWnd(hWnd);
	g_pReg->SetBaseMessage(wBaseMessage);
	g_pReg->SetRegistrationTransport(usRegistrationTransport);


#if(0)
	// Start the retries thread
	hThread = (HANDLE)_beginthread(Retry, 0, 0);
	SPIDER_TRACE(SP_THREAD, "_beginthread(Retry, 0 0); <%X>\n", hThread);
	if (hThread == (HANDLE)-1)
	{
		SPIDER_TRACE(SP_NEWDEL, "del g_pReg = %X\n", g_pReg);
		delete g_pReg;
		g_pReg = 0;
		return (GKI_NO_THREAD);
	}
	g_pReg->SetRetryThread(hThread);
#else
	// initialize timer and values
	UINT_PTR uTimer = g_pReg->StartRetryTimer();
	if (!uTimer)
	{
		SPIDER_TRACE(SP_NEWDEL, "del g_pReg = %X\n", g_pReg);
		delete g_pReg;
		g_pReg = 0;
		return (GKI_NO_THREAD);
	}
#endif




#ifdef BROADCAST_DISCOVERY
	// Check to see if we are not bound to a gatekeeper
	if (pDestAddr == 0)
	{
		hThread = (HANDLE)_beginthread(GKDiscovery, 0, 0);
		SPIDER_TRACE(SP_THREAD, "_beginthread(GKDiscovery, 0, 0); <%X>\n", hThread);
		if (hThread == (HANDLE)-1)
		{
			SPIDER_TRACE(SP_NEWDEL, "del g_pReg = %X\n", g_pReg);
			delete g_pReg;
			g_pReg = 0;
			return (GKI_NO_THREAD);
		}
		g_pReg->SetDiscThread(hThread);

		return (GKI_OK);
	}
#else
	ASSERT(pDestAddr);
#endif

	// Connect to destination gatekeeper and retrieve RAS port
	if ((nRet = g_pReg->m_pSocket->Connect(pDestAddr)) != 0)
	{
		SPIDER_TRACE(SP_NEWDEL, "del g_pReg = %X\n", g_pReg);
		delete g_pReg;
		g_pReg = 0;
		return (GKI_WINSOCK2_ERROR(nRet));
	}

	// Create RegistrationRequest structure - Encode and send PDU
	if ((hResult = g_pReg->RegistrationRequest(FALSE)) != GKI_OK)
	{
		SPIDER_TRACE(SP_NEWDEL, "del g_pReg = %X\n", g_pReg);
		delete g_pReg;
		g_pReg = 0;
		return (hResult);
	}

	// Post a receive on this socket
	hThread = (HANDLE)_beginthread(PostReceive, 0, 0);
	SPIDER_TRACE(SP_THREAD, "_beginthread(PostReceive, 0, 0); <%X>\n", hThread);
	if (hThread == (HANDLE)-1)
	{
		SPIDER_TRACE(SP_NEWDEL, "del g_pReg = %X\n", g_pReg);
		delete g_pReg;
		g_pReg = 0;
		return (GKI_NO_THREAD);
	}
	g_pReg->SetRcvThread(hThread);

	return (GKI_OK);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\gkreg.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\gkreg.cpv  $
*																		*
*	$Revision:   1.6  $
*	$Date:   26 Feb 1997 15:33:34  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\gkreg.cpv  $
//
//    Rev 1.6   26 Feb 1997 15:33:34   CHULME
// Call Coder.Free in case of error - potential memory leak plugged
//
//    Rev 1.5   14 Feb 1997 16:43:06   CHULME
// Updated comments and removed inaccurate comments
//
//    Rev 1.4   12 Feb 1997 01:12:52   CHULME
// Redid thread synchronization to use Gatekeeper.Lock
//
//    Rev 1.3   08 Feb 1997 12:15:48   CHULME
// Terminate retry thread in destructor via semaphore
//
//    Rev 1.2   21 Jan 1997 17:24:06   CHULME
// Removed gatekeeper identifier from gatekeeper request
//
//    Rev 1.1   17 Jan 1997 09:02:22   CHULME
// Changed reg.h to gkreg.h to avoid name conflict with inc directory
//
//    Rev 1.0   17 Jan 1997 08:48:08   CHULME
// Initial revision.
//
//    Rev 1.7   10 Jan 1997 16:15:58   CHULME
// Removed MFC dependency
//
//    Rev 1.6   20 Dec 1996 16:39:14   CHULME
// Removed extraneous debug statements
//
//    Rev 1.5   20 Dec 1996 01:27:24   CHULME
// Fixed memory leak with gatekeeper identifier
//
//    Rev 1.4   10 Dec 1996 11:26:36   CHULME
// Fixed handling of IRQ to not require response address in PDU
//
//    Rev 1.3   02 Dec 1996 23:49:58   CHULME
// Added premptive synchronization code
//
//    Rev 1.2   22 Nov 1996 15:22:16   CHULME
// Added VCS log to the header
*************************************************************************/

// registration.cpp : Provides the implementation for the CRegistration class
//
#include "precomp.h"

#include <process.h>
#include <stdlib.h>
#include <time.h>
#include "GKICOM.H"
#include "dspider.h"
#include "dgkilit.h"
#include "DGKIPROT.H"
#include "gksocket.h"
#include "GKREG.H"
#include "GATEKPR.H"
#include "h225asn.h"
#include "coder.hpp"
#include "dgkiext.h"
#include "ccerror.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLinkedList Implementation

template <class T> CLinkedList<T>::CLinkedList()
{
	pTail = NULL;
	iCount = 0;
}

template <class T> CLinkedList<T>::~CLinkedList()
{
	RemoveAll();
}

template <class T> void CLinkedList<T>::AddTail (const T& NewItem)
{
	AddTailPriv(new TItem<T>(NewItem));
}

template <class T> void CLinkedList<T>::AddTailPriv(TItem<T> *pNewItem)
{
	if (pTail) // if the list is non-empty - add to tail
	{
		pNewItem->pPrev = pTail;
		pNewItem->pNext = pTail->pNext;			// preserve the pointer to the head.
		pTail->pNext->pPrev = pNewItem;
		pTail->pNext = pNewItem;				// insert the new element
	}
	else										// insert first element
	{											// new element is the tail
		pNewItem->pPrev = pNewItem->pNext = pNewItem;	
	}

	pTail = pNewItem;							// move tail to the new item
	iCount++;
}

template <class T> BOOL CLinkedList<T>::IsEmpty(void)
{
	if (pTail == NULL)
	{ return TRUE; }
	else
	{ return FALSE; }
}

template <class T> POS CLinkedList<T>::GetFirstPos (void)
{
	if (pTail)
	{	return (POS) pTail->pNext;
	}
	else
	{	return NULL;
	}
}

template <class T> T CLinkedList<T>::GetNext (POS &Position)
{
	TItem<T> *pCurItem = (TItem<T> *)Position;
	T RetValue;

	if (Position)
	{
		RetValue = pCurItem->Value;
		if (pCurItem == pTail)		// we are at the end of the list
		{	Position = NULL;
		}
		else						// move to the next position
		{	Position = (POS)(pCurItem->pNext);
		}
	}
	return RetValue;
}

template <class T> POS CLinkedList<T>::Find (const T& Item)
{
	TItem<T> *pCurItem;
	
	if (!pTail)
	{	return NULL;
	}
	else
	{	
		pCurItem = pTail;
		do
		{
			pCurItem = pCurItem->pNext;	// starting with the head
			if (pCurItem->Value == Item)
			{	return ((POS) pCurItem); }
		}
		while (pCurItem != pTail);
	}
	return NULL;
}

// It moves Position to the next item after removint the current one.
template <class T> BOOL CLinkedList<T>::RemoveAt (POS &Position)
{
	TItem<T> *pCurItem = (TItem<T> *)Position;

	if (!pCurItem)
	{	return FALSE; }
	else if (pCurItem == pCurItem->pNext)		// The only element
	{
		Position = NULL;
		pTail = NULL;
		delete pCurItem;
	}
	else
	{
		Position = (POS) pCurItem->pNext;
		pCurItem->pPrev->pNext = pCurItem->pNext;
		pCurItem->pNext->pPrev = pCurItem->pPrev;
		if (pCurItem == pTail)
		{
			pTail = pCurItem->pPrev;
		}
		delete pCurItem;
	}
	iCount--;
	return TRUE;
}

template <class T> T CLinkedList<T>::GetAt(const POS Position)
{
	TItem<T> *pCurItem = (TItem<T> *)Position;
	T RetValue;

	if (Position)
	{	RetValue = pCurItem->Value;
	}

	return RetValue;
}

template <class T> void CLinkedList<T>::RemoveAll(void)
{
	TItem<T> *pCurItem;
	TItem<T> *pNextItem;

	if (pTail)
	{	
		pCurItem = pTail->pNext;			// Start with the head.
		pTail->pNext = NULL;

		while (pCurItem != NULL)
		{
			pNextItem = pCurItem->pNext;
			delete pCurItem;
			pCurItem = pNextItem;
		}
	}
	pTail = NULL;
	iCount = 0;
}

template <class T> int CLinkedList<T>::GetCount(void)
{
	return iCount;
}


VOID CALLBACK RetryTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{

#ifdef _DEBUG
	char			szGKDebug[80];
#endif
	HRESULT			hResult = GKI_OK;
	
	ASSERT(g_pGatekeeper);
	if(g_pGatekeeper == NULL)
		return;
		
	g_pGatekeeper->Lock();
	if(g_pReg)
	{
		hResult = g_pReg->Retry();
	}

	if(hResult != GKI_OK)
	{
		SPIDER_TRACE(SP_NEWDEL, "del g_pReg = %X\n", g_pReg);
		delete g_pReg;
		g_pReg = 0;
	}
	g_pGatekeeper->Unlock();
}



/////////////////////////////////////////////////////////////////////////////
// CRegistration construction

CRegistration::CRegistration()
{
	// ABSTRACT:  The constructor for the CRegistration class will initialize
	//            the member variables.  Notably missing is the construction
	//            of the pointed to socket object.  This must be done after
	//            constructing this object to allow for checking the error code.
	// AUTHOR:    Colin Hulme

#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_CONDES, "CRegistration::CRegistration()\n", 0);
	m_pVendorInfo = NULL;
	m_pCallSignalAddress = 0;
	memset(&m_terminalType, 0, sizeof(EndpointType));
	m_pRgstrtnRqst_trmnlAls = 0;
	m_hWnd = 0;
	m_wBaseMessage = 0;
	m_usRegistrationTransport = 0;

	m_pLocationInfo = 0;
	memset(&m_Location[0], 0, sizeof(TransportAddress) * 2);

	memset(&m_RCm_gtkprIdntfr, 0, sizeof(GatekeeperIdentifier));
	memset(&m_endpointID, 0, sizeof(EndpointIdentifier));

	m_requestSeqNum = 0;
	m_pRASAddress = 0;

	m_State = GK_REG_PENDING;
	SPIDER_TRACE(SP_STATE, "m_State = GK_REG_PENDING (%X)\n", this);

	m_pRasMessage = 0;
	m_pSocket = 0;
	m_hRcvThread = 0;
//	m_hRetryThread = 0;

	m_uTimer = 0;
	m_uRetryResetCount = GKR_RETRY_INTERVAL_SECONDS * (1000/GKR_RETRY_TICK_MS);
	m_uRetryCountdown = GKR_RETRY_INTERVAL_SECONDS;
	m_uMaxRetryCount = GKR_RETRY_MAX;
	m_usRetryCount = 0;
	InitializeCriticalSection(&m_SocketCRS);

#ifdef BROADCAST_DISCOVERY	
	m_hDiscThread = 0;
#endif
//	m_dwLockingThread = 0;
//	m_hRetrySemaphore = NULL;

//	InitializeCriticalSection(&m_CriticalSection);

	// Initialize the base call reference value to a random number
	srand( (unsigned)time( NULL ) );
	m_usCallReferenceValue = (unsigned short)rand();
}

/////////////////////////////////////////////////////////////////////////////
// CRegistration destruction

CRegistration::~CRegistration()
{
	// ABSTRACT:  The destructor for the CRegistration class must free the
	//            memory allocated for the Transport addresses and Alias
	//            addresses.  It does this by deleting the structures and
	//            walking the link list.
	// AUTHOR:    Colin Hulme

	SeqTransportAddr	*pTA1, *pTA2;
	SeqAliasAddr		*pAA1, *pAA2;
	DWORD				dwErrorCode;
#ifdef _DEBUG
	char				szGKDebug[80];
#endif

	SPIDER_TRACE(SP_CONDES, "CRegistration::~CRegistration()\n", 0);

#if(0)
	// Terminate the Retry Thread
	if(m_hRetryThread)
	{
		if(m_hRetrySemaphore)
		{
			SPIDER_TRACE(SP_THREAD, "Release retry thread %X\n", m_hRetryThread);
			// Signal the thread to shutdown
			ReleaseSemaphore(m_hRetrySemaphore,1,NULL);

			// Wait for the thread to terminate
			dwErrorCode = WaitForSingleObject(m_hRetryThread, TIMEOUT_THREAD);
			m_hRetryThread = NULL;
		}
	}
#else

	// Stop retry timer
	if(m_uTimer)
	{
		KillTimer(m_hWnd, m_uTimer);
	}
#endif
	if(m_pVendorInfo)
		FreeVendorInfo(m_pVendorInfo);
		
	// Delete allocated memory for sequence of call signal addresses
	pTA1 = m_pCallSignalAddress;
	while (pTA1 != 0)
	{
		pTA2 = pTA1->next;
		SPIDER_TRACE(SP_NEWDEL, "del pTA1 = %X\n", pTA1);
		delete pTA1;
		pTA1 = pTA2;
	}

	// Delete allocated memory for sequence of alias addresses
	pAA1 = m_pRgstrtnRqst_trmnlAls;
	while (pAA1 != 0)
	{
		pAA2 = pAA1->next;
		if (pAA1->value.choice == h323_ID_chosen)
		{
			SPIDER_TRACE(SP_NEWDEL, "del pAA1->value.u.h323_ID.value = %X\n", pAA1->value.u.h323_ID.value);
			delete pAA1->value.u.h323_ID.value;
		}
		SPIDER_TRACE(SP_NEWDEL, "del pAA1 = %X\n", pAA1);
		delete pAA1;
		pAA1 = pAA2;
	}

	// Delete allocated memory for sequence of location alias addresses
	pAA1 = m_pLocationInfo;
	while (pAA1 != 0)
	{
		pAA2 = pAA1->next;
		if (pAA1->value.choice == h323_ID_chosen)
		{
			SPIDER_TRACE(SP_NEWDEL, "del pAA1->value.u.h323_ID.value = %X\n", pAA1->value.u.h323_ID.value);
			delete pAA1->value.u.h323_ID.value;
		}
		SPIDER_TRACE(SP_NEWDEL, "del pAA1 = %X\n", pAA1);
		delete pAA1;
		pAA1 = pAA2;
	}

	// Delete allocated memory for identifiers
	if (m_RCm_gtkprIdntfr.length)
	{
		SPIDER_TRACE(SP_NEWDEL, "del m_RCm_gtkprIdntfr.value = %X\n", m_RCm_gtkprIdntfr.value);
		delete m_RCm_gtkprIdntfr.value;
	}
	if (m_endpointID.length)
	{
		SPIDER_TRACE(SP_NEWDEL, "del m_endpointID.value = %X\n", m_endpointID.value);
		delete m_endpointID.value;
	}

	// Delete allocated memory for sequence of RAS addresses
	pTA1 = m_pRASAddress;
	while (pTA1 != 0)
	{
		pTA2 = pTA1->next;
		SPIDER_TRACE(SP_NEWDEL, "del pTA1 = %X\n", pTA1);
		delete pTA1;
		pTA1 = pTA2;
	}

	if (!m_Calls.IsEmpty())
	{
		// Free up any call objects
		// on this registration object
		POS pos;
		for( pos = m_Calls.GetFirstPos(); pos != NULL; )
		{
			// Delete the call object
			CCall *pCall = m_Calls.GetNext(pos);
			SPIDER_TRACE(SP_NEWDEL, "del pCall = %X\n", pCall);
			delete pCall;
		}
		// Now remove all pointers from the list
		m_Calls.RemoveAll();
	}

	// Delete memory for last RAS message if still allocated
	if (m_pRasMessage)
	{
		SPIDER_TRACE(SP_NEWDEL, "del m_pRasMessage = %X\n", m_pRasMessage);
		delete m_pRasMessage;
	}

//	if (m_dwLockingThread)
//		Unlock();
//	DeleteCriticalSection(&m_CriticalSection);
#if(0)
	if(m_hRetrySemaphore)
	{
		CloseHandle(m_hRetrySemaphore);
		m_hRetrySemaphore = NULL;
	}
#endif

	
	m_pSocket->Close();
	
	LockSocket();
	// Close the socket and delete the socket object
	SPIDER_TRACE(SP_NEWDEL, "del m_pSocket = %X\n", m_pSocket);
	delete m_pSocket;
	UnlockSocket();

	DeleteCriticalSection(&m_SocketCRS);
}

UINT_PTR CRegistration::StartRetryTimer(void)
{
	if(m_uTimer)
	{
		KillTimer(m_hWnd, m_uTimer);
		m_uTimer = 0;
	}
	m_uRetryResetCount = GKR_RETRY_INTERVAL_SECONDS * (1000/GKR_RETRY_TICK_MS);
	m_uRetryCountdown = GKR_RETRY_INTERVAL_SECONDS;
	m_uMaxRetryCount = GKR_RETRY_MAX;
	m_usRetryCount = 0;

	m_uTimer = SetTimer(NULL, NULL, GKR_RETRY_TICK_MS, RetryTimerProc);
	//m_uTimer = SetTimer(hWnd, GKREG_TIMER_ID, GKR_RETRY_TICK_MS, RetryTimerProc);
	return m_uTimer;
}

HRESULT
CRegistration::AddVendorInfo(PCC_VENDORINFO pVendorInfo)
{
	HRESULT hr = GKI_OK;
	if(m_pVendorInfo)
	{
		FreeVendorInfo(m_pVendorInfo);
		m_pVendorInfo = NULL;
	}
	if(pVendorInfo)
	{
		hr = CopyVendorInfo(&m_pVendorInfo, pVendorInfo);
		if(hr != CC_OK)
		{
			m_pVendorInfo = NULL;
		}
	}
	return hr;
}

HRESULT
CRegistration::AddCallSignalAddr(TransportAddress& rvalue)
{
	// ABSTRACT:  This procedure is called to add a call signal address
	//            to the link list of call signal addresses.  This will
	//            be called for each transport on receiving a GKI_RegistrationRequest.
	//            A local copy is made to avoid reliance on the client
	//            keeping the memory valid.  This procedure returns 0 if
	//            successful and non-zero for a failure.
	// AUTHOR:    Colin Hulme

	SeqTransportAddr			*pCSA;
#ifdef _DEBUG
	char						szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CRegistration::AddCallSignalAddr(%X)\n", rvalue.choice);

	if (m_pCallSignalAddress == 0)	// First one in the list
	{
		m_pCallSignalAddress = new SeqTransportAddr;
		SPIDER_TRACE(SP_NEWDEL, "new m_pCallSignalAddress = %X\n", m_pCallSignalAddress);
		if (m_pCallSignalAddress == 0)
			return (GKI_NO_MEMORY);
		memset(m_pCallSignalAddress, 0, sizeof(SeqTransportAddr));
		pCSA = m_pCallSignalAddress;
	}
	else
	{
		for (pCSA = m_pCallSignalAddress; pCSA->next != 0; pCSA = pCSA->next)
			;						// walk the list til last entry
		pCSA->next = new SeqTransportAddr;
		SPIDER_TRACE(SP_NEWDEL, "new pCSA->next = %X\n", pCSA->next);
		if (pCSA->next == 0)
			return (GKI_NO_MEMORY);
		memset(pCSA->next, 0, sizeof(SeqTransportAddr));
		pCSA = pCSA->next;
	}
	pCSA->next = 0;					// initialize new structure fields
	pCSA->value = rvalue;
	return (GKI_OK);
}

HRESULT
CRegistration::AddRASAddr(TransportAddress& rvalue, unsigned short usPort)
{
	// ABSTRACT:  This procedure is called to add a RAS address
	//            to the link list of RAS addresses.  This will
	//            be called only for the transport used for the registration
	//            request.  This procedure returns 0 if successful and non-zero
	//            for a failure.
	// AUTHOR:    Colin Hulme

#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CRegistration::AddRASAddr(%X, usPort)\n", rvalue.choice);

	m_pRASAddress = new SeqTransportAddr;
	SPIDER_TRACE(SP_NEWDEL, "new m_pRASAddress = %X\n", m_pRASAddress);
	if (m_pRASAddress == 0)
		return (GKI_NO_MEMORY);
	memset(m_pRASAddress, 0, sizeof(SeqTransportAddr));
	m_pRASAddress->next = 0;					// initialize new structure fields
	m_pRASAddress->value = rvalue;

	// Add actual RAS port to RAS address
	switch (m_pRASAddress->value.choice)
	{
	case ipAddress_chosen:
		m_pRASAddress->value.u.ipAddress.port = usPort;
		break;
	case ipxAddress_chosen:
		m_pRASAddress->value.u.ipxAddress.port.value[0] = HIBYTE(usPort);
		m_pRASAddress->value.u.ipxAddress.port.value[1] = LOBYTE(usPort);
		break;
	}
	return (GKI_OK);
}

HRESULT
CRegistration::AddAliasAddr(AliasAddress& rvalue)
{
	// ABSTRACT:  This procedure is called to add an alias address
	//            to the link list of alias addresses.  This will
	//            be called for each alias on receiving a GKI_RegistrationRequest.
	//            A local copy is made to avoid reliance on the client
	//            keeping the memory valid.
	//            In the eventuality that the gatekeeper assigns alias
	//            addresses, this procedure will be called for each alias
	//            contained in the registrationConfirm message.
	//            This procedure returns 0 if successful and non-zero
	//            for a failure.
	// AUTHOR:    Colin Hulme

	SeqAliasAddr	*p1;
	unsigned short	uIdx;
	unsigned short	*pus;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CRegistration::AddAliasAddr(%X)\n", rvalue.choice);

	if (m_pRgstrtnRqst_trmnlAls == 0)	// First one in the list
	{
		m_pRgstrtnRqst_trmnlAls = new SeqAliasAddr;
		SPIDER_TRACE(SP_NEWDEL, "new m_pRgstrtnRqst_trmnlAls = %X\n", m_pRgstrtnRqst_trmnlAls);
		if (m_pRgstrtnRqst_trmnlAls == 0)
			return (GKI_NO_MEMORY);
		memset(m_pRgstrtnRqst_trmnlAls, 0, sizeof(SeqAliasAddr));
		p1 = m_pRgstrtnRqst_trmnlAls;
	}
	else
	{
		for (p1 = m_pRgstrtnRqst_trmnlAls; p1->next != 0; p1 = p1->next)
			;						// walk the list til last entry
		p1->next = new SeqAliasAddr;
		SPIDER_TRACE(SP_NEWDEL, "new p1->next = %X\n", p1->next);
		if (p1->next == 0)
			return (GKI_NO_MEMORY);
		memset(p1->next, 0, sizeof(SeqAliasAddr));
		p1 = p1->next;
	}
	p1->next = 0;					// initialize new structure fields
	p1->value = rvalue;
	if (p1->value.choice == h323_ID_chosen)
	{
		pus = new unsigned short[p1->value.u.h323_ID.length];
		SPIDER_TRACE(SP_NEWDEL, "new pus = %X\n", pus);
		if (pus == 0)
			return (GKI_NO_MEMORY);
		memset(pus, 0, sizeof(unsigned short) * p1->value.u.h323_ID.length);
		for (uIdx = 0; uIdx < p1->value.u.h323_ID.length; uIdx++)
			*(pus + uIdx) = *(p1->value.u.h323_ID.value + uIdx);
		p1->value.u.h323_ID.value = pus;
	}
	return (GKI_OK);
}

HRESULT
CRegistration::AddLocationInfo(AliasAddress& rvalue)
{
	// ABSTRACT:  This procedure is called to add an alias address
	//            to the link list of alias addresses.  This will
	//            be called for each alias on receiving a GKI_RegistrationRequest.
	//            A local copy is made to avoid reliance on the client
	//            keeping the memory valid.
	//            In the eventuality that the gatekeeper assigns alias
	//            addresses, this procedure will be called for each alias
	//            contained in the registrationConfirm message.
	//            This procedure returns 0 if successful and non-zero
	//            for a failure.
	// AUTHOR:    Colin Hulme

	SeqAliasAddr	*p1;
	unsigned short	uIdx;
	unsigned short	*pus;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CRegistration::AddLocationInfo(%X)\n", rvalue.choice);

	if (m_pLocationInfo == 0)	// First one in the list
	{
		m_pLocationInfo = new SeqAliasAddr;
		SPIDER_TRACE(SP_NEWDEL, "new m_pLocationInfo = %X\n", m_pLocationInfo);
		if (m_pLocationInfo == 0)
			return (GKI_NO_MEMORY);
		memset(m_pLocationInfo, 0, sizeof(SeqAliasAddr));
		p1 = m_pLocationInfo;
	}
	else
	{
		for (p1 = m_pLocationInfo; p1->next != 0; p1 = p1->next)
			;						// walk the list til last entry
		p1->next = new SeqAliasAddr;
		SPIDER_TRACE(SP_NEWDEL, "new p1->next = %X\n", p1->next);
		if (p1->next == 0)
			return (GKI_NO_MEMORY);
		memset(p1->next, 0, sizeof(SeqAliasAddr));
		p1 = p1->next;
	}
	p1->next = 0;					// initialize new structure fields
	p1->value = rvalue;
	if (p1->value.choice == h323_ID_chosen)
	{
		pus = new unsigned short[p1->value.u.h323_ID.length];
		SPIDER_TRACE(SP_NEWDEL, "new pus = %X\n", pus);
		if (pus == 0)
			return (GKI_NO_MEMORY);
		memset(pus, 0, sizeof(unsigned short) * p1->value.u.h323_ID.length);
		for (uIdx = 0; uIdx < p1->value.u.h323_ID.length; uIdx++)
			*(pus + uIdx) = *(p1->value.u.h323_ID.value + uIdx);
		p1->value.u.h323_ID.value = pus;
	}
	return (GKI_OK);
}

TransportAddress *
CRegistration::GetTransportAddress(unsigned short usCallTransport)
{
	SeqTransportAddr			*pCSA;

	for (pCSA = m_pCallSignalAddress; pCSA != 0; pCSA = pCSA->next)
	{
		if (pCSA->value.choice == usCallTransport)
			return (&pCSA->value);
	}
	return (NULL);	// Didn't find it
}

HRESULT
CRegistration::RegistrationRequest(BOOL fDiscovery)
{
	// ABSTRACT:  This procedure will create a RegistrationRequest structure
	//            call the encoder and send the PDU.  If it is successful, it
	//            will return 0, else it will return an error code.  Note:  The
	//            memory allocated for the RAS Message is not freed until either
	//            a response from the gatekeeper or it times out.  This allows
	//            for retransmission without having to rebuild this message.
	// AUTHOR:    Colin Hulme

	ASN1_BUF		Asn1Buf;
	DWORD			dwErrorCode;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CRegistration::RegistrationRequest()\n", 0);
	ASSERT(g_pCoder);
	if (g_pCoder == NULL)
		return (GKI_NOT_INITIALIZED);	

	// Allocate a RasMessage structure and initialized to 0
	m_usRetryCount = 0;
	m_uRetryCountdown = m_uRetryResetCount;
	
	m_pRasMessage = new RasMessage;
	SPIDER_TRACE(SP_NEWDEL, "new m_pRasMessage = %X\n", m_pRasMessage);
	if (m_pRasMessage == 0)
		return (GKI_NO_MEMORY);
	memset(m_pRasMessage, 0, sizeof(RasMessage));

	// Setup structure fields for RegistrationRequest
	m_pRasMessage->choice = registrationRequest_chosen;
	if (m_pRgstrtnRqst_trmnlAls != 0)
		m_pRasMessage->u.registrationRequest.bit_mask |= RgstrtnRqst_trmnlAls_present;
	if (m_RCm_gtkprIdntfr.length != 0)
		m_pRasMessage->u.registrationRequest.bit_mask |= RgstrtnRqst_gtkprIdntfr_present;

	m_pRasMessage->u.registrationRequest.requestSeqNum = ++m_requestSeqNum;

	// discoveryComplete is a ASN1_BOOL (char) and fDiscovery is a BOOL (int) so the
	// cast was added to remove a compiler warning.  Since the value of fDiscovery
	// is always 0 or 1, no loss occurs in the cast. -- DLD
	m_pRasMessage->u.registrationRequest.discoveryComplete = (ASN1_BOOL)fDiscovery;
	m_pRasMessage->u.registrationRequest.callSignalAddress = (PRegistrationRequest_callSignalAddress)m_pCallSignalAddress;
	m_pRasMessage->u.registrationRequest.rasAddress = (PRegistrationRequest_rasAddress)m_pRASAddress;
	m_pRasMessage->u.registrationRequest.terminalType = m_terminalType;
	m_pRasMessage->u.registrationRequest.RgstrtnRqst_trmnlAls = (PRegistrationRequest_terminalAlias)m_pRgstrtnRqst_trmnlAls;
	m_pRasMessage->u.registrationRequest.RgstrtnRqst_gtkprIdntfr = m_RCm_gtkprIdntfr;
	m_pRasMessage->u.registrationRequest.endpointVendor.bit_mask = 0;

	if(m_pVendorInfo)
	{
		m_pRasMessage->u.registrationRequest.endpointVendor.vendor.t35CountryCode
			= m_pVendorInfo->bCountryCode;

		m_pRasMessage->u.registrationRequest.endpointVendor.vendor.t35Extension
			= m_pVendorInfo->bExtension;
		m_pRasMessage->u.registrationRequest.endpointVendor.vendor.manufacturerCode
			= m_pVendorInfo->wManufacturerCode;

		if(m_pVendorInfo->pProductNumber
			&& m_pVendorInfo->pProductNumber->pOctetString
			&& m_pVendorInfo->pProductNumber->wOctetStringLength)
		{
			UINT uSize = min(m_pVendorInfo->pProductNumber->wOctetStringLength,
				  	sizeof(m_pRasMessage->u.registrationRequest.endpointVendor.productId.value));
					
			m_pRasMessage->u.registrationRequest.endpointVendor.bit_mask |= productId_present;
			// truncate to fit size of registrationRequest.endpointVendor.productId.value
			m_pRasMessage->u.registrationRequest.endpointVendor.productId.length = uSize;
			memcpy(&m_pRasMessage->u.registrationRequest.endpointVendor.productId.value,
				m_pVendorInfo->pProductNumber->pOctetString, uSize);
		}

		if(m_pVendorInfo->pVersionNumber
			&& m_pVendorInfo->pVersionNumber->pOctetString
			&& m_pVendorInfo->pVersionNumber->wOctetStringLength)
		{
			UINT uSize = min(m_pVendorInfo->pVersionNumber->wOctetStringLength,
				  	sizeof(m_pRasMessage->u.registrationRequest.endpointVendor.versionId.value));
			m_pRasMessage->u.registrationRequest.endpointVendor.bit_mask |= versionId_present;
			// truncate to fit size of registrationRequest.endpointVendor.versionId.value
			m_pRasMessage->u.registrationRequest.endpointVendor.versionId.length = uSize;
			memcpy(&m_pRasMessage->u.registrationRequest.endpointVendor.versionId.value,
				m_pVendorInfo->pVersionNumber->pOctetString, uSize);
		}
	}		
#ifdef _DEBUG
	if (dwGKIDLLFlags & SP_DUMPMEM)
		DumpMem(m_pRasMessage, sizeof(RasMessage));
#endif

	// Assign ProtocolIdentifier
	g_pCoder->SetProtocolIdentifier(*m_pRasMessage);

	// Encode the PDU & send it
	dwErrorCode = g_pCoder->Encode(m_pRasMessage, &Asn1Buf);
	if (dwErrorCode)
		return (GKI_ENCODER_ERROR);

	// Create a backup copy of the encoded PDU if using debug echo support
	if (fGKIEcho)
	{
		pEchoBuff = new char[Asn1Buf.length];
		SPIDER_TRACE(SP_NEWDEL, "new pEchoBuff = %X\n", pEchoBuff);
		if (pEchoBuff == 0)
			return (GKI_NO_MEMORY);
		memcpy(pEchoBuff, (char *)Asn1Buf.value, Asn1Buf.length);
		nEchoLen = Asn1Buf.length;
	}

	SPIDER_TRACE(SP_PDU, "Send RRQ; g_pReg = %X\n", this);
	if (fGKIDontSend == FALSE)
		if (m_pSocket->Send((char *)Asn1Buf.value, Asn1Buf.length) == SOCKET_ERROR)
			return (GKI_WINSOCK2_ERROR(SOCKET_ERROR));

	// Free the encoder memory
	g_pCoder->Free(Asn1Buf);

	return (GKI_OK);
}

HRESULT
CRegistration::UnregistrationRequest(void)
{
	// ABSTRACT:  This procedure will create an UnregistrationRequest structure
	//            call the encoder and send the PDU.  If it is successful, it
	//            will return 0, else it will return an error code.
	// AUTHOR:    Colin Hulme

	ASN1_BUF		Asn1Buf;
	DWORD			dwErrorCode;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CRegistration::UnregistrationRequest()\n", 0);
	ASSERT(g_pCoder);
	if (g_pCoder == NULL)
		return (GKI_NOT_INITIALIZED);	
		
	// Allocate a RasMessage structure and initialized to 0
	m_usRetryCount = 0;
	m_uRetryCountdown = m_uRetryResetCount;
	
	m_pRasMessage = new RasMessage;
	SPIDER_TRACE(SP_NEWDEL, "new m_pRasMessage = %X\n", m_pRasMessage);
	if (m_pRasMessage == 0)
		return (GKI_NO_MEMORY);
	memset(m_pRasMessage, 0, sizeof(RasMessage));

	// Setup structure fields for UnregistrationRequest
	m_pRasMessage->choice = unregistrationRequest_chosen;
	if (m_pRgstrtnRqst_trmnlAls != 0)
		m_pRasMessage->u.unregistrationRequest.bit_mask |= UnrgstrtnRqst_endpntAls_present;
	if (m_endpointID.length != 0)
		m_pRasMessage->u.unregistrationRequest.bit_mask |= URt_endpntIdntfr_present;
	
	m_pRasMessage->u.unregistrationRequest.requestSeqNum = ++m_requestSeqNum;
	m_pRasMessage->u.unregistrationRequest.callSignalAddress = (PUnregistrationRequest_callSignalAddress)m_pCallSignalAddress;
	m_pRasMessage->u.unregistrationRequest.UnrgstrtnRqst_endpntAls = (PUnregistrationRequest_endpointAlias)m_pRgstrtnRqst_trmnlAls;
	m_pRasMessage->u.unregistrationRequest.URt_endpntIdntfr = m_endpointID;
#ifdef _DEBUG
	if (dwGKIDLLFlags & SP_DUMPMEM)
		DumpMem(m_pRasMessage, sizeof(RasMessage));
#endif

	// Encode the PDU & send it
	dwErrorCode = g_pCoder->Encode(m_pRasMessage, &Asn1Buf);
	if (dwErrorCode)
		return (GKI_ENCODER_ERROR);

	// Create a backup copy of the encoded PDU if using debug echo support
	if (fGKIEcho)
	{
		pEchoBuff = new char[Asn1Buf.length];
		SPIDER_TRACE(SP_NEWDEL, "new pEchoBuff = %X\n", pEchoBuff);
		if (pEchoBuff == 0)
			return (GKI_NO_MEMORY);
		memcpy(pEchoBuff, (char *)Asn1Buf.value, Asn1Buf.length);
		nEchoLen = Asn1Buf.length;
	}

	m_State = GK_UNREG_PENDING;
	SPIDER_TRACE(SP_STATE, "m_State = GK_UNREG_PENDING (%X)\n", this);

	SPIDER_TRACE(SP_PDU, "Send URQ; g_pReg = %X\n", this);
	if (fGKIDontSend == FALSE)
		if (m_pSocket->Send((char *)Asn1Buf.value, Asn1Buf.length) == SOCKET_ERROR)
			return (GKI_WINSOCK2_ERROR(SOCKET_ERROR));

	// Free the encoder memory
	g_pCoder->Free(Asn1Buf);

	return (GKI_OK);
}

HRESULT
CRegistration::LocationRequest(void)
{
	// ABSTRACT:  This procedure will create a LocationRequest structure
	//            call the encoder and send the PDU.  If it is successful, it
	//            will return 0, else it will return an error code.  Note:  The
	//            memory allocated for the RAS Message is not freed until either
	//            a response from the gatekeeper or it times out.  This allows
	//            for retransmission without having to rebuild this message.
	// AUTHOR:    Colin Hulme

	ASN1_BUF		Asn1Buf;
	DWORD			dwErrorCode;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CRegistration::LocationRequest()\n", 0);
	ASSERT(g_pCoder);
	if (g_pCoder == NULL)
		return (GKI_NOT_INITIALIZED);	
		
	// Allocate a RasMessage structure and initialized to 0
	m_usRetryCount = 0;
	m_uRetryCountdown = m_uRetryResetCount;
	
	m_pRasMessage = new RasMessage;
	SPIDER_TRACE(SP_NEWDEL, "new m_pRasMessage = %X\n", m_pRasMessage);
	if (m_pRasMessage == 0)
		return (GKI_NO_MEMORY);
	memset(m_pRasMessage, 0, sizeof(RasMessage));

	// Setup structure fields for LocationRequest
	m_pRasMessage->choice = locationRequest_chosen;
	if (m_endpointID.length != 0)
		m_pRasMessage->u.locationRequest.bit_mask |= LctnRqst_endpntIdntfr_present;
	
	m_pRasMessage->u.locationRequest.requestSeqNum = ++m_requestSeqNum;

	m_pRasMessage->u.locationRequest.LctnRqst_endpntIdntfr = m_endpointID;
	m_pRasMessage->u.locationRequest.destinationInfo =
			(PLocationRequest_destinationInfo)m_pLocationInfo;
	m_pRasMessage->u.locationRequest.replyAddress = m_pRASAddress->value;

#ifdef _DEBUG
	if (dwGKIDLLFlags & SP_DUMPMEM)
		DumpMem(m_pRasMessage, sizeof(RasMessage));
#endif

	// Encode the PDU & send it
	dwErrorCode = g_pCoder->Encode(m_pRasMessage, &Asn1Buf);
	if (dwErrorCode)
		return (GKI_ENCODER_ERROR);

	// Create a backup copy of the encoded PDU if using debug echo support
	if (fGKIEcho)
	{
		pEchoBuff = new char[Asn1Buf.length];
		SPIDER_TRACE(SP_NEWDEL, "new pEchoBuff = %X\n", pEchoBuff);
		if (pEchoBuff == 0)
			return (GKI_NO_MEMORY);
		memcpy(pEchoBuff, (char *)Asn1Buf.value, Asn1Buf.length);
		nEchoLen = Asn1Buf.length;
	}

	m_State = GK_LOC_PENDING;
	SPIDER_TRACE(SP_STATE, "m_State = GK_LOC_PENDING (%X)\n", this);

	SPIDER_TRACE(SP_PDU, "Send LRQ; g_pReg = %X\n", this);
	if (fGKIDontSend == FALSE)
		if (m_pSocket->Send((char *)Asn1Buf.value, Asn1Buf.length) == SOCKET_ERROR)
			return (GKI_WINSOCK2_ERROR(SOCKET_ERROR));

	// Free the encoder memory
	g_pCoder->Free(Asn1Buf);

	return (GKI_OK);
}

HRESULT
CRegistration::GatekeeperRequest(void)
{
	// ABSTRACT:  This procedure will create a GatekeeperRequest structure
	//            call the encoder and send the PDU.  If it is successful, it
	//            will return 0, else it will return an error code.
	// AUTHOR:    Colin Hulme

	ASN1_BUF		Asn1Buf;
	DWORD			dwErrorCode;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CRegistration::GatekeeperRequest()\n", 0);
	ASSERT(g_pCoder);
	if (g_pCoder == NULL)
		return (GKI_NOT_INITIALIZED);	
		
	// Allocate a RasMessage structure and initialized to 0
	m_usRetryCount = 0;
	m_uRetryCountdown = m_uRetryResetCount;
	
	m_pRasMessage = new RasMessage;
	SPIDER_TRACE(SP_NEWDEL, "new m_pRasMessage = %X\n", m_pRasMessage);
	if (m_pRasMessage == 0)
		return (GKI_NO_MEMORY);
	memset(m_pRasMessage, 0, sizeof(RasMessage));

	// Setup structure fields for GatekeeperRequest
	m_pRasMessage->choice = gatekeeperRequest_chosen;
	if (m_pRgstrtnRqst_trmnlAls != 0)
		m_pRasMessage->u.gatekeeperRequest.bit_mask |= GtkprRqst_endpointAlias_present;
	
	m_pRasMessage->u.gatekeeperRequest.requestSeqNum = ++m_requestSeqNum;

	m_pRasMessage->u.gatekeeperRequest.rasAddress = m_pRASAddress->value;
	m_pRasMessage->u.gatekeeperRequest.endpointType = m_terminalType;
	m_pRasMessage->u.gatekeeperRequest.GtkprRqst_endpointAlias = (PGatekeeperRequest_endpointAlias)m_pRgstrtnRqst_trmnlAls;

	// Assign ProtocolIdentifier
	g_pCoder->SetProtocolIdentifier(*m_pRasMessage);

	// Encode the PDU & send it
	dwErrorCode = g_pCoder->Encode(m_pRasMessage, &Asn1Buf);
	if (dwErrorCode)
		return (GKI_ENCODER_ERROR);

	// Create a backup copy of the encoded PDU if using debug echo support
	if (fGKIEcho)
	{
		pEchoBuff = new char[Asn1Buf.length];
		SPIDER_TRACE(SP_NEWDEL, "new pEchoBuff = %X\n", pEchoBuff);
		if (pEchoBuff == 0)
			return (GKI_NO_MEMORY);
		memcpy(pEchoBuff, (char *)Asn1Buf.value, Asn1Buf.length);
		nEchoLen = Asn1Buf.length;
	}

	SPIDER_TRACE(SP_PDU, "Send GRQ; g_pReg = %X\n", this);
	if (fGKIDontSend == FALSE)
	{
		if (m_pSocket->SendBroadcast((char *)Asn1Buf.value, Asn1Buf.length) == SOCKET_ERROR)
		{
			g_pCoder->Free(Asn1Buf);
			return (GKI_WINSOCK2_ERROR(SOCKET_ERROR));
		}
	}

	// Free the encoder memory
	g_pCoder->Free(Asn1Buf);

	return (GKI_OK);
}

HRESULT
CRegistration::PDUHandler(RasMessage *pRasMessage)
{
	// ABSTRACT:  This procedure will interpret the received PDU and dispatch
	//            to the appropriate handler.
	// AUTHOR:    Colin Hulme

#ifdef _DEBUG
	char			szGKDebug[80];
#endif
	HRESULT			hResult = GKI_OK;

	SPIDER_TRACE(SP_FUNC, "CRegistration::PDUHandler(%X)\n", pRasMessage);
	ASSERT(g_pCoder);
	if (g_pCoder == NULL)
		return (GKI_NOT_INITIALIZED);	
		
	switch (pRasMessage->choice)
	{
	// Incoming response PDUs
	case gatekeeperConfirm_chosen:
		SPIDER_TRACE(SP_PDU, "Rcv GCF; g_pReg = %X\n", this);
		break;
	case gatekeeperReject_chosen:
		SPIDER_TRACE(SP_PDU, "Rcv GRJ; g_pReg = %X\n", this);
		break;
	case registrationConfirm_chosen:
		SPIDER_TRACE(SP_PDU, "Rcv RCF; g_pReg = %X\n", this);
		if ((m_State == GK_REG_PENDING) &&
				(pRasMessage->u.registrationConfirm.requestSeqNum ==
				m_pRasMessage->u.registrationRequest.requestSeqNum))
			hResult = RegistrationConfirm(pRasMessage);
		else
			hResult = UnknownMessage(pRasMessage);
		break;
	case registrationReject_chosen:
		SPIDER_TRACE(SP_PDU, "Rcv RRJ; g_pReg = %X\n", this);
		if ((m_State == GK_REG_PENDING) &&
				(pRasMessage->u.registrationReject.requestSeqNum ==
				m_pRasMessage->u.registrationRequest.requestSeqNum))
			hResult = RegistrationReject(pRasMessage);
		else
			hResult = UnknownMessage(pRasMessage);
		break;
	case unregistrationConfirm_chosen:
		SPIDER_TRACE(SP_PDU, "Rcv UCF; g_pReg = %X\n", this);
		if ((m_State == GK_UNREG_PENDING) &&
				(pRasMessage->u.unregistrationConfirm.requestSeqNum ==
				m_pRasMessage->u.unregistrationRequest.requestSeqNum))
			hResult = UnregistrationConfirm(pRasMessage);
		else
			hResult = UnknownMessage(pRasMessage);
		break;
	case unregistrationReject_chosen:
		SPIDER_TRACE(SP_PDU, "Rcv URJ; g_pReg = %X\n", this);
		if ((m_State == GK_UNREG_PENDING) &&
				(pRasMessage->u.unregistrationReject.requestSeqNum ==
				m_pRasMessage->u.unregistrationRequest.requestSeqNum))
			hResult = UnregistrationReject(pRasMessage);
		else
			hResult = UnknownMessage(pRasMessage);
		break;
	case admissionConfirm_chosen:
		{
			// The sequence number of this RAS message seems to be the
			// only thing we can link back to the ARQ so we use it
			// to look up the call that this ACF is associated with
			RequestSeqNum	seqNum = pRasMessage->u.admissionConfirm.requestSeqNum;
			CCall			*pCall = FindCallBySeqNum(seqNum);
			if ((m_State == GK_REGISTERED) && (pCall))
			{
				SPIDER_TRACE(SP_PDU, "Rcv ACF; pCall = %X\n", pCall);
				hResult = pCall->AdmissionConfirm(pRasMessage);
			}
			else
			{
				SPIDER_TRACE(SP_PDU, "Rcv ACF; g_pReg = %X\n", this);
				hResult = UnknownMessage(pRasMessage);
			}
		}
		break;
	case admissionReject_chosen:
		{
			// The sequence number of this RAS message seems to be the
			// only thing we can link back to the ARQ so we use it
			// to look up the call that this ARJ is associated with
			RequestSeqNum	seqNum = pRasMessage->u.admissionReject.requestSeqNum;
			CCall			*pCall = FindCallBySeqNum(seqNum);
			if ((m_State == GK_REGISTERED) && (pCall))
			{
				SPIDER_TRACE(SP_PDU, "Rcv ARJ; pCall = %X\n", pCall);
				hResult = pCall->AdmissionReject(pRasMessage);
				if (hResult == GKI_DELETE_CALL)
				{
					DeleteCall(pCall);
					hResult = GKI_OK;	// Don't want to exit PostReceive loop
				}
			}
			else
			{
				SPIDER_TRACE(SP_PDU, "Rcv ARJ; g_pReg = %X\n", this);
				hResult = UnknownMessage(pRasMessage);
			}
		}
		break;
	case bandwidthConfirm_chosen:
		{
			// The sequence number of this RAS message seems to be the
			// only thing we can link back to the BRQ so we use it
			// to look up the call that this BCF is associated with
			RequestSeqNum	seqNum = pRasMessage->u.bandwidthConfirm.requestSeqNum;
			CCall			*pCall = FindCallBySeqNum(seqNum);
			if ((m_State == GK_REGISTERED) && (pCall))
			{
				SPIDER_TRACE(SP_PDU, "Rcv BCF; pCall = %X\n", pCall);
				hResult = pCall->BandwidthConfirm(pRasMessage);
			}
			else
			{
				SPIDER_TRACE(SP_PDU, "Rcv BCF; g_pReg = %X\n", this);
				hResult = UnknownMessage(pRasMessage);
			}
		}
		break;
	case bandwidthReject_chosen:
		{
			// The sequence number of this RAS message seems to be the
			// only thing we can link back to the BRQ so we use it
			// to look up the call that this BCF is associated with
			RequestSeqNum	seqNum = pRasMessage->u.bandwidthReject.requestSeqNum;
			CCall			*pCall = FindCallBySeqNum(seqNum);
			if ((m_State == GK_REGISTERED) && (pCall))
			{
				SPIDER_TRACE(SP_PDU, "Rcv BRJ; pCall = %X\n", pCall);
				hResult = pCall->BandwidthReject(pRasMessage);
			}
			else
			{
				SPIDER_TRACE(SP_PDU, "Rcv BRJ; g_pReg = %X\n", this);
				hResult = UnknownMessage(pRasMessage);
			}
		}
		break;
	case disengageConfirm_chosen:
		{
			// The sequence number of this RAS message seems to be the
			// only thing we can link back to the DRQ so we use it
			// to look up the call that this DCF is associated with
			RequestSeqNum	seqNum = pRasMessage->u.disengageConfirm.requestSeqNum;
			CCall			*pCall = FindCallBySeqNum(seqNum);
			if ((m_State == GK_REGISTERED) && (pCall))
			{
				SPIDER_TRACE(SP_PDU, "Rcv DCF; pCall = %X\n", pCall);
				hResult = pCall->DisengageConfirm(pRasMessage);
				if (hResult == GKI_DELETE_CALL)
				{
					DeleteCall(pCall);
					hResult = GKI_OK;	// Don't want to exit PostReceive loop
				}
			}
			else
			{
				SPIDER_TRACE(SP_PDU, "Rcv DCF; g_pReg = %X\n", this);
				hResult = UnknownMessage(pRasMessage);
			}
		}
		break;
	case disengageReject_chosen:
		{
			// The sequence number of this RAS message seems to be the
			// only thing we can link back to the DRQ so we use it
			// to look up the call that this DRJ is associated with
			RequestSeqNum	seqNum = pRasMessage->u.disengageReject.requestSeqNum;
			CCall			*pCall = FindCallBySeqNum(seqNum);
			if ((m_State == GK_REGISTERED) && (pCall))
			{
				SPIDER_TRACE(SP_PDU, "Rcv DRJ; pCall = %X\n", pCall);
				hResult = pCall->DisengageReject(pRasMessage);
				if (hResult == GKI_DELETE_CALL)
				{
					DeleteCall(pCall);
					hResult = GKI_OK;	// Don't want to exit PostReceive loop
				}
			}
			else
			{
				SPIDER_TRACE(SP_PDU, "Rcv DRJ; g_pReg = %X\n", this);
				hResult = UnknownMessage(pRasMessage);
			}
		}
		break;
	case locationConfirm_chosen:
		SPIDER_TRACE(SP_PDU, "Rcv LCF; g_pReg = %X\n", this);
		if ((m_State == GK_LOC_PENDING) &&
				(pRasMessage->u.locationConfirm.requestSeqNum ==
				m_pRasMessage->u.locationRequest.requestSeqNum))
			hResult = LocationConfirm(pRasMessage);
		else
			hResult = UnknownMessage(pRasMessage);
		break;
	case locationReject_chosen:
		SPIDER_TRACE(SP_PDU, "Rcv LRJ; g_pReg = %X\n", this);
		if ((m_State == GK_LOC_PENDING) &&
				(pRasMessage->u.locationReject.requestSeqNum ==
				m_pRasMessage->u.locationRequest.requestSeqNum))
			hResult = LocationReject(pRasMessage);
		else
			hResult = UnknownMessage(pRasMessage);
		break;

	case nonStandardMessage_chosen:
		SPIDER_TRACE(SP_PDU, "Rcv NSM; g_pReg = %X\n", this);
		hResult = UnknownMessage(pRasMessage);
		break;
	case unknownMessageResponse_chosen:
		SPIDER_TRACE(SP_PDU, "Rcv XRS; g_pReg = %X\n", this);
		break;

	// Incoming Request PDUs
	case unregistrationRequest_chosen:
		SPIDER_TRACE(SP_PDU, "Rcv URQ; g_pReg = %X\n", this);
		if (m_State == GK_REGISTERED)
		{
			WORD wReason;
			// Notify user of received unregistration request and reason
			if(pRasMessage->u.unregistrationRequest.bit_mask
				& UnregistrationRequest_reason_present)
 			{
 				wReason = pRasMessage->u.unregistrationRequest.reason.choice;
			}
			else
				wReason = 0;
			SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_UNREG_REQUEST, 0, 0)\n", 0);
			PostMessage(m_hWnd, m_wBaseMessage + GKI_UNREG_REQUEST, wReason, 0);
		
			hResult = SendUnregistrationConfirm(pRasMessage);
			if (hResult == GKI_OK)
				hResult = GKI_EXIT_THREAD;
		}
		else
			hResult = UnknownMessage(pRasMessage);
		break;
	case bandwidthRequest_chosen:
		{
			// Check the CRV in this BRQ and see if we have a call
			// that corresponds to it.
			CallReferenceValue	crv = pRasMessage->u.bandwidthRequest.callReferenceValue;
			CCall			*pCall = FindCallByCRV(crv);
			if ((m_State == GK_REGISTERED) && (pCall))
			{
				SPIDER_TRACE(SP_PDU, "Rcv BRQ; pCall = %X\n", pCall);
				hResult = pCall->SendBandwidthConfirm(pRasMessage);
			}
			else
			{
				SPIDER_TRACE(SP_PDU, "Rcv BRQ; g_pReg = %X\n", this);
				hResult = UnknownMessage(pRasMessage);
			}
		}
		break;
	case disengageRequest_chosen:
		{
			// Check the CRV in this DRQ and see if we have a call
			// that corresponds to it.
			CallReferenceValue	crv = pRasMessage->u.disengageRequest.callReferenceValue;
			CCall			*pCall = FindCallByCRV(crv);
			if ((m_State == GK_REGISTERED) && (pCall))
			{
				SPIDER_TRACE(SP_PDU, "Rcv DRQ; pCall = %X\n", pCall);
				hResult = pCall->SendDisengageConfirm(pRasMessage);
				if (hResult == GKI_DELETE_CALL)
				{
					DeleteCall(pCall);
					hResult = GKI_OK;	// Don't want to exit PostReceive loop
				}
			}
			else
			{
				SPIDER_TRACE(SP_PDU, "Rcv DRQ; g_pReg = %X\n", this);
				hResult = UnknownMessage(pRasMessage);
			}
		}
		break;
	case infoRequest_chosen:
		SPIDER_TRACE(SP_PDU, "Rcv IRQ; g_pReg = %X\n", this);
		if ((m_State != GK_UNREGISTERED) && (m_State != GK_REG_PENDING))
		{
			// Check the CRV in this DRQ and see if we have a call
			// that corresponds to it.
			CallReferenceValue	crv = pRasMessage->u.infoRequest.callReferenceValue;
			CCall			*pCall = NULL;
			// A zero in the CRV means provide info for all calls, so we start
			// the chain with the first one.
			if (crv == 0)
			{
				if (m_Calls.IsEmpty())
					hResult = SendInfoRequestResponse(0, pRasMessage);
				else
				{
					POS	pos = m_Calls.GetFirstPos();
					pCall = m_Calls.GetAt(pos);
					hResult = pCall->SendInfoRequestResponse(0, pRasMessage, FALSE);
				}
			}
			else
			{
				// This is a call specific request so if we don't find
				// a matching call, we'll send an XRS
				pCall = FindCallByCRV(crv);
				if (pCall)
					hResult = pCall->SendInfoRequestResponse(0, pRasMessage, TRUE);
				else
					hResult = UnknownMessage(pRasMessage);
			}
		}
		break;

	// Should never see these PDUs
	case gatekeeperRequest_chosen:
	case registrationRequest_chosen:
	case admissionRequest_chosen:
	case locationRequest_chosen:
	case infoRequestResponse_chosen:
		SPIDER_TRACE(SP_PDU, "Rcv unexpected PDU; g_pReg = %X\n", this);
		SPIDER_TRACE(SP_PDU, "pRasMessage->choice = %X\n", pRasMessage->choice);
		hResult = UnknownMessage(pRasMessage);
		break;

	// Everything else - probably a bad PDU
	default:
		SPIDER_TRACE(SP_PDU, "Rcv unrecognized PDU; g_pReg = %X\n", this);
		SPIDER_TRACE(SP_PDU, "pRasMessage->choice = %X\n", pRasMessage->choice);
		hResult = UnknownMessage(pRasMessage);
		break;
	}

	return (hResult);
}

HRESULT
CRegistration::RegistrationConfirm(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called if a registrationConfirm is
	//            received and matches an outstanding registrationRequest.
	//            It will delete the memory used for the registrationRequest
	//            change the state and notify the user by posting a message.
	//            Additional information contained in the registrationConfirm
	//            is stored in the CRegistration class.
	// AUTHOR:    Colin Hulme

	SeqAliasAddr	*pAA;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CRegistration::RegistrationConfirm(%X)\n", pRasMessage);
	ASSERT(g_pCoder);
	if (g_pCoder == NULL)
		return (GKI_NOT_INITIALIZED);	
		
	// Delete allocated RasMessage storage
	SPIDER_TRACE(SP_NEWDEL, "del m_pRasMessage = %X\n", m_pRasMessage);
	delete m_pRasMessage;
	m_pRasMessage = 0;

	// Update member variables
	m_State = GK_REGISTERED;
	SPIDER_TRACE(SP_STATE, "m_State = GK_REGISTERED (%X)\n", this);

	if (pRasMessage->u.registrationConfirm.bit_mask & RgstrtnCnfrm_trmnlAls_present)
	{
		// Copy alias addresses
		for (pAA = (SeqAliasAddr *)pRasMessage->u.registrationConfirm.RgstrtnCnfrm_trmnlAls;
				pAA != 0; pAA = pAA->next)
			AddAliasAddr(pAA->value);
	}
	if ((pRasMessage->u.registrationConfirm.bit_mask & RCm_gtkprIdntfr_present) &&
			(m_RCm_gtkprIdntfr.value == 0))
	{
		// Copy gatekeeper identifier
		m_RCm_gtkprIdntfr.length = pRasMessage->u.registrationConfirm.RCm_gtkprIdntfr.length;
		m_RCm_gtkprIdntfr.value = new unsigned short[m_RCm_gtkprIdntfr.length];
		SPIDER_TRACE(SP_NEWDEL, "new m_RCm_gtkprIdntfr.value = %X\n", m_RCm_gtkprIdntfr.value);
		if (m_RCm_gtkprIdntfr.value == 0)
			return (GKI_NO_MEMORY);
		memcpy(m_RCm_gtkprIdntfr.value,
				pRasMessage->u.registrationConfirm.RCm_gtkprIdntfr.value,
				m_RCm_gtkprIdntfr.length * sizeof(unsigned short));

	}
	// Copy endpoint identifier
	m_endpointID.length = pRasMessage->u.registrationConfirm.endpointIdentifier.length;
	m_endpointID.value = new unsigned short[m_endpointID.length];
	SPIDER_TRACE(SP_NEWDEL, "new m_endpointID.value = %X\n", m_endpointID.value);
	if (m_endpointID.value == 0)
		return (GKI_NO_MEMORY);
	memcpy(m_endpointID.value,
			pRasMessage->u.registrationConfirm.endpointIdentifier.value,
			m_endpointID.length * sizeof(unsigned short));


	SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_REG_CONFIRM, 0, 0)\n", 0);
	PostMessage(m_hWnd, m_wBaseMessage + GKI_REG_CONFIRM, 0, 0);

	return (GKI_OK);
}

HRESULT
CRegistration::RegistrationReject(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called if a registrationReject is
	//            received and matches an outstanding registrationRequest.
	//            It will delete the memory used for the registrationRequest
	//            change the state and notify the user by posting a message
	//            Returning a non-zero value, indicates that the PostReceive
	//            loop should terminate, delete the registration object
	//            and exit the thread.  If the rejectReason is discovery
	//            required, this function execs the discovery thread and
	//            notifies PostReceive to exit the thread without deleting
	//            the registration object and socket.
	// AUTHOR:    Colin Hulme

	HANDLE				hThread;
	SeqTransportAddr	*pTA1, *pTA2;
	int					nRet;
	HRESULT				hResult;
#ifdef _DEBUG
	char				szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CRegistration::RegistrationReject(%X)\n", pRasMessage);
	ASSERT(g_pCoder);
	if (g_pCoder == NULL)
		return (GKI_NOT_INITIALIZED);	

#ifdef BROADCAST_DISCOVERY		
	if (pRasMessage->u.registrationReject.rejectReason.choice == discoveryRequired_chosen)
	{
		SPIDER_TRACE(SP_NEWDEL, "del m_pRasMessage = %X\n", m_pRasMessage);
		delete m_pRasMessage;
		m_pRasMessage = 0;

		// Close socket and reopen in non-connected state to allow sendto
		if ((nRet = m_pSocket->Close()) != 0)
			return (GKI_WINSOCK2_ERROR(nRet));
		if ((nRet = m_pSocket->Create(m_pSocket->GetAddrFam(), 0)) != 0)
			return (GKI_WINSOCK2_ERROR(nRet));

		// Delete allocated memory for sequence of RAS addresses
		pTA1 = m_pRASAddress;
		while (pTA1 != 0)
		{
			pTA2 = pTA1->next;
			SPIDER_TRACE(SP_NEWDEL, "del pTA1 = %X\n", pTA1);
			delete pTA1;
			pTA1 = pTA2;
		}

		// Update RAS Address in CRegistration
		for (pTA1 = m_pCallSignalAddress; pTA1 != 0; pTA1 = pTA1->next)
		{
			if (pTA1->value.choice == m_usRegistrationTransport)
				if ((hResult = AddRASAddr(pTA1->value, m_pSocket->GetPort())) != GKI_OK)
					return (hResult);
		}

		hThread = (HANDLE)_beginthread(GKDiscovery, 0, 0);
		SPIDER_TRACE(SP_THREAD, "_beginthread(GKDiscovery, 0, 0); <%X>\n", hThread);
		if (hThread == (HANDLE)-1)
			return (GKI_NO_THREAD);
		SetDiscThread(hThread);
		return (GKI_REDISCOVER);
	}
#endif // BROADCAST_DISCOVERY

	m_State = GK_UNREGISTERED;
	SPIDER_TRACE(SP_STATE, "m_State = GK_UNREGISTERED (%X)\n", this);

	SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_REG_REJECT, %X, 0)\n",
									pRasMessage->u.registrationReject.rejectReason.choice);
	PostMessage(m_hWnd, m_wBaseMessage + GKI_REG_REJECT,
				(WORD)pRasMessage->u.registrationReject.rejectReason.choice, 0L);

	return (GKI_EXIT_THREAD);
}

HRESULT
CRegistration::UnregistrationConfirm(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called if an unregistrationConfirm is
	//            received and matches an outstanding unregistrationRequest.
	//            It will delete the memory used for the unregistrationRequest
	//            change the state and notify the user by posting a message.
	//            Returning a non-zero value, indicates that the PostReceive
	//            loop should terminate, delete the registration object
	//            and exit the thread.
	// AUTHOR:    Colin Hulme

#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CRegistration::UnregistrationConfirm(%X)\n", pRasMessage);

	// We deliberately don't free the RasMessage memory.  Let the registration
	// destructor do it - this provides protection from other requests.

	// Update member variables
	m_State = GK_UNREGISTERED;
	SPIDER_TRACE(SP_STATE, "m_State = GK_UNREGISTERED (%X)\n", this);

	// Notify user application
	SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_UNREG_CONFIRM, 0, 0)\n", 0);
	PostMessage(m_hWnd, m_wBaseMessage + GKI_UNREG_CONFIRM, 0, 0L);

	return (GKI_EXIT_THREAD);
}

HRESULT
CRegistration::UnregistrationReject(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called if an unregistrationReject is
	//            received and matches an outstanding unregistrationRequest.
	//            It will delete the memory used for the unregistrationRequest
	//            change the state and notify the user by posting a message
	//            Returning a non-zero value, indicates that the PostReceive
	//            loop should terminate, delete the registration object
	//            and exit the thread.
	// AUTHOR:    Colin Hulme

#ifdef _DEBUG
	char			szGKDebug[80];
#endif
	HRESULT			hResult = GKI_OK;

	SPIDER_TRACE(SP_FUNC, "CRegistration::UnregistrationReject(%X)\n", pRasMessage);


	// Update member variables
	switch (pRasMessage->u.unregistrationReject.rejectReason.choice)
	{
	case callInProgress_chosen:		// return to registered state
		// Delete allocate RasMessage storage
		SPIDER_TRACE(SP_NEWDEL, "del m_pRasMessage = %X\n", m_pRasMessage);
		delete m_pRasMessage;
		m_pRasMessage = 0;

		m_State = GK_REGISTERED;
		SPIDER_TRACE(SP_STATE, "m_State = GK_REGISTERED (%X)\n", this);
		break;
	case notCurrentlyRegistered_chosen:
	default:
		m_State = GK_UNREGISTERED;
		SPIDER_TRACE(SP_STATE, "m_State = GK_UNREGISTERED (%X)\n", this);
		hResult = GKI_EXIT_THREAD;	// kill registration and PostReceive thread
		break;
	}

	// Notify user application
	SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_UNREG_REJECT, %X, 0)\n",
									pRasMessage->u.unregistrationReject.rejectReason.choice);
	PostMessage(m_hWnd, m_wBaseMessage + GKI_UNREG_REJECT,
				(WORD)pRasMessage->u.unregistrationReject.rejectReason.choice, 0L);

	return (hResult);
}

HRESULT
CRegistration::LocationConfirm(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called if a locationConfirm is
	//            received and matches an outstanding locationRequest.
	//            It will delete the memory used for the locationRequest
	//            change the state and notify the user by posting a message.
	// AUTHOR:    Colin Hulme

	SeqAliasAddr	*pAA1, *pAA2;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CRegistration::LocationConfirm(%X)\n", pRasMessage);

	// Delete allocated RasMessage storage
	SPIDER_TRACE(SP_NEWDEL, "del m_pRasMessage = %X\n", m_pRasMessage);
	delete m_pRasMessage;
	m_pRasMessage = 0;

	// Delete allocated memory for sequence of location alias addresses
	pAA1 = m_pLocationInfo;
	while (pAA1 != 0)
	{
		pAA2 = pAA1->next;
		if (pAA1->value.choice == h323_ID_chosen)
		{
			SPIDER_TRACE(SP_NEWDEL, "del pAA1->value.u.h323_ID.value = %X\n", pAA1->value.u.h323_ID.value);
			delete pAA1->value.u.h323_ID.value;
		}
		SPIDER_TRACE(SP_NEWDEL, "del pAA1 = %X\n", pAA1);
		delete pAA1;
		pAA1 = pAA2;
	}
	m_pLocationInfo = 0;

	// Update member variables
	m_State = GK_REGISTERED;
	SPIDER_TRACE(SP_STATE, "m_State = GK_REGISTERED (%X)\n", this);
	m_Location[0] = pRasMessage->u.locationConfirm.callSignalAddress;
	m_Location[1] = pRasMessage->u.locationConfirm.rasAddress;

	// Notify user application
	SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_LOCATION_CONFIRM, 0, &m_Location[0])\n", 0);
	PostMessage(m_hWnd, m_wBaseMessage + GKI_LOCATION_CONFIRM,
			0, (LPARAM)&m_Location[0]);

	return (GKI_OK);
}

HRESULT
CRegistration::LocationReject(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called if a locationReject is
	//            received and matches an outstanding locationRequest.
	//            It will delete the memory used for the locationRequest
	//            change the state and notify the user by posting a message
	// AUTHOR:    Colin Hulme

	SeqAliasAddr	*pAA1, *pAA2;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CRegistration::LocationReject(%X)\n", pRasMessage);

	// Delete allocate RasMessage storage
	SPIDER_TRACE(SP_NEWDEL, "del m_pRasMessage = %X\n", m_pRasMessage);
	delete m_pRasMessage;
	m_pRasMessage = 0;

	// Delete allocated memory for sequence of location alias addresses
	pAA1 = m_pLocationInfo;
	while (pAA1 != 0)
	{
		pAA2 = pAA1->next;
		if (pAA1->value.choice == h323_ID_chosen)
		{
			SPIDER_TRACE(SP_NEWDEL, "del pAA1->value.u.h323_ID.value = %X\n", pAA1->value.u.h323_ID.value);
			delete pAA1->value.u.h323_ID.value;
		}
		SPIDER_TRACE(SP_NEWDEL, "del pAA1 = %X\n", pAA1);
		delete pAA1;
		pAA1 = pAA2;
	}
	m_pLocationInfo = 0;

	// Update member variables
	m_State = GK_REGISTERED;
	SPIDER_TRACE(SP_STATE, "m_State = GK_REGISTERED (%X)\n", this);

	// Notify user application
	SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_LOCATION_REJECT, %X, 0)\n",
									pRasMessage->u.locationReject.rejectReason.choice);
	PostMessage(m_hWnd, m_wBaseMessage + GKI_LOCATION_REJECT,
				(WORD)pRasMessage->u.locationReject.rejectReason.choice, 0L);

	return (GKI_OK);
}

HRESULT
CRegistration::UnknownMessage(RasMessage *pRasMessage)
{
	// ABSTRACT:  This member function is called to respond to the gatekeeper
	//            with an XRS PDU indicated that the received PDU is an unknown
	//            message
	// AUTHOR:    Colin Hulme

	ASN1_BUF		Asn1Buf;
	DWORD			dwErrorCode;
	RasMessage		*pOutRasMessage;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CRegistration::UnknownMessage(%X)\n", pRasMessage);
	ASSERT(g_pCoder);
	if (g_pCoder == NULL)
		return (GKI_NOT_INITIALIZED);	
		
	// Allocate a RasMessage structure and initialized to 0
	pOutRasMessage = new RasMessage;
	SPIDER_TRACE(SP_NEWDEL, "new pOutRasMessage = %X\n", pOutRasMessage);
	if (pOutRasMessage == 0)
		return (GKI_NO_MEMORY);
	memset(pOutRasMessage, 0, sizeof(RasMessage));

	// Setup structure fields for UnregistrationRequest
	pOutRasMessage->choice = unknownMessageResponse_chosen;
	pOutRasMessage->u.unknownMessageResponse.requestSeqNum =
			pRasMessage->u.registrationRequest.requestSeqNum; // can use from
									// from any RAS Message, since SeqNum
									// is always in same position.

	// Encode the PDU & send it
	dwErrorCode = g_pCoder->Encode(pOutRasMessage, &Asn1Buf);
	if (dwErrorCode)
		return (GKI_ENCODER_ERROR);

	SPIDER_TRACE(SP_PDU, "Send XRS; g_pReg = %X\n", this);

	if (fGKIDontSend == FALSE)
		if (m_pSocket->Send((char *)Asn1Buf.value, Asn1Buf.length) == SOCKET_ERROR)
			return (GKI_WINSOCK2_ERROR(SOCKET_ERROR));

	// Free the encoder memory
	g_pCoder->Free(Asn1Buf);

	SPIDER_TRACE(SP_NEWDEL, "del pOutRasMessage = %X\n", pOutRasMessage);
	delete pOutRasMessage;
	pOutRasMessage = 0;

	return (GKI_OK);
}

HRESULT
CRegistration::GatekeeperConfirm(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called if a gatekeeperConfirm is
	//            received.  Note this member function must first ascertain
	//            that the supplied confirmation sequence number matches
	//            the outstanding request sequence number, if not - it
	//            will send an XRS response.
	// AUTHOR:    Colin Hulme

	char				szBuffer[80];
	HRESULT				hResult;
#ifdef _DEBUG
	char				szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CRegistration::GatekeeperConfirm(%X)\n", pRasMessage);
	ASSERT(g_pGatekeeper);
	if(g_pGatekeeper == NULL)
		return (GKI_NOT_INITIALIZED);	
		
	if (m_pRasMessage == 0)
		return (0);

	if (pRasMessage->u.gatekeeperConfirm.requestSeqNum !=
			m_pRasMessage->u.gatekeeperRequest.requestSeqNum)
	{
		hResult = g_pReg->UnknownMessage(pRasMessage);
		return (hResult);
	}

	// Delete allocated RasMessage storage
	SPIDER_TRACE(SP_NEWDEL, "del m_pRasMessage = %X\n", m_pRasMessage);
	delete m_pRasMessage;
	m_pRasMessage = 0;

	// Update member variables
	if ((pRasMessage->u.gatekeeperConfirm.bit_mask & GtkprCnfrm_gtkprIdntfr_present) &&
			(m_RCm_gtkprIdntfr.value == 0))
	{
		// Copy gatekeeper identifier
		m_RCm_gtkprIdntfr.length = pRasMessage->u.gatekeeperConfirm.GtkprCnfrm_gtkprIdntfr.length;
		m_RCm_gtkprIdntfr.value = new unsigned short[m_RCm_gtkprIdntfr.length];
		SPIDER_TRACE(SP_NEWDEL, "new m_RCm_gtkprIdntfr.value = %X\n", m_RCm_gtkprIdntfr.value);
		if (m_RCm_gtkprIdntfr.value == 0)
			return (GKI_NO_MEMORY);
		memcpy(m_RCm_gtkprIdntfr.value,
				pRasMessage->u.gatekeeperConfirm.GtkprCnfrm_gtkprIdntfr.value,
				m_RCm_gtkprIdntfr.length * sizeof(unsigned short));
	}
	
	// Copy gatekeeper RAS Address
	ASSERT((pRasMessage->u.gatekeeperConfirm.rasAddress.choice == ipAddress_chosen) ||
			(pRasMessage->u.gatekeeperConfirm.rasAddress.choice == ipxAddress_chosen));

	switch (pRasMessage->u.gatekeeperConfirm.rasAddress.choice)
	{
	case ipAddress_chosen:
		wsprintf(szBuffer, "%d.%d.%d.%d",
				pRasMessage->u.gatekeeperConfirm.rasAddress.u.ipAddress.ip.value[0],
				pRasMessage->u.gatekeeperConfirm.rasAddress.u.ipAddress.ip.value[1],
				pRasMessage->u.gatekeeperConfirm.rasAddress.u.ipAddress.ip.value[2],
				pRasMessage->u.gatekeeperConfirm.rasAddress.u.ipAddress.ip.value[3]);
		g_pGatekeeper->SetIPAddress(szBuffer);
		break;
#if(0)		
	case ipxAddress_chosen:
		wsprintf(szBuffer, "%02X%02X%02X%02X:%02X%02X%02X%02X%02X%02X",
				pRasMessage->u.gatekeeperConfirm.rasAddress.u.ipxAddress.netnum.value[0],
				pRasMessage->u.gatekeeperConfirm.rasAddress.u.ipxAddress.netnum.value[1],
				pRasMessage->u.gatekeeperConfirm.rasAddress.u.ipxAddress.netnum.value[2],
				pRasMessage->u.gatekeeperConfirm.rasAddress.u.ipxAddress.netnum.value[3],
				pRasMessage->u.gatekeeperConfirm.rasAddress.u.ipxAddress.node.value[0],
				pRasMessage->u.gatekeeperConfirm.rasAddress.u.ipxAddress.node.value[1],
				pRasMessage->u.gatekeeperConfirm.rasAddress.u.ipxAddress.node.value[2],
				pRasMessage->u.gatekeeperConfirm.rasAddress.u.ipxAddress.node.value[3],
				pRasMessage->u.gatekeeperConfirm.rasAddress.u.ipxAddress.node.value[4],
				pRasMessage->u.gatekeeperConfirm.rasAddress.u.ipxAddress.node.value[5]);
		g_pGatekeeper->SetIPXAddress(szBuffer);
		break;
#endif // if(0)
		default:
		break;
	}

	g_pGatekeeper->Write();

	return (GKI_OK);
}

HRESULT
CRegistration::GatekeeperReject(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called if a gatekeeperReject is
	//            received.  Note this member function must first ascertain
	//            that the supplied rejection sequence number matches
	//            the outstanding request sequence number, if not - it
	//            will send an XRS response.
	// AUTHOR:    Colin Hulme

	HRESULT			hResult;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CRegistration::GatekeeperReject(%X)\n", pRasMessage);
	ASSERT(g_pGatekeeper);
	if(g_pGatekeeper == NULL)
		return (GKI_NOT_INITIALIZED);	
		
	if (m_pRasMessage == 0)
		return (GKI_OK);

	if (pRasMessage->u.gatekeeperReject.requestSeqNum !=
			m_pRasMessage->u.gatekeeperRequest.requestSeqNum)
	{
		hResult = g_pReg->UnknownMessage(pRasMessage);
		return (hResult);
	}

	g_pGatekeeper->SetRejectFlag(TRUE);	// Indicate that atleast one GRJ was received
	return (GKI_OK);
}

HRESULT
CRegistration::SendUnregistrationConfirm(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called when an unregistrationRequest is
	//            received from the gatekeeper.  It will create the
	//            unregistrationConfirm structure, encode it and send
	//            it on the net.  It posts a message to the user
	//            notifying them.
	// AUTHOR:    Colin Hulme

	ASN1_BUF		Asn1Buf;
	DWORD			dwErrorCode;
	RasMessage		*pRespRasMessage;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CRegistration::UnregistrationConfirm(%X)\n", pRasMessage);
	ASSERT(g_pCoder);
	if (g_pCoder == NULL)
		return (GKI_NOT_INITIALIZED);	
		
	// Allocate a RasMessage structure and initialized to 0
	pRespRasMessage = new RasMessage;
	SPIDER_TRACE(SP_NEWDEL, "new pRespRasMessage = %X\n", pRespRasMessage);
	if (pRespRasMessage == 0)
		return (GKI_NO_MEMORY);
	memset(pRespRasMessage, 0, sizeof(RasMessage));

	// Setup structure fields for UnregistrationConfirm
	pRespRasMessage->choice = unregistrationConfirm_chosen;
	pRespRasMessage->u.unregistrationConfirm.requestSeqNum =
			pRasMessage->u.unregistrationRequest.requestSeqNum;

#ifdef _DEBUG
	if (dwGKIDLLFlags & SP_DUMPMEM)
		DumpMem(pRespRasMessage, sizeof(RasMessage));
#endif

	// Encode the PDU & send it
	dwErrorCode = g_pCoder->Encode(pRespRasMessage, &Asn1Buf);
	if (dwErrorCode)
		return (GKI_ENCODER_ERROR);

	m_State = GK_UNREGISTERED;
	SPIDER_TRACE(SP_STATE, "m_State = GK_UNREGISTERED (%X)\n", this);

	SPIDER_TRACE(SP_PDU, "Send UCF; g_pReg = %X\n", this);
	if (fGKIDontSend == FALSE)
		if (m_pSocket->Send((char *)Asn1Buf.value, Asn1Buf.length) == SOCKET_ERROR)
			return (GKI_WINSOCK2_ERROR(SOCKET_ERROR));

	// Free the encoder memory
	g_pCoder->Free(Asn1Buf);

	// Delete allocated RasMessage storage
	SPIDER_TRACE(SP_NEWDEL, "del pRespRasMessage = %X\n", pRespRasMessage);
	delete pRespRasMessage;

	// fake "received unregistration confirm" because the upper
	// state machine code depends on it
	SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_UNREG_CONFIRM, 0, 0)\n", 0);
	PostMessage(m_hWnd, m_wBaseMessage + GKI_UNREG_CONFIRM, 0, 0);

	return (GKI_OK);
}

HRESULT
CRegistration::Retry(void)
{
	// ABSTRACT:  This function is called by the background Retry thread
	//            at the configured time interval.  It will check if there
	//            are any outstanding PDUs for the Registration object
	//            If so, they will be retransmitted.  If the maximum number of
	//            retries has expired, the memory will be cleaned up.
	//            This function will return 0 to the background thread unless
	//            it wants the thread to terminate.
	// AUTHOR:    Colin Hulme

	ASN1_BUF			Asn1Buf;
	DWORD				dwErrorCode;
	HANDLE				hThread;
	SeqTransportAddr	*pTA1, *pTA2;
	SeqAliasAddr		*pAA1, *pAA2;
	int					nRet;
#ifdef _DEBUG
	char				szGKDebug[80];
#endif
	HRESULT				hResult = GKI_OK;

//	SPIDER_TRACE(SP_FUNC, "CRegistration::Retry() %X\n", m_pCall);
	ASSERT(g_pCoder);
	if ((g_pCoder == NULL) && (g_pGatekeeper == NULL))
		return (GKI_NOT_INITIALIZED);	

	// Allow calls to do retry processing
	if (!m_Calls.IsEmpty())
	{
		// Loop through and let each call do it's retry processing
		// It should be safe to call DeleteCall() from within the
		// iteration since pos1 should still be valid after the
		// removal.
		POS pos1;
		for( pos1 = m_Calls.GetFirstPos(); pos1 != NULL; )
		{
			// Call Retry() for this call
			CCall *pCall = m_Calls.GetNext(pos1);
			ASSERT (pCall);
			hResult = pCall->Retry();
			if (hResult == GKI_DELETE_CALL)
			{
				DeleteCall(pCall);
				hResult = GKI_OK;
			}
		}
	}
	
	// Check if any outstanding registration PDUs
	if (m_pRasMessage && (--m_uRetryCountdown == 0))
	{
		// going to retry, reset countdown
		m_uRetryCountdown = m_uRetryResetCount;

		if (m_usRetryCount <= m_uMaxRetryCount)
		{
			// Encode the PDU & resend it
			dwErrorCode = g_pCoder->Encode(m_pRasMessage, &Asn1Buf);
			if (dwErrorCode)
				return (GKI_ENCODER_ERROR);

			SPIDER_TRACE(SP_PDU, "RESend PDU; g_pReg = %X\n", this);
			if (fGKIDontSend == FALSE)
			{
				if (m_pRasMessage->choice == gatekeeperRequest_chosen)
				{
					if (m_pSocket->SendBroadcast((char *)Asn1Buf.value, Asn1Buf.length) == SOCKET_ERROR)
						return (GKI_WINSOCK2_ERROR(SOCKET_ERROR));
				}
				else
				{
					if (m_pSocket->Send((char *)Asn1Buf.value, Asn1Buf.length) == SOCKET_ERROR)
						return (GKI_WINSOCK2_ERROR(SOCKET_ERROR));
				}
			}

			// Free the encoder memory
			g_pCoder->Free(Asn1Buf);
			m_usRetryCount++;
		}
		else	// Retries expired - clean up
		{
			switch (m_pRasMessage->choice)
			{
			case gatekeeperRequest_chosen:

#ifdef BROADCAST_DISCOVERY			

				m_State = GK_UNREGISTERED;
				SPIDER_TRACE(SP_STATE, "m_State = GK_UNREGISTERED (%X)\n", this);

				// We deliberately don't free the RasMessage memory.  Let the
				// registration destructor do it - this provides protection
				// from other requests.

				// Close socket - this will terminate the Discovery thread
				if ((nRet = m_pSocket->Close()) != 0)
					return (GKI_WINSOCK2_ERROR(nRet));

				// Delete cached address from the registry
				g_pGatekeeper->DeleteCachedAddresses();

				if (g_pGatekeeper->GetRejectFlag() == FALSE)
				{
					SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_REG_BYPASS, 0, 0)\n", 0);
					PostMessage(m_hWnd, m_wBaseMessage + GKI_REG_BYPASS,
							0, 0);
					return (GKI_EXIT_THREAD);
				}
				else
					hResult = GKI_EXIT_THREAD;
#else 	
				ASSERT(0);
				hResult = GKI_EXIT_THREAD;
#endif	//BROADCAST_DISCOVERY				
				break;
			case registrationRequest_chosen:
				SPIDER_TRACE(SP_NEWDEL, "del m_pRasMessage = %X\n", m_pRasMessage);
				delete m_pRasMessage;
				m_pRasMessage = 0;
				
#ifdef BROADCAST_DISCOVERY
				// Need to attempt gatekeeper discovery

				// Close socket and reopen in non-connected state to allow sendto
				// This will also terminate the PostRecv thread
				if ((nRet = m_pSocket->Close()) != 0)
					return (GKI_WINSOCK2_ERROR(nRet));
				if ((nRet = m_pSocket->Create(m_pSocket->GetAddrFam(), 0)) != 0)
					return (GKI_WINSOCK2_ERROR(nRet));

				// Delete allocated memory for sequence of RAS addresses
				pTA1 = m_pRASAddress;
				while (pTA1 != 0)
				{
					pTA2 = pTA1->next;
					SPIDER_TRACE(SP_NEWDEL, "del pTA1 = %X\n", pTA1);
					delete pTA1;
					pTA1 = pTA2;
				}

				// Update RAS Address in CRegistration
				for (pTA1 = m_pCallSignalAddress; pTA1 != 0; pTA1 = pTA1->next)
				{
					if (pTA1->value.choice == m_usRegistrationTransport)
						if ((hResult = AddRASAddr(pTA1->value, m_pSocket->GetPort())) != GKI_OK)
							return (hResult);
				}

				// Start the discovery thread
				hThread = (HANDLE)_beginthread(GKDiscovery, 0, 0);
				SPIDER_TRACE(SP_THREAD, "_beginthread(GKDiscovery, 0, 0); <%X>\n", hThread);
				if (hThread == (HANDLE)-1)
					return (GKI_NO_THREAD);
				SetDiscThread(hThread);

				hResult = GKI_REDISCOVER;
				break;
#else // not BROADCAST_DISCOVERY
				hResult = GKI_EXIT_THREAD;
#endif // BROADCAST_DISCOVERY

			case unregistrationRequest_chosen:
				m_State = GK_UNREGISTERED;
				SPIDER_TRACE(SP_STATE, "m_State = GK_UNREGISTERED (%X)\n", this);

				SPIDER_TRACE(SP_NEWDEL, "del m_pRasMessage = %X\n", m_pRasMessage);
				delete m_pRasMessage;
				m_pRasMessage = 0;

				// Close socket - this will terminate the Receive thread
				if ((nRet = m_pSocket->Close()) != 0)
					return (GKI_WINSOCK2_ERROR(nRet));

				hResult = GKI_EXIT_THREAD;
				break;

			case locationRequest_chosen:
				m_State = GK_REGISTERED;
				SPIDER_TRACE(SP_STATE, "m_State = GK_REGISTERED (%X)\n", this);

				SPIDER_TRACE(SP_NEWDEL, "del m_pRasMessage = %X\n", m_pRasMessage);
				delete m_pRasMessage;
				m_pRasMessage = 0;

				// Delete allocated memory for sequence of location alias addresses
				pAA1 = m_pLocationInfo;
				while (pAA1 != 0)
				{
					pAA2 = pAA1->next;
					if (pAA1->value.choice == h323_ID_chosen)
					{
						SPIDER_TRACE(SP_NEWDEL, "del pAA1->value.u.h323_ID.value = %X\n", pAA1->value.u.h323_ID.value);
						delete pAA1->value.u.h323_ID.value;
					}
					SPIDER_TRACE(SP_NEWDEL, "del pAA1 = %X\n", pAA1);
					delete pAA1;
					pAA1 = pAA2;
				}

				break;
			}

			// Notify user that gatekeeper didn't respond
			if (hResult != GKI_REDISCOVER)
			{
				SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, GKI_NO_RESPONSE)\n", 0);
				PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR,
						0, GKI_NO_RESPONSE);
			}
			else
				hResult = GKI_OK;	// Don't exit retry thread
		}
	}

	return (hResult);
}

HRESULT
CRegistration::SendInfoRequestResponse(CallInfoStruct *pCallInfo, RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called from one or more call object
	//            to create an IRR RasMessage, encapsulate the supplied
	//            call information and send the message to the
	//            gatekeeper.
	// AUTHOR:    Colin Hulme

	ASN1_BUF			Asn1Buf;
	DWORD				dwErrorCode;
	RasMessage			*pRespRasMessage;
	struct sockaddr_in	sAddrIn;
#ifdef _DEBUG
	char				szGKDebug[80];
#endif


	SPIDER_TRACE(SP_FUNC, "CRegistration::SendInfoRequestResponse()\n", 0);
	ASSERT(g_pCoder);
	if (g_pCoder == NULL)
		return (GKI_NOT_INITIALIZED);	
		
	// Allocate a RasMessage structure and initialized to 0
	pRespRasMessage = new RasMessage;
	SPIDER_TRACE(SP_NEWDEL, "new pRespRasMessage = %X\n", pRespRasMessage);
	if (pRespRasMessage == 0)
		return (GKI_NO_MEMORY);
	memset(pRespRasMessage, 0, sizeof(RasMessage));

	// Setup structure fields for InfoRequestResponse
	pRespRasMessage->choice = infoRequestResponse_chosen;
	if (m_pRgstrtnRqst_trmnlAls != 0)
		pRespRasMessage->u.infoRequestResponse.bit_mask |= InfRqstRspns_endpntAls_present;
	if (pCallInfo != 0)
		pRespRasMessage->u.infoRequestResponse.bit_mask |= perCallInfo_present;

	if (pRasMessage)
	{
		pRespRasMessage->u.infoRequestResponse.requestSeqNum =
				pRasMessage->u.infoRequest.requestSeqNum;
		if (pRasMessage->u.infoRequest.bit_mask & replyAddress_present)
		{
			switch (pRasMessage->u.infoRequest.replyAddress.choice)
			{
			case ipAddress_chosen:
				sAddrIn.sin_family = AF_INET;
				sAddrIn.sin_port = htons(pRasMessage->u.infoRequest.replyAddress.u.ipAddress.port);
				break;
			case ipxAddress_chosen:
				sAddrIn.sin_family = AF_IPX;
				sAddrIn.sin_port = htons(GKIPX_RAS_PORT); //Need to use reply port
				break;
			}
			memcpy(&sAddrIn.sin_addr,
					&pRasMessage->u.infoRequest.replyAddress.u.ipAddress.ip.value[0], 4);
		}
	}
	else
		// unsolicited IRRs must have a sequence number of 1!!!! (H.225 says so)
		pRespRasMessage->u.infoRequestResponse.requestSeqNum = 1;
	

	pRespRasMessage->u.infoRequestResponse.endpointType = m_terminalType;
	pRespRasMessage->u.infoRequestResponse.endpointIdentifier = m_endpointID;
	pRespRasMessage->u.infoRequestResponse.rasAddress = m_pRASAddress->value;
	pRespRasMessage->u.infoRequestResponse.callSignalAddress =
				(PInfoRequestResponse_callSignalAddress)m_pCallSignalAddress;
	pRespRasMessage->u.infoRequestResponse.InfRqstRspns_endpntAls =
				(PInfoRequestResponse_endpointAlias)m_pRgstrtnRqst_trmnlAls;

	pRespRasMessage->u.infoRequestResponse.perCallInfo =
                (PInfoRequestResponse_perCallInfo)pCallInfo;

#ifdef _DEBUG
	if (dwGKIDLLFlags & SP_DUMPMEM)
		DumpMem(pRespRasMessage, sizeof(RasMessage));
#endif

	// Encode the PDU & send it
	dwErrorCode = g_pCoder->Encode(pRespRasMessage, &Asn1Buf);
	if (dwErrorCode)
		return (GKI_ENCODER_ERROR);

	SPIDER_TRACE(SP_PDU, "Send IRR; g_pReg = %X\n", this);
	if (fGKIDontSend == FALSE)
	{
		if (pRasMessage && (pRasMessage->u.infoRequest.bit_mask & replyAddress_present))
		{
			if (g_pReg->m_pSocket->SendTo((char *)Asn1Buf.value, Asn1Buf.length,
					(LPSOCKADDR)&sAddrIn, sizeof(sAddrIn)) == SOCKET_ERROR)
				return (GKI_WINSOCK2_ERROR(SOCKET_ERROR));
		}
		else
		{
			if (g_pReg->m_pSocket->Send((char *)Asn1Buf.value, Asn1Buf.length) == SOCKET_ERROR)
				return (GKI_WINSOCK2_ERROR(SOCKET_ERROR));
		}
	}

	// Free the encoder memory
	g_pCoder->Free(Asn1Buf);

	// Delete allocated RasMessage storage
	SPIDER_TRACE(SP_NEWDEL, "del pRespRasMessage = %X\n", pRespRasMessage);
	delete pRespRasMessage;

	return (GKI_OK);
}


//
// FindCallBySeqNum()
//
// ABSTRACT:
//	This function attempts to locate a call within the list of calls
//	in the registration object that has an outstanding RAS request that has this
//	sequence number.
//
// RETURNS:
//	Pointer to call associated with the sequence number or
//	NULL if no call is found.
//
// NOTES:
//	This function is usually called by the CRegistration::PDUHandler()
//	when it receives a reply message that needs to be associated with a
//	particular call.
//
// ASSUMPTIONS:
//	Each call object holds on to the sequence numbers for RAS
//	requests that it has not received replies for.
//
// AUTHOR:	Dan Dexter
CCall *
CRegistration::FindCallBySeqNum(RequestSeqNum seqNum)
{
	// If there are no calls, we can just return now
	if (m_Calls.IsEmpty())
		return(NULL);

	// Initialize return value to "call not found"
	CCall *RetVal = NULL;

	// Otherwise, iterate through the calls and ask them
	// if this sequence number belongs to them
	POS pos;
	for( pos = m_Calls.GetFirstPos(); pos != NULL; )
	{
		// Ask call if sequence number is theirs
		CCall *pCall = m_Calls.GetNext(pos);
		if (pCall->MatchSeqNum(seqNum))
		{
			RetVal = pCall;
			break;
		}
	}
	return(RetVal);
}

//
// FindCallByCRV()
//
// ABSTRACT:
//	This function attempts to locate a call within the list of calls
//	in the registration object that is associated with the passed in
//	CallReferenceValue.
//
// RETURNS:
//	Pointer to call associated with the CRV or
//	NULL if no call is found.
//
// NOTES:
//	This function is usually called by the CRegistration::PDUHandler()
//	when it receives a reply message that needs to be associated with a
//	particular call.
//
// AUTHOR:	Dan Dexter
CCall *
CRegistration::FindCallByCRV(CallReferenceValue crv)
{
	// If there are no calls, we can just return now
	if (m_Calls.IsEmpty())
		return(NULL);

	// Initialize return value to "call not found"
	CCall *RetVal = NULL;

	// Otherwise, iterate through the calls and ask them
	// if this CRV number belongs to them
	POS pos;
	for( pos = m_Calls.GetFirstPos(); pos != NULL; )
	{
		// Ask call if sequence number is theirs
		CCall *pCall = m_Calls.GetNext(pos);
		if (pCall->MatchCRV(crv))
		{
			RetVal = pCall;
			break;
		}
	}
	return(RetVal);
}

void
CRegistration::DeleteCall(CCall *pCall)
{
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	POS pos = m_Calls.Find(pCall);
	// We don't expect to be asked to delete
	// calls that aren't in the list, so ASSERT
	ASSERT(pos);

	if (pos)
	{
		CCall *pCallObject = m_Calls.GetAt(pos);
		m_Calls.RemoveAt(pos);
		SPIDER_TRACE(SP_NEWDEL, "del pCallObject = %X\n", pCallObject);
		delete pCallObject;
	}
}

void
CRegistration::AddCall(CCall *pCall)
{
	m_Calls.AddTail(pCall);
}

CCall *
CRegistration::GetNextCall(CCall *pCall)
{
	CCall	*RetVal = NULL;

	if (pCall)
	{
		// The call list should never be empty
		// if we're called with a non-NULL call pointer
		ASSERT(!m_Calls.IsEmpty());

		POS	pos = m_Calls.Find(pCall);
		// The call passed in better have been found
		ASSERT(pos);

		if (pos)
		{
			// This actually gets the existing call, but sets
			// pos to point to the next call.
			CCall *pNextCall = m_Calls.GetNext(pos);
			if (pos)
			{
				// This call sets up the return value
				RetVal = m_Calls.GetAt(pos);
			}
		}
	}
	return(RetVal);
}

#if 0
void
CRegistration::Lock(void)
{
	EnterCriticalSection(&m_CriticalSection);
	m_dwLockingThread = GetCurrentThreadId();
}

void
CRegistration::Unlock(void)
{
	// Assert that the unlock is done by the
	// thread that holds the lock
	ASSERT(m_dwLockingThread == GetCurrentThreadId());
	
	m_dwLockingThread = 0;
	LeaveCriticalSection(&m_CriticalSection);
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\gkiunreg.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\gkiunreg.cpv  $
*																		*
*	$Revision:   1.6  $
*	$Date:   12 Feb 1997 01:11:02  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\gkiunreg.cpv  $
// 
//    Rev 1.6   12 Feb 1997 01:11:02   CHULME
// Redid thread synchronization to use Gatekeeper.Lock
// 
//    Rev 1.5   17 Jan 1997 09:02:20   CHULME
// Changed reg.h to gkreg.h to avoid name conflict with inc directory
// 
//    Rev 1.4   10 Jan 1997 16:15:44   CHULME
// Removed MFC dependency
// 
//    Rev 1.3   20 Dec 1996 16:38:16   CHULME
// Fixed access synchronization with Gatekeeper lock
// 
//    Rev 1.2   02 Dec 1996 23:50:48   CHULME
// Added premptive synchronization code
// 
//    Rev 1.1   22 Nov 1996 15:22:12   CHULME
// Added VCS log to the header
*************************************************************************/

// gkiunregistration.cpp : Handles the GKI_UnregistrationRequest API
//

#include "precomp.h"

#include <process.h>
#include <winsock.h>
#include "GKICOM.H"
#include "dspider.h"
#include "dgkilit.h"
#include "DGKIPROT.H"
#include "GATEKPR.H"
#include "gksocket.h"
#include "GKREG.H"
#include "h225asn.h"
#include "coder.hpp"
#include "dgkiext.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern "C" HRESULT DLL_EXPORT
GKI_UnregistrationRequest(void)
{
	// ABSTRACT:  This function is exported.  It is called by the client application
	//            to unregister with the Gatekeeper.  The handle supplied by the client
	//            is actually a pointer to the CRegistration object, which will be 
	//            deleted
	// AUTHOR:    Colin Hulme

	HRESULT			hResult;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "GKI_UnregistrationRequest()\n", 0);
	SPIDER_TRACE(SP_GKI, "GKI_UnregistrationRequest()\n", 0);

	// Create a Gatekeeper lock object on the stack
	// It's constructor will lock pGK and when we return
	// from any path, its destructor will unlock pGK
	CGatekeeperLock	GKLock(g_pGatekeeper);
	if (g_pReg == 0)
		return (GKI_NOT_REG);

	// Protect against concurrent PDUs
	if (g_pReg->GetRasMessage() != 0)
		return (GKI_BUSY);


	// Create UnregistrationRequest structure - Encode and send PDU
	hResult = g_pReg->UnregistrationRequest();

	return (hResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\gkreg.h ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\gkreg.h_v  $
*																		*
*	$Revision:   1.2  $
*	$Date:   12 Feb 1997 01:12:04  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\gkreg.h_v  $
 *
 *    Rev 1.2   12 Feb 1997 01:12:04   CHULME
 * Redid thread synchronization to use Gatekeeper.Lock
 *
 *    Rev 1.1   08 Feb 1997 12:17:00   CHULME
 * Changed from using unsigned long to using HANDLE for threads
 * Added semphore to registration class
 *
 *    Rev 1.0   17 Jan 1997 08:48:32   CHULME
 * Initial revision.
 *
 *    Rev 1.3   10 Jan 1997 16:16:02   CHULME
 * Removed MFC dependency
 *
 *    Rev 1.2   02 Dec 1996 23:50:34   CHULME
 * Added premptive synchronization code
 *
 *    Rev 1.1   22 Nov 1996 15:21:16   CHULME
 * Added VCS log to the header
*************************************************************************/

// Registration.h : interface of the CRegistration class
// See Registration.cpp for the implementation of this class
/////////////////////////////////////////////////////////////////////////////

#ifndef REGISTRATION_H
#define REGISTRATION_H

#include "dcall.h"

extern "C" HRESULT CopyVendorInfo(PCC_VENDORINFO *ppDest, PCC_VENDORINFO pSource);
extern "C" HRESULT FreeVendorInfo(PCC_VENDORINFO pVendorInfo);

typedef void * POS;

template <class T> struct TItem
{
	TItem	*pNext;
	TItem	*pPrev;
	T		Value;
	TItem	(const T& NewValue) : Value(NewValue) {}
};

// Here we implement a circularly linked list
template <class T> class CLinkedList
{
public:
			CLinkedList();
			~CLinkedList();
	void	AddTail (const T& NewItem);
	BOOL	IsEmpty (void);
	POS		GetFirstPos (void);
	T		GetNext (POS &Position);
	POS		Find (const T& Item);
	BOOL	RemoveAt (POS &Position);
	T		GetAt(const POS Position);
	void	RemoveAll(void);
	int		GetCount(void);

private:
	TItem<T> *pTail;
	int iCount;
	void AddTailPriv(TItem<T> *pNewItem);
};

typedef CLinkedList < CCall* > CCallList;

class CRegistration
{
private:
	SeqTransportAddr		*m_pCallSignalAddress;
	EndpointType			m_terminalType;
	SeqAliasAddr			*m_pRgstrtnRqst_trmnlAls;
	HWND					m_hWnd;
	WORD					m_wBaseMessage;
	unsigned short			m_usRegistrationTransport;

	SeqAliasAddr			*m_pLocationInfo;
	TransportAddress		m_Location[2];
    PCC_VENDORINFO         m_pVendorInfo;
	GatekeeperIdentifier	m_RCm_gtkprIdntfr;
	EndpointIdentifier		m_endpointID;

	RequestSeqNum			m_requestSeqNum;
	SeqTransportAddr		*m_pRASAddress;

	CCallList				m_Calls;

	RasMessage				*m_pRasMessage;

	HANDLE					m_hRcvThread;
	UINT_PTR                m_uTimer;
	UINT                    m_uRetryResetCount;
	UINT                    m_uRetryCountdown;
	UINT                    m_uMaxRetryCount;
	CRITICAL_SECTION		m_SocketCRS;
	
//	HANDLE					m_hRetryThread;
#ifdef BROADCAST_DISCOVERY	
	HANDLE					m_hDiscThread;
#endif
	unsigned short			m_usCallReferenceValue;
	unsigned short			m_usRetryCount;
//	CRITICAL_SECTION		m_CriticalSection;
//	DWORD					m_dwLockingThread;

public:
//	volatile HANDLE			m_hRetrySemaphore;

	enum {
		GK_UNREGISTERED,
		GK_REG_PENDING,
		GK_REGISTERED,
		GK_UNREG_PENDING,
		GK_LOC_PENDING
	}						m_State;

	CGKSocket				*m_pSocket;

	CRegistration();
	~CRegistration();
	
    HRESULT AddVendorInfo(PCC_VENDORINFO pVendorInfo);
	HRESULT AddCallSignalAddr(TransportAddress& rvalue);
	HRESULT AddRASAddr(TransportAddress& rvalue, unsigned short usPort);
	void SetTerminalType(EndpointType *pTerminalType)
	{
		m_terminalType = *pTerminalType;
	}
	HRESULT AddAliasAddr(AliasAddress& rvalue);
	HRESULT AddLocationInfo(AliasAddress& rvalue);
	void SetHWnd(HWND hWnd)
	{
		m_hWnd = hWnd;
	}
	void SetBaseMessage(WORD wBaseMessage)
	{
		m_wBaseMessage = wBaseMessage;
	}
	void SetRegistrationTransport(unsigned short usRegistrationTransport)
	{
		m_usRegistrationTransport = usRegistrationTransport;
	}
	void SetRcvThread(HANDLE hThread)
	{
		m_hRcvThread = hThread;
	}
	HANDLE GetRcvThread(void)
	{
		return m_hRcvThread;
	}
	void LockSocket()	{ EnterCriticalSection(&m_SocketCRS); }
	void UnlockSocket() { LeaveCriticalSection(&m_SocketCRS); }

	UINT_PTR StartRetryTimer(void);

//	void SetRetryThread(HANDLE hThread)
//	{
//		m_hRetryThread = hThread;
//	}
#ifdef BROADCAST_DISCOVERY
	void SetDiscThread(HANDLE hThread)
	{
		m_hDiscThread = hThread;
	}
	HANDLE GetDiscThread(void)
	{
		return m_hDiscThread;
	}
#endif 	
	HWND GetHWnd(void)
	{
		return (m_hWnd);
	}
	WORD GetBaseMessage(void)
	{
		return (m_wBaseMessage);
	}
	unsigned short GetRegistrationTransport(void)
	{
		return (m_usRegistrationTransport);
	}
	unsigned short GetNextCRV(void)
	{
		return (++m_usCallReferenceValue);
	}
	TransportAddress *GetTransportAddress(unsigned short usCallTransport);
	RequestSeqNum GetNextSeqNum(void)
	{
		return (++m_requestSeqNum);
	}
	EndpointIdentifier GetEndpointIdentifier(void)
	{
		return (m_endpointID);
	}
	SeqAliasAddr *GetAlias(void)
	{
		return (m_pRgstrtnRqst_trmnlAls);
	}
	RasMessage *GetRasMessage(void)
	{
		return (m_pRasMessage);
	}
	int GetState(void)
	{
		return (m_State);
	}

	HRESULT RegistrationRequest(BOOL fDiscovery);
	HRESULT UnregistrationRequest(void);
	HRESULT GatekeeperRequest(void);
	HRESULT LocationRequest(void);

	HRESULT PDUHandler(RasMessage *pRasMessage);

	HRESULT RegistrationConfirm(RasMessage *pRasMessage);
	HRESULT RegistrationReject(RasMessage *pRasMessage);
	HRESULT UnregistrationConfirm(RasMessage *pRasMessage);
	HRESULT UnregistrationReject(RasMessage *pRasMessage);
	HRESULT LocationConfirm(RasMessage *pRasMessage);
	HRESULT LocationReject(RasMessage *pRasMessage);
	HRESULT UnknownMessage(RasMessage *pRasMessage);
	HRESULT GatekeeperConfirm(RasMessage *pRasMessage);
	HRESULT GatekeeperReject(RasMessage *pRasMessage);
	HRESULT SendUnregistrationConfirm(RasMessage *pRasMessage);
	HRESULT Retry(void);
	HRESULT SendInfoRequestResponse(CallInfoStruct *pCallInfo, RasMessage *pRasMessage);
	CCall *FindCallBySeqNum(RequestSeqNum seqNum);
	CCall *FindCallByCRV(CallReferenceValue crv);
	void DeleteCall(CCall *pCall);
	void AddCall(CCall *pCall);
	CCall *GetNextCall(CCall *pCall);
//	void Lock(void);
//	void Unlock(void);
};

#if 0
class CRegistrationLock
{
private:
	CRegistration*	m_pReg;
public:
	CRegistrationLock(CRegistration *g_pReg)
	{
		_ASSERT(g_pReg);
		m_pReg = g_pReg;
		g_pReg->Lock();
	}
	~CRegistrationLock()
	{
		m_pReg->Unlock();
	}
};
#endif

#endif // REGISTRATION_H

/////////////////////////////////////////////////////////////////////////////

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\gksocket.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\gksocket.cpv  $
*																		*
*	$Revision:   1.5  $
*	$Date:   28 Feb 1997 15:46:24  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\gksocket.cpv  $
// 
//    Rev 1.5   28 Feb 1997 15:46:24   CHULME
// Check additional return value on recvfrom for a closed socket
// 
//    Rev 1.4   17 Jan 1997 09:02:28   CHULME
// Changed reg.h to gkreg.h to avoid name conflict with inc directory
// 
//    Rev 1.3   10 Jan 1997 16:15:48   CHULME
// Removed MFC dependency
// 
//    Rev 1.2   18 Dec 1996 14:23:30   CHULME
// Changed discovery to send broadcast and multicast GRQs - debug only disable
// 
//    Rev 1.1   22 Nov 1996 14:56:04   CHULME
// Added detection of LastError = 0 for treatment on socket close
*************************************************************************/

// gksocket.cpp : Provides the implementation for the CGKSocket class
//

#include <precomp.h>

#define IP_MULTICAST_TTL    3           /* set/get IP multicast timetolive  */

#include "dspider.h"
#include "dgkilit.h"
#include "DGKIPROT.H"
#include "GATEKPR.H"
#include "gksocket.h"
#include "GKREG.H"
#include "h225asn.h"
#include "coder.hpp"
#include "dgkiext.h"

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
	// INTEROP
	#include "interop.h"
	#include "rasplog.h"
	extern LPInteropLogger		RasLogger;
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGKSocket construction

CGKSocket::CGKSocket()
{
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_CONDES, "CGKSocket::CGKSocket()\n", 0);

	m_hSocket = INVALID_SOCKET;
	m_nLastErr = 0;
	m_nAddrFam = 0;
	m_usPort = 0;
}

/////////////////////////////////////////////////////////////////////////////
// CGKSocket destruction

CGKSocket::~CGKSocket()
{
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_CONDES, "CGKSocket::~CGKSocket()\n", 0);

	if (m_hSocket != INVALID_SOCKET)
		Close();
}

int
CGKSocket::Create(int nAddrFam, unsigned short usPort)
{
// ABSTRACT:  Creates the socket for the supplied address family (transport) 
//            and binds it to the specified port.  This function returns 0
//            if successful, else it will return the winsock comm error code.
// AUTHOR:    Colin Hulme

	int				nRet, nLen;
	SOCKADDR_IN		sAddrIn;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif


	SPIDER_TRACE(SP_FUNC, "CGKSocket::Create(nAddrFam, %X)\n", usPort);

	// Create a socket for the supplied address family
	SPIDER_TRACE(SP_WSOCK, "socket(%X, SOCK_DGRAM, 0)\n", nAddrFam);
	if ((m_hSocket = socket(nAddrFam, SOCK_DGRAM, 0)) == INVALID_SOCKET)
	{
		m_nLastErr = WSAGetLastError();		// Get winsock error code
		SpiderWSErrDecode(m_nLastErr);		// Debug print of error decode
		return (m_nLastErr);
	}
	m_nAddrFam = nAddrFam;

	// Bind socket to a local address
	switch (nAddrFam)
	{
	case PF_INET:
		sAddrIn.sin_family = AF_INET;
		break;
	case PF_IPX:
		sAddrIn.sin_family = AF_IPX;
		break;
	}
	sAddrIn.sin_addr.s_addr = htonl(INADDR_ANY);
	sAddrIn.sin_port = htons(usPort);
	SPIDER_TRACE(SP_WSOCK, "bind(%X, &sAddrIn, sizeof(sAddrIn))\n", m_hSocket);
	nRet = bind(m_hSocket, (LPSOCKADDR)&sAddrIn, sizeof(sAddrIn));
	if (nRet != 0)
	{
		m_nLastErr = WSAGetLastError();
		SpiderWSErrDecode(m_nLastErr);
		Close();		// Close the socket
		return (m_nLastErr);
	}

	// Get dynamic port number - not actually guaranteed til after connect
	SPIDER_TRACE(SP_WSOCK, "getsockname(%X, (LPSOCKADDR)&sAddrIn, sizeof(sAddrIn))\n", m_hSocket);
	nLen = sizeof(sAddrIn);
	nRet = getsockname(m_hSocket, (LPSOCKADDR)&sAddrIn, &nLen);
	if (nRet == SOCKET_ERROR)
	{
		m_nLastErr = WSAGetLastError();
		SpiderWSErrDecode(m_nLastErr);
		Close();		// Close the socket
		return (SOCKET_ERROR);
	}
	SPIDER_DEBUG(sAddrIn.sin_port);
	m_usPort = ntohs(sAddrIn.sin_port);

	return (0);
}

int
CGKSocket::Connect(PSOCKADDR_IN pAddr)
{
// ABSTRACT:  This simulates a connect.  It simply stores the relevant
//            information in a member variable that will be used by the
//            Send and Receive member functions.
// AUTHOR:    Colin Hulme

	m_sAddrIn = *pAddr;
	m_sAddrIn.sin_family = AF_INET;
	m_sAddrIn.sin_port = htons(GKIP_RAS_PORT);

	return (0);
}

int
CGKSocket::Send(char *pBuffer, int nLen)
{
// ABSTRACT:  This function will send a datagram on the connected socket.
// AUTHOR:    Colin Hulme

	int				nRet;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CGKSocket::Send(pBuffer, %X)\n", nLen);

	SPIDER_TRACE(SP_WSOCK, "sendto(%X, pBuffer, nLen, 0, &m_sAddrIn, sizeof(m_sAddrIn))\n", m_hSocket);
#ifdef _DEBUG
	//INTEROP
	if (dwGKIDLLFlags & SP_LOGGER)
		InteropOutput((LPInteropLogger)RasLogger,
						(BYTE FAR *)pBuffer,
						nLen,
						RASLOG_SENT_PDU);
#endif
#ifdef PCS_COMPLIANCE
	//INTEROP
	InteropOutput((LPInteropLogger)RasLogger,
					(BYTE FAR *)pBuffer,
					nLen,
					RASLOG_SENT_PDU);
#endif
	nRet = sendto(m_hSocket, pBuffer, nLen, 0, (LPSOCKADDR)&m_sAddrIn, sizeof(m_sAddrIn));
	SPIDER_DEBUG(nRet);
	if (nRet == SOCKET_ERROR)
	{
		m_nLastErr = WSAGetLastError();
		SpiderWSErrDecode(m_nLastErr);
		Close();		// Close the socket
		return (SOCKET_ERROR);
	}

	return (nRet);
}

int
CGKSocket::SendTo(char *pBuffer, int nLen, const struct sockaddr FAR * to, int tolen)
{
// ABSTRACT:  This function will send a datagram on the connected socket.
// AUTHOR:    Colin Hulme

	int				nRet;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CGKSocket::SendTo(pBuffer, %X, to, tolen)\n", nLen);

	SPIDER_TRACE(SP_WSOCK, "sendto(%X, pBuffer, nLen, 0, to, tolen)\n", m_hSocket);
#ifdef _DEBUG
	//INTEROP
	if (dwGKIDLLFlags & SP_LOGGER)
		InteropOutput((LPInteropLogger)RasLogger,
						(BYTE FAR *)pBuffer,
						nLen,
						RASLOG_SENT_PDU);
#endif
#ifdef PCS_COMPLIANCE
	//INTEROP
	InteropOutput((LPInteropLogger)RasLogger,
					(BYTE FAR *)pBuffer,
					nLen,
					RASLOG_SENT_PDU);
#endif
	nRet = sendto(m_hSocket, pBuffer, nLen, 0, to, tolen);
	SPIDER_DEBUG(nRet);
	if (nRet == SOCKET_ERROR)
	{
		m_nLastErr = WSAGetLastError();
		SpiderWSErrDecode(m_nLastErr);
		Close();		// Close the socket
		return (SOCKET_ERROR);
	}

	return (nRet);
}

int
CGKSocket::Receive(char *pBuffer, int nLen)
{
// ABSTRACT:  This function will post a receive for an incoming datagram.
// AUTHOR:    Colin Hulme

	int				nRet;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CGKSocket::Receive(pBuffer, %X)\n", nLen);

	SPIDER_TRACE(SP_WSOCK, "recvfrom(%X, pBuffer, nLen, 0, 0, 0)\n", m_hSocket);
	nRet = recvfrom(m_hSocket, pBuffer, nLen, 0, 0, 0);
	SPIDER_DEBUG(nRet);
	if (nRet == SOCKET_ERROR)
	{
		m_nLastErr = WSAGetLastError();
		if ((m_nLastErr == 2) || (m_nLastErr == 0) || (m_nLastErr == WSAEINVAL))	// Weird return values seen
			m_nLastErr = WSAEINTR;		// occasionally when socket closed
		SpiderWSErrDecode(m_nLastErr);
		if (m_nLastErr != WSAEINTR)
			Close();		// Close the socket
		return (SOCKET_ERROR);
	}

#ifdef _DEBUG
	//INTEROP
	if (dwGKIDLLFlags & SP_LOGGER)
		InteropOutput((LPInteropLogger)RasLogger,
						(BYTE FAR *)pBuffer,
						nLen,
						RASLOG_RECEIVED_PDU);
#endif
#ifdef PCS_COMPLIANCE
	//INTEROP
	InteropOutput((LPInteropLogger)RasLogger,
					(BYTE FAR *)pBuffer,
					nLen,
					RASLOG_RECEIVED_PDU);
#endif

	return (nRet);
}

int
CGKSocket::SendBroadcast(char *pBuffer, int nLen)
{
// ABSTRACT:  This function will send a datagram to the broadcast address
//            and to the multicast address.  In the case of a debug build,
//            a registry setting can be used to disable the multicast
//            transmission.  Both transmissions will always occur in the
//            release build.
// AUTHOR:    Colin Hulme

	int					nRet, nValue;
	struct sockaddr_in	sAddrIn;
#ifdef _DEBUG
	char				szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CGKSocket::SendBroadcast(pBuffer, %X)\n", nLen);
	ASSERT(g_pGatekeeper);
	if(g_pGatekeeper == NULL)
		return SOCKET_ERROR;	
		
	// Setup family and port information
	switch (m_nAddrFam)
	{
	case PF_INET:
		sAddrIn.sin_family = AF_INET;
		sAddrIn.sin_port = htons(GKIP_DISC_PORT);
		break;
	case PF_IPX:
		sAddrIn.sin_family = AF_IPX;
		sAddrIn.sin_port = htons(GKIPX_DISC_PORT);
		break;
	}

	// ================= SEND BROADCAST ===================
	//if ((nValue = (int)Gatekeeper.GetMCastTTL()) == 0)
	// Set socket options to allow broadcasting on this socket
	nValue = 1;		// TRUE - for setting BOOLEAN
	SPIDER_TRACE(SP_WSOCK, "setsockopt(%X, SOL_SOCKET, SO_BROADCAST, &nValue, sizeof(nValue))\n", m_hSocket);
	nRet = setsockopt(m_hSocket, SOL_SOCKET, SO_BROADCAST, (const char *)&nValue, sizeof(nValue));
		// TBD - Don't know if SOL_SOCKET is going to work for other transports
	if (nRet == SOCKET_ERROR)
	{
		m_nLastErr = WSAGetLastError();
		SpiderWSErrDecode(m_nLastErr);
		Close();		// Close the socket
		return (SOCKET_ERROR);
	}
	sAddrIn.sin_addr.s_addr = htonl(INADDR_BROADCAST);

	SPIDER_TRACE(SP_WSOCK, "sendto(%X, pBuffer, nLen, 0, (LPSOCKADDR)&sAddrIn, sizeof(sAddrIn))\n", m_hSocket);
#ifdef _DEBUG
	//INTEROP
	if (dwGKIDLLFlags & SP_LOGGER)
		InteropOutput((LPInteropLogger)RasLogger,
						(BYTE FAR *)pBuffer,
						nLen,
						RASLOG_SENT_PDU);
#endif
#ifdef PCS_COMPLIANCE
	//INTEROP
	InteropOutput((LPInteropLogger)RasLogger,
					(BYTE FAR *)pBuffer,
					nLen,
					RASLOG_SENT_PDU);
#endif
	nRet = sendto(m_hSocket, pBuffer, nLen, 0, (LPSOCKADDR)&sAddrIn, sizeof(sAddrIn));
	SPIDER_DEBUG(nRet);
	if (nRet == SOCKET_ERROR)
	{
		m_nLastErr = WSAGetLastError();
		SpiderWSErrDecode(m_nLastErr);
		Close();		// Close the socket
		return (SOCKET_ERROR);
	}

#ifdef _DEBUG
	if ((nValue = (int)g_pGatekeeper->GetMCastTTL()) != 0)
	{		// debug only conditional for avoiding sending multicast
#endif
	// ================= SEND MULTICAST ===================
	// Set socket options for multicast time to live
	nValue = 16;	//FMN
	SPIDER_TRACE(SP_WSOCK, "setsockopt(%X, IPPROTO_IP, IP_MULTICAST_TTL, &nValue, sizeof(nValue))\n", m_hSocket);
	nRet = setsockopt(m_hSocket, IPPROTO_IP, IP_MULTICAST_TTL, 
					(const char *)&nValue, sizeof(nValue));
		// TBD - IP specific - handle IPX case with broadcast?
	if (nRet == SOCKET_ERROR)
	{
		m_nLastErr = WSAGetLastError();
		SpiderWSErrDecode(m_nLastErr);
		Close();		// Close the socket
		return (SOCKET_ERROR);
	}
	sAddrIn.sin_addr.s_addr = inet_addr(GKIP_DISC_MCADDR);

	SPIDER_TRACE(SP_WSOCK, "sendto(%X, pBuffer, nLen, 0, (LPSOCKADDR)&sAddrIn, sizeof(sAddrIn))\n", m_hSocket);
#ifdef _DEBUG
	//INTEROP
	if (dwGKIDLLFlags & SP_LOGGER)
		InteropOutput((LPInteropLogger)RasLogger,
						(BYTE FAR *)pBuffer,
						nLen,
						RASLOG_SENT_PDU);
#endif
#ifdef PCS_COMPLIANCE
	//INTEROP
	InteropOutput((LPInteropLogger)RasLogger,
					(BYTE FAR *)pBuffer,
					nLen,
					RASLOG_SENT_PDU);
#endif
	nRet = sendto(m_hSocket, pBuffer, nLen, 0, (LPSOCKADDR)&sAddrIn, sizeof(sAddrIn));
	SPIDER_DEBUG(nRet);
	if (nRet == SOCKET_ERROR)
	{
		m_nLastErr = WSAGetLastError();
		SpiderWSErrDecode(m_nLastErr);
		Close();		// Close the socket
		return (SOCKET_ERROR);
	}
#ifdef _DEBUG
	}	// End debug only conditional for avoiding sending multicast
#endif

	return (nRet);
}

int
CGKSocket::ReceiveFrom(char *pBuffer, int nLen)
{
// ABSTRACT:  This function will post a receivefrom looking for a GCF or GRJ
// AUTHOR:    Colin Hulme

	int				nRet;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CGKSocket::ReceiveFrom(pBuffer, %X)\n", nLen);

	SPIDER_TRACE(SP_WSOCK, "recvfrom(%X, pBuffer, nLen, 0, 0, 0)\n", m_hSocket);
	nRet = recvfrom(m_hSocket, pBuffer, nLen, 0, 0, 0);
	SPIDER_DEBUG(nRet);
	if (nRet == SOCKET_ERROR)
	{
		m_nLastErr = WSAGetLastError();
		if ((m_nLastErr == 2) || (m_nLastErr == 0))	// Weird return values seen
			m_nLastErr = WSAEINTR;		// occasionally when socket closed
		SpiderWSErrDecode(m_nLastErr);
		if (m_nLastErr != WSAEINTR)
			Close();		// Close the socket
		return (SOCKET_ERROR);
	}

#ifdef _DEBUG
	//INTEROP
	if (dwGKIDLLFlags & SP_LOGGER)
		InteropOutput((LPInteropLogger)RasLogger,
						(BYTE FAR *)pBuffer,
						nLen,
						RASLOG_RECEIVED_PDU);
#endif
#ifdef PCS_COMPLIANCE
	//INTEROP
	InteropOutput((LPInteropLogger)RasLogger,
					(BYTE FAR *)pBuffer,
					nLen,
					RASLOG_RECEIVED_PDU);
#endif

	return (nRet);
}

int
CGKSocket::Close(void)
{
// ABSTRACT:  This function will close the socket
// AUTHOR:    Colin Hulme

	int				nRet;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CGKSocket::Close()\n", 0);

	// Close the socket
	SPIDER_TRACE(SP_WSOCK, "closesocket(%X)\n", m_hSocket);
	nRet = closesocket(m_hSocket);
	m_hSocket = INVALID_SOCKET;

	return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\gk_asn1.h ===
#ifndef _GK_ASN1_H_
#define _GK_ASN1_H_

#include "av_asn1.h"
#include "h225asn.h"

#ifdef __cplusplus
extern "C" {
#endif


// GatekeeperInfo, H310Caps, H320Caps, H321Caps, H322Caps, H323Caps, H324Caps, VoiceCaps, T120OnlyCaps, McuInfo, TerminalInfo
#define GtkprInf_nnStndrdDt_present     GatekeeperInfo_nonStandardData_present
#define GtkprInf_nnStndrdDt             nonStandardData

// GatewayInfo
#define GtwyInf_nonStandardData_present GatewayInfo_nonStandardData_present
#define GtwyInf_nonStandardData         nonStandardData

// EndpointType
#define EndpntTyp_nnStndrdDt_present    EndpointType_nonStandardData_present
#define EndpntTyp_nnStndrdDt            nonStandardData

// GatekeeperRequest
#define GtkprRqst_nnStndrdDt_present    GatekeeperRequest_nonStandardData_present
#define GtkprRqst_gtkprIdntfr_present   GatekeeperRequest_gatekeeperIdentifier_present
#define GtkprRqst_callServices_present  GatekeeperRequest_callServices_present
#define GtkprRqst_endpointAlias_present GatekeeperRequest_endpointAlias_present
#define GtkprRqst_nnStndrdDt            nonStandardData
#define GtkprRqst_gtkprIdntfr           gatekeeperIdentifier
#define GtkprRqst_callServices          callServices
#define GtkprRqst_endpointAlias         endpointAlias

// GatekeeperConfirm
#define GtkprCnfrm_nnStndrdDt_present   GatekeeperConfirm_nonStandardData_present
#define GtkprCnfrm_gtkprIdntfr_present  GatekeeperConfirm_gatekeeperIdentifier_present
#define GtkprCnfrm_nnStndrdDt           nonStandardData
#define GtkprCnfrm_gtkprIdntfr          gatekeeperIdentifier

// GatekeeperRejectReason
#define GtkprRjctRsn_rsrcUnvlbl_chosen  GatekeeperRejectReason_resourceUnavailable_chosen
#define GtkprRjctRsn_invldRvsn_chosen   GatekeeperRejectReason_invalidRevision_chosen
#define GtkprRjctRsn_undfndRsn_chosen   GatekeeperRejectReason_undefinedReason_chosen

// GatekeeperReject
#define GtkprRjct_nnStndrdDt_present    GatekeeperReject_nonStandardData_present
#define GtkprRjct_gtkprIdntfr_present   GatekeeperReject_gatekeeperIdentifier_present
#define GtkprRjct_nnStndrdDt            nonStandardData
#define GtkprRjct_gtkprIdntfr           gatekeeperIdentifier

// RegistrationRequest
#define RgstrtnRqst_nnStndrdDt_present  RegistrationRequest_nonStandardData_present
#define RgstrtnRqst_trmnlAls_present    RegistrationRequest_terminalAlias_present
#define RgstrtnRqst_gtkprIdntfr_present RegistrationRequest_gatekeeperIdentifier_present
#define RgstrtnRqst_nnStndrdDt          nonStandardData
#define RgstrtnRqst_trmnlAls            terminalAlias
#define RgstrtnRqst_gtkprIdntfr         gatekeeperIdentifier

// RegistrationConfirm
#define RgstrtnCnfrm_nnStndrdDt_present RegistrationConfirm_nonStandardData_present
#define RgstrtnCnfrm_trmnlAls_present   RegistrationConfirm_terminalAlias_present
#define RCm_gtkprIdntfr_present         RegistrationConfirm_gatekeeperIdentifier_present
#define RgstrtnCnfrm_nnStndrdDt         nonStandardData
#define RgstrtnCnfrm_trmnlAls           terminalAlias
#define RCm_gtkprIdntfr                 gatekeeperIdentifier

// RegistrationRejectReason
#define RgstrtnRjctRsn_invldRvsn_chosen RegistrationRejectReason_invalidRevision_chosen
#define RgstrtnRjctRsn_undfndRsn_chosen RegistrationRejectReason_undefinedReason_chosen

// RegistrationReject
#define RgstrtnRjct_nnStndrdDt_present  RegistrationReject_nonStandardData_present
#define RgstrtnRjct_gtkprIdntfr_present RegistrationReject_gatekeeperIdentifier_present
#define RgstrtnRjct_nnStndrdDt          nonStandardData
#define RgstrtnRjct_gtkprIdntfr         gatekeeperIdentifier

// UnregistrationRequest
#define UnrgstrtnRqst_endpntAls_present UnregistrationRequest_endpointAlias_present
#define URt_nnStndrdDt_1_present        UnregistrationRequest_nonStandardData_present
#define URt_endpntIdntfr_present        UnregistrationRequest_endpointIdentifier_present
#define UnrgstrtnRqst_endpntAls         endpointAlias
#define URt_nnStndrdDt_1                nonStandardData
#define URt_endpntIdntfr                endpointIdentifier

// UnregistrationConfirm
#define UCm_nnStndrdDt_present          UnregistrationConfirm_nonStandardData_present
#define UCm_nnStndrdDt                  nonStandardData

// UnregRejectReason
#define UnrgRjctRsn_undfndRsn_chosen    UnregRejectReason_undefinedReason_chosen

// UnregistrationReject
#define URt_nnStndrdDt_2_present        UnregistrationReject_nonStandardData_present
#define URt_nnStndrdDt_2                nonStandardData

// AdmissionRequest
#define AdmssnRqst_nnStndrdDt_present   AdmissionRequest_nonStandardData_present
#define AdmssnRqst_callServices_present AdmissionRequest_callServices_present
#define AdmssnRqst_nnStndrdDt           nonStandardData
#define AdmssnRqst_callServices         callServices

// AdmissionConfirm
#define AdmssnCnfrm_nnStndrdDt_present  AdmissionConfirm_nonStandardData_present
#define AdmssnCnfrm_nnStndrdDt          nonStandardData

// AdmissionRejectReason
#define ARRn_invldPrmssn_chosen         AdmissionRejectReason_invalidPermission_chosen
#define AdmssnRjctRsn_rqstDnd_chosen    AdmissionRejectReason_requestDenied_chosen
#define AdmssnRjctRsn_undfndRsn_chosen  AdmissionRejectReason_undefinedReason_chosen
#define invldEndpntIdntfr_chosen        invalidEndpointIdentifier_chosen
#define AdmssnRjctRsn_rsrcUnvlbl_chosen AdmissionRejectReason_resourceUnavailable_chosen

// AdmissionReject
#define AdmssnRjct_nnStndrdDt_present   AdmissionReject_nonStandardData_present
#define AdmssnRjct_nnStndrdDt           nonStandardData

// BandwidthRequest
#define BndwdthRqst_nnStndrdDt_present  BandwidthRequest_nonStandardData_present
#define BndwdthRqst_nnStndrdDt          nonStandardData

// BandwidthConfirm
#define BndwdthCnfrm_nnStndrdDt_present BandwidthConfirm_nonStandardData_present
#define BndwdthCnfrm_nnStndrdDt         nonStandardData

// BandRejectReason
#define BndRjctRsn_invldPrmssn_chosen   BandRejectReason_invalidPermission_chosen
#define BndRjctRsn_invldRvsn_chosen     BandRejectReason_invalidRevision_chosen
#define BndRjctRsn_undfndRsn_chosen     BandRejectReason_undefinedReason_chosen

// BandwidthReject
#define BndwdthRjct_nnStndrdDt_present  BandwidthReject_nonStandardData_present
#define BndwdthRjct_nnStndrdDt          nonStandardData

// DisengageReason
#define DsnggRsn_undefinedReason_chosen DisengageReason_undefinedReason_chosen

// DisengageRequest
#define DsnggRqst_nnStndrdDt_present    DisengageRequest_nonStandardData_present
#define DsnggRqst_nnStndrdDt            nonStandardData

// DisengageConfirm
#define UCm_nnStndrdDt                  nonStandardData

// DisengageRejectReason
#define DsnggRjctRsn_ntRgstrd_chosen    DisengageRejectReason_notRegistered_chosen

// DisengageReject
#define DsnggRjct_nnStndrdDt_present    DisengageReject_nonStandardData_present
#define DsnggRjct_nnStndrdDt            nonStandardData

// LocationRequest
#define LctnRqst_endpntIdntfr_present   LocationRequest_endpointIdentifier_present
#define LctnRqst_nnStndrdDt_present     LocationRequest_nonStandardData_present
#define LctnRqst_endpntIdntfr           endpointIdentifier
#define LctnRqst_nnStndrdDt             nonStandardData

// LocationConfirm
#define LctnCnfrm_nnStndrdDt_present    LocationConfirm_nonStandardData_present
#define LctnCnfrm_nnStndrdDt            nonStandardData

// LocationRejectReason
#define LctnRjctRsn_ntRgstrd_chosen     LocationRejectReason_notRegistered_chosen
#define LctnRjctRsn_invldPrmssn_chosen  LocationRejectReason_invalidPermission_chosen
#define LctnRjctRsn_rqstDnd_chosen      LocationRejectReason_requestDenied_chosen
#define LctnRjctRsn_undfndRsn_chosen    LocationRejectReason_undefinedReason_chosen

// LocationReject
#define LctnRjct_nnStndrdDt_present     LocationReject_nonStandardData_present
#define LctnRjct_nnStndrdDt             nonStandardData

// InfoRequest
#define InfRqst_nonStandardData_present InfoRequest_nonStandardData_present
#define InfRqst_nonStandardData         nonStandardData

// InfoRequestResponse
#define InfRqstRspns_nnStndrdDt_present InfoRequestResponse_nonStandardData_present
#define InfRqstRspns_endpntAls_present  InfoRequestResponse_endpointAlias_present
#define InfRqstRspns_nnStndrdDt         nonStandardData
#define InfRqstRspns_endpntAls          endpointAlias

#define prCllInf_nnStndrdDt_present     InfoRequestResponse_perCallInfo_Seq_nonStandardData_present
#define prCllInf_nnStndrdDt             nonStandardData


#ifdef __cplusplus
}
#endif


#endif // _GK_ASN1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\gksocket.h ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\gksocket.h_v  $
*																		*
*	$Revision:   1.2  $
*	$Date:   10 Jan 1997 16:15:50  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\gksocket.h_v  $
 * 
 *    Rev 1.2   10 Jan 1997 16:15:50   CHULME
 * Removed MFC dependency
 * 
 *    Rev 1.1   22 Nov 1996 15:24:10   CHULME
 * Added VCS log to the header
*************************************************************************/

// gksocket.h : interface of the CGKSocket class
// See gksocket.cpp for the implementation of this class
/////////////////////////////////////////////////////////////////////////////

#ifndef GKSOCKET_H
#define GKSOCKET_H
#undef _WIN32_WINNT	// override bogus platform definition in our common build environment
//#include <winsock.h>

class CGKSocket
{
private:
	SOCKET				m_hSocket;
	int					m_nLastErr;
	int					m_nAddrFam;
	unsigned short		m_usPort;
	struct sockaddr_in	m_sAddrIn;


public:
	CGKSocket();
	~CGKSocket();

	int Create(int nAddrFam, unsigned short usPort);
	int Connect(PSOCKADDR_IN pAddr);
	int Send(char *pBuffer, int nLen);
	int Receive(char *pBuffer, int nLen);
	int SendBroadcast(char *pBuffer, int nLen);
	int ReceiveFrom(char *pBuffer, int nLen);
	int SendTo(char *pBuffer, int nLen, const struct sockaddr FAR * to, int tolen);
	int Close(void);
	unsigned short GetPort(void)
	{
		return (m_usPort);
	}
	int GetLastError(void)
	{
		return (m_nLastErr);
	}
	int GetAddrFam(void)
	{
		return (m_nAddrFam);
	}
};


#endif // GKSOCKET_H

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h245asn.h ===
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for Multimedia System Control (H.245) */

#ifndef _H245ASN_Module_H_
#define _H245ASN_Module_H_

#include "msper.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct UnicastAddress_iPSourceRouteAddress_route * PUnicastAddress_iPSourceRouteAddress_route;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers * PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers;

typedef struct RedundancyEncodingCapability_secondaryEncoding * PRedundancyEncodingCapability_secondaryEncoding;

typedef struct RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom * PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom;

typedef struct MultiplexElement_type_subElementList * PMultiplexElement_type_subElementList;

typedef struct RequestAllTerminalIDsResponse_terminalInformation * PRequestAllTerminalIDsResponse_terminalInformation;

typedef struct EncryptionSync_escrowentry * PEncryptionSync_escrowentry;

typedef struct H263Options_customPictureFormat * PH263Options_customPictureFormat;

typedef struct H263Options_customPictureClockFrequency * PH263Options_customPictureClockFrequency;

typedef struct MultipointCapability_mediaDistributionCapability * PMultipointCapability_mediaDistributionCapability;

typedef struct H222Capability_vcCapability * PH222Capability_vcCapability;

typedef struct CapabilityDescriptor_simultaneousCapabilities * PCapabilityDescriptor_simultaneousCapabilities;

typedef struct CertSelectionCriteria * PCertSelectionCriteria;

typedef struct CommunicationModeTableEntry_nonStandard * PCommunicationModeTableEntry_nonStandard;

typedef struct MultiplexEntrySend_multiplexEntryDescriptors * PMultiplexEntrySend_multiplexEntryDescriptors;

typedef struct H2250LogicalChannelAckParameters_nonStandard * PH2250LogicalChannelAckParameters_nonStandard;

typedef struct H2250LogicalChannelParameters_nonStandard * PH2250LogicalChannelParameters_nonStandard;

typedef struct ConferenceCapability_nonStandardData * PConferenceCapability_nonStandardData;

typedef struct H263Options_modeCombos * PH263Options_modeCombos;

typedef struct TransportCapability_qOSCapabilities * PTransportCapability_qOSCapabilities;

typedef struct EncryptionCapability * PEncryptionCapability;

typedef struct EnhancementLayerInfo_spatialEnhancement * PEnhancementLayerInfo_spatialEnhancement;

typedef struct EnhancementLayerInfo_snrEnhancement * PEnhancementLayerInfo_snrEnhancement;

typedef struct H2250Capability_redundancyEncodingCapability * PH2250Capability_redundancyEncodingCapability;

typedef struct EnhancementLayerInfo_bPictureEnhancement * PEnhancementLayerInfo_bPictureEnhancement;

typedef struct MediaDistributionCapability_distributedData * PMediaDistributionCapability_distributedData;

typedef struct MediaDistributionCapability_centralizedData * PMediaDistributionCapability_centralizedData;

typedef struct CommunicationModeResponse_communicationModeTable * PCommunicationModeResponse_communicationModeTable;

typedef struct CommunicationModeCommand_communicationModeTable * PCommunicationModeCommand_communicationModeTable;

typedef struct TerminalCapabilitySet_capabilityTable * PTerminalCapabilitySet_capabilityTable;

typedef struct RequestMode_requestedModes * PRequestMode_requestedModes;

typedef struct UnicastAddress_iPSourceRouteAddress_route_Seq {
    ASN1uint32_t length;
    ASN1octet_t value[4];
} UnicastAddress_iPSourceRouteAddress_route_Seq;

typedef ASN1uint16_t CustomPictureFormat_pixelAspectInformation_pixelAspectCode_Set;

typedef ASN1uint16_t RTPH263VideoRedundancyEncoding_containedThreads_Seq;

typedef ASN1uint16_t RTPH263VideoRedundancyFrameMapping_frameSequence_Seq;

typedef ASN1uint16_t SequenceNumber;

typedef ASN1uint16_t CapabilityTableEntryNumber;

typedef ASN1uint16_t CapabilityDescriptorNumber;

typedef ASN1uint16_t LogicalChannelNumber;

typedef ASN1uint16_t MultiplexTableEntryNumber;

typedef ASN1uint16_t McuNumber;

typedef ASN1uint16_t TerminalNumber;

typedef struct TerminalID {
    ASN1uint32_t length;
    ASN1octet_t value[128];
} TerminalID;

typedef struct ConferenceID {
    ASN1uint32_t length;
    ASN1octet_t value[32];
} ConferenceID;

typedef struct Password {
    ASN1uint32_t length;
    ASN1octet_t value[32];
} Password;

typedef struct NewATMVCIndication_aal_aal1_errorCorrection {
    ASN1choice_t choice;
#   define nullErrorCorrection_chosen 1
#   define longInterleaver_chosen 2
#   define shortInterleaver_chosen 3
#   define errorCorrectionOnly_chosen 4
} NewATMVCIndication_aal_aal1_errorCorrection;

typedef struct NewATMVCIndication_aal_aal1_clockRecovery {
    ASN1choice_t choice;
#   define nullClockRecovery_chosen 1
#   define srtsClockRecovery_chosen 2
#   define adaptiveClockRecovery_chosen 3
} NewATMVCIndication_aal_aal1_clockRecovery;

typedef struct MiscellaneousCommand_type_progressiveRefinementStart_repeatCount {
    ASN1choice_t choice;
#   define doOneProgression_chosen 1
#   define doContinuousProgressions_chosen 2
#   define doOneIndependentProgression_chosen 3
#   define doContinuousIndependentProgressions_chosen 4
} MiscellaneousCommand_type_progressiveRefinementStart_repeatCount;

typedef struct V76LogicalChannelParameters_mode_eRM_recovery {
    ASN1choice_t choice;
#   define rej_chosen 1
#   define sREJ_chosen 2
#   define mSREJ_chosen 3
} V76LogicalChannelParameters_mode_eRM_recovery;

typedef struct CustomPictureFormat_pixelAspectInformation_extendedPAR_Set {
    ASN1uint16_t width;
    ASN1uint16_t height;
} CustomPictureFormat_pixelAspectInformation_extendedPAR_Set;

typedef struct CustomPictureFormat_mPI_customPCF_Set {
    ASN1uint16_t clockConversionCode;
    ASN1uint16_t clockDivisor;
    ASN1uint16_t customMPI;
} CustomPictureFormat_mPI_customPCF_Set;

typedef struct VCCapability_availableBitRates_type_rangeOfBitRates {
    ASN1uint16_t lowerBitRate;
    ASN1uint16_t higherBitRate;
} VCCapability_availableBitRates_type_rangeOfBitRates;

typedef struct TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded {
    ASN1choice_t choice;
    union {
#	define highestEntryNumberProcessed_chosen 1
	CapabilityTableEntryNumber highestEntryNumberProcessed;
#	define noneProcessed_chosen 2
    } u;
} TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded;

typedef struct VCCapability_availableBitRates_type {
    ASN1choice_t choice;
    union {
#	define singleBitRate_chosen 1
	ASN1uint16_t singleBitRate;
#	define rangeOfBitRates_chosen 2
	VCCapability_availableBitRates_type_rangeOfBitRates rangeOfBitRates;
    } u;
} VCCapability_availableBitRates_type;

typedef struct H223Capability_h223MultiplexTableCapability_enhanced {
    ASN1uint16_t maximumNestingDepth;
    ASN1uint16_t maximumElementListSize;
    ASN1uint16_t maximumSubElementListSize;
} H223Capability_h223MultiplexTableCapability_enhanced;

typedef struct CustomPictureFormat_mPI_customPCF {
    ASN1uint32_t count;
    CustomPictureFormat_mPI_customPCF_Set value[16];
} CustomPictureFormat_mPI_customPCF;

typedef struct CustomPictureFormat_pixelAspectInformation_extendedPAR {
    ASN1uint32_t count;
    CustomPictureFormat_pixelAspectInformation_extendedPAR_Set value[256];
} CustomPictureFormat_pixelAspectInformation_extendedPAR;

typedef struct CustomPictureFormat_pixelAspectInformation_pixelAspectCode {
    ASN1uint32_t count;
    CustomPictureFormat_pixelAspectInformation_pixelAspectCode_Set value[14];
} CustomPictureFormat_pixelAspectInformation_pixelAspectCode;

typedef struct H223LogicalChannelParameters_adaptationLayerType_al3 {
    ASN1uint16_t controlFieldOctets;
    ASN1uint32_t sendBufferSize;
} H223LogicalChannelParameters_adaptationLayerType_al3;

typedef struct V76LogicalChannelParameters_mode_eRM {
    ASN1uint16_t windowSize;
    V76LogicalChannelParameters_mode_eRM_recovery recovery;
} V76LogicalChannelParameters_mode_eRM;

typedef struct UnicastAddress_iPSourceRouteAddress_route {
    PUnicastAddress_iPSourceRouteAddress_route next;
    UnicastAddress_iPSourceRouteAddress_route_Seq value;
} UnicastAddress_iPSourceRouteAddress_route_Element;

typedef struct UnicastAddress_iPSourceRouteAddress_routing {
    ASN1choice_t choice;
#   define strict_chosen 1
#   define loose_chosen 2
} UnicastAddress_iPSourceRouteAddress_routing;

typedef struct H223ModeParameters_adaptationLayerType_al3 {
    ASN1uint16_t controlFieldOctets;
    ASN1uint32_t sendBufferSize;
} H223ModeParameters_adaptationLayerType_al3;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers {
    ASN1uint32_t count;
    CapabilityDescriptorNumber value[256];
} SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers {
    PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers next;
    CapabilityTableEntryNumber value;
} SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_Element;

typedef struct MiscellaneousCommand_type_progressiveRefinementStart {
    MiscellaneousCommand_type_progressiveRefinementStart_repeatCount repeatCount;
} MiscellaneousCommand_type_progressiveRefinementStart;

typedef struct MiscellaneousCommand_type_videoFastUpdateMB {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define firstGOB_present 0x80
    ASN1uint16_t firstGOB;
#   define firstMB_present 0x40
    ASN1uint16_t firstMB;
    ASN1uint16_t numberOfMBs;
} MiscellaneousCommand_type_videoFastUpdateMB;

typedef struct MiscellaneousCommand_type_videoFastUpdateGOB {
    ASN1uint16_t firstGOB;
    ASN1uint16_t numberOfGOBs;
} MiscellaneousCommand_type_videoFastUpdateGOB;

typedef struct MiscellaneousIndication_type_videoNotDecodedMBs {
    ASN1uint16_t firstMB;
    ASN1uint16_t numberOfMBs;
    ASN1uint16_t temporalReference;
} MiscellaneousIndication_type_videoNotDecodedMBs;

typedef struct NewATMVCIndication_aal_aal5 {
    ASN1uint16_t forwardMaximumSDUSize;
    ASN1uint16_t backwardMaximumSDUSize;
} NewATMVCIndication_aal_aal5;

typedef struct NewATMVCIndication_aal_aal1 {
    NewATMVCIndication_aal_aal1_clockRecovery clockRecovery;
    NewATMVCIndication_aal_aal1_errorCorrection errorCorrection;
    ASN1bool_t structuredDataTransfer;
    ASN1bool_t partiallyFilledCells;
} NewATMVCIndication_aal_aal1;

typedef struct NewATMVCIndication_reverseParameters_multiplex {
    ASN1choice_t choice;
#   define NewATMVCIndication_reverseParameters_multiplex_noMultiplex_chosen 1
#   define NewATMVCIndication_reverseParameters_multiplex_transportStream_chosen 2
#   define NewATMVCIndication_reverseParameters_multiplex_programStream_chosen 3
} NewATMVCIndication_reverseParameters_multiplex;

typedef struct UserInputIndication_signal_rtp {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define timestamp_present 0x80
    ASN1uint32_t timestamp;
#   define expirationTime_present 0x40
    ASN1uint32_t expirationTime;
    LogicalChannelNumber logicalChannelNumber;
} UserInputIndication_signal_rtp;

typedef struct UserInputIndication_signalUpdate_rtp {
    LogicalChannelNumber logicalChannelNumber;
} UserInputIndication_signalUpdate_rtp;

typedef struct UserInputIndication_signalUpdate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t duration;
#   define UserInputIndication_signalUpdate_rtp_present 0x80
    UserInputIndication_signalUpdate_rtp rtp;
} UserInputIndication_signalUpdate;

typedef struct UserInputIndication_signal {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1char_t signalType[2];
#   define duration_present 0x80
    ASN1uint16_t duration;
#   define UserInputIndication_signal_rtp_present 0x40
    UserInputIndication_signal_rtp rtp;
} UserInputIndication_signal;

typedef struct NewATMVCIndication_reverseParameters {
    ASN1uint16_t bitRate;
    ASN1bool_t bitRateLockedToPCRClock;
    ASN1bool_t bitRateLockedToNetworkClock;
    NewATMVCIndication_reverseParameters_multiplex multiplex;
} NewATMVCIndication_reverseParameters;

typedef struct NewATMVCIndication_multiplex {
    ASN1choice_t choice;
#   define NewATMVCIndication_multiplex_noMultiplex_chosen 1
#   define NewATMVCIndication_multiplex_transportStream_chosen 2
#   define NewATMVCIndication_multiplex_programStream_chosen 3
} NewATMVCIndication_multiplex;

typedef struct NewATMVCIndication_aal {
    ASN1choice_t choice;
    union {
#	define aal1_chosen 1
	NewATMVCIndication_aal_aal1 aal1;
#	define aal5_chosen 2
	NewATMVCIndication_aal_aal5 aal5;
    } u;
} NewATMVCIndication_aal;

typedef struct JitterIndication_scope {
    ASN1choice_t choice;
    union {
#	define JitterIndication_scope_logicalChannelNumber_chosen 1
	LogicalChannelNumber logicalChannelNumber;
#	define JitterIndication_scope_resourceID_chosen 2
	ASN1uint16_t resourceID;
#	define JitterIndication_scope_wholeMultiplex_chosen 3
    } u;
} JitterIndication_scope;

typedef struct FunctionNotSupported_cause {
    ASN1choice_t choice;
#   define syntaxError_chosen 1
#   define semanticError_chosen 2
#   define unknownFunction_chosen 3
} FunctionNotSupported_cause;

typedef struct H223MultiplexReconfiguration_h223AnnexADoubleFlag {
    ASN1choice_t choice;
#   define start_chosen 1
#   define stop_chosen 2
} H223MultiplexReconfiguration_h223AnnexADoubleFlag;

typedef struct H223MultiplexReconfiguration_h223ModeChange {
    ASN1choice_t choice;
#   define toLevel0_chosen 1
#   define toLevel1_chosen 2
#   define toLevel2_chosen 3
#   define toLevel2withOptionalHeader_chosen 4
} H223MultiplexReconfiguration_h223ModeChange;

typedef struct EndSessionCommand_isdnOptions {
    ASN1choice_t choice;
#   define EndSessionCommand_isdnOptions_telephonyMode_chosen 1
#   define v140_chosen 2
#   define terminalOnHold_chosen 3
} EndSessionCommand_isdnOptions;

typedef struct EndSessionCommand_gstnOptions {
    ASN1choice_t choice;
#   define EndSessionCommand_gstnOptions_telephonyMode_chosen 1
#   define v8bis_chosen 2
#   define v34DSVD_chosen 3
#   define v34DuplexFAX_chosen 4
#   define v34H324_chosen 5
} EndSessionCommand_gstnOptions;

typedef struct FlowControlCommand_restriction {
    ASN1choice_t choice;
    union {
#	define maximumBitRate_chosen 1
	ASN1uint32_t maximumBitRate;
#	define noRestriction_chosen 2
    } u;
} FlowControlCommand_restriction;

typedef struct FlowControlCommand_scope {
    ASN1choice_t choice;
    union {
#	define FlowControlCommand_scope_logicalChannelNumber_chosen 1
	LogicalChannelNumber logicalChannelNumber;
#	define FlowControlCommand_scope_resourceID_chosen 2
	ASN1uint16_t resourceID;
#	define FlowControlCommand_scope_wholeMultiplex_chosen 3
    } u;
} FlowControlCommand_scope;

typedef struct SendTerminalCapabilitySet_specificRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t multiplexCapability;
#   define capabilityTableEntryNumbers_present 0x80
    PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers capabilityTableEntryNumbers;
#   define capabilityDescriptorNumbers_present 0x40
    SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers capabilityDescriptorNumbers;
} SendTerminalCapabilitySet_specificRequest;

typedef struct RemoteMCResponse_reject {
    ASN1choice_t choice;
#   define RemoteMCResponse_reject_unspecified_chosen 1
#   define RemoteMCResponse_reject_functionNotSupported_chosen 2
} RemoteMCResponse_reject;

typedef struct ConferenceResponse_sendThisSourceResponse {
    ASN1choice_t choice;
#   define grantedSendThisSource_chosen 1
#   define deniedSendThisSource_chosen 2
} ConferenceResponse_sendThisSourceResponse;

typedef struct ConferenceResponse_makeTerminalBroadcasterResponse {
    ASN1choice_t choice;
#   define grantedMakeTerminalBroadcaster_chosen 1
#   define deniedMakeTerminalBroadcaster_chosen 2
} ConferenceResponse_makeTerminalBroadcasterResponse;

typedef struct ConferenceResponse_broadcastMyLogicalChannelResponse {
    ASN1choice_t choice;
#   define grantedBroadcastMyLogicalChannel_chosen 1
#   define deniedBroadcastMyLogicalChannel_chosen 2
} ConferenceResponse_broadcastMyLogicalChannelResponse;

typedef struct ConferenceResponse_extensionAddressResponse {
    TerminalID extensionAddress;
} ConferenceResponse_extensionAddressResponse;

typedef struct ConferenceResponse_makeMeChairResponse {
    ASN1choice_t choice;
#   define grantedChairToken_chosen 1
#   define deniedChairToken_chosen 2
} ConferenceResponse_makeMeChairResponse;

typedef struct MaintenanceLoopReject_cause {
    ASN1choice_t choice;
#   define canNotPerformLoop_chosen 1
} MaintenanceLoopReject_cause;

typedef struct MaintenanceLoopReject_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopReject_type_systemLoop_chosen 1
#	define MaintenanceLoopReject_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopReject_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopReject_type;

typedef struct MaintenanceLoopAck_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopAck_type_systemLoop_chosen 1
#	define MaintenanceLoopAck_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopAck_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopAck_type;

typedef struct MaintenanceLoopRequest_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopRequest_type_systemLoop_chosen 1
#	define MaintenanceLoopRequest_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopRequest_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopRequest_type;

typedef struct G7231AnnexCMode_g723AnnexCAudioMode {
    ASN1uint16_t highRateMode0;
    ASN1uint16_t highRateMode1;
    ASN1uint16_t lowRateMode0;
    ASN1uint16_t lowRateMode1;
    ASN1uint16_t sidMode0;
    ASN1uint16_t sidMode1;
} G7231AnnexCMode_g723AnnexCAudioMode;

typedef struct IS13818AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS13818AudioMode_multichannelType_singleChannel_chosen 1
#   define IS13818AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS13818AudioMode_multichannelType_twoChannelDual_chosen 3
#   define threeChannels2_1_chosen 4
#   define threeChannels3_0_chosen 5
#   define fourChannels2_0_2_0_chosen 6
#   define fourChannels2_2_chosen 7
#   define fourChannels3_1_chosen 8
#   define fiveChannels3_0_2_0_chosen 9
#   define fiveChannels3_2_chosen 10
} IS13818AudioMode_multichannelType;

typedef struct IS13818AudioMode_audioSampling {
    ASN1choice_t choice;
#   define audioSampling16k_chosen 1
#   define audioSampling22k05_chosen 2
#   define audioSampling24k_chosen 3
#   define IS13818AudioMode_audioSampling_audioSampling32k_chosen 4
#   define IS13818AudioMode_audioSampling_audioSampling44k1_chosen 5
#   define IS13818AudioMode_audioSampling_audioSampling48k_chosen 6
} IS13818AudioMode_audioSampling;

typedef struct IS13818AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS13818AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS13818AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS13818AudioMode_audioLayer_audioLayer3_chosen 3
} IS13818AudioMode_audioLayer;

typedef struct IS11172AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS11172AudioMode_multichannelType_singleChannel_chosen 1
#   define IS11172AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS11172AudioMode_multichannelType_twoChannelDual_chosen 3
} IS11172AudioMode_multichannelType;

typedef struct IS11172AudioMode_audioSampling {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioSampling_audioSampling32k_chosen 1
#   define IS11172AudioMode_audioSampling_audioSampling44k1_chosen 2
#   define IS11172AudioMode_audioSampling_audioSampling48k_chosen 3
} IS11172AudioMode_audioSampling;

typedef struct IS11172AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS11172AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS11172AudioMode_audioLayer_audioLayer3_chosen 3
} IS11172AudioMode_audioLayer;

typedef struct AudioMode_g7231 {
    ASN1choice_t choice;
#   define noSilenceSuppressionLowRate_chosen 1
#   define noSilenceSuppressionHighRate_chosen 2
#   define silenceSuppressionLowRate_chosen 3
#   define silenceSuppressionHighRate_chosen 4
} AudioMode_g7231;

typedef struct H263VideoMode_resolution {
    ASN1choice_t choice;
#   define sqcif_chosen 1
#   define H263VideoMode_resolution_qcif_chosen 2
#   define H263VideoMode_resolution_cif_chosen 3
#   define cif4_chosen 4
#   define cif16_chosen 5
} H263VideoMode_resolution;

typedef struct H262VideoMode_profileAndLevel {
    ASN1choice_t choice;
#   define profileAndLevel_SPatML_chosen 1
#   define profileAndLevel_MPatLL_chosen 2
#   define profileAndLevel_MPatML_chosen 3
#   define profileAndLevel_MPatH_14_chosen 4
#   define profileAndLevel_MPatHL_chosen 5
#   define profileAndLevel_SNRatLL_chosen 6
#   define profileAndLevel_SNRatML_chosen 7
#   define profileAndLevel_SpatialatH_14_chosen 8
#   define profileAndLevel_HPatML_chosen 9
#   define profileAndLevel_HPatH_14_chosen 10
#   define profileAndLevel_HPatHL_chosen 11
} H262VideoMode_profileAndLevel;

typedef struct H261VideoMode_resolution {
    ASN1choice_t choice;
#   define H261VideoMode_resolution_qcif_chosen 1
#   define H261VideoMode_resolution_cif_chosen 2
} H261VideoMode_resolution;

typedef struct RequestModeReject_cause {
    ASN1choice_t choice;
#   define modeUnavailable_chosen 1
#   define multipointConstraint_chosen 2
#   define requestDenied_chosen 3
} RequestModeReject_cause;

typedef struct RequestModeAck_response {
    ASN1choice_t choice;
#   define willTransmitMostPreferredMode_chosen 1
#   define willTransmitLessPreferredMode_chosen 2
} RequestModeAck_response;

typedef struct RequestMultiplexEntryRelease_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryRelease_entryNumbers;

typedef struct RequestMultiplexEntryRejectionDescriptions_cause {
    ASN1choice_t choice;
#   define RequestMultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen 1
} RequestMultiplexEntryRejectionDescriptions_cause;

typedef struct RequestMultiplexEntryReject_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryReject_entryNumbers;

typedef struct RequestMultiplexEntryAck_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryAck_entryNumbers;

typedef struct RequestMultiplexEntry_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntry_entryNumbers;

typedef struct MultiplexEntrySendRelease_multiplexTableEntryNumber {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} MultiplexEntrySendRelease_multiplexTableEntryNumber;

typedef struct MultiplexEntryRejectionDescriptions_cause {
    ASN1choice_t choice;
#   define MultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen 1
#   define descriptorTooComplex_chosen 2
} MultiplexEntryRejectionDescriptions_cause;

typedef struct MultiplexEntrySendAck_multiplexTableEntryNumber {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} MultiplexEntrySendAck_multiplexTableEntryNumber;

typedef struct MultiplexElement_repeatCount {
    ASN1choice_t choice;
    union {
#	define MultiplexElement_repeatCount_finite_chosen 1
	ASN1uint16_t finite;
#	define untilClosingFlag_chosen 2
    } u;
} MultiplexElement_repeatCount;

typedef struct MultiplexElement_type {
    ASN1choice_t choice;
    union {
#	define MultiplexElement_type_logicalChannelNumber_chosen 1
	ASN1uint16_t logicalChannelNumber;
#	define subElementList_chosen 2
	PMultiplexElement_type_subElementList subElementList;
    } u;
} MultiplexElement_type;

typedef struct RequestChannelCloseReject_cause {
    ASN1choice_t choice;
#   define RequestChannelCloseReject_cause_unspecified_chosen 1
} RequestChannelCloseReject_cause;

typedef struct RequestChannelClose_reason {
    ASN1choice_t choice;
#   define RequestChannelClose_reason_unknown_chosen 1
#   define normal_chosen 2
#   define RequestChannelClose_reason_reopen_chosen 3
#   define RequestChannelClose_reason_reservationFailure_chosen 4
} RequestChannelClose_reason;

typedef struct CloseLogicalChannel_reason {
    ASN1choice_t choice;
#   define CloseLogicalChannel_reason_unknown_chosen 1
#   define CloseLogicalChannel_reason_reopen_chosen 2
#   define CloseLogicalChannel_reason_reservationFailure_chosen 3
} CloseLogicalChannel_reason;

typedef struct CloseLogicalChannel_source {
    ASN1choice_t choice;
#   define user_chosen 1
#   define lcse_chosen 2
} CloseLogicalChannel_source;

typedef struct OpenLogicalChannelReject_cause {
    ASN1choice_t choice;
#   define OpenLogicalChannelReject_cause_unspecified_chosen 1
#   define unsuitableReverseParameters_chosen 2
#   define dataTypeNotSupported_chosen 3
#   define dataTypeNotAvailable_chosen 4
#   define unknownDataType_chosen 5
#   define dataTypeALCombinationNotSupported_chosen 6
#   define multicastChannelNotAllowed_chosen 7
#   define insufficientBandwidth_chosen 8
#   define separateStackEstablishmentFailed_chosen 9
#   define invalidSessionID_chosen 10
#   define masterSlaveConflict_chosen 11
#   define waitForCommunicationMode_chosen 12
#   define invalidDependentChannel_chosen 13
#   define replacementForRejected_chosen 14
} OpenLogicalChannelReject_cause;

typedef struct MulticastAddress_iP6Address {
    struct MulticastAddress_iP6Address_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } network;
    ASN1uint16_t tsapIdentifier;
} MulticastAddress_iP6Address;

typedef struct MulticastAddress_iPAddress {
    struct MulticastAddress_iPAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
} MulticastAddress_iPAddress;

typedef struct UnicastAddress_iPSourceRouteAddress {
    UnicastAddress_iPSourceRouteAddress_routing routing;
    struct UnicastAddress_iPSourceRouteAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
    PUnicastAddress_iPSourceRouteAddress_route route;
} UnicastAddress_iPSourceRouteAddress;

typedef struct UnicastAddress_iP6Address {
    struct UnicastAddress_iP6Address_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } network;
    ASN1uint16_t tsapIdentifier;
} UnicastAddress_iP6Address;

typedef struct UnicastAddress_iPXAddress {
    struct UnicastAddress_iPXAddress_node_node {
	ASN1uint32_t length;
	ASN1octet_t value[6];
    } node;
    struct UnicastAddress_iPXAddress_netnum_netnum {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } netnum;
    struct UnicastAddress_iPXAddress_tsapIdentifier_tsapIdentifier {
	ASN1uint32_t length;
	ASN1octet_t value[2];
    } tsapIdentifier;
} UnicastAddress_iPXAddress;

typedef struct UnicastAddress_iPAddress {
    struct UnicastAddress_iPAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
} UnicastAddress_iPAddress;

typedef struct V76LogicalChannelParameters_mode {
    ASN1choice_t choice;
    union {
#	define eRM_chosen 1
	V76LogicalChannelParameters_mode_eRM eRM;
#	define uNERM_chosen 2
    } u;
} V76LogicalChannelParameters_mode;

typedef struct V76LogicalChannelParameters_suspendResume {
    ASN1choice_t choice;
#   define noSuspendResume_chosen 1
#   define V76LogicalChannelParameters_suspendResume_suspendResumewAddress_chosen 2
#   define V76LogicalChannelParameters_suspendResume_suspendResumewoAddress_chosen 3
} V76LogicalChannelParameters_suspendResume;

typedef struct H223AnnexCArqParameters_numberOfRetransmissions {
    ASN1choice_t choice;
    union {
#	define H223AnnexCArqParameters_numberOfRetransmissions_finite_chosen 1
	ASN1uint16_t finite;
#	define infinite_chosen 2
    } u;
} H223AnnexCArqParameters_numberOfRetransmissions;

typedef struct H223AL3MParameters_crcLength {
    ASN1choice_t choice;
#   define H223AL3MParameters_crcLength_crc4bit_chosen 1
#   define H223AL3MParameters_crcLength_crc12bit_chosen 2
#   define H223AL3MParameters_crcLength_crc20bit_chosen 3
#   define H223AL3MParameters_crcLength_crc28bit_chosen 4
} H223AL3MParameters_crcLength;

typedef struct H223AL3MParameters_headerFormat {
    ASN1choice_t choice;
#   define H223AL3MParameters_headerFormat_sebch16_7_chosen 1
#   define H223AL3MParameters_headerFormat_golay24_12_chosen 2
} H223AL3MParameters_headerFormat;

typedef struct H223AL2MParameters_headerFEC {
    ASN1choice_t choice;
#   define sebch16_5_chosen 1
#   define H223AL2MParameters_headerFEC_golay24_12_chosen 2
} H223AL2MParameters_headerFEC;

typedef struct H223AL1MParameters_crcLength {
    ASN1choice_t choice;
#   define H223AL1MParameters_crcLength_crc4bit_chosen 1
#   define H223AL1MParameters_crcLength_crc12bit_chosen 2
#   define H223AL1MParameters_crcLength_crc20bit_chosen 3
#   define H223AL1MParameters_crcLength_crc28bit_chosen 4
} H223AL1MParameters_crcLength;

typedef struct H223AL1MParameters_headerFEC {
    ASN1choice_t choice;
#   define H223AL1MParameters_headerFEC_sebch16_7_chosen 1
#   define H223AL1MParameters_headerFEC_golay24_12_chosen 2
} H223AL1MParameters_headerFEC;

typedef struct H223AL1MParameters_transferMode {
    ASN1choice_t choice;
#   define framed_chosen 1
#   define unframed_chosen 2
} H223AL1MParameters_transferMode;

typedef struct Q2931Address_address {
    ASN1choice_t choice;
    union {
#	define internationalNumber_chosen 1
	ASN1char_t internationalNumber[17];
#	define nsapAddress_chosen 2
	struct Q2931Address_address_nsapAddress_nsapAddress {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsapAddress;
    } u;
} Q2931Address_address;

typedef struct NetworkAccessParameters_t120SetupProcedure {
    ASN1choice_t choice;
#   define originateCall_chosen 1
#   define waitForCall_chosen 2
#   define issueQuery_chosen 3
} NetworkAccessParameters_t120SetupProcedure;

typedef struct NetworkAccessParameters_distribution {
    ASN1choice_t choice;
#   define unicast_chosen 1
#   define multicast_chosen 2
} NetworkAccessParameters_distribution;

typedef struct T84Profile_t84Restricted {
    ASN1bool_t qcif;
    ASN1bool_t cif;
    ASN1bool_t ccir601Seq;
    ASN1bool_t ccir601Prog;
    ASN1bool_t hdtvSeq;
    ASN1bool_t hdtvProg;
    ASN1bool_t g3FacsMH200x100;
    ASN1bool_t g3FacsMH200x200;
    ASN1bool_t g4FacsMMR200x100;
    ASN1bool_t g4FacsMMR200x200;
    ASN1bool_t jbig200x200Seq;
    ASN1bool_t jbig200x200Prog;
    ASN1bool_t jbig300x300Seq;
    ASN1bool_t jbig300x300Prog;
    ASN1bool_t digPhotoLow;
    ASN1bool_t digPhotoMedSeq;
    ASN1bool_t digPhotoMedProg;
    ASN1bool_t digPhotoHighSeq;
    ASN1bool_t digPhotoHighProg;
} T84Profile_t84Restricted;

typedef struct G7231AnnexCCapability_g723AnnexCAudioMode {
    ASN1uint16_t highRateMode0;
    ASN1uint16_t highRateMode1;
    ASN1uint16_t lowRateMode0;
    ASN1uint16_t lowRateMode1;
    ASN1uint16_t sidMode0;
    ASN1uint16_t sidMode1;
} G7231AnnexCCapability_g723AnnexCAudioMode;

typedef struct AudioCapability_g7231 {
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
} AudioCapability_g7231;

typedef struct CustomPictureFormat_pixelAspectInformation {
    ASN1choice_t choice;
    union {
#	define anyPixelAspectRatio_chosen 1
	ASN1bool_t anyPixelAspectRatio;
#	define pixelAspectCode_chosen 2
	CustomPictureFormat_pixelAspectInformation_pixelAspectCode pixelAspectCode;
#	define extendedPAR_chosen 3
	CustomPictureFormat_pixelAspectInformation_extendedPAR extendedPAR;
    } u;
} CustomPictureFormat_pixelAspectInformation;

typedef struct CustomPictureFormat_mPI {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define standardMPI_present 0x80
    ASN1uint16_t standardMPI;
#   define customPCF_present 0x40
    CustomPictureFormat_mPI_customPCF customPCF;
} CustomPictureFormat_mPI;

typedef struct RefPictureSelection_videoBackChannelSend {
    ASN1choice_t choice;
#   define RefPictureSelection_videoBackChannelSend_none_chosen 1
#   define ackMessageOnly_chosen 2
#   define nackMessageOnly_chosen 3
#   define ackOrNackMessageOnly_chosen 4
#   define ackAndNackMessage_chosen 5
} RefPictureSelection_videoBackChannelSend;

typedef struct RefPictureSelection_additionalPictureMemory {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define sqcifAdditionalPictureMemory_present 0x80
    ASN1uint16_t sqcifAdditionalPictureMemory;
#   define qcifAdditionalPictureMemory_present 0x40
    ASN1uint16_t qcifAdditionalPictureMemory;
#   define cifAdditionalPictureMemory_present 0x20
    ASN1uint16_t cifAdditionalPictureMemory;
#   define cif4AdditionalPictureMemory_present 0x10
    ASN1uint16_t cif4AdditionalPictureMemory;
#   define cif16AdditionalPictureMemory_present 0x8
    ASN1uint16_t cif16AdditionalPictureMemory;
#   define bigCpfAdditionalPictureMemory_present 0x4
    ASN1uint16_t bigCpfAdditionalPictureMemory;
} RefPictureSelection_additionalPictureMemory;

typedef struct RTPH263VideoRedundancyFrameMapping_frameSequence {
    ASN1uint32_t count;
    RTPH263VideoRedundancyFrameMapping_frameSequence_Seq value[256];
} RTPH263VideoRedundancyFrameMapping_frameSequence;

typedef struct RTPH263VideoRedundancyEncoding_containedThreads {
    ASN1uint32_t count;
    RTPH263VideoRedundancyEncoding_containedThreads_Seq value[256];
} RTPH263VideoRedundancyEncoding_containedThreads;

typedef struct RTPH263VideoRedundancyEncoding_frameToThreadMapping {
    ASN1choice_t choice;
    union {
#	define roundrobin_chosen 1
#	define custom_chosen 2
	PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom custom;
    } u;
} RTPH263VideoRedundancyEncoding_frameToThreadMapping;

typedef struct RedundancyEncodingCapability_secondaryEncoding {
    PRedundancyEncodingCapability_secondaryEncoding next;
    CapabilityTableEntryNumber value;
} RedundancyEncodingCapability_secondaryEncoding_Element;

typedef struct H2250Capability_mcCapability {
    ASN1bool_t centralizedConferenceMC;
    ASN1bool_t decentralizedConferenceMC;
} H2250Capability_mcCapability;

typedef struct H223Capability_mobileOperationTransmitCapability {
    ASN1bool_t modeChangeCapability;
    ASN1bool_t h223AnnexA;
    ASN1bool_t h223AnnexADoubleFlag;
    ASN1bool_t h223AnnexB;
    ASN1bool_t h223AnnexBwithHeader;
} H223Capability_mobileOperationTransmitCapability;

typedef struct H223Capability_h223MultiplexTableCapability {
    ASN1choice_t choice;
    union {
#	define basic_chosen 1
#	define enhanced_chosen 2
	H223Capability_h223MultiplexTableCapability_enhanced enhanced;
    } u;
} H223Capability_h223MultiplexTableCapability;

typedef struct VCCapability_availableBitRates {
    VCCapability_availableBitRates_type type;
} VCCapability_availableBitRates;

typedef struct VCCapability_aal5 {
    ASN1uint16_t forwardMaximumSDUSize;
    ASN1uint16_t backwardMaximumSDUSize;
} VCCapability_aal5;

typedef struct VCCapability_aal1 {
    ASN1bool_t nullClockRecovery;
    ASN1bool_t srtsClockRecovery;
    ASN1bool_t adaptiveClockRecovery;
    ASN1bool_t nullErrorCorrection;
    ASN1bool_t longInterleaver;
    ASN1bool_t shortInterleaver;
    ASN1bool_t errorCorrectionOnly;
    ASN1bool_t structuredDataTransfer;
    ASN1bool_t partiallyFilledCells;
} VCCapability_aal1;

typedef struct Capability_h233EncryptionReceiveCapability {
    ASN1uint16_t h233IVResponseTime;
} Capability_h233EncryptionReceiveCapability;

typedef struct TerminalCapabilitySetReject_cause {
    ASN1choice_t choice;
    union {
#	define TerminalCapabilitySetReject_cause_unspecified_chosen 1
#	define undefinedTableEntryUsed_chosen 2
#	define descriptorCapacityExceeded_chosen 3
#	define tableEntryCapacityExceeded_chosen 4
	TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded tableEntryCapacityExceeded;
    } u;
} TerminalCapabilitySetReject_cause;

typedef struct MasterSlaveDeterminationReject_cause {
    ASN1choice_t choice;
#   define identicalNumbers_chosen 1
} MasterSlaveDeterminationReject_cause;

typedef struct MasterSlaveDeterminationAck_decision {
    ASN1choice_t choice;
#   define master_chosen 1
#   define slave_chosen 2
} MasterSlaveDeterminationAck_decision;

typedef struct NonStandardIdentifier_h221NonStandard {
    ASN1uint16_t t35CountryCode;
    ASN1uint16_t t35Extension;
    ASN1uint16_t manufacturerCode;
} NonStandardIdentifier_h221NonStandard;

typedef struct NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221NonStandard_chosen 2
	NonStandardIdentifier_h221NonStandard h221NonStandard;
    } u;
} NonStandardIdentifier;

typedef struct MasterSlaveDetermination {
    ASN1uint16_t terminalType;
    ASN1uint32_t statusDeterminationNumber;
} MasterSlaveDetermination;

typedef struct MasterSlaveDeterminationAck {
    MasterSlaveDeterminationAck_decision decision;
} MasterSlaveDeterminationAck;

typedef struct MasterSlaveDeterminationReject {
    MasterSlaveDeterminationReject_cause cause;
} MasterSlaveDeterminationReject;

typedef struct MasterSlaveDeterminationRelease {
    char placeholder;
} MasterSlaveDeterminationRelease;

typedef struct CapabilityDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CapabilityDescriptorNumber capabilityDescriptorNumber;
#   define simultaneousCapabilities_present 0x80
    PCapabilityDescriptor_simultaneousCapabilities simultaneousCapabilities;
} CapabilityDescriptor;

typedef struct AlternativeCapabilitySet {
    ASN1uint32_t count;
    CapabilityTableEntryNumber value[256];
} AlternativeCapabilitySet;

typedef struct TerminalCapabilitySetAck {
    SequenceNumber sequenceNumber;
} TerminalCapabilitySetAck;

typedef struct TerminalCapabilitySetReject {
    SequenceNumber sequenceNumber;
    TerminalCapabilitySetReject_cause cause;
} TerminalCapabilitySetReject;

typedef struct TerminalCapabilitySetRelease {
    char placeholder;
} TerminalCapabilitySetRelease;

typedef struct H222Capability {
    ASN1uint16_t numberOfVCs;
    PH222Capability_vcCapability vcCapability;
} H222Capability;

typedef struct VCCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define aal1_present 0x80
    VCCapability_aal1 aal1;
#   define aal5_present 0x40
    VCCapability_aal5 aal5;
    ASN1bool_t transportStream;
    ASN1bool_t programStream;
    VCCapability_availableBitRates availableBitRates;
} VCCapability;

typedef struct H223AnnexCCapability {
    ASN1bool_t videoWithAL1M;
    ASN1bool_t videoWithAL2M;
    ASN1bool_t videoWithAL3M;
    ASN1bool_t audioWithAL1M;
    ASN1bool_t audioWithAL2M;
    ASN1bool_t audioWithAL3M;
    ASN1bool_t dataWithAL1M;
    ASN1bool_t dataWithAL2M;
    ASN1bool_t dataWithAL3M;
    ASN1bool_t alpduInterleaving;
    ASN1uint16_t maximumAL1MPDUSize;
    ASN1uint16_t maximumAL2MSDUSize;
    ASN1uint16_t maximumAL3MSDUSize;
} H223AnnexCCapability;

typedef struct V75Capability {
    ASN1bool_t audioHeader;
} V75Capability;

typedef struct QOSMode {
    ASN1choice_t choice;
#   define guaranteedQOS_chosen 1
#   define controlledLoad_chosen 2
} QOSMode;

typedef struct ATMParameters {
    ASN1uint16_t maxNTUSize;
    ASN1bool_t atmUBR;
    ASN1bool_t atmrtVBR;
    ASN1bool_t atmnrtVBR;
    ASN1bool_t atmABR;
    ASN1bool_t atmCBR;
} ATMParameters;

typedef struct MediaTransportType {
    ASN1choice_t choice;
#   define ip_UDP_chosen 1
#   define ip_TCP_chosen 2
#   define atm_AAL5_UNIDIR_chosen 3
#   define atm_AAL5_BIDIR_chosen 4
} MediaTransportType;

typedef struct MediaChannelCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define mediaTransport_present 0x80
    MediaTransportType mediaTransport;
} MediaChannelCapability;

typedef struct RTPH263VideoRedundancyEncoding {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t numberOfThreads;
    ASN1uint16_t framesBetweenSyncPoints;
    RTPH263VideoRedundancyEncoding_frameToThreadMapping frameToThreadMapping;
#   define containedThreads_present 0x80
    RTPH263VideoRedundancyEncoding_containedThreads containedThreads;
} RTPH263VideoRedundancyEncoding;

typedef struct RTPH263VideoRedundancyFrameMapping {
    ASN1uint16_t threadNumber;
    RTPH263VideoRedundancyFrameMapping_frameSequence frameSequence;
} RTPH263VideoRedundancyFrameMapping;

typedef struct MultipointCapability {
    ASN1bool_t multicastCapability;
    ASN1bool_t multiUniCastConference;
    PMultipointCapability_mediaDistributionCapability mediaDistributionCapability;
} MultipointCapability;

typedef struct MediaDistributionCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t centralizedControl;
    ASN1bool_t distributedControl;
    ASN1bool_t centralizedAudio;
    ASN1bool_t distributedAudio;
    ASN1bool_t centralizedVideo;
    ASN1bool_t distributedVideo;
#   define centralizedData_present 0x80
    PMediaDistributionCapability_centralizedData centralizedData;
#   define distributedData_present 0x40
    PMediaDistributionCapability_distributedData distributedData;
} MediaDistributionCapability;

typedef struct H261VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H261VideoCapability_qcifMPI_present 0x80
    ASN1uint16_t qcifMPI;
#   define H261VideoCapability_cifMPI_present 0x40
    ASN1uint16_t cifMPI;
    ASN1bool_t temporalSpatialTradeOffCapability;
    ASN1uint16_t maxBitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoCapability;

typedef struct H262VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t profileAndLevel_SPatML;
    ASN1bool_t profileAndLevel_MPatLL;
    ASN1bool_t profileAndLevel_MPatML;
    ASN1bool_t profileAndLevel_MPatH_14;
    ASN1bool_t profileAndLevel_MPatHL;
    ASN1bool_t profileAndLevel_SNRatLL;
    ASN1bool_t profileAndLevel_SNRatML;
    ASN1bool_t profileAndLevel_SpatialatH_14;
    ASN1bool_t profileAndLevel_HPatML;
    ASN1bool_t profileAndLevel_HPatH_14;
    ASN1bool_t profileAndLevel_HPatHL;
#   define H262VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoCapability_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoCapability;

typedef struct EnhancementLayerInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t baseBitRateConstrained;
#   define snrEnhancement_present 0x80
    PEnhancementLayerInfo_snrEnhancement snrEnhancement;
#   define spatialEnhancement_present 0x40
    PEnhancementLayerInfo_spatialEnhancement spatialEnhancement;
#   define bPictureEnhancement_present 0x20
    PEnhancementLayerInfo_bPictureEnhancement bPictureEnhancement;
} EnhancementLayerInfo;

typedef struct TransparencyParameters {
    ASN1uint16_t presentationOrder;
    ASN1int32_t offset_x;
    ASN1int32_t offset_y;
    ASN1uint16_t scale_x;
    ASN1uint16_t scale_y;
} TransparencyParameters;

typedef struct RefPictureSelection {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define additionalPictureMemory_present 0x80
    RefPictureSelection_additionalPictureMemory additionalPictureMemory;
    ASN1bool_t videoMux;
    RefPictureSelection_videoBackChannelSend videoBackChannelSend;
} RefPictureSelection;

typedef struct CustomPictureClockFrequency {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t clockConversionCode;
    ASN1uint16_t clockDivisor;
#   define CustomPictureClockFrequency_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define CustomPictureClockFrequency_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define CustomPictureClockFrequency_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define CustomPictureClockFrequency_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define CustomPictureClockFrequency_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
} CustomPictureClockFrequency;

typedef struct CustomPictureFormat {
    ASN1uint16_t maxCustomPictureWidth;
    ASN1uint16_t maxCustomPictureHeight;
    ASN1uint16_t minCustomPictureWidth;
    ASN1uint16_t minCustomPictureHeight;
    CustomPictureFormat_mPI mPI;
    CustomPictureFormat_pixelAspectInformation pixelAspectInformation;
} CustomPictureFormat;

typedef struct H263ModeComboFlags {
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
    ASN1bool_t advancedIntraCodingMode;
    ASN1bool_t deblockingFilterMode;
    ASN1bool_t unlimitedMotionVectors;
    ASN1bool_t slicesInOrder_NonRect;
    ASN1bool_t slicesInOrder_Rect;
    ASN1bool_t slicesNoOrder_NonRect;
    ASN1bool_t slicesNoOrder_Rect;
    ASN1bool_t improvedPBFramesMode;
    ASN1bool_t referencePicSelect;
    ASN1bool_t dynamicPictureResizingByFour;
    ASN1bool_t dynamicPictureResizingSixteenthPel;
    ASN1bool_t dynamicWarpingHalfPel;
    ASN1bool_t dynamicWarpingSixteenthPel;
    ASN1bool_t reducedResolutionUpdate;
    ASN1bool_t independentSegmentDecoding;
    ASN1bool_t alternateInterVLCMode;
    ASN1bool_t modifiedQuantizationMode;
} H263ModeComboFlags;

typedef struct IS11172VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoCapability_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoCapability;

typedef struct G7231AnnexCCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
#   define g723AnnexCAudioMode_present 0x80
    G7231AnnexCCapability_g723AnnexCAudioMode g723AnnexCAudioMode;
} G7231AnnexCCapability;

typedef struct IS11172AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1uint16_t bitRate;
} IS11172AudioCapability;

typedef struct IS13818AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling16k;
    ASN1bool_t audioSampling22k05;
    ASN1bool_t audioSampling24k;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1bool_t threeChannels2_1;
    ASN1bool_t threeChannels3_0;
    ASN1bool_t fourChannels2_0_2_0;
    ASN1bool_t fourChannels2_2;
    ASN1bool_t fourChannels3_1;
    ASN1bool_t fiveChannels3_0_2_0;
    ASN1bool_t fiveChannels3_2;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioCapability;

typedef struct GSMAudioCapability {
    ASN1uint16_t audioUnitSize;
    ASN1bool_t comfortNoise;
    ASN1bool_t scrambled;
} GSMAudioCapability;

typedef struct V42bis {
    ASN1uint32_t numberOfCodewords;
    ASN1uint16_t maximumStringLength;
} V42bis;

typedef struct T84Profile {
    ASN1choice_t choice;
    union {
#	define t84Unrestricted_chosen 1
#	define t84Restricted_chosen 2
	T84Profile_t84Restricted t84Restricted;
    } u;
} T84Profile;

typedef struct ConferenceCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define ConferenceCapability_nonStandardData_present 0x80
    PConferenceCapability_nonStandardData nonStandardData;
    ASN1bool_t chairControlCapability;
#   define videoIndicateMixingCapability_present 0x8000
    ASN1bool_t videoIndicateMixingCapability;
} ConferenceCapability;

typedef struct Q2931Address {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Q2931Address_address address;
#   define subaddress_present 0x80
    struct Q2931Address_subaddress_subaddress {
	ASN1uint32_t length;
	ASN1octet_t value[20];
    } subaddress;
} Q2931Address;

typedef struct V75Parameters {
    ASN1bool_t audioHeaderPresent;
} V75Parameters;

typedef struct H222LogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t resourceID;
    ASN1uint16_t subChannelID;
#   define pcr_pid_present 0x80
    ASN1uint16_t pcr_pid;
#   define programDescriptors_present 0x40
    ASN1octetstring_t programDescriptors;
#   define streamDescriptors_present 0x20
    ASN1octetstring_t streamDescriptors;
} H222LogicalChannelParameters;

typedef struct H223AL2MParameters {
    H223AL2MParameters_headerFEC headerFEC;
    ASN1bool_t alpduInterleaving;
} H223AL2MParameters;

typedef struct H223AnnexCArqParameters {
    H223AnnexCArqParameters_numberOfRetransmissions numberOfRetransmissions;
    ASN1uint32_t sendBufferSize;
} H223AnnexCArqParameters;

typedef struct CRCLength {
    ASN1choice_t choice;
#   define crc8bit_chosen 1
#   define crc16bit_chosen 2
#   define crc32bit_chosen 3
} CRCLength;

typedef struct EscrowData {
    ASN1objectidentifier_t escrowID;
    ASN1bitstring_t escrowValue;
} EscrowData;

typedef struct OpenLogicalChannelReject {
    LogicalChannelNumber forwardLogicalChannelNumber;
    OpenLogicalChannelReject_cause cause;
} OpenLogicalChannelReject;

typedef struct OpenLogicalChannelConfirm {
    LogicalChannelNumber forwardLogicalChannelNumber;
} OpenLogicalChannelConfirm;

typedef struct CloseLogicalChannel {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
    CloseLogicalChannel_source source;
#   define CloseLogicalChannel_reason_present 0x80
    CloseLogicalChannel_reason reason;
} CloseLogicalChannel;

typedef struct CloseLogicalChannelAck {
    LogicalChannelNumber forwardLogicalChannelNumber;
} CloseLogicalChannelAck;

typedef struct RequestChannelCloseAck {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelCloseAck;

typedef struct RequestChannelCloseReject {
    LogicalChannelNumber forwardLogicalChannelNumber;
    RequestChannelCloseReject_cause cause;
} RequestChannelCloseReject;

typedef struct RequestChannelCloseRelease {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelCloseRelease;

typedef struct MultiplexEntrySend {
    SequenceNumber sequenceNumber;
    PMultiplexEntrySend_multiplexEntryDescriptors multiplexEntryDescriptors;
} MultiplexEntrySend;

typedef struct MultiplexElement {
    MultiplexElement_type type;
    MultiplexElement_repeatCount repeatCount;
} MultiplexElement;

typedef struct MultiplexEntrySendAck {
    SequenceNumber sequenceNumber;
    MultiplexEntrySendAck_multiplexTableEntryNumber multiplexTableEntryNumber;
} MultiplexEntrySendAck;

typedef struct MultiplexEntryRejectionDescriptions {
    MultiplexTableEntryNumber multiplexTableEntryNumber;
    MultiplexEntryRejectionDescriptions_cause cause;
} MultiplexEntryRejectionDescriptions;

typedef struct MultiplexEntrySendRelease {
    MultiplexEntrySendRelease_multiplexTableEntryNumber multiplexTableEntryNumber;
} MultiplexEntrySendRelease;

typedef struct RequestMultiplexEntry {
    RequestMultiplexEntry_entryNumbers entryNumbers;
} RequestMultiplexEntry;

typedef struct RequestMultiplexEntryAck {
    RequestMultiplexEntryAck_entryNumbers entryNumbers;
} RequestMultiplexEntryAck;

typedef struct RequestMultiplexEntryRejectionDescriptions {
    MultiplexTableEntryNumber multiplexTableEntryNumber;
    RequestMultiplexEntryRejectionDescriptions_cause cause;
} RequestMultiplexEntryRejectionDescriptions;

typedef struct RequestMultiplexEntryRelease {
    RequestMultiplexEntryRelease_entryNumbers entryNumbers;
} RequestMultiplexEntryRelease;

typedef struct RequestMode {
    SequenceNumber sequenceNumber;
    PRequestMode_requestedModes requestedModes;
} RequestMode;

typedef struct RequestModeAck {
    SequenceNumber sequenceNumber;
    RequestModeAck_response response;
} RequestModeAck;

typedef struct RequestModeReject {
    SequenceNumber sequenceNumber;
    RequestModeReject_cause cause;
} RequestModeReject;

typedef struct RequestModeRelease {
    char placeholder;
} RequestModeRelease;

typedef struct V76ModeParameters {
    ASN1choice_t choice;
#   define V76ModeParameters_suspendResumewAddress_chosen 1
#   define V76ModeParameters_suspendResumewoAddress_chosen 2
} V76ModeParameters;

typedef struct H261VideoMode {
    H261VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoMode;

typedef struct H262VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H262VideoMode_profileAndLevel profileAndLevel;
#   define H262VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoMode_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoMode;

typedef struct IS11172VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoMode_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoMode;

typedef struct IS11172AudioMode {
    IS11172AudioMode_audioLayer audioLayer;
    IS11172AudioMode_audioSampling audioSampling;
    IS11172AudioMode_multichannelType multichannelType;
    ASN1uint16_t bitRate;
} IS11172AudioMode;

typedef struct IS13818AudioMode {
    IS13818AudioMode_audioLayer audioLayer;
    IS13818AudioMode_audioSampling audioSampling;
    IS13818AudioMode_multichannelType multichannelType;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioMode;

typedef struct G7231AnnexCMode {
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
    G7231AnnexCMode_g723AnnexCAudioMode g723AnnexCAudioMode;
} G7231AnnexCMode;

typedef struct RoundTripDelayRequest {
    SequenceNumber sequenceNumber;
} RoundTripDelayRequest;

typedef struct RoundTripDelayResponse {
    SequenceNumber sequenceNumber;
} RoundTripDelayResponse;

typedef struct MaintenanceLoopRequest {
    MaintenanceLoopRequest_type type;
} MaintenanceLoopRequest;

typedef struct MaintenanceLoopAck {
    MaintenanceLoopAck_type type;
} MaintenanceLoopAck;

typedef struct MaintenanceLoopReject {
    MaintenanceLoopReject_type type;
    MaintenanceLoopReject_cause cause;
} MaintenanceLoopReject;

typedef struct MaintenanceLoopOffCommand {
    char placeholder;
} MaintenanceLoopOffCommand;

typedef struct CommunicationModeCommand {
    PCommunicationModeCommand_communicationModeTable communicationModeTable;
} CommunicationModeCommand;

typedef struct CommunicationModeRequest {
    char placeholder;
} CommunicationModeRequest;

typedef struct CommunicationModeResponse {
    ASN1choice_t choice;
    union {
#	define communicationModeTable_chosen 1
	PCommunicationModeResponse_communicationModeTable communicationModeTable;
    } u;
} CommunicationModeResponse;

typedef struct Criteria {
    ASN1objectidentifier_t field;
    struct Criteria_value_value {
	ASN1uint32_t length;
	ASN1octet_t value[65535];
    } value;
} Criteria;

typedef struct TerminalLabel {
    McuNumber mcuNumber;
    TerminalNumber terminalNumber;
} TerminalLabel;

typedef struct RequestAllTerminalIDsResponse {
    PRequestAllTerminalIDsResponse_terminalInformation terminalInformation;
} RequestAllTerminalIDsResponse;

typedef struct TerminalInformation {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} TerminalInformation;

typedef struct RemoteMCRequest {
    ASN1choice_t choice;
#   define masterActivate_chosen 1
#   define slaveActivate_chosen 2
#   define deActivate_chosen 3
} RemoteMCRequest;

typedef struct RemoteMCResponse {
    ASN1choice_t choice;
    union {
#	define accept_chosen 1
#	define reject_chosen 2
	RemoteMCResponse_reject reject;
    } u;
} RemoteMCResponse;

typedef struct SendTerminalCapabilitySet {
    ASN1choice_t choice;
    union {
#	define specificRequest_chosen 1
	SendTerminalCapabilitySet_specificRequest specificRequest;
#	define genericRequest_chosen 2
    } u;
} SendTerminalCapabilitySet;

typedef struct FlowControlCommand {
    FlowControlCommand_scope scope;
    FlowControlCommand_restriction restriction;
} FlowControlCommand;

typedef struct SubstituteConferenceIDCommand {
    struct SubstituteConferenceIDCommand_conferenceIdentifier_conferenceIdentifier {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } conferenceIdentifier;
} SubstituteConferenceIDCommand;

typedef struct KeyProtectionMethod {
    ASN1bool_t secureChannel;
    ASN1bool_t sharedSecret;
    ASN1bool_t certProtectedKey;
} KeyProtectionMethod;

typedef struct EncryptionUpdateRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define keyProtectionMethod_present 0x80
    KeyProtectionMethod keyProtectionMethod;
} EncryptionUpdateRequest;

typedef struct H223MultiplexReconfiguration {
    ASN1choice_t choice;
    union {
#	define h223ModeChange_chosen 1
	H223MultiplexReconfiguration_h223ModeChange h223ModeChange;
#	define h223AnnexADoubleFlag_chosen 2
	H223MultiplexReconfiguration_h223AnnexADoubleFlag h223AnnexADoubleFlag;
    } u;
} H223MultiplexReconfiguration;

typedef struct FunctionNotSupported {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    FunctionNotSupported_cause cause;
#   define returnedFunction_present 0x80
    ASN1octetstring_t returnedFunction;
} FunctionNotSupported;

typedef struct TerminalYouAreSeeingInSubPictureNumber {
    TerminalNumber terminalNumber;
    ASN1uint16_t subPictureNumber;
} TerminalYouAreSeeingInSubPictureNumber;

typedef struct VideoIndicateCompose {
    ASN1uint16_t compositionNumber;
} VideoIndicateCompose;

typedef struct ConferenceIndication {
    ASN1choice_t choice;
    union {
#	define sbeNumber_chosen 1
	ASN1uint16_t sbeNumber;
#	define terminalNumberAssign_chosen 2
	TerminalLabel terminalNumberAssign;
#	define terminalJoinedConference_chosen 3
	TerminalLabel terminalJoinedConference;
#	define terminalLeftConference_chosen 4
	TerminalLabel terminalLeftConference;
#	define seenByAtLeastOneOther_chosen 5
#	define cancelSeenByAtLeastOneOther_chosen 6
#	define seenByAll_chosen 7
#	define cancelSeenByAll_chosen 8
#	define terminalYouAreSeeing_chosen 9
	TerminalLabel terminalYouAreSeeing;
#	define requestForFloor_chosen 10
#	define withdrawChairToken_chosen 11
#	define floorRequested_chosen 12
	TerminalLabel floorRequested;
#	define terminalYouAreSeeingInSubPictureNumber_chosen 13
	TerminalYouAreSeeingInSubPictureNumber terminalYouAreSeeingInSubPictureNumber;
#	define videoIndicateCompose_chosen 14
	VideoIndicateCompose videoIndicateCompose;
    } u;
} ConferenceIndication;

typedef struct JitterIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    JitterIndication_scope scope;
    ASN1uint16_t estimatedReceivedJitterMantissa;
    ASN1uint16_t estimatedReceivedJitterExponent;
#   define skippedFrameCount_present 0x80
    ASN1uint16_t skippedFrameCount;
#   define additionalDecoderBuffer_present 0x40
    ASN1uint32_t additionalDecoderBuffer;
} JitterIndication;

typedef struct H223SkewIndication {
    LogicalChannelNumber logicalChannelNumber1;
    LogicalChannelNumber logicalChannelNumber2;
    ASN1uint16_t skew;
} H223SkewIndication;

typedef struct H2250MaximumSkewIndication {
    LogicalChannelNumber logicalChannelNumber1;
    LogicalChannelNumber logicalChannelNumber2;
    ASN1uint16_t maximumSkew;
} H2250MaximumSkewIndication;

typedef struct VendorIdentification {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    NonStandardIdentifier vendor;
#   define productNumber_present 0x80
    struct VendorIdentification_productNumber_productNumber {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } productNumber;
#   define versionNumber_present 0x40
    struct VendorIdentification_versionNumber_versionNumber {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } versionNumber;
} VendorIdentification;

typedef struct NewATMVCIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t resourceID;
    ASN1uint16_t bitRate;
    ASN1bool_t bitRateLockedToPCRClock;
    ASN1bool_t bitRateLockedToNetworkClock;
    NewATMVCIndication_aal aal;
    NewATMVCIndication_multiplex multiplex;
#   define reverseParameters_present 0x80
    NewATMVCIndication_reverseParameters reverseParameters;
} NewATMVCIndication;

typedef struct RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom {
    PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom next;
    RTPH263VideoRedundancyFrameMapping value;
} RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_Element;

typedef struct MultiplexElement_type_subElementList {
    ASN1uint32_t count;
    MultiplexElement value[255];
} MultiplexElement_type_subElementList;

typedef struct RequestAllTerminalIDsResponse_terminalInformation {
    PRequestAllTerminalIDsResponse_terminalInformation next;
    TerminalInformation value;
} RequestAllTerminalIDsResponse_terminalInformation_Element;

typedef struct ConferenceResponse_terminalCertificateResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ConferenceResponse_terminalCertificateResponse_terminalLabel_present 0x80
    TerminalLabel terminalLabel;
#   define certificateResponse_present 0x40
    struct ConferenceResponse_terminalCertificateResponse_certificateResponse_certificateResponse {
	ASN1uint32_t length;
	ASN1octet_t value[65535];
    } certificateResponse;
} ConferenceResponse_terminalCertificateResponse;

typedef struct ConferenceResponse_chairTokenOwnerResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_chairTokenOwnerResponse;

typedef struct ConferenceResponse_terminalListResponse {
    ASN1uint32_t count;
    TerminalLabel value[256];
} ConferenceResponse_terminalListResponse;

typedef struct ConferenceResponse_passwordResponse {
    TerminalLabel terminalLabel;
    Password password;
} ConferenceResponse_passwordResponse;

typedef struct ConferenceResponse_conferenceIDResponse {
    TerminalLabel terminalLabel;
    ConferenceID conferenceID;
} ConferenceResponse_conferenceIDResponse;

typedef struct ConferenceResponse_terminalIDResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_terminalIDResponse;

typedef struct ConferenceResponse_mCTerminalIDResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_mCTerminalIDResponse;

typedef struct ConferenceRequest_requestTerminalCertificate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ConferenceRequest_requestTerminalCertificate_terminalLabel_present 0x80
    TerminalLabel terminalLabel;
#   define certSelectionCriteria_present 0x40
    PCertSelectionCriteria certSelectionCriteria;
#   define sRandom_present 0x20
    ASN1uint32_t sRandom;
} ConferenceRequest_requestTerminalCertificate;

typedef struct RequestMultiplexEntryReject_rejectionDescriptions {
    ASN1uint32_t count;
    RequestMultiplexEntryRejectionDescriptions value[15];
} RequestMultiplexEntryReject_rejectionDescriptions;

typedef struct MultiplexEntrySendReject_rejectionDescriptions {
    ASN1uint32_t count;
    MultiplexEntryRejectionDescriptions value[15];
} MultiplexEntrySendReject_rejectionDescriptions;

typedef struct MultiplexEntryDescriptor_elementList {
    ASN1uint32_t count;
    MultiplexElement value[256];
} MultiplexEntryDescriptor_elementList;

typedef struct EncryptionSync_escrowentry {
    PEncryptionSync_escrowentry next;
    EscrowData value;
} EncryptionSync_escrowentry_Element;

typedef struct H223AL3MParameters_arqType {
    ASN1choice_t choice;
    union {
#	define H223AL3MParameters_arqType_noArq_chosen 1
#	define H223AL3MParameters_arqType_typeIArq_chosen 2
	H223AnnexCArqParameters typeIArq;
#	define H223AL3MParameters_arqType_typeIIArq_chosen 3
	H223AnnexCArqParameters typeIIArq;
    } u;
} H223AL3MParameters_arqType;

typedef struct H223AL1MParameters_arqType {
    ASN1choice_t choice;
    union {
#	define H223AL1MParameters_arqType_noArq_chosen 1
#	define H223AL1MParameters_arqType_typeIArq_chosen 2
	H223AnnexCArqParameters typeIArq;
#	define H223AL1MParameters_arqType_typeIIArq_chosen 3
	H223AnnexCArqParameters typeIIArq;
    } u;
} H223AL1MParameters_arqType;

typedef struct H263VideoModeCombos_h263VideoCoupledModes {
    ASN1uint32_t count;
    H263ModeComboFlags value[16];
} H263VideoModeCombos_h263VideoCoupledModes;

typedef struct H263Options_customPictureFormat {
    PH263Options_customPictureFormat next;
    CustomPictureFormat value;
} H263Options_customPictureFormat_Element;

typedef struct H263Options_customPictureClockFrequency {
    PH263Options_customPictureClockFrequency next;
    CustomPictureClockFrequency value;
} H263Options_customPictureClockFrequency_Element;

typedef struct MultipointCapability_mediaDistributionCapability {
    PMultipointCapability_mediaDistributionCapability next;
    MediaDistributionCapability value;
} MultipointCapability_mediaDistributionCapability_Element;

typedef struct TransportCapability_mediaChannelCapabilities {
    ASN1uint32_t count;
    MediaChannelCapability value[256];
} TransportCapability_mediaChannelCapabilities;

typedef struct H222Capability_vcCapability {
    PH222Capability_vcCapability next;
    VCCapability value;
} H222Capability_vcCapability_Element;

typedef struct CapabilityDescriptor_simultaneousCapabilities {
    PCapabilityDescriptor_simultaneousCapabilities next;
    AlternativeCapabilitySet value;
} CapabilityDescriptor_simultaneousCapabilities_Element;

typedef struct TerminalCapabilitySet_capabilityDescriptors {
    ASN1uint32_t count;
    CapabilityDescriptor value[256];
} TerminalCapabilitySet_capabilityDescriptors;

typedef struct NonStandardParameter {
    NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} NonStandardParameter;

typedef struct H223Capability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t transportWithI_frames;
    ASN1bool_t videoWithAL1;
    ASN1bool_t videoWithAL2;
    ASN1bool_t videoWithAL3;
    ASN1bool_t audioWithAL1;
    ASN1bool_t audioWithAL2;
    ASN1bool_t audioWithAL3;
    ASN1bool_t dataWithAL1;
    ASN1bool_t dataWithAL2;
    ASN1bool_t dataWithAL3;
    ASN1uint16_t maximumAl2SDUSize;
    ASN1uint16_t maximumAl3SDUSize;
    ASN1uint16_t maximumDelayJitter;
    H223Capability_h223MultiplexTableCapability h223MultiplexTableCapability;
#   define maxMUXPDUSizeCapability_present 0x80
    ASN1bool_t maxMUXPDUSizeCapability;
#   define nsrpSupport_present 0x40
    ASN1bool_t nsrpSupport;
#   define mobileOperationTransmitCapability_present 0x20
    H223Capability_mobileOperationTransmitCapability mobileOperationTransmitCapability;
#   define h223AnnexCCapability_present 0x10
    H223AnnexCCapability h223AnnexCCapability;
} H223Capability;

typedef struct V76Capability {
    ASN1bool_t suspendResumeCapabilitywAddress;
    ASN1bool_t suspendResumeCapabilitywoAddress;
    ASN1bool_t rejCapability;
    ASN1bool_t sREJCapability;
    ASN1bool_t mREJCapability;
    ASN1bool_t crc8bitCapability;
    ASN1bool_t crc16bitCapability;
    ASN1bool_t crc32bitCapability;
    ASN1bool_t uihCapability;
    ASN1uint16_t numOfDLCS;
    ASN1bool_t twoOctetAddressFieldCapability;
    ASN1bool_t loopBackTestCapability;
    ASN1uint16_t n401Capability;
    ASN1uint16_t maxWindowSizeCapability;
    V75Capability v75Capability;
} V76Capability;

typedef struct RSVPParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define qosMode_present 0x80
    QOSMode qosMode;
#   define tokenRate_present 0x40
    ASN1uint32_t tokenRate;
#   define bucketSize_present 0x20
    ASN1uint32_t bucketSize;
#   define peakRate_present 0x10
    ASN1uint32_t peakRate;
#   define minPoliced_present 0x8
    ASN1uint32_t minPoliced;
#   define maxPktSize_present 0x4
    ASN1uint32_t maxPktSize;
} RSVPParameters;

typedef struct QOSCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define QOSCapability_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
#   define rsvpParameters_present 0x40
    RSVPParameters rsvpParameters;
#   define atmParameters_present 0x20
    ATMParameters atmParameters;
} QOSCapability;

typedef struct TransportCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define TransportCapability_nonStandard_present 0x80
    NonStandardParameter nonStandard;
#   define qOSCapabilities_present 0x40
    PTransportCapability_qOSCapabilities qOSCapabilities;
#   define mediaChannelCapabilities_present 0x20
    TransportCapability_mediaChannelCapabilities mediaChannelCapabilities;
} TransportCapability;

typedef struct RedundancyEncodingMethod {
    ASN1choice_t choice;
    union {
#	define RedundancyEncodingMethod_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define rtpAudioRedundancyEncoding_chosen 2
#	define rtpH263VideoRedundancyEncoding_chosen 3
	RTPH263VideoRedundancyEncoding rtpH263VideoRedundancyEncoding;
    } u;
} RedundancyEncodingMethod;

typedef struct H263Options {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t advancedIntraCodingMode;
    ASN1bool_t deblockingFilterMode;
    ASN1bool_t improvedPBFramesMode;
    ASN1bool_t unlimitedMotionVectors;
    ASN1bool_t fullPictureFreeze;
    ASN1bool_t partialPictureFreezeAndRelease;
    ASN1bool_t resizingPartPicFreezeAndRelease;
    ASN1bool_t fullPictureSnapshot;
    ASN1bool_t partialPictureSnapshot;
    ASN1bool_t videoSegmentTagging;
    ASN1bool_t progressiveRefinement;
    ASN1bool_t dynamicPictureResizingByFour;
    ASN1bool_t dynamicPictureResizingSixteenthPel;
    ASN1bool_t dynamicWarpingHalfPel;
    ASN1bool_t dynamicWarpingSixteenthPel;
    ASN1bool_t independentSegmentDecoding;
    ASN1bool_t slicesInOrder_NonRect;
    ASN1bool_t slicesInOrder_Rect;
    ASN1bool_t slicesNoOrder_NonRect;
    ASN1bool_t slicesNoOrder_Rect;
    ASN1bool_t alternateInterVLCMode;
    ASN1bool_t modifiedQuantizationMode;
    ASN1bool_t reducedResolutionUpdate;
#   define transparencyParameters_present 0x80
    TransparencyParameters transparencyParameters;
    ASN1bool_t separateVideoBackChannel;
#   define refPictureSelection_present 0x40
    RefPictureSelection refPictureSelection;
#   define customPictureClockFrequency_present 0x20
    PH263Options_customPictureClockFrequency customPictureClockFrequency;
#   define customPictureFormat_present 0x10
    PH263Options_customPictureFormat customPictureFormat;
#   define modeCombos_present 0x8
    PH263Options_modeCombos modeCombos;
} H263Options;

typedef struct H263VideoModeCombos {
    H263ModeComboFlags h263VideoUncoupledModes;
    H263VideoModeCombos_h263VideoCoupledModes h263VideoCoupledModes;
} H263VideoModeCombos;

typedef struct AudioCapability {
    ASN1choice_t choice;
    union {
#	define AudioCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioCapability_g711Alaw64k_chosen 2
	ASN1uint16_t g711Alaw64k;
#	define AudioCapability_g711Alaw56k_chosen 3
	ASN1uint16_t g711Alaw56k;
#	define AudioCapability_g711Ulaw64k_chosen 4
	ASN1uint16_t g711Ulaw64k;
#	define AudioCapability_g711Ulaw56k_chosen 5
	ASN1uint16_t g711Ulaw56k;
#	define AudioCapability_g722_64k_chosen 6
	ASN1uint16_t g722_64k;
#	define AudioCapability_g722_56k_chosen 7
	ASN1uint16_t g722_56k;
#	define AudioCapability_g722_48k_chosen 8
	ASN1uint16_t g722_48k;
#	define AudioCapability_g7231_chosen 9
	AudioCapability_g7231 g7231;
#	define AudioCapability_g728_chosen 10
	ASN1uint16_t g728;
#	define AudioCapability_g729_chosen 11
	ASN1uint16_t g729;
#	define AudioCapability_g729AnnexA_chosen 12
	ASN1uint16_t g729AnnexA;
#	define is11172AudioCapability_chosen 13
	IS11172AudioCapability is11172AudioCapability;
#	define is13818AudioCapability_chosen 14
	IS13818AudioCapability is13818AudioCapability;
#	define AudioCapability_g729wAnnexB_chosen 15
	ASN1uint16_t g729wAnnexB;
#	define AudioCapability_g729AnnexAwAnnexB_chosen 16
	ASN1uint16_t g729AnnexAwAnnexB;
#	define g7231AnnexCCapability_chosen 17
	G7231AnnexCCapability g7231AnnexCCapability;
#	define AudioCapability_gsmFullRate_chosen 18
	GSMAudioCapability gsmFullRate;
#	define AudioCapability_gsmHalfRate_chosen 19
	GSMAudioCapability gsmHalfRate;
#	define AudioCapability_gsmEnhancedFullRate_chosen 20
	GSMAudioCapability gsmEnhancedFullRate;
    } u;
} AudioCapability;

typedef struct CompressionType {
    ASN1choice_t choice;
    union {
#	define v42bis_chosen 1
	V42bis v42bis;
    } u;
} CompressionType;

typedef struct MediaEncryptionAlgorithm {
    ASN1choice_t choice;
    union {
#	define MediaEncryptionAlgorithm_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define algorithm_chosen 2
	ASN1objectidentifier_t algorithm;
    } u;
} MediaEncryptionAlgorithm;

typedef struct AuthenticationCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define AuthenticationCapability_nonStandard_present 0x80
    NonStandardParameter nonStandard;
} AuthenticationCapability;

typedef struct IntegrityCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define IntegrityCapability_nonStandard_present 0x80
    NonStandardParameter nonStandard;
} IntegrityCapability;

typedef struct H223AL1MParameters {
    H223AL1MParameters_transferMode transferMode;
    H223AL1MParameters_headerFEC headerFEC;
    H223AL1MParameters_crcLength crcLength;
    ASN1uint16_t rcpcCodeRate;
    H223AL1MParameters_arqType arqType;
    ASN1bool_t alpduInterleaving;
    ASN1bool_t alsduSplitting;
} H223AL1MParameters;

typedef struct H223AL3MParameters {
    H223AL3MParameters_headerFormat headerFormat;
    H223AL3MParameters_crcLength crcLength;
    ASN1uint16_t rcpcCodeRate;
    H223AL3MParameters_arqType arqType;
    ASN1bool_t alpduInterleaving;
} H223AL3MParameters;

typedef struct V76HDLCParameters {
    CRCLength crcLength;
    ASN1uint16_t n401;
    ASN1bool_t loopbackTestProcedure;
} V76HDLCParameters;

typedef struct UnicastAddress {
    ASN1choice_t choice;
    union {
#	define UnicastAddress_iPAddress_chosen 1
	UnicastAddress_iPAddress iPAddress;
#	define iPXAddress_chosen 2
	UnicastAddress_iPXAddress iPXAddress;
#	define UnicastAddress_iP6Address_chosen 3
	UnicastAddress_iP6Address iP6Address;
#	define netBios_chosen 4
	struct UnicastAddress_netBios_netBios {
	    ASN1uint32_t length;
	    ASN1octet_t value[16];
	} netBios;
#	define iPSourceRouteAddress_chosen 5
	UnicastAddress_iPSourceRouteAddress iPSourceRouteAddress;
#	define UnicastAddress_nsap_chosen 6
	struct UnicastAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define UnicastAddress_nonStandardAddress_chosen 7
	NonStandardParameter nonStandardAddress;
    } u;
} UnicastAddress;

typedef struct MulticastAddress {
    ASN1choice_t choice;
    union {
#	define MulticastAddress_iPAddress_chosen 1
	MulticastAddress_iPAddress iPAddress;
#	define MulticastAddress_iP6Address_chosen 2
	MulticastAddress_iP6Address iP6Address;
#	define MulticastAddress_nsap_chosen 3
	struct MulticastAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define MulticastAddress_nonStandardAddress_chosen 4
	NonStandardParameter nonStandardAddress;
    } u;
} MulticastAddress;

typedef struct EncryptionSync {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define EncryptionSync_nonStandard_present 0x80
    NonStandardParameter nonStandard;
    ASN1uint16_t synchFlag;
    struct EncryptionSync_h235Key_h235Key {
	ASN1uint32_t length;
	ASN1octet_t value[65535];
    } h235Key;
#   define escrowentry_present 0x40
    PEncryptionSync_escrowentry escrowentry;
} EncryptionSync;

typedef struct RequestChannelClose {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
#   define qosCapability_present 0x80
    QOSCapability qosCapability;
#   define RequestChannelClose_reason_present 0x40
    RequestChannelClose_reason reason;
} RequestChannelClose;

typedef struct MultiplexEntryDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    MultiplexTableEntryNumber multiplexTableEntryNumber;
#   define elementList_present 0x80
    MultiplexEntryDescriptor_elementList elementList;
} MultiplexEntryDescriptor;

typedef struct MultiplexEntrySendReject {
    SequenceNumber sequenceNumber;
    MultiplexEntrySendReject_rejectionDescriptions rejectionDescriptions;
} MultiplexEntrySendReject;

typedef struct RequestMultiplexEntryReject {
    RequestMultiplexEntryReject_entryNumbers entryNumbers;
    RequestMultiplexEntryReject_rejectionDescriptions rejectionDescriptions;
} RequestMultiplexEntryReject;

typedef struct H263VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H263VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
#   define H263VideoMode_errorCompensation_present 0x80
    ASN1bool_t errorCompensation;
#   define H263VideoMode_enhancementLayerInfo_present 0x40
    EnhancementLayerInfo enhancementLayerInfo;
#   define H263VideoMode_h263Options_present 0x20
    H263Options h263Options;
} H263VideoMode;

typedef struct AudioMode {
    ASN1choice_t choice;
    union {
#	define AudioMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioMode_g711Alaw64k_chosen 2
#	define AudioMode_g711Alaw56k_chosen 3
#	define AudioMode_g711Ulaw64k_chosen 4
#	define AudioMode_g711Ulaw56k_chosen 5
#	define AudioMode_g722_64k_chosen 6
#	define AudioMode_g722_56k_chosen 7
#	define AudioMode_g722_48k_chosen 8
#	define AudioMode_g728_chosen 9
#	define AudioMode_g729_chosen 10
#	define AudioMode_g729AnnexA_chosen 11
#	define AudioMode_g7231_chosen 12
	AudioMode_g7231 g7231;
#	define is11172AudioMode_chosen 13
	IS11172AudioMode is11172AudioMode;
#	define is13818AudioMode_chosen 14
	IS13818AudioMode is13818AudioMode;
#	define AudioMode_g729wAnnexB_chosen 15
	ASN1uint16_t g729wAnnexB;
#	define AudioMode_g729AnnexAwAnnexB_chosen 16
	ASN1uint16_t g729AnnexAwAnnexB;
#	define g7231AnnexCMode_chosen 17
	G7231AnnexCMode g7231AnnexCMode;
#	define AudioMode_gsmFullRate_chosen 18
	GSMAudioCapability gsmFullRate;
#	define AudioMode_gsmHalfRate_chosen 19
	GSMAudioCapability gsmHalfRate;
#	define AudioMode_gsmEnhancedFullRate_chosen 20
	GSMAudioCapability gsmEnhancedFullRate;
    } u;
} AudioMode;

typedef struct EncryptionMode {
    ASN1choice_t choice;
    union {
#	define EncryptionMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h233Encryption_chosen 2
    } u;
} EncryptionMode;

typedef struct ConferenceRequest {
    ASN1choice_t choice;
    union {
#	define terminalListRequest_chosen 1
#	define makeMeChair_chosen 2
#	define cancelMakeMeChair_chosen 3
#	define dropTerminal_chosen 4
	TerminalLabel dropTerminal;
#	define requestTerminalID_chosen 5
	TerminalLabel requestTerminalID;
#	define enterH243Password_chosen 6
#	define enterH243TerminalID_chosen 7
#	define enterH243ConferenceID_chosen 8
#	define enterExtensionAddress_chosen 9
#	define requestChairTokenOwner_chosen 10
#	define requestTerminalCertificate_chosen 11
	ConferenceRequest_requestTerminalCertificate requestTerminalCertificate;
#	define ConferenceRequest_broadcastMyLogicalChannel_chosen 12
	LogicalChannelNumber broadcastMyLogicalChannel;
#	define ConferenceRequest_makeTerminalBroadcaster_chosen 13
	TerminalLabel makeTerminalBroadcaster;
#	define ConferenceRequest_sendThisSource_chosen 14
	TerminalLabel sendThisSource;
#	define requestAllTerminalIDs_chosen 15
#	define remoteMCRequest_chosen 16
	RemoteMCRequest remoteMCRequest;
    } u;
} ConferenceRequest;

typedef struct CertSelectionCriteria {
    PCertSelectionCriteria next;
    Criteria value;
} CertSelectionCriteria_Element;

typedef struct ConferenceResponse {
    ASN1choice_t choice;
    union {
#	define mCTerminalIDResponse_chosen 1
	ConferenceResponse_mCTerminalIDResponse mCTerminalIDResponse;
#	define terminalIDResponse_chosen 2
	ConferenceResponse_terminalIDResponse terminalIDResponse;
#	define conferenceIDResponse_chosen 3
	ConferenceResponse_conferenceIDResponse conferenceIDResponse;
#	define passwordResponse_chosen 4
	ConferenceResponse_passwordResponse passwordResponse;
#	define terminalListResponse_chosen 5
	ConferenceResponse_terminalListResponse terminalListResponse;
#	define videoCommandReject_chosen 6
#	define terminalDropReject_chosen 7
#	define makeMeChairResponse_chosen 8
	ConferenceResponse_makeMeChairResponse makeMeChairResponse;
#	define extensionAddressResponse_chosen 9
	ConferenceResponse_extensionAddressResponse extensionAddressResponse;
#	define chairTokenOwnerResponse_chosen 10
	ConferenceResponse_chairTokenOwnerResponse chairTokenOwnerResponse;
#	define terminalCertificateResponse_chosen 11
	ConferenceResponse_terminalCertificateResponse terminalCertificateResponse;
#	define broadcastMyLogicalChannelResponse_chosen 12
	ConferenceResponse_broadcastMyLogicalChannelResponse broadcastMyLogicalChannelResponse;
#	define makeTerminalBroadcasterResponse_chosen 13
	ConferenceResponse_makeTerminalBroadcasterResponse makeTerminalBroadcasterResponse;
#	define sendThisSourceResponse_chosen 14
	ConferenceResponse_sendThisSourceResponse sendThisSourceResponse;
#	define requestAllTerminalIDsResponse_chosen 15
	RequestAllTerminalIDsResponse requestAllTerminalIDsResponse;
#	define remoteMCResponse_chosen 16
	RemoteMCResponse remoteMCResponse;
    } u;
} ConferenceResponse;

typedef struct EndSessionCommand {
    ASN1choice_t choice;
    union {
#	define EndSessionCommand_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define disconnect_chosen 2
#	define gstnOptions_chosen 3
	EndSessionCommand_gstnOptions gstnOptions;
#	define isdnOptions_chosen 4
	EndSessionCommand_isdnOptions isdnOptions;
    } u;
} EndSessionCommand;

typedef struct ConferenceCommand {
    ASN1choice_t choice;
    union {
#	define ConferenceCommand_broadcastMyLogicalChannel_chosen 1
	LogicalChannelNumber broadcastMyLogicalChannel;
#	define cancelBroadcastMyLogicalChannel_chosen 2
	LogicalChannelNumber cancelBroadcastMyLogicalChannel;
#	define ConferenceCommand_makeTerminalBroadcaster_chosen 3
	TerminalLabel makeTerminalBroadcaster;
#	define cancelMakeTerminalBroadcaster_chosen 4
#	define ConferenceCommand_sendThisSource_chosen 5
	TerminalLabel sendThisSource;
#	define cancelSendThisSource_chosen 6
#	define dropConference_chosen 7
#	define substituteConferenceIDCommand_chosen 8
	SubstituteConferenceIDCommand substituteConferenceIDCommand;
    } u;
} ConferenceCommand;

typedef struct UserInputIndication_userInputSupportIndication {
    ASN1choice_t choice;
    union {
#	define UserInputIndication_userInputSupportIndication_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define UserInputIndication_userInputSupportIndication_basicString_chosen 2
#	define UserInputIndication_userInputSupportIndication_iA5String_chosen 3
#	define UserInputIndication_userInputSupportIndication_generalString_chosen 4
    } u;
} UserInputIndication_userInputSupportIndication;

typedef struct MiscellaneousIndication_type {
    ASN1choice_t choice;
    union {
#	define logicalChannelActive_chosen 1
#	define logicalChannelInactive_chosen 2
#	define multipointConference_chosen 3
#	define cancelMultipointConference_chosen 4
#	define multipointZeroComm_chosen 5
#	define cancelMultipointZeroComm_chosen 6
#	define multipointSecondaryStatus_chosen 7
#	define cancelMultipointSecondaryStatus_chosen 8
#	define videoIndicateReadyToActivate_chosen 9
#	define MiscellaneousIndication_type_videoTemporalSpatialTradeOff_chosen 10
	ASN1uint16_t videoTemporalSpatialTradeOff;
#	define videoNotDecodedMBs_chosen 11
	MiscellaneousIndication_type_videoNotDecodedMBs videoNotDecodedMBs;
#	define transportCapability_chosen 12
	TransportCapability transportCapability;
    } u;
} MiscellaneousIndication_type;

typedef struct MiscellaneousCommand_type {
    ASN1choice_t choice;
    union {
#	define equaliseDelay_chosen 1
#	define zeroDelay_chosen 2
#	define multipointModeCommand_chosen 3
#	define cancelMultipointModeCommand_chosen 4
#	define videoFreezePicture_chosen 5
#	define videoFastUpdatePicture_chosen 6
#	define videoFastUpdateGOB_chosen 7
	MiscellaneousCommand_type_videoFastUpdateGOB videoFastUpdateGOB;
#	define MiscellaneousCommand_type_videoTemporalSpatialTradeOff_chosen 8
	ASN1uint16_t videoTemporalSpatialTradeOff;
#	define videoSendSyncEveryGOB_chosen 9
#	define videoSendSyncEveryGOBCancel_chosen 10
#	define videoFastUpdateMB_chosen 11
	MiscellaneousCommand_type_videoFastUpdateMB videoFastUpdateMB;
#	define maxH223MUXPDUsize_chosen 12
	ASN1uint16_t maxH223MUXPDUsize;
#	define encryptionUpdate_chosen 13
	EncryptionSync encryptionUpdate;
#	define encryptionUpdateRequest_chosen 14
	EncryptionUpdateRequest encryptionUpdateRequest;
#	define switchReceiveMediaOff_chosen 15
#	define switchReceiveMediaOn_chosen 16
#	define progressiveRefinementStart_chosen 17
	MiscellaneousCommand_type_progressiveRefinementStart progressiveRefinementStart;
#	define progressiveRefinementAbortOne_chosen 18
#	define progressiveRefinementAbortContinuous_chosen 19
    } u;
} MiscellaneousCommand_type;

typedef struct EncryptionCommand_encryptionAlgorithmID {
    SequenceNumber h233AlgorithmIdentifier;
    NonStandardParameter associatedAlgorithm;
} EncryptionCommand_encryptionAlgorithmID;

typedef struct CommunicationModeTableEntry_nonStandard {
    PCommunicationModeTableEntry_nonStandard next;
    NonStandardParameter value;
} CommunicationModeTableEntry_nonStandard_Element;

typedef struct RedundancyEncodingMode_secondaryEncoding {
    ASN1choice_t choice;
    union {
#	define RedundancyEncodingMode_secondaryEncoding_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define RedundancyEncodingMode_secondaryEncoding_audioData_chosen 2
	AudioMode audioData;
    } u;
} RedundancyEncodingMode_secondaryEncoding;

typedef struct H223ModeParameters_adaptationLayerType {
    ASN1choice_t choice;
    union {
#	define H223ModeParameters_adaptationLayerType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223ModeParameters_adaptationLayerType_al1Framed_chosen 2
#	define H223ModeParameters_adaptationLayerType_al1NotFramed_chosen 3
#	define H223ModeParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen 4
#	define H223ModeParameters_adaptationLayerType_al2WithSequenceNumbers_chosen 5
#	define H223ModeParameters_adaptationLayerType_al3_chosen 6
	H223ModeParameters_adaptationLayerType_al3 al3;
#	define H223ModeParameters_adaptationLayerType_al1M_chosen 7
	H223AL1MParameters al1M;
#	define H223ModeParameters_adaptationLayerType_al2M_chosen 8
	H223AL2MParameters al2M;
#	define H223ModeParameters_adaptationLayerType_al3M_chosen 9
	H223AL3MParameters al3M;
    } u;
} H223ModeParameters_adaptationLayerType;

typedef struct MultiplexEntrySend_multiplexEntryDescriptors {
    PMultiplexEntrySend_multiplexEntryDescriptors next;
    MultiplexEntryDescriptor value;
} MultiplexEntrySend_multiplexEntryDescriptors_Element;

typedef struct H2250LogicalChannelAckParameters_nonStandard {
    PH2250LogicalChannelAckParameters_nonStandard next;
    NonStandardParameter value;
} H2250LogicalChannelAckParameters_nonStandard_Element;

typedef struct RTPPayloadType_payloadDescriptor {
    ASN1choice_t choice;
    union {
#	define nonStandardIdentifier_chosen 1
	NonStandardParameter nonStandardIdentifier;
#	define rfc_number_chosen 2
	ASN1uint16_t rfc_number;
#	define oid_chosen 3
	ASN1objectidentifier_t oid;
    } u;
} RTPPayloadType_payloadDescriptor;

typedef struct H2250LogicalChannelParameters_nonStandard {
    PH2250LogicalChannelParameters_nonStandard next;
    NonStandardParameter value;
} H2250LogicalChannelParameters_nonStandard_Element;

typedef struct H223LogicalChannelParameters_adaptationLayerType {
    ASN1choice_t choice;
    union {
#	define H223LogicalChannelParameters_adaptationLayerType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223LogicalChannelParameters_adaptationLayerType_al1Framed_chosen 2
#	define H223LogicalChannelParameters_adaptationLayerType_al1NotFramed_chosen 3
#	define H223LogicalChannelParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen 4
#	define H223LogicalChannelParameters_adaptationLayerType_al2WithSequenceNumbers_chosen 5
#	define H223LogicalChannelParameters_adaptationLayerType_al3_chosen 6
	H223LogicalChannelParameters_adaptationLayerType_al3 al3;
#	define H223LogicalChannelParameters_adaptationLayerType_al1M_chosen 7
	H223AL1MParameters al1M;
#	define H223LogicalChannelParameters_adaptationLayerType_al2M_chosen 8
	H223AL2MParameters al2M;
#	define H223LogicalChannelParameters_adaptationLayerType_al3M_chosen 9
	H223AL3MParameters al3M;
    } u;
} H223LogicalChannelParameters_adaptationLayerType;

typedef struct ConferenceCapability_nonStandardData {
    PConferenceCapability_nonStandardData next;
    NonStandardParameter value;
} ConferenceCapability_nonStandardData_Element;

typedef struct UserInputCapability_nonStandard {
    ASN1uint32_t count;
    NonStandardParameter value[16];
} UserInputCapability_nonStandard;

typedef struct DataProtocolCapability_v76wCompression {
    ASN1choice_t choice;
    union {
#	define transmitCompression_chosen 1
	CompressionType transmitCompression;
#	define receiveCompression_chosen 2
	CompressionType receiveCompression;
#	define transmitAndReceiveCompression_chosen 3
	CompressionType transmitAndReceiveCompression;
    } u;
} DataProtocolCapability_v76wCompression;

typedef struct H263Options_modeCombos {
    PH263Options_modeCombos next;
    H263VideoModeCombos value;
} H263Options_modeCombos_Element;

typedef struct TransportCapability_qOSCapabilities {
    PTransportCapability_qOSCapabilities next;
    QOSCapability value;
} TransportCapability_qOSCapabilities_Element;

typedef struct NonStandardMessage {
    NonStandardParameter nonStandardData;
} NonStandardMessage;

typedef struct RedundancyEncodingCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RedundancyEncodingMethod redundancyEncodingMethod;
    CapabilityTableEntryNumber primaryEncoding;
#   define RedundancyEncodingCapability_secondaryEncoding_present 0x80
    PRedundancyEncodingCapability_secondaryEncoding secondaryEncoding;
} RedundancyEncodingCapability;

typedef struct H263VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H263VideoCapability_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define H263VideoCapability_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define H263VideoCapability_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define H263VideoCapability_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define H263VideoCapability_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
    ASN1uint32_t maxBitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
    ASN1bool_t temporalSpatialTradeOffCapability;
#   define hrd_B_present 0x4
    ASN1uint32_t hrd_B;
#   define bppMaxKb_present 0x2
    ASN1uint16_t bppMaxKb;
#   define H263VideoCapability_slowSqcifMPI_present 0x8000
    ASN1uint16_t slowSqcifMPI;
#   define H263VideoCapability_slowQcifMPI_present 0x4000
    ASN1uint16_t slowQcifMPI;
#   define H263VideoCapability_slowCifMPI_present 0x2000
    ASN1uint16_t slowCifMPI;
#   define H263VideoCapability_slowCif4MPI_present 0x1000
    ASN1uint16_t slowCif4MPI;
#   define H263VideoCapability_slowCif16MPI_present 0x800
    ASN1uint16_t slowCif16MPI;
#   define H263VideoCapability_errorCompensation_present 0x400
    ASN1bool_t errorCompensation;
#   define H263VideoCapability_enhancementLayerInfo_present 0x200
    EnhancementLayerInfo enhancementLayerInfo;
#   define H263VideoCapability_h263Options_present 0x100
    H263Options h263Options;
} H263VideoCapability;

typedef struct EnhancementOptions {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define EnhancementOptions_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define EnhancementOptions_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define EnhancementOptions_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define EnhancementOptions_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define EnhancementOptions_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
    ASN1uint32_t maxBitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t temporalSpatialTradeOffCapability;
#   define EnhancementOptions_slowSqcifMPI_present 0x4
    ASN1uint16_t slowSqcifMPI;
#   define EnhancementOptions_slowQcifMPI_present 0x2
    ASN1uint16_t slowQcifMPI;
#   define EnhancementOptions_slowCifMPI_present 0x1
    ASN1uint16_t slowCifMPI;
#   define EnhancementOptions_slowCif4MPI_present 0x8000
    ASN1uint16_t slowCif4MPI;
#   define EnhancementOptions_slowCif16MPI_present 0x4000
    ASN1uint16_t slowCif16MPI;
    ASN1bool_t errorCompensation;
#   define EnhancementOptions_h263Options_present 0x2000
    H263Options h263Options;
} EnhancementOptions;

typedef struct DataProtocolCapability {
    ASN1choice_t choice;
    union {
#	define DataProtocolCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define v14buffered_chosen 2
#	define v42lapm_chosen 3
#	define hdlcFrameTunnelling_chosen 4
#	define h310SeparateVCStack_chosen 5
#	define h310SingleVCStack_chosen 6
#	define transparent_chosen 7
#	define segmentationAndReassembly_chosen 8
#	define hdlcFrameTunnelingwSAR_chosen 9
#	define v120_chosen 10
#	define separateLANStack_chosen 11
#	define v76wCompression_chosen 12
	DataProtocolCapability_v76wCompression v76wCompression;
    } u;
} DataProtocolCapability;

typedef struct EncryptionAuthenticationAndIntegrity {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define encryptionCapability_present 0x80
    PEncryptionCapability encryptionCapability;
#   define authenticationCapability_present 0x40
    AuthenticationCapability authenticationCapability;
#   define integrityCapability_present 0x20
    IntegrityCapability integrityCapability;
} EncryptionAuthenticationAndIntegrity;

typedef struct EncryptionCapability {
    PEncryptionCapability next;
    MediaEncryptionAlgorithm value;
} EncryptionCapability_Element;

typedef struct UserInputCapability {
    ASN1choice_t choice;
    union {
#	define UserInputCapability_nonStandard_chosen 1
	UserInputCapability_nonStandard nonStandard;
#	define UserInputCapability_basicString_chosen 2
#	define UserInputCapability_iA5String_chosen 3
#	define UserInputCapability_generalString_chosen 4
#	define dtmf_chosen 5
#	define hookflash_chosen 6
    } u;
} UserInputCapability;

typedef struct H223LogicalChannelParameters {
    H223LogicalChannelParameters_adaptationLayerType adaptationLayerType;
    ASN1bool_t segmentableFlag;
} H223LogicalChannelParameters;

typedef struct V76LogicalChannelParameters {
    V76HDLCParameters hdlcParameters;
    V76LogicalChannelParameters_suspendResume suspendResume;
    ASN1bool_t uIH;
    V76LogicalChannelParameters_mode mode;
    V75Parameters v75Parameters;
} V76LogicalChannelParameters;

typedef struct RTPPayloadType {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RTPPayloadType_payloadDescriptor payloadDescriptor;
#   define payloadType_present 0x80
    ASN1uint16_t payloadType;
} RTPPayloadType;

typedef struct H245TransportAddress {
    ASN1choice_t choice;
    union {
#	define unicastAddress_chosen 1
	UnicastAddress unicastAddress;
#	define multicastAddress_chosen 2
	MulticastAddress multicastAddress;
    } u;
} H245TransportAddress;

typedef struct H2250LogicalChannelAckParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H2250LogicalChannelAckParameters_nonStandard_present 0x80
    PH2250LogicalChannelAckParameters_nonStandard nonStandard;
#   define sessionID_present 0x40
    ASN1uint16_t sessionID;
#   define H2250LogicalChannelAckParameters_mediaChannel_present 0x20
    H245TransportAddress mediaChannel;
#   define H2250LogicalChannelAckParameters_mediaControlChannel_present 0x10
    H245TransportAddress mediaControlChannel;
#   define H2250LogicalChannelAckParameters_dynamicRTPPayloadType_present 0x8
    ASN1uint16_t dynamicRTPPayloadType;
#   define flowControlToZero_present 0x8000
    ASN1bool_t flowControlToZero;
#   define H2250LogicalChannelAckParameters_portNumber_present 0x4000
    ASN1uint16_t portNumber;
} H2250LogicalChannelAckParameters;

typedef struct H223ModeParameters {
    H223ModeParameters_adaptationLayerType adaptationLayerType;
    ASN1bool_t segmentableFlag;
} H223ModeParameters;

typedef struct RedundancyEncodingMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RedundancyEncodingMethod redundancyEncodingMethod;
#   define RedundancyEncodingMode_secondaryEncoding_present 0x80
    RedundancyEncodingMode_secondaryEncoding secondaryEncoding;
} RedundancyEncodingMode;

typedef struct VideoMode {
    ASN1choice_t choice;
    union {
#	define VideoMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoMode_chosen 2
	H261VideoMode h261VideoMode;
#	define h262VideoMode_chosen 3
	H262VideoMode h262VideoMode;
#	define h263VideoMode_chosen 4
	H263VideoMode h263VideoMode;
#	define is11172VideoMode_chosen 5
	IS11172VideoMode is11172VideoMode;
    } u;
} VideoMode;

typedef struct EncryptionCommand {
    ASN1choice_t choice;
    union {
#	define encryptionSE_chosen 1
	ASN1octetstring_t encryptionSE;
#	define encryptionIVRequest_chosen 2
#	define encryptionAlgorithmID_chosen 3
	EncryptionCommand_encryptionAlgorithmID encryptionAlgorithmID;
    } u;
} EncryptionCommand;

typedef struct MiscellaneousCommand {
    LogicalChannelNumber logicalChannelNumber;
    MiscellaneousCommand_type type;
} MiscellaneousCommand;

typedef struct MiscellaneousIndication {
    LogicalChannelNumber logicalChannelNumber;
    MiscellaneousIndication_type type;
} MiscellaneousIndication;

typedef struct MCLocationIndication {
    H245TransportAddress signalAddress;
} MCLocationIndication;

typedef struct UserInputIndication {
    ASN1choice_t choice;
    union {
#	define UserInputIndication_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define alphanumeric_chosen 2
	ASN1ztcharstring_t alphanumeric;
#	define userInputSupportIndication_chosen 3
	UserInputIndication_userInputSupportIndication userInputSupportIndication;
#	define signal_chosen 4
	UserInputIndication_signal signal;
#	define signalUpdate_chosen 5
	UserInputIndication_signalUpdate signalUpdate;
    } u;
} UserInputIndication;

typedef struct DataApplicationCapability_application_nlpid {
    DataProtocolCapability nlpidProtocol;
    ASN1octetstring_t nlpidData;
} DataApplicationCapability_application_nlpid;

typedef struct DataApplicationCapability_application_t84 {
    DataProtocolCapability t84Protocol;
    T84Profile t84Profile;
} DataApplicationCapability_application_t84;

typedef struct DataMode_application_nlpid {
    DataProtocolCapability nlpidProtocol;
    ASN1octetstring_t nlpidData;
} DataMode_application_nlpid;

typedef struct DataMode_application {
    ASN1choice_t choice;
    union {
#	define DataMode_application_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define DataMode_application_t120_chosen 2
	DataProtocolCapability t120;
#	define DataMode_application_dsm_cc_chosen 3
	DataProtocolCapability dsm_cc;
#	define DataMode_application_userData_chosen 4
	DataProtocolCapability userData;
#	define DataMode_application_t84_chosen 5
	DataProtocolCapability t84;
#	define DataMode_application_t434_chosen 6
	DataProtocolCapability t434;
#	define DataMode_application_h224_chosen 7
	DataProtocolCapability h224;
#	define DataMode_application_nlpid_chosen 8
	DataMode_application_nlpid nlpid;
#	define DataMode_application_dsvdControl_chosen 9
#	define DataMode_application_h222DataPartitioning_chosen 10
	DataProtocolCapability h222DataPartitioning;
#	define DataMode_application_t30fax_chosen 11
	DataProtocolCapability t30fax;
#	define DataMode_application_t140_chosen 12
	DataProtocolCapability t140;
    } u;
} DataMode_application;

typedef struct OpenLogicalChannelAck_forwardMultiplexAckParameters {
    ASN1choice_t choice;
    union {
#	define h2250LogicalChannelAckParameters_chosen 1
	H2250LogicalChannelAckParameters h2250LogicalChannelAckParameters;
    } u;
} OpenLogicalChannelAck_forwardMultiplexAckParameters;

typedef struct H2250LogicalChannelParameters_mediaPacketization {
    ASN1choice_t choice;
    union {
#	define h261aVideoPacketization_chosen 1
#	define rtpPayloadType_chosen 2
	RTPPayloadType rtpPayloadType;
    } u;
} H2250LogicalChannelParameters_mediaPacketization;

typedef struct NetworkAccessParameters_networkAddress {
    ASN1choice_t choice;
    union {
#	define q2931Address_chosen 1
	Q2931Address q2931Address;
#	define e164Address_chosen 2
	ASN1char_t e164Address[129];
#	define localAreaAddress_chosen 3
	H245TransportAddress localAreaAddress;
    } u;
} NetworkAccessParameters_networkAddress;

typedef struct DataApplicationCapability_application {
    ASN1choice_t choice;
    union {
#	define DataApplicationCapability_application_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define DataApplicationCapability_application_t120_chosen 2
	DataProtocolCapability t120;
#	define DataApplicationCapability_application_dsm_cc_chosen 3
	DataProtocolCapability dsm_cc;
#	define DataApplicationCapability_application_userData_chosen 4
	DataProtocolCapability userData;
#	define DataApplicationCapability_application_t84_chosen 5
	DataApplicationCapability_application_t84 t84;
#	define DataApplicationCapability_application_t434_chosen 6
	DataProtocolCapability t434;
#	define DataApplicationCapability_application_h224_chosen 7
	DataProtocolCapability h224;
#	define DataApplicationCapability_application_nlpid_chosen 8
	DataApplicationCapability_application_nlpid nlpid;
#	define DataApplicationCapability_application_dsvdControl_chosen 9
#	define DataApplicationCapability_application_h222DataPartitioning_chosen 10
	DataProtocolCapability h222DataPartitioning;
#	define DataApplicationCapability_application_t30fax_chosen 11
	DataProtocolCapability t30fax;
#	define DataApplicationCapability_application_t140_chosen 12
	DataProtocolCapability t140;
    } u;
} DataApplicationCapability_application;

typedef struct EnhancementLayerInfo_spatialEnhancement {
    PEnhancementLayerInfo_spatialEnhancement next;
    EnhancementOptions value;
} EnhancementLayerInfo_spatialEnhancement_Element;

typedef struct EnhancementLayerInfo_snrEnhancement {
    PEnhancementLayerInfo_snrEnhancement next;
    EnhancementOptions value;
} EnhancementLayerInfo_snrEnhancement_Element;

typedef struct MediaPacketizationCapability_rtpPayloadType {
    ASN1uint32_t count;
    RTPPayloadType value[256];
} MediaPacketizationCapability_rtpPayloadType;

typedef struct H2250Capability_redundancyEncodingCapability {
    PH2250Capability_redundancyEncodingCapability next;
    RedundancyEncodingCapability value;
} H2250Capability_redundancyEncodingCapability_Element;

typedef struct CommandMessage {
    ASN1choice_t choice;
    union {
#	define CommandMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define maintenanceLoopOffCommand_chosen 2
	MaintenanceLoopOffCommand maintenanceLoopOffCommand;
#	define sendTerminalCapabilitySet_chosen 3
	SendTerminalCapabilitySet sendTerminalCapabilitySet;
#	define encryptionCommand_chosen 4
	EncryptionCommand encryptionCommand;
#	define flowControlCommand_chosen 5
	FlowControlCommand flowControlCommand;
#	define endSessionCommand_chosen 6
	EndSessionCommand endSessionCommand;
#	define miscellaneousCommand_chosen 7
	MiscellaneousCommand miscellaneousCommand;
#	define communicationModeCommand_chosen 8
	CommunicationModeCommand communicationModeCommand;
#	define conferenceCommand_chosen 9
	ConferenceCommand conferenceCommand;
#	define h223MultiplexReconfiguration_chosen 10
	H223MultiplexReconfiguration h223MultiplexReconfiguration;
    } u;
} CommandMessage;

typedef struct H235SecurityCapability {
    EncryptionAuthenticationAndIntegrity encryptionAuthenticationAndIntegrity;
    CapabilityTableEntryNumber mediaCapability;
} H235SecurityCapability;

typedef struct MediaPacketizationCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t h261aVideoPacketization;
#   define rtpPayloadType_present 0x80
    MediaPacketizationCapability_rtpPayloadType rtpPayloadType;
} MediaPacketizationCapability;

typedef struct VideoCapability {
    ASN1choice_t choice;
    union {
#	define VideoCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoCapability_chosen 2
	H261VideoCapability h261VideoCapability;
#	define h262VideoCapability_chosen 3
	H262VideoCapability h262VideoCapability;
#	define h263VideoCapability_chosen 4
	H263VideoCapability h263VideoCapability;
#	define is11172VideoCapability_chosen 5
	IS11172VideoCapability is11172VideoCapability;
    } u;
} VideoCapability;

typedef struct BEnhancementParameters {
    EnhancementOptions enhancementOptions;
    ASN1uint16_t numberOfBPictures;
} BEnhancementParameters;

typedef struct DataApplicationCapability {
    DataApplicationCapability_application application;
    ASN1uint32_t maxBitRate;
} DataApplicationCapability;

typedef struct NetworkAccessParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define distribution_present 0x80
    NetworkAccessParameters_distribution distribution;
    NetworkAccessParameters_networkAddress networkAddress;
    ASN1bool_t associateConference;
#   define externalReference_present 0x40
    struct NetworkAccessParameters_externalReference_externalReference {
	ASN1uint32_t length;
	ASN1octet_t value[255];
    } externalReference;
#   define t120SetupProcedure_present 0x8000
    NetworkAccessParameters_t120SetupProcedure t120SetupProcedure;
} NetworkAccessParameters;

typedef struct H2250ModeParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define redundancyEncodingMode_present 0x80
    RedundancyEncodingMode redundancyEncodingMode;
} H2250ModeParameters;

typedef struct DataMode {
    DataMode_application application;
    ASN1uint32_t bitRate;
} DataMode;

typedef struct CommunicationModeTableEntry_dataType {
    ASN1choice_t choice;
    union {
#	define CommunicationModeTableEntry_dataType_videoData_chosen 1
	VideoCapability videoData;
#	define CommunicationModeTableEntry_dataType_audioData_chosen 2
	AudioCapability audioData;
#	define CommunicationModeTableEntry_dataType_data_chosen 3
	DataApplicationCapability data;
    } u;
} CommunicationModeTableEntry_dataType;

typedef struct H235Mode_mediaMode {
    ASN1choice_t choice;
    union {
#	define H235Mode_mediaMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H235Mode_mediaMode_videoMode_chosen 2
	VideoMode videoMode;
#	define H235Mode_mediaMode_audioMode_chosen 3
	AudioMode audioMode;
#	define H235Mode_mediaMode_dataMode_chosen 4
	DataMode dataMode;
    } u;
} H235Mode_mediaMode;

typedef struct H235Media_mediaType {
    ASN1choice_t choice;
    union {
#	define H235Media_mediaType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H235Media_mediaType_videoData_chosen 2
	VideoCapability videoData;
#	define H235Media_mediaType_audioData_chosen 3
	AudioCapability audioData;
#	define H235Media_mediaType_data_chosen 4
	DataApplicationCapability data;
    } u;
} H235Media_mediaType;

typedef struct EnhancementLayerInfo_bPictureEnhancement {
    PEnhancementLayerInfo_bPictureEnhancement next;
    BEnhancementParameters value;
} EnhancementLayerInfo_bPictureEnhancement_Element;

typedef struct MediaDistributionCapability_distributedData {
    PMediaDistributionCapability_distributedData next;
    DataApplicationCapability value;
} MediaDistributionCapability_distributedData_Element;

typedef struct MediaDistributionCapability_centralizedData {
    PMediaDistributionCapability_centralizedData next;
    DataApplicationCapability value;
} MediaDistributionCapability_centralizedData_Element;

typedef struct Capability {
    ASN1choice_t choice;
    union {
#	define Capability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define receiveVideoCapability_chosen 2
	VideoCapability receiveVideoCapability;
#	define transmitVideoCapability_chosen 3
	VideoCapability transmitVideoCapability;
#	define receiveAndTransmitVideoCapability_chosen 4
	VideoCapability receiveAndTransmitVideoCapability;
#	define receiveAudioCapability_chosen 5
	AudioCapability receiveAudioCapability;
#	define transmitAudioCapability_chosen 6
	AudioCapability transmitAudioCapability;
#	define receiveAndTransmitAudioCapability_chosen 7
	AudioCapability receiveAndTransmitAudioCapability;
#	define receiveDataApplicationCapability_chosen 8
	DataApplicationCapability receiveDataApplicationCapability;
#	define transmitDataApplicationCapability_chosen 9
	DataApplicationCapability transmitDataApplicationCapability;
#	define receiveAndTransmitDataApplicationCapability_chosen 10
	DataApplicationCapability receiveAndTransmitDataApplicationCapability;
#	define h233EncryptionTransmitCapability_chosen 11
	ASN1bool_t h233EncryptionTransmitCapability;
#	define h233EncryptionReceiveCapability_chosen 12
	Capability_h233EncryptionReceiveCapability h233EncryptionReceiveCapability;
#	define conferenceCapability_chosen 13
	ConferenceCapability conferenceCapability;
#	define h235SecurityCapability_chosen 14
	H235SecurityCapability h235SecurityCapability;
#	define maxPendingReplacementFor_chosen 15
	ASN1uint16_t maxPendingReplacementFor;
#	define receiveUserInputCapability_chosen 16
	UserInputCapability receiveUserInputCapability;
#	define transmitUserInputCapability_chosen 17
	UserInputCapability transmitUserInputCapability;
#	define receiveAndTransmitUserInputCapability_chosen 18
	UserInputCapability receiveAndTransmitUserInputCapability;
    } u;
} Capability;

typedef struct H2250Capability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t maximumAudioDelayJitter;
    MultipointCapability receiveMultipointCapability;
    MultipointCapability transmitMultipointCapability;
    MultipointCapability receiveAndTransmitMultipointCapability;
    H2250Capability_mcCapability mcCapability;
    ASN1bool_t rtcpVideoControlCapability;
    MediaPacketizationCapability mediaPacketizationCapability;
#   define H2250Capability_transportCapability_present 0x80
    TransportCapability transportCapability;
#   define redundancyEncodingCapability_present 0x40
    PH2250Capability_redundancyEncodingCapability redundancyEncodingCapability;
#   define logicalChannelSwitchingCapability_present 0x20
    ASN1bool_t logicalChannelSwitchingCapability;
#   define t120DynamicPortCapability_present 0x10
    ASN1bool_t t120DynamicPortCapability;
} H2250Capability;

typedef struct H235Media {
    EncryptionAuthenticationAndIntegrity encryptionAuthenticationAndIntegrity;
    H235Media_mediaType mediaType;
} H235Media;

typedef struct H235Mode {
    EncryptionAuthenticationAndIntegrity encryptionAuthenticationAndIntegrity;
    H235Mode_mediaMode mediaMode;
} H235Mode;

typedef struct ModeElement_type {
    ASN1choice_t choice;
    union {
#	define ModeElement_type_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define ModeElement_type_videoMode_chosen 2
	VideoMode videoMode;
#	define ModeElement_type_audioMode_chosen 3
	AudioMode audioMode;
#	define ModeElement_type_dataMode_chosen 4
	DataMode dataMode;
#	define encryptionMode_chosen 5
	EncryptionMode encryptionMode;
#	define h235Mode_chosen 6
	H235Mode h235Mode;
    } u;
} ModeElement_type;

typedef struct CapabilityTableEntry {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CapabilityTableEntryNumber capabilityTableEntryNumber;
#   define capability_present 0x80
    Capability capability;
} CapabilityTableEntry;

typedef struct MultiplexCapability {
    ASN1choice_t choice;
    union {
#	define MultiplexCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h222Capability_chosen 2
	H222Capability h222Capability;
#	define h223Capability_chosen 3
	H223Capability h223Capability;
#	define v76Capability_chosen 4
	V76Capability v76Capability;
#	define h2250Capability_chosen 5
	H2250Capability h2250Capability;
    } u;
} MultiplexCapability;

typedef struct DataType {
    ASN1choice_t choice;
    union {
#	define DataType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define nullData_chosen 2
#	define DataType_videoData_chosen 3
	VideoCapability videoData;
#	define DataType_audioData_chosen 4
	AudioCapability audioData;
#	define DataType_data_chosen 5
	DataApplicationCapability data;
#	define encryptionData_chosen 6
	EncryptionMode encryptionData;
#	define h235Control_chosen 7
	NonStandardParameter h235Control;
#	define h235Media_chosen 8
	H235Media h235Media;
    } u;
} DataType;

typedef struct RedundancyEncoding {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RedundancyEncodingMethod redundancyEncodingMethod;
#   define RedundancyEncoding_secondaryEncoding_present 0x80
    DataType secondaryEncoding;
} RedundancyEncoding;

typedef struct ModeElement {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ModeElement_type type;
#   define h223ModeParameters_present 0x80
    H223ModeParameters h223ModeParameters;
#   define v76ModeParameters_present 0x8000
    V76ModeParameters v76ModeParameters;
#   define h2250ModeParameters_present 0x4000
    H2250ModeParameters h2250ModeParameters;
} ModeElement;

typedef struct CommunicationModeTableEntry {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define CommunicationModeTableEntry_nonStandard_present 0x80
    PCommunicationModeTableEntry_nonStandard nonStandard;
    ASN1uint16_t sessionID;
#   define CommunicationModeTableEntry_associatedSessionID_present 0x40
    ASN1uint16_t associatedSessionID;
#   define CommunicationModeTableEntry_terminalLabel_present 0x20
    TerminalLabel terminalLabel;
    ASN1char16string_t sessionDescription;
    CommunicationModeTableEntry_dataType dataType;
#   define CommunicationModeTableEntry_mediaChannel_present 0x10
    H245TransportAddress mediaChannel;
#   define CommunicationModeTableEntry_mediaGuaranteedDelivery_present 0x8
    ASN1bool_t mediaGuaranteedDelivery;
#   define CommunicationModeTableEntry_mediaControlChannel_present 0x4
    H245TransportAddress mediaControlChannel;
#   define CommunicationModeTableEntry_mediaControlGuaranteedDelivery_present 0x2
    ASN1bool_t mediaControlGuaranteedDelivery;
#   define CommunicationModeTableEntry_redundancyEncoding_present 0x8000
    RedundancyEncoding redundancyEncoding;
#   define sessionDependency_present 0x4000
    ASN1uint16_t sessionDependency;
#   define CommunicationModeTableEntry_destination_present 0x2000
    TerminalLabel destination;
} CommunicationModeTableEntry;

typedef struct CommunicationModeResponse_communicationModeTable {
    PCommunicationModeResponse_communicationModeTable next;
    CommunicationModeTableEntry value;
} CommunicationModeResponse_communicationModeTable_Element;

typedef struct CommunicationModeCommand_communicationModeTable {
    PCommunicationModeCommand_communicationModeTable next;
    CommunicationModeTableEntry value;
} CommunicationModeCommand_communicationModeTable_Element;

typedef struct TerminalCapabilitySet_capabilityTable {
    PTerminalCapabilitySet_capabilityTable next;
    CapabilityTableEntry value;
} TerminalCapabilitySet_capabilityTable_Element;

typedef struct TerminalCapabilitySet {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SequenceNumber sequenceNumber;
    ASN1objectidentifier_t protocolIdentifier;
#   define multiplexCapability_present 0x80
    MultiplexCapability multiplexCapability;
#   define capabilityTable_present 0x40
    PTerminalCapabilitySet_capabilityTable capabilityTable;
#   define capabilityDescriptors_present 0x20
    TerminalCapabilitySet_capabilityDescriptors capabilityDescriptors;
} TerminalCapabilitySet;

typedef struct H2250LogicalChannelParameters {
    union {
	ASN1uint32_t bit_mask;
	ASN1octet_t o[3];
    };
#   define H2250LogicalChannelParameters_nonStandard_present 0x80
    PH2250LogicalChannelParameters_nonStandard nonStandard;
    ASN1uint16_t sessionID;
#   define H2250LogicalChannelParameters_associatedSessionID_present 0x40
    ASN1uint16_t associatedSessionID;
#   define H2250LogicalChannelParameters_mediaChannel_present 0x20
    H245TransportAddress mediaChannel;
#   define H2250LogicalChannelParameters_mediaGuaranteedDelivery_present 0x10
    ASN1bool_t mediaGuaranteedDelivery;
#   define H2250LogicalChannelParameters_mediaControlChannel_present 0x8
    H245TransportAddress mediaControlChannel;
#   define H2250LogicalChannelParameters_mediaControlGuaranteedDelivery_present 0x4
    ASN1bool_t mediaControlGuaranteedDelivery;
#   define silenceSuppression_present 0x2
    ASN1bool_t silenceSuppression;
#   define H2250LogicalChannelParameters_destination_present 0x1
    TerminalLabel destination;
#   define H2250LogicalChannelParameters_dynamicRTPPayloadType_present 0x8000
    ASN1uint16_t dynamicRTPPayloadType;
#   define mediaPacketization_present 0x4000
    H2250LogicalChannelParameters_mediaPacketization mediaPacketization;
#   define H2250LogicalChannelParameters_transportCapability_present 0x800000
    TransportCapability transportCapability;
#   define H2250LogicalChannelParameters_redundancyEncoding_present 0x400000
    RedundancyEncoding redundancyEncoding;
#   define source_present 0x200000
    TerminalLabel source;
} H2250LogicalChannelParameters;

typedef struct ModeDescription {
    ASN1uint32_t count;
    ModeElement value[256];
} ModeDescription;

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen 1
	H222LogicalChannelParameters h222LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen 2
	H223LogicalChannelParameters h223LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen 3
	V76LogicalChannelParameters v76LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 4
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_none_chosen 5
    } u;
} OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen 1
	H223LogicalChannelParameters h223LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen 2
	V76LogicalChannelParameters v76LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 3
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
    } u;
} OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen 1
	H222LogicalChannelParameters h222LogicalChannelParameters;
#	define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 2
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
    } u;
} OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters;

typedef struct RequestMode_requestedModes {
    PRequestMode_requestedModes next;
    ModeDescription value;
} RequestMode_requestedModes_Element;

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber reverseLogicalChannelNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber_present 0x80
    ASN1uint16_t portNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_present 0x40
    OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters multiplexParameters;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_replacementFor_present 0x8000
    LogicalChannelNumber replacementFor;
} OpenLogicalChannelAck_reverseLogicalChannelParameters;

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    DataType dataType;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_present 0x80
    OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters multiplexParameters;
#   define reverseLogicalChannelDependency_present 0x8000
    LogicalChannelNumber reverseLogicalChannelDependency;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_replacementFor_present 0x4000
    LogicalChannelNumber replacementFor;
} OpenLogicalChannel_reverseLogicalChannelParameters;

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define OpenLogicalChannel_forwardLogicalChannelParameters_portNumber_present 0x80
    ASN1uint16_t portNumber;
    DataType dataType;
    OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters multiplexParameters;
#   define forwardLogicalChannelDependency_present 0x8000
    LogicalChannelNumber forwardLogicalChannelDependency;
#   define OpenLogicalChannel_forwardLogicalChannelParameters_replacementFor_present 0x4000
    LogicalChannelNumber replacementFor;
} OpenLogicalChannel_forwardLogicalChannelParameters;

typedef struct OpenLogicalChannel {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
    OpenLogicalChannel_forwardLogicalChannelParameters forwardLogicalChannelParameters;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_present 0x80
    OpenLogicalChannel_reverseLogicalChannelParameters reverseLogicalChannelParameters;
#   define OpenLogicalChannel_separateStack_present 0x8000
    NetworkAccessParameters separateStack;
#   define OpenLogicalChannel_encryptionSync_present 0x4000
    EncryptionSync encryptionSync;
} OpenLogicalChannel;

typedef struct OpenLogicalChannelAck {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_present 0x80
    OpenLogicalChannelAck_reverseLogicalChannelParameters reverseLogicalChannelParameters;
#   define OpenLogicalChannelAck_separateStack_present 0x8000
    NetworkAccessParameters separateStack;
#   define forwardMultiplexAckParameters_present 0x4000
    OpenLogicalChannelAck_forwardMultiplexAckParameters forwardMultiplexAckParameters;
#   define OpenLogicalChannelAck_encryptionSync_present 0x2000
    EncryptionSync encryptionSync;
} OpenLogicalChannelAck;

typedef struct RequestMessage {
    ASN1choice_t choice;
    union {
#	define RequestMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define masterSlaveDetermination_chosen 2
	MasterSlaveDetermination masterSlaveDetermination;
#	define terminalCapabilitySet_chosen 3
	TerminalCapabilitySet terminalCapabilitySet;
#	define openLogicalChannel_chosen 4
	OpenLogicalChannel openLogicalChannel;
#	define closeLogicalChannel_chosen 5
	CloseLogicalChannel closeLogicalChannel;
#	define requestChannelClose_chosen 6
	RequestChannelClose requestChannelClose;
#	define multiplexEntrySend_chosen 7
	MultiplexEntrySend multiplexEntrySend;
#	define requestMultiplexEntry_chosen 8
	RequestMultiplexEntry requestMultiplexEntry;
#	define requestMode_chosen 9
	RequestMode requestMode;
#	define roundTripDelayRequest_chosen 10
	RoundTripDelayRequest roundTripDelayRequest;
#	define maintenanceLoopRequest_chosen 11
	MaintenanceLoopRequest maintenanceLoopRequest;
#	define communicationModeRequest_chosen 12
	CommunicationModeRequest communicationModeRequest;
#	define conferenceRequest_chosen 13
	ConferenceRequest conferenceRequest;
    } u;
} RequestMessage;

typedef struct ResponseMessage {
    ASN1choice_t choice;
    union {
#	define ResponseMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define masterSlaveDeterminationAck_chosen 2
	MasterSlaveDeterminationAck masterSlaveDeterminationAck;
#	define masterSlaveDeterminationReject_chosen 3
	MasterSlaveDeterminationReject masterSlaveDeterminationReject;
#	define terminalCapabilitySetAck_chosen 4
	TerminalCapabilitySetAck terminalCapabilitySetAck;
#	define terminalCapabilitySetReject_chosen 5
	TerminalCapabilitySetReject terminalCapabilitySetReject;
#	define openLogicalChannelAck_chosen 6
	OpenLogicalChannelAck openLogicalChannelAck;
#	define openLogicalChannelReject_chosen 7
	OpenLogicalChannelReject openLogicalChannelReject;
#	define closeLogicalChannelAck_chosen 8
	CloseLogicalChannelAck closeLogicalChannelAck;
#	define requestChannelCloseAck_chosen 9
	RequestChannelCloseAck requestChannelCloseAck;
#	define requestChannelCloseReject_chosen 10
	RequestChannelCloseReject requestChannelCloseReject;
#	define multiplexEntrySendAck_chosen 11
	MultiplexEntrySendAck multiplexEntrySendAck;
#	define multiplexEntrySendReject_chosen 12
	MultiplexEntrySendReject multiplexEntrySendReject;
#	define requestMultiplexEntryAck_chosen 13
	RequestMultiplexEntryAck requestMultiplexEntryAck;
#	define requestMultiplexEntryReject_chosen 14
	RequestMultiplexEntryReject requestMultiplexEntryReject;
#	define requestModeAck_chosen 15
	RequestModeAck requestModeAck;
#	define requestModeReject_chosen 16
	RequestModeReject requestModeReject;
#	define roundTripDelayResponse_chosen 17
	RoundTripDelayResponse roundTripDelayResponse;
#	define maintenanceLoopAck_chosen 18
	MaintenanceLoopAck maintenanceLoopAck;
#	define maintenanceLoopReject_chosen 19
	MaintenanceLoopReject maintenanceLoopReject;
#	define communicationModeResponse_chosen 20
	CommunicationModeResponse communicationModeResponse;
#	define conferenceResponse_chosen 21
	ConferenceResponse conferenceResponse;
    } u;
} ResponseMessage;

typedef OpenLogicalChannel FastConnectOLC;
#define FastConnectOLC_PDU 0
#define SIZE_H245ASN_Module_PDU_0 sizeof(FastConnectOLC)

typedef struct FunctionNotUnderstood {
    ASN1choice_t choice;
    union {
#	define FunctionNotUnderstood_request_chosen 1
	RequestMessage request;
#	define FunctionNotUnderstood_response_chosen 2
	ResponseMessage response;
#	define FunctionNotUnderstood_command_chosen 3
	CommandMessage command;
    } u;
} FunctionNotUnderstood;

typedef struct IndicationMessage {
    ASN1choice_t choice;
    union {
#	define IndicationMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define functionNotUnderstood_chosen 2
	FunctionNotUnderstood functionNotUnderstood;
#	define masterSlaveDeterminationRelease_chosen 3
	MasterSlaveDeterminationRelease masterSlaveDeterminationRelease;
#	define terminalCapabilitySetRelease_chosen 4
	TerminalCapabilitySetRelease terminalCapabilitySetRelease;
#	define openLogicalChannelConfirm_chosen 5
	OpenLogicalChannelConfirm openLogicalChannelConfirm;
#	define requestChannelCloseRelease_chosen 6
	RequestChannelCloseRelease requestChannelCloseRelease;
#	define multiplexEntrySendRelease_chosen 7
	MultiplexEntrySendRelease multiplexEntrySendRelease;
#	define requestMultiplexEntryRelease_chosen 8
	RequestMultiplexEntryRelease requestMultiplexEntryRelease;
#	define requestModeRelease_chosen 9
	RequestModeRelease requestModeRelease;
#	define miscellaneousIndication_chosen 10
	MiscellaneousIndication miscellaneousIndication;
#	define jitterIndication_chosen 11
	JitterIndication jitterIndication;
#	define h223SkewIndication_chosen 12
	H223SkewIndication h223SkewIndication;
#	define newATMVCIndication_chosen 13
	NewATMVCIndication newATMVCIndication;
#	define userInput_chosen 14
	UserInputIndication userInput;
#	define h2250MaximumSkewIndication_chosen 15
	H2250MaximumSkewIndication h2250MaximumSkewIndication;
#	define mcLocationIndication_chosen 16
	MCLocationIndication mcLocationIndication;
#	define conferenceIndication_chosen 17
	ConferenceIndication conferenceIndication;
#	define vendorIdentification_chosen 18
	VendorIdentification vendorIdentification;
#	define IndicationMessage_functionNotSupported_chosen 19
	FunctionNotSupported functionNotSupported;
    } u;
} IndicationMessage;

typedef struct MultimediaSystemControlMessage {
    ASN1choice_t choice;
    union {
#	define MultimediaSystemControlMessage_request_chosen 1
	RequestMessage request;
#	define MultimediaSystemControlMessage_response_chosen 2
	ResponseMessage response;
#	define MultimediaSystemControlMessage_command_chosen 3
	CommandMessage command;
#	define indication_chosen 4
	IndicationMessage indication;
    } u;
} MultimediaSystemControlMessage;
#define MultimediaSystemControlMessage_PDU 1
#define SIZE_H245ASN_Module_PDU_1 sizeof(MultimediaSystemControlMessage)


extern ASN1module_t H245ASN_Module;
extern void ASN1CALL H245ASN_Module_Startup(void);
extern void ASN1CALL H245ASN_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route val);
    extern int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route val);
	extern void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route_ElmFn(PUnicastAddress_iPSourceRouteAddress_route val);
    extern int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
    extern int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
	extern void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
    extern int ASN1CALL ASN1Enc_RedundancyEncodingCapability_secondaryEncoding_ElmFn(ASN1encoding_t enc, PRedundancyEncodingCapability_secondaryEncoding val);
    extern int ASN1CALL ASN1Dec_RedundancyEncodingCapability_secondaryEncoding_ElmFn(ASN1decoding_t dec, PRedundancyEncodingCapability_secondaryEncoding val);
	extern void ASN1CALL ASN1Free_RedundancyEncodingCapability_secondaryEncoding_ElmFn(PRedundancyEncodingCapability_secondaryEncoding val);
    extern int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(ASN1encoding_t enc, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val);
    extern int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(ASN1decoding_t dec, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val);
	extern void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val);
    extern int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(ASN1encoding_t enc, PRequestAllTerminalIDsResponse_terminalInformation val);
    extern int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(ASN1decoding_t dec, PRequestAllTerminalIDsResponse_terminalInformation val);
	extern void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(PRequestAllTerminalIDsResponse_terminalInformation val);
    extern int ASN1CALL ASN1Enc_EncryptionSync_escrowentry_ElmFn(ASN1encoding_t enc, PEncryptionSync_escrowentry val);
    extern int ASN1CALL ASN1Dec_EncryptionSync_escrowentry_ElmFn(ASN1decoding_t dec, PEncryptionSync_escrowentry val);
	extern void ASN1CALL ASN1Free_EncryptionSync_escrowentry_ElmFn(PEncryptionSync_escrowentry val);
    extern int ASN1CALL ASN1Enc_H263Options_customPictureFormat_ElmFn(ASN1encoding_t enc, PH263Options_customPictureFormat val);
    extern int ASN1CALL ASN1Dec_H263Options_customPictureFormat_ElmFn(ASN1decoding_t dec, PH263Options_customPictureFormat val);
	extern void ASN1CALL ASN1Free_H263Options_customPictureFormat_ElmFn(PH263Options_customPictureFormat val);
    extern int ASN1CALL ASN1Enc_H263Options_customPictureClockFrequency_ElmFn(ASN1encoding_t enc, PH263Options_customPictureClockFrequency val);
    extern int ASN1CALL ASN1Dec_H263Options_customPictureClockFrequency_ElmFn(ASN1decoding_t dec, PH263Options_customPictureClockFrequency val);
	extern void ASN1CALL ASN1Free_H263Options_customPictureClockFrequency_ElmFn(PH263Options_customPictureClockFrequency val);
    extern int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability val);
    extern int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability val);
	extern void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability_ElmFn(PMultipointCapability_mediaDistributionCapability val);
    extern int ASN1CALL ASN1Enc_H222Capability_vcCapability_ElmFn(ASN1encoding_t enc, PH222Capability_vcCapability val);
    extern int ASN1CALL ASN1Dec_H222Capability_vcCapability_ElmFn(ASN1decoding_t dec, PH222Capability_vcCapability val);
	extern void ASN1CALL ASN1Free_H222Capability_vcCapability_ElmFn(PH222Capability_vcCapability val);
    extern int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities val);
    extern int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities val);
	extern void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities_ElmFn(PCapabilityDescriptor_simultaneousCapabilities val);
    extern int ASN1CALL ASN1Enc_CertSelectionCriteria_ElmFn(ASN1encoding_t enc, PCertSelectionCriteria val);
    extern int ASN1CALL ASN1Dec_CertSelectionCriteria_ElmFn(ASN1decoding_t dec, PCertSelectionCriteria val);
	extern void ASN1CALL ASN1Free_CertSelectionCriteria_ElmFn(PCertSelectionCriteria val);
    extern int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard val);
    extern int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard val);
	extern void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard_ElmFn(PCommunicationModeTableEntry_nonStandard val);
    extern int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors val);
    extern int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors val);
	extern void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(PMultiplexEntrySend_multiplexEntryDescriptors val);
    extern int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard val);
    extern int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard val);
	extern void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard_ElmFn(PH2250LogicalChannelAckParameters_nonStandard val);
    extern int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard val);
    extern int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard val);
	extern void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard_ElmFn(PH2250LogicalChannelParameters_nonStandard val);
    extern int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData_ElmFn(ASN1encoding_t enc, PConferenceCapability_nonStandardData val);
    extern int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData_ElmFn(ASN1decoding_t dec, PConferenceCapability_nonStandardData val);
	extern void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData_ElmFn(PConferenceCapability_nonStandardData val);
    extern int ASN1CALL ASN1Enc_H263Options_modeCombos_ElmFn(ASN1encoding_t enc, PH263Options_modeCombos val);
    extern int ASN1CALL ASN1Dec_H263Options_modeCombos_ElmFn(ASN1decoding_t dec, PH263Options_modeCombos val);
	extern void ASN1CALL ASN1Free_H263Options_modeCombos_ElmFn(PH263Options_modeCombos val);
    extern int ASN1CALL ASN1Enc_TransportCapability_qOSCapabilities_ElmFn(ASN1encoding_t enc, PTransportCapability_qOSCapabilities val);
    extern int ASN1CALL ASN1Dec_TransportCapability_qOSCapabilities_ElmFn(ASN1decoding_t dec, PTransportCapability_qOSCapabilities val);
	extern void ASN1CALL ASN1Free_TransportCapability_qOSCapabilities_ElmFn(PTransportCapability_qOSCapabilities val);
    extern int ASN1CALL ASN1Enc_EncryptionCapability_ElmFn(ASN1encoding_t enc, PEncryptionCapability val);
    extern int ASN1CALL ASN1Dec_EncryptionCapability_ElmFn(ASN1decoding_t dec, PEncryptionCapability val);
	extern void ASN1CALL ASN1Free_EncryptionCapability_ElmFn(PEncryptionCapability val);
    extern int ASN1CALL ASN1Enc_EnhancementLayerInfo_spatialEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_spatialEnhancement val);
    extern int ASN1CALL ASN1Dec_EnhancementLayerInfo_spatialEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_spatialEnhancement val);
	extern void ASN1CALL ASN1Free_EnhancementLayerInfo_spatialEnhancement_ElmFn(PEnhancementLayerInfo_spatialEnhancement val);
    extern int ASN1CALL ASN1Enc_EnhancementLayerInfo_snrEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_snrEnhancement val);
    extern int ASN1CALL ASN1Dec_EnhancementLayerInfo_snrEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_snrEnhancement val);
	extern void ASN1CALL ASN1Free_EnhancementLayerInfo_snrEnhancement_ElmFn(PEnhancementLayerInfo_snrEnhancement val);
    extern int ASN1CALL ASN1Enc_H2250Capability_redundancyEncodingCapability_ElmFn(ASN1encoding_t enc, PH2250Capability_redundancyEncodingCapability val);
    extern int ASN1CALL ASN1Dec_H2250Capability_redundancyEncodingCapability_ElmFn(ASN1decoding_t dec, PH2250Capability_redundancyEncodingCapability val);
	extern void ASN1CALL ASN1Free_H2250Capability_redundancyEncodingCapability_ElmFn(PH2250Capability_redundancyEncodingCapability val);
    extern int ASN1CALL ASN1Enc_EnhancementLayerInfo_bPictureEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_bPictureEnhancement val);
    extern int ASN1CALL ASN1Dec_EnhancementLayerInfo_bPictureEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_bPictureEnhancement val);
	extern void ASN1CALL ASN1Free_EnhancementLayerInfo_bPictureEnhancement_ElmFn(PEnhancementLayerInfo_bPictureEnhancement val);
    extern int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_distributedData val);
    extern int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_distributedData val);
	extern void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData_ElmFn(PMediaDistributionCapability_distributedData val);
    extern int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData val);
    extern int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData val);
	extern void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData_ElmFn(PMediaDistributionCapability_centralizedData val);
    extern int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable val);
    extern int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable val);
	extern void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable_ElmFn(PCommunicationModeResponse_communicationModeTable val);
    extern int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable val);
    extern int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable val);
	extern void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable_ElmFn(PCommunicationModeCommand_communicationModeTable val);
    extern int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable val);
    extern int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable val);
	extern void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable_ElmFn(PTerminalCapabilitySet_capabilityTable val);
    extern int ASN1CALL ASN1Enc_RequestMode_requestedModes_ElmFn(ASN1encoding_t enc, PRequestMode_requestedModes val);
    extern int ASN1CALL ASN1Dec_RequestMode_requestedModes_ElmFn(ASN1decoding_t dec, PRequestMode_requestedModes val);
	extern void ASN1CALL ASN1Free_RequestMode_requestedModes_ElmFn(PRequestMode_requestedModes val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _H245ASN_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h225asn.h ===
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for H.235 Security Messages v1 (H.235) */
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for Multimedia System Control (H.245) */
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for H.323 Messages v2 (H.225) */

#ifndef _H225ASN_Module_H_
#define _H225ASN_Module_H_

#include "msper.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct InfoRequestResponse_perCallInfo_Seq_substituteConfIDs * PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs;

typedef struct TransportAddress_ipSourceRoute_route * PTransportAddress_ipSourceRoute_route;

typedef struct RTPSession_associatedSessionIds * PRTPSession_associatedSessionIds;

typedef struct GatekeeperRequest_algorithmOIDs * PGatekeeperRequest_algorithmOIDs;

typedef struct Progress_UUIE_fastStart * PProgress_UUIE_fastStart;

typedef struct Facility_UUIE_fastStart * PFacility_UUIE_fastStart;

typedef struct Setup_UUIE_fastStart * PSetup_UUIE_fastStart;

typedef struct Setup_UUIE_destExtraCRV * PSetup_UUIE_destExtraCRV;

typedef struct Connect_UUIE_fastStart * PConnect_UUIE_fastStart;

typedef struct CallProceeding_UUIE_fastStart * PCallProceeding_UUIE_fastStart;

typedef struct Alerting_UUIE_fastStart * PAlerting_UUIE_fastStart;

typedef struct H323_UU_PDU_h245Control * PH323_UU_PDU_h245Control;

typedef struct H323_UU_PDU_h4501SupplementaryService * PH323_UU_PDU_h4501SupplementaryService;

typedef struct InfoRequestResponse_perCallInfo_Seq_tokens * PInfoRequestResponse_perCallInfo_Seq_tokens;

typedef struct ResourcesAvailableConfirm_tokens * PResourcesAvailableConfirm_tokens;

typedef struct ResourcesAvailableIndicate_tokens * PResourcesAvailableIndicate_tokens;

typedef struct RequestInProgress_tokens * PRequestInProgress_tokens;

typedef struct UnknownMessageResponse_tokens * PUnknownMessageResponse_tokens;

typedef struct H225NonStandardMessage_tokens * PH225NonStandardMessage_tokens;

typedef struct InfoRequestNak_tokens * PInfoRequestNak_tokens;

typedef struct InfoRequestAck_tokens * PInfoRequestAck_tokens;

typedef struct InfoRequestResponse_tokens * PInfoRequestResponse_tokens;

typedef struct InfoRequest_tokens * PInfoRequest_tokens;

typedef struct DisengageReject_tokens * PDisengageReject_tokens;

typedef struct DisengageConfirm_tokens * PDisengageConfirm_tokens;

typedef struct DisengageRequest_tokens * PDisengageRequest_tokens;

typedef struct LocationReject_tokens * PLocationReject_tokens;

typedef struct LocationConfirm_tokens * PLocationConfirm_tokens;

typedef struct LocationRequest_tokens * PLocationRequest_tokens;

typedef struct BandwidthReject_tokens * PBandwidthReject_tokens;

typedef struct BandwidthConfirm_tokens * PBandwidthConfirm_tokens;

typedef struct BandwidthRequest_tokens * PBandwidthRequest_tokens;

typedef struct AdmissionReject_tokens * PAdmissionReject_tokens;

typedef struct AdmissionConfirm_tokens * PAdmissionConfirm_tokens;

typedef struct AdmissionRequest_tokens * PAdmissionRequest_tokens;

typedef struct UnregistrationReject_tokens * PUnregistrationReject_tokens;

typedef struct UnregistrationConfirm_tokens * PUnregistrationConfirm_tokens;

typedef struct UnregistrationRequest_tokens * PUnregistrationRequest_tokens;

typedef struct RegistrationReject_tokens * PRegistrationReject_tokens;

typedef struct RegistrationConfirm_tokens * PRegistrationConfirm_tokens;

typedef struct RegistrationRequest_tokens * PRegistrationRequest_tokens;

typedef struct GatekeeperReject_tokens * PGatekeeperReject_tokens;

typedef struct GatekeeperConfirm_tokens * PGatekeeperConfirm_tokens;

typedef struct GatekeeperRequest_authenticationCapability * PGatekeeperRequest_authenticationCapability;

typedef struct GatekeeperRequest_tokens * PGatekeeperRequest_tokens;

typedef struct Endpoint_tokens * PEndpoint_tokens;

typedef struct Progress_UUIE_tokens * PProgress_UUIE_tokens;

typedef struct Facility_UUIE_tokens * PFacility_UUIE_tokens;

typedef struct Setup_UUIE_tokens * PSetup_UUIE_tokens;

typedef struct Connect_UUIE_tokens * PConnect_UUIE_tokens;

typedef struct CallProceeding_UUIE_tokens * PCallProceeding_UUIE_tokens;

typedef struct Alerting_UUIE_tokens * PAlerting_UUIE_tokens;

typedef struct GatekeeperConfirm_integrity * PGatekeeperConfirm_integrity;

typedef struct GatekeeperRequest_integrity * PGatekeeperRequest_integrity;

typedef struct NonStandardProtocol_dataRatesSupported * PNonStandardProtocol_dataRatesSupported;

typedef struct T120OnlyCaps_dataRatesSupported * PT120OnlyCaps_dataRatesSupported;

typedef struct VoiceCaps_dataRatesSupported * PVoiceCaps_dataRatesSupported;

typedef struct H324Caps_dataRatesSupported * PH324Caps_dataRatesSupported;

typedef struct H323Caps_dataRatesSupported * PH323Caps_dataRatesSupported;

typedef struct H322Caps_dataRatesSupported * PH322Caps_dataRatesSupported;

typedef struct H321Caps_dataRatesSupported * PH321Caps_dataRatesSupported;

typedef struct H320Caps_dataRatesSupported * PH320Caps_dataRatesSupported;

typedef struct H310Caps_dataRatesSupported * PH310Caps_dataRatesSupported;

typedef struct Setup_UUIE_h245SecurityCapability * PSetup_UUIE_h245SecurityCapability;

typedef struct H323_UU_PDU_nonStandardControl * PH323_UU_PDU_nonStandardControl;

typedef struct InfoRequestResponse_perCallInfo_Seq_data * PInfoRequestResponse_perCallInfo_Seq_data;

typedef struct InfoRequestResponse_perCallInfo_Seq_video * PInfoRequestResponse_perCallInfo_Seq_video;

typedef struct InfoRequestResponse_perCallInfo_Seq_audio * PInfoRequestResponse_perCallInfo_Seq_audio;

typedef struct InfoRequestResponse_perCallInfo * PInfoRequestResponse_perCallInfo;

typedef struct InfoRequestResponse_callSignalAddress * PInfoRequestResponse_callSignalAddress;

typedef struct AdmissionReject_callSignalAddress * PAdmissionReject_callSignalAddress;

typedef struct UnregistrationRequest_callSignalAddress * PUnregistrationRequest_callSignalAddress;

typedef struct RegistrationConfirm_alternateGatekeeper * PRegistrationConfirm_alternateGatekeeper;

typedef struct RegistrationConfirm_callSignalAddress * PRegistrationConfirm_callSignalAddress;

typedef struct RegistrationRequest_rasAddress * PRegistrationRequest_rasAddress;

typedef struct RegistrationRequest_callSignalAddress * PRegistrationRequest_callSignalAddress;

typedef struct GatekeeperConfirm_alternateGatekeeper * PGatekeeperConfirm_alternateGatekeeper;

typedef struct AltGKInfo_alternateGatekeeper * PAltGKInfo_alternateGatekeeper;

typedef struct Endpoint_rasAddress * PEndpoint_rasAddress;

typedef struct Endpoint_callSignalAddress * PEndpoint_callSignalAddress;

typedef struct ResourcesAvailableIndicate_protocols * PResourcesAvailableIndicate_protocols;

typedef struct InfoRequestResponse_endpointAlias * PInfoRequestResponse_endpointAlias;

typedef struct LocationConfirm_alternateEndpoints * PLocationConfirm_alternateEndpoints;

typedef struct LocationConfirm_remoteExtensionAddress * PLocationConfirm_remoteExtensionAddress;

typedef struct LocationConfirm_destExtraCallInfo * PLocationConfirm_destExtraCallInfo;

typedef struct LocationConfirm_destinationInfo * PLocationConfirm_destinationInfo;

typedef struct LocationRequest_sourceInfo * PLocationRequest_sourceInfo;

typedef struct LocationRequest_destinationInfo * PLocationRequest_destinationInfo;

typedef struct AdmissionConfirm_alternateEndpoints * PAdmissionConfirm_alternateEndpoints;

typedef struct AdmissionConfirm_remoteExtensionAddress * PAdmissionConfirm_remoteExtensionAddress;

typedef struct AdmissionConfirm_destExtraCallInfo * PAdmissionConfirm_destExtraCallInfo;

typedef struct AdmissionConfirm_destinationInfo * PAdmissionConfirm_destinationInfo;

typedef struct AdmissionRequest_destAlternatives * PAdmissionRequest_destAlternatives;

typedef struct AdmissionRequest_srcAlternatives * PAdmissionRequest_srcAlternatives;

typedef struct AdmissionRequest_srcInfo * PAdmissionRequest_srcInfo;

typedef struct AdmissionRequest_destExtraCallInfo * PAdmissionRequest_destExtraCallInfo;

typedef struct AdmissionRequest_destinationInfo * PAdmissionRequest_destinationInfo;

typedef struct UnregistrationRequest_alternateEndpoints * PUnregistrationRequest_alternateEndpoints;

typedef struct UnregistrationRequest_endpointAlias * PUnregistrationRequest_endpointAlias;

typedef struct RegistrationRejectReason_duplicateAlias * PRegistrationRejectReason_duplicateAlias;

typedef struct RegistrationConfirm_terminalAlias * PRegistrationConfirm_terminalAlias;

typedef struct RegistrationRequest_alternateEndpoints * PRegistrationRequest_alternateEndpoints;

typedef struct RegistrationRequest_terminalAlias * PRegistrationRequest_terminalAlias;

typedef struct GatekeeperRequest_alternateEndpoints * PGatekeeperRequest_alternateEndpoints;

typedef struct GatekeeperRequest_endpointAlias * PGatekeeperRequest_endpointAlias;

typedef struct Endpoint_destExtraCallInfo * PEndpoint_destExtraCallInfo;

typedef struct Endpoint_remoteExtensionAddress * PEndpoint_remoteExtensionAddress;

typedef struct Endpoint_aliasAddress * PEndpoint_aliasAddress;

typedef struct NonStandardProtocol_supportedPrefixes * PNonStandardProtocol_supportedPrefixes;

typedef struct T120OnlyCaps_supportedPrefixes * PT120OnlyCaps_supportedPrefixes;

typedef struct VoiceCaps_supportedPrefixes * PVoiceCaps_supportedPrefixes;

typedef struct H324Caps_supportedPrefixes * PH324Caps_supportedPrefixes;

typedef struct H323Caps_supportedPrefixes * PH323Caps_supportedPrefixes;

typedef struct H322Caps_supportedPrefixes * PH322Caps_supportedPrefixes;

typedef struct H321Caps_supportedPrefixes * PH321Caps_supportedPrefixes;

typedef struct H320Caps_supportedPrefixes * PH320Caps_supportedPrefixes;

typedef struct H310Caps_supportedPrefixes * PH310Caps_supportedPrefixes;

typedef struct GatewayInfo_protocol * PGatewayInfo_protocol;

typedef struct Facility_UUIE_destExtraCallInfo * PFacility_UUIE_destExtraCallInfo;

typedef struct Facility_UUIE_alternativeAliasAddress * PFacility_UUIE_alternativeAliasAddress;

typedef struct Setup_UUIE_destExtraCallInfo * PSetup_UUIE_destExtraCallInfo;

typedef struct Setup_UUIE_destinationAddress * PSetup_UUIE_destinationAddress;

typedef struct Setup_UUIE_sourceAddress * PSetup_UUIE_sourceAddress;

typedef struct InfoRequestResponse_perCallInfo_Seq_cryptoTokens * PInfoRequestResponse_perCallInfo_Seq_cryptoTokens;

typedef struct ResourcesAvailableConfirm_cryptoTokens * PResourcesAvailableConfirm_cryptoTokens;

typedef struct ResourcesAvailableIndicate_cryptoTokens * PResourcesAvailableIndicate_cryptoTokens;

typedef struct RequestInProgress_cryptoTokens * PRequestInProgress_cryptoTokens;

typedef struct UnknownMessageResponse_cryptoTokens * PUnknownMessageResponse_cryptoTokens;

typedef struct H225NonStandardMessage_cryptoTokens * PH225NonStandardMessage_cryptoTokens;

typedef struct InfoRequestNak_cryptoTokens * PInfoRequestNak_cryptoTokens;

typedef struct InfoRequestAck_cryptoTokens * PInfoRequestAck_cryptoTokens;

typedef struct InfoRequestResponse_cryptoTokens * PInfoRequestResponse_cryptoTokens;

typedef struct InfoRequest_cryptoTokens * PInfoRequest_cryptoTokens;

typedef struct DisengageReject_cryptoTokens * PDisengageReject_cryptoTokens;

typedef struct DisengageConfirm_cryptoTokens * PDisengageConfirm_cryptoTokens;

typedef struct DisengageRequest_cryptoTokens * PDisengageRequest_cryptoTokens;

typedef struct LocationReject_cryptoTokens * PLocationReject_cryptoTokens;

typedef struct LocationConfirm_cryptoTokens * PLocationConfirm_cryptoTokens;

typedef struct LocationRequest_cryptoTokens * PLocationRequest_cryptoTokens;

typedef struct BandwidthReject_cryptoTokens * PBandwidthReject_cryptoTokens;

typedef struct BandwidthConfirm_cryptoTokens * PBandwidthConfirm_cryptoTokens;

typedef struct BandwidthRequest_cryptoTokens * PBandwidthRequest_cryptoTokens;

typedef struct AdmissionReject_cryptoTokens * PAdmissionReject_cryptoTokens;

typedef struct AdmissionConfirm_cryptoTokens * PAdmissionConfirm_cryptoTokens;

typedef struct AdmissionRequest_cryptoTokens * PAdmissionRequest_cryptoTokens;

typedef struct UnregistrationReject_cryptoTokens * PUnregistrationReject_cryptoTokens;

typedef struct UnregistrationConfirm_cryptoTokens * PUnregistrationConfirm_cryptoTokens;

typedef struct UnregistrationRequest_cryptoTokens * PUnregistrationRequest_cryptoTokens;

typedef struct RegistrationReject_cryptoTokens * PRegistrationReject_cryptoTokens;

typedef struct RegistrationConfirm_cryptoTokens * PRegistrationConfirm_cryptoTokens;

typedef struct RegistrationRequest_cryptoTokens * PRegistrationRequest_cryptoTokens;

typedef struct GatekeeperReject_cryptoTokens * PGatekeeperReject_cryptoTokens;

typedef struct GatekeeperConfirm_cryptoTokens * PGatekeeperConfirm_cryptoTokens;

typedef struct GatekeeperRequest_cryptoTokens * PGatekeeperRequest_cryptoTokens;

typedef struct Endpoint_cryptoTokens * PEndpoint_cryptoTokens;

typedef struct Progress_UUIE_cryptoTokens * PProgress_UUIE_cryptoTokens;

typedef struct Facility_UUIE_conferences * PFacility_UUIE_conferences;

typedef struct Facility_UUIE_cryptoTokens * PFacility_UUIE_cryptoTokens;

typedef struct Setup_UUIE_cryptoTokens * PSetup_UUIE_cryptoTokens;

typedef struct Connect_UUIE_cryptoTokens * PConnect_UUIE_cryptoTokens;

typedef struct CallProceeding_UUIE_cryptoTokens * PCallProceeding_UUIE_cryptoTokens;

typedef struct Alerting_UUIE_cryptoTokens * PAlerting_UUIE_cryptoTokens;

typedef struct InfoRequestResponse_perCallInfo_Seq_pdu * PInfoRequestResponse_perCallInfo_Seq_pdu;

typedef struct TransportAddress_ipSourceRoute_route_Seq {
    ASN1uint32_t length;
    ASN1octet_t value[4];
} TransportAddress_ipSourceRoute_route_Seq;

typedef ASN1octetstring_t H323_UU_PDU_h4501SupplementaryService_Seq;

typedef ASN1octetstring_t H323_UU_PDU_h245Control_Seq;

typedef ASN1octetstring_t Alerting_UUIE_fastStart_Seq;

typedef ASN1octetstring_t CallProceeding_UUIE_fastStart_Seq;

typedef ASN1octetstring_t Connect_UUIE_fastStart_Seq;

typedef ASN1octetstring_t Setup_UUIE_fastStart_Seq;

typedef ASN1octetstring_t Facility_UUIE_fastStart_Seq;

typedef ASN1octetstring_t Progress_UUIE_fastStart_Seq;

typedef ASN1objectidentifier_t GatekeeperRequest_algorithmOIDs_Seq;

typedef ASN1uint16_t RTPSession_associatedSessionIds_Seq;

typedef struct ChallengeString {
    ASN1uint32_t length;
    ASN1octet_t value[128];
} ChallengeString;

typedef ASN1uint32_t TimeStamp;

typedef ASN1int32_t RandomVal;

typedef ASN1char16string_t Password;

typedef ASN1char16string_t Identifier;

typedef struct IV8 {
    ASN1uint32_t length;
    ASN1octet_t value[8];
} IV8;

typedef ASN1char_t NumberDigits[129];

typedef struct GloballyUniqueID {
    ASN1uint32_t length;
    ASN1octet_t value[16];
} GloballyUniqueID;

typedef GloballyUniqueID ConferenceIdentifier;

typedef ASN1uint16_t RequestSeqNum;

typedef ASN1char16string_t GatekeeperIdentifier;

typedef ASN1uint32_t BandWidth;

typedef ASN1uint16_t CallReferenceValue;

typedef ASN1char16string_t EndpointIdentifier;

typedef ASN1objectidentifier_t ProtocolIdentifier;

typedef ASN1uint32_t TimeToLive;

typedef struct InfoRequestResponse_perCallInfo_Seq_substituteConfIDs {
    PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs next;
    ConferenceIdentifier value;
} InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_Element;

typedef struct TransportAddress_ipSourceRoute_routing {
    ASN1choice_t choice;
#   define TransportAddress_ipSourceRoute_routing_strict_chosen 1
#   define TransportAddress_ipSourceRoute_routing_loose_chosen 2
} TransportAddress_ipSourceRoute_routing;

typedef struct TransportAddress_ipSourceRoute_route {
    PTransportAddress_ipSourceRoute_route next;
    TransportAddress_ipSourceRoute_route_Seq value;
} TransportAddress_ipSourceRoute_route_Element;

typedef struct RTPSession_associatedSessionIds {
    PRTPSession_associatedSessionIds next;
    RTPSession_associatedSessionIds_Seq value;
} RTPSession_associatedSessionIds_Element;

typedef struct RegistrationConfirm_preGrantedARQ {
    ASN1bool_t makeCall;
    ASN1bool_t useGKCallSignalAddressToMakeCall;
    ASN1bool_t answerCall;
    ASN1bool_t useGKCallSignalAddressToAnswer;
} RegistrationConfirm_preGrantedARQ;

typedef struct GatekeeperRequest_algorithmOIDs {
    PGatekeeperRequest_algorithmOIDs next;
    GatekeeperRequest_algorithmOIDs_Seq value;
} GatekeeperRequest_algorithmOIDs_Element;

typedef struct TransportAddress_ip6Address {
    struct TransportAddress_ip6Address_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } ip;
    ASN1uint16_t port;
} TransportAddress_ip6Address;

typedef struct TransportAddress_ipxAddress {
    struct TransportAddress_ipxAddress_node_node {
	ASN1uint32_t length;
	ASN1octet_t value[6];
    } node;
    struct TransportAddress_ipxAddress_netnum_netnum {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } netnum;
    struct TransportAddress_ipxAddress_port_port {
	ASN1uint32_t length;
	ASN1octet_t value[2];
    } port;
} TransportAddress_ipxAddress;

typedef struct TransportAddress_ipSourceRoute {
    struct TransportAddress_ipSourceRoute_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } ip;
    ASN1uint16_t port;
    PTransportAddress_ipSourceRoute_route route;
    TransportAddress_ipSourceRoute_routing routing;
} TransportAddress_ipSourceRoute;

typedef struct TransportAddress_ipAddress {
    struct TransportAddress_ipAddress_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } ip;
    ASN1uint16_t port;
} TransportAddress_ipAddress;

typedef struct Progress_UUIE_fastStart {
    PProgress_UUIE_fastStart next;
    Progress_UUIE_fastStart_Seq value;
} Progress_UUIE_fastStart_Element;

typedef struct Facility_UUIE_fastStart {
    PFacility_UUIE_fastStart next;
    Facility_UUIE_fastStart_Seq value;
} Facility_UUIE_fastStart_Element;

typedef struct Setup_UUIE_fastStart {
    PSetup_UUIE_fastStart next;
    Setup_UUIE_fastStart_Seq value;
} Setup_UUIE_fastStart_Element;

typedef struct Setup_UUIE_conferenceGoal {
    ASN1choice_t choice;
#   define create_chosen 1
#   define join_chosen 2
#   define invite_chosen 3
#   define capability_negotiation_chosen 4
#   define callIndependentSupplementaryService_chosen 5
} Setup_UUIE_conferenceGoal;

typedef struct Setup_UUIE_destExtraCRV {
    PSetup_UUIE_destExtraCRV next;
    CallReferenceValue value;
} Setup_UUIE_destExtraCRV_Element;

typedef struct Connect_UUIE_fastStart {
    PConnect_UUIE_fastStart next;
    Connect_UUIE_fastStart_Seq value;
} Connect_UUIE_fastStart_Element;

typedef struct CallProceeding_UUIE_fastStart {
    PCallProceeding_UUIE_fastStart next;
    CallProceeding_UUIE_fastStart_Seq value;
} CallProceeding_UUIE_fastStart_Element;

typedef struct Alerting_UUIE_fastStart {
    PAlerting_UUIE_fastStart next;
    Alerting_UUIE_fastStart_Seq value;
} Alerting_UUIE_fastStart_Element;

typedef struct H323_UU_PDU_h245Control {
    PH323_UU_PDU_h245Control next;
    H323_UU_PDU_h245Control_Seq value;
} H323_UU_PDU_h245Control_Element;

typedef struct H323_UU_PDU_h4501SupplementaryService {
    PH323_UU_PDU_h4501SupplementaryService next;
    H323_UU_PDU_h4501SupplementaryService_Seq value;
} H323_UU_PDU_h4501SupplementaryService_Element;

typedef struct H323_UserInformation_user_data {
    ASN1uint16_t protocol_discriminator;
    struct H323_UserInformation_user_data_user_information_user_information {
	ASN1uint32_t length;
	ASN1octet_t value[131];
    } user_information;
} H323_UserInformation_user_data;

typedef struct H235NonStandardParameter {
    ASN1objectidentifier_t nonStandardIdentifier;
    ASN1octetstring_t data;
} H235NonStandardParameter;

typedef struct DHset {
    ASN1bitstring_t halfkey;
    ASN1bitstring_t modSize;
    ASN1bitstring_t generator;
} DHset;

typedef struct TypedCertificate {
    ASN1objectidentifier_t type;
    ASN1octetstring_t certificate;
} TypedCertificate;

typedef struct AuthenticationMechanism {
    ASN1choice_t choice;
    union {
#	define dhExch_chosen 1
#	define pwdSymEnc_chosen 2
#	define pwdHash_chosen 3
#	define certSign_chosen 4
#	define AuthenticationMechanism_ipsec_chosen 5
#	define AuthenticationMechanism_tls_chosen 6
#	define AuthenticationMechanism_nonStandard_chosen 7
	H235NonStandardParameter nonStandard;
    } u;
} AuthenticationMechanism;

typedef struct ClearToken {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1objectidentifier_t tokenOID;
#   define ClearToken_timeStamp_present 0x80
    TimeStamp timeStamp;
#   define password_present 0x40
    Password password;
#   define dhkey_present 0x20
    DHset dhkey;
#   define challenge_present 0x10
    ChallengeString challenge;
#   define random_present 0x8
    RandomVal random;
#   define ClearToken_certificate_present 0x4
    TypedCertificate certificate;
#   define generalID_present 0x2
    Identifier generalID;
#   define ClearToken_nonStandard_present 0x1
    H235NonStandardParameter nonStandard;
} ClearToken;

typedef struct Params {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ranInt_present 0x80
    ASN1int32_t ranInt;
#   define iv8_present 0x40
    IV8 iv8;
} Params;

typedef struct EncodedGeneralToken {
    ASN1objectidentifier_t id;
    ClearToken type;
} EncodedGeneralToken;

typedef ClearToken PwdCertToken;

typedef struct EncodedPwdCertToken {
    ASN1objectidentifier_t id;
    PwdCertToken type;
} EncodedPwdCertToken;

typedef struct ReleaseCompleteReason {
    ASN1choice_t choice;
#   define noBandwidth_chosen 1
#   define gatekeeperResources_chosen 2
#   define unreachableDestination_chosen 3
#   define destinationRejection_chosen 4
#   define ReleaseCompleteReason_invalidRevision_chosen 5
#   define noPermission_chosen 6
#   define unreachableGatekeeper_chosen 7
#   define gatewayResources_chosen 8
#   define badFormatAddress_chosen 9
#   define adaptiveBusy_chosen 10
#   define inConf_chosen 11
#   define ReleaseCompleteReason_undefinedReason_chosen 12
#   define facilityCallDeflection_chosen 13
#   define securityDenied_chosen 14
#   define ReleaseCompleteReason_calledPartyNotRegistered_chosen 15
#   define ReleaseCompleteReason_callerNotRegistered_chosen 16
} ReleaseCompleteReason;

typedef struct FacilityReason {
    ASN1choice_t choice;
#   define FacilityReason_routeCallToGatekeeper_chosen 1
#   define callForwarded_chosen 2
#   define routeCallToMC_chosen 3
#   define FacilityReason_undefinedReason_chosen 4
#   define conferenceListChoice_chosen 5
#   define startH245_chosen 6
} FacilityReason;

typedef struct H221NonStandard {
    ASN1uint16_t t35CountryCode;
    ASN1uint16_t t35Extension;
    ASN1uint16_t manufacturerCode;
} H221NonStandard;

typedef struct H225NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define H225NonStandardIdentifier_object_chosen 1
	ASN1objectidentifier_t object;
#	define H225NonStandardIdentifier_h221NonStandard_chosen 2
	H221NonStandard h221NonStandard;
    } u;
} H225NonStandardIdentifier;

typedef struct PublicTypeOfNumber {
    ASN1choice_t choice;
#   define PublicTypeOfNumber_unknown_chosen 1
#   define PublicTypeOfNumber_internationalNumber_chosen 2
#   define nationalNumber_chosen 3
#   define networkSpecificNumber_chosen 4
#   define subscriberNumber_chosen 5
#   define PublicTypeOfNumber_abbreviatedNumber_chosen 6
} PublicTypeOfNumber;

typedef struct PrivateTypeOfNumber {
    ASN1choice_t choice;
#   define PrivateTypeOfNumber_unknown_chosen 1
#   define level2RegionalNumber_chosen 2
#   define level1RegionalNumber_chosen 3
#   define pISNSpecificNumber_chosen 4
#   define localNumber_chosen 5
#   define PrivateTypeOfNumber_abbreviatedNumber_chosen 6
} PrivateTypeOfNumber;

typedef struct AltGKInfo {
    PAltGKInfo_alternateGatekeeper alternateGatekeeper;
    ASN1bool_t altGKisPermanent;
} AltGKInfo;

typedef struct Q954Details {
    ASN1bool_t conferenceCalling;
    ASN1bool_t threePartyService;
} Q954Details;

typedef struct CallIdentifier {
    GloballyUniqueID guid;
} CallIdentifier;

typedef struct ICV {
    ASN1objectidentifier_t algorithmOID;
    ASN1bitstring_t icv;
} ICV;

typedef struct GatekeeperRejectReason {
    ASN1choice_t choice;
#   define GatekeeperRejectReason_resourceUnavailable_chosen 1
#   define terminalExcluded_chosen 2
#   define GatekeeperRejectReason_invalidRevision_chosen 3
#   define GatekeeperRejectReason_undefinedReason_chosen 4
#   define GatekeeperRejectReason_securityDenial_chosen 5
} GatekeeperRejectReason;

typedef struct RegistrationRejectReason {
    ASN1choice_t choice;
    union {
#	define discoveryRequired_chosen 1
#	define RegistrationRejectReason_invalidRevision_chosen 2
#	define invalidCallSignalAddress_chosen 3
#	define invalidRASAddress_chosen 4
#	define duplicateAlias_chosen 5
	PRegistrationRejectReason_duplicateAlias duplicateAlias;
#	define invalidTerminalType_chosen 6
#	define RegistrationRejectReason_undefinedReason_chosen 7
#	define transportNotSupported_chosen 8
#	define transportQOSNotSupported_chosen 9
#	define RegistrationRejectReason_resourceUnavailable_chosen 10
#	define invalidAlias_chosen 11
#	define RegistrationRejectReason_securityDenial_chosen 12
    } u;
} RegistrationRejectReason;

typedef struct UnregRequestReason {
    ASN1choice_t choice;
#   define reregistrationRequired_chosen 1
#   define ttlExpired_chosen 2
#   define UnregRequestReason_securityDenial_chosen 3
#   define UnregRequestReason_undefinedReason_chosen 4
} UnregRequestReason;

typedef struct UnregRejectReason {
    ASN1choice_t choice;
#   define notCurrentlyRegistered_chosen 1
#   define callInProgress_chosen 2
#   define UnregRejectReason_undefinedReason_chosen 3
#   define permissionDenied_chosen 4
#   define UnregRejectReason_securityDenial_chosen 5
} UnregRejectReason;

typedef struct CallType {
    ASN1choice_t choice;
#   define pointToPoint_chosen 1
#   define oneToN_chosen 2
#   define nToOne_chosen 3
#   define nToN_chosen 4
} CallType;

typedef struct CallModel {
    ASN1choice_t choice;
#   define direct_chosen 1
#   define gatekeeperRouted_chosen 2
} CallModel;

typedef struct TransportQOS {
    ASN1choice_t choice;
#   define endpointControlled_chosen 1
#   define gatekeeperControlled_chosen 2
#   define noControl_chosen 3
} TransportQOS;

typedef struct UUIEsRequested {
    ASN1bool_t setup;
    ASN1bool_t callProceeding;
    ASN1bool_t connect;
    ASN1bool_t alerting;
    ASN1bool_t information;
    ASN1bool_t releaseComplete;
    ASN1bool_t facility;
    ASN1bool_t progress;
    ASN1bool_t empty;
} UUIEsRequested;

typedef struct AdmissionRejectReason {
    ASN1choice_t choice;
#   define AdmissionRejectReason_calledPartyNotRegistered_chosen 1
#   define AdmissionRejectReason_invalidPermission_chosen 2
#   define AdmissionRejectReason_requestDenied_chosen 3
#   define AdmissionRejectReason_undefinedReason_chosen 4
#   define AdmissionRejectReason_callerNotRegistered_chosen 5
#   define AdmissionRejectReason_routeCallToGatekeeper_chosen 6
#   define invalidEndpointIdentifier_chosen 7
#   define AdmissionRejectReason_resourceUnavailable_chosen 8
#   define AdmissionRejectReason_securityDenial_chosen 9
#   define qosControlNotSupported_chosen 10
#   define incompleteAddress_chosen 11
} AdmissionRejectReason;

typedef struct BandRejectReason {
    ASN1choice_t choice;
#   define notBound_chosen 1
#   define invalidConferenceID_chosen 2
#   define BandRejectReason_invalidPermission_chosen 3
#   define insufficientResources_chosen 4
#   define BandRejectReason_invalidRevision_chosen 5
#   define BandRejectReason_undefinedReason_chosen 6
#   define BandRejectReason_securityDenial_chosen 7
} BandRejectReason;

typedef struct LocationRejectReason {
    ASN1choice_t choice;
#   define LocationRejectReason_notRegistered_chosen 1
#   define LocationRejectReason_invalidPermission_chosen 2
#   define LocationRejectReason_requestDenied_chosen 3
#   define LocationRejectReason_undefinedReason_chosen 4
#   define LocationRejectReason_securityDenial_chosen 5
} LocationRejectReason;

typedef struct DisengageReason {
    ASN1choice_t choice;
#   define forcedDrop_chosen 1
#   define normalDrop_chosen 2
#   define DisengageReason_undefinedReason_chosen 3
} DisengageReason;

typedef struct DisengageRejectReason {
    ASN1choice_t choice;
#   define DisengageRejectReason_notRegistered_chosen 1
#   define requestToDropOther_chosen 2
#   define DisengageRejectReason_securityDenial_chosen 3
} DisengageRejectReason;

typedef struct InfoRequestNakReason {
    ASN1choice_t choice;
#   define InfoRequestNakReason_notRegistered_chosen 1
#   define InfoRequestNakReason_securityDenial_chosen 2
#   define InfoRequestNakReason_undefinedReason_chosen 3
} InfoRequestNakReason;

typedef struct UnknownMessageResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
#   define UnknownMessageResponse_tokens_present 0x80
    PUnknownMessageResponse_tokens tokens;
#   define UnknownMessageResponse_cryptoTokens_present 0x40
    PUnknownMessageResponse_cryptoTokens cryptoTokens;
#   define UnknownMessageResponse_integrityCheckValue_present 0x20
    ICV integrityCheckValue;
} UnknownMessageResponse;

typedef struct InfoRequestResponse_perCallInfo_Seq_tokens {
    PInfoRequestResponse_perCallInfo_Seq_tokens next;
    ClearToken value;
} InfoRequestResponse_perCallInfo_Seq_tokens_Element;

typedef struct ResourcesAvailableConfirm_tokens {
    PResourcesAvailableConfirm_tokens next;
    ClearToken value;
} ResourcesAvailableConfirm_tokens_Element;

typedef struct ResourcesAvailableIndicate_tokens {
    PResourcesAvailableIndicate_tokens next;
    ClearToken value;
} ResourcesAvailableIndicate_tokens_Element;

typedef struct RequestInProgress_tokens {
    PRequestInProgress_tokens next;
    ClearToken value;
} RequestInProgress_tokens_Element;

typedef struct UnknownMessageResponse_tokens {
    PUnknownMessageResponse_tokens next;
    ClearToken value;
} UnknownMessageResponse_tokens_Element;

typedef struct H225NonStandardMessage_tokens {
    PH225NonStandardMessage_tokens next;
    ClearToken value;
} H225NonStandardMessage_tokens_Element;

typedef struct InfoRequestNak_tokens {
    PInfoRequestNak_tokens next;
    ClearToken value;
} InfoRequestNak_tokens_Element;

typedef struct InfoRequestAck_tokens {
    PInfoRequestAck_tokens next;
    ClearToken value;
} InfoRequestAck_tokens_Element;

typedef struct InfoRequestResponse_tokens {
    PInfoRequestResponse_tokens next;
    ClearToken value;
} InfoRequestResponse_tokens_Element;

typedef struct InfoRequest_tokens {
    PInfoRequest_tokens next;
    ClearToken value;
} InfoRequest_tokens_Element;

typedef struct DisengageReject_tokens {
    PDisengageReject_tokens next;
    ClearToken value;
} DisengageReject_tokens_Element;

typedef struct DisengageConfirm_tokens {
    PDisengageConfirm_tokens next;
    ClearToken value;
} DisengageConfirm_tokens_Element;

typedef struct DisengageRequest_tokens {
    PDisengageRequest_tokens next;
    ClearToken value;
} DisengageRequest_tokens_Element;

typedef struct LocationReject_tokens {
    PLocationReject_tokens next;
    ClearToken value;
} LocationReject_tokens_Element;

typedef struct LocationConfirm_tokens {
    PLocationConfirm_tokens next;
    ClearToken value;
} LocationConfirm_tokens_Element;

typedef struct LocationRequest_tokens {
    PLocationRequest_tokens next;
    ClearToken value;
} LocationRequest_tokens_Element;

typedef struct BandwidthReject_tokens {
    PBandwidthReject_tokens next;
    ClearToken value;
} BandwidthReject_tokens_Element;

typedef struct BandwidthConfirm_tokens {
    PBandwidthConfirm_tokens next;
    ClearToken value;
} BandwidthConfirm_tokens_Element;

typedef struct BandwidthRequest_tokens {
    PBandwidthRequest_tokens next;
    ClearToken value;
} BandwidthRequest_tokens_Element;

typedef struct AdmissionReject_tokens {
    PAdmissionReject_tokens next;
    ClearToken value;
} AdmissionReject_tokens_Element;

typedef struct AdmissionConfirm_tokens {
    PAdmissionConfirm_tokens next;
    ClearToken value;
} AdmissionConfirm_tokens_Element;

typedef struct AdmissionRequest_tokens {
    PAdmissionRequest_tokens next;
    ClearToken value;
} AdmissionRequest_tokens_Element;

typedef struct UnregistrationReject_tokens {
    PUnregistrationReject_tokens next;
    ClearToken value;
} UnregistrationReject_tokens_Element;

typedef struct UnregistrationConfirm_tokens {
    PUnregistrationConfirm_tokens next;
    ClearToken value;
} UnregistrationConfirm_tokens_Element;

typedef struct UnregistrationRequest_tokens {
    PUnregistrationRequest_tokens next;
    ClearToken value;
} UnregistrationRequest_tokens_Element;

typedef struct RegistrationReject_tokens {
    PRegistrationReject_tokens next;
    ClearToken value;
} RegistrationReject_tokens_Element;

typedef struct RegistrationConfirm_tokens {
    PRegistrationConfirm_tokens next;
    ClearToken value;
} RegistrationConfirm_tokens_Element;

typedef struct RegistrationRequest_tokens {
    PRegistrationRequest_tokens next;
    ClearToken value;
} RegistrationRequest_tokens_Element;

typedef struct GatekeeperReject_tokens {
    PGatekeeperReject_tokens next;
    ClearToken value;
} GatekeeperReject_tokens_Element;

typedef struct GatekeeperConfirm_tokens {
    PGatekeeperConfirm_tokens next;
    ClearToken value;
} GatekeeperConfirm_tokens_Element;

typedef struct GatekeeperRequest_authenticationCapability {
    PGatekeeperRequest_authenticationCapability next;
    AuthenticationMechanism value;
} GatekeeperRequest_authenticationCapability_Element;

typedef struct GatekeeperRequest_tokens {
    PGatekeeperRequest_tokens next;
    ClearToken value;
} GatekeeperRequest_tokens_Element;

typedef struct Endpoint_tokens {
    PEndpoint_tokens next;
    ClearToken value;
} Endpoint_tokens_Element;

typedef struct Progress_UUIE_tokens {
    PProgress_UUIE_tokens next;
    ClearToken value;
} Progress_UUIE_tokens_Element;

typedef struct Facility_UUIE_tokens {
    PFacility_UUIE_tokens next;
    ClearToken value;
} Facility_UUIE_tokens_Element;

typedef struct Setup_UUIE_tokens {
    PSetup_UUIE_tokens next;
    ClearToken value;
} Setup_UUIE_tokens_Element;

typedef struct Connect_UUIE_tokens {
    PConnect_UUIE_tokens next;
    ClearToken value;
} Connect_UUIE_tokens_Element;

typedef struct CallProceeding_UUIE_tokens {
    PCallProceeding_UUIE_tokens next;
    ClearToken value;
} CallProceeding_UUIE_tokens_Element;

typedef struct Alerting_UUIE_tokens {
    PAlerting_UUIE_tokens next;
    ClearToken value;
} Alerting_UUIE_tokens_Element;

typedef struct SIGNED_EncodedGeneralToken {
    EncodedGeneralToken toBeSigned;
    ASN1objectidentifier_t algorithmOID;
    Params paramS;
    ASN1bitstring_t signature;
} SIGNED_EncodedGeneralToken;

typedef struct ENCRYPTED {
    ASN1objectidentifier_t algorithmOID;
    Params paramS;
    ASN1octetstring_t encryptedData;
} ENCRYPTED;

typedef struct HASHED {
    ASN1objectidentifier_t algorithmOID;
    Params paramS;
    ASN1bitstring_t hash;
} HASHED;

typedef struct SIGNED_EncodedPwdCertToken {
    EncodedPwdCertToken toBeSigned;
    ASN1objectidentifier_t algorithmOID;
    Params paramS;
    ASN1bitstring_t signature;
} SIGNED_EncodedPwdCertToken;

typedef struct Information_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ProtocolIdentifier protocolIdentifier;
#   define Information_UUIE_callIdentifier_present 0x80
    CallIdentifier callIdentifier;
} Information_UUIE;

typedef struct ReleaseComplete_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ProtocolIdentifier protocolIdentifier;
#   define ReleaseComplete_UUIE_reason_present 0x80
    ReleaseCompleteReason reason;
#   define ReleaseComplete_UUIE_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
} ReleaseComplete_UUIE;

typedef struct VendorIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H221NonStandard vendor;
#   define productId_present 0x80
    struct VendorIdentifier_productId_productId {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } productId;
#   define versionId_present 0x40
    struct VendorIdentifier_versionId_versionId {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } versionId;
} VendorIdentifier;

typedef struct H225NonStandardParameter {
    H225NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} H225NonStandardParameter;

typedef struct PublicPartyNumber {
    PublicTypeOfNumber publicTypeOfNumber;
    NumberDigits publicNumberDigits;
} PublicPartyNumber;

typedef struct PrivatePartyNumber {
    PrivateTypeOfNumber privateTypeOfNumber;
    NumberDigits privateNumberDigits;
} PrivatePartyNumber;

typedef struct SecurityServiceMode {
    ASN1choice_t choice;
    union {
#	define SecurityServiceMode_nonStandard_chosen 1
	H225NonStandardParameter nonStandard;
#	define SecurityServiceMode_none_chosen 2
#	define SecurityServiceMode_default_chosen 3
    } u;
} SecurityServiceMode;

typedef struct SecurityCapabilities {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define SecurityCapabilities_nonStandard_present 0x80
    H225NonStandardParameter nonStandard;
    SecurityServiceMode encryption;
    SecurityServiceMode authenticaton;
    SecurityServiceMode integrity;
} SecurityCapabilities;

typedef struct H245Security {
    ASN1choice_t choice;
    union {
#	define H245Security_nonStandard_chosen 1
	H225NonStandardParameter nonStandard;
#	define noSecurity_chosen 2
#	define H245Security_tls_chosen 3
	SecurityCapabilities tls;
#	define H245Security_ipsec_chosen 4
	SecurityCapabilities ipsec;
    } u;
} H245Security;

typedef struct QseriesOptions {
    ASN1bool_t q932Full;
    ASN1bool_t q951Full;
    ASN1bool_t q952Full;
    ASN1bool_t q953Full;
    ASN1bool_t q955Full;
    ASN1bool_t q956Full;
    ASN1bool_t q957Full;
    Q954Details q954Info;
} QseriesOptions;

typedef struct EncryptIntAlg {
    ASN1choice_t choice;
    union {
#	define EncryptIntAlg_nonStandard_chosen 1
	H225NonStandardParameter nonStandard;
#	define isoAlgorithm_chosen 2
	ASN1objectidentifier_t isoAlgorithm;
    } u;
} EncryptIntAlg;

typedef struct NonIsoIntegrityMechanism {
    ASN1choice_t choice;
    union {
#	define hMAC_MD5_chosen 1
#	define hMAC_iso10118_2_s_chosen 2
	EncryptIntAlg hMAC_iso10118_2_s;
#	define hMAC_iso10118_2_l_chosen 3
	EncryptIntAlg hMAC_iso10118_2_l;
#	define hMAC_iso10118_3_chosen 4
	ASN1objectidentifier_t hMAC_iso10118_3;
    } u;
} NonIsoIntegrityMechanism;

typedef struct IntegrityMechanism {
    ASN1choice_t choice;
    union {
#	define IntegrityMechanism_nonStandard_chosen 1
	H225NonStandardParameter nonStandard;
#	define digSig_chosen 2
#	define iso9797_chosen 3
	ASN1objectidentifier_t iso9797;
#	define nonIsoIM_chosen 4
	NonIsoIntegrityMechanism nonIsoIM;
    } u;
} IntegrityMechanism;

typedef ClearToken FastStartToken;

typedef struct EncodedFastStartToken {
    ASN1objectidentifier_t id;
    FastStartToken type;
} EncodedFastStartToken;

typedef struct DataRate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define DataRate_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    BandWidth channelRate;
#   define channelMultiplier_present 0x40
    ASN1uint16_t channelMultiplier;
} DataRate;

typedef struct GatekeeperReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define GatekeeperReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define GatekeeperReject_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
    GatekeeperRejectReason rejectReason;
#   define GatekeeperReject_altGKInfo_present 0x8000
    AltGKInfo altGKInfo;
#   define GatekeeperReject_tokens_present 0x4000
    PGatekeeperReject_tokens tokens;
#   define GatekeeperReject_cryptoTokens_present 0x2000
    PGatekeeperReject_cryptoTokens cryptoTokens;
#   define GatekeeperReject_integrityCheckValue_present 0x1000
    ICV integrityCheckValue;
} GatekeeperReject;

typedef struct RegistrationConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define RegistrationConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    PRegistrationConfirm_callSignalAddress callSignalAddress;
#   define RegistrationConfirm_terminalAlias_present 0x40
    PRegistrationConfirm_terminalAlias terminalAlias;
#   define RegistrationConfirm_gatekeeperIdentifier_present 0x20
    GatekeeperIdentifier gatekeeperIdentifier;
    EndpointIdentifier endpointIdentifier;
#   define RegistrationConfirm_alternateGatekeeper_present 0x8000
    PRegistrationConfirm_alternateGatekeeper alternateGatekeeper;
#   define RegistrationConfirm_timeToLive_present 0x4000
    TimeToLive timeToLive;
#   define RegistrationConfirm_tokens_present 0x2000
    PRegistrationConfirm_tokens tokens;
#   define RegistrationConfirm_cryptoTokens_present 0x1000
    PRegistrationConfirm_cryptoTokens cryptoTokens;
#   define RegistrationConfirm_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
#   define RegistrationConfirm_willRespondToIRR_present 0x400
    ASN1bool_t willRespondToIRR;
#   define preGrantedARQ_present 0x200
    RegistrationConfirm_preGrantedARQ preGrantedARQ;
} RegistrationConfirm;

typedef struct RegistrationReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define RegistrationReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    RegistrationRejectReason rejectReason;
#   define RegistrationReject_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
#   define RegistrationReject_altGKInfo_present 0x8000
    AltGKInfo altGKInfo;
#   define RegistrationReject_tokens_present 0x4000
    PRegistrationReject_tokens tokens;
#   define RegistrationReject_cryptoTokens_present 0x2000
    PRegistrationReject_cryptoTokens cryptoTokens;
#   define RegistrationReject_integrityCheckValue_present 0x1000
    ICV integrityCheckValue;
} RegistrationReject;

typedef struct UnregistrationRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    PUnregistrationRequest_callSignalAddress callSignalAddress;
#   define UnregistrationRequest_endpointAlias_present 0x80
    PUnregistrationRequest_endpointAlias endpointAlias;
#   define UnregistrationRequest_nonStandardData_present 0x40
    H225NonStandardParameter nonStandardData;
#   define UnregistrationRequest_endpointIdentifier_present 0x20
    EndpointIdentifier endpointIdentifier;
#   define UnregistrationRequest_alternateEndpoints_present 0x8000
    PUnregistrationRequest_alternateEndpoints alternateEndpoints;
#   define UnregistrationRequest_gatekeeperIdentifier_present 0x4000
    GatekeeperIdentifier gatekeeperIdentifier;
#   define UnregistrationRequest_tokens_present 0x2000
    PUnregistrationRequest_tokens tokens;
#   define UnregistrationRequest_cryptoTokens_present 0x1000
    PUnregistrationRequest_cryptoTokens cryptoTokens;
#   define UnregistrationRequest_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
#   define UnregistrationRequest_reason_present 0x400
    UnregRequestReason reason;
} UnregistrationRequest;

typedef struct UnregistrationConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
#   define UnregistrationConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define UnregistrationConfirm_tokens_present 0x8000
    PUnregistrationConfirm_tokens tokens;
#   define UnregistrationConfirm_cryptoTokens_present 0x4000
    PUnregistrationConfirm_cryptoTokens cryptoTokens;
#   define UnregistrationConfirm_integrityCheckValue_present 0x2000
    ICV integrityCheckValue;
} UnregistrationConfirm;

typedef struct UnregistrationReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    UnregRejectReason rejectReason;
#   define UnregistrationReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define UnregistrationReject_altGKInfo_present 0x8000
    AltGKInfo altGKInfo;
#   define UnregistrationReject_tokens_present 0x4000
    PUnregistrationReject_tokens tokens;
#   define UnregistrationReject_cryptoTokens_present 0x2000
    PUnregistrationReject_cryptoTokens cryptoTokens;
#   define UnregistrationReject_integrityCheckValue_present 0x1000
    ICV integrityCheckValue;
} UnregistrationReject;

typedef struct AdmissionReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    AdmissionRejectReason rejectReason;
#   define AdmissionReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define AdmissionReject_altGKInfo_present 0x8000
    AltGKInfo altGKInfo;
#   define AdmissionReject_tokens_present 0x4000
    PAdmissionReject_tokens tokens;
#   define AdmissionReject_cryptoTokens_present 0x2000
    PAdmissionReject_cryptoTokens cryptoTokens;
#   define AdmissionReject_callSignalAddress_present 0x1000
    PAdmissionReject_callSignalAddress callSignalAddress;
#   define AdmissionReject_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
} AdmissionReject;

typedef struct BandwidthRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    EndpointIdentifier endpointIdentifier;
    ConferenceIdentifier conferenceID;
    CallReferenceValue callReferenceValue;
#   define callType_present 0x80
    CallType callType;
    BandWidth bandWidth;
#   define BandwidthRequest_nonStandardData_present 0x40
    H225NonStandardParameter nonStandardData;
#   define BandwidthRequest_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define BandwidthRequest_gatekeeperIdentifier_present 0x4000
    GatekeeperIdentifier gatekeeperIdentifier;
#   define BandwidthRequest_tokens_present 0x2000
    PBandwidthRequest_tokens tokens;
#   define BandwidthRequest_cryptoTokens_present 0x1000
    PBandwidthRequest_cryptoTokens cryptoTokens;
#   define BandwidthRequest_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
#   define BandwidthRequest_answeredCall_present 0x400
    ASN1bool_t answeredCall;
} BandwidthRequest;

typedef struct BandwidthConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    BandWidth bandWidth;
#   define BandwidthConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define BandwidthConfirm_tokens_present 0x8000
    PBandwidthConfirm_tokens tokens;
#   define BandwidthConfirm_cryptoTokens_present 0x4000
    PBandwidthConfirm_cryptoTokens cryptoTokens;
#   define BandwidthConfirm_integrityCheckValue_present 0x2000
    ICV integrityCheckValue;
} BandwidthConfirm;

typedef struct BandwidthReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    BandRejectReason rejectReason;
    BandWidth allowedBandWidth;
#   define BandwidthReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define BandwidthReject_altGKInfo_present 0x8000
    AltGKInfo altGKInfo;
#   define BandwidthReject_tokens_present 0x4000
    PBandwidthReject_tokens tokens;
#   define BandwidthReject_cryptoTokens_present 0x2000
    PBandwidthReject_cryptoTokens cryptoTokens;
#   define BandwidthReject_integrityCheckValue_present 0x1000
    ICV integrityCheckValue;
} BandwidthReject;

typedef struct LocationReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    LocationRejectReason rejectReason;
#   define LocationReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define LocationReject_altGKInfo_present 0x8000
    AltGKInfo altGKInfo;
#   define LocationReject_tokens_present 0x4000
    PLocationReject_tokens tokens;
#   define LocationReject_cryptoTokens_present 0x2000
    PLocationReject_cryptoTokens cryptoTokens;
#   define LocationReject_integrityCheckValue_present 0x1000
    ICV integrityCheckValue;
} LocationReject;

typedef struct DisengageRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    EndpointIdentifier endpointIdentifier;
    ConferenceIdentifier conferenceID;
    CallReferenceValue callReferenceValue;
    DisengageReason disengageReason;
#   define DisengageRequest_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define DisengageRequest_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define DisengageRequest_gatekeeperIdentifier_present 0x4000
    GatekeeperIdentifier gatekeeperIdentifier;
#   define DisengageRequest_tokens_present 0x2000
    PDisengageRequest_tokens tokens;
#   define DisengageRequest_cryptoTokens_present 0x1000
    PDisengageRequest_cryptoTokens cryptoTokens;
#   define DisengageRequest_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
#   define DisengageRequest_answeredCall_present 0x400
    ASN1bool_t answeredCall;
} DisengageRequest;

typedef struct DisengageConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
#   define DisengageConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define DisengageConfirm_tokens_present 0x8000
    PDisengageConfirm_tokens tokens;
#   define DisengageConfirm_cryptoTokens_present 0x4000
    PDisengageConfirm_cryptoTokens cryptoTokens;
#   define DisengageConfirm_integrityCheckValue_present 0x2000
    ICV integrityCheckValue;
} DisengageConfirm;

typedef struct DisengageReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    DisengageRejectReason rejectReason;
#   define DisengageReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define DisengageReject_altGKInfo_present 0x8000
    AltGKInfo altGKInfo;
#   define DisengageReject_tokens_present 0x4000
    PDisengageReject_tokens tokens;
#   define DisengageReject_cryptoTokens_present 0x2000
    PDisengageReject_cryptoTokens cryptoTokens;
#   define DisengageReject_integrityCheckValue_present 0x1000
    ICV integrityCheckValue;
} DisengageReject;

typedef struct InfoRequestAck {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
#   define InfoRequestAck_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define InfoRequestAck_tokens_present 0x40
    PInfoRequestAck_tokens tokens;
#   define InfoRequestAck_cryptoTokens_present 0x20
    PInfoRequestAck_cryptoTokens cryptoTokens;
#   define InfoRequestAck_integrityCheckValue_present 0x10
    ICV integrityCheckValue;
} InfoRequestAck;

typedef struct InfoRequestNak {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
#   define InfoRequestNak_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    InfoRequestNakReason nakReason;
#   define InfoRequestNak_altGKInfo_present 0x40
    AltGKInfo altGKInfo;
#   define InfoRequestNak_tokens_present 0x20
    PInfoRequestNak_tokens tokens;
#   define InfoRequestNak_cryptoTokens_present 0x10
    PInfoRequestNak_cryptoTokens cryptoTokens;
#   define InfoRequestNak_integrityCheckValue_present 0x8
    ICV integrityCheckValue;
} InfoRequestNak;

typedef struct H225NonStandardMessage {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    H225NonStandardParameter nonStandardData;
#   define H225NonStandardMessage_tokens_present 0x80
    PH225NonStandardMessage_tokens tokens;
#   define H225NonStandardMessage_cryptoTokens_present 0x40
    PH225NonStandardMessage_cryptoTokens cryptoTokens;
#   define H225NonStandardMessage_integrityCheckValue_present 0x20
    ICV integrityCheckValue;
} H225NonStandardMessage;

typedef struct RequestInProgress {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
#   define RequestInProgress_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define RequestInProgress_tokens_present 0x40
    PRequestInProgress_tokens tokens;
#   define RequestInProgress_cryptoTokens_present 0x20
    PRequestInProgress_cryptoTokens cryptoTokens;
#   define RequestInProgress_integrityCheckValue_present 0x10
    ICV integrityCheckValue;
    ASN1uint16_t delay;
} RequestInProgress;

typedef struct ResourcesAvailableIndicate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define ResourcesAvailableIndicate_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    EndpointIdentifier endpointIdentifier;
    PResourcesAvailableIndicate_protocols protocols;
    ASN1bool_t almostOutOfResources;
#   define ResourcesAvailableIndicate_tokens_present 0x40
    PResourcesAvailableIndicate_tokens tokens;
#   define ResourcesAvailableIndicate_cryptoTokens_present 0x20
    PResourcesAvailableIndicate_cryptoTokens cryptoTokens;
#   define ResourcesAvailableIndicate_integrityCheckValue_present 0x10
    ICV integrityCheckValue;
} ResourcesAvailableIndicate;

typedef struct ResourcesAvailableConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define ResourcesAvailableConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define ResourcesAvailableConfirm_tokens_present 0x40
    PResourcesAvailableConfirm_tokens tokens;
#   define ResourcesAvailableConfirm_cryptoTokens_present 0x20
    PResourcesAvailableConfirm_cryptoTokens cryptoTokens;
#   define ResourcesAvailableConfirm_integrityCheckValue_present 0x10
    ICV integrityCheckValue;
} ResourcesAvailableConfirm;

typedef struct GatekeeperConfirm_integrity {
    PGatekeeperConfirm_integrity next;
    IntegrityMechanism value;
} GatekeeperConfirm_integrity_Element;

typedef struct GatekeeperRequest_integrity {
    PGatekeeperRequest_integrity next;
    IntegrityMechanism value;
} GatekeeperRequest_integrity_Element;

typedef struct CryptoH323Token_cryptoGKPwdHash {
    GatekeeperIdentifier gatekeeperId;
    TimeStamp timeStamp;
    HASHED token;
} CryptoH323Token_cryptoGKPwdHash;

typedef struct NonStandardProtocol_dataRatesSupported {
    PNonStandardProtocol_dataRatesSupported next;
    DataRate value;
} NonStandardProtocol_dataRatesSupported_Element;

typedef struct T120OnlyCaps_dataRatesSupported {
    PT120OnlyCaps_dataRatesSupported next;
    DataRate value;
} T120OnlyCaps_dataRatesSupported_Element;

typedef struct VoiceCaps_dataRatesSupported {
    PVoiceCaps_dataRatesSupported next;
    DataRate value;
} VoiceCaps_dataRatesSupported_Element;

typedef struct H324Caps_dataRatesSupported {
    PH324Caps_dataRatesSupported next;
    DataRate value;
} H324Caps_dataRatesSupported_Element;

typedef struct H323Caps_dataRatesSupported {
    PH323Caps_dataRatesSupported next;
    DataRate value;
} H323Caps_dataRatesSupported_Element;

typedef struct H322Caps_dataRatesSupported {
    PH322Caps_dataRatesSupported next;
    DataRate value;
} H322Caps_dataRatesSupported_Element;

typedef struct H321Caps_dataRatesSupported {
    PH321Caps_dataRatesSupported next;
    DataRate value;
} H321Caps_dataRatesSupported_Element;

typedef struct H320Caps_dataRatesSupported {
    PH320Caps_dataRatesSupported next;
    DataRate value;
} H320Caps_dataRatesSupported_Element;

typedef struct H310Caps_dataRatesSupported {
    PH310Caps_dataRatesSupported next;
    DataRate value;
} H310Caps_dataRatesSupported_Element;

typedef struct Setup_UUIE_h245SecurityCapability {
    PSetup_UUIE_h245SecurityCapability next;
    H245Security value;
} Setup_UUIE_h245SecurityCapability_Element;

typedef struct H323_UU_PDU_nonStandardControl {
    PH323_UU_PDU_nonStandardControl next;
    H225NonStandardParameter value;
} H323_UU_PDU_nonStandardControl_Element;

typedef struct CryptoToken_cryptoHashedToken {
    ASN1objectidentifier_t tokenOID;
    ClearToken hashedVals;
    HASHED token;
} CryptoToken_cryptoHashedToken;

typedef struct CryptoToken_cryptoSignedToken {
    ASN1objectidentifier_t tokenOID;
    SIGNED_EncodedGeneralToken token;
} CryptoToken_cryptoSignedToken;

typedef struct CryptoToken_cryptoEncryptedToken {
    ASN1objectidentifier_t tokenOID;
    ENCRYPTED token;
} CryptoToken_cryptoEncryptedToken;

typedef struct CryptoToken {
    ASN1choice_t choice;
    union {
#	define cryptoEncryptedToken_chosen 1
	CryptoToken_cryptoEncryptedToken cryptoEncryptedToken;
#	define cryptoSignedToken_chosen 2
	CryptoToken_cryptoSignedToken cryptoSignedToken;
#	define cryptoHashedToken_chosen 3
	CryptoToken_cryptoHashedToken cryptoHashedToken;
#	define cryptoPwdEncr_chosen 4
	ENCRYPTED cryptoPwdEncr;
    } u;
} CryptoToken;

typedef struct SIGNED_EncodedFastStartToken {
    EncodedFastStartToken toBeSigned;
    ASN1objectidentifier_t algorithmOID;
    Params paramS;
    ASN1bitstring_t signature;
} SIGNED_EncodedFastStartToken;

typedef struct TransportAddress {
    ASN1choice_t choice;
    union {
#	define ipAddress_chosen 1
	TransportAddress_ipAddress ipAddress;
#	define ipSourceRoute_chosen 2
	TransportAddress_ipSourceRoute ipSourceRoute;
#	define ipxAddress_chosen 3
	TransportAddress_ipxAddress ipxAddress;
#	define ip6Address_chosen 4
	TransportAddress_ip6Address ip6Address;
#	define TransportAddress_netBios_chosen 5
	struct TransportAddress_netBios_netBios {
	    ASN1uint32_t length;
	    ASN1octet_t value[16];
	} netBios;
#	define TransportAddress_nsap_chosen 6
	struct TransportAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define TransportAddress_nonStandardAddress_chosen 7
	H225NonStandardParameter nonStandardAddress;
    } u;
} TransportAddress;

typedef struct GatewayInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define protocol_present 0x80
    PGatewayInfo_protocol protocol;
#   define GatewayInfo_nonStandardData_present 0x40
    H225NonStandardParameter nonStandardData;
} GatewayInfo;

typedef struct H310Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H310Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H310Caps_dataRatesSupported_present 0x8000
    PH310Caps_dataRatesSupported dataRatesSupported;
#   define H310Caps_supportedPrefixes_present 0x4000
    PH310Caps_supportedPrefixes supportedPrefixes;
} H310Caps;

typedef struct H320Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H320Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H320Caps_dataRatesSupported_present 0x8000
    PH320Caps_dataRatesSupported dataRatesSupported;
#   define H320Caps_supportedPrefixes_present 0x4000
    PH320Caps_supportedPrefixes supportedPrefixes;
} H320Caps;

typedef struct H321Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H321Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H321Caps_dataRatesSupported_present 0x8000
    PH321Caps_dataRatesSupported dataRatesSupported;
#   define H321Caps_supportedPrefixes_present 0x4000
    PH321Caps_supportedPrefixes supportedPrefixes;
} H321Caps;

typedef struct H322Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H322Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H322Caps_dataRatesSupported_present 0x8000
    PH322Caps_dataRatesSupported dataRatesSupported;
#   define H322Caps_supportedPrefixes_present 0x4000
    PH322Caps_supportedPrefixes supportedPrefixes;
} H322Caps;

typedef struct H323Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H323Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H323Caps_dataRatesSupported_present 0x8000
    PH323Caps_dataRatesSupported dataRatesSupported;
#   define H323Caps_supportedPrefixes_present 0x4000
    PH323Caps_supportedPrefixes supportedPrefixes;
} H323Caps;

typedef struct H324Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H324Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H324Caps_dataRatesSupported_present 0x8000
    PH324Caps_dataRatesSupported dataRatesSupported;
#   define H324Caps_supportedPrefixes_present 0x4000
    PH324Caps_supportedPrefixes supportedPrefixes;
} H324Caps;

typedef struct VoiceCaps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define VoiceCaps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define VoiceCaps_dataRatesSupported_present 0x8000
    PVoiceCaps_dataRatesSupported dataRatesSupported;
#   define VoiceCaps_supportedPrefixes_present 0x4000
    PVoiceCaps_supportedPrefixes supportedPrefixes;
} VoiceCaps;

typedef struct T120OnlyCaps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define T120OnlyCaps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define T120OnlyCaps_dataRatesSupported_present 0x8000
    PT120OnlyCaps_dataRatesSupported dataRatesSupported;
#   define T120OnlyCaps_supportedPrefixes_present 0x4000
    PT120OnlyCaps_supportedPrefixes supportedPrefixes;
} T120OnlyCaps;

typedef struct NonStandardProtocol {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define NonStandardProtocol_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define NonStandardProtocol_dataRatesSupported_present 0x40
    PNonStandardProtocol_dataRatesSupported dataRatesSupported;
    PNonStandardProtocol_supportedPrefixes supportedPrefixes;
} NonStandardProtocol;

typedef struct McuInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define McuInfo_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
} McuInfo;

typedef struct TerminalInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define TerminalInfo_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
} TerminalInfo;

typedef struct GatekeeperInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define GatekeeperInfo_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
} GatekeeperInfo;

typedef struct PartyNumber {
    ASN1choice_t choice;
    union {
#	define publicNumber_chosen 1
	PublicPartyNumber publicNumber;
#	define dataPartyNumber_chosen 2
	NumberDigits dataPartyNumber;
#	define telexPartyNumber_chosen 3
	NumberDigits telexPartyNumber;
#	define privateNumber_chosen 4
	PrivatePartyNumber privateNumber;
#	define nationalStandardPartyNumber_chosen 5
	NumberDigits nationalStandardPartyNumber;
    } u;
} PartyNumber;

typedef struct AlternateGK {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    TransportAddress rasAddress;
#   define AlternateGK_gatekeeperIdentifier_present 0x80
    GatekeeperIdentifier gatekeeperIdentifier;
    ASN1bool_t needToRegister;
    ASN1uint16_t priority;
} AlternateGK;

typedef struct GatekeeperConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define GatekeeperConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define GatekeeperConfirm_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
    TransportAddress rasAddress;
#   define GatekeeperConfirm_alternateGatekeeper_present 0x8000
    PGatekeeperConfirm_alternateGatekeeper alternateGatekeeper;
#   define authenticationMode_present 0x4000
    AuthenticationMechanism authenticationMode;
#   define GatekeeperConfirm_tokens_present 0x2000
    PGatekeeperConfirm_tokens tokens;
#   define GatekeeperConfirm_cryptoTokens_present 0x1000
    PGatekeeperConfirm_cryptoTokens cryptoTokens;
#   define algorithmOID_present 0x800
    ASN1objectidentifier_t algorithmOID;
#   define GatekeeperConfirm_integrity_present 0x400
    PGatekeeperConfirm_integrity integrity;
#   define GatekeeperConfirm_integrityCheckValue_present 0x200
    ICV integrityCheckValue;
} GatekeeperConfirm;

typedef struct AdmissionRequest {
    union {
	ASN1uint32_t bit_mask;
	ASN1octet_t o[3];
    };
    RequestSeqNum requestSeqNum;
    CallType callType;
#   define callModel_present 0x80
    CallModel callModel;
    EndpointIdentifier endpointIdentifier;
#   define AdmissionRequest_destinationInfo_present 0x40
    PAdmissionRequest_destinationInfo destinationInfo;
#   define AdmissionRequest_destCallSignalAddress_present 0x20
    TransportAddress destCallSignalAddress;
#   define AdmissionRequest_destExtraCallInfo_present 0x10
    PAdmissionRequest_destExtraCallInfo destExtraCallInfo;
    PAdmissionRequest_srcInfo srcInfo;
#   define srcCallSignalAddress_present 0x8
    TransportAddress srcCallSignalAddress;
    BandWidth bandWidth;
    CallReferenceValue callReferenceValue;
#   define AdmissionRequest_nonStandardData_present 0x4
    H225NonStandardParameter nonStandardData;
#   define AdmissionRequest_callServices_present 0x2
    QseriesOptions callServices;
    ConferenceIdentifier conferenceID;
    ASN1bool_t activeMC;
    ASN1bool_t answerCall;
#   define AdmissionRequest_canMapAlias_present 0x8000
    ASN1bool_t canMapAlias;
#   define AdmissionRequest_callIdentifier_present 0x4000
    CallIdentifier callIdentifier;
#   define srcAlternatives_present 0x2000
    PAdmissionRequest_srcAlternatives srcAlternatives;
#   define destAlternatives_present 0x1000
    PAdmissionRequest_destAlternatives destAlternatives;
#   define AdmissionRequest_gatekeeperIdentifier_present 0x800
    GatekeeperIdentifier gatekeeperIdentifier;
#   define AdmissionRequest_tokens_present 0x400
    PAdmissionRequest_tokens tokens;
#   define AdmissionRequest_cryptoTokens_present 0x200
    PAdmissionRequest_cryptoTokens cryptoTokens;
#   define AdmissionRequest_integrityCheckValue_present 0x100
    ICV integrityCheckValue;
#   define AdmissionRequest_transportQOS_present 0x800000
    TransportQOS transportQOS;
#   define AdmissionRequest_willSupplyUUIEs_present 0x400000
    ASN1bool_t willSupplyUUIEs;
} AdmissionRequest;

typedef struct LocationRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
#   define LocationRequest_endpointIdentifier_present 0x80
    EndpointIdentifier endpointIdentifier;
    PLocationRequest_destinationInfo destinationInfo;
#   define LocationRequest_nonStandardData_present 0x40
    H225NonStandardParameter nonStandardData;
    TransportAddress replyAddress;
#   define sourceInfo_present 0x8000
    PLocationRequest_sourceInfo sourceInfo;
#   define LocationRequest_canMapAlias_present 0x4000
    ASN1bool_t canMapAlias;
#   define LocationRequest_gatekeeperIdentifier_present 0x2000
    GatekeeperIdentifier gatekeeperIdentifier;
#   define LocationRequest_tokens_present 0x1000
    PLocationRequest_tokens tokens;
#   define LocationRequest_cryptoTokens_present 0x800
    PLocationRequest_cryptoTokens cryptoTokens;
#   define LocationRequest_integrityCheckValue_present 0x400
    ICV integrityCheckValue;
} LocationRequest;

typedef struct InfoRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    CallReferenceValue callReferenceValue;
#   define InfoRequest_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define replyAddress_present 0x40
    TransportAddress replyAddress;
#   define InfoRequest_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define InfoRequest_tokens_present 0x4000
    PInfoRequest_tokens tokens;
#   define InfoRequest_cryptoTokens_present 0x2000
    PInfoRequest_cryptoTokens cryptoTokens;
#   define InfoRequest_integrityCheckValue_present 0x1000
    ICV integrityCheckValue;
#   define InfoRequest_uuiesRequested_present 0x800
    UUIEsRequested uuiesRequested;
} InfoRequest;

typedef struct TransportChannelInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define sendAddress_present 0x80
    TransportAddress sendAddress;
#   define recvAddress_present 0x40
    TransportAddress recvAddress;
} TransportChannelInfo;

typedef struct RTPSession {
    TransportChannelInfo rtpAddress;
    TransportChannelInfo rtcpAddress;
    ASN1ztcharstring_t cname;
    ASN1uint32_t ssrc;
    ASN1uint16_t sessionId;
    PRTPSession_associatedSessionIds associatedSessionIds;
} RTPSession;

typedef struct InfoRequestResponse_perCallInfo_Seq_data {
    PInfoRequestResponse_perCallInfo_Seq_data next;
    TransportChannelInfo value;
} InfoRequestResponse_perCallInfo_Seq_data_Element;

typedef struct InfoRequestResponse_perCallInfo_Seq_video {
    PInfoRequestResponse_perCallInfo_Seq_video next;
    RTPSession value;
} InfoRequestResponse_perCallInfo_Seq_video_Element;

typedef struct InfoRequestResponse_perCallInfo_Seq_audio {
    PInfoRequestResponse_perCallInfo_Seq_audio next;
    RTPSession value;
} InfoRequestResponse_perCallInfo_Seq_audio_Element;

typedef struct InfoRequestResponse_perCallInfo_Seq {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define InfoRequestResponse_perCallInfo_Seq_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    CallReferenceValue callReferenceValue;
    ConferenceIdentifier conferenceID;
#   define originator_present 0x40
    ASN1bool_t originator;
#   define audio_present 0x20
    PInfoRequestResponse_perCallInfo_Seq_audio audio;
#   define video_present 0x10
    PInfoRequestResponse_perCallInfo_Seq_video video;
#   define data_present 0x8
    PInfoRequestResponse_perCallInfo_Seq_data data;
    TransportChannelInfo h245;
    TransportChannelInfo callSignaling;
    CallType callType;
    BandWidth bandWidth;
    CallModel callModel;
#   define InfoRequestResponse_perCallInfo_Seq_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define InfoRequestResponse_perCallInfo_Seq_tokens_present 0x4000
    PInfoRequestResponse_perCallInfo_Seq_tokens tokens;
#   define InfoRequestResponse_perCallInfo_Seq_cryptoTokens_present 0x2000
    PInfoRequestResponse_perCallInfo_Seq_cryptoTokens cryptoTokens;
#   define substituteConfIDs_present 0x1000
    PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs substituteConfIDs;
#   define pdu_present 0x800
    PInfoRequestResponse_perCallInfo_Seq_pdu pdu;
} InfoRequestResponse_perCallInfo_Seq;

typedef struct InfoRequestResponse_perCallInfo {
    PInfoRequestResponse_perCallInfo next;
    InfoRequestResponse_perCallInfo_Seq value;
} InfoRequestResponse_perCallInfo_Element;

typedef struct InfoRequestResponse_callSignalAddress {
    PInfoRequestResponse_callSignalAddress next;
    TransportAddress value;
} InfoRequestResponse_callSignalAddress_Element;

typedef struct AdmissionReject_callSignalAddress {
    PAdmissionReject_callSignalAddress next;
    TransportAddress value;
} AdmissionReject_callSignalAddress_Element;

typedef struct UnregistrationRequest_callSignalAddress {
    PUnregistrationRequest_callSignalAddress next;
    TransportAddress value;
} UnregistrationRequest_callSignalAddress_Element;

typedef struct RegistrationConfirm_alternateGatekeeper {
    PRegistrationConfirm_alternateGatekeeper next;
    AlternateGK value;
} RegistrationConfirm_alternateGatekeeper_Element;

typedef struct RegistrationConfirm_callSignalAddress {
    PRegistrationConfirm_callSignalAddress next;
    TransportAddress value;
} RegistrationConfirm_callSignalAddress_Element;

typedef struct RegistrationRequest_rasAddress {
    PRegistrationRequest_rasAddress next;
    TransportAddress value;
} RegistrationRequest_rasAddress_Element;

typedef struct RegistrationRequest_callSignalAddress {
    PRegistrationRequest_callSignalAddress next;
    TransportAddress value;
} RegistrationRequest_callSignalAddress_Element;

typedef struct GatekeeperConfirm_alternateGatekeeper {
    PGatekeeperConfirm_alternateGatekeeper next;
    AlternateGK value;
} GatekeeperConfirm_alternateGatekeeper_Element;

typedef struct AltGKInfo_alternateGatekeeper {
    PAltGKInfo_alternateGatekeeper next;
    AlternateGK value;
} AltGKInfo_alternateGatekeeper_Element;

typedef struct Endpoint_rasAddress {
    PEndpoint_rasAddress next;
    TransportAddress value;
} Endpoint_rasAddress_Element;

typedef struct Endpoint_callSignalAddress {
    PEndpoint_callSignalAddress next;
    TransportAddress value;
} Endpoint_callSignalAddress_Element;

typedef struct EndpointType {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define EndpointType_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define vendor_present 0x40
    VendorIdentifier vendor;
#   define gatekeeper_present 0x20
    GatekeeperInfo gatekeeper;
#   define gateway_present 0x10
    GatewayInfo gateway;
#   define mcu_present 0x8
    McuInfo mcu;
#   define terminal_present 0x4
    TerminalInfo terminal;
    ASN1bool_t mc;
    ASN1bool_t undefinedNode;
} EndpointType;

typedef struct SupportedProtocols {
    ASN1choice_t choice;
    union {
#	define nonStandardData_chosen 1
	H225NonStandardParameter nonStandardData;
#	define h310_chosen 2
	H310Caps h310;
#	define h320_chosen 3
	H320Caps h320;
#	define h321_chosen 4
	H321Caps h321;
#	define h322_chosen 5
	H322Caps h322;
#	define h323_chosen 6
	H323Caps h323;
#	define h324_chosen 7
	H324Caps h324;
#	define voice_chosen 8
	VoiceCaps voice;
#	define t120_only_chosen 9
	T120OnlyCaps t120_only;
#	define nonStandardProtocol_chosen 10
	NonStandardProtocol nonStandardProtocol;
    } u;
} SupportedProtocols;

typedef struct AliasAddress {
    ASN1choice_t choice;
    union {
#	define e164_chosen 1
	ASN1char_t e164[129];
#	define h323_ID_chosen 2
	ASN1char16string_t h323_ID;
#	define url_ID_chosen 3
	ASN1char_t url_ID[513];
#	define transportID_chosen 4
	TransportAddress transportID;
#	define email_ID_chosen 5
	ASN1char_t email_ID[513];
#	define partyNumber_chosen 6
	PartyNumber partyNumber;
    } u;
} AliasAddress;

typedef struct Endpoint {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define Endpoint_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define aliasAddress_present 0x40
    PEndpoint_aliasAddress aliasAddress;
#   define Endpoint_callSignalAddress_present 0x20
    PEndpoint_callSignalAddress callSignalAddress;
#   define rasAddress_present 0x10
    PEndpoint_rasAddress rasAddress;
#   define endpointType_present 0x8
    EndpointType endpointType;
#   define Endpoint_tokens_present 0x4
    PEndpoint_tokens tokens;
#   define Endpoint_cryptoTokens_present 0x2
    PEndpoint_cryptoTokens cryptoTokens;
#   define priority_present 0x1
    ASN1uint16_t priority;
#   define Endpoint_remoteExtensionAddress_present 0x8000
    PEndpoint_remoteExtensionAddress remoteExtensionAddress;
#   define Endpoint_destExtraCallInfo_present 0x4000
    PEndpoint_destExtraCallInfo destExtraCallInfo;
} Endpoint;

typedef struct SupportedPrefix {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define SupportedPrefix_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    AliasAddress prefix;
} SupportedPrefix;

typedef struct GatekeeperRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define GatekeeperRequest_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    TransportAddress rasAddress;
    EndpointType endpointType;
#   define GatekeeperRequest_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
#   define GatekeeperRequest_callServices_present 0x20
    QseriesOptions callServices;
#   define GatekeeperRequest_endpointAlias_present 0x10
    PGatekeeperRequest_endpointAlias endpointAlias;
#   define GatekeeperRequest_alternateEndpoints_present 0x8000
    PGatekeeperRequest_alternateEndpoints alternateEndpoints;
#   define GatekeeperRequest_tokens_present 0x4000
    PGatekeeperRequest_tokens tokens;
#   define GatekeeperRequest_cryptoTokens_present 0x2000
    PGatekeeperRequest_cryptoTokens cryptoTokens;
#   define GatekeeperRequest_authenticationCapability_present 0x1000
    PGatekeeperRequest_authenticationCapability authenticationCapability;
#   define algorithmOIDs_present 0x800
    PGatekeeperRequest_algorithmOIDs algorithmOIDs;
#   define GatekeeperRequest_integrity_present 0x400
    PGatekeeperRequest_integrity integrity;
#   define GatekeeperRequest_integrityCheckValue_present 0x200
    ICV integrityCheckValue;
} GatekeeperRequest;

typedef struct RegistrationRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define RegistrationRequest_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    ASN1bool_t discoveryComplete;
    PRegistrationRequest_callSignalAddress callSignalAddress;
    PRegistrationRequest_rasAddress rasAddress;
    EndpointType terminalType;
#   define RegistrationRequest_terminalAlias_present 0x40
    PRegistrationRequest_terminalAlias terminalAlias;
#   define RegistrationRequest_gatekeeperIdentifier_present 0x20
    GatekeeperIdentifier gatekeeperIdentifier;
    VendorIdentifier endpointVendor;
#   define RegistrationRequest_alternateEndpoints_present 0x8000
    PRegistrationRequest_alternateEndpoints alternateEndpoints;
#   define RegistrationRequest_timeToLive_present 0x4000
    TimeToLive timeToLive;
#   define RegistrationRequest_tokens_present 0x2000
    PRegistrationRequest_tokens tokens;
#   define RegistrationRequest_cryptoTokens_present 0x1000
    PRegistrationRequest_cryptoTokens cryptoTokens;
#   define RegistrationRequest_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
#   define keepAlive_present 0x400
    ASN1bool_t keepAlive;
#   define RegistrationRequest_endpointIdentifier_present 0x200
    EndpointIdentifier endpointIdentifier;
#   define RegistrationRequest_willSupplyUUIEs_present 0x100
    ASN1bool_t willSupplyUUIEs;
} RegistrationRequest;

typedef struct AdmissionConfirm {
    union {
	ASN1uint32_t bit_mask;
	ASN1octet_t o[3];
    };
    RequestSeqNum requestSeqNum;
    BandWidth bandWidth;
    CallModel callModel;
    TransportAddress destCallSignalAddress;
#   define irrFrequency_present 0x80
    ASN1uint16_t irrFrequency;
#   define AdmissionConfirm_nonStandardData_present 0x40
    H225NonStandardParameter nonStandardData;
#   define AdmissionConfirm_destinationInfo_present 0x8000
    PAdmissionConfirm_destinationInfo destinationInfo;
#   define AdmissionConfirm_destExtraCallInfo_present 0x4000
    PAdmissionConfirm_destExtraCallInfo destExtraCallInfo;
#   define AdmissionConfirm_destinationType_present 0x2000
    EndpointType destinationType;
#   define AdmissionConfirm_remoteExtensionAddress_present 0x1000
    PAdmissionConfirm_remoteExtensionAddress remoteExtensionAddress;
#   define AdmissionConfirm_alternateEndpoints_present 0x800
    PAdmissionConfirm_alternateEndpoints alternateEndpoints;
#   define AdmissionConfirm_tokens_present 0x400
    PAdmissionConfirm_tokens tokens;
#   define AdmissionConfirm_cryptoTokens_present 0x200
    PAdmissionConfirm_cryptoTokens cryptoTokens;
#   define AdmissionConfirm_integrityCheckValue_present 0x100
    ICV integrityCheckValue;
#   define AdmissionConfirm_transportQOS_present 0x800000
    TransportQOS transportQOS;
#   define AdmissionConfirm_willRespondToIRR_present 0x400000
    ASN1bool_t willRespondToIRR;
#   define AdmissionConfirm_uuiesRequested_present 0x200000
    UUIEsRequested uuiesRequested;
} AdmissionConfirm;

typedef struct LocationConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    TransportAddress callSignalAddress;
    TransportAddress rasAddress;
#   define LocationConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define LocationConfirm_destinationInfo_present 0x8000
    PLocationConfirm_destinationInfo destinationInfo;
#   define LocationConfirm_destExtraCallInfo_present 0x4000
    PLocationConfirm_destExtraCallInfo destExtraCallInfo;
#   define LocationConfirm_destinationType_present 0x2000
    EndpointType destinationType;
#   define LocationConfirm_remoteExtensionAddress_present 0x1000
    PLocationConfirm_remoteExtensionAddress remoteExtensionAddress;
#   define LocationConfirm_alternateEndpoints_present 0x800
    PLocationConfirm_alternateEndpoints alternateEndpoints;
#   define LocationConfirm_tokens_present 0x400
    PLocationConfirm_tokens tokens;
#   define LocationConfirm_cryptoTokens_present 0x200
    PLocationConfirm_cryptoTokens cryptoTokens;
#   define LocationConfirm_integrityCheckValue_present 0x100
    ICV integrityCheckValue;
} LocationConfirm;

typedef struct InfoRequestResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define InfoRequestResponse_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    RequestSeqNum requestSeqNum;
    EndpointType endpointType;
    EndpointIdentifier endpointIdentifier;
    TransportAddress rasAddress;
    PInfoRequestResponse_callSignalAddress callSignalAddress;
#   define InfoRequestResponse_endpointAlias_present 0x40
    PInfoRequestResponse_endpointAlias endpointAlias;
#   define perCallInfo_present 0x20
    PInfoRequestResponse_perCallInfo perCallInfo;
#   define InfoRequestResponse_tokens_present 0x8000
    PInfoRequestResponse_tokens tokens;
#   define InfoRequestResponse_cryptoTokens_present 0x4000
    PInfoRequestResponse_cryptoTokens cryptoTokens;
#   define InfoRequestResponse_integrityCheckValue_present 0x2000
    ICV integrityCheckValue;
#   define needResponse_present 0x1000
    ASN1bool_t needResponse;
} InfoRequestResponse;

typedef struct ResourcesAvailableIndicate_protocols {
    PResourcesAvailableIndicate_protocols next;
    SupportedProtocols value;
} ResourcesAvailableIndicate_protocols_Element;

typedef struct InfoRequestResponse_endpointAlias {
    PInfoRequestResponse_endpointAlias next;
    AliasAddress value;
} InfoRequestResponse_endpointAlias_Element;

typedef struct LocationConfirm_alternateEndpoints {
    PLocationConfirm_alternateEndpoints next;
    Endpoint value;
} LocationConfirm_alternateEndpoints_Element;

typedef struct LocationConfirm_remoteExtensionAddress {
    PLocationConfirm_remoteExtensionAddress next;
    AliasAddress value;
} LocationConfirm_remoteExtensionAddress_Element;

typedef struct LocationConfirm_destExtraCallInfo {
    PLocationConfirm_destExtraCallInfo next;
    AliasAddress value;
} LocationConfirm_destExtraCallInfo_Element;

typedef struct LocationConfirm_destinationInfo {
    PLocationConfirm_destinationInfo next;
    AliasAddress value;
} LocationConfirm_destinationInfo_Element;

typedef struct LocationRequest_sourceInfo {
    PLocationRequest_sourceInfo next;
    AliasAddress value;
} LocationRequest_sourceInfo_Element;

typedef struct LocationRequest_destinationInfo {
    PLocationRequest_destinationInfo next;
    AliasAddress value;
} LocationRequest_destinationInfo_Element;

typedef struct AdmissionConfirm_alternateEndpoints {
    PAdmissionConfirm_alternateEndpoints next;
    Endpoint value;
} AdmissionConfirm_alternateEndpoints_Element;

typedef struct AdmissionConfirm_remoteExtensionAddress {
    PAdmissionConfirm_remoteExtensionAddress next;
    AliasAddress value;
} AdmissionConfirm_remoteExtensionAddress_Element;

typedef struct AdmissionConfirm_destExtraCallInfo {
    PAdmissionConfirm_destExtraCallInfo next;
    AliasAddress value;
} AdmissionConfirm_destExtraCallInfo_Element;

typedef struct AdmissionConfirm_destinationInfo {
    PAdmissionConfirm_destinationInfo next;
    AliasAddress value;
} AdmissionConfirm_destinationInfo_Element;

typedef struct AdmissionRequest_destAlternatives {
    PAdmissionRequest_destAlternatives next;
    Endpoint value;
} AdmissionRequest_destAlternatives_Element;

typedef struct AdmissionRequest_srcAlternatives {
    PAdmissionRequest_srcAlternatives next;
    Endpoint value;
} AdmissionRequest_srcAlternatives_Element;

typedef struct AdmissionRequest_srcInfo {
    PAdmissionRequest_srcInfo next;
    AliasAddress value;
} AdmissionRequest_srcInfo_Element;

typedef struct AdmissionRequest_destExtraCallInfo {
    PAdmissionRequest_destExtraCallInfo next;
    AliasAddress value;
} AdmissionRequest_destExtraCallInfo_Element;

typedef struct AdmissionRequest_destinationInfo {
    PAdmissionRequest_destinationInfo next;
    AliasAddress value;
} AdmissionRequest_destinationInfo_Element;

typedef struct UnregistrationRequest_alternateEndpoints {
    PUnregistrationRequest_alternateEndpoints next;
    Endpoint value;
} UnregistrationRequest_alternateEndpoints_Element;

typedef struct UnregistrationRequest_endpointAlias {
    PUnregistrationRequest_endpointAlias next;
    AliasAddress value;
} UnregistrationRequest_endpointAlias_Element;

typedef struct RegistrationRejectReason_duplicateAlias {
    PRegistrationRejectReason_duplicateAlias next;
    AliasAddress value;
} RegistrationRejectReason_duplicateAlias_Element;

typedef struct RegistrationConfirm_terminalAlias {
    PRegistrationConfirm_terminalAlias next;
    AliasAddress value;
} RegistrationConfirm_terminalAlias_Element;

typedef struct RegistrationRequest_alternateEndpoints {
    PRegistrationRequest_alternateEndpoints next;
    Endpoint value;
} RegistrationRequest_alternateEndpoints_Element;

typedef struct RegistrationRequest_terminalAlias {
    PRegistrationRequest_terminalAlias next;
    AliasAddress value;
} RegistrationRequest_terminalAlias_Element;

typedef struct GatekeeperRequest_alternateEndpoints {
    PGatekeeperRequest_alternateEndpoints next;
    Endpoint value;
} GatekeeperRequest_alternateEndpoints_Element;

typedef struct GatekeeperRequest_endpointAlias {
    PGatekeeperRequest_endpointAlias next;
    AliasAddress value;
} GatekeeperRequest_endpointAlias_Element;

typedef struct CryptoH323Token_cryptoEPPwdHash {
    AliasAddress alias;
    TimeStamp timeStamp;
    HASHED token;
} CryptoH323Token_cryptoEPPwdHash;

typedef struct Endpoint_destExtraCallInfo {
    PEndpoint_destExtraCallInfo next;
    AliasAddress value;
} Endpoint_destExtraCallInfo_Element;

typedef struct Endpoint_remoteExtensionAddress {
    PEndpoint_remoteExtensionAddress next;
    AliasAddress value;
} Endpoint_remoteExtensionAddress_Element;

typedef struct Endpoint_aliasAddress {
    PEndpoint_aliasAddress next;
    AliasAddress value;
} Endpoint_aliasAddress_Element;

typedef struct NonStandardProtocol_supportedPrefixes {
    PNonStandardProtocol_supportedPrefixes next;
    SupportedPrefix value;
} NonStandardProtocol_supportedPrefixes_Element;

typedef struct T120OnlyCaps_supportedPrefixes {
    PT120OnlyCaps_supportedPrefixes next;
    SupportedPrefix value;
} T120OnlyCaps_supportedPrefixes_Element;

typedef struct VoiceCaps_supportedPrefixes {
    PVoiceCaps_supportedPrefixes next;
    SupportedPrefix value;
} VoiceCaps_supportedPrefixes_Element;

typedef struct H324Caps_supportedPrefixes {
    PH324Caps_supportedPrefixes next;
    SupportedPrefix value;
} H324Caps_supportedPrefixes_Element;

typedef struct H323Caps_supportedPrefixes {
    PH323Caps_supportedPrefixes next;
    SupportedPrefix value;
} H323Caps_supportedPrefixes_Element;

typedef struct H322Caps_supportedPrefixes {
    PH322Caps_supportedPrefixes next;
    SupportedPrefix value;
} H322Caps_supportedPrefixes_Element;

typedef struct H321Caps_supportedPrefixes {
    PH321Caps_supportedPrefixes next;
    SupportedPrefix value;
} H321Caps_supportedPrefixes_Element;

typedef struct H320Caps_supportedPrefixes {
    PH320Caps_supportedPrefixes next;
    SupportedPrefix value;
} H320Caps_supportedPrefixes_Element;

typedef struct H310Caps_supportedPrefixes {
    PH310Caps_supportedPrefixes next;
    SupportedPrefix value;
} H310Caps_supportedPrefixes_Element;

typedef struct GatewayInfo_protocol {
    PGatewayInfo_protocol next;
    SupportedProtocols value;
} GatewayInfo_protocol_Element;

typedef struct Facility_UUIE_destExtraCallInfo {
    PFacility_UUIE_destExtraCallInfo next;
    AliasAddress value;
} Facility_UUIE_destExtraCallInfo_Element;

typedef struct Facility_UUIE_alternativeAliasAddress {
    PFacility_UUIE_alternativeAliasAddress next;
    AliasAddress value;
} Facility_UUIE_alternativeAliasAddress_Element;

typedef struct Setup_UUIE_destExtraCallInfo {
    PSetup_UUIE_destExtraCallInfo next;
    AliasAddress value;
} Setup_UUIE_destExtraCallInfo_Element;

typedef struct Setup_UUIE_destinationAddress {
    PSetup_UUIE_destinationAddress next;
    AliasAddress value;
} Setup_UUIE_destinationAddress_Element;

typedef struct Setup_UUIE_sourceAddress {
    PSetup_UUIE_sourceAddress next;
    AliasAddress value;
} Setup_UUIE_sourceAddress_Element;

typedef struct Alerting_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ProtocolIdentifier protocolIdentifier;
    EndpointType destinationInfo;
#   define Alerting_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
#   define Alerting_UUIE_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define Alerting_UUIE_h245SecurityMode_present 0x4000
    H245Security h245SecurityMode;
#   define Alerting_UUIE_tokens_present 0x2000
    PAlerting_UUIE_tokens tokens;
#   define Alerting_UUIE_cryptoTokens_present 0x1000
    PAlerting_UUIE_cryptoTokens cryptoTokens;
#   define Alerting_UUIE_fastStart_present 0x800
    PAlerting_UUIE_fastStart fastStart;
} Alerting_UUIE;

typedef struct CallProceeding_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ProtocolIdentifier protocolIdentifier;
    EndpointType destinationInfo;
#   define CallProceeding_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
#   define CallProceeding_UUIE_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define CallProceeding_UUIE_h245SecurityMode_present 0x4000
    H245Security h245SecurityMode;
#   define CallProceeding_UUIE_tokens_present 0x2000
    PCallProceeding_UUIE_tokens tokens;
#   define CallProceeding_UUIE_cryptoTokens_present 0x1000
    PCallProceeding_UUIE_cryptoTokens cryptoTokens;
#   define CallProceeding_UUIE_fastStart_present 0x800
    PCallProceeding_UUIE_fastStart fastStart;
} CallProceeding_UUIE;

typedef struct Connect_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ProtocolIdentifier protocolIdentifier;
#   define Connect_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
    EndpointType destinationInfo;
    ConferenceIdentifier conferenceID;
#   define Connect_UUIE_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define Connect_UUIE_h245SecurityMode_present 0x4000
    H245Security h245SecurityMode;
#   define Connect_UUIE_tokens_present 0x2000
    PConnect_UUIE_tokens tokens;
#   define Connect_UUIE_cryptoTokens_present 0x1000
    PConnect_UUIE_cryptoTokens cryptoTokens;
#   define Connect_UUIE_fastStart_present 0x800
    PConnect_UUIE_fastStart fastStart;
} Connect_UUIE;

typedef struct Setup_UUIE {
    union {
	ASN1uint32_t bit_mask;
	ASN1octet_t o[3];
    };
    ProtocolIdentifier protocolIdentifier;
#   define Setup_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
#   define sourceAddress_present 0x40
    PSetup_UUIE_sourceAddress sourceAddress;
    EndpointType sourceInfo;
#   define destinationAddress_present 0x20
    PSetup_UUIE_destinationAddress destinationAddress;
#   define Setup_UUIE_destCallSignalAddress_present 0x10
    TransportAddress destCallSignalAddress;
#   define Setup_UUIE_destExtraCallInfo_present 0x8
    PSetup_UUIE_destExtraCallInfo destExtraCallInfo;
#   define destExtraCRV_present 0x4
    PSetup_UUIE_destExtraCRV destExtraCRV;
    ASN1bool_t activeMC;
    ConferenceIdentifier conferenceID;
    Setup_UUIE_conferenceGoal conferenceGoal;
#   define Setup_UUIE_callServices_present 0x2
    QseriesOptions callServices;
    CallType callType;
#   define sourceCallSignalAddress_present 0x8000
    TransportAddress sourceCallSignalAddress;
#   define Setup_UUIE_remoteExtensionAddress_present 0x4000
    AliasAddress remoteExtensionAddress;
#   define Setup_UUIE_callIdentifier_present 0x2000
    CallIdentifier callIdentifier;
#   define h245SecurityCapability_present 0x1000
    PSetup_UUIE_h245SecurityCapability h245SecurityCapability;
#   define Setup_UUIE_tokens_present 0x800
    PSetup_UUIE_tokens tokens;
#   define Setup_UUIE_cryptoTokens_present 0x400
    PSetup_UUIE_cryptoTokens cryptoTokens;
#   define Setup_UUIE_fastStart_present 0x200
    PSetup_UUIE_fastStart fastStart;
#   define mediaWaitForConnect_present 0x100
    ASN1bool_t mediaWaitForConnect;
#   define canOverlapSend_present 0x800000
    ASN1bool_t canOverlapSend;
} Setup_UUIE;

typedef struct Facility_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ProtocolIdentifier protocolIdentifier;
#   define alternativeAddress_present 0x80
    TransportAddress alternativeAddress;
#   define alternativeAliasAddress_present 0x40
    PFacility_UUIE_alternativeAliasAddress alternativeAliasAddress;
#   define Facility_UUIE_conferenceID_present 0x20
    ConferenceIdentifier conferenceID;
    FacilityReason reason;
#   define Facility_UUIE_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define Facility_UUIE_destExtraCallInfo_present 0x4000
    PFacility_UUIE_destExtraCallInfo destExtraCallInfo;
#   define Facility_UUIE_remoteExtensionAddress_present 0x2000
    AliasAddress remoteExtensionAddress;
#   define Facility_UUIE_tokens_present 0x1000
    PFacility_UUIE_tokens tokens;
#   define Facility_UUIE_cryptoTokens_present 0x800
    PFacility_UUIE_cryptoTokens cryptoTokens;
#   define conferences_present 0x400
    PFacility_UUIE_conferences conferences;
#   define Facility_UUIE_h245Address_present 0x200
    TransportAddress h245Address;
#   define Facility_UUIE_fastStart_present 0x100
    PFacility_UUIE_fastStart fastStart;
} Facility_UUIE;

typedef struct ConferenceList {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ConferenceList_conferenceID_present 0x80
    ConferenceIdentifier conferenceID;
#   define conferenceAlias_present 0x40
    AliasAddress conferenceAlias;
#   define ConferenceList_nonStandardData_present 0x20
    H225NonStandardParameter nonStandardData;
} ConferenceList;

typedef struct Progress_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ProtocolIdentifier protocolIdentifier;
    EndpointType destinationInfo;
#   define Progress_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
    CallIdentifier callIdentifier;
#   define Progress_UUIE_h245SecurityMode_present 0x40
    H245Security h245SecurityMode;
#   define Progress_UUIE_tokens_present 0x20
    PProgress_UUIE_tokens tokens;
#   define Progress_UUIE_cryptoTokens_present 0x10
    PProgress_UUIE_cryptoTokens cryptoTokens;
#   define Progress_UUIE_fastStart_present 0x8
    PProgress_UUIE_fastStart fastStart;
} Progress_UUIE;

typedef struct CryptoH323Token {
    ASN1choice_t choice;
    union {
#	define cryptoEPPwdHash_chosen 1
	CryptoH323Token_cryptoEPPwdHash cryptoEPPwdHash;
#	define cryptoGKPwdHash_chosen 2
	CryptoH323Token_cryptoGKPwdHash cryptoGKPwdHash;
#	define cryptoEPPwdEncr_chosen 3
	ENCRYPTED cryptoEPPwdEncr;
#	define cryptoGKPwdEncr_chosen 4
	ENCRYPTED cryptoGKPwdEncr;
#	define cryptoEPCert_chosen 5
	SIGNED_EncodedPwdCertToken cryptoEPCert;
#	define cryptoGKCert_chosen 6
	SIGNED_EncodedPwdCertToken cryptoGKCert;
#	define cryptoFastStart_chosen 7
	SIGNED_EncodedFastStartToken cryptoFastStart;
#	define nestedcryptoToken_chosen 8
	CryptoToken nestedcryptoToken;
    } u;
} CryptoH323Token;

typedef struct RasMessage {
    ASN1choice_t choice;
    union {
#	define gatekeeperRequest_chosen 1
	GatekeeperRequest gatekeeperRequest;
#	define gatekeeperConfirm_chosen 2
	GatekeeperConfirm gatekeeperConfirm;
#	define gatekeeperReject_chosen 3
	GatekeeperReject gatekeeperReject;
#	define registrationRequest_chosen 4
	RegistrationRequest registrationRequest;
#	define registrationConfirm_chosen 5
	RegistrationConfirm registrationConfirm;
#	define registrationReject_chosen 6
	RegistrationReject registrationReject;
#	define unregistrationRequest_chosen 7
	UnregistrationRequest unregistrationRequest;
#	define unregistrationConfirm_chosen 8
	UnregistrationConfirm unregistrationConfirm;
#	define unregistrationReject_chosen 9
	UnregistrationReject unregistrationReject;
#	define admissionRequest_chosen 10
	AdmissionRequest admissionRequest;
#	define admissionConfirm_chosen 11
	AdmissionConfirm admissionConfirm;
#	define admissionReject_chosen 12
	AdmissionReject admissionReject;
#	define bandwidthRequest_chosen 13
	BandwidthRequest bandwidthRequest;
#	define bandwidthConfirm_chosen 14
	BandwidthConfirm bandwidthConfirm;
#	define bandwidthReject_chosen 15
	BandwidthReject bandwidthReject;
#	define disengageRequest_chosen 16
	DisengageRequest disengageRequest;
#	define disengageConfirm_chosen 17
	DisengageConfirm disengageConfirm;
#	define disengageReject_chosen 18
	DisengageReject disengageReject;
#	define locationRequest_chosen 19
	LocationRequest locationRequest;
#	define locationConfirm_chosen 20
	LocationConfirm locationConfirm;
#	define locationReject_chosen 21
	LocationReject locationReject;
#	define infoRequest_chosen 22
	InfoRequest infoRequest;
#	define infoRequestResponse_chosen 23
	InfoRequestResponse infoRequestResponse;
#	define nonStandardMessage_chosen 24
	H225NonStandardMessage nonStandardMessage;
#	define unknownMessageResponse_chosen 25
	UnknownMessageResponse unknownMessageResponse;
#	define requestInProgress_chosen 26
	RequestInProgress requestInProgress;
#	define resourcesAvailableIndicate_chosen 27
	ResourcesAvailableIndicate resourcesAvailableIndicate;
#	define resourcesAvailableConfirm_chosen 28
	ResourcesAvailableConfirm resourcesAvailableConfirm;
#	define infoRequestAck_chosen 29
	InfoRequestAck infoRequestAck;
#	define infoRequestNak_chosen 30
	InfoRequestNak infoRequestNak;
    } u;
} RasMessage;
#define RasMessage_PDU 0
#define SIZE_H225ASN_Module_PDU_0 sizeof(RasMessage)

typedef struct InfoRequestResponse_perCallInfo_Seq_cryptoTokens {
    PInfoRequestResponse_perCallInfo_Seq_cryptoTokens next;
    CryptoH323Token value;
} InfoRequestResponse_perCallInfo_Seq_cryptoTokens_Element;

typedef struct ResourcesAvailableConfirm_cryptoTokens {
    PResourcesAvailableConfirm_cryptoTokens next;
    CryptoH323Token value;
} ResourcesAvailableConfirm_cryptoTokens_Element;

typedef struct ResourcesAvailableIndicate_cryptoTokens {
    PResourcesAvailableIndicate_cryptoTokens next;
    CryptoH323Token value;
} ResourcesAvailableIndicate_cryptoTokens_Element;

typedef struct RequestInProgress_cryptoTokens {
    PRequestInProgress_cryptoTokens next;
    CryptoH323Token value;
} RequestInProgress_cryptoTokens_Element;

typedef struct UnknownMessageResponse_cryptoTokens {
    PUnknownMessageResponse_cryptoTokens next;
    CryptoH323Token value;
} UnknownMessageResponse_cryptoTokens_Element;

typedef struct H225NonStandardMessage_cryptoTokens {
    PH225NonStandardMessage_cryptoTokens next;
    CryptoH323Token value;
} H225NonStandardMessage_cryptoTokens_Element;

typedef struct InfoRequestNak_cryptoTokens {
    PInfoRequestNak_cryptoTokens next;
    CryptoH323Token value;
} InfoRequestNak_cryptoTokens_Element;

typedef struct InfoRequestAck_cryptoTokens {
    PInfoRequestAck_cryptoTokens next;
    CryptoH323Token value;
} InfoRequestAck_cryptoTokens_Element;

typedef struct InfoRequestResponse_cryptoTokens {
    PInfoRequestResponse_cryptoTokens next;
    CryptoH323Token value;
} InfoRequestResponse_cryptoTokens_Element;

typedef struct InfoRequest_cryptoTokens {
    PInfoRequest_cryptoTokens next;
    CryptoH323Token value;
} InfoRequest_cryptoTokens_Element;

typedef struct DisengageReject_cryptoTokens {
    PDisengageReject_cryptoTokens next;
    CryptoH323Token value;
} DisengageReject_cryptoTokens_Element;

typedef struct DisengageConfirm_cryptoTokens {
    PDisengageConfirm_cryptoTokens next;
    CryptoH323Token value;
} DisengageConfirm_cryptoTokens_Element;

typedef struct DisengageRequest_cryptoTokens {
    PDisengageRequest_cryptoTokens next;
    CryptoH323Token value;
} DisengageRequest_cryptoTokens_Element;

typedef struct LocationReject_cryptoTokens {
    PLocationReject_cryptoTokens next;
    CryptoH323Token value;
} LocationReject_cryptoTokens_Element;

typedef struct LocationConfirm_cryptoTokens {
    PLocationConfirm_cryptoTokens next;
    CryptoH323Token value;
} LocationConfirm_cryptoTokens_Element;

typedef struct LocationRequest_cryptoTokens {
    PLocationRequest_cryptoTokens next;
    CryptoH323Token value;
} LocationRequest_cryptoTokens_Element;

typedef struct BandwidthReject_cryptoTokens {
    PBandwidthReject_cryptoTokens next;
    CryptoH323Token value;
} BandwidthReject_cryptoTokens_Element;

typedef struct BandwidthConfirm_cryptoTokens {
    PBandwidthConfirm_cryptoTokens next;
    CryptoH323Token value;
} BandwidthConfirm_cryptoTokens_Element;

typedef struct BandwidthRequest_cryptoTokens {
    PBandwidthRequest_cryptoTokens next;
    CryptoH323Token value;
} BandwidthRequest_cryptoTokens_Element;

typedef struct AdmissionReject_cryptoTokens {
    PAdmissionReject_cryptoTokens next;
    CryptoH323Token value;
} AdmissionReject_cryptoTokens_Element;

typedef struct AdmissionConfirm_cryptoTokens {
    PAdmissionConfirm_cryptoTokens next;
    CryptoH323Token value;
} AdmissionConfirm_cryptoTokens_Element;

typedef struct AdmissionRequest_cryptoTokens {
    PAdmissionRequest_cryptoTokens next;
    CryptoH323Token value;
} AdmissionRequest_cryptoTokens_Element;

typedef struct UnregistrationReject_cryptoTokens {
    PUnregistrationReject_cryptoTokens next;
    CryptoH323Token value;
} UnregistrationReject_cryptoTokens_Element;

typedef struct UnregistrationConfirm_cryptoTokens {
    PUnregistrationConfirm_cryptoTokens next;
    CryptoH323Token value;
} UnregistrationConfirm_cryptoTokens_Element;

typedef struct UnregistrationRequest_cryptoTokens {
    PUnregistrationRequest_cryptoTokens next;
    CryptoH323Token value;
} UnregistrationRequest_cryptoTokens_Element;

typedef struct RegistrationReject_cryptoTokens {
    PRegistrationReject_cryptoTokens next;
    CryptoH323Token value;
} RegistrationReject_cryptoTokens_Element;

typedef struct RegistrationConfirm_cryptoTokens {
    PRegistrationConfirm_cryptoTokens next;
    CryptoH323Token value;
} RegistrationConfirm_cryptoTokens_Element;

typedef struct RegistrationRequest_cryptoTokens {
    PRegistrationRequest_cryptoTokens next;
    CryptoH323Token value;
} RegistrationRequest_cryptoTokens_Element;

typedef struct GatekeeperReject_cryptoTokens {
    PGatekeeperReject_cryptoTokens next;
    CryptoH323Token value;
} GatekeeperReject_cryptoTokens_Element;

typedef struct GatekeeperConfirm_cryptoTokens {
    PGatekeeperConfirm_cryptoTokens next;
    CryptoH323Token value;
} GatekeeperConfirm_cryptoTokens_Element;

typedef struct GatekeeperRequest_cryptoTokens {
    PGatekeeperRequest_cryptoTokens next;
    CryptoH323Token value;
} GatekeeperRequest_cryptoTokens_Element;

typedef struct Endpoint_cryptoTokens {
    PEndpoint_cryptoTokens next;
    CryptoH323Token value;
} Endpoint_cryptoTokens_Element;

typedef struct Progress_UUIE_cryptoTokens {
    PProgress_UUIE_cryptoTokens next;
    CryptoH323Token value;
} Progress_UUIE_cryptoTokens_Element;

typedef struct Facility_UUIE_conferences {
    PFacility_UUIE_conferences next;
    ConferenceList value;
} Facility_UUIE_conferences_Element;

typedef struct Facility_UUIE_cryptoTokens {
    PFacility_UUIE_cryptoTokens next;
    CryptoH323Token value;
} Facility_UUIE_cryptoTokens_Element;

typedef struct Setup_UUIE_cryptoTokens {
    PSetup_UUIE_cryptoTokens next;
    CryptoH323Token value;
} Setup_UUIE_cryptoTokens_Element;

typedef struct Connect_UUIE_cryptoTokens {
    PConnect_UUIE_cryptoTokens next;
    CryptoH323Token value;
} Connect_UUIE_cryptoTokens_Element;

typedef struct CallProceeding_UUIE_cryptoTokens {
    PCallProceeding_UUIE_cryptoTokens next;
    CryptoH323Token value;
} CallProceeding_UUIE_cryptoTokens_Element;

typedef struct Alerting_UUIE_cryptoTokens {
    PAlerting_UUIE_cryptoTokens next;
    CryptoH323Token value;
} Alerting_UUIE_cryptoTokens_Element;

typedef struct H323_UU_PDU_h323_message_body {
    ASN1choice_t choice;
    union {
#	define setup_chosen 1
	Setup_UUIE setup;
#	define callProceeding_chosen 2
	CallProceeding_UUIE callProceeding;
#	define connect_chosen 3
	Connect_UUIE connect;
#	define alerting_chosen 4
	Alerting_UUIE alerting;
#	define information_chosen 5
	Information_UUIE information;
#	define releaseComplete_chosen 6
	ReleaseComplete_UUIE releaseComplete;
#	define facility_chosen 7
	Facility_UUIE facility;
#	define progress_chosen 8
	Progress_UUIE progress;
#	define empty_chosen 9
    } u;
} H323_UU_PDU_h323_message_body;

typedef struct H323_UU_PDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    H323_UU_PDU_h323_message_body h323_message_body;
#   define H323_UU_PDU_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define h4501SupplementaryService_present 0x8000
    PH323_UU_PDU_h4501SupplementaryService h4501SupplementaryService;
#   define h245Tunneling_present 0x4000
    ASN1bool_t h245Tunneling;
#   define h245Control_present 0x2000
    PH323_UU_PDU_h245Control h245Control;
#   define nonStandardControl_present 0x1000
    PH323_UU_PDU_nonStandardControl nonStandardControl;
} H323_UU_PDU;

typedef struct InfoRequestResponse_perCallInfo_Seq_pdu_Seq {
    H323_UU_PDU h323pdu;
    ASN1bool_t sent;
} InfoRequestResponse_perCallInfo_Seq_pdu_Seq;

typedef struct InfoRequestResponse_perCallInfo_Seq_pdu {
    PInfoRequestResponse_perCallInfo_Seq_pdu next;
    InfoRequestResponse_perCallInfo_Seq_pdu_Seq value;
} InfoRequestResponse_perCallInfo_Seq_pdu_Element;

typedef struct H323_UserInformation {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H323_UU_PDU h323_uu_pdu;
#   define user_data_present 0x80
    H323_UserInformation_user_data user_data;
} H323_UserInformation;
#define H323_UserInformation_PDU 1
#define SIZE_H225ASN_Module_PDU_1 sizeof(H323_UserInformation)


extern ASN1module_t H225ASN_Module;
extern void ASN1CALL H225ASN_Module_Startup(void);
extern void ASN1CALL H225ASN_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val);
    extern int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route_ElmFn(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route val);
    extern int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route_ElmFn(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route val);
	extern void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route_ElmFn(PTransportAddress_ipSourceRoute_route val);
    extern int ASN1CALL ASN1Enc_RTPSession_associatedSessionIds_ElmFn(ASN1encoding_t enc, PRTPSession_associatedSessionIds val);
    extern int ASN1CALL ASN1Dec_RTPSession_associatedSessionIds_ElmFn(ASN1decoding_t dec, PRTPSession_associatedSessionIds val);
	extern void ASN1CALL ASN1Free_RTPSession_associatedSessionIds_ElmFn(PRTPSession_associatedSessionIds val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_algorithmOIDs_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_algorithmOIDs val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_algorithmOIDs_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_algorithmOIDs val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_algorithmOIDs_ElmFn(PGatekeeperRequest_algorithmOIDs val);
    extern int ASN1CALL ASN1Enc_Progress_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PProgress_UUIE_fastStart val);
    extern int ASN1CALL ASN1Dec_Progress_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PProgress_UUIE_fastStart val);
	extern void ASN1CALL ASN1Free_Progress_UUIE_fastStart_ElmFn(PProgress_UUIE_fastStart val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PFacility_UUIE_fastStart val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PFacility_UUIE_fastStart val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_fastStart_ElmFn(PFacility_UUIE_fastStart val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PSetup_UUIE_fastStart val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PSetup_UUIE_fastStart val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_fastStart_ElmFn(PSetup_UUIE_fastStart val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCRV_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destExtraCRV val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCRV_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destExtraCRV val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_destExtraCRV_ElmFn(PSetup_UUIE_destExtraCRV val);
    extern int ASN1CALL ASN1Enc_Connect_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PConnect_UUIE_fastStart val);
    extern int ASN1CALL ASN1Dec_Connect_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PConnect_UUIE_fastStart val);
	extern void ASN1CALL ASN1Free_Connect_UUIE_fastStart_ElmFn(PConnect_UUIE_fastStart val);
    extern int ASN1CALL ASN1Enc_CallProceeding_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_fastStart val);
    extern int ASN1CALL ASN1Dec_CallProceeding_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_fastStart val);
	extern void ASN1CALL ASN1Free_CallProceeding_UUIE_fastStart_ElmFn(PCallProceeding_UUIE_fastStart val);
    extern int ASN1CALL ASN1Enc_Alerting_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_fastStart val);
    extern int ASN1CALL ASN1Dec_Alerting_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_fastStart val);
	extern void ASN1CALL ASN1Free_Alerting_UUIE_fastStart_ElmFn(PAlerting_UUIE_fastStart val);
    extern int ASN1CALL ASN1Enc_H323_UU_PDU_h245Control_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_h245Control val);
    extern int ASN1CALL ASN1Dec_H323_UU_PDU_h245Control_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_h245Control val);
	extern void ASN1CALL ASN1Free_H323_UU_PDU_h245Control_ElmFn(PH323_UU_PDU_h245Control val);
    extern int ASN1CALL ASN1Enc_H323_UU_PDU_h4501SupplementaryService_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_h4501SupplementaryService val);
    extern int ASN1CALL ASN1Dec_H323_UU_PDU_h4501SupplementaryService_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_h4501SupplementaryService val);
	extern void ASN1CALL ASN1Free_H323_UU_PDU_h4501SupplementaryService_ElmFn(PH323_UU_PDU_h4501SupplementaryService val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_tokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_tokens val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(PInfoRequestResponse_perCallInfo_Seq_tokens val);
    extern int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_tokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_tokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableConfirm_tokens val);
	extern void ASN1CALL ASN1Free_ResourcesAvailableConfirm_tokens_ElmFn(PResourcesAvailableConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_tokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_tokens val);
    extern int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_tokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_tokens val);
	extern void ASN1CALL ASN1Free_ResourcesAvailableIndicate_tokens_ElmFn(PResourcesAvailableIndicate_tokens val);
    extern int ASN1CALL ASN1Enc_RequestInProgress_tokens_ElmFn(ASN1encoding_t enc, PRequestInProgress_tokens val);
    extern int ASN1CALL ASN1Dec_RequestInProgress_tokens_ElmFn(ASN1decoding_t dec, PRequestInProgress_tokens val);
	extern void ASN1CALL ASN1Free_RequestInProgress_tokens_ElmFn(PRequestInProgress_tokens val);
    extern int ASN1CALL ASN1Enc_UnknownMessageResponse_tokens_ElmFn(ASN1encoding_t enc, PUnknownMessageResponse_tokens val);
    extern int ASN1CALL ASN1Dec_UnknownMessageResponse_tokens_ElmFn(ASN1decoding_t dec, PUnknownMessageResponse_tokens val);
	extern void ASN1CALL ASN1Free_UnknownMessageResponse_tokens_ElmFn(PUnknownMessageResponse_tokens val);
    extern int ASN1CALL ASN1Enc_H225NonStandardMessage_tokens_ElmFn(ASN1encoding_t enc, PH225NonStandardMessage_tokens val);
    extern int ASN1CALL ASN1Dec_H225NonStandardMessage_tokens_ElmFn(ASN1decoding_t dec, PH225NonStandardMessage_tokens val);
	extern void ASN1CALL ASN1Free_H225NonStandardMessage_tokens_ElmFn(PH225NonStandardMessage_tokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestNak_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestNak_tokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestNak_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestNak_tokens val);
	extern void ASN1CALL ASN1Free_InfoRequestNak_tokens_ElmFn(PInfoRequestNak_tokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestAck_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestAck_tokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestAck_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestAck_tokens val);
	extern void ASN1CALL ASN1Free_InfoRequestAck_tokens_ElmFn(PInfoRequestAck_tokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_tokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_tokens val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_tokens_ElmFn(PInfoRequestResponse_tokens val);
    extern int ASN1CALL ASN1Enc_InfoRequest_tokens_ElmFn(ASN1encoding_t enc, PInfoRequest_tokens val);
    extern int ASN1CALL ASN1Dec_InfoRequest_tokens_ElmFn(ASN1decoding_t dec, PInfoRequest_tokens val);
	extern void ASN1CALL ASN1Free_InfoRequest_tokens_ElmFn(PInfoRequest_tokens val);
    extern int ASN1CALL ASN1Enc_DisengageReject_tokens_ElmFn(ASN1encoding_t enc, PDisengageReject_tokens val);
    extern int ASN1CALL ASN1Dec_DisengageReject_tokens_ElmFn(ASN1decoding_t dec, PDisengageReject_tokens val);
	extern void ASN1CALL ASN1Free_DisengageReject_tokens_ElmFn(PDisengageReject_tokens val);
    extern int ASN1CALL ASN1Enc_DisengageConfirm_tokens_ElmFn(ASN1encoding_t enc, PDisengageConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_DisengageConfirm_tokens_ElmFn(ASN1decoding_t dec, PDisengageConfirm_tokens val);
	extern void ASN1CALL ASN1Free_DisengageConfirm_tokens_ElmFn(PDisengageConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_DisengageRequest_tokens_ElmFn(ASN1encoding_t enc, PDisengageRequest_tokens val);
    extern int ASN1CALL ASN1Dec_DisengageRequest_tokens_ElmFn(ASN1decoding_t dec, PDisengageRequest_tokens val);
	extern void ASN1CALL ASN1Free_DisengageRequest_tokens_ElmFn(PDisengageRequest_tokens val);
    extern int ASN1CALL ASN1Enc_LocationReject_tokens_ElmFn(ASN1encoding_t enc, PLocationReject_tokens val);
    extern int ASN1CALL ASN1Dec_LocationReject_tokens_ElmFn(ASN1decoding_t dec, PLocationReject_tokens val);
	extern void ASN1CALL ASN1Free_LocationReject_tokens_ElmFn(PLocationReject_tokens val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_tokens_ElmFn(ASN1encoding_t enc, PLocationConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_tokens_ElmFn(ASN1decoding_t dec, PLocationConfirm_tokens val);
	extern void ASN1CALL ASN1Free_LocationConfirm_tokens_ElmFn(PLocationConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_LocationRequest_tokens_ElmFn(ASN1encoding_t enc, PLocationRequest_tokens val);
    extern int ASN1CALL ASN1Dec_LocationRequest_tokens_ElmFn(ASN1decoding_t dec, PLocationRequest_tokens val);
	extern void ASN1CALL ASN1Free_LocationRequest_tokens_ElmFn(PLocationRequest_tokens val);
    extern int ASN1CALL ASN1Enc_BandwidthReject_tokens_ElmFn(ASN1encoding_t enc, PBandwidthReject_tokens val);
    extern int ASN1CALL ASN1Dec_BandwidthReject_tokens_ElmFn(ASN1decoding_t dec, PBandwidthReject_tokens val);
	extern void ASN1CALL ASN1Free_BandwidthReject_tokens_ElmFn(PBandwidthReject_tokens val);
    extern int ASN1CALL ASN1Enc_BandwidthConfirm_tokens_ElmFn(ASN1encoding_t enc, PBandwidthConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_BandwidthConfirm_tokens_ElmFn(ASN1decoding_t dec, PBandwidthConfirm_tokens val);
	extern void ASN1CALL ASN1Free_BandwidthConfirm_tokens_ElmFn(PBandwidthConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_BandwidthRequest_tokens_ElmFn(ASN1encoding_t enc, PBandwidthRequest_tokens val);
    extern int ASN1CALL ASN1Dec_BandwidthRequest_tokens_ElmFn(ASN1decoding_t dec, PBandwidthRequest_tokens val);
	extern void ASN1CALL ASN1Free_BandwidthRequest_tokens_ElmFn(PBandwidthRequest_tokens val);
    extern int ASN1CALL ASN1Enc_AdmissionReject_tokens_ElmFn(ASN1encoding_t enc, PAdmissionReject_tokens val);
    extern int ASN1CALL ASN1Dec_AdmissionReject_tokens_ElmFn(ASN1decoding_t dec, PAdmissionReject_tokens val);
	extern void ASN1CALL ASN1Free_AdmissionReject_tokens_ElmFn(PAdmissionReject_tokens val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_tokens_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_tokens_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_tokens val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_tokens_ElmFn(PAdmissionConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_tokens_ElmFn(ASN1encoding_t enc, PAdmissionRequest_tokens val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_tokens_ElmFn(ASN1decoding_t dec, PAdmissionRequest_tokens val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_tokens_ElmFn(PAdmissionRequest_tokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationReject_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationReject_tokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationReject_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationReject_tokens val);
	extern void ASN1CALL ASN1Free_UnregistrationReject_tokens_ElmFn(PUnregistrationReject_tokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationConfirm_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationConfirm_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationConfirm_tokens val);
	extern void ASN1CALL ASN1Free_UnregistrationConfirm_tokens_ElmFn(PUnregistrationConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_tokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_tokens val);
	extern void ASN1CALL ASN1Free_UnregistrationRequest_tokens_ElmFn(PUnregistrationRequest_tokens val);
    extern int ASN1CALL ASN1Enc_RegistrationReject_tokens_ElmFn(ASN1encoding_t enc, PRegistrationReject_tokens val);
    extern int ASN1CALL ASN1Dec_RegistrationReject_tokens_ElmFn(ASN1decoding_t dec, PRegistrationReject_tokens val);
	extern void ASN1CALL ASN1Free_RegistrationReject_tokens_ElmFn(PRegistrationReject_tokens val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_tokens_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_tokens_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_tokens val);
	extern void ASN1CALL ASN1Free_RegistrationConfirm_tokens_ElmFn(PRegistrationConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_tokens_ElmFn(ASN1encoding_t enc, PRegistrationRequest_tokens val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_tokens_ElmFn(ASN1decoding_t dec, PRegistrationRequest_tokens val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_tokens_ElmFn(PRegistrationRequest_tokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperReject_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperReject_tokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperReject_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperReject_tokens val);
	extern void ASN1CALL ASN1Free_GatekeeperReject_tokens_ElmFn(PGatekeeperReject_tokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperConfirm_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperConfirm_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_tokens val);
	extern void ASN1CALL ASN1Free_GatekeeperConfirm_tokens_ElmFn(PGatekeeperConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_authenticationCapability_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_authenticationCapability val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_authenticationCapability_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_authenticationCapability val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_authenticationCapability_ElmFn(PGatekeeperRequest_authenticationCapability val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_tokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_tokens val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_tokens_ElmFn(PGatekeeperRequest_tokens val);
    extern int ASN1CALL ASN1Enc_Endpoint_tokens_ElmFn(ASN1encoding_t enc, PEndpoint_tokens val);
    extern int ASN1CALL ASN1Dec_Endpoint_tokens_ElmFn(ASN1decoding_t dec, PEndpoint_tokens val);
	extern void ASN1CALL ASN1Free_Endpoint_tokens_ElmFn(PEndpoint_tokens val);
    extern int ASN1CALL ASN1Enc_Progress_UUIE_tokens_ElmFn(ASN1encoding_t enc, PProgress_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_Progress_UUIE_tokens_ElmFn(ASN1decoding_t dec, PProgress_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_Progress_UUIE_tokens_ElmFn(PProgress_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_tokens_ElmFn(ASN1encoding_t enc, PFacility_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_tokens_ElmFn(ASN1decoding_t dec, PFacility_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_tokens_ElmFn(PFacility_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_tokens_ElmFn(ASN1encoding_t enc, PSetup_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_tokens_ElmFn(ASN1decoding_t dec, PSetup_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_tokens_ElmFn(PSetup_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_Connect_UUIE_tokens_ElmFn(ASN1encoding_t enc, PConnect_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_Connect_UUIE_tokens_ElmFn(ASN1decoding_t dec, PConnect_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_Connect_UUIE_tokens_ElmFn(PConnect_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_CallProceeding_UUIE_tokens_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_CallProceeding_UUIE_tokens_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_CallProceeding_UUIE_tokens_ElmFn(PCallProceeding_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_Alerting_UUIE_tokens_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_Alerting_UUIE_tokens_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_Alerting_UUIE_tokens_ElmFn(PAlerting_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperConfirm_integrity_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_integrity val);
    extern int ASN1CALL ASN1Dec_GatekeeperConfirm_integrity_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_integrity val);
	extern void ASN1CALL ASN1Free_GatekeeperConfirm_integrity_ElmFn(PGatekeeperConfirm_integrity val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_integrity_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_integrity val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_integrity_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_integrity val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_integrity_ElmFn(PGatekeeperRequest_integrity val);
    extern int ASN1CALL ASN1Enc_NonStandardProtocol_dataRatesSupported_ElmFn(ASN1encoding_t enc, PNonStandardProtocol_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_NonStandardProtocol_dataRatesSupported_ElmFn(ASN1decoding_t dec, PNonStandardProtocol_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_NonStandardProtocol_dataRatesSupported_ElmFn(PNonStandardProtocol_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_T120OnlyCaps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PT120OnlyCaps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_T120OnlyCaps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PT120OnlyCaps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_T120OnlyCaps_dataRatesSupported_ElmFn(PT120OnlyCaps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_VoiceCaps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PVoiceCaps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_VoiceCaps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PVoiceCaps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_VoiceCaps_dataRatesSupported_ElmFn(PVoiceCaps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H324Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH324Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H324Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH324Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H324Caps_dataRatesSupported_ElmFn(PH324Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H323Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH323Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H323Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH323Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H323Caps_dataRatesSupported_ElmFn(PH323Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H322Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH322Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H322Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH322Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H322Caps_dataRatesSupported_ElmFn(PH322Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H321Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH321Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H321Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH321Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H321Caps_dataRatesSupported_ElmFn(PH321Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H320Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH320Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H320Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH320Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H320Caps_dataRatesSupported_ElmFn(PH320Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H310Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH310Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H310Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH310Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H310Caps_dataRatesSupported_ElmFn(PH310Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_h245SecurityCapability_ElmFn(ASN1encoding_t enc, PSetup_UUIE_h245SecurityCapability val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_h245SecurityCapability_ElmFn(ASN1decoding_t dec, PSetup_UUIE_h245SecurityCapability val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_h245SecurityCapability_ElmFn(PSetup_UUIE_h245SecurityCapability val);
    extern int ASN1CALL ASN1Enc_H323_UU_PDU_nonStandardControl_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_nonStandardControl val);
    extern int ASN1CALL ASN1Dec_H323_UU_PDU_nonStandardControl_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_nonStandardControl val);
	extern void ASN1CALL ASN1Free_H323_UU_PDU_nonStandardControl_ElmFn(PH323_UU_PDU_nonStandardControl val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_data val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_data val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(PInfoRequestResponse_perCallInfo_Seq_data val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_video val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_video val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(PInfoRequestResponse_perCallInfo_Seq_video val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_audio val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_audio val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(PInfoRequestResponse_perCallInfo_Seq_audio val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_ElmFn(PInfoRequestResponse_perCallInfo val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_callSignalAddress_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_callSignalAddress_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_callSignalAddress val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_callSignalAddress_ElmFn(PInfoRequestResponse_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_AdmissionReject_callSignalAddress_ElmFn(ASN1encoding_t enc, PAdmissionReject_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_AdmissionReject_callSignalAddress_ElmFn(ASN1decoding_t dec, PAdmissionReject_callSignalAddress val);
	extern void ASN1CALL ASN1Free_AdmissionReject_callSignalAddress_ElmFn(PAdmissionReject_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_callSignalAddress_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_callSignalAddress_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_callSignalAddress val);
	extern void ASN1CALL ASN1Free_UnregistrationRequest_callSignalAddress_ElmFn(PUnregistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_alternateGatekeeper val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_alternateGatekeeper val);
	extern void ASN1CALL ASN1Free_RegistrationConfirm_alternateGatekeeper_ElmFn(PRegistrationConfirm_alternateGatekeeper val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_callSignalAddress_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_callSignalAddress_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_callSignalAddress val);
	extern void ASN1CALL ASN1Free_RegistrationConfirm_callSignalAddress_ElmFn(PRegistrationConfirm_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_rasAddress_ElmFn(ASN1encoding_t enc, PRegistrationRequest_rasAddress val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_rasAddress_ElmFn(ASN1decoding_t dec, PRegistrationRequest_rasAddress val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_rasAddress_ElmFn(PRegistrationRequest_rasAddress val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_callSignalAddress_ElmFn(ASN1encoding_t enc, PRegistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_callSignalAddress_ElmFn(ASN1decoding_t dec, PRegistrationRequest_callSignalAddress val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_callSignalAddress_ElmFn(PRegistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_GatekeeperConfirm_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_alternateGatekeeper val);
    extern int ASN1CALL ASN1Dec_GatekeeperConfirm_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_alternateGatekeeper val);
	extern void ASN1CALL ASN1Free_GatekeeperConfirm_alternateGatekeeper_ElmFn(PGatekeeperConfirm_alternateGatekeeper val);
    extern int ASN1CALL ASN1Enc_AltGKInfo_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PAltGKInfo_alternateGatekeeper val);
    extern int ASN1CALL ASN1Dec_AltGKInfo_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PAltGKInfo_alternateGatekeeper val);
	extern void ASN1CALL ASN1Free_AltGKInfo_alternateGatekeeper_ElmFn(PAltGKInfo_alternateGatekeeper val);
    extern int ASN1CALL ASN1Enc_Endpoint_rasAddress_ElmFn(ASN1encoding_t enc, PEndpoint_rasAddress val);
    extern int ASN1CALL ASN1Dec_Endpoint_rasAddress_ElmFn(ASN1decoding_t dec, PEndpoint_rasAddress val);
	extern void ASN1CALL ASN1Free_Endpoint_rasAddress_ElmFn(PEndpoint_rasAddress val);
    extern int ASN1CALL ASN1Enc_Endpoint_callSignalAddress_ElmFn(ASN1encoding_t enc, PEndpoint_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_Endpoint_callSignalAddress_ElmFn(ASN1decoding_t dec, PEndpoint_callSignalAddress val);
	extern void ASN1CALL ASN1Free_Endpoint_callSignalAddress_ElmFn(PEndpoint_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_protocols_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_protocols val);
    extern int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_protocols_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_protocols val);
	extern void ASN1CALL ASN1Free_ResourcesAvailableIndicate_protocols_ElmFn(PResourcesAvailableIndicate_protocols val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_endpointAlias_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_endpointAlias val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_endpointAlias_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_endpointAlias val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_endpointAlias_ElmFn(PInfoRequestResponse_endpointAlias val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_alternateEndpoints_ElmFn(ASN1encoding_t enc, PLocationConfirm_alternateEndpoints val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_alternateEndpoints_ElmFn(ASN1decoding_t dec, PLocationConfirm_alternateEndpoints val);
	extern void ASN1CALL ASN1Free_LocationConfirm_alternateEndpoints_ElmFn(PLocationConfirm_alternateEndpoints val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_remoteExtensionAddress_ElmFn(ASN1encoding_t enc, PLocationConfirm_remoteExtensionAddress val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_remoteExtensionAddress_ElmFn(ASN1decoding_t dec, PLocationConfirm_remoteExtensionAddress val);
	extern void ASN1CALL ASN1Free_LocationConfirm_remoteExtensionAddress_ElmFn(PLocationConfirm_remoteExtensionAddress val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PLocationConfirm_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PLocationConfirm_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_LocationConfirm_destExtraCallInfo_ElmFn(PLocationConfirm_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_destinationInfo_ElmFn(ASN1encoding_t enc, PLocationConfirm_destinationInfo val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_destinationInfo_ElmFn(ASN1decoding_t dec, PLocationConfirm_destinationInfo val);
	extern void ASN1CALL ASN1Free_LocationConfirm_destinationInfo_ElmFn(PLocationConfirm_destinationInfo val);
    extern int ASN1CALL ASN1Enc_LocationRequest_sourceInfo_ElmFn(ASN1encoding_t enc, PLocationRequest_sourceInfo val);
    extern int ASN1CALL ASN1Dec_LocationRequest_sourceInfo_ElmFn(ASN1decoding_t dec, PLocationRequest_sourceInfo val);
	extern void ASN1CALL ASN1Free_LocationRequest_sourceInfo_ElmFn(PLocationRequest_sourceInfo val);
    extern int ASN1CALL ASN1Enc_LocationRequest_destinationInfo_ElmFn(ASN1encoding_t enc, PLocationRequest_destinationInfo val);
    extern int ASN1CALL ASN1Dec_LocationRequest_destinationInfo_ElmFn(ASN1decoding_t dec, PLocationRequest_destinationInfo val);
	extern void ASN1CALL ASN1Free_LocationRequest_destinationInfo_ElmFn(PLocationRequest_destinationInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_alternateEndpoints_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_alternateEndpoints val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_alternateEndpoints_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_alternateEndpoints val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_alternateEndpoints_ElmFn(PAdmissionConfirm_alternateEndpoints val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_remoteExtensionAddress_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_remoteExtensionAddress val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_remoteExtensionAddress_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_remoteExtensionAddress val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_remoteExtensionAddress_ElmFn(PAdmissionConfirm_remoteExtensionAddress val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_destExtraCallInfo_ElmFn(PAdmissionConfirm_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_destinationInfo_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_destinationInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_destinationInfo_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_destinationInfo val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_destinationInfo_ElmFn(PAdmissionConfirm_destinationInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_destAlternatives_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destAlternatives val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_destAlternatives_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destAlternatives val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_destAlternatives_ElmFn(PAdmissionRequest_destAlternatives val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_srcAlternatives_ElmFn(ASN1encoding_t enc, PAdmissionRequest_srcAlternatives val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_srcAlternatives_ElmFn(ASN1decoding_t dec, PAdmissionRequest_srcAlternatives val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_srcAlternatives_ElmFn(PAdmissionRequest_srcAlternatives val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_srcInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_srcInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_srcInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_srcInfo val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_srcInfo_ElmFn(PAdmissionRequest_srcInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_destExtraCallInfo_ElmFn(PAdmissionRequest_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_destinationInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destinationInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_destinationInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destinationInfo val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_destinationInfo_ElmFn(PAdmissionRequest_destinationInfo val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_alternateEndpoints val);
	extern void ASN1CALL ASN1Free_UnregistrationRequest_alternateEndpoints_ElmFn(PUnregistrationRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_endpointAlias_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_endpointAlias val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_endpointAlias_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_endpointAlias val);
	extern void ASN1CALL ASN1Free_UnregistrationRequest_endpointAlias_ElmFn(PUnregistrationRequest_endpointAlias val);
    extern int ASN1CALL ASN1Enc_RegistrationRejectReason_duplicateAlias_ElmFn(ASN1encoding_t enc, PRegistrationRejectReason_duplicateAlias val);
    extern int ASN1CALL ASN1Dec_RegistrationRejectReason_duplicateAlias_ElmFn(ASN1decoding_t dec, PRegistrationRejectReason_duplicateAlias val);
	extern void ASN1CALL ASN1Free_RegistrationRejectReason_duplicateAlias_ElmFn(PRegistrationRejectReason_duplicateAlias val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_terminalAlias_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_terminalAlias val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_terminalAlias_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_terminalAlias val);
	extern void ASN1CALL ASN1Free_RegistrationConfirm_terminalAlias_ElmFn(PRegistrationConfirm_terminalAlias val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PRegistrationRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PRegistrationRequest_alternateEndpoints val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_alternateEndpoints_ElmFn(PRegistrationRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_terminalAlias_ElmFn(ASN1encoding_t enc, PRegistrationRequest_terminalAlias val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_terminalAlias_ElmFn(ASN1decoding_t dec, PRegistrationRequest_terminalAlias val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_terminalAlias_ElmFn(PRegistrationRequest_terminalAlias val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_alternateEndpoints val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_alternateEndpoints_ElmFn(PGatekeeperRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_endpointAlias_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_endpointAlias val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_endpointAlias_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_endpointAlias val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_endpointAlias_ElmFn(PGatekeeperRequest_endpointAlias val);
    extern int ASN1CALL ASN1Enc_Endpoint_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PEndpoint_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_Endpoint_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PEndpoint_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_Endpoint_destExtraCallInfo_ElmFn(PEndpoint_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_Endpoint_remoteExtensionAddress_ElmFn(ASN1encoding_t enc, PEndpoint_remoteExtensionAddress val);
    extern int ASN1CALL ASN1Dec_Endpoint_remoteExtensionAddress_ElmFn(ASN1decoding_t dec, PEndpoint_remoteExtensionAddress val);
	extern void ASN1CALL ASN1Free_Endpoint_remoteExtensionAddress_ElmFn(PEndpoint_remoteExtensionAddress val);
    extern int ASN1CALL ASN1Enc_Endpoint_aliasAddress_ElmFn(ASN1encoding_t enc, PEndpoint_aliasAddress val);
    extern int ASN1CALL ASN1Dec_Endpoint_aliasAddress_ElmFn(ASN1decoding_t dec, PEndpoint_aliasAddress val);
	extern void ASN1CALL ASN1Free_Endpoint_aliasAddress_ElmFn(PEndpoint_aliasAddress val);
    extern int ASN1CALL ASN1Enc_NonStandardProtocol_supportedPrefixes_ElmFn(ASN1encoding_t enc, PNonStandardProtocol_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_NonStandardProtocol_supportedPrefixes_ElmFn(ASN1decoding_t dec, PNonStandardProtocol_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_NonStandardProtocol_supportedPrefixes_ElmFn(PNonStandardProtocol_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_T120OnlyCaps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PT120OnlyCaps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_T120OnlyCaps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PT120OnlyCaps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_T120OnlyCaps_supportedPrefixes_ElmFn(PT120OnlyCaps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_VoiceCaps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PVoiceCaps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_VoiceCaps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PVoiceCaps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_VoiceCaps_supportedPrefixes_ElmFn(PVoiceCaps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H324Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH324Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H324Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH324Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H324Caps_supportedPrefixes_ElmFn(PH324Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H323Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH323Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H323Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH323Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H323Caps_supportedPrefixes_ElmFn(PH323Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H322Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH322Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H322Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH322Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H322Caps_supportedPrefixes_ElmFn(PH322Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H321Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH321Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H321Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH321Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H321Caps_supportedPrefixes_ElmFn(PH321Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H320Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH320Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H320Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH320Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H320Caps_supportedPrefixes_ElmFn(PH320Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H310Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH310Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H310Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH310Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H310Caps_supportedPrefixes_ElmFn(PH310Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_GatewayInfo_protocol_ElmFn(ASN1encoding_t enc, PGatewayInfo_protocol val);
    extern int ASN1CALL ASN1Dec_GatewayInfo_protocol_ElmFn(ASN1decoding_t dec, PGatewayInfo_protocol val);
	extern void ASN1CALL ASN1Free_GatewayInfo_protocol_ElmFn(PGatewayInfo_protocol val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PFacility_UUIE_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PFacility_UUIE_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_destExtraCallInfo_ElmFn(PFacility_UUIE_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_alternativeAliasAddress_ElmFn(ASN1encoding_t enc, PFacility_UUIE_alternativeAliasAddress val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_alternativeAliasAddress_ElmFn(ASN1decoding_t dec, PFacility_UUIE_alternativeAliasAddress val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_alternativeAliasAddress_ElmFn(PFacility_UUIE_alternativeAliasAddress val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_destExtraCallInfo_ElmFn(PSetup_UUIE_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_destinationAddress_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destinationAddress val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_destinationAddress_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destinationAddress val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_destinationAddress_ElmFn(PSetup_UUIE_destinationAddress val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_sourceAddress_ElmFn(ASN1encoding_t enc, PSetup_UUIE_sourceAddress val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_sourceAddress_ElmFn(ASN1decoding_t dec, PSetup_UUIE_sourceAddress val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_sourceAddress_ElmFn(PSetup_UUIE_sourceAddress val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_ResourcesAvailableConfirm_cryptoTokens_ElmFn(PResourcesAvailableConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_cryptoTokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_cryptoTokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_cryptoTokens val);
	extern void ASN1CALL ASN1Free_ResourcesAvailableIndicate_cryptoTokens_ElmFn(PResourcesAvailableIndicate_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_RequestInProgress_cryptoTokens_ElmFn(ASN1encoding_t enc, PRequestInProgress_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_RequestInProgress_cryptoTokens_ElmFn(ASN1decoding_t dec, PRequestInProgress_cryptoTokens val);
	extern void ASN1CALL ASN1Free_RequestInProgress_cryptoTokens_ElmFn(PRequestInProgress_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_UnknownMessageResponse_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnknownMessageResponse_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_UnknownMessageResponse_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnknownMessageResponse_cryptoTokens val);
	extern void ASN1CALL ASN1Free_UnknownMessageResponse_cryptoTokens_ElmFn(PUnknownMessageResponse_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_H225NonStandardMessage_cryptoTokens_ElmFn(ASN1encoding_t enc, PH225NonStandardMessage_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_H225NonStandardMessage_cryptoTokens_ElmFn(ASN1decoding_t dec, PH225NonStandardMessage_cryptoTokens val);
	extern void ASN1CALL ASN1Free_H225NonStandardMessage_cryptoTokens_ElmFn(PH225NonStandardMessage_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestNak_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestNak_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestNak_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestNak_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequestNak_cryptoTokens_ElmFn(PInfoRequestNak_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestAck_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestAck_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestAck_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestAck_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequestAck_cryptoTokens_ElmFn(PInfoRequestAck_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_cryptoTokens_ElmFn(PInfoRequestResponse_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequest_cryptoTokens_ElmFn(PInfoRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_DisengageReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_DisengageReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_DisengageReject_cryptoTokens_ElmFn(PDisengageReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_DisengageConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_DisengageConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_DisengageConfirm_cryptoTokens_ElmFn(PDisengageConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_DisengageRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_DisengageRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_DisengageRequest_cryptoTokens_ElmFn(PDisengageRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_LocationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_LocationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_LocationReject_cryptoTokens_ElmFn(PLocationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_LocationConfirm_cryptoTokens_ElmFn(PLocationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_LocationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_LocationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_LocationRequest_cryptoTokens_ElmFn(PLocationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_BandwidthReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_BandwidthReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_BandwidthReject_cryptoTokens_ElmFn(PBandwidthReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_BandwidthConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_BandwidthConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_BandwidthConfirm_cryptoTokens_ElmFn(PBandwidthConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_BandwidthRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_BandwidthRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_BandwidthRequest_cryptoTokens_ElmFn(PBandwidthRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_AdmissionReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_AdmissionReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_AdmissionReject_cryptoTokens_ElmFn(PAdmissionReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_cryptoTokens_ElmFn(PAdmissionConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_cryptoTokens_ElmFn(PAdmissionRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_UnregistrationReject_cryptoTokens_ElmFn(PUnregistrationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_UnregistrationConfirm_cryptoTokens_ElmFn(PUnregistrationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_UnregistrationRequest_cryptoTokens_ElmFn(PUnregistrationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_RegistrationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_RegistrationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_RegistrationReject_cryptoTokens_ElmFn(PRegistrationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_RegistrationConfirm_cryptoTokens_ElmFn(PRegistrationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_cryptoTokens_ElmFn(PRegistrationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_GatekeeperReject_cryptoTokens_ElmFn(PGatekeeperReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_GatekeeperConfirm_cryptoTokens_ElmFn(PGatekeeperConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_cryptoTokens_ElmFn(PGatekeeperRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Endpoint_cryptoTokens_ElmFn(ASN1encoding_t enc, PEndpoint_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Endpoint_cryptoTokens_ElmFn(ASN1decoding_t dec, PEndpoint_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Endpoint_cryptoTokens_ElmFn(PEndpoint_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Progress_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PProgress_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Progress_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PProgress_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Progress_UUIE_cryptoTokens_ElmFn(PProgress_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_conferences_ElmFn(ASN1encoding_t enc, PFacility_UUIE_conferences val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_conferences_ElmFn(ASN1decoding_t dec, PFacility_UUIE_conferences val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_conferences_ElmFn(PFacility_UUIE_conferences val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PFacility_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PFacility_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_cryptoTokens_ElmFn(PFacility_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PSetup_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PSetup_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_cryptoTokens_ElmFn(PSetup_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Connect_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PConnect_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Connect_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PConnect_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Connect_UUIE_cryptoTokens_ElmFn(PConnect_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_CallProceeding_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_CallProceeding_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_CallProceeding_UUIE_cryptoTokens_ElmFn(PCallProceeding_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Alerting_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Alerting_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Alerting_UUIE_cryptoTokens_ElmFn(PAlerting_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_pdu val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_pdu val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(PInfoRequestResponse_perCallInfo_Seq_pdu val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _H225ASN_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h245asn.c ===
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for Multimedia System Control (H.245) */

#include <windows.h>
#include "h245asn.h"

ASN1module_t H245ASN_Module = NULL;

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1_errorCorrection(ASN1encoding_t enc, NewATMVCIndication_aal_aal1_errorCorrection *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1_clockRecovery(ASN1encoding_t enc, NewATMVCIndication_aal_aal1_clockRecovery *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(ASN1encoding_t enc, MiscellaneousCommand_type_progressiveRefinementStart_repeatCount *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode_eRM_recovery(ASN1encoding_t enc, V76LogicalChannelParameters_mode_eRM_recovery *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_extendedPAR_Set *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI_customPCF_Set(ASN1encoding_t enc, CustomPictureFormat_mPI_customPCF_Set *val);
static int ASN1CALL ASN1Enc_VCCapability_availableBitRates_type_rangeOfBitRates(ASN1encoding_t enc, VCCapability_availableBitRates_type_rangeOfBitRates *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(ASN1encoding_t enc, TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *val);
static int ASN1CALL ASN1Enc_VCCapability_availableBitRates_type(ASN1encoding_t enc, VCCapability_availableBitRates_type *val);
static int ASN1CALL ASN1Enc_H223Capability_h223MultiplexTableCapability_enhanced(ASN1encoding_t enc, H223Capability_h223MultiplexTableCapability_enhanced *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI_customPCF(ASN1encoding_t enc, CustomPictureFormat_mPI_customPCF *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_extendedPAR *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val);
static int ASN1CALL ASN1Enc_H223LogicalChannelParameters_adaptationLayerType_al3(ASN1encoding_t enc, H223LogicalChannelParameters_adaptationLayerType_al3 *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode_eRM(ASN1encoding_t enc, V76LogicalChannelParameters_mode_eRM *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_routing(ASN1encoding_t enc, UnicastAddress_iPSourceRouteAddress_routing *val);
static int ASN1CALL ASN1Enc_H223ModeParameters_adaptationLayerType_al3(ASN1encoding_t enc, H223ModeParameters_adaptationLayerType_al3 *val);
static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(ASN1encoding_t enc, SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val);
static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart(ASN1encoding_t enc, MiscellaneousCommand_type_progressiveRefinementStart *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_videoFastUpdateMB(ASN1encoding_t enc, MiscellaneousCommand_type_videoFastUpdateMB *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_videoFastUpdateGOB(ASN1encoding_t enc, MiscellaneousCommand_type_videoFastUpdateGOB *val);
static int ASN1CALL ASN1Enc_MiscellaneousIndication_type_videoNotDecodedMBs(ASN1encoding_t enc, MiscellaneousIndication_type_videoNotDecodedMBs *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal5(ASN1encoding_t enc, NewATMVCIndication_aal_aal5 *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1(ASN1encoding_t enc, NewATMVCIndication_aal_aal1 *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_reverseParameters_multiplex(ASN1encoding_t enc, NewATMVCIndication_reverseParameters_multiplex *val);
static int ASN1CALL ASN1Enc_UserInputIndication_signal_rtp(ASN1encoding_t enc, UserInputIndication_signal_rtp *val);
static int ASN1CALL ASN1Enc_UserInputIndication_signalUpdate_rtp(ASN1encoding_t enc, UserInputIndication_signalUpdate_rtp *val);
static int ASN1CALL ASN1Enc_UserInputIndication_signalUpdate(ASN1encoding_t enc, UserInputIndication_signalUpdate *val);
static int ASN1CALL ASN1Enc_UserInputIndication_signal(ASN1encoding_t enc, UserInputIndication_signal *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_reverseParameters(ASN1encoding_t enc, NewATMVCIndication_reverseParameters *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_multiplex(ASN1encoding_t enc, NewATMVCIndication_multiplex *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_aal(ASN1encoding_t enc, NewATMVCIndication_aal *val);
static int ASN1CALL ASN1Enc_JitterIndication_scope(ASN1encoding_t enc, JitterIndication_scope *val);
static int ASN1CALL ASN1Enc_FunctionNotSupported_cause(ASN1encoding_t enc, FunctionNotSupported_cause *val);
static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration_h223AnnexADoubleFlag(ASN1encoding_t enc, H223MultiplexReconfiguration_h223AnnexADoubleFlag *val);
static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration_h223ModeChange(ASN1encoding_t enc, H223MultiplexReconfiguration_h223ModeChange *val);
static int ASN1CALL ASN1Enc_EndSessionCommand_isdnOptions(ASN1encoding_t enc, EndSessionCommand_isdnOptions *val);
static int ASN1CALL ASN1Enc_EndSessionCommand_gstnOptions(ASN1encoding_t enc, EndSessionCommand_gstnOptions *val);
static int ASN1CALL ASN1Enc_FlowControlCommand_restriction(ASN1encoding_t enc, FlowControlCommand_restriction *val);
static int ASN1CALL ASN1Enc_FlowControlCommand_scope(ASN1encoding_t enc, FlowControlCommand_scope *val);
static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest(ASN1encoding_t enc, SendTerminalCapabilitySet_specificRequest *val);
static int ASN1CALL ASN1Enc_RemoteMCResponse_reject(ASN1encoding_t enc, RemoteMCResponse_reject *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_sendThisSourceResponse(ASN1encoding_t enc, ConferenceResponse_sendThisSourceResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_makeTerminalBroadcasterResponse(ASN1encoding_t enc, ConferenceResponse_makeTerminalBroadcasterResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_broadcastMyLogicalChannelResponse(ASN1encoding_t enc, ConferenceResponse_broadcastMyLogicalChannelResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_extensionAddressResponse(ASN1encoding_t enc, ConferenceResponse_extensionAddressResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_makeMeChairResponse(ASN1encoding_t enc, ConferenceResponse_makeMeChairResponse *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopReject_cause(ASN1encoding_t enc, MaintenanceLoopReject_cause *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopReject_type(ASN1encoding_t enc, MaintenanceLoopReject_type *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopAck_type(ASN1encoding_t enc, MaintenanceLoopAck_type *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopRequest_type(ASN1encoding_t enc, MaintenanceLoopRequest_type *val);
static int ASN1CALL ASN1Enc_G7231AnnexCMode_g723AnnexCAudioMode(ASN1encoding_t enc, G7231AnnexCMode_g723AnnexCAudioMode *val);
static int ASN1CALL ASN1Enc_IS13818AudioMode_multichannelType(ASN1encoding_t enc, IS13818AudioMode_multichannelType *val);
static int ASN1CALL ASN1Enc_IS13818AudioMode_audioSampling(ASN1encoding_t enc, IS13818AudioMode_audioSampling *val);
static int ASN1CALL ASN1Enc_IS13818AudioMode_audioLayer(ASN1encoding_t enc, IS13818AudioMode_audioLayer *val);
static int ASN1CALL ASN1Enc_IS11172AudioMode_multichannelType(ASN1encoding_t enc, IS11172AudioMode_multichannelType *val);
static int ASN1CALL ASN1Enc_IS11172AudioMode_audioSampling(ASN1encoding_t enc, IS11172AudioMode_audioSampling *val);
static int ASN1CALL ASN1Enc_IS11172AudioMode_audioLayer(ASN1encoding_t enc, IS11172AudioMode_audioLayer *val);
static int ASN1CALL ASN1Enc_AudioMode_g7231(ASN1encoding_t enc, AudioMode_g7231 *val);
static int ASN1CALL ASN1Enc_H263VideoMode_resolution(ASN1encoding_t enc, H263VideoMode_resolution *val);
static int ASN1CALL ASN1Enc_H262VideoMode_profileAndLevel(ASN1encoding_t enc, H262VideoMode_profileAndLevel *val);
static int ASN1CALL ASN1Enc_H261VideoMode_resolution(ASN1encoding_t enc, H261VideoMode_resolution *val);
static int ASN1CALL ASN1Enc_RequestModeReject_cause(ASN1encoding_t enc, RequestModeReject_cause *val);
static int ASN1CALL ASN1Enc_RequestModeAck_response(ASN1encoding_t enc, RequestModeAck_response *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryRelease_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryRelease_entryNumbers *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryRejectionDescriptions_cause(ASN1encoding_t enc, RequestMultiplexEntryRejectionDescriptions_cause *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryReject_entryNumbers *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryAck_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryAck_entryNumbers *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntry_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntry_entryNumbers *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendRelease_multiplexTableEntryNumber(ASN1encoding_t enc, MultiplexEntrySendRelease_multiplexTableEntryNumber *val);
static int ASN1CALL ASN1Enc_MultiplexEntryRejectionDescriptions_cause(ASN1encoding_t enc, MultiplexEntryRejectionDescriptions_cause *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendAck_multiplexTableEntryNumber(ASN1encoding_t enc, MultiplexEntrySendAck_multiplexTableEntryNumber *val);
static int ASN1CALL ASN1Enc_MultiplexElement_repeatCount(ASN1encoding_t enc, MultiplexElement_repeatCount *val);
static int ASN1CALL ASN1Enc_MultiplexElement_type(ASN1encoding_t enc, MultiplexElement_type *val);
static int ASN1CALL ASN1Enc_RequestChannelCloseReject_cause(ASN1encoding_t enc, RequestChannelCloseReject_cause *val);
static int ASN1CALL ASN1Enc_RequestChannelClose_reason(ASN1encoding_t enc, RequestChannelClose_reason *val);
static int ASN1CALL ASN1Enc_CloseLogicalChannel_reason(ASN1encoding_t enc, CloseLogicalChannel_reason *val);
static int ASN1CALL ASN1Enc_CloseLogicalChannel_source(ASN1encoding_t enc, CloseLogicalChannel_source *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelReject_cause(ASN1encoding_t enc, OpenLogicalChannelReject_cause *val);
static int ASN1CALL ASN1Enc_MulticastAddress_iP6Address(ASN1encoding_t enc, MulticastAddress_iP6Address *val);
static int ASN1CALL ASN1Enc_MulticastAddress_iPAddress(ASN1encoding_t enc, MulticastAddress_iPAddress *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress(ASN1encoding_t enc, UnicastAddress_iPSourceRouteAddress *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iP6Address(ASN1encoding_t enc, UnicastAddress_iP6Address *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPXAddress(ASN1encoding_t enc, UnicastAddress_iPXAddress *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPAddress(ASN1encoding_t enc, UnicastAddress_iPAddress *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode(ASN1encoding_t enc, V76LogicalChannelParameters_mode *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_suspendResume(ASN1encoding_t enc, V76LogicalChannelParameters_suspendResume *val);
static int ASN1CALL ASN1Enc_H223AnnexCArqParameters_numberOfRetransmissions(ASN1encoding_t enc, H223AnnexCArqParameters_numberOfRetransmissions *val);
static int ASN1CALL ASN1Enc_H223AL3MParameters_crcLength(ASN1encoding_t enc, H223AL3MParameters_crcLength *val);
static int ASN1CALL ASN1Enc_H223AL3MParameters_headerFormat(ASN1encoding_t enc, H223AL3MParameters_headerFormat *val);
static int ASN1CALL ASN1Enc_H223AL2MParameters_headerFEC(ASN1encoding_t enc, H223AL2MParameters_headerFEC *val);
static int ASN1CALL ASN1Enc_H223AL1MParameters_crcLength(ASN1encoding_t enc, H223AL1MParameters_crcLength *val);
static int ASN1CALL ASN1Enc_H223AL1MParameters_headerFEC(ASN1encoding_t enc, H223AL1MParameters_headerFEC *val);
static int ASN1CALL ASN1Enc_H223AL1MParameters_transferMode(ASN1encoding_t enc, H223AL1MParameters_transferMode *val);
static int ASN1CALL ASN1Enc_Q2931Address_address(ASN1encoding_t enc, Q2931Address_address *val);
static int ASN1CALL ASN1Enc_NetworkAccessParameters_t120SetupProcedure(ASN1encoding_t enc, NetworkAccessParameters_t120SetupProcedure *val);
static int ASN1CALL ASN1Enc_NetworkAccessParameters_distribution(ASN1encoding_t enc, NetworkAccessParameters_distribution *val);
static int ASN1CALL ASN1Enc_T84Profile_t84Restricted(ASN1encoding_t enc, T84Profile_t84Restricted *val);
static int ASN1CALL ASN1Enc_G7231AnnexCCapability_g723AnnexCAudioMode(ASN1encoding_t enc, G7231AnnexCCapability_g723AnnexCAudioMode *val);
static int ASN1CALL ASN1Enc_AudioCapability_g7231(ASN1encoding_t enc, AudioCapability_g7231 *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI(ASN1encoding_t enc, CustomPictureFormat_mPI *val);
static int ASN1CALL ASN1Enc_RefPictureSelection_videoBackChannelSend(ASN1encoding_t enc, RefPictureSelection_videoBackChannelSend *val);
static int ASN1CALL ASN1Enc_RefPictureSelection_additionalPictureMemory(ASN1encoding_t enc, RefPictureSelection_additionalPictureMemory *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyFrameMapping_frameSequence(ASN1encoding_t enc, RTPH263VideoRedundancyFrameMapping_frameSequence *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_containedThreads(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding_containedThreads *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding_frameToThreadMapping *val);
static int ASN1CALL ASN1Enc_RedundancyEncodingCapability_secondaryEncoding(ASN1encoding_t enc, PRedundancyEncodingCapability_secondaryEncoding *val);
static int ASN1CALL ASN1Enc_H2250Capability_mcCapability(ASN1encoding_t enc, H2250Capability_mcCapability *val);
static int ASN1CALL ASN1Enc_H223Capability_mobileOperationTransmitCapability(ASN1encoding_t enc, H223Capability_mobileOperationTransmitCapability *val);
static int ASN1CALL ASN1Enc_H223Capability_h223MultiplexTableCapability(ASN1encoding_t enc, H223Capability_h223MultiplexTableCapability *val);
static int ASN1CALL ASN1Enc_VCCapability_availableBitRates(ASN1encoding_t enc, VCCapability_availableBitRates *val);
static int ASN1CALL ASN1Enc_VCCapability_aal5(ASN1encoding_t enc, VCCapability_aal5 *val);
static int ASN1CALL ASN1Enc_VCCapability_aal1(ASN1encoding_t enc, VCCapability_aal1 *val);
static int ASN1CALL ASN1Enc_Capability_h233EncryptionReceiveCapability(ASN1encoding_t enc, Capability_h233EncryptionReceiveCapability *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject_cause(ASN1encoding_t enc, TerminalCapabilitySetReject_cause *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationReject_cause(ASN1encoding_t enc, MasterSlaveDeterminationReject_cause *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationAck_decision(ASN1encoding_t enc, MasterSlaveDeterminationAck_decision *val);
static int ASN1CALL ASN1Enc_NonStandardIdentifier_h221NonStandard(ASN1encoding_t enc, NonStandardIdentifier_h221NonStandard *val);
static int ASN1CALL ASN1Enc_NonStandardIdentifier(ASN1encoding_t enc, NonStandardIdentifier *val);
static int ASN1CALL ASN1Enc_MasterSlaveDetermination(ASN1encoding_t enc, MasterSlaveDetermination *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationAck(ASN1encoding_t enc, MasterSlaveDeterminationAck *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationReject(ASN1encoding_t enc, MasterSlaveDeterminationReject *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationRelease(ASN1encoding_t enc, MasterSlaveDeterminationRelease *val);
static int ASN1CALL ASN1Enc_CapabilityDescriptor(ASN1encoding_t enc, CapabilityDescriptor *val);
static int ASN1CALL ASN1Enc_AlternativeCapabilitySet(ASN1encoding_t enc, AlternativeCapabilitySet *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetAck(ASN1encoding_t enc, TerminalCapabilitySetAck *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject(ASN1encoding_t enc, TerminalCapabilitySetReject *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetRelease(ASN1encoding_t enc, TerminalCapabilitySetRelease *val);
static int ASN1CALL ASN1Enc_H222Capability(ASN1encoding_t enc, H222Capability *val);
static int ASN1CALL ASN1Enc_VCCapability(ASN1encoding_t enc, VCCapability *val);
static int ASN1CALL ASN1Enc_H223AnnexCCapability(ASN1encoding_t enc, H223AnnexCCapability *val);
static int ASN1CALL ASN1Enc_V75Capability(ASN1encoding_t enc, V75Capability *val);
static int ASN1CALL ASN1Enc_QOSMode(ASN1encoding_t enc, QOSMode *val);
static int ASN1CALL ASN1Enc_ATMParameters(ASN1encoding_t enc, ATMParameters *val);
static int ASN1CALL ASN1Enc_MediaTransportType(ASN1encoding_t enc, MediaTransportType *val);
static int ASN1CALL ASN1Enc_MediaChannelCapability(ASN1encoding_t enc, MediaChannelCapability *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyFrameMapping(ASN1encoding_t enc, RTPH263VideoRedundancyFrameMapping *val);
static int ASN1CALL ASN1Enc_MultipointCapability(ASN1encoding_t enc, MultipointCapability *val);
static int ASN1CALL ASN1Enc_MediaDistributionCapability(ASN1encoding_t enc, MediaDistributionCapability *val);
static int ASN1CALL ASN1Enc_H261VideoCapability(ASN1encoding_t enc, H261VideoCapability *val);
static int ASN1CALL ASN1Enc_H262VideoCapability(ASN1encoding_t enc, H262VideoCapability *val);
static int ASN1CALL ASN1Enc_EnhancementLayerInfo(ASN1encoding_t enc, EnhancementLayerInfo *val);
static int ASN1CALL ASN1Enc_TransparencyParameters(ASN1encoding_t enc, TransparencyParameters *val);
static int ASN1CALL ASN1Enc_RefPictureSelection(ASN1encoding_t enc, RefPictureSelection *val);
static int ASN1CALL ASN1Enc_CustomPictureClockFrequency(ASN1encoding_t enc, CustomPictureClockFrequency *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat(ASN1encoding_t enc, CustomPictureFormat *val);
static int ASN1CALL ASN1Enc_H263ModeComboFlags(ASN1encoding_t enc, H263ModeComboFlags *val);
static int ASN1CALL ASN1Enc_IS11172VideoCapability(ASN1encoding_t enc, IS11172VideoCapability *val);
static int ASN1CALL ASN1Enc_G7231AnnexCCapability(ASN1encoding_t enc, G7231AnnexCCapability *val);
static int ASN1CALL ASN1Enc_IS11172AudioCapability(ASN1encoding_t enc, IS11172AudioCapability *val);
static int ASN1CALL ASN1Enc_IS13818AudioCapability(ASN1encoding_t enc, IS13818AudioCapability *val);
static int ASN1CALL ASN1Enc_GSMAudioCapability(ASN1encoding_t enc, GSMAudioCapability *val);
static int ASN1CALL ASN1Enc_V42bis(ASN1encoding_t enc, V42bis *val);
static int ASN1CALL ASN1Enc_T84Profile(ASN1encoding_t enc, T84Profile *val);
static int ASN1CALL ASN1Enc_ConferenceCapability(ASN1encoding_t enc, ConferenceCapability *val);
static int ASN1CALL ASN1Enc_Q2931Address(ASN1encoding_t enc, Q2931Address *val);
static int ASN1CALL ASN1Enc_V75Parameters(ASN1encoding_t enc, V75Parameters *val);
static int ASN1CALL ASN1Enc_H222LogicalChannelParameters(ASN1encoding_t enc, H222LogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_H223AL2MParameters(ASN1encoding_t enc, H223AL2MParameters *val);
static int ASN1CALL ASN1Enc_H223AnnexCArqParameters(ASN1encoding_t enc, H223AnnexCArqParameters *val);
static int ASN1CALL ASN1Enc_CRCLength(ASN1encoding_t enc, CRCLength *val);
static int ASN1CALL ASN1Enc_EscrowData(ASN1encoding_t enc, EscrowData *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelReject(ASN1encoding_t enc, OpenLogicalChannelReject *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelConfirm(ASN1encoding_t enc, OpenLogicalChannelConfirm *val);
static int ASN1CALL ASN1Enc_CloseLogicalChannel(ASN1encoding_t enc, CloseLogicalChannel *val);
static int ASN1CALL ASN1Enc_CloseLogicalChannelAck(ASN1encoding_t enc, CloseLogicalChannelAck *val);
static int ASN1CALL ASN1Enc_RequestChannelCloseAck(ASN1encoding_t enc, RequestChannelCloseAck *val);
static int ASN1CALL ASN1Enc_RequestChannelCloseReject(ASN1encoding_t enc, RequestChannelCloseReject *val);
static int ASN1CALL ASN1Enc_RequestChannelCloseRelease(ASN1encoding_t enc, RequestChannelCloseRelease *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySend(ASN1encoding_t enc, MultiplexEntrySend *val);
static int ASN1CALL ASN1Enc_MultiplexElement(ASN1encoding_t enc, MultiplexElement *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendAck(ASN1encoding_t enc, MultiplexEntrySendAck *val);
static int ASN1CALL ASN1Enc_MultiplexEntryRejectionDescriptions(ASN1encoding_t enc, MultiplexEntryRejectionDescriptions *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendRelease(ASN1encoding_t enc, MultiplexEntrySendRelease *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntry(ASN1encoding_t enc, RequestMultiplexEntry *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryAck(ASN1encoding_t enc, RequestMultiplexEntryAck *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryRejectionDescriptions(ASN1encoding_t enc, RequestMultiplexEntryRejectionDescriptions *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryRelease(ASN1encoding_t enc, RequestMultiplexEntryRelease *val);
static int ASN1CALL ASN1Enc_RequestMode(ASN1encoding_t enc, RequestMode *val);
static int ASN1CALL ASN1Enc_RequestModeAck(ASN1encoding_t enc, RequestModeAck *val);
static int ASN1CALL ASN1Enc_RequestModeReject(ASN1encoding_t enc, RequestModeReject *val);
static int ASN1CALL ASN1Enc_RequestModeRelease(ASN1encoding_t enc, RequestModeRelease *val);
static int ASN1CALL ASN1Enc_V76ModeParameters(ASN1encoding_t enc, V76ModeParameters *val);
static int ASN1CALL ASN1Enc_H261VideoMode(ASN1encoding_t enc, H261VideoMode *val);
static int ASN1CALL ASN1Enc_H262VideoMode(ASN1encoding_t enc, H262VideoMode *val);
static int ASN1CALL ASN1Enc_IS11172VideoMode(ASN1encoding_t enc, IS11172VideoMode *val);
static int ASN1CALL ASN1Enc_IS11172AudioMode(ASN1encoding_t enc, IS11172AudioMode *val);
static int ASN1CALL ASN1Enc_IS13818AudioMode(ASN1encoding_t enc, IS13818AudioMode *val);
static int ASN1CALL ASN1Enc_G7231AnnexCMode(ASN1encoding_t enc, G7231AnnexCMode *val);
static int ASN1CALL ASN1Enc_RoundTripDelayRequest(ASN1encoding_t enc, RoundTripDelayRequest *val);
static int ASN1CALL ASN1Enc_RoundTripDelayResponse(ASN1encoding_t enc, RoundTripDelayResponse *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopRequest(ASN1encoding_t enc, MaintenanceLoopRequest *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopAck(ASN1encoding_t enc, MaintenanceLoopAck *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopReject(ASN1encoding_t enc, MaintenanceLoopReject *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopOffCommand(ASN1encoding_t enc, MaintenanceLoopOffCommand *val);
static int ASN1CALL ASN1Enc_CommunicationModeCommand(ASN1encoding_t enc, CommunicationModeCommand *val);
static int ASN1CALL ASN1Enc_CommunicationModeRequest(ASN1encoding_t enc, CommunicationModeRequest *val);
static int ASN1CALL ASN1Enc_CommunicationModeResponse(ASN1encoding_t enc, CommunicationModeResponse *val);
static int ASN1CALL ASN1Enc_Criteria(ASN1encoding_t enc, Criteria *val);
static int ASN1CALL ASN1Enc_TerminalLabel(ASN1encoding_t enc, TerminalLabel *val);
static int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse(ASN1encoding_t enc, RequestAllTerminalIDsResponse *val);
static int ASN1CALL ASN1Enc_TerminalInformation(ASN1encoding_t enc, TerminalInformation *val);
static int ASN1CALL ASN1Enc_RemoteMCRequest(ASN1encoding_t enc, RemoteMCRequest *val);
static int ASN1CALL ASN1Enc_RemoteMCResponse(ASN1encoding_t enc, RemoteMCResponse *val);
static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet(ASN1encoding_t enc, SendTerminalCapabilitySet *val);
static int ASN1CALL ASN1Enc_FlowControlCommand(ASN1encoding_t enc, FlowControlCommand *val);
static int ASN1CALL ASN1Enc_SubstituteConferenceIDCommand(ASN1encoding_t enc, SubstituteConferenceIDCommand *val);
static int ASN1CALL ASN1Enc_KeyProtectionMethod(ASN1encoding_t enc, KeyProtectionMethod *val);
static int ASN1CALL ASN1Enc_EncryptionUpdateRequest(ASN1encoding_t enc, EncryptionUpdateRequest *val);
static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration(ASN1encoding_t enc, H223MultiplexReconfiguration *val);
static int ASN1CALL ASN1Enc_FunctionNotSupported(ASN1encoding_t enc, FunctionNotSupported *val);
static int ASN1CALL ASN1Enc_TerminalYouAreSeeingInSubPictureNumber(ASN1encoding_t enc, TerminalYouAreSeeingInSubPictureNumber *val);
static int ASN1CALL ASN1Enc_VideoIndicateCompose(ASN1encoding_t enc, VideoIndicateCompose *val);
static int ASN1CALL ASN1Enc_ConferenceIndication(ASN1encoding_t enc, ConferenceIndication *val);
static int ASN1CALL ASN1Enc_JitterIndication(ASN1encoding_t enc, JitterIndication *val);
static int ASN1CALL ASN1Enc_H223SkewIndication(ASN1encoding_t enc, H223SkewIndication *val);
static int ASN1CALL ASN1Enc_H2250MaximumSkewIndication(ASN1encoding_t enc, H2250MaximumSkewIndication *val);
static int ASN1CALL ASN1Enc_VendorIdentification(ASN1encoding_t enc, VendorIdentification *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication(ASN1encoding_t enc, NewATMVCIndication *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(ASN1encoding_t enc, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val);
static int ASN1CALL ASN1Enc_MultiplexElement_type_subElementList(ASN1encoding_t enc, PMultiplexElement_type_subElementList *val);
static int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation(ASN1encoding_t enc, PRequestAllTerminalIDsResponse_terminalInformation *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_terminalCertificateResponse(ASN1encoding_t enc, ConferenceResponse_terminalCertificateResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_chairTokenOwnerResponse(ASN1encoding_t enc, ConferenceResponse_chairTokenOwnerResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_terminalListResponse(ASN1encoding_t enc, ConferenceResponse_terminalListResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_passwordResponse(ASN1encoding_t enc, ConferenceResponse_passwordResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_conferenceIDResponse(ASN1encoding_t enc, ConferenceResponse_conferenceIDResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_terminalIDResponse(ASN1encoding_t enc, ConferenceResponse_terminalIDResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_mCTerminalIDResponse(ASN1encoding_t enc, ConferenceResponse_mCTerminalIDResponse *val);
static int ASN1CALL ASN1Enc_ConferenceRequest_requestTerminalCertificate(ASN1encoding_t enc, ConferenceRequest_requestTerminalCertificate *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject_rejectionDescriptions(ASN1encoding_t enc, RequestMultiplexEntryReject_rejectionDescriptions *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendReject_rejectionDescriptions(ASN1encoding_t enc, MultiplexEntrySendReject_rejectionDescriptions *val);
static int ASN1CALL ASN1Enc_MultiplexEntryDescriptor_elementList(ASN1encoding_t enc, MultiplexEntryDescriptor_elementList *val);
static int ASN1CALL ASN1Enc_EncryptionSync_escrowentry(ASN1encoding_t enc, PEncryptionSync_escrowentry *val);
static int ASN1CALL ASN1Enc_H223AL3MParameters_arqType(ASN1encoding_t enc, H223AL3MParameters_arqType *val);
static int ASN1CALL ASN1Enc_H223AL1MParameters_arqType(ASN1encoding_t enc, H223AL1MParameters_arqType *val);
static int ASN1CALL ASN1Enc_H263VideoModeCombos_h263VideoCoupledModes(ASN1encoding_t enc, H263VideoModeCombos_h263VideoCoupledModes *val);
static int ASN1CALL ASN1Enc_H263Options_customPictureFormat(ASN1encoding_t enc, PH263Options_customPictureFormat *val);
static int ASN1CALL ASN1Enc_H263Options_customPictureClockFrequency(ASN1encoding_t enc, PH263Options_customPictureClockFrequency *val);
static int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability *val);
static int ASN1CALL ASN1Enc_TransportCapability_mediaChannelCapabilities(ASN1encoding_t enc, TransportCapability_mediaChannelCapabilities *val);
static int ASN1CALL ASN1Enc_H222Capability_vcCapability(ASN1encoding_t enc, PH222Capability_vcCapability *val);
static int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityDescriptors(ASN1encoding_t enc, TerminalCapabilitySet_capabilityDescriptors *val);
static int ASN1CALL ASN1Enc_NonStandardParameter(ASN1encoding_t enc, NonStandardParameter *val);
static int ASN1CALL ASN1Enc_H223Capability(ASN1encoding_t enc, H223Capability *val);
static int ASN1CALL ASN1Enc_V76Capability(ASN1encoding_t enc, V76Capability *val);
static int ASN1CALL ASN1Enc_RSVPParameters(ASN1encoding_t enc, RSVPParameters *val);
static int ASN1CALL ASN1Enc_QOSCapability(ASN1encoding_t enc, QOSCapability *val);
static int ASN1CALL ASN1Enc_TransportCapability(ASN1encoding_t enc, TransportCapability *val);
static int ASN1CALL ASN1Enc_RedundancyEncodingMethod(ASN1encoding_t enc, RedundancyEncodingMethod *val);
static int ASN1CALL ASN1Enc_H263Options(ASN1encoding_t enc, H263Options *val);
static int ASN1CALL ASN1Enc_H263VideoModeCombos(ASN1encoding_t enc, H263VideoModeCombos *val);
static int ASN1CALL ASN1Enc_AudioCapability(ASN1encoding_t enc, AudioCapability *val);
static int ASN1CALL ASN1Enc_CompressionType(ASN1encoding_t enc, CompressionType *val);
static int ASN1CALL ASN1Enc_MediaEncryptionAlgorithm(ASN1encoding_t enc, MediaEncryptionAlgorithm *val);
static int ASN1CALL ASN1Enc_AuthenticationCapability(ASN1encoding_t enc, AuthenticationCapability *val);
static int ASN1CALL ASN1Enc_IntegrityCapability(ASN1encoding_t enc, IntegrityCapability *val);
static int ASN1CALL ASN1Enc_H223AL1MParameters(ASN1encoding_t enc, H223AL1MParameters *val);
static int ASN1CALL ASN1Enc_H223AL3MParameters(ASN1encoding_t enc, H223AL3MParameters *val);
static int ASN1CALL ASN1Enc_V76HDLCParameters(ASN1encoding_t enc, V76HDLCParameters *val);
static int ASN1CALL ASN1Enc_UnicastAddress(ASN1encoding_t enc, UnicastAddress *val);
static int ASN1CALL ASN1Enc_MulticastAddress(ASN1encoding_t enc, MulticastAddress *val);
static int ASN1CALL ASN1Enc_EncryptionSync(ASN1encoding_t enc, EncryptionSync *val);
static int ASN1CALL ASN1Enc_RequestChannelClose(ASN1encoding_t enc, RequestChannelClose *val);
static int ASN1CALL ASN1Enc_MultiplexEntryDescriptor(ASN1encoding_t enc, MultiplexEntryDescriptor *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendReject(ASN1encoding_t enc, MultiplexEntrySendReject *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject(ASN1encoding_t enc, RequestMultiplexEntryReject *val);
static int ASN1CALL ASN1Enc_H263VideoMode(ASN1encoding_t enc, H263VideoMode *val);
static int ASN1CALL ASN1Enc_AudioMode(ASN1encoding_t enc, AudioMode *val);
static int ASN1CALL ASN1Enc_EncryptionMode(ASN1encoding_t enc, EncryptionMode *val);
static int ASN1CALL ASN1Enc_ConferenceRequest(ASN1encoding_t enc, ConferenceRequest *val);
static int ASN1CALL ASN1Enc_CertSelectionCriteria(ASN1encoding_t enc, PCertSelectionCriteria *val);
static int ASN1CALL ASN1Enc_ConferenceResponse(ASN1encoding_t enc, ConferenceResponse *val);
static int ASN1CALL ASN1Enc_EndSessionCommand(ASN1encoding_t enc, EndSessionCommand *val);
static int ASN1CALL ASN1Enc_ConferenceCommand(ASN1encoding_t enc, ConferenceCommand *val);
static int ASN1CALL ASN1Enc_UserInputIndication_userInputSupportIndication(ASN1encoding_t enc, UserInputIndication_userInputSupportIndication *val);
static int ASN1CALL ASN1Enc_MiscellaneousIndication_type(ASN1encoding_t enc, MiscellaneousIndication_type *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand_type(ASN1encoding_t enc, MiscellaneousCommand_type *val);
static int ASN1CALL ASN1Enc_EncryptionCommand_encryptionAlgorithmID(ASN1encoding_t enc, EncryptionCommand_encryptionAlgorithmID *val);
static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard *val);
static int ASN1CALL ASN1Enc_RedundancyEncodingMode_secondaryEncoding(ASN1encoding_t enc, RedundancyEncodingMode_secondaryEncoding *val);
static int ASN1CALL ASN1Enc_H223ModeParameters_adaptationLayerType(ASN1encoding_t enc, H223ModeParameters_adaptationLayerType *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard *val);
static int ASN1CALL ASN1Enc_RTPPayloadType_payloadDescriptor(ASN1encoding_t enc, RTPPayloadType_payloadDescriptor *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard *val);
static int ASN1CALL ASN1Enc_H223LogicalChannelParameters_adaptationLayerType(ASN1encoding_t enc, H223LogicalChannelParameters_adaptationLayerType *val);
static int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData(ASN1encoding_t enc, PConferenceCapability_nonStandardData *val);
static int ASN1CALL ASN1Enc_UserInputCapability_nonStandard(ASN1encoding_t enc, UserInputCapability_nonStandard *val);
static int ASN1CALL ASN1Enc_DataProtocolCapability_v76wCompression(ASN1encoding_t enc, DataProtocolCapability_v76wCompression *val);
static int ASN1CALL ASN1Enc_H263Options_modeCombos(ASN1encoding_t enc, PH263Options_modeCombos *val);
static int ASN1CALL ASN1Enc_TransportCapability_qOSCapabilities(ASN1encoding_t enc, PTransportCapability_qOSCapabilities *val);
static int ASN1CALL ASN1Enc_NonStandardMessage(ASN1encoding_t enc, NonStandardMessage *val);
static int ASN1CALL ASN1Enc_RedundancyEncodingCapability(ASN1encoding_t enc, RedundancyEncodingCapability *val);
static int ASN1CALL ASN1Enc_H263VideoCapability(ASN1encoding_t enc, H263VideoCapability *val);
static int ASN1CALL ASN1Enc_EnhancementOptions(ASN1encoding_t enc, EnhancementOptions *val);
static int ASN1CALL ASN1Enc_DataProtocolCapability(ASN1encoding_t enc, DataProtocolCapability *val);
static int ASN1CALL ASN1Enc_EncryptionAuthenticationAndIntegrity(ASN1encoding_t enc, EncryptionAuthenticationAndIntegrity *val);
static int ASN1CALL ASN1Enc_EncryptionCapability(ASN1encoding_t enc, PEncryptionCapability *val);
static int ASN1CALL ASN1Enc_UserInputCapability(ASN1encoding_t enc, UserInputCapability *val);
static int ASN1CALL ASN1Enc_H223LogicalChannelParameters(ASN1encoding_t enc, H223LogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters(ASN1encoding_t enc, V76LogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_RTPPayloadType(ASN1encoding_t enc, RTPPayloadType *val);
static int ASN1CALL ASN1Enc_H245TransportAddress(ASN1encoding_t enc, H245TransportAddress *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters(ASN1encoding_t enc, H2250LogicalChannelAckParameters *val);
static int ASN1CALL ASN1Enc_H223ModeParameters(ASN1encoding_t enc, H223ModeParameters *val);
static int ASN1CALL ASN1Enc_RedundancyEncodingMode(ASN1encoding_t enc, RedundancyEncodingMode *val);
static int ASN1CALL ASN1Enc_VideoMode(ASN1encoding_t enc, VideoMode *val);
static int ASN1CALL ASN1Enc_EncryptionCommand(ASN1encoding_t enc, EncryptionCommand *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand(ASN1encoding_t enc, MiscellaneousCommand *val);
static int ASN1CALL ASN1Enc_MiscellaneousIndication(ASN1encoding_t enc, MiscellaneousIndication *val);
static int ASN1CALL ASN1Enc_MCLocationIndication(ASN1encoding_t enc, MCLocationIndication *val);
static int ASN1CALL ASN1Enc_UserInputIndication(ASN1encoding_t enc, UserInputIndication *val);
static int ASN1CALL ASN1Enc_DataApplicationCapability_application_nlpid(ASN1encoding_t enc, DataApplicationCapability_application_nlpid *val);
static int ASN1CALL ASN1Enc_DataApplicationCapability_application_t84(ASN1encoding_t enc, DataApplicationCapability_application_t84 *val);
static int ASN1CALL ASN1Enc_DataMode_application_nlpid(ASN1encoding_t enc, DataMode_application_nlpid *val);
static int ASN1CALL ASN1Enc_DataMode_application(ASN1encoding_t enc, DataMode_application *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_forwardMultiplexAckParameters(ASN1encoding_t enc, OpenLogicalChannelAck_forwardMultiplexAckParameters *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_mediaPacketization(ASN1encoding_t enc, H2250LogicalChannelParameters_mediaPacketization *val);
static int ASN1CALL ASN1Enc_NetworkAccessParameters_networkAddress(ASN1encoding_t enc, NetworkAccessParameters_networkAddress *val);
static int ASN1CALL ASN1Enc_DataApplicationCapability_application(ASN1encoding_t enc, DataApplicationCapability_application *val);
static int ASN1CALL ASN1Enc_EnhancementLayerInfo_spatialEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_spatialEnhancement *val);
static int ASN1CALL ASN1Enc_EnhancementLayerInfo_snrEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_snrEnhancement *val);
static int ASN1CALL ASN1Enc_MediaPacketizationCapability_rtpPayloadType(ASN1encoding_t enc, MediaPacketizationCapability_rtpPayloadType *val);
static int ASN1CALL ASN1Enc_H2250Capability_redundancyEncodingCapability(ASN1encoding_t enc, PH2250Capability_redundancyEncodingCapability *val);
static int ASN1CALL ASN1Enc_CommandMessage(ASN1encoding_t enc, CommandMessage *val);
static int ASN1CALL ASN1Enc_H235SecurityCapability(ASN1encoding_t enc, H235SecurityCapability *val);
static int ASN1CALL ASN1Enc_MediaPacketizationCapability(ASN1encoding_t enc, MediaPacketizationCapability *val);
static int ASN1CALL ASN1Enc_VideoCapability(ASN1encoding_t enc, VideoCapability *val);
static int ASN1CALL ASN1Enc_BEnhancementParameters(ASN1encoding_t enc, BEnhancementParameters *val);
static int ASN1CALL ASN1Enc_DataApplicationCapability(ASN1encoding_t enc, DataApplicationCapability *val);
static int ASN1CALL ASN1Enc_NetworkAccessParameters(ASN1encoding_t enc, NetworkAccessParameters *val);
static int ASN1CALL ASN1Enc_H2250ModeParameters(ASN1encoding_t enc, H2250ModeParameters *val);
static int ASN1CALL ASN1Enc_DataMode(ASN1encoding_t enc, DataMode *val);
static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_dataType(ASN1encoding_t enc, CommunicationModeTableEntry_dataType *val);
static int ASN1CALL ASN1Enc_H235Mode_mediaMode(ASN1encoding_t enc, H235Mode_mediaMode *val);
static int ASN1CALL ASN1Enc_H235Media_mediaType(ASN1encoding_t enc, H235Media_mediaType *val);
static int ASN1CALL ASN1Enc_EnhancementLayerInfo_bPictureEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_bPictureEnhancement *val);
static int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData(ASN1encoding_t enc, PMediaDistributionCapability_distributedData *val);
static int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData *val);
static int ASN1CALL ASN1Enc_Capability(ASN1encoding_t enc, Capability *val);
static int ASN1CALL ASN1Enc_H2250Capability(ASN1encoding_t enc, H2250Capability *val);
static int ASN1CALL ASN1Enc_H235Media(ASN1encoding_t enc, H235Media *val);
static int ASN1CALL ASN1Enc_H235Mode(ASN1encoding_t enc, H235Mode *val);
static int ASN1CALL ASN1Enc_ModeElement_type(ASN1encoding_t enc, ModeElement_type *val);
static int ASN1CALL ASN1Enc_CapabilityTableEntry(ASN1encoding_t enc, CapabilityTableEntry *val);
static int ASN1CALL ASN1Enc_MultiplexCapability(ASN1encoding_t enc, MultiplexCapability *val);
static int ASN1CALL ASN1Enc_DataType(ASN1encoding_t enc, DataType *val);
static int ASN1CALL ASN1Enc_RedundancyEncoding(ASN1encoding_t enc, RedundancyEncoding *val);
static int ASN1CALL ASN1Enc_ModeElement(ASN1encoding_t enc, ModeElement *val);
static int ASN1CALL ASN1Enc_CommunicationModeTableEntry(ASN1encoding_t enc, CommunicationModeTableEntry *val);
static int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable *val);
static int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySet(ASN1encoding_t enc, TerminalCapabilitySet *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters(ASN1encoding_t enc, H2250LogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_ModeDescription(ASN1encoding_t enc, ModeDescription *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Enc_RequestMode_requestedModes(ASN1encoding_t enc, PRequestMode_requestedModes *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannelAck_reverseLogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannel_reverseLogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannel_forwardLogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel(ASN1encoding_t enc, OpenLogicalChannel *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelAck(ASN1encoding_t enc, OpenLogicalChannelAck *val);
static int ASN1CALL ASN1Enc_RequestMessage(ASN1encoding_t enc, RequestMessage *val);
static int ASN1CALL ASN1Enc_ResponseMessage(ASN1encoding_t enc, ResponseMessage *val);
static int ASN1CALL ASN1Enc_FastConnectOLC(ASN1encoding_t enc, FastConnectOLC *val);
static int ASN1CALL ASN1Enc_FunctionNotUnderstood(ASN1encoding_t enc, FunctionNotUnderstood *val);
static int ASN1CALL ASN1Enc_IndicationMessage(ASN1encoding_t enc, IndicationMessage *val);
static int ASN1CALL ASN1Enc_MultimediaSystemControlMessage(ASN1encoding_t enc, MultimediaSystemControlMessage *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1_errorCorrection(ASN1decoding_t dec, NewATMVCIndication_aal_aal1_errorCorrection *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1_clockRecovery(ASN1decoding_t dec, NewATMVCIndication_aal_aal1_clockRecovery *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(ASN1decoding_t dec, MiscellaneousCommand_type_progressiveRefinementStart_repeatCount *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode_eRM_recovery(ASN1decoding_t dec, V76LogicalChannelParameters_mode_eRM_recovery *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_extendedPAR_Set *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI_customPCF_Set(ASN1decoding_t dec, CustomPictureFormat_mPI_customPCF_Set *val);
static int ASN1CALL ASN1Dec_VCCapability_availableBitRates_type_rangeOfBitRates(ASN1decoding_t dec, VCCapability_availableBitRates_type_rangeOfBitRates *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(ASN1decoding_t dec, TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *val);
static int ASN1CALL ASN1Dec_VCCapability_availableBitRates_type(ASN1decoding_t dec, VCCapability_availableBitRates_type *val);
static int ASN1CALL ASN1Dec_H223Capability_h223MultiplexTableCapability_enhanced(ASN1decoding_t dec, H223Capability_h223MultiplexTableCapability_enhanced *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI_customPCF(ASN1decoding_t dec, CustomPictureFormat_mPI_customPCF *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_extendedPAR *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val);
static int ASN1CALL ASN1Dec_H223LogicalChannelParameters_adaptationLayerType_al3(ASN1decoding_t dec, H223LogicalChannelParameters_adaptationLayerType_al3 *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode_eRM(ASN1decoding_t dec, V76LogicalChannelParameters_mode_eRM *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_routing(ASN1decoding_t dec, UnicastAddress_iPSourceRouteAddress_routing *val);
static int ASN1CALL ASN1Dec_H223ModeParameters_adaptationLayerType_al3(ASN1decoding_t dec, H223ModeParameters_adaptationLayerType_al3 *val);
static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(ASN1decoding_t dec, SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val);
static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart(ASN1decoding_t dec, MiscellaneousCommand_type_progressiveRefinementStart *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_videoFastUpdateMB(ASN1decoding_t dec, MiscellaneousCommand_type_videoFastUpdateMB *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_videoFastUpdateGOB(ASN1decoding_t dec, MiscellaneousCommand_type_videoFastUpdateGOB *val);
static int ASN1CALL ASN1Dec_MiscellaneousIndication_type_videoNotDecodedMBs(ASN1decoding_t dec, MiscellaneousIndication_type_videoNotDecodedMBs *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal5(ASN1decoding_t dec, NewATMVCIndication_aal_aal5 *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1(ASN1decoding_t dec, NewATMVCIndication_aal_aal1 *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_reverseParameters_multiplex(ASN1decoding_t dec, NewATMVCIndication_reverseParameters_multiplex *val);
static int ASN1CALL ASN1Dec_UserInputIndication_signal_rtp(ASN1decoding_t dec, UserInputIndication_signal_rtp *val);
static int ASN1CALL ASN1Dec_UserInputIndication_signalUpdate_rtp(ASN1decoding_t dec, UserInputIndication_signalUpdate_rtp *val);
static int ASN1CALL ASN1Dec_UserInputIndication_signalUpdate(ASN1decoding_t dec, UserInputIndication_signalUpdate *val);
static int ASN1CALL ASN1Dec_UserInputIndication_signal(ASN1decoding_t dec, UserInputIndication_signal *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_reverseParameters(ASN1decoding_t dec, NewATMVCIndication_reverseParameters *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_multiplex(ASN1decoding_t dec, NewATMVCIndication_multiplex *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal(ASN1decoding_t dec, NewATMVCIndication_aal *val);
static int ASN1CALL ASN1Dec_JitterIndication_scope(ASN1decoding_t dec, JitterIndication_scope *val);
static int ASN1CALL ASN1Dec_FunctionNotSupported_cause(ASN1decoding_t dec, FunctionNotSupported_cause *val);
static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration_h223AnnexADoubleFlag(ASN1decoding_t dec, H223MultiplexReconfiguration_h223AnnexADoubleFlag *val);
static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration_h223ModeChange(ASN1decoding_t dec, H223MultiplexReconfiguration_h223ModeChange *val);
static int ASN1CALL ASN1Dec_EndSessionCommand_isdnOptions(ASN1decoding_t dec, EndSessionCommand_isdnOptions *val);
static int ASN1CALL ASN1Dec_EndSessionCommand_gstnOptions(ASN1decoding_t dec, EndSessionCommand_gstnOptions *val);
static int ASN1CALL ASN1Dec_FlowControlCommand_restriction(ASN1decoding_t dec, FlowControlCommand_restriction *val);
static int ASN1CALL ASN1Dec_FlowControlCommand_scope(ASN1decoding_t dec, FlowControlCommand_scope *val);
static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest(ASN1decoding_t dec, SendTerminalCapabilitySet_specificRequest *val);
static int ASN1CALL ASN1Dec_RemoteMCResponse_reject(ASN1decoding_t dec, RemoteMCResponse_reject *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_sendThisSourceResponse(ASN1decoding_t dec, ConferenceResponse_sendThisSourceResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_makeTerminalBroadcasterResponse(ASN1decoding_t dec, ConferenceResponse_makeTerminalBroadcasterResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_broadcastMyLogicalChannelResponse(ASN1decoding_t dec, ConferenceResponse_broadcastMyLogicalChannelResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_extensionAddressResponse(ASN1decoding_t dec, ConferenceResponse_extensionAddressResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_makeMeChairResponse(ASN1decoding_t dec, ConferenceResponse_makeMeChairResponse *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopReject_cause(ASN1decoding_t dec, MaintenanceLoopReject_cause *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopReject_type(ASN1decoding_t dec, MaintenanceLoopReject_type *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopAck_type(ASN1decoding_t dec, MaintenanceLoopAck_type *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopRequest_type(ASN1decoding_t dec, MaintenanceLoopRequest_type *val);
static int ASN1CALL ASN1Dec_G7231AnnexCMode_g723AnnexCAudioMode(ASN1decoding_t dec, G7231AnnexCMode_g723AnnexCAudioMode *val);
static int ASN1CALL ASN1Dec_IS13818AudioMode_multichannelType(ASN1decoding_t dec, IS13818AudioMode_multichannelType *val);
static int ASN1CALL ASN1Dec_IS13818AudioMode_audioSampling(ASN1decoding_t dec, IS13818AudioMode_audioSampling *val);
static int ASN1CALL ASN1Dec_IS13818AudioMode_audioLayer(ASN1decoding_t dec, IS13818AudioMode_audioLayer *val);
static int ASN1CALL ASN1Dec_IS11172AudioMode_multichannelType(ASN1decoding_t dec, IS11172AudioMode_multichannelType *val);
static int ASN1CALL ASN1Dec_IS11172AudioMode_audioSampling(ASN1decoding_t dec, IS11172AudioMode_audioSampling *val);
static int ASN1CALL ASN1Dec_IS11172AudioMode_audioLayer(ASN1decoding_t dec, IS11172AudioMode_audioLayer *val);
static int ASN1CALL ASN1Dec_AudioMode_g7231(ASN1decoding_t dec, AudioMode_g7231 *val);
static int ASN1CALL ASN1Dec_H263VideoMode_resolution(ASN1decoding_t dec, H263VideoMode_resolution *val);
static int ASN1CALL ASN1Dec_H262VideoMode_profileAndLevel(ASN1decoding_t dec, H262VideoMode_profileAndLevel *val);
static int ASN1CALL ASN1Dec_H261VideoMode_resolution(ASN1decoding_t dec, H261VideoMode_resolution *val);
static int ASN1CALL ASN1Dec_RequestModeReject_cause(ASN1decoding_t dec, RequestModeReject_cause *val);
static int ASN1CALL ASN1Dec_RequestModeAck_response(ASN1decoding_t dec, RequestModeAck_response *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryRelease_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryRelease_entryNumbers *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryRejectionDescriptions_cause(ASN1decoding_t dec, RequestMultiplexEntryRejectionDescriptions_cause *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryReject_entryNumbers *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryAck_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryAck_entryNumbers *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntry_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntry_entryNumbers *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendRelease_multiplexTableEntryNumber(ASN1decoding_t dec, MultiplexEntrySendRelease_multiplexTableEntryNumber *val);
static int ASN1CALL ASN1Dec_MultiplexEntryRejectionDescriptions_cause(ASN1decoding_t dec, MultiplexEntryRejectionDescriptions_cause *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendAck_multiplexTableEntryNumber(ASN1decoding_t dec, MultiplexEntrySendAck_multiplexTableEntryNumber *val);
static int ASN1CALL ASN1Dec_MultiplexElement_repeatCount(ASN1decoding_t dec, MultiplexElement_repeatCount *val);
static int ASN1CALL ASN1Dec_MultiplexElement_type(ASN1decoding_t dec, MultiplexElement_type *val);
static int ASN1CALL ASN1Dec_RequestChannelCloseReject_cause(ASN1decoding_t dec, RequestChannelCloseReject_cause *val);
static int ASN1CALL ASN1Dec_RequestChannelClose_reason(ASN1decoding_t dec, RequestChannelClose_reason *val);
static int ASN1CALL ASN1Dec_CloseLogicalChannel_reason(ASN1decoding_t dec, CloseLogicalChannel_reason *val);
static int ASN1CALL ASN1Dec_CloseLogicalChannel_source(ASN1decoding_t dec, CloseLogicalChannel_source *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelReject_cause(ASN1decoding_t dec, OpenLogicalChannelReject_cause *val);
static int ASN1CALL ASN1Dec_MulticastAddress_iP6Address(ASN1decoding_t dec, MulticastAddress_iP6Address *val);
static int ASN1CALL ASN1Dec_MulticastAddress_iPAddress(ASN1decoding_t dec, MulticastAddress_iPAddress *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress(ASN1decoding_t dec, UnicastAddress_iPSourceRouteAddress *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iP6Address(ASN1decoding_t dec, UnicastAddress_iP6Address *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPXAddress(ASN1decoding_t dec, UnicastAddress_iPXAddress *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPAddress(ASN1decoding_t dec, UnicastAddress_iPAddress *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode(ASN1decoding_t dec, V76LogicalChannelParameters_mode *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_suspendResume(ASN1decoding_t dec, V76LogicalChannelParameters_suspendResume *val);
static int ASN1CALL ASN1Dec_H223AnnexCArqParameters_numberOfRetransmissions(ASN1decoding_t dec, H223AnnexCArqParameters_numberOfRetransmissions *val);
static int ASN1CALL ASN1Dec_H223AL3MParameters_crcLength(ASN1decoding_t dec, H223AL3MParameters_crcLength *val);
static int ASN1CALL ASN1Dec_H223AL3MParameters_headerFormat(ASN1decoding_t dec, H223AL3MParameters_headerFormat *val);
static int ASN1CALL ASN1Dec_H223AL2MParameters_headerFEC(ASN1decoding_t dec, H223AL2MParameters_headerFEC *val);
static int ASN1CALL ASN1Dec_H223AL1MParameters_crcLength(ASN1decoding_t dec, H223AL1MParameters_crcLength *val);
static int ASN1CALL ASN1Dec_H223AL1MParameters_headerFEC(ASN1decoding_t dec, H223AL1MParameters_headerFEC *val);
static int ASN1CALL ASN1Dec_H223AL1MParameters_transferMode(ASN1decoding_t dec, H223AL1MParameters_transferMode *val);
static int ASN1CALL ASN1Dec_Q2931Address_address(ASN1decoding_t dec, Q2931Address_address *val);
static int ASN1CALL ASN1Dec_NetworkAccessParameters_t120SetupProcedure(ASN1decoding_t dec, NetworkAccessParameters_t120SetupProcedure *val);
static int ASN1CALL ASN1Dec_NetworkAccessParameters_distribution(ASN1decoding_t dec, NetworkAccessParameters_distribution *val);
static int ASN1CALL ASN1Dec_T84Profile_t84Restricted(ASN1decoding_t dec, T84Profile_t84Restricted *val);
static int ASN1CALL ASN1Dec_G7231AnnexCCapability_g723AnnexCAudioMode(ASN1decoding_t dec, G7231AnnexCCapability_g723AnnexCAudioMode *val);
static int ASN1CALL ASN1Dec_AudioCapability_g7231(ASN1decoding_t dec, AudioCapability_g7231 *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI(ASN1decoding_t dec, CustomPictureFormat_mPI *val);
static int ASN1CALL ASN1Dec_RefPictureSelection_videoBackChannelSend(ASN1decoding_t dec, RefPictureSelection_videoBackChannelSend *val);
static int ASN1CALL ASN1Dec_RefPictureSelection_additionalPictureMemory(ASN1decoding_t dec, RefPictureSelection_additionalPictureMemory *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyFrameMapping_frameSequence(ASN1decoding_t dec, RTPH263VideoRedundancyFrameMapping_frameSequence *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_containedThreads(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding_containedThreads *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding_frameToThreadMapping *val);
static int ASN1CALL ASN1Dec_RedundancyEncodingCapability_secondaryEncoding(ASN1decoding_t dec, PRedundancyEncodingCapability_secondaryEncoding *val);
static int ASN1CALL ASN1Dec_H2250Capability_mcCapability(ASN1decoding_t dec, H2250Capability_mcCapability *val);
static int ASN1CALL ASN1Dec_H223Capability_mobileOperationTransmitCapability(ASN1decoding_t dec, H223Capability_mobileOperationTransmitCapability *val);
static int ASN1CALL ASN1Dec_H223Capability_h223MultiplexTableCapability(ASN1decoding_t dec, H223Capability_h223MultiplexTableCapability *val);
static int ASN1CALL ASN1Dec_VCCapability_availableBitRates(ASN1decoding_t dec, VCCapability_availableBitRates *val);
static int ASN1CALL ASN1Dec_VCCapability_aal5(ASN1decoding_t dec, VCCapability_aal5 *val);
static int ASN1CALL ASN1Dec_VCCapability_aal1(ASN1decoding_t dec, VCCapability_aal1 *val);
static int ASN1CALL ASN1Dec_Capability_h233EncryptionReceiveCapability(ASN1decoding_t dec, Capability_h233EncryptionReceiveCapability *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject_cause(ASN1decoding_t dec, TerminalCapabilitySetReject_cause *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationReject_cause(ASN1decoding_t dec, MasterSlaveDeterminationReject_cause *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationAck_decision(ASN1decoding_t dec, MasterSlaveDeterminationAck_decision *val);
static int ASN1CALL ASN1Dec_NonStandardIdentifier_h221NonStandard(ASN1decoding_t dec, NonStandardIdentifier_h221NonStandard *val);
static int ASN1CALL ASN1Dec_NonStandardIdentifier(ASN1decoding_t dec, NonStandardIdentifier *val);
static int ASN1CALL ASN1Dec_MasterSlaveDetermination(ASN1decoding_t dec, MasterSlaveDetermination *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationAck(ASN1decoding_t dec, MasterSlaveDeterminationAck *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationReject(ASN1decoding_t dec, MasterSlaveDeterminationReject *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationRelease(ASN1decoding_t dec, MasterSlaveDeterminationRelease *val);
static int ASN1CALL ASN1Dec_CapabilityDescriptor(ASN1decoding_t dec, CapabilityDescriptor *val);
static int ASN1CALL ASN1Dec_AlternativeCapabilitySet(ASN1decoding_t dec, AlternativeCapabilitySet *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetAck(ASN1decoding_t dec, TerminalCapabilitySetAck *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject(ASN1decoding_t dec, TerminalCapabilitySetReject *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetRelease(ASN1decoding_t dec, TerminalCapabilitySetRelease *val);
static int ASN1CALL ASN1Dec_H222Capability(ASN1decoding_t dec, H222Capability *val);
static int ASN1CALL ASN1Dec_VCCapability(ASN1decoding_t dec, VCCapability *val);
static int ASN1CALL ASN1Dec_H223AnnexCCapability(ASN1decoding_t dec, H223AnnexCCapability *val);
static int ASN1CALL ASN1Dec_V75Capability(ASN1decoding_t dec, V75Capability *val);
static int ASN1CALL ASN1Dec_QOSMode(ASN1decoding_t dec, QOSMode *val);
static int ASN1CALL ASN1Dec_ATMParameters(ASN1decoding_t dec, ATMParameters *val);
static int ASN1CALL ASN1Dec_MediaTransportType(ASN1decoding_t dec, MediaTransportType *val);
static int ASN1CALL ASN1Dec_MediaChannelCapability(ASN1decoding_t dec, MediaChannelCapability *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyFrameMapping(ASN1decoding_t dec, RTPH263VideoRedundancyFrameMapping *val);
static int ASN1CALL ASN1Dec_MultipointCapability(ASN1decoding_t dec, MultipointCapability *val);
static int ASN1CALL ASN1Dec_MediaDistributionCapability(ASN1decoding_t dec, MediaDistributionCapability *val);
static int ASN1CALL ASN1Dec_H261VideoCapability(ASN1decoding_t dec, H261VideoCapability *val);
static int ASN1CALL ASN1Dec_H262VideoCapability(ASN1decoding_t dec, H262VideoCapability *val);
static int ASN1CALL ASN1Dec_EnhancementLayerInfo(ASN1decoding_t dec, EnhancementLayerInfo *val);
static int ASN1CALL ASN1Dec_TransparencyParameters(ASN1decoding_t dec, TransparencyParameters *val);
static int ASN1CALL ASN1Dec_RefPictureSelection(ASN1decoding_t dec, RefPictureSelection *val);
static int ASN1CALL ASN1Dec_CustomPictureClockFrequency(ASN1decoding_t dec, CustomPictureClockFrequency *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat(ASN1decoding_t dec, CustomPictureFormat *val);
static int ASN1CALL ASN1Dec_H263ModeComboFlags(ASN1decoding_t dec, H263ModeComboFlags *val);
static int ASN1CALL ASN1Dec_IS11172VideoCapability(ASN1decoding_t dec, IS11172VideoCapability *val);
static int ASN1CALL ASN1Dec_G7231AnnexCCapability(ASN1decoding_t dec, G7231AnnexCCapability *val);
static int ASN1CALL ASN1Dec_IS11172AudioCapability(ASN1decoding_t dec, IS11172AudioCapability *val);
static int ASN1CALL ASN1Dec_IS13818AudioCapability(ASN1decoding_t dec, IS13818AudioCapability *val);
static int ASN1CALL ASN1Dec_GSMAudioCapability(ASN1decoding_t dec, GSMAudioCapability *val);
static int ASN1CALL ASN1Dec_V42bis(ASN1decoding_t dec, V42bis *val);
static int ASN1CALL ASN1Dec_T84Profile(ASN1decoding_t dec, T84Profile *val);
static int ASN1CALL ASN1Dec_ConferenceCapability(ASN1decoding_t dec, ConferenceCapability *val);
static int ASN1CALL ASN1Dec_Q2931Address(ASN1decoding_t dec, Q2931Address *val);
static int ASN1CALL ASN1Dec_V75Parameters(ASN1decoding_t dec, V75Parameters *val);
static int ASN1CALL ASN1Dec_H222LogicalChannelParameters(ASN1decoding_t dec, H222LogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_H223AL2MParameters(ASN1decoding_t dec, H223AL2MParameters *val);
static int ASN1CALL ASN1Dec_H223AnnexCArqParameters(ASN1decoding_t dec, H223AnnexCArqParameters *val);
static int ASN1CALL ASN1Dec_CRCLength(ASN1decoding_t dec, CRCLength *val);
static int ASN1CALL ASN1Dec_EscrowData(ASN1decoding_t dec, EscrowData *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelReject(ASN1decoding_t dec, OpenLogicalChannelReject *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelConfirm(ASN1decoding_t dec, OpenLogicalChannelConfirm *val);
static int ASN1CALL ASN1Dec_CloseLogicalChannel(ASN1decoding_t dec, CloseLogicalChannel *val);
static int ASN1CALL ASN1Dec_CloseLogicalChannelAck(ASN1decoding_t dec, CloseLogicalChannelAck *val);
static int ASN1CALL ASN1Dec_RequestChannelCloseAck(ASN1decoding_t dec, RequestChannelCloseAck *val);
static int ASN1CALL ASN1Dec_RequestChannelCloseReject(ASN1decoding_t dec, RequestChannelCloseReject *val);
static int ASN1CALL ASN1Dec_RequestChannelCloseRelease(ASN1decoding_t dec, RequestChannelCloseRelease *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySend(ASN1decoding_t dec, MultiplexEntrySend *val);
static int ASN1CALL ASN1Dec_MultiplexElement(ASN1decoding_t dec, MultiplexElement *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendAck(ASN1decoding_t dec, MultiplexEntrySendAck *val);
static int ASN1CALL ASN1Dec_MultiplexEntryRejectionDescriptions(ASN1decoding_t dec, MultiplexEntryRejectionDescriptions *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendRelease(ASN1decoding_t dec, MultiplexEntrySendRelease *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntry(ASN1decoding_t dec, RequestMultiplexEntry *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryAck(ASN1decoding_t dec, RequestMultiplexEntryAck *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryRejectionDescriptions(ASN1decoding_t dec, RequestMultiplexEntryRejectionDescriptions *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryRelease(ASN1decoding_t dec, RequestMultiplexEntryRelease *val);
static int ASN1CALL ASN1Dec_RequestMode(ASN1decoding_t dec, RequestMode *val);
static int ASN1CALL ASN1Dec_RequestModeAck(ASN1decoding_t dec, RequestModeAck *val);
static int ASN1CALL ASN1Dec_RequestModeReject(ASN1decoding_t dec, RequestModeReject *val);
static int ASN1CALL ASN1Dec_RequestModeRelease(ASN1decoding_t dec, RequestModeRelease *val);
static int ASN1CALL ASN1Dec_V76ModeParameters(ASN1decoding_t dec, V76ModeParameters *val);
static int ASN1CALL ASN1Dec_H261VideoMode(ASN1decoding_t dec, H261VideoMode *val);
static int ASN1CALL ASN1Dec_H262VideoMode(ASN1decoding_t dec, H262VideoMode *val);
static int ASN1CALL ASN1Dec_IS11172VideoMode(ASN1decoding_t dec, IS11172VideoMode *val);
static int ASN1CALL ASN1Dec_IS11172AudioMode(ASN1decoding_t dec, IS11172AudioMode *val);
static int ASN1CALL ASN1Dec_IS13818AudioMode(ASN1decoding_t dec, IS13818AudioMode *val);
static int ASN1CALL ASN1Dec_G7231AnnexCMode(ASN1decoding_t dec, G7231AnnexCMode *val);
static int ASN1CALL ASN1Dec_RoundTripDelayRequest(ASN1decoding_t dec, RoundTripDelayRequest *val);
static int ASN1CALL ASN1Dec_RoundTripDelayResponse(ASN1decoding_t dec, RoundTripDelayResponse *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopRequest(ASN1decoding_t dec, MaintenanceLoopRequest *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopAck(ASN1decoding_t dec, MaintenanceLoopAck *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopReject(ASN1decoding_t dec, MaintenanceLoopReject *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopOffCommand(ASN1decoding_t dec, MaintenanceLoopOffCommand *val);
static int ASN1CALL ASN1Dec_CommunicationModeCommand(ASN1decoding_t dec, CommunicationModeCommand *val);
static int ASN1CALL ASN1Dec_CommunicationModeRequest(ASN1decoding_t dec, CommunicationModeRequest *val);
static int ASN1CALL ASN1Dec_CommunicationModeResponse(ASN1decoding_t dec, CommunicationModeResponse *val);
static int ASN1CALL ASN1Dec_Criteria(ASN1decoding_t dec, Criteria *val);
static int ASN1CALL ASN1Dec_TerminalLabel(ASN1decoding_t dec, TerminalLabel *val);
static int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse(ASN1decoding_t dec, RequestAllTerminalIDsResponse *val);
static int ASN1CALL ASN1Dec_TerminalInformation(ASN1decoding_t dec, TerminalInformation *val);
static int ASN1CALL ASN1Dec_RemoteMCRequest(ASN1decoding_t dec, RemoteMCRequest *val);
static int ASN1CALL ASN1Dec_RemoteMCResponse(ASN1decoding_t dec, RemoteMCResponse *val);
static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet(ASN1decoding_t dec, SendTerminalCapabilitySet *val);
static int ASN1CALL ASN1Dec_FlowControlCommand(ASN1decoding_t dec, FlowControlCommand *val);
static int ASN1CALL ASN1Dec_SubstituteConferenceIDCommand(ASN1decoding_t dec, SubstituteConferenceIDCommand *val);
static int ASN1CALL ASN1Dec_KeyProtectionMethod(ASN1decoding_t dec, KeyProtectionMethod *val);
static int ASN1CALL ASN1Dec_EncryptionUpdateRequest(ASN1decoding_t dec, EncryptionUpdateRequest *val);
static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration(ASN1decoding_t dec, H223MultiplexReconfiguration *val);
static int ASN1CALL ASN1Dec_FunctionNotSupported(ASN1decoding_t dec, FunctionNotSupported *val);
static int ASN1CALL ASN1Dec_TerminalYouAreSeeingInSubPictureNumber(ASN1decoding_t dec, TerminalYouAreSeeingInSubPictureNumber *val);
static int ASN1CALL ASN1Dec_VideoIndicateCompose(ASN1decoding_t dec, VideoIndicateCompose *val);
static int ASN1CALL ASN1Dec_ConferenceIndication(ASN1decoding_t dec, ConferenceIndication *val);
static int ASN1CALL ASN1Dec_JitterIndication(ASN1decoding_t dec, JitterIndication *val);
static int ASN1CALL ASN1Dec_H223SkewIndication(ASN1decoding_t dec, H223SkewIndication *val);
static int ASN1CALL ASN1Dec_H2250MaximumSkewIndication(ASN1decoding_t dec, H2250MaximumSkewIndication *val);
static int ASN1CALL ASN1Dec_VendorIdentification(ASN1decoding_t dec, VendorIdentification *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication(ASN1decoding_t dec, NewATMVCIndication *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(ASN1decoding_t dec, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val);
static int ASN1CALL ASN1Dec_MultiplexElement_type_subElementList(ASN1decoding_t dec, PMultiplexElement_type_subElementList *val);
static int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation(ASN1decoding_t dec, PRequestAllTerminalIDsResponse_terminalInformation *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_terminalCertificateResponse(ASN1decoding_t dec, ConferenceResponse_terminalCertificateResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_chairTokenOwnerResponse(ASN1decoding_t dec, ConferenceResponse_chairTokenOwnerResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_terminalListResponse(ASN1decoding_t dec, ConferenceResponse_terminalListResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_passwordResponse(ASN1decoding_t dec, ConferenceResponse_passwordResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_conferenceIDResponse(ASN1decoding_t dec, ConferenceResponse_conferenceIDResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_terminalIDResponse(ASN1decoding_t dec, ConferenceResponse_terminalIDResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_mCTerminalIDResponse(ASN1decoding_t dec, ConferenceResponse_mCTerminalIDResponse *val);
static int ASN1CALL ASN1Dec_ConferenceRequest_requestTerminalCertificate(ASN1decoding_t dec, ConferenceRequest_requestTerminalCertificate *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject_rejectionDescriptions(ASN1decoding_t dec, RequestMultiplexEntryReject_rejectionDescriptions *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendReject_rejectionDescriptions(ASN1decoding_t dec, MultiplexEntrySendReject_rejectionDescriptions *val);
static int ASN1CALL ASN1Dec_MultiplexEntryDescriptor_elementList(ASN1decoding_t dec, MultiplexEntryDescriptor_elementList *val);
static int ASN1CALL ASN1Dec_EncryptionSync_escrowentry(ASN1decoding_t dec, PEncryptionSync_escrowentry *val);
static int ASN1CALL ASN1Dec_H223AL3MParameters_arqType(ASN1decoding_t dec, H223AL3MParameters_arqType *val);
static int ASN1CALL ASN1Dec_H223AL1MParameters_arqType(ASN1decoding_t dec, H223AL1MParameters_arqType *val);
static int ASN1CALL ASN1Dec_H263VideoModeCombos_h263VideoCoupledModes(ASN1decoding_t dec, H263VideoModeCombos_h263VideoCoupledModes *val);
static int ASN1CALL ASN1Dec_H263Options_customPictureFormat(ASN1decoding_t dec, PH263Options_customPictureFormat *val);
static int ASN1CALL ASN1Dec_H263Options_customPictureClockFrequency(ASN1decoding_t dec, PH263Options_customPictureClockFrequency *val);
static int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability *val);
static int ASN1CALL ASN1Dec_TransportCapability_mediaChannelCapabilities(ASN1decoding_t dec, TransportCapability_mediaChannelCapabilities *val);
static int ASN1CALL ASN1Dec_H222Capability_vcCapability(ASN1decoding_t dec, PH222Capability_vcCapability *val);
static int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityDescriptors(ASN1decoding_t dec, TerminalCapabilitySet_capabilityDescriptors *val);
static int ASN1CALL ASN1Dec_NonStandardParameter(ASN1decoding_t dec, NonStandardParameter *val);
static int ASN1CALL ASN1Dec_H223Capability(ASN1decoding_t dec, H223Capability *val);
static int ASN1CALL ASN1Dec_V76Capability(ASN1decoding_t dec, V76Capability *val);
static int ASN1CALL ASN1Dec_RSVPParameters(ASN1decoding_t dec, RSVPParameters *val);
static int ASN1CALL ASN1Dec_QOSCapability(ASN1decoding_t dec, QOSCapability *val);
static int ASN1CALL ASN1Dec_TransportCapability(ASN1decoding_t dec, TransportCapability *val);
static int ASN1CALL ASN1Dec_RedundancyEncodingMethod(ASN1decoding_t dec, RedundancyEncodingMethod *val);
static int ASN1CALL ASN1Dec_H263Options(ASN1decoding_t dec, H263Options *val);
static int ASN1CALL ASN1Dec_H263VideoModeCombos(ASN1decoding_t dec, H263VideoModeCombos *val);
static int ASN1CALL ASN1Dec_AudioCapability(ASN1decoding_t dec, AudioCapability *val);
static int ASN1CALL ASN1Dec_CompressionType(ASN1decoding_t dec, CompressionType *val);
static int ASN1CALL ASN1Dec_MediaEncryptionAlgorithm(ASN1decoding_t dec, MediaEncryptionAlgorithm *val);
static int ASN1CALL ASN1Dec_AuthenticationCapability(ASN1decoding_t dec, AuthenticationCapability *val);
static int ASN1CALL ASN1Dec_IntegrityCapability(ASN1decoding_t dec, IntegrityCapability *val);
static int ASN1CALL ASN1Dec_H223AL1MParameters(ASN1decoding_t dec, H223AL1MParameters *val);
static int ASN1CALL ASN1Dec_H223AL3MParameters(ASN1decoding_t dec, H223AL3MParameters *val);
static int ASN1CALL ASN1Dec_V76HDLCParameters(ASN1decoding_t dec, V76HDLCParameters *val);
static int ASN1CALL ASN1Dec_UnicastAddress(ASN1decoding_t dec, UnicastAddress *val);
static int ASN1CALL ASN1Dec_MulticastAddress(ASN1decoding_t dec, MulticastAddress *val);
static int ASN1CALL ASN1Dec_EncryptionSync(ASN1decoding_t dec, EncryptionSync *val);
static int ASN1CALL ASN1Dec_RequestChannelClose(ASN1decoding_t dec, RequestChannelClose *val);
static int ASN1CALL ASN1Dec_MultiplexEntryDescriptor(ASN1decoding_t dec, MultiplexEntryDescriptor *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendReject(ASN1decoding_t dec, MultiplexEntrySendReject *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject(ASN1decoding_t dec, RequestMultiplexEntryReject *val);
static int ASN1CALL ASN1Dec_H263VideoMode(ASN1decoding_t dec, H263VideoMode *val);
static int ASN1CALL ASN1Dec_AudioMode(ASN1decoding_t dec, AudioMode *val);
static int ASN1CALL ASN1Dec_EncryptionMode(ASN1decoding_t dec, EncryptionMode *val);
static int ASN1CALL ASN1Dec_ConferenceRequest(ASN1decoding_t dec, ConferenceRequest *val);
static int ASN1CALL ASN1Dec_CertSelectionCriteria(ASN1decoding_t dec, PCertSelectionCriteria *val);
static int ASN1CALL ASN1Dec_ConferenceResponse(ASN1decoding_t dec, ConferenceResponse *val);
static int ASN1CALL ASN1Dec_EndSessionCommand(ASN1decoding_t dec, EndSessionCommand *val);
static int ASN1CALL ASN1Dec_ConferenceCommand(ASN1decoding_t dec, ConferenceCommand *val);
static int ASN1CALL ASN1Dec_UserInputIndication_userInputSupportIndication(ASN1decoding_t dec, UserInputIndication_userInputSupportIndication *val);
static int ASN1CALL ASN1Dec_MiscellaneousIndication_type(ASN1decoding_t dec, MiscellaneousIndication_type *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand_type(ASN1decoding_t dec, MiscellaneousCommand_type *val);
static int ASN1CALL ASN1Dec_EncryptionCommand_encryptionAlgorithmID(ASN1decoding_t dec, EncryptionCommand_encryptionAlgorithmID *val);
static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard *val);
static int ASN1CALL ASN1Dec_RedundancyEncodingMode_secondaryEncoding(ASN1decoding_t dec, RedundancyEncodingMode_secondaryEncoding *val);
static int ASN1CALL ASN1Dec_H223ModeParameters_adaptationLayerType(ASN1decoding_t dec, H223ModeParameters_adaptationLayerType *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard *val);
static int ASN1CALL ASN1Dec_RTPPayloadType_payloadDescriptor(ASN1decoding_t dec, RTPPayloadType_payloadDescriptor *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard *val);
static int ASN1CALL ASN1Dec_H223LogicalChannelParameters_adaptationLayerType(ASN1decoding_t dec, H223LogicalChannelParameters_adaptationLayerType *val);
static int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData(ASN1decoding_t dec, PConferenceCapability_nonStandardData *val);
static int ASN1CALL ASN1Dec_UserInputCapability_nonStandard(ASN1decoding_t dec, UserInputCapability_nonStandard *val);
static int ASN1CALL ASN1Dec_DataProtocolCapability_v76wCompression(ASN1decoding_t dec, DataProtocolCapability_v76wCompression *val);
static int ASN1CALL ASN1Dec_H263Options_modeCombos(ASN1decoding_t dec, PH263Options_modeCombos *val);
static int ASN1CALL ASN1Dec_TransportCapability_qOSCapabilities(ASN1decoding_t dec, PTransportCapability_qOSCapabilities *val);
static int ASN1CALL ASN1Dec_NonStandardMessage(ASN1decoding_t dec, NonStandardMessage *val);
static int ASN1CALL ASN1Dec_RedundancyEncodingCapability(ASN1decoding_t dec, RedundancyEncodingCapability *val);
static int ASN1CALL ASN1Dec_H263VideoCapability(ASN1decoding_t dec, H263VideoCapability *val);
static int ASN1CALL ASN1Dec_EnhancementOptions(ASN1decoding_t dec, EnhancementOptions *val);
static int ASN1CALL ASN1Dec_DataProtocolCapability(ASN1decoding_t dec, DataProtocolCapability *val);
static int ASN1CALL ASN1Dec_EncryptionAuthenticationAndIntegrity(ASN1decoding_t dec, EncryptionAuthenticationAndIntegrity *val);
static int ASN1CALL ASN1Dec_EncryptionCapability(ASN1decoding_t dec, PEncryptionCapability *val);
static int ASN1CALL ASN1Dec_UserInputCapability(ASN1decoding_t dec, UserInputCapability *val);
static int ASN1CALL ASN1Dec_H223LogicalChannelParameters(ASN1decoding_t dec, H223LogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters(ASN1decoding_t dec, V76LogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_RTPPayloadType(ASN1decoding_t dec, RTPPayloadType *val);
static int ASN1CALL ASN1Dec_H245TransportAddress(ASN1decoding_t dec, H245TransportAddress *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters(ASN1decoding_t dec, H2250LogicalChannelAckParameters *val);
static int ASN1CALL ASN1Dec_H223ModeParameters(ASN1decoding_t dec, H223ModeParameters *val);
static int ASN1CALL ASN1Dec_RedundancyEncodingMode(ASN1decoding_t dec, RedundancyEncodingMode *val);
static int ASN1CALL ASN1Dec_VideoMode(ASN1decoding_t dec, VideoMode *val);
static int ASN1CALL ASN1Dec_EncryptionCommand(ASN1decoding_t dec, EncryptionCommand *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand(ASN1decoding_t dec, MiscellaneousCommand *val);
static int ASN1CALL ASN1Dec_MiscellaneousIndication(ASN1decoding_t dec, MiscellaneousIndication *val);
static int ASN1CALL ASN1Dec_MCLocationIndication(ASN1decoding_t dec, MCLocationIndication *val);
static int ASN1CALL ASN1Dec_UserInputIndication(ASN1decoding_t dec, UserInputIndication *val);
static int ASN1CALL ASN1Dec_DataApplicationCapability_application_nlpid(ASN1decoding_t dec, DataApplicationCapability_application_nlpid *val);
static int ASN1CALL ASN1Dec_DataApplicationCapability_application_t84(ASN1decoding_t dec, DataApplicationCapability_application_t84 *val);
static int ASN1CALL ASN1Dec_DataMode_application_nlpid(ASN1decoding_t dec, DataMode_application_nlpid *val);
static int ASN1CALL ASN1Dec_DataMode_application(ASN1decoding_t dec, DataMode_application *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_forwardMultiplexAckParameters(ASN1decoding_t dec, OpenLogicalChannelAck_forwardMultiplexAckParameters *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_mediaPacketization(ASN1decoding_t dec, H2250LogicalChannelParameters_mediaPacketization *val);
static int ASN1CALL ASN1Dec_NetworkAccessParameters_networkAddress(ASN1decoding_t dec, NetworkAccessParameters_networkAddress *val);
static int ASN1CALL ASN1Dec_DataApplicationCapability_application(ASN1decoding_t dec, DataApplicationCapability_application *val);
static int ASN1CALL ASN1Dec_EnhancementLayerInfo_spatialEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_spatialEnhancement *val);
static int ASN1CALL ASN1Dec_EnhancementLayerInfo_snrEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_snrEnhancement *val);
static int ASN1CALL ASN1Dec_MediaPacketizationCapability_rtpPayloadType(ASN1decoding_t dec, MediaPacketizationCapability_rtpPayloadType *val);
static int ASN1CALL ASN1Dec_H2250Capability_redundancyEncodingCapability(ASN1decoding_t dec, PH2250Capability_redundancyEncodingCapability *val);
static int ASN1CALL ASN1Dec_CommandMessage(ASN1decoding_t dec, CommandMessage *val);
static int ASN1CALL ASN1Dec_H235SecurityCapability(ASN1decoding_t dec, H235SecurityCapability *val);
static int ASN1CALL ASN1Dec_MediaPacketizationCapability(ASN1decoding_t dec, MediaPacketizationCapability *val);
static int ASN1CALL ASN1Dec_VideoCapability(ASN1decoding_t dec, VideoCapability *val);
static int ASN1CALL ASN1Dec_BEnhancementParameters(ASN1decoding_t dec, BEnhancementParameters *val);
static int ASN1CALL ASN1Dec_DataApplicationCapability(ASN1decoding_t dec, DataApplicationCapability *val);
static int ASN1CALL ASN1Dec_NetworkAccessParameters(ASN1decoding_t dec, NetworkAccessParameters *val);
static int ASN1CALL ASN1Dec_H2250ModeParameters(ASN1decoding_t dec, H2250ModeParameters *val);
static int ASN1CALL ASN1Dec_DataMode(ASN1decoding_t dec, DataMode *val);
static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_dataType(ASN1decoding_t dec, CommunicationModeTableEntry_dataType *val);
static int ASN1CALL ASN1Dec_H235Mode_mediaMode(ASN1decoding_t dec, H235Mode_mediaMode *val);
static int ASN1CALL ASN1Dec_H235Media_mediaType(ASN1decoding_t dec, H235Media_mediaType *val);
static int ASN1CALL ASN1Dec_EnhancementLayerInfo_bPictureEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_bPictureEnhancement *val);
static int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData(ASN1decoding_t dec, PMediaDistributionCapability_distributedData *val);
static int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData *val);
static int ASN1CALL ASN1Dec_Capability(ASN1decoding_t dec, Capability *val);
static int ASN1CALL ASN1Dec_H2250Capability(ASN1decoding_t dec, H2250Capability *val);
static int ASN1CALL ASN1Dec_H235Media(ASN1decoding_t dec, H235Media *val);
static int ASN1CALL ASN1Dec_H235Mode(ASN1decoding_t dec, H235Mode *val);
static int ASN1CALL ASN1Dec_ModeElement_type(ASN1decoding_t dec, ModeElement_type *val);
static int ASN1CALL ASN1Dec_CapabilityTableEntry(ASN1decoding_t dec, CapabilityTableEntry *val);
static int ASN1CALL ASN1Dec_MultiplexCapability(ASN1decoding_t dec, MultiplexCapability *val);
static int ASN1CALL ASN1Dec_DataType(ASN1decoding_t dec, DataType *val);
static int ASN1CALL ASN1Dec_RedundancyEncoding(ASN1decoding_t dec, RedundancyEncoding *val);
static int ASN1CALL ASN1Dec_ModeElement(ASN1decoding_t dec, ModeElement *val);
static int ASN1CALL ASN1Dec_CommunicationModeTableEntry(ASN1decoding_t dec, CommunicationModeTableEntry *val);
static int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable *val);
static int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySet(ASN1decoding_t dec, TerminalCapabilitySet *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters(ASN1decoding_t dec, H2250LogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_ModeDescription(ASN1decoding_t dec, ModeDescription *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Dec_RequestMode_requestedModes(ASN1decoding_t dec, PRequestMode_requestedModes *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannelAck_reverseLogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannel_reverseLogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannel_forwardLogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel(ASN1decoding_t dec, OpenLogicalChannel *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelAck(ASN1decoding_t dec, OpenLogicalChannelAck *val);
static int ASN1CALL ASN1Dec_RequestMessage(ASN1decoding_t dec, RequestMessage *val);
static int ASN1CALL ASN1Dec_ResponseMessage(ASN1decoding_t dec, ResponseMessage *val);
static int ASN1CALL ASN1Dec_FastConnectOLC(ASN1decoding_t dec, FastConnectOLC *val);
static int ASN1CALL ASN1Dec_FunctionNotUnderstood(ASN1decoding_t dec, FunctionNotUnderstood *val);
static int ASN1CALL ASN1Dec_IndicationMessage(ASN1decoding_t dec, IndicationMessage *val);
static int ASN1CALL ASN1Dec_MultimediaSystemControlMessage(ASN1decoding_t dec, MultimediaSystemControlMessage *val);
static void ASN1CALL ASN1Free_CustomPictureFormat_mPI_customPCF(CustomPictureFormat_mPI_customPCF *val);
static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation_extendedPAR(CustomPictureFormat_pixelAspectInformation_extendedPAR *val);
static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val);
static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route(PUnicastAddress_iPSourceRouteAddress_route *val);
static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val);
static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val);
static void ASN1CALL ASN1Free_UserInputIndication_signal(UserInputIndication_signal *val);
static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest(SendTerminalCapabilitySet_specificRequest *val);
static void ASN1CALL ASN1Free_ConferenceResponse_extensionAddressResponse(ConferenceResponse_extensionAddressResponse *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryRelease_entryNumbers(RequestMultiplexEntryRelease_entryNumbers *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryReject_entryNumbers(RequestMultiplexEntryReject_entryNumbers *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryAck_entryNumbers(RequestMultiplexEntryAck_entryNumbers *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntry_entryNumbers(RequestMultiplexEntry_entryNumbers *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendRelease_multiplexTableEntryNumber(MultiplexEntrySendRelease_multiplexTableEntryNumber *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendAck_multiplexTableEntryNumber(MultiplexEntrySendAck_multiplexTableEntryNumber *val);
static void ASN1CALL ASN1Free_MultiplexElement_type(MultiplexElement_type *val);
static void ASN1CALL ASN1Free_MulticastAddress_iP6Address(MulticastAddress_iP6Address *val);
static void ASN1CALL ASN1Free_MulticastAddress_iPAddress(MulticastAddress_iPAddress *val);
static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress(UnicastAddress_iPSourceRouteAddress *val);
static void ASN1CALL ASN1Free_UnicastAddress_iP6Address(UnicastAddress_iP6Address *val);
static void ASN1CALL ASN1Free_UnicastAddress_iPXAddress(UnicastAddress_iPXAddress *val);
static void ASN1CALL ASN1Free_UnicastAddress_iPAddress(UnicastAddress_iPAddress *val);
static void ASN1CALL ASN1Free_Q2931Address_address(Q2931Address_address *val);
static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation(CustomPictureFormat_pixelAspectInformation *val);
static void ASN1CALL ASN1Free_CustomPictureFormat_mPI(CustomPictureFormat_mPI *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyFrameMapping_frameSequence(RTPH263VideoRedundancyFrameMapping_frameSequence *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_containedThreads(RTPH263VideoRedundancyEncoding_containedThreads *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping(RTPH263VideoRedundancyEncoding_frameToThreadMapping *val);
static void ASN1CALL ASN1Free_RedundancyEncodingCapability_secondaryEncoding(PRedundancyEncodingCapability_secondaryEncoding *val);
static void ASN1CALL ASN1Free_NonStandardIdentifier(NonStandardIdentifier *val);
static void ASN1CALL ASN1Free_CapabilityDescriptor(CapabilityDescriptor *val);
static void ASN1CALL ASN1Free_AlternativeCapabilitySet(AlternativeCapabilitySet *val);
static void ASN1CALL ASN1Free_H222Capability(H222Capability *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding(RTPH263VideoRedundancyEncoding *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyFrameMapping(RTPH263VideoRedundancyFrameMapping *val);
static void ASN1CALL ASN1Free_MultipointCapability(MultipointCapability *val);
static void ASN1CALL ASN1Free_MediaDistributionCapability(MediaDistributionCapability *val);
static void ASN1CALL ASN1Free_EnhancementLayerInfo(EnhancementLayerInfo *val);
static void ASN1CALL ASN1Free_CustomPictureFormat(CustomPictureFormat *val);
static void ASN1CALL ASN1Free_ConferenceCapability(ConferenceCapability *val);
static void ASN1CALL ASN1Free_Q2931Address(Q2931Address *val);
static void ASN1CALL ASN1Free_H222LogicalChannelParameters(H222LogicalChannelParameters *val);
static void ASN1CALL ASN1Free_EscrowData(EscrowData *val);
static void ASN1CALL ASN1Free_MultiplexEntrySend(MultiplexEntrySend *val);
static void ASN1CALL ASN1Free_MultiplexElement(MultiplexElement *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendAck(MultiplexEntrySendAck *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendRelease(MultiplexEntrySendRelease *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntry(RequestMultiplexEntry *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryAck(RequestMultiplexEntryAck *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryRelease(RequestMultiplexEntryRelease *val);
static void ASN1CALL ASN1Free_RequestMode(RequestMode *val);
static void ASN1CALL ASN1Free_CommunicationModeCommand(CommunicationModeCommand *val);
static void ASN1CALL ASN1Free_CommunicationModeResponse(CommunicationModeResponse *val);
static void ASN1CALL ASN1Free_Criteria(Criteria *val);
static void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse(RequestAllTerminalIDsResponse *val);
static void ASN1CALL ASN1Free_TerminalInformation(TerminalInformation *val);
static void ASN1CALL ASN1Free_SendTerminalCapabilitySet(SendTerminalCapabilitySet *val);
static void ASN1CALL ASN1Free_SubstituteConferenceIDCommand(SubstituteConferenceIDCommand *val);
static void ASN1CALL ASN1Free_FunctionNotSupported(FunctionNotSupported *val);
static void ASN1CALL ASN1Free_VendorIdentification(VendorIdentification *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val);
static void ASN1CALL ASN1Free_MultiplexElement_type_subElementList(PMultiplexElement_type_subElementList *val);
static void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse_terminalInformation(PRequestAllTerminalIDsResponse_terminalInformation *val);
static void ASN1CALL ASN1Free_ConferenceResponse_terminalCertificateResponse(ConferenceResponse_terminalCertificateResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_chairTokenOwnerResponse(ConferenceResponse_chairTokenOwnerResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_terminalListResponse(ConferenceResponse_terminalListResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_passwordResponse(ConferenceResponse_passwordResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_conferenceIDResponse(ConferenceResponse_conferenceIDResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_terminalIDResponse(ConferenceResponse_terminalIDResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_mCTerminalIDResponse(ConferenceResponse_mCTerminalIDResponse *val);
static void ASN1CALL ASN1Free_ConferenceRequest_requestTerminalCertificate(ConferenceRequest_requestTerminalCertificate *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryReject_rejectionDescriptions(RequestMultiplexEntryReject_rejectionDescriptions *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendReject_rejectionDescriptions(MultiplexEntrySendReject_rejectionDescriptions *val);
static void ASN1CALL ASN1Free_MultiplexEntryDescriptor_elementList(MultiplexEntryDescriptor_elementList *val);
static void ASN1CALL ASN1Free_EncryptionSync_escrowentry(PEncryptionSync_escrowentry *val);
static void ASN1CALL ASN1Free_H263VideoModeCombos_h263VideoCoupledModes(H263VideoModeCombos_h263VideoCoupledModes *val);
static void ASN1CALL ASN1Free_H263Options_customPictureFormat(PH263Options_customPictureFormat *val);
static void ASN1CALL ASN1Free_H263Options_customPictureClockFrequency(PH263Options_customPictureClockFrequency *val);
static void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability(PMultipointCapability_mediaDistributionCapability *val);
static void ASN1CALL ASN1Free_TransportCapability_mediaChannelCapabilities(TransportCapability_mediaChannelCapabilities *val);
static void ASN1CALL ASN1Free_H222Capability_vcCapability(PH222Capability_vcCapability *val);
static void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities(PCapabilityDescriptor_simultaneousCapabilities *val);
static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityDescriptors(TerminalCapabilitySet_capabilityDescriptors *val);
static void ASN1CALL ASN1Free_NonStandardParameter(NonStandardParameter *val);
static void ASN1CALL ASN1Free_QOSCapability(QOSCapability *val);
static void ASN1CALL ASN1Free_TransportCapability(TransportCapability *val);
static void ASN1CALL ASN1Free_RedundancyEncodingMethod(RedundancyEncodingMethod *val);
static void ASN1CALL ASN1Free_H263Options(H263Options *val);
static void ASN1CALL ASN1Free_H263VideoModeCombos(H263VideoModeCombos *val);
static void ASN1CALL ASN1Free_AudioCapability(AudioCapability *val);
static void ASN1CALL ASN1Free_MediaEncryptionAlgorithm(MediaEncryptionAlgorithm *val);
static void ASN1CALL ASN1Free_AuthenticationCapability(AuthenticationCapability *val);
static void ASN1CALL ASN1Free_IntegrityCapability(IntegrityCapability *val);
static void ASN1CALL ASN1Free_UnicastAddress(UnicastAddress *val);
static void ASN1CALL ASN1Free_MulticastAddress(MulticastAddress *val);
static void ASN1CALL ASN1Free_EncryptionSync(EncryptionSync *val);
static void ASN1CALL ASN1Free_RequestChannelClose(RequestChannelClose *val);
static void ASN1CALL ASN1Free_MultiplexEntryDescriptor(MultiplexEntryDescriptor *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendReject(MultiplexEntrySendReject *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryReject(RequestMultiplexEntryReject *val);
static void ASN1CALL ASN1Free_H263VideoMode(H263VideoMode *val);
static void ASN1CALL ASN1Free_AudioMode(AudioMode *val);
static void ASN1CALL ASN1Free_EncryptionMode(EncryptionMode *val);
static void ASN1CALL ASN1Free_ConferenceRequest(ConferenceRequest *val);
static void ASN1CALL ASN1Free_CertSelectionCriteria(PCertSelectionCriteria *val);
static void ASN1CALL ASN1Free_ConferenceResponse(ConferenceResponse *val);
static void ASN1CALL ASN1Free_EndSessionCommand(EndSessionCommand *val);
static void ASN1CALL ASN1Free_ConferenceCommand(ConferenceCommand *val);
static void ASN1CALL ASN1Free_UserInputIndication_userInputSupportIndication(UserInputIndication_userInputSupportIndication *val);
static void ASN1CALL ASN1Free_MiscellaneousIndication_type(MiscellaneousIndication_type *val);
static void ASN1CALL ASN1Free_MiscellaneousCommand_type(MiscellaneousCommand_type *val);
static void ASN1CALL ASN1Free_EncryptionCommand_encryptionAlgorithmID(EncryptionCommand_encryptionAlgorithmID *val);
static void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard(PCommunicationModeTableEntry_nonStandard *val);
static void ASN1CALL ASN1Free_RedundancyEncodingMode_secondaryEncoding(RedundancyEncodingMode_secondaryEncoding *val);
static void ASN1CALL ASN1Free_H223ModeParameters_adaptationLayerType(H223ModeParameters_adaptationLayerType *val);
static void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors(PMultiplexEntrySend_multiplexEntryDescriptors *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard(PH2250LogicalChannelAckParameters_nonStandard *val);
static void ASN1CALL ASN1Free_RTPPayloadType_payloadDescriptor(RTPPayloadType_payloadDescriptor *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard(PH2250LogicalChannelParameters_nonStandard *val);
static void ASN1CALL ASN1Free_H223LogicalChannelParameters_adaptationLayerType(H223LogicalChannelParameters_adaptationLayerType *val);
static void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData(PConferenceCapability_nonStandardData *val);
static void ASN1CALL ASN1Free_UserInputCapability_nonStandard(UserInputCapability_nonStandard *val);
static void ASN1CALL ASN1Free_H263Options_modeCombos(PH263Options_modeCombos *val);
static void ASN1CALL ASN1Free_TransportCapability_qOSCapabilities(PTransportCapability_qOSCapabilities *val);
static void ASN1CALL ASN1Free_NonStandardMessage(NonStandardMessage *val);
static void ASN1CALL ASN1Free_RedundancyEncodingCapability(RedundancyEncodingCapability *val);
static void ASN1CALL ASN1Free_H263VideoCapability(H263VideoCapability *val);
static void ASN1CALL ASN1Free_EnhancementOptions(EnhancementOptions *val);
static void ASN1CALL ASN1Free_DataProtocolCapability(DataProtocolCapability *val);
static void ASN1CALL ASN1Free_EncryptionAuthenticationAndIntegrity(EncryptionAuthenticationAndIntegrity *val);
static void ASN1CALL ASN1Free_EncryptionCapability(PEncryptionCapability *val);
static void ASN1CALL ASN1Free_UserInputCapability(UserInputCapability *val);
static void ASN1CALL ASN1Free_H223LogicalChannelParameters(H223LogicalChannelParameters *val);
static void ASN1CALL ASN1Free_RTPPayloadType(RTPPayloadType *val);
static void ASN1CALL ASN1Free_H245TransportAddress(H245TransportAddress *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters(H2250LogicalChannelAckParameters *val);
static void ASN1CALL ASN1Free_H223ModeParameters(H223ModeParameters *val);
static void ASN1CALL ASN1Free_RedundancyEncodingMode(RedundancyEncodingMode *val);
static void ASN1CALL ASN1Free_VideoMode(VideoMode *val);
static void ASN1CALL ASN1Free_EncryptionCommand(EncryptionCommand *val);
static void ASN1CALL ASN1Free_MiscellaneousCommand(MiscellaneousCommand *val);
static void ASN1CALL ASN1Free_MiscellaneousIndication(MiscellaneousIndication *val);
static void ASN1CALL ASN1Free_MCLocationIndication(MCLocationIndication *val);
static void ASN1CALL ASN1Free_UserInputIndication(UserInputIndication *val);
static void ASN1CALL ASN1Free_DataApplicationCapability_application_nlpid(DataApplicationCapability_application_nlpid *val);
static void ASN1CALL ASN1Free_DataApplicationCapability_application_t84(DataApplicationCapability_application_t84 *val);
static void ASN1CALL ASN1Free_DataMode_application_nlpid(DataMode_application_nlpid *val);
static void ASN1CALL ASN1Free_DataMode_application(DataMode_application *val);
static void ASN1CALL ASN1Free_OpenLogicalChannelAck_forwardMultiplexAckParameters(OpenLogicalChannelAck_forwardMultiplexAckParameters *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelParameters_mediaPacketization(H2250LogicalChannelParameters_mediaPacketization *val);
static void ASN1CALL ASN1Free_NetworkAccessParameters_networkAddress(NetworkAccessParameters_networkAddress *val);
static void ASN1CALL ASN1Free_DataApplicationCapability_application(DataApplicationCapability_application *val);
static void ASN1CALL ASN1Free_EnhancementLayerInfo_spatialEnhancement(PEnhancementLayerInfo_spatialEnhancement *val);
static void ASN1CALL ASN1Free_EnhancementLayerInfo_snrEnhancement(PEnhancementLayerInfo_snrEnhancement *val);
static void ASN1CALL ASN1Free_MediaPacketizationCapability_rtpPayloadType(MediaPacketizationCapability_rtpPayloadType *val);
static void ASN1CALL ASN1Free_H2250Capability_redundancyEncodingCapability(PH2250Capability_redundancyEncodingCapability *val);
static void ASN1CALL ASN1Free_CommandMessage(CommandMessage *val);
static void ASN1CALL ASN1Free_H235SecurityCapability(H235SecurityCapability *val);
static void ASN1CALL ASN1Free_MediaPacketizationCapability(MediaPacketizationCapability *val);
static void ASN1CALL ASN1Free_VideoCapability(VideoCapability *val);
static void ASN1CALL ASN1Free_BEnhancementParameters(BEnhancementParameters *val);
static void ASN1CALL ASN1Free_DataApplicationCapability(DataApplicationCapability *val);
static void ASN1CALL ASN1Free_NetworkAccessParameters(NetworkAccessParameters *val);
static void ASN1CALL ASN1Free_H2250ModeParameters(H2250ModeParameters *val);
static void ASN1CALL ASN1Free_DataMode(DataMode *val);
static void ASN1CALL ASN1Free_CommunicationModeTableEntry_dataType(CommunicationModeTableEntry_dataType *val);
static void ASN1CALL ASN1Free_H235Mode_mediaMode(H235Mode_mediaMode *val);
static void ASN1CALL ASN1Free_H235Media_mediaType(H235Media_mediaType *val);
static void ASN1CALL ASN1Free_EnhancementLayerInfo_bPictureEnhancement(PEnhancementLayerInfo_bPictureEnhancement *val);
static void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData(PMediaDistributionCapability_distributedData *val);
static void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData(PMediaDistributionCapability_centralizedData *val);
static void ASN1CALL ASN1Free_Capability(Capability *val);
static void ASN1CALL ASN1Free_H2250Capability(H2250Capability *val);
static void ASN1CALL ASN1Free_H235Media(H235Media *val);
static void ASN1CALL ASN1Free_H235Mode(H235Mode *val);
static void ASN1CALL ASN1Free_ModeElement_type(ModeElement_type *val);
static void ASN1CALL ASN1Free_CapabilityTableEntry(CapabilityTableEntry *val);
static void ASN1CALL ASN1Free_MultiplexCapability(MultiplexCapability *val);
static void ASN1CALL ASN1Free_DataType(DataType *val);
static void ASN1CALL ASN1Free_RedundancyEncoding(RedundancyEncoding *val);
static void ASN1CALL ASN1Free_ModeElement(ModeElement *val);
static void ASN1CALL ASN1Free_CommunicationModeTableEntry(CommunicationModeTableEntry *val);
static void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable(PCommunicationModeResponse_communicationModeTable *val);
static void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable(PCommunicationModeCommand_communicationModeTable *val);
static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable(PTerminalCapabilitySet_capabilityTable *val);
static void ASN1CALL ASN1Free_TerminalCapabilitySet(TerminalCapabilitySet *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelParameters(H2250LogicalChannelParameters *val);
static void ASN1CALL ASN1Free_ModeDescription(ModeDescription *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val);
static void ASN1CALL ASN1Free_RequestMode_requestedModes(PRequestMode_requestedModes *val);
static void ASN1CALL ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters(OpenLogicalChannelAck_reverseLogicalChannelParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters(OpenLogicalChannel_reverseLogicalChannelParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters(OpenLogicalChannel_forwardLogicalChannelParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel(OpenLogicalChannel *val);
static void ASN1CALL ASN1Free_OpenLogicalChannelAck(OpenLogicalChannelAck *val);
static void ASN1CALL ASN1Free_RequestMessage(RequestMessage *val);
static void ASN1CALL ASN1Free_ResponseMessage(ResponseMessage *val);
static void ASN1CALL ASN1Free_FastConnectOLC(FastConnectOLC *val);
static void ASN1CALL ASN1Free_FunctionNotUnderstood(FunctionNotUnderstood *val);
static void ASN1CALL ASN1Free_IndicationMessage(IndicationMessage *val);
static void ASN1CALL ASN1Free_MultimediaSystemControlMessage(MultimediaSystemControlMessage *val);

typedef ASN1PerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[2] = {
    (ASN1EncFun_t) ASN1Enc_FastConnectOLC,
    (ASN1EncFun_t) ASN1Enc_MultimediaSystemControlMessage,
};
typedef ASN1PerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[2] = {
    (ASN1DecFun_t) ASN1Dec_FastConnectOLC,
    (ASN1DecFun_t) ASN1Dec_MultimediaSystemControlMessage,
};
static const ASN1FreeFun_t freefntab[2] = {
    (ASN1FreeFun_t) ASN1Free_FastConnectOLC,
    (ASN1FreeFun_t) ASN1Free_MultimediaSystemControlMessage,
};
static const ULONG sizetab[2] = {
    SIZE_H245ASN_Module_PDU_0,
    SIZE_H245ASN_Module_PDU_1,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL H245ASN_Module_Startup(void)
{
    H245ASN_Module = ASN1_CreateModule(0x10000, ASN1_PER_RULE_ALIGNED, ASN1FLAGS_NONE, 2, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x35343268);
}

void ASN1CALL H245ASN_Module_Cleanup(void)
{
    ASN1_CloseModule(H245ASN_Module);
    H245ASN_Module = NULL;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1_errorCorrection(ASN1encoding_t enc, NewATMVCIndication_aal_aal1_errorCorrection *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1_errorCorrection(ASN1decoding_t dec, NewATMVCIndication_aal_aal1_errorCorrection *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1_clockRecovery(ASN1encoding_t enc, NewATMVCIndication_aal_aal1_clockRecovery *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1_clockRecovery(ASN1decoding_t dec, NewATMVCIndication_aal_aal1_clockRecovery *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(ASN1encoding_t enc, MiscellaneousCommand_type_progressiveRefinementStart_repeatCount *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(ASN1decoding_t dec, MiscellaneousCommand_type_progressiveRefinementStart_repeatCount *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode_eRM_recovery(ASN1encoding_t enc, V76LogicalChannelParameters_mode_eRM_recovery *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode_eRM_recovery(ASN1decoding_t dec, V76LogicalChannelParameters_mode_eRM_recovery *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_extendedPAR_Set *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->width - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->height - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_extendedPAR_Set *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->width))
	return 0;
    (val)->width += 1;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->height))
	return 0;
    (val)->height += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI_customPCF_Set(ASN1encoding_t enc, CustomPictureFormat_mPI_customPCF_Set *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->clockConversionCode - 1000))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->clockDivisor - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->customMPI - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI_customPCF_Set(ASN1decoding_t dec, CustomPictureFormat_mPI_customPCF_Set *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 1, &(val)->clockConversionCode))
	return 0;
    (val)->clockConversionCode += 1000;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->clockDivisor))
	return 0;
    (val)->clockDivisor += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->customMPI))
	return 0;
    (val)->customMPI += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_availableBitRates_type_rangeOfBitRates(ASN1encoding_t enc, VCCapability_availableBitRates_type_rangeOfBitRates *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->lowerBitRate - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->higherBitRate - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_availableBitRates_type_rangeOfBitRates(ASN1decoding_t dec, VCCapability_availableBitRates_type_rangeOfBitRates *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->lowerBitRate))
	return 0;
    (val)->lowerBitRate += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->higherBitRate))
	return 0;
    (val)->higherBitRate += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(ASN1encoding_t enc, TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.highestEntryNumberProcessed - 1))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(ASN1decoding_t dec, TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.highestEntryNumberProcessed))
	    return 0;
	(val)->u.highestEntryNumberProcessed += 1;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_availableBitRates_type(ASN1encoding_t enc, VCCapability_availableBitRates_type *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.singleBitRate - 1))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_VCCapability_availableBitRates_type_rangeOfBitRates(enc, &(val)->u.rangeOfBitRates))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_availableBitRates_type(ASN1decoding_t dec, VCCapability_availableBitRates_type *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.singleBitRate))
	    return 0;
	(val)->u.singleBitRate += 1;
	break;
    case 2:
	if (!ASN1Dec_VCCapability_availableBitRates_type_rangeOfBitRates(dec, &(val)->u.rangeOfBitRates))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223Capability_h223MultiplexTableCapability_enhanced(ASN1encoding_t enc, H223Capability_h223MultiplexTableCapability_enhanced *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->maximumNestingDepth - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->maximumElementListSize - 2))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->maximumSubElementListSize - 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223Capability_h223MultiplexTableCapability_enhanced(ASN1decoding_t dec, H223Capability_h223MultiplexTableCapability_enhanced *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->maximumNestingDepth))
	return 0;
    (val)->maximumNestingDepth += 1;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maximumElementListSize))
	return 0;
    (val)->maximumElementListSize += 2;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maximumSubElementListSize))
	return 0;
    (val)->maximumSubElementListSize += 2;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI_customPCF(ASN1encoding_t enc, CustomPictureFormat_mPI_customPCF *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_CustomPictureFormat_mPI_customPCF_Set(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI_customPCF(ASN1decoding_t dec, CustomPictureFormat_mPI_customPCF *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_CustomPictureFormat_mPI_customPCF_Set(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat_mPI_customPCF(CustomPictureFormat_mPI_customPCF *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_extendedPAR *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_extendedPAR *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation_extendedPAR(CustomPictureFormat_pixelAspectInformation_extendedPAR *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_H223LogicalChannelParameters_adaptationLayerType_al3(ASN1encoding_t enc, H223LogicalChannelParameters_adaptationLayerType_al3 *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncBitVal(enc, 2, (val)->controlFieldOctets))
	return 0;
    l = ASN1uint32_uoctets((val)->sendBufferSize);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->sendBufferSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223LogicalChannelParameters_adaptationLayerType_al3(ASN1decoding_t dec, H223LogicalChannelParameters_adaptationLayerType_al3 *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecU16Val(dec, 2, &(val)->controlFieldOctets))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->sendBufferSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode_eRM(ASN1encoding_t enc, V76LogicalChannelParameters_mode_eRM *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->windowSize - 1))
	return 0;
    if (!ASN1Enc_V76LogicalChannelParameters_mode_eRM_recovery(enc, &(val)->recovery))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode_eRM(ASN1decoding_t dec, V76LogicalChannelParameters_mode_eRM *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->windowSize))
	return 0;
    (val)->windowSize += 1;
    if (!ASN1Dec_V76LogicalChannelParameters_mode_eRM_recovery(dec, &(val)->recovery))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnicastAddress_iPSourceRouteAddress_route_ElmFn);
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &val->value, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnicastAddress_iPSourceRouteAddress_route_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &val->value, 4))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route(PUnicastAddress_iPSourceRouteAddress_route *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnicastAddress_iPSourceRouteAddress_route_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route_ElmFn(PUnicastAddress_iPSourceRouteAddress_route val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_routing(ASN1encoding_t enc, UnicastAddress_iPSourceRouteAddress_routing *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_routing(ASN1decoding_t dec, UnicastAddress_iPSourceRouteAddress_routing *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223ModeParameters_adaptationLayerType_al3(ASN1encoding_t enc, H223ModeParameters_adaptationLayerType_al3 *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncBitVal(enc, 2, (val)->controlFieldOctets))
	return 0;
    l = ASN1uint32_uoctets((val)->sendBufferSize);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->sendBufferSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223ModeParameters_adaptationLayerType_al3(ASN1decoding_t dec, H223ModeParameters_adaptationLayerType_al3 *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecU16Val(dec, 2, &(val)->controlFieldOctets))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->sendBufferSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(ASN1encoding_t enc, SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(ASN1decoding_t dec, SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn, 1, 65535, 16);
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn, sizeof(**val), 1, 65535, 16);
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1;
    return 1;
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart(ASN1encoding_t enc, MiscellaneousCommand_type_progressiveRefinementStart *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(enc, &(val)->repeatCount))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart(ASN1decoding_t dec, MiscellaneousCommand_type_progressiveRefinementStart *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(dec, &(val)->repeatCount))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_videoFastUpdateMB(ASN1encoding_t enc, MiscellaneousCommand_type_videoFastUpdateMB *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->firstGOB))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->firstMB - 1))
	    return 0;
    }
    if (!ASN1PEREncUnsignedShort(enc, (val)->numberOfMBs - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_videoFastUpdateMB(ASN1decoding_t dec, MiscellaneousCommand_type_videoFastUpdateMB *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->firstGOB))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->firstMB))
	    return 0;
	(val)->firstMB += 1;
    }
    if (!ASN1PERDecUnsignedShort(dec, &(val)->numberOfMBs))
	return 0;
    (val)->numberOfMBs += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_videoFastUpdateGOB(ASN1encoding_t enc, MiscellaneousCommand_type_videoFastUpdateGOB *val)
{
    if (!ASN1PEREncBitVal(enc, 5, (val)->firstGOB))
	return 0;
    if (!ASN1PEREncBitVal(enc, 5, (val)->numberOfGOBs - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_videoFastUpdateGOB(ASN1decoding_t dec, MiscellaneousCommand_type_videoFastUpdateGOB *val)
{
    if (!ASN1PERDecU16Val(dec, 5, &(val)->firstGOB))
	return 0;
    if (!ASN1PERDecU16Val(dec, 5, &(val)->numberOfGOBs))
	return 0;
    (val)->numberOfGOBs += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_MiscellaneousIndication_type_videoNotDecodedMBs(ASN1encoding_t enc, MiscellaneousIndication_type_videoNotDecodedMBs *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->firstMB - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->numberOfMBs - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->temporalReference))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousIndication_type_videoNotDecodedMBs(ASN1decoding_t dec, MiscellaneousIndication_type_videoNotDecodedMBs *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->firstMB))
	return 0;
    (val)->firstMB += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->numberOfMBs))
	return 0;
    (val)->numberOfMBs += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->temporalReference))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal5(ASN1encoding_t enc, NewATMVCIndication_aal_aal5 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardMaximumSDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->backwardMaximumSDUSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal5(ASN1decoding_t dec, NewATMVCIndication_aal_aal5 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardMaximumSDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->backwardMaximumSDUSize))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1(ASN1encoding_t enc, NewATMVCIndication_aal_aal1 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_NewATMVCIndication_aal_aal1_clockRecovery(enc, &(val)->clockRecovery))
	return 0;
    if (!ASN1Enc_NewATMVCIndication_aal_aal1_errorCorrection(enc, &(val)->errorCorrection))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->structuredDataTransfer))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->partiallyFilledCells))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1(ASN1decoding_t dec, NewATMVCIndication_aal_aal1 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_NewATMVCIndication_aal_aal1_clockRecovery(dec, &(val)->clockRecovery))
	return 0;
    if (!ASN1Dec_NewATMVCIndication_aal_aal1_errorCorrection(dec, &(val)->errorCorrection))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->structuredDataTransfer))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->partiallyFilledCells))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_reverseParameters_multiplex(ASN1encoding_t enc, NewATMVCIndication_reverseParameters_multiplex *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_reverseParameters_multiplex(ASN1decoding_t dec, NewATMVCIndication_reverseParameters_multiplex *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_UserInputIndication_signal_rtp(ASN1encoding_t enc, UserInputIndication_signal_rtp *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->timestamp);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->timestamp))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->expirationTime);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->expirationTime))
	    return 0;
    }
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication_signal_rtp(ASN1decoding_t dec, UserInputIndication_signal_rtp *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->timestamp))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->expirationTime))
	    return 0;
    }
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber))
	return 0;
    (val)->logicalChannelNumber += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UserInputIndication_signalUpdate_rtp(ASN1encoding_t enc, UserInputIndication_signalUpdate_rtp *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication_signalUpdate_rtp(ASN1decoding_t dec, UserInputIndication_signalUpdate_rtp *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber))
	return 0;
    (val)->logicalChannelNumber += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UserInputIndication_signalUpdate(ASN1encoding_t enc, UserInputIndication_signalUpdate *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->duration - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_UserInputIndication_signalUpdate_rtp(enc, &(val)->rtp))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication_signalUpdate(ASN1decoding_t dec, UserInputIndication_signalUpdate *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->duration))
	return 0;
    (val)->duration += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_UserInputIndication_signalUpdate_rtp(dec, &(val)->rtp))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UserInputIndication_signal(ASN1encoding_t enc, UserInputIndication_signal *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    t = lstrlenA((val)->signalType);
    if (!ASN1PEREncCharString(enc, t, (val)->signalType, 8))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->duration - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_UserInputIndication_signal_rtp(enc, &(val)->rtp))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication_signal(ASN1decoding_t dec, UserInputIndication_signal *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecZeroCharStringNoAlloc(dec, 1, (val)->signalType, 8))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->duration))
	    return 0;
	(val)->duration += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_UserInputIndication_signal_rtp(dec, &(val)->rtp))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserInputIndication_signal(UserInputIndication_signal *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_reverseParameters(ASN1encoding_t enc, NewATMVCIndication_reverseParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->bitRateLockedToPCRClock))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->bitRateLockedToNetworkClock))
	return 0;
    if (!ASN1Enc_NewATMVCIndication_reverseParameters_multiplex(enc, &(val)->multiplex))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_reverseParameters(ASN1decoding_t dec, NewATMVCIndication_reverseParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->bitRateLockedToPCRClock))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->bitRateLockedToNetworkClock))
	return 0;
    if (!ASN1Dec_NewATMVCIndication_reverseParameters_multiplex(dec, &(val)->multiplex))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_multiplex(ASN1encoding_t enc, NewATMVCIndication_multiplex *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_multiplex(ASN1decoding_t dec, NewATMVCIndication_multiplex *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal(ASN1encoding_t enc, NewATMVCIndication_aal *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NewATMVCIndication_aal_aal1(enc, &(val)->u.aal1))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_NewATMVCIndication_aal_aal5(enc, &(val)->u.aal5))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal(ASN1decoding_t dec, NewATMVCIndication_aal *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NewATMVCIndication_aal_aal1(dec, &(val)->u.aal1))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_NewATMVCIndication_aal_aal5(dec, &(val)->u.aal5))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_JitterIndication_scope(ASN1encoding_t enc, JitterIndication_scope *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelNumber - 1))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.resourceID))
	    return 0;
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_JitterIndication_scope(ASN1decoding_t dec, JitterIndication_scope *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelNumber))
	    return 0;
	(val)->u.logicalChannelNumber += 1;
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.resourceID))
	    return 0;
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_FunctionNotSupported_cause(ASN1encoding_t enc, FunctionNotSupported_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FunctionNotSupported_cause(ASN1decoding_t dec, FunctionNotSupported_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration_h223AnnexADoubleFlag(ASN1encoding_t enc, H223MultiplexReconfiguration_h223AnnexADoubleFlag *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration_h223AnnexADoubleFlag(ASN1decoding_t dec, H223MultiplexReconfiguration_h223AnnexADoubleFlag *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration_h223ModeChange(ASN1encoding_t enc, H223MultiplexReconfiguration_h223ModeChange *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration_h223ModeChange(ASN1decoding_t dec, H223MultiplexReconfiguration_h223ModeChange *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_EndSessionCommand_isdnOptions(ASN1encoding_t enc, EndSessionCommand_isdnOptions *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EndSessionCommand_isdnOptions(ASN1decoding_t dec, EndSessionCommand_isdnOptions *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_EndSessionCommand_gstnOptions(ASN1encoding_t enc, EndSessionCommand_gstnOptions *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EndSessionCommand_gstnOptions(ASN1decoding_t dec, EndSessionCommand_gstnOptions *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_FlowControlCommand_restriction(ASN1encoding_t enc, FlowControlCommand_restriction *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	l = ASN1uint32_uoctets((val)->u.maximumBitRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->u.maximumBitRate))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_FlowControlCommand_restriction(ASN1decoding_t dec, FlowControlCommand_restriction *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->u.maximumBitRate))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_FlowControlCommand_scope(ASN1encoding_t enc, FlowControlCommand_scope *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelNumber - 1))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.resourceID))
	    return 0;
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_FlowControlCommand_scope(ASN1decoding_t dec, FlowControlCommand_scope *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelNumber))
	    return 0;
	(val)->u.logicalChannelNumber += 1;
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.resourceID))
	    return 0;
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest(ASN1encoding_t enc, SendTerminalCapabilitySet_specificRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multiplexCapability))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(enc, &(val)->capabilityTableEntryNumbers))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(enc, &(val)->capabilityDescriptorNumbers))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest(ASN1decoding_t dec, SendTerminalCapabilitySet_specificRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multiplexCapability))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(dec, &(val)->capabilityTableEntryNumbers))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(dec, &(val)->capabilityDescriptorNumbers))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest(SendTerminalCapabilitySet_specificRequest *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(&(val)->capabilityTableEntryNumbers);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(&(val)->capabilityDescriptorNumbers);
	}
    }
}

static int ASN1CALL ASN1Enc_RemoteMCResponse_reject(ASN1encoding_t enc, RemoteMCResponse_reject *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteMCResponse_reject(ASN1decoding_t dec, RemoteMCResponse_reject *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceResponse_sendThisSourceResponse(ASN1encoding_t enc, ConferenceResponse_sendThisSourceResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_sendThisSourceResponse(ASN1decoding_t dec, ConferenceResponse_sendThisSourceResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceResponse_makeTerminalBroadcasterResponse(ASN1encoding_t enc, ConferenceResponse_makeTerminalBroadcasterResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_makeTerminalBroadcasterResponse(ASN1decoding_t dec, ConferenceResponse_makeTerminalBroadcasterResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceResponse_broadcastMyLogicalChannelResponse(ASN1encoding_t enc, ConferenceResponse_broadcastMyLogicalChannelResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_broadcastMyLogicalChannelResponse(ASN1decoding_t dec, ConferenceResponse_broadcastMyLogicalChannelResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceResponse_extensionAddressResponse(ASN1encoding_t enc, ConferenceResponse_extensionAddressResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->extensionAddress, 1, 128, 7))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_extensionAddressResponse(ASN1decoding_t dec, ConferenceResponse_extensionAddressResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->extensionAddress, 1, 128, 7))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_extensionAddressResponse(ConferenceResponse_extensionAddressResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_makeMeChairResponse(ASN1encoding_t enc, ConferenceResponse_makeMeChairResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_makeMeChairResponse(ASN1decoding_t dec, ConferenceResponse_makeMeChairResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopReject_cause(ASN1encoding_t enc, MaintenanceLoopReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopReject_cause(ASN1decoding_t dec, MaintenanceLoopReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopReject_type(ASN1encoding_t enc, MaintenanceLoopReject_type *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.mediaLoop - 1))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelLoop - 1))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopReject_type(ASN1decoding_t dec, MaintenanceLoopReject_type *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.mediaLoop))
	    return 0;
	(val)->u.mediaLoop += 1;
	break;
    case 3:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelLoop))
	    return 0;
	(val)->u.logicalChannelLoop += 1;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopAck_type(ASN1encoding_t enc, MaintenanceLoopAck_type *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.mediaLoop - 1))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelLoop - 1))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopAck_type(ASN1decoding_t dec, MaintenanceLoopAck_type *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.mediaLoop))
	    return 0;
	(val)->u.mediaLoop += 1;
	break;
    case 3:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelLoop))
	    return 0;
	(val)->u.logicalChannelLoop += 1;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopRequest_type(ASN1encoding_t enc, MaintenanceLoopRequest_type *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.mediaLoop - 1))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelLoop - 1))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopRequest_type(ASN1decoding_t dec, MaintenanceLoopRequest_type *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.mediaLoop))
	    return 0;
	(val)->u.mediaLoop += 1;
	break;
    case 3:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelLoop))
	    return 0;
	(val)->u.logicalChannelLoop += 1;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_G7231AnnexCMode_g723AnnexCAudioMode(ASN1encoding_t enc, G7231AnnexCMode_g723AnnexCAudioMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->highRateMode0 - 27))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->highRateMode1 - 27))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->lowRateMode0 - 23))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->lowRateMode1 - 23))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->sidMode0 - 6))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->sidMode1 - 6))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_G7231AnnexCMode_g723AnnexCAudioMode(ASN1decoding_t dec, G7231AnnexCMode_g723AnnexCAudioMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->highRateMode0))
	return 0;
    (val)->highRateMode0 += 27;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->highRateMode1))
	return 0;
    (val)->highRateMode1 += 27;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->lowRateMode0))
	return 0;
    (val)->lowRateMode0 += 23;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->lowRateMode1))
	return 0;
    (val)->lowRateMode1 += 23;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->sidMode0))
	return 0;
    (val)->sidMode0 += 6;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->sidMode1))
	return 0;
    (val)->sidMode1 += 6;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioMode_multichannelType(ASN1encoding_t enc, IS13818AudioMode_multichannelType *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioMode_multichannelType(ASN1decoding_t dec, IS13818AudioMode_multichannelType *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioMode_audioSampling(ASN1encoding_t enc, IS13818AudioMode_audioSampling *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioMode_audioSampling(ASN1decoding_t dec, IS13818AudioMode_audioSampling *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioMode_audioLayer(ASN1encoding_t enc, IS13818AudioMode_audioLayer *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioMode_audioLayer(ASN1decoding_t dec, IS13818AudioMode_audioLayer *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioMode_multichannelType(ASN1encoding_t enc, IS11172AudioMode_multichannelType *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioMode_multichannelType(ASN1decoding_t dec, IS11172AudioMode_multichannelType *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioMode_audioSampling(ASN1encoding_t enc, IS11172AudioMode_audioSampling *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioMode_audioSampling(ASN1decoding_t dec, IS11172AudioMode_audioSampling *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioMode_audioLayer(ASN1encoding_t enc, IS11172AudioMode_audioLayer *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioMode_audioLayer(ASN1decoding_t dec, IS11172AudioMode_audioLayer *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_AudioMode_g7231(ASN1encoding_t enc, AudioMode_g7231 *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AudioMode_g7231(ASN1decoding_t dec, AudioMode_g7231 *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H263VideoMode_resolution(ASN1encoding_t enc, H263VideoMode_resolution *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263VideoMode_resolution(ASN1decoding_t dec, H263VideoMode_resolution *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H262VideoMode_profileAndLevel(ASN1encoding_t enc, H262VideoMode_profileAndLevel *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H262VideoMode_profileAndLevel(ASN1decoding_t dec, H262VideoMode_profileAndLevel *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H261VideoMode_resolution(ASN1encoding_t enc, H261VideoMode_resolution *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H261VideoMode_resolution(ASN1decoding_t dec, H261VideoMode_resolution *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestModeReject_cause(ASN1encoding_t enc, RequestModeReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeReject_cause(ASN1decoding_t dec, RequestModeReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestModeAck_response(ASN1encoding_t enc, RequestModeAck_response *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeAck_response(ASN1decoding_t dec, RequestModeAck_response *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryRelease_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryRelease_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryRelease_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryRelease_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryRelease_entryNumbers(RequestMultiplexEntryRelease_entryNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryRejectionDescriptions_cause(ASN1encoding_t enc, RequestMultiplexEntryRejectionDescriptions_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryRejectionDescriptions_cause(ASN1decoding_t dec, RequestMultiplexEntryRejectionDescriptions_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryReject_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryReject_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryReject_entryNumbers(RequestMultiplexEntryReject_entryNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryAck_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryAck_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryAck_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryAck_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryAck_entryNumbers(RequestMultiplexEntryAck_entryNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntry_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntry_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntry_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntry_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntry_entryNumbers(RequestMultiplexEntry_entryNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendRelease_multiplexTableEntryNumber(ASN1encoding_t enc, MultiplexEntrySendRelease_multiplexTableEntryNumber *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendRelease_multiplexTableEntryNumber(ASN1decoding_t dec, MultiplexEntrySendRelease_multiplexTableEntryNumber *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendRelease_multiplexTableEntryNumber(MultiplexEntrySendRelease_multiplexTableEntryNumber *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntryRejectionDescriptions_cause(ASN1encoding_t enc, MultiplexEntryRejectionDescriptions_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntryRejectionDescriptions_cause(ASN1decoding_t dec, MultiplexEntryRejectionDescriptions_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendAck_multiplexTableEntryNumber(ASN1encoding_t enc, MultiplexEntrySendAck_multiplexTableEntryNumber *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendAck_multiplexTableEntryNumber(ASN1decoding_t dec, MultiplexEntrySendAck_multiplexTableEntryNumber *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendAck_multiplexTableEntryNumber(MultiplexEntrySendAck_multiplexTableEntryNumber *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexElement_repeatCount(ASN1encoding_t enc, MultiplexElement_repeatCount *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.finite - 1))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexElement_repeatCount(ASN1decoding_t dec, MultiplexElement_repeatCount *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.finite))
	    return 0;
	(val)->u.finite += 1;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MultiplexElement_type(ASN1encoding_t enc, MultiplexElement_type *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MultiplexElement_type_subElementList(enc, &(val)->u.subElementList))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexElement_type(ASN1decoding_t dec, MultiplexElement_type *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MultiplexElement_type_subElementList(dec, &(val)->u.subElementList))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexElement_type(MultiplexElement_type *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_MultiplexElement_type_subElementList(&(val)->u.subElementList);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RequestChannelCloseReject_cause(ASN1encoding_t enc, RequestChannelCloseReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelCloseReject_cause(ASN1decoding_t dec, RequestChannelCloseReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestChannelClose_reason(ASN1encoding_t enc, RequestChannelClose_reason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelClose_reason(ASN1decoding_t dec, RequestChannelClose_reason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CloseLogicalChannel_reason(ASN1encoding_t enc, CloseLogicalChannel_reason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CloseLogicalChannel_reason(ASN1decoding_t dec, CloseLogicalChannel_reason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CloseLogicalChannel_source(ASN1encoding_t enc, CloseLogicalChannel_source *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CloseLogicalChannel_source(ASN1decoding_t dec, CloseLogicalChannel_source *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelReject_cause(ASN1encoding_t enc, OpenLogicalChannelReject_cause *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 6))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelReject_cause(ASN1decoding_t dec, OpenLogicalChannelReject_cause *val)
{
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 6))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MulticastAddress_iP6Address(ASN1encoding_t enc, MulticastAddress_iP6Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 16))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MulticastAddress_iP6Address(ASN1decoding_t dec, MulticastAddress_iP6Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 16))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MulticastAddress_iP6Address(MulticastAddress_iP6Address *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MulticastAddress_iPAddress(ASN1encoding_t enc, MulticastAddress_iPAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MulticastAddress_iPAddress(ASN1decoding_t dec, MulticastAddress_iPAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MulticastAddress_iPAddress(MulticastAddress_iPAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress(ASN1encoding_t enc, UnicastAddress_iPSourceRouteAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_UnicastAddress_iPSourceRouteAddress_routing(enc, &(val)->routing))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
	return 0;
    if (!ASN1Enc_UnicastAddress_iPSourceRouteAddress_route(enc, &(val)->route))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress(ASN1decoding_t dec, UnicastAddress_iPSourceRouteAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_UnicastAddress_iPSourceRouteAddress_routing(dec, &(val)->routing))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
	return 0;
    if (!ASN1Dec_UnicastAddress_iPSourceRouteAddress_route(dec, &(val)->route))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress(UnicastAddress_iPSourceRouteAddress *val)
{
    if (val) {
	ASN1Free_UnicastAddress_iPSourceRouteAddress_route(&(val)->route);
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iP6Address(ASN1encoding_t enc, UnicastAddress_iP6Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 16))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iP6Address(ASN1decoding_t dec, UnicastAddress_iP6Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 16))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iP6Address(UnicastAddress_iP6Address *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPXAddress(ASN1encoding_t enc, UnicastAddress_iPXAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->node, 6))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->netnum, 4))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->tsapIdentifier, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPXAddress(ASN1decoding_t dec, UnicastAddress_iPXAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->node, 6))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->netnum, 4))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->tsapIdentifier, 2))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iPXAddress(UnicastAddress_iPXAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPAddress(ASN1encoding_t enc, UnicastAddress_iPAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPAddress(ASN1decoding_t dec, UnicastAddress_iPAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iPAddress(UnicastAddress_iPAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode(ASN1encoding_t enc, V76LogicalChannelParameters_mode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_V76LogicalChannelParameters_mode_eRM(enc, &(val)->u.eRM))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode(ASN1decoding_t dec, V76LogicalChannelParameters_mode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_V76LogicalChannelParameters_mode_eRM(dec, &(val)->u.eRM))
	    return 0;
	break;
    case 2:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_suspendResume(ASN1encoding_t enc, V76LogicalChannelParameters_suspendResume *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_suspendResume(ASN1decoding_t dec, V76LogicalChannelParameters_suspendResume *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AnnexCArqParameters_numberOfRetransmissions(ASN1encoding_t enc, H223AnnexCArqParameters_numberOfRetransmissions *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncBitVal(enc, 5, (val)->u.finite))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexCArqParameters_numberOfRetransmissions(ASN1decoding_t dec, H223AnnexCArqParameters_numberOfRetransmissions *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU16Val(dec, 5, &(val)->u.finite))
	    return 0;
	break;
    case 2:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL3MParameters_crcLength(ASN1encoding_t enc, H223AL3MParameters_crcLength *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL3MParameters_crcLength(ASN1decoding_t dec, H223AL3MParameters_crcLength *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL3MParameters_headerFormat(ASN1encoding_t enc, H223AL3MParameters_headerFormat *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL3MParameters_headerFormat(ASN1decoding_t dec, H223AL3MParameters_headerFormat *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL2MParameters_headerFEC(ASN1encoding_t enc, H223AL2MParameters_headerFEC *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL2MParameters_headerFEC(ASN1decoding_t dec, H223AL2MParameters_headerFEC *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL1MParameters_crcLength(ASN1encoding_t enc, H223AL1MParameters_crcLength *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL1MParameters_crcLength(ASN1decoding_t dec, H223AL1MParameters_crcLength *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL1MParameters_headerFEC(ASN1encoding_t enc, H223AL1MParameters_headerFEC *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL1MParameters_headerFEC(ASN1decoding_t dec, H223AL1MParameters_headerFEC *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL1MParameters_transferMode(ASN1encoding_t enc, H223AL1MParameters_transferMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL1MParameters_transferMode(ASN1decoding_t dec, H223AL1MParameters_transferMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static ASN1stringtableentry_t Q2931Address_address_internationalNumber_StringTableEntries[] = {
    { 32, 32, 0 }, { 48, 57, 1 }, 
};

static ASN1stringtable_t Q2931Address_address_internationalNumber_StringTable = {
    2, Q2931Address_address_internationalNumber_StringTableEntries
};

static int ASN1CALL ASN1Enc_Q2931Address_address(ASN1encoding_t enc, Q2931Address_address *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	t = lstrlenA((val)->u.internationalNumber);
	if (!ASN1PEREncBitVal(enc, 4, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.internationalNumber, 4, &Q2931Address_address_internationalNumber_StringTable))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->u.nsapAddress, 1, 20, 5))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Q2931Address_address(ASN1decoding_t dec, Q2931Address_address *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU32Val(dec, 4, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.internationalNumber, 4, &Q2931Address_address_internationalNumber_StringTable))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->u.nsapAddress, 1, 20, 5))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Q2931Address_address(Q2931Address_address *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    break;
	case 2:
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_NetworkAccessParameters_t120SetupProcedure(ASN1encoding_t enc, NetworkAccessParameters_t120SetupProcedure *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NetworkAccessParameters_t120SetupProcedure(ASN1decoding_t dec, NetworkAccessParameters_t120SetupProcedure *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NetworkAccessParameters_distribution(ASN1encoding_t enc, NetworkAccessParameters_distribution *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NetworkAccessParameters_distribution(ASN1decoding_t dec, NetworkAccessParameters_distribution *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_T84Profile_t84Restricted(ASN1encoding_t enc, T84Profile_t84Restricted *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->qcif))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->cif))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->ccir601Seq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->ccir601Prog))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->hdtvSeq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->hdtvProg))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->g3FacsMH200x100))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->g3FacsMH200x200))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->g4FacsMMR200x100))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->g4FacsMMR200x200))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->jbig200x200Seq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->jbig200x200Prog))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->jbig300x300Seq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->jbig300x300Prog))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoLow))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoMedSeq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoMedProg))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoHighSeq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoHighProg))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_T84Profile_t84Restricted(ASN1decoding_t dec, T84Profile_t84Restricted *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->qcif))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->cif))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->ccir601Seq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->ccir601Prog))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->hdtvSeq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->hdtvProg))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->g3FacsMH200x100))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->g3FacsMH200x200))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->g4FacsMMR200x100))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->g4FacsMMR200x200))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->jbig200x200Seq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->jbig200x200Prog))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->jbig300x300Seq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->jbig300x300Prog))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoLow))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoMedSeq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoMedProg))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoHighSeq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoHighProg))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_G7231AnnexCCapability_g723AnnexCAudioMode(ASN1encoding_t enc, G7231AnnexCCapability_g723AnnexCAudioMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->highRateMode0 - 27))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->highRateMode1 - 27))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->lowRateMode0 - 23))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->lowRateMode1 - 23))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->sidMode0 - 6))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->sidMode1 - 6))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_G7231AnnexCCapability_g723AnnexCAudioMode(ASN1decoding_t dec, G7231AnnexCCapability_g723AnnexCAudioMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->highRateMode0))
	return 0;
    (val)->highRateMode0 += 27;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->highRateMode1))
	return 0;
    (val)->highRateMode1 += 27;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->lowRateMode0))
	return 0;
    (val)->lowRateMode0 += 23;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->lowRateMode1))
	return 0;
    (val)->lowRateMode1 += 23;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->sidMode0))
	return 0;
    (val)->sidMode0 += 6;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->sidMode1))
	return 0;
    (val)->sidMode1 += 6;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_AudioCapability_g7231(ASN1encoding_t enc, AudioCapability_g7231 *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->maxAl_sduAudioFrames - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->silenceSuppression))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AudioCapability_g7231(ASN1decoding_t dec, AudioCapability_g7231 *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maxAl_sduAudioFrames))
	return 0;
    (val)->maxAl_sduAudioFrames += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->silenceSuppression))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncBoolean(enc, (val)->u.anyPixelAspectRatio))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(enc, &(val)->u.pixelAspectCode))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR(enc, &(val)->u.extendedPAR))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecBoolean(dec, &(val)->u.anyPixelAspectRatio))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(dec, &(val)->u.pixelAspectCode))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR(dec, &(val)->u.extendedPAR))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation(CustomPictureFormat_pixelAspectInformation *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(&(val)->u.pixelAspectCode);
	    break;
	case 3:
	    ASN1Free_CustomPictureFormat_pixelAspectInformation_extendedPAR(&(val)->u.extendedPAR);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI(ASN1encoding_t enc, CustomPictureFormat_mPI *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->standardMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_CustomPictureFormat_mPI_customPCF(enc, &(val)->customPCF))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI(ASN1decoding_t dec, CustomPictureFormat_mPI *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->standardMPI))
	    return 0;
	(val)->standardMPI += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_CustomPictureFormat_mPI_customPCF(dec, &(val)->customPCF))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat_mPI(CustomPictureFormat_mPI *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1Free_CustomPictureFormat_mPI_customPCF(&(val)->customPCF);
	}
    }
}

static int ASN1CALL ASN1Enc_RefPictureSelection_videoBackChannelSend(ASN1encoding_t enc, RefPictureSelection_videoBackChannelSend *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RefPictureSelection_videoBackChannelSend(ASN1decoding_t dec, RefPictureSelection_videoBackChannelSend *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RefPictureSelection_additionalPictureMemory(ASN1encoding_t enc, RefPictureSelection_additionalPictureMemory *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->sqcifAdditionalPictureMemory - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->qcifAdditionalPictureMemory - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->cifAdditionalPictureMemory - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->cif4AdditionalPictureMemory - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->cif16AdditionalPictureMemory - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->bigCpfAdditionalPictureMemory - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RefPictureSelection_additionalPictureMemory(ASN1decoding_t dec, RefPictureSelection_additionalPictureMemory *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->sqcifAdditionalPictureMemory))
	    return 0;
	(val)->sqcifAdditionalPictureMemory += 1;
    }
    if ((val)->o[0] & 0x40) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->qcifAdditionalPictureMemory))
	    return 0;
	(val)->qcifAdditionalPictureMemory += 1;
    }
    if ((val)->o[0] & 0x20) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->cifAdditionalPictureMemory))
	    return 0;
	(val)->cifAdditionalPictureMemory += 1;
    }
    if ((val)->o[0] & 0x10) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->cif4AdditionalPictureMemory))
	    return 0;
	(val)->cif4AdditionalPictureMemory += 1;
    }
    if ((val)->o[0] & 0x8) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->cif16AdditionalPictureMemory))
	    return 0;
	(val)->cif16AdditionalPictureMemory += 1;
    }
    if ((val)->o[0] & 0x4) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->bigCpfAdditionalPictureMemory))
	    return 0;
	(val)->bigCpfAdditionalPictureMemory += 1;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyFrameMapping_frameSequence(ASN1encoding_t enc, RTPH263VideoRedundancyFrameMapping_frameSequence *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyFrameMapping_frameSequence(ASN1decoding_t dec, RTPH263VideoRedundancyFrameMapping_frameSequence *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyFrameMapping_frameSequence(RTPH263VideoRedundancyFrameMapping_frameSequence *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_containedThreads(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding_containedThreads *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_containedThreads(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding_containedThreads *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_containedThreads(RTPH263VideoRedundancyEncoding_containedThreads *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding_frameToThreadMapping *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(enc, &(val)->u.custom))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding_frameToThreadMapping *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(dec, &(val)->u.custom))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping(RTPH263VideoRedundancyEncoding_frameToThreadMapping *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(&(val)->u.custom);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncodingCapability_secondaryEncoding(ASN1encoding_t enc, PRedundancyEncodingCapability_secondaryEncoding *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RedundancyEncodingCapability_secondaryEncoding_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_RedundancyEncodingCapability_secondaryEncoding_ElmFn(ASN1encoding_t enc, PRedundancyEncodingCapability_secondaryEncoding val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncodingCapability_secondaryEncoding(ASN1decoding_t dec, PRedundancyEncodingCapability_secondaryEncoding *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RedundancyEncodingCapability_secondaryEncoding_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_RedundancyEncodingCapability_secondaryEncoding_ElmFn(ASN1decoding_t dec, PRedundancyEncodingCapability_secondaryEncoding val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1;
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncodingCapability_secondaryEncoding(PRedundancyEncodingCapability_secondaryEncoding *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RedundancyEncodingCapability_secondaryEncoding_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RedundancyEncodingCapability_secondaryEncoding_ElmFn(PRedundancyEncodingCapability_secondaryEncoding val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_H2250Capability_mcCapability(ASN1encoding_t enc, H2250Capability_mcCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->centralizedConferenceMC))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->decentralizedConferenceMC))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250Capability_mcCapability(ASN1decoding_t dec, H2250Capability_mcCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->centralizedConferenceMC))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->decentralizedConferenceMC))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223Capability_mobileOperationTransmitCapability(ASN1encoding_t enc, H223Capability_mobileOperationTransmitCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->modeChangeCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->h223AnnexA))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->h223AnnexADoubleFlag))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->h223AnnexB))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->h223AnnexBwithHeader))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223Capability_mobileOperationTransmitCapability(ASN1decoding_t dec, H223Capability_mobileOperationTransmitCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->modeChangeCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->h223AnnexA))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->h223AnnexADoubleFlag))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->h223AnnexB))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->h223AnnexBwithHeader))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223Capability_h223MultiplexTableCapability(ASN1encoding_t enc, H223Capability_h223MultiplexTableCapability *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_H223Capability_h223MultiplexTableCapability_enhanced(enc, &(val)->u.enhanced))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223Capability_h223MultiplexTableCapability(ASN1decoding_t dec, H223Capability_h223MultiplexTableCapability *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_H223Capability_h223MultiplexTableCapability_enhanced(dec, &(val)->u.enhanced))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_availableBitRates(ASN1encoding_t enc, VCCapability_availableBitRates *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_VCCapability_availableBitRates_type(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_availableBitRates(ASN1decoding_t dec, VCCapability_availableBitRates *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_VCCapability_availableBitRates_type(dec, &(val)->type))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_aal5(ASN1encoding_t enc, VCCapability_aal5 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardMaximumSDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->backwardMaximumSDUSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_aal5(ASN1decoding_t dec, VCCapability_aal5 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardMaximumSDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->backwardMaximumSDUSize))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_aal1(ASN1encoding_t enc, VCCapability_aal1 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->nullClockRecovery))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->srtsClockRecovery))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->adaptiveClockRecovery))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->nullErrorCorrection))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->longInterleaver))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->shortInterleaver))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->errorCorrectionOnly))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->structuredDataTransfer))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->partiallyFilledCells))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_aal1(ASN1decoding_t dec, VCCapability_aal1 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->nullClockRecovery))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->srtsClockRecovery))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->adaptiveClockRecovery))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->nullErrorCorrection))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->longInterleaver))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->shortInterleaver))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->errorCorrectionOnly))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->structuredDataTransfer))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->partiallyFilledCells))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_Capability_h233EncryptionReceiveCapability(ASN1encoding_t enc, Capability_h233EncryptionReceiveCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->h233IVResponseTime))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Capability_h233EncryptionReceiveCapability(ASN1decoding_t dec, Capability_h233EncryptionReceiveCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->h233IVResponseTime))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject_cause(ASN1encoding_t enc, TerminalCapabilitySetReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Enc_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(enc, &(val)->u.tableEntryCapacityExceeded))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject_cause(ASN1decoding_t dec, TerminalCapabilitySetReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Dec_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(dec, &(val)->u.tableEntryCapacityExceeded))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationReject_cause(ASN1encoding_t enc, MasterSlaveDeterminationReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationReject_cause(ASN1decoding_t dec, MasterSlaveDeterminationReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationAck_decision(ASN1encoding_t enc, MasterSlaveDeterminationAck_decision *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationAck_decision(ASN1decoding_t dec, MasterSlaveDeterminationAck_decision *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NonStandardIdentifier_h221NonStandard(ASN1encoding_t enc, NonStandardIdentifier_h221NonStandard *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35CountryCode))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35Extension))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->manufacturerCode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardIdentifier_h221NonStandard(ASN1decoding_t dec, NonStandardIdentifier_h221NonStandard *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35CountryCode))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35Extension))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->manufacturerCode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NonStandardIdentifier(ASN1encoding_t enc, NonStandardIdentifier *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_NonStandardIdentifier_h221NonStandard(enc, &(val)->u.h221NonStandard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardIdentifier(ASN1decoding_t dec, NonStandardIdentifier *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_NonStandardIdentifier_h221NonStandard(dec, &(val)->u.h221NonStandard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardIdentifier(NonStandardIdentifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1objectidentifier_free(&(val)->u.object);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MasterSlaveDetermination(ASN1encoding_t enc, MasterSlaveDetermination *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->terminalType))
	return 0;
    l = ASN1uint32_uoctets((val)->statusDeterminationNumber);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->statusDeterminationNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDetermination(ASN1decoding_t dec, MasterSlaveDetermination *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->terminalType))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->statusDeterminationNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationAck(ASN1encoding_t enc, MasterSlaveDeterminationAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MasterSlaveDeterminationAck_decision(enc, &(val)->decision))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationAck(ASN1decoding_t dec, MasterSlaveDeterminationAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MasterSlaveDeterminationAck_decision(dec, &(val)->decision))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationReject(ASN1encoding_t enc, MasterSlaveDeterminationReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MasterSlaveDeterminationReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationReject(ASN1decoding_t dec, MasterSlaveDeterminationReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MasterSlaveDeterminationReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationRelease(ASN1encoding_t enc, MasterSlaveDeterminationRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationRelease(ASN1decoding_t dec, MasterSlaveDeterminationRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CapabilityDescriptor(ASN1encoding_t enc, CapabilityDescriptor *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->capabilityDescriptorNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CapabilityDescriptor_simultaneousCapabilities(enc, &(val)->simultaneousCapabilities))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CapabilityDescriptor(ASN1decoding_t dec, CapabilityDescriptor *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->capabilityDescriptorNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CapabilityDescriptor_simultaneousCapabilities(dec, &(val)->simultaneousCapabilities))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CapabilityDescriptor(CapabilityDescriptor *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CapabilityDescriptor_simultaneousCapabilities(&(val)->simultaneousCapabilities);
	}
    }
}

static int ASN1CALL ASN1Enc_AlternativeCapabilitySet(ASN1encoding_t enc, AlternativeCapabilitySet *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncUnsignedShort(enc, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AlternativeCapabilitySet(ASN1decoding_t dec, AlternativeCapabilitySet *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecUnsignedShort(dec, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AlternativeCapabilitySet(AlternativeCapabilitySet *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetAck(ASN1encoding_t enc, TerminalCapabilitySetAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetAck(ASN1decoding_t dec, TerminalCapabilitySetAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject(ASN1encoding_t enc, TerminalCapabilitySetReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_TerminalCapabilitySetReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject(ASN1decoding_t dec, TerminalCapabilitySetReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_TerminalCapabilitySetReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetRelease(ASN1encoding_t enc, TerminalCapabilitySetRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetRelease(ASN1decoding_t dec, TerminalCapabilitySetRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H222Capability(ASN1encoding_t enc, H222Capability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->numberOfVCs - 1))
	return 0;
    if (!ASN1Enc_H222Capability_vcCapability(enc, &(val)->vcCapability))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H222Capability(ASN1decoding_t dec, H222Capability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->numberOfVCs))
	return 0;
    (val)->numberOfVCs += 1;
    if (!ASN1Dec_H222Capability_vcCapability(dec, &(val)->vcCapability))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H222Capability(H222Capability *val)
{
    if (val) {
	ASN1Free_H222Capability_vcCapability(&(val)->vcCapability);
    }
}

static int ASN1CALL ASN1Enc_VCCapability(ASN1encoding_t enc, VCCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_VCCapability_aal1(enc, &(val)->aal1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_VCCapability_aal5(enc, &(val)->aal5))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->transportStream))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->programStream))
	return 0;
    if (!ASN1Enc_VCCapability_availableBitRates(enc, &(val)->availableBitRates))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability(ASN1decoding_t dec, VCCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_VCCapability_aal1(dec, &(val)->aal1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_VCCapability_aal5(dec, &(val)->aal5))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->transportStream))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->programStream))
	return 0;
    if (!ASN1Dec_VCCapability_availableBitRates(dec, &(val)->availableBitRates))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AnnexCCapability(ASN1encoding_t enc, H223AnnexCCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL1M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL2M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL3M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL1M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL2M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL3M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL1M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL2M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL3M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alpduInterleaving))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAL1MPDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAL2MSDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAL3MSDUSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexCCapability(ASN1decoding_t dec, H223AnnexCCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL1M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL2M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL3M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL1M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL2M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL3M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL1M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL2M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL3M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alpduInterleaving))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAL1MPDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAL2MSDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAL3MSDUSize))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V75Capability(ASN1encoding_t enc, V75Capability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioHeader))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V75Capability(ASN1decoding_t dec, V75Capability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioHeader))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_QOSMode(ASN1encoding_t enc, QOSMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_QOSMode(ASN1decoding_t dec, QOSMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ATMParameters(ASN1encoding_t enc, ATMParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maxNTUSize))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->atmUBR))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->atmrtVBR))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->atmnrtVBR))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->atmABR))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->atmCBR))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ATMParameters(ASN1decoding_t dec, ATMParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maxNTUSize))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->atmUBR))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->atmrtVBR))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->atmnrtVBR))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->atmABR))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->atmCBR))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MediaTransportType(ASN1encoding_t enc, MediaTransportType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MediaTransportType(ASN1decoding_t dec, MediaTransportType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MediaChannelCapability(ASN1encoding_t enc, MediaChannelCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_MediaTransportType(enc, &(val)->mediaTransport))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MediaChannelCapability(ASN1decoding_t dec, MediaChannelCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_MediaTransportType(dec, &(val)->mediaTransport))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->numberOfThreads - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->framesBetweenSyncPoints - 1))
	return 0;
    if (!ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping(enc, &(val)->frameToThreadMapping))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_RTPH263VideoRedundancyEncoding_containedThreads(enc, &(val)->containedThreads))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->numberOfThreads))
	return 0;
    (val)->numberOfThreads += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->framesBetweenSyncPoints))
	return 0;
    (val)->framesBetweenSyncPoints += 1;
    if (!ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping(dec, &(val)->frameToThreadMapping))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_RTPH263VideoRedundancyEncoding_containedThreads(dec, &(val)->containedThreads))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding(RTPH263VideoRedundancyEncoding *val)
{
    if (val) {
	ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping(&(val)->frameToThreadMapping);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_RTPH263VideoRedundancyEncoding_containedThreads(&(val)->containedThreads);
	}
    }
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyFrameMapping(ASN1encoding_t enc, RTPH263VideoRedundancyFrameMapping *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->threadNumber))
	return 0;
    if (!ASN1Enc_RTPH263VideoRedundancyFrameMapping_frameSequence(enc, &(val)->frameSequence))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyFrameMapping(ASN1decoding_t dec, RTPH263VideoRedundancyFrameMapping *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->threadNumber))
	return 0;
    if (!ASN1Dec_RTPH263VideoRedundancyFrameMapping_frameSequence(dec, &(val)->frameSequence))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyFrameMapping(RTPH263VideoRedundancyFrameMapping *val)
{
    if (val) {
	ASN1Free_RTPH263VideoRedundancyFrameMapping_frameSequence(&(val)->frameSequence);
    }
}

static int ASN1CALL ASN1Enc_MultipointCapability(ASN1encoding_t enc, MultipointCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multicastCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multiUniCastConference))
	return 0;
    if (!ASN1Enc_MultipointCapability_mediaDistributionCapability(enc, &(val)->mediaDistributionCapability))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultipointCapability(ASN1decoding_t dec, MultipointCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multicastCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multiUniCastConference))
	return 0;
    if (!ASN1Dec_MultipointCapability_mediaDistributionCapability(dec, &(val)->mediaDistributionCapability))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultipointCapability(MultipointCapability *val)
{
    if (val) {
	ASN1Free_MultipointCapability_mediaDistributionCapability(&(val)->mediaDistributionCapability);
    }
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability(ASN1encoding_t enc, MediaDistributionCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->centralizedControl))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->distributedControl))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->centralizedAudio))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->distributedAudio))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->centralizedVideo))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->distributedVideo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_MediaDistributionCapability_centralizedData(enc, &(val)->centralizedData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_MediaDistributionCapability_distributedData(enc, &(val)->distributedData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability(ASN1decoding_t dec, MediaDistributionCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->centralizedControl))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->distributedControl))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->centralizedAudio))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->distributedAudio))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->centralizedVideo))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->distributedVideo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_MediaDistributionCapability_centralizedData(dec, &(val)->centralizedData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_MediaDistributionCapability_distributedData(dec, &(val)->distributedData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MediaDistributionCapability(MediaDistributionCapability *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_MediaDistributionCapability_centralizedData(&(val)->centralizedData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_MediaDistributionCapability_distributedData(&(val)->distributedData);
	}
    }
}

static int ASN1CALL ASN1Enc_H261VideoCapability(ASN1encoding_t enc, H261VideoCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 2, (val)->qcifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 2, (val)->cifMPI - 1))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->temporalSpatialTradeOffCapability))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maxBitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->stillImageTransmission))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H261VideoCapability(ASN1decoding_t dec, H261VideoCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 2, &(val)->qcifMPI))
	    return 0;
	(val)->qcifMPI += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU16Val(dec, 2, &(val)->cifMPI))
	    return 0;
	(val)->cifMPI += 1;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->temporalSpatialTradeOffCapability))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maxBitRate))
	return 0;
    (val)->maxBitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->stillImageTransmission))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H262VideoCapability(ASN1encoding_t enc, H262VideoCapability *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_SPatML))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_MPatLL))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_MPatML))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_MPatH_14))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_MPatHL))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_SNRatLL))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_SNRatML))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_SpatialatH_14))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_HPatML))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_HPatH_14))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_HPatHL))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->videoBitRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->vbvBufferSize);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 4, (val)->framesPerSecond))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	l = ASN1uint32_uoctets((val)->luminanceSampleRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->luminanceSampleRate))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H262VideoCapability(ASN1decoding_t dec, H262VideoCapability *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_SPatML))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_MPatLL))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_MPatML))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_MPatH_14))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_MPatHL))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_SNRatLL))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_SNRatML))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_SpatialatH_14))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_HPatML))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_HPatH_14))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_HPatHL))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 4, &(val)->framesPerSecond))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->luminanceSampleRate))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo(ASN1encoding_t enc, EnhancementLayerInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->baseBitRateConstrained))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_EnhancementLayerInfo_snrEnhancement(enc, &(val)->snrEnhancement))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_EnhancementLayerInfo_spatialEnhancement(enc, &(val)->spatialEnhancement))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_EnhancementLayerInfo_bPictureEnhancement(enc, &(val)->bPictureEnhancement))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo(ASN1decoding_t dec, EnhancementLayerInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->baseBitRateConstrained))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_EnhancementLayerInfo_snrEnhancement(dec, &(val)->snrEnhancement))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_EnhancementLayerInfo_spatialEnhancement(dec, &(val)->spatialEnhancement))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_EnhancementLayerInfo_bPictureEnhancement(dec, &(val)->bPictureEnhancement))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo(EnhancementLayerInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_EnhancementLayerInfo_snrEnhancement(&(val)->snrEnhancement);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_EnhancementLayerInfo_spatialEnhancement(&(val)->spatialEnhancement);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_EnhancementLayerInfo_bPictureEnhancement(&(val)->bPictureEnhancement);
	}
    }
}

static int ASN1CALL ASN1Enc_TransparencyParameters(ASN1encoding_t enc, TransparencyParameters *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->presentationOrder - 1))
	return 0;
    l = ASN1uint32_uoctets((val)->offset_x + 262144);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->offset_x + 262144))
	return 0;
    l = ASN1uint32_uoctets((val)->offset_y + 262144);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->offset_y + 262144))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->scale_x - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->scale_y - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransparencyParameters(ASN1decoding_t dec, TransparencyParameters *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->presentationOrder))
	return 0;
    (val)->presentationOrder += 1;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->offset_x))
	return 0;
    (val)->offset_x += 0 - 262144;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->offset_y))
	return 0;
    (val)->offset_y += 0 - 262144;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->scale_x))
	return 0;
    (val)->scale_x += 1;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->scale_y))
	return 0;
    (val)->scale_y += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RefPictureSelection(ASN1encoding_t enc, RefPictureSelection *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_RefPictureSelection_additionalPictureMemory(enc, &(val)->additionalPictureMemory))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->videoMux))
	return 0;
    if (!ASN1Enc_RefPictureSelection_videoBackChannelSend(enc, &(val)->videoBackChannelSend))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RefPictureSelection(ASN1decoding_t dec, RefPictureSelection *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_RefPictureSelection_additionalPictureMemory(dec, &(val)->additionalPictureMemory))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->videoMux))
	return 0;
    if (!ASN1Dec_RefPictureSelection_videoBackChannelSend(dec, &(val)->videoBackChannelSend))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureClockFrequency(ASN1encoding_t enc, CustomPictureClockFrequency *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->clockConversionCode - 1000))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->clockDivisor - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->sqcifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->qcifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->cifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->cif4MPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->cif16MPI - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureClockFrequency(ASN1decoding_t dec, CustomPictureClockFrequency *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if (!ASN1PERDecU16Val(dec, 1, &(val)->clockConversionCode))
	return 0;
    (val)->clockConversionCode += 1000;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->clockDivisor))
	return 0;
    (val)->clockDivisor += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->sqcifMPI))
	    return 0;
	(val)->sqcifMPI += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->qcifMPI))
	    return 0;
	(val)->qcifMPI += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->cifMPI))
	    return 0;
	(val)->cifMPI += 1;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->cif4MPI))
	    return 0;
	(val)->cif4MPI += 1;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->cif16MPI))
	    return 0;
	(val)->cif16MPI += 1;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureFormat(ASN1encoding_t enc, CustomPictureFormat *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maxCustomPictureWidth - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maxCustomPictureHeight - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->minCustomPictureWidth - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->minCustomPictureHeight - 1))
	return 0;
    if (!ASN1Enc_CustomPictureFormat_mPI(enc, &(val)->mPI))
	return 0;
    if (!ASN1Enc_CustomPictureFormat_pixelAspectInformation(enc, &(val)->pixelAspectInformation))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat(ASN1decoding_t dec, CustomPictureFormat *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maxCustomPictureWidth))
	return 0;
    (val)->maxCustomPictureWidth += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maxCustomPictureHeight))
	return 0;
    (val)->maxCustomPictureHeight += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->minCustomPictureWidth))
	return 0;
    (val)->minCustomPictureWidth += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->minCustomPictureHeight))
	return 0;
    (val)->minCustomPictureHeight += 1;
    if (!ASN1Dec_CustomPictureFormat_mPI(dec, &(val)->mPI))
	return 0;
    if (!ASN1Dec_CustomPictureFormat_pixelAspectInformation(dec, &(val)->pixelAspectInformation))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat(CustomPictureFormat *val)
{
    if (val) {
	ASN1Free_CustomPictureFormat_mPI(&(val)->mPI);
	ASN1Free_CustomPictureFormat_pixelAspectInformation(&(val)->pixelAspectInformation);
    }
}

static int ASN1CALL ASN1Enc_H263ModeComboFlags(ASN1encoding_t enc, H263ModeComboFlags *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unrestrictedVector))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->arithmeticCoding))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->advancedPrediction))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->pbFrames))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->advancedIntraCodingMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->deblockingFilterMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unlimitedMotionVectors))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesInOrder_NonRect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesInOrder_Rect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesNoOrder_NonRect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesNoOrder_Rect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->improvedPBFramesMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->referencePicSelect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicPictureResizingByFour))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicPictureResizingSixteenthPel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicWarpingHalfPel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicWarpingSixteenthPel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->reducedResolutionUpdate))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->independentSegmentDecoding))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alternateInterVLCMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->modifiedQuantizationMode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263ModeComboFlags(ASN1decoding_t dec, H263ModeComboFlags *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->unrestrictedVector))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->arithmeticCoding))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->advancedPrediction))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->pbFrames))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->advancedIntraCodingMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->deblockingFilterMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->unlimitedMotionVectors))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesInOrder_NonRect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesInOrder_Rect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesNoOrder_NonRect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesNoOrder_Rect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->improvedPBFramesMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->referencePicSelect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicPictureResizingByFour))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicPictureResizingSixteenthPel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicWarpingHalfPel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicWarpingSixteenthPel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->reducedResolutionUpdate))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->independentSegmentDecoding))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alternateInterVLCMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->modifiedQuantizationMode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172VideoCapability(ASN1encoding_t enc, IS11172VideoCapability *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->constrainedBitstream))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->videoBitRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->vbvBufferSize);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 4, (val)->pictureRate))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	l = ASN1uint32_uoctets((val)->luminanceSampleRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->luminanceSampleRate))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172VideoCapability(ASN1decoding_t dec, IS11172VideoCapability *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->constrainedBitstream))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 4, &(val)->pictureRate))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->luminanceSampleRate))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_G7231AnnexCCapability(ASN1encoding_t enc, G7231AnnexCCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->maxAl_sduAudioFrames - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->silenceSuppression))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_G7231AnnexCCapability_g723AnnexCAudioMode(enc, &(val)->g723AnnexCAudioMode))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_G7231AnnexCCapability(ASN1decoding_t dec, G7231AnnexCCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maxAl_sduAudioFrames))
	return 0;
    (val)->maxAl_sduAudioFrames += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->silenceSuppression))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_G7231AnnexCCapability_g723AnnexCAudioMode(dec, &(val)->g723AnnexCAudioMode))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioCapability(ASN1encoding_t enc, IS11172AudioCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer3))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling32k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling44k1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling48k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->singleChannel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->twoChannels))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioCapability(ASN1decoding_t dec, IS11172AudioCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer3))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling32k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling44k1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling48k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->singleChannel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->twoChannels))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioCapability(ASN1encoding_t enc, IS13818AudioCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer3))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling16k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling22k05))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling24k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling32k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling44k1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling48k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->singleChannel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->twoChannels))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->threeChannels2_1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->threeChannels3_0))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fourChannels2_0_2_0))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fourChannels2_2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fourChannels3_1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fiveChannels3_0_2_0))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fiveChannels3_2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->lowFrequencyEnhancement))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multilingual))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioCapability(ASN1decoding_t dec, IS13818AudioCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer3))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling16k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling22k05))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling24k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling32k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling44k1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling48k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->singleChannel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->twoChannels))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->threeChannels2_1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->threeChannels3_0))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fourChannels2_0_2_0))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fourChannels2_2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fourChannels3_1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fiveChannels3_0_2_0))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fiveChannels3_2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->lowFrequencyEnhancement))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multilingual))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_GSMAudioCapability(ASN1encoding_t enc, GSMAudioCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->audioUnitSize - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->comfortNoise))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->scrambled))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GSMAudioCapability(ASN1decoding_t dec, GSMAudioCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->audioUnitSize))
	return 0;
    (val)->audioUnitSize += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->comfortNoise))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->scrambled))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V42bis(ASN1encoding_t enc, V42bis *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, (val)->numberOfCodewords - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->maximumStringLength - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V42bis(ASN1decoding_t dec, V42bis *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &(val)->numberOfCodewords))
	return 0;
    (val)->numberOfCodewords += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maximumStringLength))
	return 0;
    (val)->maximumStringLength += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_T84Profile(ASN1encoding_t enc, T84Profile *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_T84Profile_t84Restricted(enc, &(val)->u.t84Restricted))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_T84Profile(ASN1decoding_t dec, T84Profile *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_T84Profile_t84Restricted(dec, &(val)->u.t84Restricted))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceCapability(ASN1encoding_t enc, ConferenceCapability *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_ConferenceCapability_nonStandardData(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->chairControlCapability))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1PEREncBoolean(ee, (val)->videoIndicateMixingCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceCapability(ASN1decoding_t dec, ConferenceCapability *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ConferenceCapability_nonStandardData(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->chairControlCapability))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->videoIndicateMixingCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceCapability(ConferenceCapability *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ConferenceCapability_nonStandardData(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_Q2931Address(ASN1encoding_t enc, Q2931Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_Q2931Address_address(enc, &(val)->address))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->subaddress, 1, 20, 5))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Q2931Address(ASN1decoding_t dec, Q2931Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_Q2931Address_address(dec, &(val)->address))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->subaddress, 1, 20, 5))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Q2931Address(Q2931Address *val)
{
    if (val) {
	ASN1Free_Q2931Address_address(&(val)->address);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_V75Parameters(ASN1encoding_t enc, V75Parameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioHeaderPresent))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V75Parameters(ASN1decoding_t dec, V75Parameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioHeaderPresent))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H222LogicalChannelParameters(ASN1encoding_t enc, H222LogicalChannelParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->resourceID))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->subChannelID))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->pcr_pid))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->programDescriptors))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->streamDescriptors))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H222LogicalChannelParameters(ASN1decoding_t dec, H222LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->resourceID))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->subChannelID))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->pcr_pid))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->programDescriptors))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->streamDescriptors))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H222LogicalChannelParameters(H222LogicalChannelParameters *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1octetstring_free(&(val)->programDescriptors);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1octetstring_free(&(val)->streamDescriptors);
	}
    }
}

static int ASN1CALL ASN1Enc_H223AL2MParameters(ASN1encoding_t enc, H223AL2MParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H223AL2MParameters_headerFEC(enc, &(val)->headerFEC))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alpduInterleaving))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL2MParameters(ASN1decoding_t dec, H223AL2MParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H223AL2MParameters_headerFEC(dec, &(val)->headerFEC))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alpduInterleaving))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AnnexCArqParameters(ASN1encoding_t enc, H223AnnexCArqParameters *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H223AnnexCArqParameters_numberOfRetransmissions(enc, &(val)->numberOfRetransmissions))
	return 0;
    l = ASN1uint32_uoctets((val)->sendBufferSize);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->sendBufferSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexCArqParameters(ASN1decoding_t dec, H223AnnexCArqParameters *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H223AnnexCArqParameters_numberOfRetransmissions(dec, &(val)->numberOfRetransmissions))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->sendBufferSize))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CRCLength(ASN1encoding_t enc, CRCLength *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CRCLength(ASN1decoding_t dec, CRCLength *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_EscrowData(ASN1encoding_t enc, EscrowData *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->escrowID))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, ((val)->escrowValue).length - 1))
	return 0;
    if (!ASN1PEREncBits(enc, ((val)->escrowValue).length, ((val)->escrowValue).value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EscrowData(ASN1decoding_t dec, EscrowData *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->escrowID))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &((val)->escrowValue).length))
	return 0;
    ((val)->escrowValue).length += 1;
    if (!ASN1PERDecBits(dec, ((val)->escrowValue).length, &((val)->escrowValue).value))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EscrowData(EscrowData *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->escrowID);
	ASN1bitstring_free(&(val)->escrowValue);
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelReject(ASN1encoding_t enc, OpenLogicalChannelReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_OpenLogicalChannelReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelReject(ASN1decoding_t dec, OpenLogicalChannelReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!ASN1Dec_OpenLogicalChannelReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelConfirm(ASN1encoding_t enc, OpenLogicalChannelConfirm *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelConfirm(ASN1decoding_t dec, OpenLogicalChannelConfirm *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CloseLogicalChannel(ASN1encoding_t enc, CloseLogicalChannel *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x80;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_CloseLogicalChannel_source(enc, &(val)->source))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[0] & 0x80) {
	    if (!ASN1Enc_CloseLogicalChannel_reason(ee, &(val)->reason))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CloseLogicalChannel(ASN1decoding_t dec, CloseLogicalChannel *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!ASN1Dec_CloseLogicalChannel_source(dec, &(val)->source))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CloseLogicalChannel_reason(dd, &(val)->reason))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CloseLogicalChannelAck(ASN1encoding_t enc, CloseLogicalChannelAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CloseLogicalChannelAck(ASN1decoding_t dec, CloseLogicalChannelAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestChannelCloseAck(ASN1encoding_t enc, RequestChannelCloseAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelCloseAck(ASN1decoding_t dec, RequestChannelCloseAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestChannelCloseReject(ASN1encoding_t enc, RequestChannelCloseReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_RequestChannelCloseReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelCloseReject(ASN1decoding_t dec, RequestChannelCloseReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!ASN1Dec_RequestChannelCloseReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestChannelCloseRelease(ASN1encoding_t enc, RequestChannelCloseRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelCloseRelease(ASN1decoding_t dec, RequestChannelCloseRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MultiplexEntrySend(ASN1encoding_t enc, MultiplexEntrySend *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors(enc, &(val)->multiplexEntryDescriptors))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySend(ASN1decoding_t dec, MultiplexEntrySend *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors(dec, &(val)->multiplexEntryDescriptors))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySend(MultiplexEntrySend *val)
{
    if (val) {
	ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors(&(val)->multiplexEntryDescriptors);
    }
}

static int ASN1CALL ASN1Enc_MultiplexElement(ASN1encoding_t enc, MultiplexElement *val)
{
    if (!ASN1Enc_MultiplexElement_type(enc, &(val)->type))
	return 0;
    if (!ASN1Enc_MultiplexElement_repeatCount(enc, &(val)->repeatCount))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexElement(ASN1decoding_t dec, MultiplexElement *val)
{
    if (!ASN1Dec_MultiplexElement_type(dec, &(val)->type))
	return 0;
    if (!ASN1Dec_MultiplexElement_repeatCount(dec, &(val)->repeatCount))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexElement(MultiplexElement *val)
{
    if (val) {
	ASN1Free_MultiplexElement_type(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendAck(ASN1encoding_t enc, MultiplexEntrySendAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_MultiplexEntrySendAck_multiplexTableEntryNumber(enc, &(val)->multiplexTableEntryNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendAck(ASN1decoding_t dec, MultiplexEntrySendAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_MultiplexEntrySendAck_multiplexTableEntryNumber(dec, &(val)->multiplexTableEntryNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendAck(MultiplexEntrySendAck *val)
{
    if (val) {
	ASN1Free_MultiplexEntrySendAck_multiplexTableEntryNumber(&(val)->multiplexTableEntryNumber);
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntryRejectionDescriptions(ASN1encoding_t enc, MultiplexEntryRejectionDescriptions *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->multiplexTableEntryNumber - 1))
	return 0;
    if (!ASN1Enc_MultiplexEntryRejectionDescriptions_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntryRejectionDescriptions(ASN1decoding_t dec, MultiplexEntryRejectionDescriptions *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->multiplexTableEntryNumber))
	return 0;
    (val)->multiplexTableEntryNumber += 1;
    if (!ASN1Dec_MultiplexEntryRejectionDescriptions_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendRelease(ASN1encoding_t enc, MultiplexEntrySendRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MultiplexEntrySendRelease_multiplexTableEntryNumber(enc, &(val)->multiplexTableEntryNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendRelease(ASN1decoding_t dec, MultiplexEntrySendRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MultiplexEntrySendRelease_multiplexTableEntryNumber(dec, &(val)->multiplexTableEntryNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendRelease(MultiplexEntrySendRelease *val)
{
    if (val) {
	ASN1Free_MultiplexEntrySendRelease_multiplexTableEntryNumber(&(val)->multiplexTableEntryNumber);
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntry(ASN1encoding_t enc, RequestMultiplexEntry *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntry_entryNumbers(enc, &(val)->entryNumbers))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntry(ASN1decoding_t dec, RequestMultiplexEntry *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_RequestMultiplexEntry_entryNumbers(dec, &(val)->entryNumbers))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntry(RequestMultiplexEntry *val)
{
    if (val) {
	ASN1Free_RequestMultiplexEntry_entryNumbers(&(val)->entryNumbers);
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryAck(ASN1encoding_t enc, RequestMultiplexEntryAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntryAck_entryNumbers(enc, &(val)->entryNumbers))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryAck(ASN1decoding_t dec, RequestMultiplexEntryAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_RequestMultiplexEntryAck_entryNumbers(dec, &(val)->entryNumbers))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryAck(RequestMultiplexEntryAck *val)
{
    if (val) {
	ASN1Free_RequestMultiplexEntryAck_entryNumbers(&(val)->entryNumbers);
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryRejectionDescriptions(ASN1encoding_t enc, RequestMultiplexEntryRejectionDescriptions *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->multiplexTableEntryNumber - 1))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntryRejectionDescriptions_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryRejectionDescriptions(ASN1decoding_t dec, RequestMultiplexEntryRejectionDescriptions *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->multiplexTableEntryNumber))
	return 0;
    (val)->multiplexTableEntryNumber += 1;
    if (!ASN1Dec_RequestMultiplexEntryRejectionDescriptions_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryRelease(ASN1encoding_t enc, RequestMultiplexEntryRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntryRelease_entryNumbers(enc, &(val)->entryNumbers))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryRelease(ASN1decoding_t dec, RequestMultiplexEntryRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_RequestMultiplexEntryRelease_entryNumbers(dec, &(val)->entryNumbers))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryRelease(RequestMultiplexEntryRelease *val)
{
    if (val) {
	ASN1Free_RequestMultiplexEntryRelease_entryNumbers(&(val)->entryNumbers);
    }
}

static int ASN1CALL ASN1Enc_RequestMode(ASN1encoding_t enc, RequestMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_RequestMode_requestedModes(enc, &(val)->requestedModes))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMode(ASN1decoding_t dec, RequestMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_RequestMode_requestedModes(dec, &(val)->requestedModes))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMode(RequestMode *val)
{
    if (val) {
	ASN1Free_RequestMode_requestedModes(&(val)->requestedModes);
    }
}

static int ASN1CALL ASN1Enc_RequestModeAck(ASN1encoding_t enc, RequestModeAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_RequestModeAck_response(enc, &(val)->response))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeAck(ASN1decoding_t dec, RequestModeAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_RequestModeAck_response(dec, &(val)->response))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestModeReject(ASN1encoding_t enc, RequestModeReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_RequestModeReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeReject(ASN1decoding_t dec, RequestModeReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_RequestModeReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestModeRelease(ASN1encoding_t enc, RequestModeRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeRelease(ASN1decoding_t dec, RequestModeRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V76ModeParameters(ASN1encoding_t enc, V76ModeParameters *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76ModeParameters(ASN1decoding_t dec, V76ModeParameters *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H261VideoMode(ASN1encoding_t enc, H261VideoMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H261VideoMode_resolution(enc, &(val)->resolution))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->stillImageTransmission))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H261VideoMode(ASN1decoding_t dec, H261VideoMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H261VideoMode_resolution(dec, &(val)->resolution))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->stillImageTransmission))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H262VideoMode(ASN1encoding_t enc, H262VideoMode *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if (!ASN1Enc_H262VideoMode_profileAndLevel(enc, &(val)->profileAndLevel))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->videoBitRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->vbvBufferSize);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 4, (val)->framesPerSecond))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	l = ASN1uint32_uoctets((val)->luminanceSampleRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->luminanceSampleRate))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H262VideoMode(ASN1decoding_t dec, H262VideoMode *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if (!ASN1Dec_H262VideoMode_profileAndLevel(dec, &(val)->profileAndLevel))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 4, &(val)->framesPerSecond))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->luminanceSampleRate))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172VideoMode(ASN1encoding_t enc, IS11172VideoMode *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->constrainedBitstream))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->videoBitRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->vbvBufferSize);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 4, (val)->pictureRate))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	l = ASN1uint32_uoctets((val)->luminanceSampleRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->luminanceSampleRate))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172VideoMode(ASN1decoding_t dec, IS11172VideoMode *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->constrainedBitstream))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 4, &(val)->pictureRate))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->luminanceSampleRate))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioMode(ASN1encoding_t enc, IS11172AudioMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_IS11172AudioMode_audioLayer(enc, &(val)->audioLayer))
	return 0;
    if (!ASN1Enc_IS11172AudioMode_audioSampling(enc, &(val)->audioSampling))
	return 0;
    if (!ASN1Enc_IS11172AudioMode_multichannelType(enc, &(val)->multichannelType))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioMode(ASN1decoding_t dec, IS11172AudioMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_IS11172AudioMode_audioLayer(dec, &(val)->audioLayer))
	return 0;
    if (!ASN1Dec_IS11172AudioMode_audioSampling(dec, &(val)->audioSampling))
	return 0;
    if (!ASN1Dec_IS11172AudioMode_multichannelType(dec, &(val)->multichannelType))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioMode(ASN1encoding_t enc, IS13818AudioMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_IS13818AudioMode_audioLayer(enc, &(val)->audioLayer))
	return 0;
    if (!ASN1Enc_IS13818AudioMode_audioSampling(enc, &(val)->audioSampling))
	return 0;
    if (!ASN1Enc_IS13818AudioMode_multichannelType(enc, &(val)->multichannelType))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->lowFrequencyEnhancement))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multilingual))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioMode(ASN1decoding_t dec, IS13818AudioMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_IS13818AudioMode_audioLayer(dec, &(val)->audioLayer))
	return 0;
    if (!ASN1Dec_IS13818AudioMode_audioSampling(dec, &(val)->audioSampling))
	return 0;
    if (!ASN1Dec_IS13818AudioMode_multichannelType(dec, &(val)->multichannelType))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->lowFrequencyEnhancement))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multilingual))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_G7231AnnexCMode(ASN1encoding_t enc, G7231AnnexCMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->maxAl_sduAudioFrames - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->silenceSuppression))
	return 0;
    if (!ASN1Enc_G7231AnnexCMode_g723AnnexCAudioMode(enc, &(val)->g723AnnexCAudioMode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_G7231AnnexCMode(ASN1decoding_t dec, G7231AnnexCMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maxAl_sduAudioFrames))
	return 0;
    (val)->maxAl_sduAudioFrames += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->silenceSuppression))
	return 0;
    if (!ASN1Dec_G7231AnnexCMode_g723AnnexCAudioMode(dec, &(val)->g723AnnexCAudioMode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RoundTripDelayRequest(ASN1encoding_t enc, RoundTripDelayRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RoundTripDelayRequest(ASN1decoding_t dec, RoundTripDelayRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RoundTripDelayResponse(ASN1encoding_t enc, RoundTripDelayResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RoundTripDelayResponse(ASN1decoding_t dec, RoundTripDelayResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopRequest(ASN1encoding_t enc, MaintenanceLoopRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MaintenanceLoopRequest_type(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopRequest(ASN1decoding_t dec, MaintenanceLoopRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MaintenanceLoopRequest_type(dec, &(val)->type))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopAck(ASN1encoding_t enc, MaintenanceLoopAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MaintenanceLoopAck_type(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopAck(ASN1decoding_t dec, MaintenanceLoopAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MaintenanceLoopAck_type(dec, &(val)->type))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopReject(ASN1encoding_t enc, MaintenanceLoopReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MaintenanceLoopReject_type(enc, &(val)->type))
	return 0;
    if (!ASN1Enc_MaintenanceLoopReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopReject(ASN1decoding_t dec, MaintenanceLoopReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MaintenanceLoopReject_type(dec, &(val)->type))
	return 0;
    if (!ASN1Dec_MaintenanceLoopReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopOffCommand(ASN1encoding_t enc, MaintenanceLoopOffCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopOffCommand(ASN1decoding_t dec, MaintenanceLoopOffCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CommunicationModeCommand(ASN1encoding_t enc, CommunicationModeCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_CommunicationModeCommand_communicationModeTable(enc, &(val)->communicationModeTable))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeCommand(ASN1decoding_t dec, CommunicationModeCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_CommunicationModeCommand_communicationModeTable(dec, &(val)->communicationModeTable))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeCommand(CommunicationModeCommand *val)
{
    if (val) {
	ASN1Free_CommunicationModeCommand_communicationModeTable(&(val)->communicationModeTable);
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeRequest(ASN1encoding_t enc, CommunicationModeRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeRequest(ASN1decoding_t dec, CommunicationModeRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CommunicationModeResponse(ASN1encoding_t enc, CommunicationModeResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_CommunicationModeResponse_communicationModeTable(enc, &(val)->u.communicationModeTable))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeResponse(ASN1decoding_t dec, CommunicationModeResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_CommunicationModeResponse_communicationModeTable(dec, &(val)->u.communicationModeTable))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeResponse(CommunicationModeResponse *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_CommunicationModeResponse_communicationModeTable(&(val)->u.communicationModeTable);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_Criteria(ASN1encoding_t enc, Criteria *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->field))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->value, 1, 65535, 16))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Criteria(ASN1decoding_t dec, Criteria *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->field))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->value, 1, 65535, 16))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Criteria(Criteria *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->field);
    }
}

static int ASN1CALL ASN1Enc_TerminalLabel(ASN1encoding_t enc, TerminalLabel *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->mcuNumber))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->terminalNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalLabel(ASN1decoding_t dec, TerminalLabel *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->mcuNumber))
	return 0;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->terminalNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse(ASN1encoding_t enc, RequestAllTerminalIDsResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation(enc, &(val)->terminalInformation))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse(ASN1decoding_t dec, RequestAllTerminalIDsResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation(dec, &(val)->terminalInformation))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse(RequestAllTerminalIDsResponse *val)
{
    if (val) {
	ASN1Free_RequestAllTerminalIDsResponse_terminalInformation(&(val)->terminalInformation);
    }
}

static int ASN1CALL ASN1Enc_TerminalInformation(ASN1encoding_t enc, TerminalInformation *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalInformation(ASN1decoding_t dec, TerminalInformation *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TerminalInformation(TerminalInformation *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RemoteMCRequest(ASN1encoding_t enc, RemoteMCRequest *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteMCRequest(ASN1decoding_t dec, RemoteMCRequest *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RemoteMCResponse(ASN1encoding_t enc, RemoteMCResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_RemoteMCResponse_reject(enc, &(val)->u.reject))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteMCResponse(ASN1decoding_t dec, RemoteMCResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_RemoteMCResponse_reject(dec, &(val)->u.reject))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet(ASN1encoding_t enc, SendTerminalCapabilitySet *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_SendTerminalCapabilitySet_specificRequest(enc, &(val)->u.specificRequest))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet(ASN1decoding_t dec, SendTerminalCapabilitySet *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_SendTerminalCapabilitySet_specificRequest(dec, &(val)->u.specificRequest))
	    return 0;
	break;
    case 2:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet(SendTerminalCapabilitySet *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_SendTerminalCapabilitySet_specificRequest(&(val)->u.specificRequest);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_FlowControlCommand(ASN1encoding_t enc, FlowControlCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_FlowControlCommand_scope(enc, &(val)->scope))
	return 0;
    if (!ASN1Enc_FlowControlCommand_restriction(enc, &(val)->restriction))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FlowControlCommand(ASN1decoding_t dec, FlowControlCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_FlowControlCommand_scope(dec, &(val)->scope))
	return 0;
    if (!ASN1Dec_FlowControlCommand_restriction(dec, &(val)->restriction))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_SubstituteConferenceIDCommand(ASN1encoding_t enc, SubstituteConferenceIDCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceIdentifier, 16))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SubstituteConferenceIDCommand(ASN1decoding_t dec, SubstituteConferenceIDCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceIdentifier, 16))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SubstituteConferenceIDCommand(SubstituteConferenceIDCommand *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_KeyProtectionMethod(ASN1encoding_t enc, KeyProtectionMethod *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->secureChannel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->sharedSecret))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->certProtectedKey))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeyProtectionMethod(ASN1decoding_t dec, KeyProtectionMethod *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->secureChannel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->sharedSecret))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->certProtectedKey))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_EncryptionUpdateRequest(ASN1encoding_t enc, EncryptionUpdateRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KeyProtectionMethod(enc, &(val)->keyProtectionMethod))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionUpdateRequest(ASN1decoding_t dec, EncryptionUpdateRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_KeyProtectionMethod(dec, &(val)->keyProtectionMethod))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration(ASN1encoding_t enc, H223MultiplexReconfiguration *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H223MultiplexReconfiguration_h223ModeChange(enc, &(val)->u.h223ModeChange))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H223MultiplexReconfiguration_h223AnnexADoubleFlag(enc, &(val)->u.h223AnnexADoubleFlag))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration(ASN1decoding_t dec, H223MultiplexReconfiguration *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H223MultiplexReconfiguration_h223ModeChange(dec, &(val)->u.h223ModeChange))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H223MultiplexReconfiguration_h223AnnexADoubleFlag(dec, &(val)->u.h223AnnexADoubleFlag))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_FunctionNotSupported(ASN1encoding_t enc, FunctionNotSupported *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_FunctionNotSupported_cause(enc, &(val)->cause))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->returnedFunction))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_FunctionNotSupported(ASN1decoding_t dec, FunctionNotSupported *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_FunctionNotSupported_cause(dec, &(val)->cause))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->returnedFunction))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_FunctionNotSupported(FunctionNotSupported *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->returnedFunction);
	}
    }
}

static int ASN1CALL ASN1Enc_TerminalYouAreSeeingInSubPictureNumber(ASN1encoding_t enc, TerminalYouAreSeeingInSubPictureNumber *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->terminalNumber))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->subPictureNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalYouAreSeeingInSubPictureNumber(ASN1decoding_t dec, TerminalYouAreSeeingInSubPictureNumber *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->terminalNumber))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->subPictureNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VideoIndicateCompose(ASN1encoding_t enc, VideoIndicateCompose *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->compositionNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VideoIndicateCompose(ASN1decoding_t dec, VideoIndicateCompose *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->compositionNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceIndication(ASN1encoding_t enc, ConferenceIndication *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncBitVal(enc, 4, (val)->u.sbeNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.terminalNumberAssign))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.terminalJoinedConference))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.terminalLeftConference))
	    return 0;
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.terminalYouAreSeeing))
	    return 0;
	break;
    case 10:
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TerminalLabel(ee, &(val)->u.floorRequested))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 13:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TerminalYouAreSeeingInSubPictureNumber(ee, &(val)->u.terminalYouAreSeeingInSubPictureNumber))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 14:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_VideoIndicateCompose(ee, &(val)->u.videoIndicateCompose))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceIndication(ASN1decoding_t dec, ConferenceIndication *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU16Val(dec, 4, &(val)->u.sbeNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.terminalNumberAssign))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.terminalJoinedConference))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.terminalLeftConference))
	    return 0;
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.terminalYouAreSeeing))
	    return 0;
	break;
    case 10:
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_TerminalLabel(dd, &(val)->u.floorRequested))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 13:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_TerminalYouAreSeeingInSubPictureNumber(dd, &(val)->u.terminalYouAreSeeingInSubPictureNumber))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 14:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_VideoIndicateCompose(dd, &(val)->u.videoIndicateCompose))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_JitterIndication(ASN1encoding_t enc, JitterIndication *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_JitterIndication_scope(enc, &(val)->scope))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->estimatedReceivedJitterMantissa))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->estimatedReceivedJitterExponent))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 4, (val)->skippedFrameCount))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->additionalDecoderBuffer);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->additionalDecoderBuffer))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_JitterIndication(ASN1decoding_t dec, JitterIndication *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_JitterIndication_scope(dec, &(val)->scope))
	return 0;
    if (!ASN1PERDecU16Val(dec, 2, &(val)->estimatedReceivedJitterMantissa))
	return 0;
    if (!ASN1PERDecU16Val(dec, 3, &(val)->estimatedReceivedJitterExponent))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 4, &(val)->skippedFrameCount))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->additionalDecoderBuffer))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223SkewIndication(ASN1encoding_t enc, H223SkewIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber1 - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber2 - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->skew))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223SkewIndication(ASN1decoding_t dec, H223SkewIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber1))
	return 0;
    (val)->logicalChannelNumber1 += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber2))
	return 0;
    (val)->logicalChannelNumber2 += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->skew))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H2250MaximumSkewIndication(ASN1encoding_t enc, H2250MaximumSkewIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber1 - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber2 - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumSkew))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250MaximumSkewIndication(ASN1decoding_t dec, H2250MaximumSkewIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber1))
	return 0;
    (val)->logicalChannelNumber1 += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber2))
	return 0;
    (val)->logicalChannelNumber2 += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumSkew))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VendorIdentification(ASN1encoding_t enc, VendorIdentification *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->vendor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->productNumber, 1, 256, 8))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->versionNumber, 1, 256, 8))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VendorIdentification(ASN1decoding_t dec, VendorIdentification *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->vendor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->productNumber, 1, 256, 8))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->versionNumber, 1, 256, 8))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_VendorIdentification(VendorIdentification *val)
{
    if (val) {
	ASN1Free_NonStandardIdentifier(&(val)->vendor);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_NewATMVCIndication(ASN1encoding_t enc, NewATMVCIndication *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x80;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->resourceID))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->bitRateLockedToPCRClock))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->bitRateLockedToNetworkClock))
	return 0;
    if (!ASN1Enc_NewATMVCIndication_aal(enc, &(val)->aal))
	return 0;
    if (!ASN1Enc_NewATMVCIndication_multiplex(enc, &(val)->multiplex))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[0] & 0x80) {
	    if (!ASN1Enc_NewATMVCIndication_reverseParameters(ee, &(val)->reverseParameters))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication(ASN1decoding_t dec, NewATMVCIndication *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->resourceID))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->bitRateLockedToPCRClock))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->bitRateLockedToNetworkClock))
	return 0;
    if (!ASN1Dec_NewATMVCIndication_aal(dec, &(val)->aal))
	return 0;
    if (!ASN1Dec_NewATMVCIndication_multiplex(dec, &(val)->multiplex))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_NewATMVCIndication_reverseParameters(dd, &(val)->reverseParameters))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(ASN1encoding_t enc, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(ASN1encoding_t enc, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val)
{
    if (!ASN1Enc_RTPH263VideoRedundancyFrameMapping(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(ASN1decoding_t dec, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(ASN1decoding_t dec, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val)
{
    if (!ASN1Dec_RTPH263VideoRedundancyFrameMapping(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val)
{
    if (val) {
	ASN1Free_RTPH263VideoRedundancyFrameMapping(&val->value);
    }
}

static int ASN1CALL ASN1Enc_MultiplexElement_type_subElementList(ASN1encoding_t enc, PMultiplexElement_type_subElementList *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 8, (*val)->count - 2))
	return 0;
    for (i = 0; i < (*val)->count; i++) {
	if (!ASN1Enc_MultiplexElement(enc, &((*val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexElement_type_subElementList(ASN1decoding_t dec, PMultiplexElement_type_subElementList *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 8, &(*val)->count))
	return 0;
    (*val)->count += 2;
    for (i = 0; i < (*val)->count; i++) {
	if (!ASN1Dec_MultiplexElement(dec, &((*val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexElement_type_subElementList(PMultiplexElement_type_subElementList *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (*val)->count; i++) {
	    ASN1Free_MultiplexElement(&(*val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation(ASN1encoding_t enc, PRequestAllTerminalIDsResponse_terminalInformation *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation_ElmFn);
}

static int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(ASN1encoding_t enc, PRequestAllTerminalIDsResponse_terminalInformation val)
{
    if (!ASN1Enc_TerminalInformation(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation(ASN1decoding_t dec, PRequestAllTerminalIDsResponse_terminalInformation *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(ASN1decoding_t dec, PRequestAllTerminalIDsResponse_terminalInformation val)
{
    if (!ASN1Dec_TerminalInformation(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse_terminalInformation(PRequestAllTerminalIDsResponse_terminalInformation *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RequestAllTerminalIDsResponse_terminalInformation_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(PRequestAllTerminalIDsResponse_terminalInformation val)
{
    if (val) {
	ASN1Free_TerminalInformation(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_terminalCertificateResponse(ASN1encoding_t enc, ConferenceResponse_terminalCertificateResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->certificateResponse, 1, 65535, 16))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_terminalCertificateResponse(ASN1decoding_t dec, ConferenceResponse_terminalCertificateResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->certificateResponse, 1, 65535, 16))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_terminalCertificateResponse(ConferenceResponse_terminalCertificateResponse *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_chairTokenOwnerResponse(ASN1encoding_t enc, ConferenceResponse_chairTokenOwnerResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_chairTokenOwnerResponse(ASN1decoding_t dec, ConferenceResponse_chairTokenOwnerResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_chairTokenOwnerResponse(ConferenceResponse_chairTokenOwnerResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_terminalListResponse(ASN1encoding_t enc, ConferenceResponse_terminalListResponse *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_TerminalLabel(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_terminalListResponse(ASN1decoding_t dec, ConferenceResponse_terminalListResponse *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_TerminalLabel(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_terminalListResponse(ConferenceResponse_terminalListResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_passwordResponse(ASN1encoding_t enc, ConferenceResponse_passwordResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->password, 1, 32, 5))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_passwordResponse(ASN1decoding_t dec, ConferenceResponse_passwordResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->password, 1, 32, 5))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_passwordResponse(ConferenceResponse_passwordResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_conferenceIDResponse(ASN1encoding_t enc, ConferenceResponse_conferenceIDResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 1, 32, 5))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_conferenceIDResponse(ASN1decoding_t dec, ConferenceResponse_conferenceIDResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 1, 32, 5))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_conferenceIDResponse(ConferenceResponse_conferenceIDResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_terminalIDResponse(ASN1encoding_t enc, ConferenceResponse_terminalIDResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_terminalIDResponse(ASN1decoding_t dec, ConferenceResponse_terminalIDResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_terminalIDResponse(ConferenceResponse_terminalIDResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_mCTerminalIDResponse(ASN1encoding_t enc, ConferenceResponse_mCTerminalIDResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_mCTerminalIDResponse(ASN1decoding_t dec, ConferenceResponse_mCTerminalIDResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_mCTerminalIDResponse(ConferenceResponse_mCTerminalIDResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceRequest_requestTerminalCertificate(ASN1encoding_t enc, ConferenceRequest_requestTerminalCertificate *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_CertSelectionCriteria(enc, &(val)->certSelectionCriteria))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	l = ASN1uint32_uoctets((val)->sRandom - 1);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->sRandom - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceRequest_requestTerminalCertificate(ASN1decoding_t dec, ConferenceRequest_requestTerminalCertificate *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_CertSelectionCriteria(dec, &(val)->certSelectionCriteria))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->sRandom))
	    return 0;
	(val)->sRandom += 1;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceRequest_requestTerminalCertificate(ConferenceRequest_requestTerminalCertificate *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1Free_CertSelectionCriteria(&(val)->certSelectionCriteria);
	}
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject_rejectionDescriptions(ASN1encoding_t enc, RequestMultiplexEntryReject_rejectionDescriptions *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_RequestMultiplexEntryRejectionDescriptions(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject_rejectionDescriptions(ASN1decoding_t dec, RequestMultiplexEntryReject_rejectionDescriptions *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_RequestMultiplexEntryRejectionDescriptions(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryReject_rejectionDescriptions(RequestMultiplexEntryReject_rejectionDescriptions *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendReject_rejectionDescriptions(ASN1encoding_t enc, MultiplexEntrySendReject_rejectionDescriptions *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_MultiplexEntryRejectionDescriptions(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendReject_rejectionDescriptions(ASN1decoding_t dec, MultiplexEntrySendReject_rejectionDescriptions *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_MultiplexEntryRejectionDescriptions(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendReject_rejectionDescriptions(MultiplexEntrySendReject_rejectionDescriptions *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntryDescriptor_elementList(ASN1encoding_t enc, MultiplexEntryDescriptor_elementList *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_MultiplexElement(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntryDescriptor_elementList(ASN1decoding_t dec, MultiplexEntryDescriptor_elementList *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_MultiplexElement(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntryDescriptor_elementList(MultiplexEntryDescriptor_elementList *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (val)->count; i++) {
	    ASN1Free_MultiplexElement(&(val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionSync_escrowentry(ASN1encoding_t enc, PEncryptionSync_escrowentry *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EncryptionSync_escrowentry_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_EncryptionSync_escrowentry_ElmFn(ASN1encoding_t enc, PEncryptionSync_escrowentry val)
{
    if (!ASN1Enc_EscrowData(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionSync_escrowentry(ASN1decoding_t dec, PEncryptionSync_escrowentry *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EncryptionSync_escrowentry_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_EncryptionSync_escrowentry_ElmFn(ASN1decoding_t dec, PEncryptionSync_escrowentry val)
{
    if (!ASN1Dec_EscrowData(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionSync_escrowentry(PEncryptionSync_escrowentry *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EncryptionSync_escrowentry_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EncryptionSync_escrowentry_ElmFn(PEncryptionSync_escrowentry val)
{
    if (val) {
	ASN1Free_EscrowData(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H223AL3MParameters_arqType(ASN1encoding_t enc, H223AL3MParameters_arqType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_H223AnnexCArqParameters(enc, &(val)->u.typeIArq))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H223AnnexCArqParameters(enc, &(val)->u.typeIIArq))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL3MParameters_arqType(ASN1decoding_t dec, H223AL3MParameters_arqType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_H223AnnexCArqParameters(dec, &(val)->u.typeIArq))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H223AnnexCArqParameters(dec, &(val)->u.typeIIArq))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL1MParameters_arqType(ASN1encoding_t enc, H223AL1MParameters_arqType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_H223AnnexCArqParameters(enc, &(val)->u.typeIArq))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H223AnnexCArqParameters(enc, &(val)->u.typeIIArq))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL1MParameters_arqType(ASN1decoding_t dec, H223AL1MParameters_arqType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_H223AnnexCArqParameters(dec, &(val)->u.typeIArq))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H223AnnexCArqParameters(dec, &(val)->u.typeIIArq))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H263VideoModeCombos_h263VideoCoupledModes(ASN1encoding_t enc, H263VideoModeCombos_h263VideoCoupledModes *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_H263ModeComboFlags(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H263VideoModeCombos_h263VideoCoupledModes(ASN1decoding_t dec, H263VideoModeCombos_h263VideoCoupledModes *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_H263ModeComboFlags(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H263VideoModeCombos_h263VideoCoupledModes(H263VideoModeCombos_h263VideoCoupledModes *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_H263Options_customPictureFormat(ASN1encoding_t enc, PH263Options_customPictureFormat *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H263Options_customPictureFormat_ElmFn, 1, 16, 4);
}

static int ASN1CALL ASN1Enc_H263Options_customPictureFormat_ElmFn(ASN1encoding_t enc, PH263Options_customPictureFormat val)
{
    if (!ASN1Enc_CustomPictureFormat(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263Options_customPictureFormat(ASN1decoding_t dec, PH263Options_customPictureFormat *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H263Options_customPictureFormat_ElmFn, sizeof(**val), 1, 16, 4);
}

static int ASN1CALL ASN1Dec_H263Options_customPictureFormat_ElmFn(ASN1decoding_t dec, PH263Options_customPictureFormat val)
{
    if (!ASN1Dec_CustomPictureFormat(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H263Options_customPictureFormat(PH263Options_customPictureFormat *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H263Options_customPictureFormat_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H263Options_customPictureFormat_ElmFn(PH263Options_customPictureFormat val)
{
    if (val) {
	ASN1Free_CustomPictureFormat(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H263Options_customPictureClockFrequency(ASN1encoding_t enc, PH263Options_customPictureClockFrequency *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H263Options_customPictureClockFrequency_ElmFn, 1, 16, 4);
}

static int ASN1CALL ASN1Enc_H263Options_customPictureClockFrequency_ElmFn(ASN1encoding_t enc, PH263Options_customPictureClockFrequency val)
{
    if (!ASN1Enc_CustomPictureClockFrequency(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263Options_customPictureClockFrequency(ASN1decoding_t dec, PH263Options_customPictureClockFrequency *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H263Options_customPictureClockFrequency_ElmFn, sizeof(**val), 1, 16, 4);
}

static int ASN1CALL ASN1Dec_H263Options_customPictureClockFrequency_ElmFn(ASN1decoding_t dec, PH263Options_customPictureClockFrequency val)
{
    if (!ASN1Dec_CustomPictureClockFrequency(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H263Options_customPictureClockFrequency(PH263Options_customPictureClockFrequency *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H263Options_customPictureClockFrequency_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H263Options_customPictureClockFrequency_ElmFn(PH263Options_customPictureClockFrequency val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_MultipointCapability_mediaDistributionCapability_ElmFn);
}

static int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability val)
{
    if (!ASN1Enc_MediaDistributionCapability(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_MultipointCapability_mediaDistributionCapability_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability val)
{
    if (!ASN1Dec_MediaDistributionCapability(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability(PMultipointCapability_mediaDistributionCapability *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_MultipointCapability_mediaDistributionCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability_ElmFn(PMultipointCapability_mediaDistributionCapability val)
{
    if (val) {
	ASN1Free_MediaDistributionCapability(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TransportCapability_mediaChannelCapabilities(ASN1encoding_t enc, TransportCapability_mediaChannelCapabilities *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_MediaChannelCapability(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransportCapability_mediaChannelCapabilities(ASN1decoding_t dec, TransportCapability_mediaChannelCapabilities *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_MediaChannelCapability(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportCapability_mediaChannelCapabilities(TransportCapability_mediaChannelCapabilities *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_H222Capability_vcCapability(ASN1encoding_t enc, PH222Capability_vcCapability *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H222Capability_vcCapability_ElmFn);
}

static int ASN1CALL ASN1Enc_H222Capability_vcCapability_ElmFn(ASN1encoding_t enc, PH222Capability_vcCapability val)
{
    if (!ASN1Enc_VCCapability(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H222Capability_vcCapability(ASN1decoding_t dec, PH222Capability_vcCapability *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H222Capability_vcCapability_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H222Capability_vcCapability_ElmFn(ASN1decoding_t dec, PH222Capability_vcCapability val)
{
    if (!ASN1Dec_VCCapability(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H222Capability_vcCapability(PH222Capability_vcCapability *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H222Capability_vcCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H222Capability_vcCapability_ElmFn(PH222Capability_vcCapability val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CapabilityDescriptor_simultaneousCapabilities_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities val)
{
    if (!ASN1Enc_AlternativeCapabilitySet(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CapabilityDescriptor_simultaneousCapabilities_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities val)
{
    if (!ASN1Dec_AlternativeCapabilitySet(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities(PCapabilityDescriptor_simultaneousCapabilities *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CapabilityDescriptor_simultaneousCapabilities_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities_ElmFn(PCapabilityDescriptor_simultaneousCapabilities val)
{
    if (val) {
	ASN1Free_AlternativeCapabilitySet(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityDescriptors(ASN1encoding_t enc, TerminalCapabilitySet_capabilityDescriptors *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_CapabilityDescriptor(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityDescriptors(ASN1decoding_t dec, TerminalCapabilitySet_capabilityDescriptors *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_CapabilityDescriptor(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityDescriptors(TerminalCapabilitySet_capabilityDescriptors *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (val)->count; i++) {
	    ASN1Free_CapabilityDescriptor(&(val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_NonStandardParameter(ASN1encoding_t enc, NonStandardParameter *val)
{
    if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->data))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardParameter(ASN1decoding_t dec, NonStandardParameter *val)
{
    if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->data))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardParameter(NonStandardParameter *val)
{
    if (val) {
	ASN1Free_NonStandardIdentifier(&(val)->nonStandardIdentifier);
	ASN1octetstring_free(&(val)->data);
    }
}

static int ASN1CALL ASN1Enc_H223Capability(ASN1encoding_t enc, H223Capability *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x80;
    o[0] |= 0x40;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->transportWithI_frames))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL3))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL3))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL3))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAl2SDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAl3SDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumDelayJitter))
	return 0;
    if (!ASN1Enc_H223Capability_h223MultiplexTableCapability(enc, &(val)->h223MultiplexTableCapability))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[0] & 0x80) {
	    if (!ASN1PEREncBoolean(ee, (val)->maxMUXPDUSizeCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x40) {
	    if (!ASN1PEREncBoolean(ee, (val)->nsrpSupport))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x20) {
	    if (!ASN1Enc_H223Capability_mobileOperationTransmitCapability(ee, &(val)->mobileOperationTransmitCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x10) {
	    if (!ASN1Enc_H223AnnexCCapability(ee, &(val)->h223AnnexCCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223Capability(ASN1decoding_t dec, H223Capability *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->transportWithI_frames))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL3))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL3))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL3))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAl2SDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAl3SDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumDelayJitter))
	return 0;
    if (!ASN1Dec_H223Capability_h223MultiplexTableCapability(dec, &(val)->h223MultiplexTableCapability))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->maxMUXPDUSizeCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->nsrpSupport))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H223Capability_mobileOperationTransmitCapability(dd, &(val)->mobileOperationTransmitCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H223AnnexCCapability(dd, &(val)->h223AnnexCCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V76Capability(ASN1encoding_t enc, V76Capability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->suspendResumeCapabilitywAddress))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->suspendResumeCapabilitywoAddress))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->rejCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->sREJCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->mREJCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->crc8bitCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->crc16bitCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->crc32bitCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->uihCapability))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->numOfDLCS - 2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->twoOctetAddressFieldCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->loopBackTestCapability))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->n401Capability - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->maxWindowSizeCapability - 1))
	return 0;
    if (!ASN1Enc_V75Capability(enc, &(val)->v75Capability))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76Capability(ASN1decoding_t dec, V76Capability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->suspendResumeCapabilitywAddress))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->suspendResumeCapabilitywoAddress))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->rejCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->sREJCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->mREJCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->crc8bitCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->crc16bitCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->crc32bitCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->uihCapability))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->numOfDLCS))
	return 0;
    (val)->numOfDLCS += 2;
    if (!ASN1PERDecBoolean(dec, &(val)->twoOctetAddressFieldCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->loopBackTestCapability))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->n401Capability))
	return 0;
    (val)->n401Capability += 1;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->maxWindowSizeCapability))
	return 0;
    (val)->maxWindowSizeCapability += 1;
    if (!ASN1Dec_V75Capability(dec, &(val)->v75Capability))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RSVPParameters(ASN1encoding_t enc, RSVPParameters *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_QOSMode(enc, &(val)->qosMode))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->tokenRate - 1);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->tokenRate - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	l = ASN1uint32_uoctets((val)->bucketSize - 1);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->bucketSize - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	l = ASN1uint32_uoctets((val)->peakRate - 1);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->peakRate - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	l = ASN1uint32_uoctets((val)->minPoliced - 1);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->minPoliced - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	l = ASN1uint32_uoctets((val)->maxPktSize - 1);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->maxPktSize - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RSVPParameters(ASN1decoding_t dec, RSVPParameters *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_QOSMode(dec, &(val)->qosMode))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->tokenRate))
	    return 0;
	(val)->tokenRate += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bucketSize))
	    return 0;
	(val)->bucketSize += 1;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->peakRate))
	    return 0;
	(val)->peakRate += 1;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->minPoliced))
	    return 0;
	(val)->minPoliced += 1;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->maxPktSize))
	    return 0;
	(val)->maxPktSize += 1;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_QOSCapability(ASN1encoding_t enc, QOSCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_RSVPParameters(enc, &(val)->rsvpParameters))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_ATMParameters(enc, &(val)->atmParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_QOSCapability(ASN1decoding_t dec, QOSCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_RSVPParameters(dec, &(val)->rsvpParameters))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_ATMParameters(dec, &(val)->atmParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_QOSCapability(QOSCapability *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_TransportCapability(ASN1encoding_t enc, TransportCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandard))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_TransportCapability_qOSCapabilities(enc, &(val)->qOSCapabilities))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_TransportCapability_mediaChannelCapabilities(enc, &(val)->mediaChannelCapabilities))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransportCapability(ASN1decoding_t dec, TransportCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandard))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_TransportCapability_qOSCapabilities(dec, &(val)->qOSCapabilities))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_TransportCapability_mediaChannelCapabilities(dec, &(val)->mediaChannelCapabilities))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportCapability(TransportCapability *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandard);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_TransportCapability_qOSCapabilities(&(val)->qOSCapabilities);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_TransportCapability_mediaChannelCapabilities(&(val)->mediaChannelCapabilities);
	}
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncodingMethod(ASN1encoding_t enc, RedundancyEncodingMethod *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_RTPH263VideoRedundancyEncoding(ee, &(val)->u.rtpH263VideoRedundancyEncoding))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncodingMethod(ASN1decoding_t dec, RedundancyEncodingMethod *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_RTPH263VideoRedundancyEncoding(dd, &(val)->u.rtpH263VideoRedundancyEncoding))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncodingMethod(RedundancyEncodingMethod *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 3:
	    ASN1Free_RTPH263VideoRedundancyEncoding(&(val)->u.rtpH263VideoRedundancyEncoding);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H263Options(ASN1encoding_t enc, H263Options *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->advancedIntraCodingMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->deblockingFilterMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->improvedPBFramesMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unlimitedMotionVectors))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fullPictureFreeze))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->partialPictureFreezeAndRelease))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->resizingPartPicFreezeAndRelease))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fullPictureSnapshot))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->partialPictureSnapshot))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoSegmentTagging))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->progressiveRefinement))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicPictureResizingByFour))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicPictureResizingSixteenthPel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicWarpingHalfPel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicWarpingSixteenthPel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->independentSegmentDecoding))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesInOrder_NonRect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesInOrder_Rect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesNoOrder_NonRect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesNoOrder_Rect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alternateInterVLCMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->modifiedQuantizationMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->reducedResolutionUpdate))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_TransparencyParameters(enc, &(val)->transparencyParameters))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->separateVideoBackChannel))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_RefPictureSelection(enc, &(val)->refPictureSelection))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_H263Options_customPictureClockFrequency(enc, &(val)->customPictureClockFrequency))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_H263Options_customPictureFormat(enc, &(val)->customPictureFormat))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_H263Options_modeCombos(enc, &(val)->modeCombos))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H263Options(ASN1decoding_t dec, H263Options *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->advancedIntraCodingMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->deblockingFilterMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->improvedPBFramesMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->unlimitedMotionVectors))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fullPictureFreeze))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->partialPictureFreezeAndRelease))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->resizingPartPicFreezeAndRelease))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fullPictureSnapshot))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->partialPictureSnapshot))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoSegmentTagging))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->progressiveRefinement))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicPictureResizingByFour))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicPictureResizingSixteenthPel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicWarpingHalfPel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicWarpingSixteenthPel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->independentSegmentDecoding))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesInOrder_NonRect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesInOrder_Rect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesNoOrder_NonRect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesNoOrder_Rect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alternateInterVLCMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->modifiedQuantizationMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->reducedResolutionUpdate))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransparencyParameters(dec, &(val)->transparencyParameters))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->separateVideoBackChannel))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_RefPictureSelection(dec, &(val)->refPictureSelection))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_H263Options_customPictureClockFrequency(dec, &(val)->customPictureClockFrequency))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_H263Options_customPictureFormat(dec, &(val)->customPictureFormat))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_H263Options_modeCombos(dec, &(val)->modeCombos))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H263Options(H263Options *val)
{
    if (val) {
	if ((val)->o[0] & 0x20) {
	    ASN1Free_H263Options_customPictureClockFrequency(&(val)->customPictureClockFrequency);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_H263Options_customPictureFormat(&(val)->customPictureFormat);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_H263Options_modeCombos(&(val)->modeCombos);
	}
    }
}

static int ASN1CALL ASN1Enc_H263VideoModeCombos(ASN1encoding_t enc, H263VideoModeCombos *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H263ModeComboFlags(enc, &(val)->h263VideoUncoupledModes))
	return 0;
    if (!ASN1Enc_H263VideoModeCombos_h263VideoCoupledModes(enc, &(val)->h263VideoCoupledModes))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263VideoModeCombos(ASN1decoding_t dec, H263VideoModeCombos *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H263ModeComboFlags(dec, &(val)->h263VideoUncoupledModes))
	return 0;
    if (!ASN1Dec_H263VideoModeCombos_h263VideoCoupledModes(dec, &(val)->h263VideoCoupledModes))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H263VideoModeCombos(H263VideoModeCombos *val)
{
    if (val) {
	ASN1Free_H263VideoModeCombos_h263VideoCoupledModes(&(val)->h263VideoCoupledModes);
    }
}

static int ASN1CALL ASN1Enc_AudioCapability(ASN1encoding_t enc, AudioCapability *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g711Alaw64k - 1))
	    return 0;
	break;
    case 3:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g711Alaw56k - 1))
	    return 0;
	break;
    case 4:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g711Ulaw64k - 1))
	    return 0;
	break;
    case 5:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g711Ulaw56k - 1))
	    return 0;
	break;
    case 6:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g722_64k - 1))
	    return 0;
	break;
    case 7:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g722_56k - 1))
	    return 0;
	break;
    case 8:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g722_48k - 1))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_AudioCapability_g7231(enc, &(val)->u.g7231))
	    return 0;
	break;
    case 10:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g728 - 1))
	    return 0;
	break;
    case 11:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g729 - 1))
	    return 0;
	break;
    case 12:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g729AnnexA - 1))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_IS11172AudioCapability(enc, &(val)->u.is11172AudioCapability))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_IS13818AudioCapability(enc, &(val)->u.is13818AudioCapability))
	    return 0;
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 8, (val)->u.g729wAnnexB - 1))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 16:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 8, (val)->u.g729AnnexAwAnnexB - 1))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 17:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_G7231AnnexCCapability(ee, &(val)->u.g7231AnnexCCapability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 18:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmFullRate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 19:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmHalfRate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 20:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmEnhancedFullRate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AudioCapability(ASN1decoding_t dec, AudioCapability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g711Alaw64k))
	    return 0;
	(val)->u.g711Alaw64k += 1;
	break;
    case 3:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g711Alaw56k))
	    return 0;
	(val)->u.g711Alaw56k += 1;
	break;
    case 4:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g711Ulaw64k))
	    return 0;
	(val)->u.g711Ulaw64k += 1;
	break;
    case 5:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g711Ulaw56k))
	    return 0;
	(val)->u.g711Ulaw56k += 1;
	break;
    case 6:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g722_64k))
	    return 0;
	(val)->u.g722_64k += 1;
	break;
    case 7:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g722_56k))
	    return 0;
	(val)->u.g722_56k += 1;
	break;
    case 8:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g722_48k))
	    return 0;
	(val)->u.g722_48k += 1;
	break;
    case 9:
	if (!ASN1Dec_AudioCapability_g7231(dec, &(val)->u.g7231))
	    return 0;
	break;
    case 10:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g728))
	    return 0;
	(val)->u.g728 += 1;
	break;
    case 11:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g729))
	    return 0;
	(val)->u.g729 += 1;
	break;
    case 12:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g729AnnexA))
	    return 0;
	(val)->u.g729AnnexA += 1;
	break;
    case 13:
	if (!ASN1Dec_IS11172AudioCapability(dec, &(val)->u.is11172AudioCapability))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_IS13818AudioCapability(dec, &(val)->u.is13818AudioCapability))
	    return 0;
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU16Val(dd, 8, &(val)->u.g729wAnnexB))
	    return 0;
	(val)->u.g729wAnnexB += 1;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 16:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU16Val(dd, 8, &(val)->u.g729AnnexAwAnnexB))
	    return 0;
	(val)->u.g729AnnexAwAnnexB += 1;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 17:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_G7231AnnexCCapability(dd, &(val)->u.g7231AnnexCCapability))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 18:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmFullRate))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 19:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmHalfRate))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 20:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmEnhancedFullRate))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AudioCapability(AudioCapability *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CompressionType(ASN1encoding_t enc, CompressionType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_V42bis(enc, &(val)->u.v42bis))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CompressionType(ASN1decoding_t dec, CompressionType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_V42bis(dec, &(val)->u.v42bis))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MediaEncryptionAlgorithm(ASN1encoding_t enc, MediaEncryptionAlgorithm *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.algorithm))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MediaEncryptionAlgorithm(ASN1decoding_t dec, MediaEncryptionAlgorithm *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.algorithm))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MediaEncryptionAlgorithm(MediaEncryptionAlgorithm *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1objectidentifier_free(&(val)->u.algorithm);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_AuthenticationCapability(ASN1encoding_t enc, AuthenticationCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandard))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AuthenticationCapability(ASN1decoding_t dec, AuthenticationCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandard))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AuthenticationCapability(AuthenticationCapability *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandard);
	}
    }
}

static int ASN1CALL ASN1Enc_IntegrityCapability(ASN1encoding_t enc, IntegrityCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandard))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IntegrityCapability(ASN1decoding_t dec, IntegrityCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandard))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_IntegrityCapability(IntegrityCapability *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandard);
	}
    }
}

static int ASN1CALL ASN1Enc_H223AL1MParameters(ASN1encoding_t enc, H223AL1MParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H223AL1MParameters_transferMode(enc, &(val)->transferMode))
	return 0;
    if (!ASN1Enc_H223AL1MParameters_headerFEC(enc, &(val)->headerFEC))
	return 0;
    if (!ASN1Enc_H223AL1MParameters_crcLength(enc, &(val)->crcLength))
	return 0;
    if (!ASN1PEREncBitVal(enc, 5, (val)->rcpcCodeRate - 8))
	return 0;
    if (!ASN1Enc_H223AL1MParameters_arqType(enc, &(val)->arqType))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alpduInterleaving))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alsduSplitting))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL1MParameters(ASN1decoding_t dec, H223AL1MParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H223AL1MParameters_transferMode(dec, &(val)->transferMode))
	return 0;
    if (!ASN1Dec_H223AL1MParameters_headerFEC(dec, &(val)->headerFEC))
	return 0;
    if (!ASN1Dec_H223AL1MParameters_crcLength(dec, &(val)->crcLength))
	return 0;
    if (!ASN1PERDecU16Val(dec, 5, &(val)->rcpcCodeRate))
	return 0;
    (val)->rcpcCodeRate += 8;
    if (!ASN1Dec_H223AL1MParameters_arqType(dec, &(val)->arqType))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alpduInterleaving))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alsduSplitting))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL3MParameters(ASN1encoding_t enc, H223AL3MParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H223AL3MParameters_headerFormat(enc, &(val)->headerFormat))
	return 0;
    if (!ASN1Enc_H223AL3MParameters_crcLength(enc, &(val)->crcLength))
	return 0;
    if (!ASN1PEREncBitVal(enc, 5, (val)->rcpcCodeRate - 8))
	return 0;
    if (!ASN1Enc_H223AL3MParameters_arqType(enc, &(val)->arqType))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alpduInterleaving))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL3MParameters(ASN1decoding_t dec, H223AL3MParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H223AL3MParameters_headerFormat(dec, &(val)->headerFormat))
	return 0;
    if (!ASN1Dec_H223AL3MParameters_crcLength(dec, &(val)->crcLength))
	return 0;
    if (!ASN1PERDecU16Val(dec, 5, &(val)->rcpcCodeRate))
	return 0;
    (val)->rcpcCodeRate += 8;
    if (!ASN1Dec_H223AL3MParameters_arqType(dec, &(val)->arqType))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alpduInterleaving))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V76HDLCParameters(ASN1encoding_t enc, V76HDLCParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_CRCLength(enc, &(val)->crcLength))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->n401 - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->loopbackTestProcedure))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76HDLCParameters(ASN1decoding_t dec, V76HDLCParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_CRCLength(dec, &(val)->crcLength))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->n401))
	return 0;
    (val)->n401 += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->loopbackTestProcedure))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UnicastAddress(ASN1encoding_t enc, UnicastAddress *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 5))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_UnicastAddress_iPAddress(enc, &(val)->u.iPAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_UnicastAddress_iPXAddress(enc, &(val)->u.iPXAddress))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_UnicastAddress_iP6Address(enc, &(val)->u.iP6Address))
	    return 0;
	break;
    case 4:
	if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_UnicastAddress_iPSourceRouteAddress(enc, &(val)->u.iPSourceRouteAddress))
	    return 0;
	break;
    case 6:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncOctetString_VarSize(ee, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 7:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_NonStandardParameter(ee, &(val)->u.nonStandardAddress))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress(ASN1decoding_t dec, UnicastAddress *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 5))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_UnicastAddress_iPAddress(dec, &(val)->u.iPAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_UnicastAddress_iPXAddress(dec, &(val)->u.iPXAddress))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_UnicastAddress_iP6Address(dec, &(val)->u.iP6Address))
	    return 0;
	break;
    case 4:
	if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_UnicastAddress_iPSourceRouteAddress(dec, &(val)->u.iPSourceRouteAddress))
	    return 0;
	break;
    case 6:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1PERDecOctetString_VarSize(dd, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 7:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_NonStandardParameter(dd, &(val)->u.nonStandardAddress))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress(UnicastAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_UnicastAddress_iPAddress(&(val)->u.iPAddress);
	    break;
	case 2:
	    ASN1Free_UnicastAddress_iPXAddress(&(val)->u.iPXAddress);
	    break;
	case 3:
	    ASN1Free_UnicastAddress_iP6Address(&(val)->u.iP6Address);
	    break;
	case 4:
	    break;
	case 5:
	    ASN1Free_UnicastAddress_iPSourceRouteAddress(&(val)->u.iPSourceRouteAddress);
	    break;
	case 6:
	    break;
	case 7:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardAddress);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MulticastAddress(ASN1encoding_t enc, MulticastAddress *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_MulticastAddress_iPAddress(enc, &(val)->u.iPAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MulticastAddress_iP6Address(enc, &(val)->u.iP6Address))
	    return 0;
	break;
    case 3:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncOctetString_VarSize(ee, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 4:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_NonStandardParameter(ee, &(val)->u.nonStandardAddress))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MulticastAddress(ASN1decoding_t dec, MulticastAddress *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_MulticastAddress_iPAddress(dec, &(val)->u.iPAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MulticastAddress_iP6Address(dec, &(val)->u.iP6Address))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1PERDecOctetString_VarSize(dd, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 4:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_NonStandardParameter(dd, &(val)->u.nonStandardAddress))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MulticastAddress(MulticastAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_MulticastAddress_iPAddress(&(val)->u.iPAddress);
	    break;
	case 2:
	    ASN1Free_MulticastAddress_iP6Address(&(val)->u.iP6Address);
	    break;
	case 3:
	    break;
	case 4:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardAddress);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionSync(ASN1encoding_t enc, EncryptionSync *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandard))
	    return 0;
    }
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->synchFlag))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->h235Key, 1, 65535, 16))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_EncryptionSync_escrowentry(enc, &(val)->escrowentry))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionSync(ASN1decoding_t dec, EncryptionSync *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandard))
	    return 0;
    }
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->synchFlag))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->h235Key, 1, 65535, 16))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_EncryptionSync_escrowentry(dec, &(val)->escrowentry))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionSync(EncryptionSync *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandard);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_EncryptionSync_escrowentry(&(val)->escrowentry);
	}
    }
}

static int ASN1CALL ASN1Enc_RequestChannelClose(ASN1encoding_t enc, RequestChannelClose *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[0] & 0x80) {
	    if (!ASN1Enc_QOSCapability(ee, &(val)->qosCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x40) {
	    if (!ASN1Enc_RequestChannelClose_reason(ee, &(val)->reason))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelClose(ASN1decoding_t dec, RequestChannelClose *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_QOSCapability(dd, &(val)->qosCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RequestChannelClose_reason(dd, &(val)->reason))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestChannelClose(RequestChannelClose *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_QOSCapability(&(val)->qosCapability);
	}
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntryDescriptor(ASN1encoding_t enc, MultiplexEntryDescriptor *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->multiplexTableEntryNumber - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_MultiplexEntryDescriptor_elementList(enc, &(val)->elementList))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntryDescriptor(ASN1decoding_t dec, MultiplexEntryDescriptor *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->multiplexTableEntryNumber))
	return 0;
    (val)->multiplexTableEntryNumber += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_MultiplexEntryDescriptor_elementList(dec, &(val)->elementList))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntryDescriptor(MultiplexEntryDescriptor *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_MultiplexEntryDescriptor_elementList(&(val)->elementList);
	}
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendReject(ASN1encoding_t enc, MultiplexEntrySendReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_MultiplexEntrySendReject_rejectionDescriptions(enc, &(val)->rejectionDescriptions))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendReject(ASN1decoding_t dec, MultiplexEntrySendReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_MultiplexEntrySendReject_rejectionDescriptions(dec, &(val)->rejectionDescriptions))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendReject(MultiplexEntrySendReject *val)
{
    if (val) {
	ASN1Free_MultiplexEntrySendReject_rejectionDescriptions(&(val)->rejectionDescriptions);
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject(ASN1encoding_t enc, RequestMultiplexEntryReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntryReject_entryNumbers(enc, &(val)->entryNumbers))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntryReject_rejectionDescriptions(enc, &(val)->rejectionDescriptions))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject(ASN1decoding_t dec, RequestMultiplexEntryReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_RequestMultiplexEntryReject_entryNumbers(dec, &(val)->entryNumbers))
	return 0;
    if (!ASN1Dec_RequestMultiplexEntryReject_rejectionDescriptions(dec, &(val)->rejectionDescriptions))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryReject(RequestMultiplexEntryReject *val)
{
    if (val) {
	ASN1Free_RequestMultiplexEntryReject_entryNumbers(&(val)->entryNumbers);
	ASN1Free_RequestMultiplexEntryReject_rejectionDescriptions(&(val)->rejectionDescriptions);
    }
}

static int ASN1CALL ASN1Enc_H263VideoMode(ASN1encoding_t enc, H263VideoMode *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x80;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1Enc_H263VideoMode_resolution(enc, &(val)->resolution))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unrestrictedVector))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->arithmeticCoding))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->advancedPrediction))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->pbFrames))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[0] & 0x80) {
	    if (!ASN1PEREncBoolean(ee, (val)->errorCompensation))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x40) {
	    if (!ASN1Enc_EnhancementLayerInfo(ee, &(val)->enhancementLayerInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x20) {
	    if (!ASN1Enc_H263Options(ee, &(val)->h263Options))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H263VideoMode(ASN1decoding_t dec, H263VideoMode *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H263VideoMode_resolution(dec, &(val)->resolution))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->unrestrictedVector))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->arithmeticCoding))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->advancedPrediction))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->pbFrames))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->errorCompensation))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_EnhancementLayerInfo(dd, &(val)->enhancementLayerInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H263Options(dd, &(val)->h263Options))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H263VideoMode(H263VideoMode *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1Free_EnhancementLayerInfo(&(val)->enhancementLayerInfo);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_H263Options(&(val)->h263Options);
	}
    }
}

static int ASN1CALL ASN1Enc_AudioMode(ASN1encoding_t enc, AudioMode *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	break;
    case 11:
	break;
    case 12:
	if (!ASN1Enc_AudioMode_g7231(enc, &(val)->u.g7231))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_IS11172AudioMode(enc, &(val)->u.is11172AudioMode))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_IS13818AudioMode(enc, &(val)->u.is13818AudioMode))
	    return 0;
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 8, (val)->u.g729wAnnexB - 1))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 16:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 8, (val)->u.g729AnnexAwAnnexB - 1))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 17:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_G7231AnnexCMode(ee, &(val)->u.g7231AnnexCMode))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 18:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmFullRate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 19:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmHalfRate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 20:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmEnhancedFullRate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AudioMode(ASN1decoding_t dec, AudioMode *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	break;
    case 11:
	break;
    case 12:
	if (!ASN1Dec_AudioMode_g7231(dec, &(val)->u.g7231))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_IS11172AudioMode(dec, &(val)->u.is11172AudioMode))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_IS13818AudioMode(dec, &(val)->u.is13818AudioMode))
	    return 0;
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU16Val(dd, 8, &(val)->u.g729wAnnexB))
	    return 0;
	(val)->u.g729wAnnexB += 1;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 16:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU16Val(dd, 8, &(val)->u.g729AnnexAwAnnexB))
	    return 0;
	(val)->u.g729AnnexAwAnnexB += 1;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 17:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_G7231AnnexCMode(dd, &(val)->u.g7231AnnexCMode))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 18:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmFullRate))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 19:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmHalfRate))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 20:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmEnhancedFullRate))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AudioMode(AudioMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionMode(ASN1encoding_t enc, EncryptionMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionMode(ASN1decoding_t dec, EncryptionMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionMode(EncryptionMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceRequest(ASN1encoding_t enc, ConferenceRequest *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 8))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.dropTerminal))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.requestTerminalID))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 10:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceRequest_requestTerminalCertificate(ee, &(val)->u.requestTerminalCertificate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncUnsignedShort(ee, (val)->u.broadcastMyLogicalChannel - 1))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 13:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TerminalLabel(ee, &(val)->u.makeTerminalBroadcaster))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 14:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TerminalLabel(ee, &(val)->u.sendThisSource))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 16:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_RemoteMCRequest(ee, &(val)->u.remoteMCRequest))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceRequest(ASN1decoding_t dec, ConferenceRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 8))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.dropTerminal))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.requestTerminalID))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 10:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceRequest_requestTerminalCertificate(dd, &(val)->u.requestTerminalCertificate))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1PERDecUnsignedShort(dd, &(val)->u.broadcastMyLogicalChannel))
	    return 0;
	(val)->u.broadcastMyLogicalChannel += 1;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 13:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_TerminalLabel(dd, &(val)->u.makeTerminalBroadcaster))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 14:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_TerminalLabel(dd, &(val)->u.sendThisSource))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 16:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_RemoteMCRequest(dd, &(val)->u.remoteMCRequest))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceRequest(ConferenceRequest *val)
{
    if (val) {
	switch ((val)->choice) {
	case 11:
	    ASN1Free_ConferenceRequest_requestTerminalCertificate(&(val)->u.requestTerminalCertificate);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CertSelectionCriteria(ASN1encoding_t enc, PCertSelectionCriteria *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CertSelectionCriteria_ElmFn, 1, 16, 4);
}

static int ASN1CALL ASN1Enc_CertSelectionCriteria_ElmFn(ASN1encoding_t enc, PCertSelectionCriteria val)
{
    if (!ASN1Enc_Criteria(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertSelectionCriteria(ASN1decoding_t dec, PCertSelectionCriteria *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CertSelectionCriteria_ElmFn, sizeof(**val), 1, 16, 4);
}

static int ASN1CALL ASN1Dec_CertSelectionCriteria_ElmFn(ASN1decoding_t dec, PCertSelectionCriteria val)
{
    if (!ASN1Dec_Criteria(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertSelectionCriteria(PCertSelectionCriteria *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CertSelectionCriteria_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CertSelectionCriteria_ElmFn(PCertSelectionCriteria val)
{
    if (val) {
	ASN1Free_Criteria(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse(ASN1encoding_t enc, ConferenceResponse *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 8))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ConferenceResponse_mCTerminalIDResponse(enc, &(val)->u.mCTerminalIDResponse))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ConferenceResponse_terminalIDResponse(enc, &(val)->u.terminalIDResponse))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ConferenceResponse_conferenceIDResponse(enc, &(val)->u.conferenceIDResponse))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ConferenceResponse_passwordResponse(enc, &(val)->u.passwordResponse))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_ConferenceResponse_terminalListResponse(enc, &(val)->u.terminalListResponse))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	if (!ASN1Enc_ConferenceResponse_makeMeChairResponse(enc, &(val)->u.makeMeChairResponse))
	    return 0;
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceResponse_extensionAddressResponse(ee, &(val)->u.extensionAddressResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 10:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceResponse_chairTokenOwnerResponse(ee, &(val)->u.chairTokenOwnerResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceResponse_terminalCertificateResponse(ee, &(val)->u.terminalCertificateResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceResponse_broadcastMyLogicalChannelResponse(ee, &(val)->u.broadcastMyLogicalChannelResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 13:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceResponse_makeTerminalBroadcasterResponse(ee, &(val)->u.makeTerminalBroadcasterResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 14:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceResponse_sendThisSourceResponse(ee, &(val)->u.sendThisSourceResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_RequestAllTerminalIDsResponse(ee, &(val)->u.requestAllTerminalIDsResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 16:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_RemoteMCResponse(ee, &(val)->u.remoteMCResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse(ASN1decoding_t dec, ConferenceResponse *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 8))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ConferenceResponse_mCTerminalIDResponse(dec, &(val)->u.mCTerminalIDResponse))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ConferenceResponse_terminalIDResponse(dec, &(val)->u.terminalIDResponse))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ConferenceResponse_conferenceIDResponse(dec, &(val)->u.conferenceIDResponse))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ConferenceResponse_passwordResponse(dec, &(val)->u.passwordResponse))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_ConferenceResponse_terminalListResponse(dec, &(val)->u.terminalListResponse))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	if (!ASN1Dec_ConferenceResponse_makeMeChairResponse(dec, &(val)->u.makeMeChairResponse))
	    return 0;
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceResponse_extensionAddressResponse(dd, &(val)->u.extensionAddressResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 10:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceResponse_chairTokenOwnerResponse(dd, &(val)->u.chairTokenOwnerResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceResponse_terminalCertificateResponse(dd, &(val)->u.terminalCertificateResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceResponse_broadcastMyLogicalChannelResponse(dd, &(val)->u.broadcastMyLogicalChannelResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 13:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceResponse_makeTerminalBroadcasterResponse(dd, &(val)->u.makeTerminalBroadcasterResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 14:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceResponse_sendThisSourceResponse(dd, &(val)->u.sendThisSourceResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_RequestAllTerminalIDsResponse(dd, &(val)->u.requestAllTerminalIDsResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 16:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_RemoteMCResponse(dd, &(val)->u.remoteMCResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse(ConferenceResponse *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ConferenceResponse_mCTerminalIDResponse(&(val)->u.mCTerminalIDResponse);
	    break;
	case 2:
	    ASN1Free_ConferenceResponse_terminalIDResponse(&(val)->u.terminalIDResponse);
	    break;
	case 3:
	    ASN1Free_ConferenceResponse_conferenceIDResponse(&(val)->u.conferenceIDResponse);
	    break;
	case 4:
	    ASN1Free_ConferenceResponse_passwordResponse(&(val)->u.passwordResponse);
	    break;
	case 5:
	    ASN1Free_ConferenceResponse_terminalListResponse(&(val)->u.terminalListResponse);
	    break;
	case 9:
	    ASN1Free_ConferenceResponse_extensionAddressResponse(&(val)->u.extensionAddressResponse);
	    break;
	case 10:
	    ASN1Free_ConferenceResponse_chairTokenOwnerResponse(&(val)->u.chairTokenOwnerResponse);
	    break;
	case 11:
	    ASN1Free_ConferenceResponse_terminalCertificateResponse(&(val)->u.terminalCertificateResponse);
	    break;
	case 15:
	    ASN1Free_RequestAllTerminalIDsResponse(&(val)->u.requestAllTerminalIDsResponse);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EndSessionCommand(ASN1encoding_t enc, EndSessionCommand *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_EndSessionCommand_gstnOptions(enc, &(val)->u.gstnOptions))
	    return 0;
	break;
    case 4:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_EndSessionCommand_isdnOptions(ee, &(val)->u.isdnOptions))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EndSessionCommand(ASN1decoding_t dec, EndSessionCommand *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_EndSessionCommand_gstnOptions(dec, &(val)->u.gstnOptions))
	    return 0;
	break;
    case 4:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_EndSessionCommand_isdnOptions(dd, &(val)->u.isdnOptions))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EndSessionCommand(EndSessionCommand *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceCommand(ASN1encoding_t enc, ConferenceCommand *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.broadcastMyLogicalChannel - 1))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.cancelBroadcastMyLogicalChannel - 1))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.makeTerminalBroadcaster))
	    return 0;
	break;
    case 4:
	break;
    case 5:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.sendThisSource))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_SubstituteConferenceIDCommand(ee, &(val)->u.substituteConferenceIDCommand))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceCommand(ASN1decoding_t dec, ConferenceCommand *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.broadcastMyLogicalChannel))
	    return 0;
	(val)->u.broadcastMyLogicalChannel += 1;
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.cancelBroadcastMyLogicalChannel))
	    return 0;
	(val)->u.cancelBroadcastMyLogicalChannel += 1;
	break;
    case 3:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.makeTerminalBroadcaster))
	    return 0;
	break;
    case 4:
	break;
    case 5:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.sendThisSource))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_SubstituteConferenceIDCommand(dd, &(val)->u.substituteConferenceIDCommand))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceCommand(ConferenceCommand *val)
{
    if (val) {
	switch ((val)->choice) {
	case 8:
	    ASN1Free_SubstituteConferenceIDCommand(&(val)->u.substituteConferenceIDCommand);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_UserInputIndication_userInputSupportIndication(ASN1encoding_t enc, UserInputIndication_userInputSupportIndication *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication_userInputSupportIndication(ASN1decoding_t dec, UserInputIndication_userInputSupportIndication *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserInputIndication_userInputSupportIndication(UserInputIndication_userInputSupportIndication *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MiscellaneousIndication_type(ASN1encoding_t enc, MiscellaneousIndication_type *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	if (!ASN1PEREncBitVal(enc, 5, (val)->u.videoTemporalSpatialTradeOff))
	    return 0;
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_MiscellaneousIndication_type_videoNotDecodedMBs(ee, &(val)->u.videoNotDecodedMBs))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TransportCapability(ee, &(val)->u.transportCapability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousIndication_type(ASN1decoding_t dec, MiscellaneousIndication_type *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	if (!ASN1PERDecU16Val(dec, 5, &(val)->u.videoTemporalSpatialTradeOff))
	    return 0;
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_MiscellaneousIndication_type_videoNotDecodedMBs(dd, &(val)->u.videoNotDecodedMBs))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_TransportCapability(dd, &(val)->u.transportCapability))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MiscellaneousIndication_type(MiscellaneousIndication_type *val)
{
    if (val) {
	switch ((val)->choice) {
	case 12:
	    ASN1Free_TransportCapability(&(val)->u.transportCapability);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand_type(ASN1encoding_t enc, MiscellaneousCommand_type *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	if (!ASN1Enc_MiscellaneousCommand_type_videoFastUpdateGOB(enc, &(val)->u.videoFastUpdateGOB))
	    return 0;
	break;
    case 8:
	if (!ASN1PEREncBitVal(enc, 5, (val)->u.videoTemporalSpatialTradeOff))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_MiscellaneousCommand_type_videoFastUpdateMB(ee, &(val)->u.videoFastUpdateMB))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncUnsignedShort(ee, (val)->u.maxH223MUXPDUsize - 1))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 13:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_EncryptionSync(ee, &(val)->u.encryptionUpdate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 14:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_EncryptionUpdateRequest(ee, &(val)->u.encryptionUpdateRequest))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 16:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 17:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart(ee, &(val)->u.progressiveRefinementStart))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 18:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 19:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand_type(ASN1decoding_t dec, MiscellaneousCommand_type *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	if (!ASN1Dec_MiscellaneousCommand_type_videoFastUpdateGOB(dec, &(val)->u.videoFastUpdateGOB))
	    return 0;
	break;
    case 8:
	if (!ASN1PERDecU16Val(dec, 5, &(val)->u.videoTemporalSpatialTradeOff))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_MiscellaneousCommand_type_videoFastUpdateMB(dd, &(val)->u.videoFastUpdateMB))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1PERDecUnsignedShort(dd, &(val)->u.maxH223MUXPDUsize))
	    return 0;
	(val)->u.maxH223MUXPDUsize += 1;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 13:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_EncryptionSync(dd, &(val)->u.encryptionUpdate))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 14:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_EncryptionUpdateRequest(dd, &(val)->u.encryptionUpdateRequest))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 16:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 17:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart(dd, &(val)->u.progressiveRefinementStart))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 18:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 19:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MiscellaneousCommand_type(MiscellaneousCommand_type *val)
{
    if (val) {
	switch ((val)->choice) {
	case 13:
	    ASN1Free_EncryptionSync(&(val)->u.encryptionUpdate);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionCommand_encryptionAlgorithmID(ASN1encoding_t enc, EncryptionCommand_encryptionAlgorithmID *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->h233AlgorithmIdentifier))
	return 0;
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->associatedAlgorithm))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionCommand_encryptionAlgorithmID(ASN1decoding_t dec, EncryptionCommand_encryptionAlgorithmID *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->h233AlgorithmIdentifier))
	return 0;
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->associatedAlgorithm))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionCommand_encryptionAlgorithmID(EncryptionCommand_encryptionAlgorithmID *val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&(val)->associatedAlgorithm);
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CommunicationModeTableEntry_nonStandard_ElmFn);
}

static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CommunicationModeTableEntry_nonStandard_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard(PCommunicationModeTableEntry_nonStandard *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CommunicationModeTableEntry_nonStandard_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard_ElmFn(PCommunicationModeTableEntry_nonStandard val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncodingMode_secondaryEncoding(ASN1encoding_t enc, RedundancyEncodingMode_secondaryEncoding *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_AudioMode(enc, &(val)->u.audioData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncodingMode_secondaryEncoding(ASN1decoding_t dec, RedundancyEncodingMode_secondaryEncoding *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_AudioMode(dec, &(val)->u.audioData))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncodingMode_secondaryEncoding(RedundancyEncodingMode_secondaryEncoding *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_AudioMode(&(val)->u.audioData);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H223ModeParameters_adaptationLayerType(ASN1encoding_t enc, H223ModeParameters_adaptationLayerType *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Enc_H223ModeParameters_adaptationLayerType_al3(enc, &(val)->u.al3))
	    return 0;
	break;
    case 7:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AL1MParameters(ee, &(val)->u.al1M))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 8:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AL2MParameters(ee, &(val)->u.al2M))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AL3MParameters(ee, &(val)->u.al3M))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223ModeParameters_adaptationLayerType(ASN1decoding_t dec, H223ModeParameters_adaptationLayerType *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Dec_H223ModeParameters_adaptationLayerType_al3(dec, &(val)->u.al3))
	    return 0;
	break;
    case 7:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H223AL1MParameters(dd, &(val)->u.al1M))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 8:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H223AL2MParameters(dd, &(val)->u.al2M))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H223AL3MParameters(dd, &(val)->u.al3M))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223ModeParameters_adaptationLayerType(H223ModeParameters_adaptationLayerType *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn, 1, 15, 4);
}

static int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors val)
{
    if (!ASN1Enc_MultiplexEntryDescriptor(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn, sizeof(**val), 1, 15, 4);
}

static int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors val)
{
    if (!ASN1Dec_MultiplexEntryDescriptor(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors(PMultiplexEntrySend_multiplexEntryDescriptors *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn);
    }
}

static void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(PMultiplexEntrySend_multiplexEntryDescriptors val)
{
    if (val) {
	ASN1Free_MultiplexEntryDescriptor(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H2250LogicalChannelAckParameters_nonStandard_ElmFn);
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H2250LogicalChannelAckParameters_nonStandard_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard(PH2250LogicalChannelAckParameters_nonStandard *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H2250LogicalChannelAckParameters_nonStandard_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard_ElmFn(PH2250LogicalChannelAckParameters_nonStandard val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RTPPayloadType_payloadDescriptor(ASN1encoding_t enc, RTPPayloadType_payloadDescriptor *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardIdentifier))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncExtensionBitClear(enc))
	    return 0;
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.rfc_number - 1))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.oid))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPPayloadType_payloadDescriptor(ASN1decoding_t dec, RTPPayloadType_payloadDescriptor *val)
{
    ASN1uint32_t x;
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardIdentifier))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecExtensionBit(dec, &x))
	    return 0;
	if (!x) {
	    if (!ASN1PERDecUnsignedShort(dec, &(val)->u.rfc_number))
		return 0;
	    (val)->u.rfc_number += 1;
	} else {
	    ASN1PERDecAlignment(dec);
	    if (!ASN1PERDecFragmentedLength(dec, &l))
		return 0;
	    if (!ASN1PERDecSkipBits(dec, l * 8))
		return 0;
	}
	break;
    case 3:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.oid))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPPayloadType_payloadDescriptor(RTPPayloadType_payloadDescriptor *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardIdentifier);
	    break;
	case 3:
	    ASN1objectidentifier_free(&(val)->u.oid);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H2250LogicalChannelParameters_nonStandard_ElmFn);
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H2250LogicalChannelParameters_nonStandard_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard(PH2250LogicalChannelParameters_nonStandard *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H2250LogicalChannelParameters_nonStandard_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard_ElmFn(PH2250LogicalChannelParameters_nonStandard val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H223LogicalChannelParameters_adaptationLayerType(ASN1encoding_t enc, H223LogicalChannelParameters_adaptationLayerType *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Enc_H223LogicalChannelParameters_adaptationLayerType_al3(enc, &(val)->u.al3))
	    return 0;
	break;
    case 7:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AL1MParameters(ee, &(val)->u.al1M))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 8:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AL2MParameters(ee, &(val)->u.al2M))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AL3MParameters(ee, &(val)->u.al3M))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223LogicalChannelParameters_adaptationLayerType(ASN1decoding_t dec, H223LogicalChannelParameters_adaptationLayerType *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Dec_H223LogicalChannelParameters_adaptationLayerType_al3(dec, &(val)->u.al3))
	    return 0;
	break;
    case 7:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H223AL1MParameters(dd, &(val)->u.al1M))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 8:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H223AL2MParameters(dd, &(val)->u.al2M))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H223AL3MParameters(dd, &(val)->u.al3M))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223LogicalChannelParameters_adaptationLayerType(H223LogicalChannelParameters_adaptationLayerType *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData(ASN1encoding_t enc, PConferenceCapability_nonStandardData *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConferenceCapability_nonStandardData_ElmFn);
}

static int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData_ElmFn(ASN1encoding_t enc, PConferenceCapability_nonStandardData val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData(ASN1decoding_t dec, PConferenceCapability_nonStandardData *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConferenceCapability_nonStandardData_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData_ElmFn(ASN1decoding_t dec, PConferenceCapability_nonStandardData val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData(PConferenceCapability_nonStandardData *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConferenceCapability_nonStandardData_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData_ElmFn(PConferenceCapability_nonStandardData val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UserInputCapability_nonStandard(ASN1encoding_t enc, UserInputCapability_nonStandard *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_NonStandardParameter(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputCapability_nonStandard(ASN1decoding_t dec, UserInputCapability_nonStandard *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_NonStandardParameter(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserInputCapability_nonStandard(UserInputCapability_nonStandard *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (val)->count; i++) {
	    ASN1Free_NonStandardParameter(&(val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_DataProtocolCapability_v76wCompression(ASN1encoding_t enc, DataProtocolCapability_v76wCompression *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_CompressionType(enc, &(val)->u.transmitCompression))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_CompressionType(enc, &(val)->u.receiveCompression))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_CompressionType(enc, &(val)->u.transmitAndReceiveCompression))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataProtocolCapability_v76wCompression(ASN1decoding_t dec, DataProtocolCapability_v76wCompression *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_CompressionType(dec, &(val)->u.transmitCompression))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_CompressionType(dec, &(val)->u.receiveCompression))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_CompressionType(dec, &(val)->u.transmitAndReceiveCompression))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H263Options_modeCombos(ASN1encoding_t enc, PH263Options_modeCombos *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H263Options_modeCombos_ElmFn, 1, 16, 4);
}

static int ASN1CALL ASN1Enc_H263Options_modeCombos_ElmFn(ASN1encoding_t enc, PH263Options_modeCombos val)
{
    if (!ASN1Enc_H263VideoModeCombos(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263Options_modeCombos(ASN1decoding_t dec, PH263Options_modeCombos *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H263Options_modeCombos_ElmFn, sizeof(**val), 1, 16, 4);
}

static int ASN1CALL ASN1Dec_H263Options_modeCombos_ElmFn(ASN1decoding_t dec, PH263Options_modeCombos val)
{
    if (!ASN1Dec_H263VideoModeCombos(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H263Options_modeCombos(PH263Options_modeCombos *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H263Options_modeCombos_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H263Options_modeCombos_ElmFn(PH263Options_modeCombos val)
{
    if (val) {
	ASN1Free_H263VideoModeCombos(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TransportCapability_qOSCapabilities(ASN1encoding_t enc, PTransportCapability_qOSCapabilities *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TransportCapability_qOSCapabilities_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_TransportCapability_qOSCapabilities_ElmFn(ASN1encoding_t enc, PTransportCapability_qOSCapabilities val)
{
    if (!ASN1Enc_QOSCapability(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportCapability_qOSCapabilities(ASN1decoding_t dec, PTransportCapability_qOSCapabilities *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TransportCapability_qOSCapabilities_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_TransportCapability_qOSCapabilities_ElmFn(ASN1decoding_t dec, PTransportCapability_qOSCapabilities val)
{
    if (!ASN1Dec_QOSCapability(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportCapability_qOSCapabilities(PTransportCapability_qOSCapabilities *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TransportCapability_qOSCapabilities_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TransportCapability_qOSCapabilities_ElmFn(PTransportCapability_qOSCapabilities val)
{
    if (val) {
	ASN1Free_QOSCapability(&val->value);
    }
}

static int ASN1CALL ASN1Enc_NonStandardMessage(ASN1encoding_t enc, NonStandardMessage *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardData))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardMessage(ASN1decoding_t dec, NonStandardMessage *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardData))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardMessage(NonStandardMessage *val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&(val)->nonStandardData);
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncodingCapability(ASN1encoding_t enc, RedundancyEncodingCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_RedundancyEncodingMethod(enc, &(val)->redundancyEncodingMethod))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->primaryEncoding - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_RedundancyEncodingCapability_secondaryEncoding(enc, &(val)->secondaryEncoding))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncodingCapability(ASN1decoding_t dec, RedundancyEncodingCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_RedundancyEncodingMethod(dec, &(val)->redundancyEncodingMethod))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->primaryEncoding))
	return 0;
    (val)->primaryEncoding += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_RedundancyEncodingCapability_secondaryEncoding(dec, &(val)->secondaryEncoding))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncodingCapability(RedundancyEncodingCapability *val)
{
    if (val) {
	ASN1Free_RedundancyEncodingMethod(&(val)->redundancyEncodingMethod);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_RedundancyEncodingCapability_secondaryEncoding(&(val)->secondaryEncoding);
	}
    }
}

static int ASN1CALL ASN1Enc_H263VideoCapability(ASN1encoding_t enc, H263VideoCapability *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x4;
    y = ASN1PEREncCheckExtensions(8, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 7, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->sqcifMPI - 1))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->qcifMPI - 1))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->cifMPI - 1))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->cif4MPI - 1))
	    return 0;
    }
    if (o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->cif16MPI - 1))
	    return 0;
    }
    l = ASN1uint32_uoctets((val)->maxBitRate - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->maxBitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unrestrictedVector))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->arithmeticCoding))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->advancedPrediction))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->pbFrames))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->temporalSpatialTradeOffCapability))
	return 0;
    if (o[0] & 0x4) {
	l = ASN1uint32_uoctets((val)->hrd_B);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->hrd_B))
	    return 0;
    }
    if (o[0] & 0x2) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->bppMaxKb))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 8, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->slowSqcifMPI - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->slowQcifMPI - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->slowCifMPI - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->slowCif4MPI - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->slowCif16MPI - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1PEREncBoolean(ee, (val)->errorCompensation))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x2) {
	    if (!ASN1Enc_EnhancementLayerInfo(ee, &(val)->enhancementLayerInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x1) {
	    if (!ASN1Enc_H263Options(ee, &(val)->h263Options))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H263VideoCapability(ASN1decoding_t dec, H263VideoCapability *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->sqcifMPI))
	    return 0;
	(val)->sqcifMPI += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->qcifMPI))
	    return 0;
	(val)->qcifMPI += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->cifMPI))
	    return 0;
	(val)->cifMPI += 1;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->cif4MPI))
	    return 0;
	(val)->cif4MPI += 1;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->cif16MPI))
	    return 0;
	(val)->cif16MPI += 1;
    }
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->maxBitRate))
	return 0;
    (val)->maxBitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->unrestrictedVector))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->arithmeticCoding))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->advancedPrediction))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->pbFrames))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->temporalSpatialTradeOffCapability))
	return 0;
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->hrd_B))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->bppMaxKb))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 8, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->slowSqcifMPI))
		return 0;
	    (val)->slowSqcifMPI += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->slowQcifMPI))
		return 0;
	    (val)->slowQcifMPI += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->slowCifMPI))
		return 0;
	    (val)->slowCifMPI += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->slowCif4MPI))
		return 0;
	    (val)->slowCif4MPI += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->slowCif16MPI))
		return 0;
	    (val)->slowCif16MPI += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->errorCompensation))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_EnhancementLayerInfo(dd, &(val)->enhancementLayerInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H263Options(dd, &(val)->h263Options))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H263VideoCapability(H263VideoCapability *val)
{
    if (val) {
	if ((val)->o[1] & 0x2) {
	    ASN1Free_EnhancementLayerInfo(&(val)->enhancementLayerInfo);
	}
	if ((val)->o[1] & 0x1) {
	    ASN1Free_H263Options(&(val)->h263Options);
	}
    }
}

static int ASN1CALL ASN1Enc_EnhancementOptions(ASN1encoding_t enc, EnhancementOptions *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 11, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->sqcifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->qcifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->cifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->cif4MPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->cif16MPI - 1))
	    return 0;
    }
    l = ASN1uint32_uoctets((val)->maxBitRate - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->maxBitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unrestrictedVector))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->arithmeticCoding))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->temporalSpatialTradeOffCapability))
	return 0;
    if ((val)->o[0] & 0x4) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->slowSqcifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->slowQcifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->slowCifMPI - 1))
	    return 0;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->slowCif4MPI - 1))
	    return 0;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->slowCif16MPI - 1))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->errorCompensation))
	return 0;
    if ((val)->o[1] & 0x20) {
	if (!ASN1Enc_H263Options(enc, &(val)->h263Options))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancementOptions(ASN1decoding_t dec, EnhancementOptions *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 11, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->sqcifMPI))
	    return 0;
	(val)->sqcifMPI += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->qcifMPI))
	    return 0;
	(val)->qcifMPI += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->cifMPI))
	    return 0;
	(val)->cifMPI += 1;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->cif4MPI))
	    return 0;
	(val)->cif4MPI += 1;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->cif16MPI))
	    return 0;
	(val)->cif16MPI += 1;
    }
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->maxBitRate))
	return 0;
    (val)->maxBitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->unrestrictedVector))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->arithmeticCoding))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->temporalSpatialTradeOffCapability))
	return 0;
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->slowSqcifMPI))
	    return 0;
	(val)->slowSqcifMPI += 1;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->slowQcifMPI))
	    return 0;
	(val)->slowQcifMPI += 1;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->slowCifMPI))
	    return 0;
	(val)->slowCifMPI += 1;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->slowCif4MPI))
	    return 0;
	(val)->slowCif4MPI += 1;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->slowCif16MPI))
	    return 0;
	(val)->slowCif16MPI += 1;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->errorCompensation))
	return 0;
    if ((val)->o[1] & 0x20) {
	if (!ASN1Dec_H263Options(dec, &(val)->h263Options))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EnhancementOptions(EnhancementOptions *val)
{
    if (val) {
	if ((val)->o[1] & 0x20) {
	    ASN1Free_H263Options(&(val)->h263Options);
	}
    }
}

static int ASN1CALL ASN1Enc_DataProtocolCapability(ASN1encoding_t enc, DataProtocolCapability *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 10:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_DataProtocolCapability_v76wCompression(ee, &(val)->u.v76wCompression))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataProtocolCapability(ASN1decoding_t dec, DataProtocolCapability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 10:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_DataProtocolCapability_v76wCompression(dd, &(val)->u.v76wCompression))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataProtocolCapability(DataProtocolCapability *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionAuthenticationAndIntegrity(ASN1encoding_t enc, EncryptionAuthenticationAndIntegrity *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_EncryptionCapability(enc, &(val)->encryptionCapability))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_AuthenticationCapability(enc, &(val)->authenticationCapability))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_IntegrityCapability(enc, &(val)->integrityCapability))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionAuthenticationAndIntegrity(ASN1decoding_t dec, EncryptionAuthenticationAndIntegrity *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_EncryptionCapability(dec, &(val)->encryptionCapability))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_AuthenticationCapability(dec, &(val)->authenticationCapability))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_IntegrityCapability(dec, &(val)->integrityCapability))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionAuthenticationAndIntegrity(EncryptionAuthenticationAndIntegrity *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_EncryptionCapability(&(val)->encryptionCapability);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_AuthenticationCapability(&(val)->authenticationCapability);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_IntegrityCapability(&(val)->integrityCapability);
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionCapability(ASN1encoding_t enc, PEncryptionCapability *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EncryptionCapability_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_EncryptionCapability_ElmFn(ASN1encoding_t enc, PEncryptionCapability val)
{
    if (!ASN1Enc_MediaEncryptionAlgorithm(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionCapability(ASN1decoding_t dec, PEncryptionCapability *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EncryptionCapability_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_EncryptionCapability_ElmFn(ASN1decoding_t dec, PEncryptionCapability val)
{
    if (!ASN1Dec_MediaEncryptionAlgorithm(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionCapability(PEncryptionCapability *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EncryptionCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EncryptionCapability_ElmFn(PEncryptionCapability val)
{
    if (val) {
	ASN1Free_MediaEncryptionAlgorithm(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UserInputCapability(ASN1encoding_t enc, UserInputCapability *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_UserInputCapability_nonStandard(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputCapability(ASN1decoding_t dec, UserInputCapability *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_UserInputCapability_nonStandard(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserInputCapability(UserInputCapability *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_UserInputCapability_nonStandard(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H223LogicalChannelParameters(ASN1encoding_t enc, H223LogicalChannelParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H223LogicalChannelParameters_adaptationLayerType(enc, &(val)->adaptationLayerType))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->segmentableFlag))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223LogicalChannelParameters(ASN1decoding_t dec, H223LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H223LogicalChannelParameters_adaptationLayerType(dec, &(val)->adaptationLayerType))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->segmentableFlag))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223LogicalChannelParameters(H223LogicalChannelParameters *val)
{
    if (val) {
	ASN1Free_H223LogicalChannelParameters_adaptationLayerType(&(val)->adaptationLayerType);
    }
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters(ASN1encoding_t enc, V76LogicalChannelParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_V76HDLCParameters(enc, &(val)->hdlcParameters))
	return 0;
    if (!ASN1Enc_V76LogicalChannelParameters_suspendResume(enc, &(val)->suspendResume))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->uIH))
	return 0;
    if (!ASN1Enc_V76LogicalChannelParameters_mode(enc, &(val)->mode))
	return 0;
    if (!ASN1Enc_V75Parameters(enc, &(val)->v75Parameters))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters(ASN1decoding_t dec, V76LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_V76HDLCParameters(dec, &(val)->hdlcParameters))
	return 0;
    if (!ASN1Dec_V76LogicalChannelParameters_suspendResume(dec, &(val)->suspendResume))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->uIH))
	return 0;
    if (!ASN1Dec_V76LogicalChannelParameters_mode(dec, &(val)->mode))
	return 0;
    if (!ASN1Dec_V75Parameters(dec, &(val)->v75Parameters))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RTPPayloadType(ASN1encoding_t enc, RTPPayloadType *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_RTPPayloadType_payloadDescriptor(enc, &(val)->payloadDescriptor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 7, (val)->payloadType))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPPayloadType(ASN1decoding_t dec, RTPPayloadType *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_RTPPayloadType_payloadDescriptor(dec, &(val)->payloadDescriptor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 7, &(val)->payloadType))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPPayloadType(RTPPayloadType *val)
{
    if (val) {
	ASN1Free_RTPPayloadType_payloadDescriptor(&(val)->payloadDescriptor);
    }
}

static int ASN1CALL ASN1Enc_H245TransportAddress(ASN1encoding_t enc, H245TransportAddress *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_UnicastAddress(enc, &(val)->u.unicastAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MulticastAddress(enc, &(val)->u.multicastAddress))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H245TransportAddress(ASN1decoding_t dec, H245TransportAddress *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_UnicastAddress(dec, &(val)->u.unicastAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MulticastAddress(dec, &(val)->u.multicastAddress))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H245TransportAddress(H245TransportAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_UnicastAddress(&(val)->u.unicastAddress);
	    break;
	case 2:
	    ASN1Free_MulticastAddress(&(val)->u.multicastAddress);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters(ASN1encoding_t enc, H2250LogicalChannelAckParameters *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 5, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H2250LogicalChannelAckParameters_nonStandard(enc, &(val)->nonStandard))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 8, (val)->sessionID - 1))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaChannel))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaControlChannel))
	    return 0;
    }
    if (o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->dynamicRTPPayloadType - 96))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1PEREncBoolean(ee, (val)->flowControlToZero))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->portNumber))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters(ASN1decoding_t dec, H2250LogicalChannelAckParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H2250LogicalChannelAckParameters_nonStandard(dec, &(val)->nonStandard))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU16Val(dec, 8, &(val)->sessionID))
	    return 0;
	(val)->sessionID += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaControlChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->dynamicRTPPayloadType))
	    return 0;
	(val)->dynamicRTPPayloadType += 96;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->flowControlToZero))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->portNumber))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters(H2250LogicalChannelAckParameters *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H2250LogicalChannelAckParameters_nonStandard(&(val)->nonStandard);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_H245TransportAddress(&(val)->mediaChannel);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_H245TransportAddress(&(val)->mediaControlChannel);
	}
    }
}

static int ASN1CALL ASN1Enc_H223ModeParameters(ASN1encoding_t enc, H223ModeParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H223ModeParameters_adaptationLayerType(enc, &(val)->adaptationLayerType))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->segmentableFlag))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223ModeParameters(ASN1decoding_t dec, H223ModeParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H223ModeParameters_adaptationLayerType(dec, &(val)->adaptationLayerType))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->segmentableFlag))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223ModeParameters(H223ModeParameters *val)
{
    if (val) {
	ASN1Free_H223ModeParameters_adaptationLayerType(&(val)->adaptationLayerType);
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncodingMode(ASN1encoding_t enc, RedundancyEncodingMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_RedundancyEncodingMethod(enc, &(val)->redundancyEncodingMethod))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_RedundancyEncodingMode_secondaryEncoding(enc, &(val)->secondaryEncoding))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncodingMode(ASN1decoding_t dec, RedundancyEncodingMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_RedundancyEncodingMethod(dec, &(val)->redundancyEncodingMethod))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_RedundancyEncodingMode_secondaryEncoding(dec, &(val)->secondaryEncoding))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncodingMode(RedundancyEncodingMode *val)
{
    if (val) {
	ASN1Free_RedundancyEncodingMethod(&(val)->redundancyEncodingMethod);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_RedundancyEncodingMode_secondaryEncoding(&(val)->secondaryEncoding);
	}
    }
}

static int ASN1CALL ASN1Enc_VideoMode(ASN1encoding_t enc, VideoMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H261VideoMode(enc, &(val)->u.h261VideoMode))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H262VideoMode(enc, &(val)->u.h262VideoMode))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_H263VideoMode(enc, &(val)->u.h263VideoMode))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_IS11172VideoMode(enc, &(val)->u.is11172VideoMode))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VideoMode(ASN1decoding_t dec, VideoMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H261VideoMode(dec, &(val)->u.h261VideoMode))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H262VideoMode(dec, &(val)->u.h262VideoMode))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_H263VideoMode(dec, &(val)->u.h263VideoMode))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_IS11172VideoMode(dec, &(val)->u.is11172VideoMode))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_VideoMode(VideoMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 4:
	    ASN1Free_H263VideoMode(&(val)->u.h263VideoMode);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionCommand(ASN1encoding_t enc, EncryptionCommand *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->u.encryptionSE))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_EncryptionCommand_encryptionAlgorithmID(enc, &(val)->u.encryptionAlgorithmID))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionCommand(ASN1decoding_t dec, EncryptionCommand *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->u.encryptionSE))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_EncryptionCommand_encryptionAlgorithmID(dec, &(val)->u.encryptionAlgorithmID))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionCommand(EncryptionCommand *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1octetstring_free(&(val)->u.encryptionSE);
	    break;
	case 3:
	    ASN1Free_EncryptionCommand_encryptionAlgorithmID(&(val)->u.encryptionAlgorithmID);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand(ASN1encoding_t enc, MiscellaneousCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_MiscellaneousCommand_type(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand(ASN1decoding_t dec, MiscellaneousCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber))
	return 0;
    (val)->logicalChannelNumber += 1;
    if (!ASN1Dec_MiscellaneousCommand_type(dec, &(val)->type))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MiscellaneousCommand(MiscellaneousCommand *val)
{
    if (val) {
	ASN1Free_MiscellaneousCommand_type(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_MiscellaneousIndication(ASN1encoding_t enc, MiscellaneousIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_MiscellaneousIndication_type(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousIndication(ASN1decoding_t dec, MiscellaneousIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber))
	return 0;
    (val)->logicalChannelNumber += 1;
    if (!ASN1Dec_MiscellaneousIndication_type(dec, &(val)->type))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MiscellaneousIndication(MiscellaneousIndication *val)
{
    if (val) {
	ASN1Free_MiscellaneousIndication_type(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_MCLocationIndication(ASN1encoding_t enc, MCLocationIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H245TransportAddress(enc, &(val)->signalAddress))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MCLocationIndication(ASN1decoding_t dec, MCLocationIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H245TransportAddress(dec, &(val)->signalAddress))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MCLocationIndication(MCLocationIndication *val)
{
    if (val) {
	ASN1Free_H245TransportAddress(&(val)->signalAddress);
    }
}

static int ASN1CALL ASN1Enc_UserInputIndication(ASN1encoding_t enc, UserInputIndication *val)
{
    ASN1uint32_t t;
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	t = lstrlenA((val)->u.alphanumeric);
	if (!ASN1PEREncFragmentedCharString(enc, t, (val)->u.alphanumeric, 8))
	    return 0;
	break;
    case 3:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_UserInputIndication_userInputSupportIndication(ee, &(val)->u.userInputSupportIndication))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 4:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_UserInputIndication_signal(ee, &(val)->u.signal))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 5:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_UserInputIndication_signalUpdate(ee, &(val)->u.signalUpdate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication(ASN1decoding_t dec, UserInputIndication *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecFragmentedZeroCharString(dec, &(val)->u.alphanumeric, 8))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_UserInputIndication_userInputSupportIndication(dd, &(val)->u.userInputSupportIndication))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 4:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_UserInputIndication_signal(dd, &(val)->u.signal))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 5:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_UserInputIndication_signalUpdate(dd, &(val)->u.signalUpdate))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserInputIndication(UserInputIndication *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1ztcharstring_free((val)->u.alphanumeric);
	    break;
	case 3:
	    ASN1Free_UserInputIndication_userInputSupportIndication(&(val)->u.userInputSupportIndication);
	    break;
	case 4:
	    ASN1Free_UserInputIndication_signal(&(val)->u.signal);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DataApplicationCapability_application_nlpid(ASN1encoding_t enc, DataApplicationCapability_application_nlpid *val)
{
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->nlpidProtocol))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->nlpidData))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataApplicationCapability_application_nlpid(ASN1decoding_t dec, DataApplicationCapability_application_nlpid *val)
{
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->nlpidProtocol))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->nlpidData))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DataApplicationCapability_application_nlpid(DataApplicationCapability_application_nlpid *val)
{
    if (val) {
	ASN1Free_DataProtocolCapability(&(val)->nlpidProtocol);
	ASN1octetstring_free(&(val)->nlpidData);
    }
}

static int ASN1CALL ASN1Enc_DataApplicationCapability_application_t84(ASN1encoding_t enc, DataApplicationCapability_application_t84 *val)
{
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->t84Protocol))
	return 0;
    if (!ASN1Enc_T84Profile(enc, &(val)->t84Profile))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataApplicationCapability_application_t84(ASN1decoding_t dec, DataApplicationCapability_application_t84 *val)
{
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->t84Protocol))
	return 0;
    if (!ASN1Dec_T84Profile(dec, &(val)->t84Profile))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DataApplicationCapability_application_t84(DataApplicationCapability_application_t84 *val)
{
    if (val) {
	ASN1Free_DataProtocolCapability(&(val)->t84Protocol);
    }
}

static int ASN1CALL ASN1Enc_DataMode_application_nlpid(ASN1encoding_t enc, DataMode_application_nlpid *val)
{
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->nlpidProtocol))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->nlpidData))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataMode_application_nlpid(ASN1decoding_t dec, DataMode_application_nlpid *val)
{
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->nlpidProtocol))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->nlpidData))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DataMode_application_nlpid(DataMode_application_nlpid *val)
{
    if (val) {
	ASN1Free_DataProtocolCapability(&(val)->nlpidProtocol);
	ASN1octetstring_free(&(val)->nlpidData);
    }
}

static int ASN1CALL ASN1Enc_DataMode_application(ASN1encoding_t enc, DataMode_application *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t120))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.dsm_cc))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.userData))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t84))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t434))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.h224))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_DataMode_application_nlpid(enc, &(val)->u.nlpid))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.h222DataPartitioning))
	    return 0;
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_DataProtocolCapability(ee, &(val)->u.t30fax))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_DataProtocolCapability(ee, &(val)->u.t140))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataMode_application(ASN1decoding_t dec, DataMode_application *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t120))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.dsm_cc))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.userData))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t84))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t434))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.h224))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_DataMode_application_nlpid(dec, &(val)->u.nlpid))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.h222DataPartitioning))
	    return 0;
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_DataProtocolCapability(dd, &(val)->u.t30fax))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_DataProtocolCapability(dd, &(val)->u.t140))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataMode_application(DataMode_application *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_DataProtocolCapability(&(val)->u.t120);
	    break;
	case 3:
	    ASN1Free_DataProtocolCapability(&(val)->u.dsm_cc);
	    break;
	case 4:
	    ASN1Free_DataProtocolCapability(&(val)->u.userData);
	    break;
	case 5:
	    ASN1Free_DataProtocolCapability(&(val)->u.t84);
	    break;
	case 6:
	    ASN1Free_DataProtocolCapability(&(val)->u.t434);
	    break;
	case 7:
	    ASN1Free_DataProtocolCapability(&(val)->u.h224);
	    break;
	case 8:
	    ASN1Free_DataMode_application_nlpid(&(val)->u.nlpid);
	    break;
	case 10:
	    ASN1Free_DataProtocolCapability(&(val)->u.h222DataPartitioning);
	    break;
	case 11:
	    ASN1Free_DataProtocolCapability(&(val)->u.t30fax);
	    break;
	case 12:
	    ASN1Free_DataProtocolCapability(&(val)->u.t140);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_forwardMultiplexAckParameters(ASN1encoding_t enc, OpenLogicalChannelAck_forwardMultiplexAckParameters *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H2250LogicalChannelAckParameters(enc, &(val)->u.h2250LogicalChannelAckParameters))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_forwardMultiplexAckParameters(ASN1decoding_t dec, OpenLogicalChannelAck_forwardMultiplexAckParameters *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H2250LogicalChannelAckParameters(dec, &(val)->u.h2250LogicalChannelAckParameters))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannelAck_forwardMultiplexAckParameters(OpenLogicalChannelAck_forwardMultiplexAckParameters *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H2250LogicalChannelAckParameters(&(val)->u.h2250LogicalChannelAckParameters);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_mediaPacketization(ASN1encoding_t enc, H2250LogicalChannelParameters_mediaPacketization *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 0, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_RTPPayloadType(ee, &(val)->u.rtpPayloadType))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_mediaPacketization(ASN1decoding_t dec, H2250LogicalChannelParameters_mediaPacketization *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 0, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_RTPPayloadType(dd, &(val)->u.rtpPayloadType))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelParameters_mediaPacketization(H2250LogicalChannelParameters_mediaPacketization *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_RTPPayloadType(&(val)->u.rtpPayloadType);
	    break;
	}
    }
}

static ASN1stringtableentry_t NetworkAccessParameters_networkAddress_e164Address_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t NetworkAccessParameters_networkAddress_e164Address_StringTable = {
    4, NetworkAccessParameters_networkAddress_e164Address_StringTableEntries
};

static int ASN1CALL ASN1Enc_NetworkAccessParameters_networkAddress(ASN1encoding_t enc, NetworkAccessParameters_networkAddress *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_Q2931Address(enc, &(val)->u.q2931Address))
	    return 0;
	break;
    case 2:
	t = lstrlenA((val)->u.e164Address);
	if (!ASN1PEREncBitVal(enc, 7, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.e164Address, 4, &NetworkAccessParameters_networkAddress_e164Address_StringTable))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H245TransportAddress(enc, &(val)->u.localAreaAddress))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NetworkAccessParameters_networkAddress(ASN1decoding_t dec, NetworkAccessParameters_networkAddress *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_Q2931Address(dec, &(val)->u.q2931Address))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecU32Val(dec, 7, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.e164Address, 4, &NetworkAccessParameters_networkAddress_e164Address_StringTable))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H245TransportAddress(dec, &(val)->u.localAreaAddress))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NetworkAccessParameters_networkAddress(NetworkAccessParameters_networkAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_Q2931Address(&(val)->u.q2931Address);
	    break;
	case 2:
	    break;
	case 3:
	    ASN1Free_H245TransportAddress(&(val)->u.localAreaAddress);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DataApplicationCapability_application(ASN1encoding_t enc, DataApplicationCapability_application *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t120))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.dsm_cc))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.userData))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_DataApplicationCapability_application_t84(enc, &(val)->u.t84))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t434))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.h224))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_DataApplicationCapability_application_nlpid(enc, &(val)->u.nlpid))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.h222DataPartitioning))
	    return 0;
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_DataProtocolCapability(ee, &(val)->u.t30fax))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_DataProtocolCapability(ee, &(val)->u.t140))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataApplicationCapability_application(ASN1decoding_t dec, DataApplicationCapability_application *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t120))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.dsm_cc))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.userData))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_DataApplicationCapability_application_t84(dec, &(val)->u.t84))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t434))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.h224))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_DataApplicationCapability_application_nlpid(dec, &(val)->u.nlpid))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.h222DataPartitioning))
	    return 0;
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_DataProtocolCapability(dd, &(val)->u.t30fax))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_DataProtocolCapability(dd, &(val)->u.t140))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataApplicationCapability_application(DataApplicationCapability_application *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_DataProtocolCapability(&(val)->u.t120);
	    break;
	case 3:
	    ASN1Free_DataProtocolCapability(&(val)->u.dsm_cc);
	    break;
	case 4:
	    ASN1Free_DataProtocolCapability(&(val)->u.userData);
	    break;
	case 5:
	    ASN1Free_DataApplicationCapability_application_t84(&(val)->u.t84);
	    break;
	case 6:
	    ASN1Free_DataProtocolCapability(&(val)->u.t434);
	    break;
	case 7:
	    ASN1Free_DataProtocolCapability(&(val)->u.h224);
	    break;
	case 8:
	    ASN1Free_DataApplicationCapability_application_nlpid(&(val)->u.nlpid);
	    break;
	case 10:
	    ASN1Free_DataProtocolCapability(&(val)->u.h222DataPartitioning);
	    break;
	case 11:
	    ASN1Free_DataProtocolCapability(&(val)->u.t30fax);
	    break;
	case 12:
	    ASN1Free_DataProtocolCapability(&(val)->u.t140);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_spatialEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_spatialEnhancement *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EnhancementLayerInfo_spatialEnhancement_ElmFn, 1, 14, 4);
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_spatialEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_spatialEnhancement val)
{
    if (!ASN1Enc_EnhancementOptions(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_spatialEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_spatialEnhancement *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EnhancementLayerInfo_spatialEnhancement_ElmFn, sizeof(**val), 1, 14, 4);
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_spatialEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_spatialEnhancement val)
{
    if (!ASN1Dec_EnhancementOptions(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_spatialEnhancement(PEnhancementLayerInfo_spatialEnhancement *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EnhancementLayerInfo_spatialEnhancement_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_spatialEnhancement_ElmFn(PEnhancementLayerInfo_spatialEnhancement val)
{
    if (val) {
	ASN1Free_EnhancementOptions(&val->value);
    }
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_snrEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_snrEnhancement *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EnhancementLayerInfo_snrEnhancement_ElmFn, 1, 14, 4);
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_snrEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_snrEnhancement val)
{
    if (!ASN1Enc_EnhancementOptions(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_snrEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_snrEnhancement *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EnhancementLayerInfo_snrEnhancement_ElmFn, sizeof(**val), 1, 14, 4);
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_snrEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_snrEnhancement val)
{
    if (!ASN1Dec_EnhancementOptions(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_snrEnhancement(PEnhancementLayerInfo_snrEnhancement *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EnhancementLayerInfo_snrEnhancement_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_snrEnhancement_ElmFn(PEnhancementLayerInfo_snrEnhancement val)
{
    if (val) {
	ASN1Free_EnhancementOptions(&val->value);
    }
}

static int ASN1CALL ASN1Enc_MediaPacketizationCapability_rtpPayloadType(ASN1encoding_t enc, MediaPacketizationCapability_rtpPayloadType *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_RTPPayloadType(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MediaPacketizationCapability_rtpPayloadType(ASN1decoding_t dec, MediaPacketizationCapability_rtpPayloadType *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_RTPPayloadType(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MediaPacketizationCapability_rtpPayloadType(MediaPacketizationCapability_rtpPayloadType *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (val)->count; i++) {
	    ASN1Free_RTPPayloadType(&(val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_H2250Capability_redundancyEncodingCapability(ASN1encoding_t enc, PH2250Capability_redundancyEncodingCapability *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H2250Capability_redundancyEncodingCapability_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_H2250Capability_redundancyEncodingCapability_ElmFn(ASN1encoding_t enc, PH2250Capability_redundancyEncodingCapability val)
{
    if (!ASN1Enc_RedundancyEncodingCapability(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250Capability_redundancyEncodingCapability(ASN1decoding_t dec, PH2250Capability_redundancyEncodingCapability *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H2250Capability_redundancyEncodingCapability_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_H2250Capability_redundancyEncodingCapability_ElmFn(ASN1decoding_t dec, PH2250Capability_redundancyEncodingCapability val)
{
    if (!ASN1Dec_RedundancyEncodingCapability(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H2250Capability_redundancyEncodingCapability(PH2250Capability_redundancyEncodingCapability *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H2250Capability_redundancyEncodingCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H2250Capability_redundancyEncodingCapability_ElmFn(PH2250Capability_redundancyEncodingCapability val)
{
    if (val) {
	ASN1Free_RedundancyEncodingCapability(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CommandMessage(ASN1encoding_t enc, CommandMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardMessage(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MaintenanceLoopOffCommand(enc, &(val)->u.maintenanceLoopOffCommand))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_SendTerminalCapabilitySet(enc, &(val)->u.sendTerminalCapabilitySet))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_EncryptionCommand(enc, &(val)->u.encryptionCommand))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_FlowControlCommand(enc, &(val)->u.flowControlCommand))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_EndSessionCommand(enc, &(val)->u.endSessionCommand))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_MiscellaneousCommand(enc, &(val)->u.miscellaneousCommand))
	    return 0;
	break;
    case 8:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_CommunicationModeCommand(ee, &(val)->u.communicationModeCommand))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceCommand(ee, &(val)->u.conferenceCommand))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 10:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223MultiplexReconfiguration(ee, &(val)->u.h223MultiplexReconfiguration))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CommandMessage(ASN1decoding_t dec, CommandMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardMessage(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MaintenanceLoopOffCommand(dec, &(val)->u.maintenanceLoopOffCommand))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_SendTerminalCapabilitySet(dec, &(val)->u.sendTerminalCapabilitySet))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_EncryptionCommand(dec, &(val)->u.encryptionCommand))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_FlowControlCommand(dec, &(val)->u.flowControlCommand))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_EndSessionCommand(dec, &(val)->u.endSessionCommand))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_MiscellaneousCommand(dec, &(val)->u.miscellaneousCommand))
	    return 0;
	break;
    case 8:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_CommunicationModeCommand(dd, &(val)->u.communicationModeCommand))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceCommand(dd, &(val)->u.conferenceCommand))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 10:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H223MultiplexReconfiguration(dd, &(val)->u.h223MultiplexReconfiguration))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommandMessage(CommandMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardMessage(&(val)->u.nonStandard);
	    break;
	case 3:
	    ASN1Free_SendTerminalCapabilitySet(&(val)->u.sendTerminalCapabilitySet);
	    break;
	case 4:
	    ASN1Free_EncryptionCommand(&(val)->u.encryptionCommand);
	    break;
	case 6:
	    ASN1Free_EndSessionCommand(&(val)->u.endSessionCommand);
	    break;
	case 7:
	    ASN1Free_MiscellaneousCommand(&(val)->u.miscellaneousCommand);
	    break;
	case 8:
	    ASN1Free_CommunicationModeCommand(&(val)->u.communicationModeCommand);
	    break;
	case 9:
	    ASN1Free_ConferenceCommand(&(val)->u.conferenceCommand);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H235SecurityCapability(ASN1encoding_t enc, H235SecurityCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_EncryptionAuthenticationAndIntegrity(enc, &(val)->encryptionAuthenticationAndIntegrity))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->mediaCapability - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H235SecurityCapability(ASN1decoding_t dec, H235SecurityCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_EncryptionAuthenticationAndIntegrity(dec, &(val)->encryptionAuthenticationAndIntegrity))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->mediaCapability))
	return 0;
    (val)->mediaCapability += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H235SecurityCapability(H235SecurityCapability *val)
{
    if (val) {
	ASN1Free_EncryptionAuthenticationAndIntegrity(&(val)->encryptionAuthenticationAndIntegrity);
    }
}

static int ASN1CALL ASN1Enc_MediaPacketizationCapability(ASN1encoding_t enc, MediaPacketizationCapability *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->h261aVideoPacketization))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, (val)->o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1Enc_MediaPacketizationCapability_rtpPayloadType(ee, &(val)->rtpPayloadType))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MediaPacketizationCapability(ASN1decoding_t dec, MediaPacketizationCapability *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->h261aVideoPacketization))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_MediaPacketizationCapability_rtpPayloadType(dd, &(val)->rtpPayloadType))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_MediaPacketizationCapability(MediaPacketizationCapability *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_MediaPacketizationCapability_rtpPayloadType(&(val)->rtpPayloadType);
	}
    }
}

static int ASN1CALL ASN1Enc_VideoCapability(ASN1encoding_t enc, VideoCapability *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H261VideoCapability(enc, &(val)->u.h261VideoCapability))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H262VideoCapability(enc, &(val)->u.h262VideoCapability))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_H263VideoCapability(enc, &(val)->u.h263VideoCapability))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_IS11172VideoCapability(enc, &(val)->u.is11172VideoCapability))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VideoCapability(ASN1decoding_t dec, VideoCapability *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H261VideoCapability(dec, &(val)->u.h261VideoCapability))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H262VideoCapability(dec, &(val)->u.h262VideoCapability))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_H263VideoCapability(dec, &(val)->u.h263VideoCapability))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_IS11172VideoCapability(dec, &(val)->u.is11172VideoCapability))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_VideoCapability(VideoCapability *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 4:
	    ASN1Free_H263VideoCapability(&(val)->u.h263VideoCapability);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BEnhancementParameters(ASN1encoding_t enc, BEnhancementParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_EnhancementOptions(enc, &(val)->enhancementOptions))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->numberOfBPictures - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BEnhancementParameters(ASN1decoding_t dec, BEnhancementParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_EnhancementOptions(dec, &(val)->enhancementOptions))
	return 0;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->numberOfBPictures))
	return 0;
    (val)->numberOfBPictures += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BEnhancementParameters(BEnhancementParameters *val)
{
    if (val) {
	ASN1Free_EnhancementOptions(&(val)->enhancementOptions);
    }
}

static int ASN1CALL ASN1Enc_DataApplicationCapability(ASN1encoding_t enc, DataApplicationCapability *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_DataApplicationCapability_application(enc, &(val)->application))
	return 0;
    l = ASN1uint32_uoctets((val)->maxBitRate);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->maxBitRate))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataApplicationCapability(ASN1decoding_t dec, DataApplicationCapability *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_DataApplicationCapability_application(dec, &(val)->application))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->maxBitRate))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataApplicationCapability(DataApplicationCapability *val)
{
    if (val) {
	ASN1Free_DataApplicationCapability_application(&(val)->application);
    }
}

static int ASN1CALL ASN1Enc_NetworkAccessParameters(ASN1encoding_t enc, NetworkAccessParameters *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NetworkAccessParameters_distribution(enc, &(val)->distribution))
	    return 0;
    }
    if (!ASN1Enc_NetworkAccessParameters_networkAddress(enc, &(val)->networkAddress))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->associateConference))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->externalReference, 1, 255, 8))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_NetworkAccessParameters_t120SetupProcedure(ee, &(val)->t120SetupProcedure))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NetworkAccessParameters(ASN1decoding_t dec, NetworkAccessParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NetworkAccessParameters_distribution(dec, &(val)->distribution))
	    return 0;
    }
    if (!ASN1Dec_NetworkAccessParameters_networkAddress(dec, &(val)->networkAddress))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->associateConference))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->externalReference, 1, 255, 8))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_NetworkAccessParameters_t120SetupProcedure(dd, &(val)->t120SetupProcedure))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_NetworkAccessParameters(NetworkAccessParameters *val)
{
    if (val) {
	ASN1Free_NetworkAccessParameters_networkAddress(&(val)->networkAddress);
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_H2250ModeParameters(ASN1encoding_t enc, H2250ModeParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_RedundancyEncodingMode(enc, &(val)->redundancyEncodingMode))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H2250ModeParameters(ASN1decoding_t dec, H2250ModeParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_RedundancyEncodingMode(dec, &(val)->redundancyEncodingMode))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H2250ModeParameters(H2250ModeParameters *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_RedundancyEncodingMode(&(val)->redundancyEncodingMode);
	}
    }
}

static int ASN1CALL ASN1Enc_DataMode(ASN1encoding_t enc, DataMode *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_DataMode_application(enc, &(val)->application))
	return 0;
    l = ASN1uint32_uoctets((val)->bitRate);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bitRate))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataMode(ASN1decoding_t dec, DataMode *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_DataMode_application(dec, &(val)->application))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bitRate))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataMode(DataMode *val)
{
    if (val) {
	ASN1Free_DataMode_application(&(val)->application);
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_dataType(ASN1encoding_t enc, CommunicationModeTableEntry_dataType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_VideoCapability(enc, &(val)->u.videoData))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_AudioCapability(enc, &(val)->u.audioData))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.data))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_dataType(ASN1decoding_t dec, CommunicationModeTableEntry_dataType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_VideoCapability(dec, &(val)->u.videoData))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_AudioCapability(dec, &(val)->u.audioData))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.data))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeTableEntry_dataType(CommunicationModeTableEntry_dataType *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_VideoCapability(&(val)->u.videoData);
	    break;
	case 2:
	    ASN1Free_AudioCapability(&(val)->u.audioData);
	    break;
	case 3:
	    ASN1Free_DataApplicationCapability(&(val)->u.data);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H235Mode_mediaMode(ASN1encoding_t enc, H235Mode_mediaMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_VideoMode(enc, &(val)->u.videoMode))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_AudioMode(enc, &(val)->u.audioMode))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_DataMode(enc, &(val)->u.dataMode))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H235Mode_mediaMode(ASN1decoding_t dec, H235Mode_mediaMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_VideoMode(dec, &(val)->u.videoMode))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_AudioMode(dec, &(val)->u.audioMode))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_DataMode(dec, &(val)->u.dataMode))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H235Mode_mediaMode(H235Mode_mediaMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_VideoMode(&(val)->u.videoMode);
	    break;
	case 3:
	    ASN1Free_AudioMode(&(val)->u.audioMode);
	    break;
	case 4:
	    ASN1Free_DataMode(&(val)->u.dataMode);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H235Media_mediaType(ASN1encoding_t enc, H235Media_mediaType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_VideoCapability(enc, &(val)->u.videoData))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_AudioCapability(enc, &(val)->u.audioData))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.data))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H235Media_mediaType(ASN1decoding_t dec, H235Media_mediaType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_VideoCapability(dec, &(val)->u.videoData))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_AudioCapability(dec, &(val)->u.audioData))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.data))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H235Media_mediaType(H235Media_mediaType *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_VideoCapability(&(val)->u.videoData);
	    break;
	case 3:
	    ASN1Free_AudioCapability(&(val)->u.audioData);
	    break;
	case 4:
	    ASN1Free_DataApplicationCapability(&(val)->u.data);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_bPictureEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_bPictureEnhancement *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EnhancementLayerInfo_bPictureEnhancement_ElmFn, 1, 14, 4);
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_bPictureEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_bPictureEnhancement val)
{
    if (!ASN1Enc_BEnhancementParameters(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_bPictureEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_bPictureEnhancement *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EnhancementLayerInfo_bPictureEnhancement_ElmFn, sizeof(**val), 1, 14, 4);
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_bPictureEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_bPictureEnhancement val)
{
    if (!ASN1Dec_BEnhancementParameters(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_bPictureEnhancement(PEnhancementLayerInfo_bPictureEnhancement *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EnhancementLayerInfo_bPictureEnhancement_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_bPictureEnhancement_ElmFn(PEnhancementLayerInfo_bPictureEnhancement val)
{
    if (val) {
	ASN1Free_BEnhancementParameters(&val->value);
    }
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData(ASN1encoding_t enc, PMediaDistributionCapability_distributedData *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_MediaDistributionCapability_distributedData_ElmFn);
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_distributedData val)
{
    if (!ASN1Enc_DataApplicationCapability(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData(ASN1decoding_t dec, PMediaDistributionCapability_distributedData *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_MediaDistributionCapability_distributedData_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_distributedData val)
{
    if (!ASN1Dec_DataApplicationCapability(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData(PMediaDistributionCapability_distributedData *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_MediaDistributionCapability_distributedData_ElmFn);
    }
}

static void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData_ElmFn(PMediaDistributionCapability_distributedData val)
{
    if (val) {
	ASN1Free_DataApplicationCapability(&val->value);
    }
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_MediaDistributionCapability_centralizedData_ElmFn);
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData val)
{
    if (!ASN1Enc_DataApplicationCapability(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_MediaDistributionCapability_centralizedData_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData val)
{
    if (!ASN1Dec_DataApplicationCapability(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData(PMediaDistributionCapability_centralizedData *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_MediaDistributionCapability_centralizedData_ElmFn);
    }
}

static void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData_ElmFn(PMediaDistributionCapability_centralizedData val)
{
    if (val) {
	ASN1Free_DataApplicationCapability(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Capability(ASN1encoding_t enc, Capability *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 12))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_VideoCapability(enc, &(val)->u.receiveVideoCapability))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_VideoCapability(enc, &(val)->u.transmitVideoCapability))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_VideoCapability(enc, &(val)->u.receiveAndTransmitVideoCapability))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_AudioCapability(enc, &(val)->u.receiveAudioCapability))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_AudioCapability(enc, &(val)->u.transmitAudioCapability))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_AudioCapability(enc, &(val)->u.receiveAndTransmitAudioCapability))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.receiveDataApplicationCapability))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.transmitDataApplicationCapability))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.receiveAndTransmitDataApplicationCapability))
	    return 0;
	break;
    case 11:
	if (!ASN1PEREncBoolean(enc, (val)->u.h233EncryptionTransmitCapability))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_Capability_h233EncryptionReceiveCapability(enc, &(val)->u.h233EncryptionReceiveCapability))
	    return 0;
	break;
    case 13:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceCapability(ee, &(val)->u.conferenceCapability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 14:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H235SecurityCapability(ee, &(val)->u.h235SecurityCapability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 8, (val)->u.maxPendingReplacementFor))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 16:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_UserInputCapability(ee, &(val)->u.receiveUserInputCapability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 17:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_UserInputCapability(ee, &(val)->u.transmitUserInputCapability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 18:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_UserInputCapability(ee, &(val)->u.receiveAndTransmitUserInputCapability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Capability(ASN1decoding_t dec, Capability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 12))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_VideoCapability(dec, &(val)->u.receiveVideoCapability))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_VideoCapability(dec, &(val)->u.transmitVideoCapability))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_VideoCapability(dec, &(val)->u.receiveAndTransmitVideoCapability))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_AudioCapability(dec, &(val)->u.receiveAudioCapability))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_AudioCapability(dec, &(val)->u.transmitAudioCapability))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_AudioCapability(dec, &(val)->u.receiveAndTransmitAudioCapability))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.receiveDataApplicationCapability))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.transmitDataApplicationCapability))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.receiveAndTransmitDataApplicationCapability))
	    return 0;
	break;
    case 11:
	if (!ASN1PERDecBoolean(dec, &(val)->u.h233EncryptionTransmitCapability))
	    return 0;
	break;
    case 12:
	if (!ASN1Dec_Capability_h233EncryptionReceiveCapability(dec, &(val)->u.h233EncryptionReceiveCapability))
	    return 0;
	break;
    case 13:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceCapability(dd, &(val)->u.conferenceCapability))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 14:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H235SecurityCapability(dd, &(val)->u.h235SecurityCapability))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU16Val(dd, 8, &(val)->u.maxPendingReplacementFor))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 16:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_UserInputCapability(dd, &(val)->u.receiveUserInputCapability))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 17:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_UserInputCapability(dd, &(val)->u.transmitUserInputCapability))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 18:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_UserInputCapability(dd, &(val)->u.receiveAndTransmitUserInputCapability))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Capability(Capability *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_VideoCapability(&(val)->u.receiveVideoCapability);
	    break;
	case 3:
	    ASN1Free_VideoCapability(&(val)->u.transmitVideoCapability);
	    break;
	case 4:
	    ASN1Free_VideoCapability(&(val)->u.receiveAndTransmitVideoCapability);
	    break;
	case 5:
	    ASN1Free_AudioCapability(&(val)->u.receiveAudioCapability);
	    break;
	case 6:
	    ASN1Free_AudioCapability(&(val)->u.transmitAudioCapability);
	    break;
	case 7:
	    ASN1Free_AudioCapability(&(val)->u.receiveAndTransmitAudioCapability);
	    break;
	case 8:
	    ASN1Free_DataApplicationCapability(&(val)->u.receiveDataApplicationCapability);
	    break;
	case 9:
	    ASN1Free_DataApplicationCapability(&(val)->u.transmitDataApplicationCapability);
	    break;
	case 10:
	    ASN1Free_DataApplicationCapability(&(val)->u.receiveAndTransmitDataApplicationCapability);
	    break;
	case 13:
	    ASN1Free_ConferenceCapability(&(val)->u.conferenceCapability);
	    break;
	case 14:
	    ASN1Free_H235SecurityCapability(&(val)->u.h235SecurityCapability);
	    break;
	case 16:
	    ASN1Free_UserInputCapability(&(val)->u.receiveUserInputCapability);
	    break;
	case 17:
	    ASN1Free_UserInputCapability(&(val)->u.transmitUserInputCapability);
	    break;
	case 18:
	    ASN1Free_UserInputCapability(&(val)->u.receiveAndTransmitUserInputCapability);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H2250Capability(ASN1encoding_t enc, H2250Capability *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x20;
    o[0] |= 0x10;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAudioDelayJitter))
	return 0;
    if (!ASN1Enc_MultipointCapability(enc, &(val)->receiveMultipointCapability))
	return 0;
    if (!ASN1Enc_MultipointCapability(enc, &(val)->transmitMultipointCapability))
	return 0;
    if (!ASN1Enc_MultipointCapability(enc, &(val)->receiveAndTransmitMultipointCapability))
	return 0;
    if (!ASN1Enc_H2250Capability_mcCapability(enc, &(val)->mcCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->rtcpVideoControlCapability))
	return 0;
    if (!ASN1Enc_MediaPacketizationCapability(enc, &(val)->mediaPacketizationCapability))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[0] & 0x80) {
	    if (!ASN1Enc_TransportCapability(ee, &(val)->transportCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x40) {
	    if (!ASN1Enc_H2250Capability_redundancyEncodingCapability(ee, &(val)->redundancyEncodingCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x20) {
	    if (!ASN1PEREncBoolean(ee, (val)->logicalChannelSwitchingCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x10) {
	    if (!ASN1PEREncBoolean(ee, (val)->t120DynamicPortCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H2250Capability(ASN1decoding_t dec, H2250Capability *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAudioDelayJitter))
	return 0;
    if (!ASN1Dec_MultipointCapability(dec, &(val)->receiveMultipointCapability))
	return 0;
    if (!ASN1Dec_MultipointCapability(dec, &(val)->transmitMultipointCapability))
	return 0;
    if (!ASN1Dec_MultipointCapability(dec, &(val)->receiveAndTransmitMultipointCapability))
	return 0;
    if (!ASN1Dec_H2250Capability_mcCapability(dec, &(val)->mcCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->rtcpVideoControlCapability))
	return 0;
    if (!ASN1Dec_MediaPacketizationCapability(dec, &(val)->mediaPacketizationCapability))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_TransportCapability(dd, &(val)->transportCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H2250Capability_redundancyEncodingCapability(dd, &(val)->redundancyEncodingCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->logicalChannelSwitchingCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->t120DynamicPortCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H2250Capability(H2250Capability *val)
{
    if (val) {
	ASN1Free_MultipointCapability(&(val)->receiveMultipointCapability);
	ASN1Free_MultipointCapability(&(val)->transmitMultipointCapability);
	ASN1Free_MultipointCapability(&(val)->receiveAndTransmitMultipointCapability);
	ASN1Free_MediaPacketizationCapability(&(val)->mediaPacketizationCapability);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportCapability(&(val)->transportCapability);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H2250Capability_redundancyEncodingCapability(&(val)->redundancyEncodingCapability);
	}
    }
}

static int ASN1CALL ASN1Enc_H235Media(ASN1encoding_t enc, H235Media *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_EncryptionAuthenticationAndIntegrity(enc, &(val)->encryptionAuthenticationAndIntegrity))
	return 0;
    if (!ASN1Enc_H235Media_mediaType(enc, &(val)->mediaType))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H235Media(ASN1decoding_t dec, H235Media *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_EncryptionAuthenticationAndIntegrity(dec, &(val)->encryptionAuthenticationAndIntegrity))
	return 0;
    if (!ASN1Dec_H235Media_mediaType(dec, &(val)->mediaType))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H235Media(H235Media *val)
{
    if (val) {
	ASN1Free_EncryptionAuthenticationAndIntegrity(&(val)->encryptionAuthenticationAndIntegrity);
	ASN1Free_H235Media_mediaType(&(val)->mediaType);
    }
}

static int ASN1CALL ASN1Enc_H235Mode(ASN1encoding_t enc, H235Mode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_EncryptionAuthenticationAndIntegrity(enc, &(val)->encryptionAuthenticationAndIntegrity))
	return 0;
    if (!ASN1Enc_H235Mode_mediaMode(enc, &(val)->mediaMode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H235Mode(ASN1decoding_t dec, H235Mode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_EncryptionAuthenticationAndIntegrity(dec, &(val)->encryptionAuthenticationAndIntegrity))
	return 0;
    if (!ASN1Dec_H235Mode_mediaMode(dec, &(val)->mediaMode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H235Mode(H235Mode *val)
{
    if (val) {
	ASN1Free_EncryptionAuthenticationAndIntegrity(&(val)->encryptionAuthenticationAndIntegrity);
	ASN1Free_H235Mode_mediaMode(&(val)->mediaMode);
    }
}

static int ASN1CALL ASN1Enc_ModeElement_type(ASN1encoding_t enc, ModeElement_type *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 5))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_VideoMode(enc, &(val)->u.videoMode))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_AudioMode(enc, &(val)->u.audioMode))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_DataMode(enc, &(val)->u.dataMode))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_EncryptionMode(enc, &(val)->u.encryptionMode))
	    return 0;
	break;
    case 6:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H235Mode(ee, &(val)->u.h235Mode))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ModeElement_type(ASN1decoding_t dec, ModeElement_type *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 5))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_VideoMode(dec, &(val)->u.videoMode))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_AudioMode(dec, &(val)->u.audioMode))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_DataMode(dec, &(val)->u.dataMode))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_EncryptionMode(dec, &(val)->u.encryptionMode))
	    return 0;
	break;
    case 6:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H235Mode(dd, &(val)->u.h235Mode))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ModeElement_type(ModeElement_type *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_VideoMode(&(val)->u.videoMode);
	    break;
	case 3:
	    ASN1Free_AudioMode(&(val)->u.audioMode);
	    break;
	case 4:
	    ASN1Free_DataMode(&(val)->u.dataMode);
	    break;
	case 5:
	    ASN1Free_EncryptionMode(&(val)->u.encryptionMode);
	    break;
	case 6:
	    ASN1Free_H235Mode(&(val)->u.h235Mode);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CapabilityTableEntry(ASN1encoding_t enc, CapabilityTableEntry *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->capabilityTableEntryNumber - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Capability(enc, &(val)->capability))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CapabilityTableEntry(ASN1decoding_t dec, CapabilityTableEntry *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->capabilityTableEntryNumber))
	return 0;
    (val)->capabilityTableEntryNumber += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_Capability(dec, &(val)->capability))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CapabilityTableEntry(CapabilityTableEntry *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Capability(&(val)->capability);
	}
    }
}

static int ASN1CALL ASN1Enc_MultiplexCapability(ASN1encoding_t enc, MultiplexCapability *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H222Capability(enc, &(val)->u.h222Capability))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H223Capability(enc, &(val)->u.h223Capability))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_V76Capability(enc, &(val)->u.v76Capability))
	    return 0;
	break;
    case 5:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H2250Capability(ee, &(val)->u.h2250Capability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexCapability(ASN1decoding_t dec, MultiplexCapability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H222Capability(dec, &(val)->u.h222Capability))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H223Capability(dec, &(val)->u.h223Capability))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_V76Capability(dec, &(val)->u.v76Capability))
	    return 0;
	break;
    case 5:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H2250Capability(dd, &(val)->u.h2250Capability))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexCapability(MultiplexCapability *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_H222Capability(&(val)->u.h222Capability);
	    break;
	case 5:
	    ASN1Free_H2250Capability(&(val)->u.h2250Capability);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DataType(ASN1encoding_t enc, DataType *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_VideoCapability(enc, &(val)->u.videoData))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_AudioCapability(enc, &(val)->u.audioData))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.data))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_EncryptionMode(enc, &(val)->u.encryptionData))
	    return 0;
	break;
    case 7:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_NonStandardParameter(ee, &(val)->u.h235Control))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 8:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H235Media(ee, &(val)->u.h235Media))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataType(ASN1decoding_t dec, DataType *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_VideoCapability(dec, &(val)->u.videoData))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_AudioCapability(dec, &(val)->u.audioData))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.data))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_EncryptionMode(dec, &(val)->u.encryptionData))
	    return 0;
	break;
    case 7:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_NonStandardParameter(dd, &(val)->u.h235Control))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 8:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H235Media(dd, &(val)->u.h235Media))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataType(DataType *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 3:
	    ASN1Free_VideoCapability(&(val)->u.videoData);
	    break;
	case 4:
	    ASN1Free_AudioCapability(&(val)->u.audioData);
	    break;
	case 5:
	    ASN1Free_DataApplicationCapability(&(val)->u.data);
	    break;
	case 6:
	    ASN1Free_EncryptionMode(&(val)->u.encryptionData);
	    break;
	case 7:
	    ASN1Free_NonStandardParameter(&(val)->u.h235Control);
	    break;
	case 8:
	    ASN1Free_H235Media(&(val)->u.h235Media);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncoding(ASN1encoding_t enc, RedundancyEncoding *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_RedundancyEncodingMethod(enc, &(val)->redundancyEncodingMethod))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_DataType(enc, &(val)->secondaryEncoding))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncoding(ASN1decoding_t dec, RedundancyEncoding *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_RedundancyEncodingMethod(dec, &(val)->redundancyEncodingMethod))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_DataType(dec, &(val)->secondaryEncoding))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncoding(RedundancyEncoding *val)
{
    if (val) {
	ASN1Free_RedundancyEncodingMethod(&(val)->redundancyEncodingMethod);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_DataType(&(val)->secondaryEncoding);
	}
    }
}

static int ASN1CALL ASN1Enc_ModeElement(ASN1encoding_t enc, ModeElement *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_ModeElement_type(enc, &(val)->type))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H223ModeParameters(enc, &(val)->h223ModeParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_V76ModeParameters(ee, &(val)->v76ModeParameters))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_H2250ModeParameters(ee, &(val)->h2250ModeParameters))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ModeElement(ASN1decoding_t dec, ModeElement *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_ModeElement_type(dec, &(val)->type))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H223ModeParameters(dec, &(val)->h223ModeParameters))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_V76ModeParameters(dd, &(val)->v76ModeParameters))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H2250ModeParameters(dd, &(val)->h2250ModeParameters))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_ModeElement(ModeElement *val)
{
    if (val) {
	ASN1Free_ModeElement_type(&(val)->type);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H223ModeParameters(&(val)->h223ModeParameters);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H2250ModeParameters(&(val)->h2250ModeParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeTableEntry(ASN1encoding_t enc, CommunicationModeTableEntry *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 7, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CommunicationModeTableEntry_nonStandard(enc, &(val)->nonStandard))
	    return 0;
    }
    if (!ASN1PEREncBitVal(enc, 8, (val)->sessionID - 1))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 8, (val)->associatedSessionID - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	    return 0;
    }
    if (!ASN1PEREncBitVal(enc, 7, ((val)->sessionDescription).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->sessionDescription).length, ((val)->sessionDescription).value, 16))
	return 0;
    if (!ASN1Enc_CommunicationModeTableEntry_dataType(enc, &(val)->dataType))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBoolean(enc, (val)->mediaGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaControlChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PEREncBoolean(enc, (val)->mediaControlGuaranteedDelivery))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_RedundancyEncoding(ee, &(val)->redundancyEncoding))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PEREncBitVal(ee, 8, (val)->sessionDependency - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_TerminalLabel(ee, &(val)->destination))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeTableEntry(ASN1decoding_t dec, CommunicationModeTableEntry *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CommunicationModeTableEntry_nonStandard(dec, &(val)->nonStandard))
	    return 0;
    }
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sessionID))
	return 0;
    (val)->sessionID += 1;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU16Val(dec, 8, &(val)->associatedSessionID))
	    return 0;
	(val)->associatedSessionID += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	    return 0;
    }
    if (!ASN1PERDecU32Val(dec, 7, &((val)->sessionDescription).length))
	return 0;
    ((val)->sessionDescription).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->sessionDescription).length, &((val)->sessionDescription).value, 16))
	return 0;
    if (!ASN1Dec_CommunicationModeTableEntry_dataType(dec, &(val)->dataType))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecBoolean(dec, &(val)->mediaGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaControlChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PERDecBoolean(dec, &(val)->mediaControlGuaranteedDelivery))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RedundancyEncoding(dd, &(val)->redundancyEncoding))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecU16Val(dd, 8, &(val)->sessionDependency))
		return 0;
	    (val)->sessionDependency += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_TerminalLabel(dd, &(val)->destination))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeTableEntry(CommunicationModeTableEntry *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CommunicationModeTableEntry_nonStandard(&(val)->nonStandard);
	}
	ASN1char16string_free(&(val)->sessionDescription);
	ASN1Free_CommunicationModeTableEntry_dataType(&(val)->dataType);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_H245TransportAddress(&(val)->mediaChannel);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_H245TransportAddress(&(val)->mediaControlChannel);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_RedundancyEncoding(&(val)->redundancyEncoding);
	}
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CommunicationModeResponse_communicationModeTable_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable val)
{
    if (!ASN1Enc_CommunicationModeTableEntry(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CommunicationModeResponse_communicationModeTable_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable val)
{
    if (!ASN1Dec_CommunicationModeTableEntry(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable(PCommunicationModeResponse_communicationModeTable *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CommunicationModeResponse_communicationModeTable_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable_ElmFn(PCommunicationModeResponse_communicationModeTable val)
{
    if (val) {
	ASN1Free_CommunicationModeTableEntry(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CommunicationModeCommand_communicationModeTable_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable val)
{
    if (!ASN1Enc_CommunicationModeTableEntry(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CommunicationModeCommand_communicationModeTable_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable val)
{
    if (!ASN1Dec_CommunicationModeTableEntry(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable(PCommunicationModeCommand_communicationModeTable *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CommunicationModeCommand_communicationModeTable_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable_ElmFn(PCommunicationModeCommand_communicationModeTable val)
{
    if (val) {
	ASN1Free_CommunicationModeTableEntry(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TerminalCapabilitySet_capabilityTable_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable val)
{
    if (!ASN1Enc_CapabilityTableEntry(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TerminalCapabilitySet_capabilityTable_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable val)
{
    if (!ASN1Dec_CapabilityTableEntry(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable(PTerminalCapabilitySet_capabilityTable *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TerminalCapabilitySet_capabilityTable_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable_ElmFn(PTerminalCapabilitySet_capabilityTable val)
{
    if (val) {
	ASN1Free_CapabilityTableEntry(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySet(ASN1encoding_t enc, TerminalCapabilitySet *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_MultiplexCapability(enc, &(val)->multiplexCapability))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_TerminalCapabilitySet_capabilityTable(enc, &(val)->capabilityTable))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_TerminalCapabilitySet_capabilityDescriptors(enc, &(val)->capabilityDescriptors))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySet(ASN1decoding_t dec, TerminalCapabilitySet *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_MultiplexCapability(dec, &(val)->multiplexCapability))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_TerminalCapabilitySet_capabilityTable(dec, &(val)->capabilityTable))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_TerminalCapabilitySet_capabilityDescriptors(dec, &(val)->capabilityDescriptors))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TerminalCapabilitySet(TerminalCapabilitySet *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_MultiplexCapability(&(val)->multiplexCapability);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_TerminalCapabilitySet_capabilityTable(&(val)->capabilityTable);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_TerminalCapabilitySet_capabilityDescriptors(&(val)->capabilityDescriptors);
	}
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters(ASN1encoding_t enc, H2250LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 2);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 10, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H2250LogicalChannelParameters_nonStandard(enc, &(val)->nonStandard))
	    return 0;
    }
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sessionID))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 8, (val)->associatedSessionID - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncBoolean(enc, (val)->mediaGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaControlChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PEREncBoolean(enc, (val)->mediaControlGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PEREncBoolean(enc, (val)->silenceSuppression))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1Enc_TerminalLabel(enc, &(val)->destination))
	    return 0;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->dynamicRTPPayloadType - 96))
	    return 0;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1Enc_H2250LogicalChannelParameters_mediaPacketization(enc, &(val)->mediaPacketization))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 2))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[2] & 0x80) {
	    if (!ASN1Enc_TransportCapability(ee, &(val)->transportCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[2] & 0x40) {
	    if (!ASN1Enc_RedundancyEncoding(ee, &(val)->redundancyEncoding))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[2] & 0x20) {
	    if (!ASN1Enc_TerminalLabel(ee, &(val)->source))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters(ASN1decoding_t dec, H2250LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 10, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H2250LogicalChannelParameters_nonStandard(dec, &(val)->nonStandard))
	    return 0;
    }
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sessionID))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU16Val(dec, 8, &(val)->associatedSessionID))
	    return 0;
	(val)->associatedSessionID += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecBoolean(dec, &(val)->mediaGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaControlChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecBoolean(dec, &(val)->mediaControlGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PERDecBoolean(dec, &(val)->silenceSuppression))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1Dec_TerminalLabel(dec, &(val)->destination))
	    return 0;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->dynamicRTPPayloadType))
	    return 0;
	(val)->dynamicRTPPayloadType += 96;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1Dec_H2250LogicalChannelParameters_mediaPacketization(dec, &(val)->mediaPacketization))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 2, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 2))
	    return 0;
	if ((val)->o[2] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_TransportCapability(dd, &(val)->transportCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[2] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RedundancyEncoding(dd, &(val)->redundancyEncoding))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[2] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_TerminalLabel(dd, &(val)->source))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelParameters(H2250LogicalChannelParameters *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H2250LogicalChannelParameters_nonStandard(&(val)->nonStandard);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_H245TransportAddress(&(val)->mediaChannel);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_H245TransportAddress(&(val)->mediaControlChannel);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H2250LogicalChannelParameters_mediaPacketization(&(val)->mediaPacketization);
	}
	if ((val)->o[2] & 0x80) {
	    ASN1Free_TransportCapability(&(val)->transportCapability);
	}
	if ((val)->o[2] & 0x40) {
	    ASN1Free_RedundancyEncoding(&(val)->redundancyEncoding);
	}
    }
}

static int ASN1CALL ASN1Enc_ModeDescription(ASN1encoding_t enc, ModeDescription *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_ModeElement(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ModeDescription(ASN1decoding_t dec, ModeDescription *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_ModeElement(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ModeDescription(ModeDescription *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (val)->count; i++) {
	    ASN1Free_ModeElement(&(val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H222LogicalChannelParameters(enc, &(val)->u.h222LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H223LogicalChannelParameters(enc, &(val)->u.h223LogicalChannelParameters))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_V76LogicalChannelParameters(enc, &(val)->u.v76LogicalChannelParameters))
	    return 0;
	break;
    case 4:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H2250LogicalChannelParameters(ee, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 5:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H222LogicalChannelParameters(dec, &(val)->u.h222LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H223LogicalChannelParameters(dec, &(val)->u.h223LogicalChannelParameters))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_V76LogicalChannelParameters(dec, &(val)->u.v76LogicalChannelParameters))
	    return 0;
	break;
    case 4:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H2250LogicalChannelParameters(dd, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 5:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H222LogicalChannelParameters(&(val)->u.h222LogicalChannelParameters);
	    break;
	case 2:
	    ASN1Free_H223LogicalChannelParameters(&(val)->u.h223LogicalChannelParameters);
	    break;
	case 4:
	    ASN1Free_H2250LogicalChannelParameters(&(val)->u.h2250LogicalChannelParameters);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H223LogicalChannelParameters(enc, &(val)->u.h223LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_V76LogicalChannelParameters(enc, &(val)->u.v76LogicalChannelParameters))
	    return 0;
	break;
    case 3:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H2250LogicalChannelParameters(ee, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H223LogicalChannelParameters(dec, &(val)->u.h223LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_V76LogicalChannelParameters(dec, &(val)->u.v76LogicalChannelParameters))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H2250LogicalChannelParameters(dd, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H223LogicalChannelParameters(&(val)->u.h223LogicalChannelParameters);
	    break;
	case 3:
	    ASN1Free_H2250LogicalChannelParameters(&(val)->u.h2250LogicalChannelParameters);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 0, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H222LogicalChannelParameters(enc, &(val)->u.h222LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H2250LogicalChannelParameters(ee, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 0, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H222LogicalChannelParameters(dec, &(val)->u.h222LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H2250LogicalChannelParameters(dd, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H222LogicalChannelParameters(&(val)->u.h222LogicalChannelParameters);
	    break;
	case 2:
	    ASN1Free_H2250LogicalChannelParameters(&(val)->u.h2250LogicalChannelParameters);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RequestMode_requestedModes(ASN1encoding_t enc, PRequestMode_requestedModes *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RequestMode_requestedModes_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_RequestMode_requestedModes_ElmFn(ASN1encoding_t enc, PRequestMode_requestedModes val)
{
    if (!ASN1Enc_ModeDescription(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMode_requestedModes(ASN1decoding_t dec, PRequestMode_requestedModes *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RequestMode_requestedModes_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_RequestMode_requestedModes_ElmFn(ASN1decoding_t dec, PRequestMode_requestedModes val)
{
    if (!ASN1Dec_ModeDescription(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RequestMode_requestedModes(PRequestMode_requestedModes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RequestMode_requestedModes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RequestMode_requestedModes_ElmFn(PRequestMode_requestedModes val)
{
    if (val) {
	ASN1Free_ModeDescription(&val->value);
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannelAck_reverseLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->reverseLogicalChannelNumber - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->portNumber))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(enc, &(val)->multiplexParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->replacementFor - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannelAck_reverseLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->reverseLogicalChannelNumber))
	return 0;
    (val)->reverseLogicalChannelNumber += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->portNumber))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(dec, &(val)->multiplexParameters))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->replacementFor))
		return 0;
	    (val)->replacementFor += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters(OpenLogicalChannelAck_reverseLogicalChannelParameters *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(&(val)->multiplexParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannel_reverseLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_DataType(enc, &(val)->dataType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(enc, &(val)->multiplexParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->reverseLogicalChannelDependency - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->replacementFor - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannel_reverseLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_DataType(dec, &(val)->dataType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(dec, &(val)->multiplexParameters))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->reverseLogicalChannelDependency))
		return 0;
	    (val)->reverseLogicalChannelDependency += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->replacementFor))
		return 0;
	    (val)->replacementFor += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters(OpenLogicalChannel_reverseLogicalChannelParameters *val)
{
    if (val) {
	ASN1Free_DataType(&(val)->dataType);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(&(val)->multiplexParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannel_forwardLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->portNumber))
	    return 0;
    }
    if (!ASN1Enc_DataType(enc, &(val)->dataType))
	return 0;
    if (!ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(enc, &(val)->multiplexParameters))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->forwardLogicalChannelDependency - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->replacementFor - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannel_forwardLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->portNumber))
	    return 0;
    }
    if (!ASN1Dec_DataType(dec, &(val)->dataType))
	return 0;
    if (!ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(dec, &(val)->multiplexParameters))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->forwardLogicalChannelDependency))
		return 0;
	    (val)->forwardLogicalChannelDependency += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->replacementFor))
		return 0;
	    (val)->replacementFor += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters(OpenLogicalChannel_forwardLogicalChannelParameters *val)
{
    if (val) {
	ASN1Free_DataType(&(val)->dataType);
	ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(&(val)->multiplexParameters);
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel(ASN1encoding_t enc, OpenLogicalChannel *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters(enc, &(val)->forwardLogicalChannelParameters))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters(enc, &(val)->reverseLogicalChannelParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_NetworkAccessParameters(ee, &(val)->separateStack))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_EncryptionSync(ee, &(val)->encryptionSync))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel(ASN1decoding_t dec, OpenLogicalChannel *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters(dec, &(val)->forwardLogicalChannelParameters))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters(dec, &(val)->reverseLogicalChannelParameters))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_NetworkAccessParameters(dd, &(val)->separateStack))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_EncryptionSync(dd, &(val)->encryptionSync))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel(OpenLogicalChannel *val)
{
    if (val) {
	ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters(&(val)->forwardLogicalChannelParameters);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters(&(val)->reverseLogicalChannelParameters);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_NetworkAccessParameters(&(val)->separateStack);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_EncryptionSync(&(val)->encryptionSync);
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelAck(ASN1encoding_t enc, OpenLogicalChannelAck *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters(enc, &(val)->reverseLogicalChannelParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_NetworkAccessParameters(ee, &(val)->separateStack))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_OpenLogicalChannelAck_forwardMultiplexAckParameters(ee, &(val)->forwardMultiplexAckParameters))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_EncryptionSync(ee, &(val)->encryptionSync))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelAck(ASN1decoding_t dec, OpenLogicalChannelAck *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters(dec, &(val)->reverseLogicalChannelParameters))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_NetworkAccessParameters(dd, &(val)->separateStack))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_OpenLogicalChannelAck_forwardMultiplexAckParameters(dd, &(val)->forwardMultiplexAckParameters))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_EncryptionSync(dd, &(val)->encryptionSync))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannelAck(OpenLogicalChannelAck *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters(&(val)->reverseLogicalChannelParameters);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_NetworkAccessParameters(&(val)->separateStack);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_OpenLogicalChannelAck_forwardMultiplexAckParameters(&(val)->forwardMultiplexAckParameters);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_EncryptionSync(&(val)->encryptionSync);
	}
    }
}

static int ASN1CALL ASN1Enc_RequestMessage(ASN1encoding_t enc, RequestMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 11))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardMessage(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MasterSlaveDetermination(enc, &(val)->u.masterSlaveDetermination))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_TerminalCapabilitySet(enc, &(val)->u.terminalCapabilitySet))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_OpenLogicalChannel(enc, &(val)->u.openLogicalChannel))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_CloseLogicalChannel(enc, &(val)->u.closeLogicalChannel))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_RequestChannelClose(enc, &(val)->u.requestChannelClose))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_MultiplexEntrySend(enc, &(val)->u.multiplexEntrySend))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_RequestMultiplexEntry(enc, &(val)->u.requestMultiplexEntry))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_RequestMode(enc, &(val)->u.requestMode))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_RoundTripDelayRequest(enc, &(val)->u.roundTripDelayRequest))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_MaintenanceLoopRequest(enc, &(val)->u.maintenanceLoopRequest))
	    return 0;
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_CommunicationModeRequest(ee, &(val)->u.communicationModeRequest))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 13:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceRequest(ee, &(val)->u.conferenceRequest))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMessage(ASN1decoding_t dec, RequestMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 11))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardMessage(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MasterSlaveDetermination(dec, &(val)->u.masterSlaveDetermination))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_TerminalCapabilitySet(dec, &(val)->u.terminalCapabilitySet))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_OpenLogicalChannel(dec, &(val)->u.openLogicalChannel))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_CloseLogicalChannel(dec, &(val)->u.closeLogicalChannel))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_RequestChannelClose(dec, &(val)->u.requestChannelClose))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_MultiplexEntrySend(dec, &(val)->u.multiplexEntrySend))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_RequestMultiplexEntry(dec, &(val)->u.requestMultiplexEntry))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_RequestMode(dec, &(val)->u.requestMode))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_RoundTripDelayRequest(dec, &(val)->u.roundTripDelayRequest))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_MaintenanceLoopRequest(dec, &(val)->u.maintenanceLoopRequest))
	    return 0;
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_CommunicationModeRequest(dd, &(val)->u.communicationModeRequest))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 13:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceRequest(dd, &(val)->u.conferenceRequest))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMessage(RequestMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardMessage(&(val)->u.nonStandard);
	    break;
	case 3:
	    ASN1Free_TerminalCapabilitySet(&(val)->u.terminalCapabilitySet);
	    break;
	case 4:
	    ASN1Free_OpenLogicalChannel(&(val)->u.openLogicalChannel);
	    break;
	case 6:
	    ASN1Free_RequestChannelClose(&(val)->u.requestChannelClose);
	    break;
	case 7:
	    ASN1Free_MultiplexEntrySend(&(val)->u.multiplexEntrySend);
	    break;
	case 8:
	    ASN1Free_RequestMultiplexEntry(&(val)->u.requestMultiplexEntry);
	    break;
	case 9:
	    ASN1Free_RequestMode(&(val)->u.requestMode);
	    break;
	case 13:
	    ASN1Free_ConferenceRequest(&(val)->u.conferenceRequest);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ResponseMessage(ASN1encoding_t enc, ResponseMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 5, 19))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardMessage(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MasterSlaveDeterminationAck(enc, &(val)->u.masterSlaveDeterminationAck))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_MasterSlaveDeterminationReject(enc, &(val)->u.masterSlaveDeterminationReject))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_TerminalCapabilitySetAck(enc, &(val)->u.terminalCapabilitySetAck))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_TerminalCapabilitySetReject(enc, &(val)->u.terminalCapabilitySetReject))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_OpenLogicalChannelAck(enc, &(val)->u.openLogicalChannelAck))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_OpenLogicalChannelReject(enc, &(val)->u.openLogicalChannelReject))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_CloseLogicalChannelAck(enc, &(val)->u.closeLogicalChannelAck))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_RequestChannelCloseAck(enc, &(val)->u.requestChannelCloseAck))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_RequestChannelCloseReject(enc, &(val)->u.requestChannelCloseReject))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_MultiplexEntrySendAck(enc, &(val)->u.multiplexEntrySendAck))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_MultiplexEntrySendReject(enc, &(val)->u.multiplexEntrySendReject))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_RequestMultiplexEntryAck(enc, &(val)->u.requestMultiplexEntryAck))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_RequestMultiplexEntryReject(enc, &(val)->u.requestMultiplexEntryReject))
	    return 0;
	break;
    case 15:
	if (!ASN1Enc_RequestModeAck(enc, &(val)->u.requestModeAck))
	    return 0;
	break;
    case 16:
	if (!ASN1Enc_RequestModeReject(enc, &(val)->u.requestModeReject))
	    return 0;
	break;
    case 17:
	if (!ASN1Enc_RoundTripDelayResponse(enc, &(val)->u.roundTripDelayResponse))
	    return 0;
	break;
    case 18:
	if (!ASN1Enc_MaintenanceLoopAck(enc, &(val)->u.maintenanceLoopAck))
	    return 0;
	break;
    case 19:
	if (!ASN1Enc_MaintenanceLoopReject(enc, &(val)->u.maintenanceLoopReject))
	    return 0;
	break;
    case 20:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_CommunicationModeResponse(ee, &(val)->u.communicationModeResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 21:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceResponse(ee, &(val)->u.conferenceResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ResponseMessage(ASN1decoding_t dec, ResponseMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 5, 19))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardMessage(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MasterSlaveDeterminationAck(dec, &(val)->u.masterSlaveDeterminationAck))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_MasterSlaveDeterminationReject(dec, &(val)->u.masterSlaveDeterminationReject))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_TerminalCapabilitySetAck(dec, &(val)->u.terminalCapabilitySetAck))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_TerminalCapabilitySetReject(dec, &(val)->u.terminalCapabilitySetReject))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_OpenLogicalChannelAck(dec, &(val)->u.openLogicalChannelAck))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_OpenLogicalChannelReject(dec, &(val)->u.openLogicalChannelReject))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_CloseLogicalChannelAck(dec, &(val)->u.closeLogicalChannelAck))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_RequestChannelCloseAck(dec, &(val)->u.requestChannelCloseAck))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_RequestChannelCloseReject(dec, &(val)->u.requestChannelCloseReject))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_MultiplexEntrySendAck(dec, &(val)->u.multiplexEntrySendAck))
	    return 0;
	break;
    case 12:
	if (!ASN1Dec_MultiplexEntrySendReject(dec, &(val)->u.multiplexEntrySendReject))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_RequestMultiplexEntryAck(dec, &(val)->u.requestMultiplexEntryAck))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_RequestMultiplexEntryReject(dec, &(val)->u.requestMultiplexEntryReject))
	    return 0;
	break;
    case 15:
	if (!ASN1Dec_RequestModeAck(dec, &(val)->u.requestModeAck))
	    return 0;
	break;
    case 16:
	if (!ASN1Dec_RequestModeReject(dec, &(val)->u.requestModeReject))
	    return 0;
	break;
    case 17:
	if (!ASN1Dec_RoundTripDelayResponse(dec, &(val)->u.roundTripDelayResponse))
	    return 0;
	break;
    case 18:
	if (!ASN1Dec_MaintenanceLoopAck(dec, &(val)->u.maintenanceLoopAck))
	    return 0;
	break;
    case 19:
	if (!ASN1Dec_MaintenanceLoopReject(dec, &(val)->u.maintenanceLoopReject))
	    return 0;
	break;
    case 20:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_CommunicationModeResponse(dd, &(val)->u.communicationModeResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 21:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceResponse(dd, &(val)->u.conferenceResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ResponseMessage(ResponseMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardMessage(&(val)->u.nonStandard);
	    break;
	case 6:
	    ASN1Free_OpenLogicalChannelAck(&(val)->u.openLogicalChannelAck);
	    break;
	case 11:
	    ASN1Free_MultiplexEntrySendAck(&(val)->u.multiplexEntrySendAck);
	    break;
	case 12:
	    ASN1Free_MultiplexEntrySendReject(&(val)->u.multiplexEntrySendReject);
	    break;
	case 13:
	    ASN1Free_RequestMultiplexEntryAck(&(val)->u.requestMultiplexEntryAck);
	    break;
	case 14:
	    ASN1Free_RequestMultiplexEntryReject(&(val)->u.requestMultiplexEntryReject);
	    break;
	case 20:
	    ASN1Free_CommunicationModeResponse(&(val)->u.communicationModeResponse);
	    break;
	case 21:
	    ASN1Free_ConferenceResponse(&(val)->u.conferenceResponse);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_FastConnectOLC(ASN1encoding_t enc, FastConnectOLC *val)
{
    if (!ASN1Enc_OpenLogicalChannel(enc, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FastConnectOLC(ASN1decoding_t dec, FastConnectOLC *val)
{
    if (!ASN1Dec_OpenLogicalChannel(dec, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_FastConnectOLC(FastConnectOLC *val)
{
    if (val) {
	ASN1Free_OpenLogicalChannel(val);
    }
}

static int ASN1CALL ASN1Enc_FunctionNotUnderstood(ASN1encoding_t enc, FunctionNotUnderstood *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_RequestMessage(enc, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ResponseMessage(enc, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_CommandMessage(enc, &(val)->u.command))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_FunctionNotUnderstood(ASN1decoding_t dec, FunctionNotUnderstood *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_RequestMessage(dec, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ResponseMessage(dec, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_CommandMessage(dec, &(val)->u.command))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_FunctionNotUnderstood(FunctionNotUnderstood *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_RequestMessage(&(val)->u.request);
	    break;
	case 2:
	    ASN1Free_ResponseMessage(&(val)->u.response);
	    break;
	case 3:
	    ASN1Free_CommandMessage(&(val)->u.command);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_IndicationMessage(ASN1encoding_t enc, IndicationMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardMessage(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_FunctionNotUnderstood(enc, &(val)->u.functionNotUnderstood))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_MasterSlaveDeterminationRelease(enc, &(val)->u.masterSlaveDeterminationRelease))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_TerminalCapabilitySetRelease(enc, &(val)->u.terminalCapabilitySetRelease))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_OpenLogicalChannelConfirm(enc, &(val)->u.openLogicalChannelConfirm))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_RequestChannelCloseRelease(enc, &(val)->u.requestChannelCloseRelease))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_MultiplexEntrySendRelease(enc, &(val)->u.multiplexEntrySendRelease))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_RequestMultiplexEntryRelease(enc, &(val)->u.requestMultiplexEntryRelease))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_RequestModeRelease(enc, &(val)->u.requestModeRelease))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_MiscellaneousIndication(enc, &(val)->u.miscellaneousIndication))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_JitterIndication(enc, &(val)->u.jitterIndication))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_H223SkewIndication(enc, &(val)->u.h223SkewIndication))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_NewATMVCIndication(enc, &(val)->u.newATMVCIndication))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_UserInputIndication(enc, &(val)->u.userInput))
	    return 0;
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H2250MaximumSkewIndication(ee, &(val)->u.h2250MaximumSkewIndication))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 16:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_MCLocationIndication(ee, &(val)->u.mcLocationIndication))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 17:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceIndication(ee, &(val)->u.conferenceIndication))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 18:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_VendorIdentification(ee, &(val)->u.vendorIdentification))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 19:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_FunctionNotSupported(ee, &(val)->u.functionNotSupported))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IndicationMessage(ASN1decoding_t dec, IndicationMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardMessage(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_FunctionNotUnderstood(dec, &(val)->u.functionNotUnderstood))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_MasterSlaveDeterminationRelease(dec, &(val)->u.masterSlaveDeterminationRelease))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_TerminalCapabilitySetRelease(dec, &(val)->u.terminalCapabilitySetRelease))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_OpenLogicalChannelConfirm(dec, &(val)->u.openLogicalChannelConfirm))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_RequestChannelCloseRelease(dec, &(val)->u.requestChannelCloseRelease))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_MultiplexEntrySendRelease(dec, &(val)->u.multiplexEntrySendRelease))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_RequestMultiplexEntryRelease(dec, &(val)->u.requestMultiplexEntryRelease))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_RequestModeRelease(dec, &(val)->u.requestModeRelease))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_MiscellaneousIndication(dec, &(val)->u.miscellaneousIndication))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_JitterIndication(dec, &(val)->u.jitterIndication))
	    return 0;
	break;
    case 12:
	if (!ASN1Dec_H223SkewIndication(dec, &(val)->u.h223SkewIndication))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_NewATMVCIndication(dec, &(val)->u.newATMVCIndication))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_UserInputIndication(dec, &(val)->u.userInput))
	    return 0;
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H2250MaximumSkewIndication(dd, &(val)->u.h2250MaximumSkewIndication))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 16:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_MCLocationIndication(dd, &(val)->u.mcLocationIndication))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 17:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceIndication(dd, &(val)->u.conferenceIndication))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 18:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_VendorIdentification(dd, &(val)->u.vendorIdentification))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 19:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_FunctionNotSupported(dd, &(val)->u.functionNotSupported))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_IndicationMessage(IndicationMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardMessage(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_FunctionNotUnderstood(&(val)->u.functionNotUnderstood);
	    break;
	case 7:
	    ASN1Free_MultiplexEntrySendRelease(&(val)->u.multiplexEntrySendRelease);
	    break;
	case 8:
	    ASN1Free_RequestMultiplexEntryRelease(&(val)->u.requestMultiplexEntryRelease);
	    break;
	case 10:
	    ASN1Free_MiscellaneousIndication(&(val)->u.miscellaneousIndication);
	    break;
	case 14:
	    ASN1Free_UserInputIndication(&(val)->u.userInput);
	    break;
	case 16:
	    ASN1Free_MCLocationIndication(&(val)->u.mcLocationIndication);
	    break;
	case 18:
	    ASN1Free_VendorIdentification(&(val)->u.vendorIdentification);
	    break;
	case 19:
	    ASN1Free_FunctionNotSupported(&(val)->u.functionNotSupported);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MultimediaSystemControlMessage(ASN1encoding_t enc, MultimediaSystemControlMessage *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_RequestMessage(enc, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ResponseMessage(enc, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_CommandMessage(enc, &(val)->u.command))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_IndicationMessage(enc, &(val)->u.indication))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultimediaSystemControlMessage(ASN1decoding_t dec, MultimediaSystemControlMessage *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_RequestMessage(dec, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ResponseMessage(dec, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_CommandMessage(dec, &(val)->u.command))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_IndicationMessage(dec, &(val)->u.indication))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultimediaSystemControlMessage(MultimediaSystemControlMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_RequestMessage(&(val)->u.request);
	    break;
	case 2:
	    ASN1Free_ResponseMessage(&(val)->u.response);
	    break;
	case 3:
	    ASN1Free_CommandMessage(&(val)->u.command);
	    break;
	case 4:
	    ASN1Free_IndicationMessage(&(val)->u.indication);
	    break;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h245asn1.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

#ifndef H245ASN1_H
#define H245ASN1_H

#include "h245asn.h"
#include "av_asn1.h"
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif


// LONCHANC: ORIGINAL MAPPING WITH NEW STRUCTURE NAMES

#define VCCapabilityLink                PH222Capability_vcCapability
#define SmltnsCpbltsLink                PCapabilityDescriptor_simultaneousCapabilities
#define CapabilityTableLink             PTerminalCapabilitySet_capabilityTable
#define MultiplexEntryDescriptorLink    PMultiplexEntrySend_multiplexEntryDescriptors
#define CommunicationModeTableLink      PCommunicationModeResponse_communicationModeTable
#define TerminalListResponseLink        PConferenceResponse_terminalListResponse
#define CpbltyTblEntryNmbrsLink         PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers
#define CommunicationModeCommandLink    PCommunicationModeCommand_communicationModeTable
#define CentralizedDataLink             PMediaDistributionCapability_centralizedData
#define DistributedDataLink             PMediaDistributionCapability_distributedData
#define MediaDistributionCapabilityLink PMultipointCapability_mediaDistributionCapability
#define NonStandardDataLink             PConferenceCapability_nonStandardData
#define RouteLink                       PUnicastAddress_iPSourceRouteAddress_route
#define H2250LCPs_nnStndrdLink          PH2250LogicalChannelParameters_nonStandard
#define MultiplexElementLink            PMultiplexElement_type_subElementList
#define RequestedModesLink              PRequestMode_requestedModes
#define H2250LCAPs_nnStndrdLink         PH2250LogicalChannelAckParameters_nonStandard
#define CMTEy_nnStndrdLink              PCommunicationModeTableEntry_nonStandard
#define OBJECTID                        struct ObjectID_
#define POBJECTID                       struct ObjectID_ *
typedef DataApplicationCapability_application_t84       H245_CAP_T84_T;
typedef DataApplicationCapability_application_nlpid     H245_CAP_NLPID_T;
typedef AudioCapability_g7231                           H245_CAP_G723_T;


// LONCHANC: NEW MAPPING FOR FIELDS AND DEFINITIONS

// H223Capability_h223MultiplexTableCapability
#define h223MltplxTblCpblty_bsc_chosen  basic_chosen
#define h223MTCy_enhncd_chosen          enhanced_chosen
#define h223MTCy_enhncd                 enhanced

// V76Capability
#define sspndRsmCpbltywAddrss           suspendResumeCapabilitywoAddress

// DataProtocolCapability
#define DtPrtclCpblty_nnStndrd_chosen   DataProtocolCapability_nonStandard_chosen
#define sgmnttnAndRssmbly_chosen        segmentationAndReassembly_chosen          
#define DtPrtclCpblty_nnStndrd          nonStandard

// DataApplicationCapability_application
#define DACy_applctn_nnStndrd_chosen    DataApplicationCapability_application_nonStandard_chosen
#define DACy_applctn_t120_chosen        DataApplicationCapability_application_t120_chosen
#define DACy_applctn_dsm_cc_chosen      DataApplicationCapability_application_dsm_cc_chosen
#define DACy_applctn_usrDt_chosen       DataApplicationCapability_application_userData_chosen
#define DACy_applctn_t84_chosen         DataApplicationCapability_application_t84_chosen
#define DACy_applctn_t434_chosen        DataApplicationCapability_application_t434_chosen
#define DACy_applctn_h224_chosen        DataApplicationCapability_application_h224_chosen
#define DACy_applctn_nlpd_chosen        DataApplicationCapability_application_nlpid_chosen
#define DACy_applctn_dsvdCntrl_chosen   DataApplicationCapability_application_dsvdControl_chosen
#define DACy_an_h222DtPrttnng_chosen    DataApplicationCapability_application_h222DataPartitioning_chosen
#define DACy_applctn_nnStndrd           nonStandard
#define DACy_applctn_t120               t120
#define DACy_applctn_dsm_cc             dsm_cc
#define DACy_applctn_usrDt              userData
#define DACy_applctn_t84                t84
#define DACy_applctn_t434               t434
#define DACy_applctn_h224               h224
#define DACy_applctn_nlpd               nlpid
#define DACy_an_h222DtPrttnng           h222DataPartitioning

// H2250Capability
#define rcvAndTrnsmtMltpntCpblty        receiveAndTransmitMultipointCapability

// H223AnnexACapability_h223AnnexAMultiplexTableCapability
#define h223AAMTCy_bsc_chosen           H223AnnexACapability_h223AnnexAMultiplexTableCapability_basic_chosen
#define h223AAMTCy_enhncd_chosen        H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced_chosen
#define h223AAMTCy_enhncd               enhanced

// MultiplexCapability
#define MltplxCpblty_nonStandard_chosen MultiplexCapability_nonStandard_chosen
#define MltplxCpblty_nonStandard        nonStandard

// H261VideoCapability
#define H261VdCpblty_qcifMPI_present    H261VideoCapability_qcifMPI_present
#define H261VdCpblty_cifMPI_present     H261VideoCapability_cifMPI_present
#define H261VdCpblty_qcifMPI            qcifMPI
#define H261VdCpblty_cifMPI             cifMPI
#define tmprlSptlTrdOffCpblty           temporalSpatialTradeOffCapability

// H262VideoCapability
#define H262VdCpblty_vdBtRt_present     H262VideoCapability_videoBitRate_present
#define H262VdCpblty_vbvBffrSz_present  H262VideoCapability_vbvBufferSize_present
#define H262VdCpblty_smplsPrLn_present  H262VideoCapability_samplesPerLine_present
#define H262VdCpblty_lnsPrFrm_present   H262VideoCapability_linesPerFrame_present
#define H262VdCpblty_frmsPrScnd_present H262VideoCapability_framesPerSecond_present
#define H262VCy_lmnncSmplRt_present     H262VideoCapability_luminanceSampleRate_present
#define H262VdCpblty_vdBtRt             videoBitRate
#define H262VdCpblty_vbvBffrSz          vbvBufferSize
#define H262VdCpblty_smplsPrLn          samplesPerLine
#define H262VdCpblty_lnsPrFrm           linesPerFrame
#define H262VdCpblty_frmsPrScnd         framesPerSecond
#define H262VCy_lmnncSmplRt             luminanceSampleRate

// H263VideoCapability
#define H263VdCpblty_qcifMPI_present    H263VideoCapability_qcifMPI_present
#define H263VdCpblty_cifMPI_present     H263VideoCapability_cifMPI_present
#define H263VCy_errrCmpnstn_present     H263VideoCapability_errorCompensation_present
#define H263VdCpblty_qcifMPI            qcifMPI
#define H263VdCpblty_cifMPI             cifMPI
#define tmprlSptlTrdOffCpblty           temporalSpatialTradeOffCapability
#define H263VCy_errrCmpnstn             errorCompensation

// IS11172VideoCapability
#define IS11172VdCpblty_vdBtRt_present  IS11172VideoCapability_videoBitRate_present
#define IS11172VCy_vbvBffrSz_present    IS11172VideoCapability_vbvBufferSize_present
#define IS11172VCy_smplsPrLn_present    IS11172VideoCapability_samplesPerLine_present
#define IS11172VCy_lnsPrFrm_present     IS11172VideoCapability_linesPerFrame_present
#define IS11172VdCpblty_pctrRt_present  IS11172VideoCapability_pictureRate_present
#define IS11172VCy_lmnncSmplRt_present  IS11172VideoCapability_luminanceSampleRate_present
#define IS11172VdCpblty_vdBtRt          videoBitRate
#define IS11172VCy_vbvBffrSz            vbvBufferSize
#define IS11172VCy_smplsPrLn            samplesPerLine
#define IS11172VCy_lnsPrFrm             linesPerFrame
#define IS11172VdCpblty_pctrRt          pictureRate
#define IS11172VCy_lmnncSmplRt          luminanceSampleRate

// VideoCapability
#define VdCpblty_nonStandard_chosen     VideoCapability_nonStandard_chosen
#define VdCpblty_nonStandard            nonStandard

// AudioCapability
#define AdCpblty_nonStandard_chosen     AudioCapability_nonStandard_chosen
#define AdCpblty_g711Alaw64k_chosen     AudioCapability_g711Alaw64k_chosen
#define AdCpblty_g711Alaw56k_chosen     AudioCapability_g711Alaw56k_chosen
#define AdCpblty_g711Ulaw64k_chosen     AudioCapability_g711Ulaw64k_chosen
#define AdCpblty_g711Ulaw56k_chosen     AudioCapability_g711Ulaw56k_chosen
// #define AudioCapability_g722_64k_chosen g722_64k_chosen
// #define AudioCapability_g722_56k_chosen g722_56k_chosen
// #define AudioCapability_g722_48k_chosen g722_48k_chosen
#define AdCpblty_g729AnnexA_chosen      AudioCapability_g729AnnexA_chosen
#define ACy_g729AASSn_chosen            AudioCapability_g729AnnexAwSilenceSuppression_chosen
#define AdCpblty_nonStandard            nonStandard
#define AdCpblty_g711Alaw64k            g711Alaw64k
#define AdCpblty_g711Alaw56k            g711Alaw56k
#define AdCpblty_g711Ulaw64k            g711Ulaw64k
#define AdCpblty_g711Ulaw56k            g711Ulaw56k
#define AudioCapability_g722_64k        g722_64k
#define AudioCapability_g722_56k        g722_56k
#define AudioCapability_g722_48k        g722_48k
#define AudioCapability_g7231           g7231
#define AudioCapability_g728            g728
#define AudioCapability_g729            g729
#define AdCpblty_g729AnnexA             g729AnnexA
#define ACy_g729AASSn                   g729AnnexAwSilenceSuppression

// Capability
#define rcvAndTrnsmtVdCpblty_chosen     receiveAndTransmitVideoCapability_chosen
#define rcvAndTrnsmtAdCpblty_chosen     receiveAndTransmitAudioCapability_chosen
#define rcvDtApplctnCpblty_chosen       receiveDataApplicationCapability_chosen
#define trnsmtDtApplctnCpblty_chosen    transmitDataApplicationCapability_chosen
#define rATDACy_chosen                  receiveAndTransmitDataApplicationCapability_chosen
#define h233EncryptnTrnsmtCpblty_chosen h233EncryptionTransmitCapability_chosen
#define h233EncryptnRcvCpblty_chosen    h233EncryptionReceiveCapability_chosen
#define Capability_nonStandard          nonStandard
#define rcvAndTrnsmtVdCpblty            receiveAndTransmitVideoCapability
#define rcvAndTrnsmtAdCpblty            receiveAndTransmitAudioCapability
#define rcvDtApplctnCpblty              receiveDataApplicationCapability
#define trnsmtDtApplctnCpblty           transmitDataApplicationCapability
#define rATDACy                         receiveAndTransmitDataApplicationCapability
#define h233EncryptnTrnsmtCpblty        h233EncryptionTransmitCapability
#define h233EncryptnRcvCpblty           h233EncryptionReceiveCapability

// CapabilityDescriptor
#define smltnsCpblts_present            simultaneousCapabilities_present
#define smltnsCpblts                    simultaneousCapabilities

// EncryptionMode
#define EncryptnMd_nonStandard_chosen   EncryptionMode_nonStandard_chosen
#define EncryptnMd_nonStandard          nonStandard

// DataType
#define DataType_nonStandard            nonStandard
#define DataType_videoData              videoData
#define DataType_audioData              audioData
#define DataType_data                   data

// H223LogicalChannelParameters_adaptationLayerType
#define H223LCPs_aLTp_nnStndrd_chosen   H223LogicalChannelParameters_adaptationLayerType_nonStandard_chosen
#define H223LCPs_aLTp_al1Frmd_chosen    H223LogicalChannelParameters_adaptationLayerType_al1Framed_chosen
#define H223LCPs_aLTp_al1NtFrmd_chosen  H223LogicalChannelParameters_adaptationLayerType_al1NotFramed_chosen
#define H223LCPs_aLTp_a2WSNs_1_chosen   H223LogicalChannelParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen
#define H223LCPs_aLTp_a2WSNs_2_chosen   H223LogicalChannelParameters_adaptationLayerType_al2WithSequenceNumbers_chosen
#define H223LCPs_aLTp_al3_chosen        H223LogicalChannelParameters_adaptationLayerType_al3_chosen
#define H223LCPs_aLTp_nnStndrd          nonStandard
#define H223LCPs_aLTp_al3               al3

// UnicastAddress
#define UncstAddrss_iP6Address_chosen   UnicastAddress_iP6Address_chosen
#define UAs_nnStndrdAddrss_chosen       UnicastAddress_nonStandardAddress_chosen
#define UnicastAddress_iPAddress        iPAddress
#define UncstAddrss_iP6Address          iP6Address
#define UnicastAddress_nsap             nsap
#define UAs_nnStndrdAddrss              nonStandardAddress

// MulticastAddress
#define MltcstAddrss_iPAddress_chosen   MulticastAddress_iPAddress_chosen
#define MltcstAddrss_iP6Address_chosen  MulticastAddress_iP6Address_chosen
#define MAs_nnStndrdAddrss_chosen       MulticastAddress_nonStandardAddress_chosen
#define MltcstAddrss_iPAddress          iPAddress
#define MltcstAddrss_iP6Address         iP6Address
#define MulticastAddress_nsap           nsap
#define MAs_nnStndrdAddrss              nonStandardAddress

// H2250LogicalChannelParameters
#define H2250LCPs_nnStndrd_present      H2250LogicalChannelParameters_nonStandard_present
#define H2250LCPs_assctdSssnID_present  H2250LogicalChannelParameters_associatedSessionID_present
#define H2250LCPs_mdChnnl_present       H2250LogicalChannelParameters_mediaChannel_present
#define H2250LCPs_mdGrntdDlvry_present  H2250LogicalChannelParameters_mediaGuaranteedDelivery_present
#define H2250LCPs_mdCntrlChnnl_present  H2250LogicalChannelParameters_mediaControlChannel_present
#define H2250LCPs_mCGDy_present         H2250LogicalChannelParameters_mediaControlGuaranteedDelivery_present
#define H2250LCPs_dRTPPTp_present       H2250LogicalChannelParameters_dynamicRTPPayloadType_present
#define H2250LCPs_nnStndrd              nonStandard
#define H2250LCPs_assctdSssnID          associatedSessionID
#define H2250LCPs_mdChnnl               mediaChannel
#define H2250LCPs_mdGrntdDlvry          mediaGuaranteedDelivery
#define H2250LCPs_mdCntrlChnnl          mediaControlChannel
#define H2250LCPs_mCGDy                 mediaControlGuaranteedDelivery
#define H2250LCPs_dRTPPTp               dynamicRTPPayloadType

// OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters
#define fLCPs_mPs_h222LCPs_chosen       OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen
#define fLCPs_mPs_h223LCPs_chosen       OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen
#define fLCPs_mPs_v76LCPs_chosen        OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen
#define fLCPs_mPs_h2250LCPs_chosen      OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen
#define fLCPs_mPs_h223AALCPs_chosen     OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223AnnexALogicalChannelParameters_chosen
#define fLCPs_mPs_h222LCPs              h222LogicalChannelParameters
#define fLCPs_mPs_h223LCPs              h223LogicalChannelParameters
#define fLCPs_mPs_v76LCPs               v76LogicalChannelParameters
#define fLCPs_mPs_h2250LCPs             h2250LogicalChannelParameters
#define fLCPs_mPs_h223AALCPs            h223AnnexALogicalChannelParameters

// OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters
#define rLCPs_mPs_h223LCPs_chosen       OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen
#define rLCPs_mPs_v76LCPs_chosen        OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen
#define rLCPs_mPs_h2250LCPs_chosen      OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen
#define rLCPs_mPs_h223AALCPs_chosen     OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223AnnexALogicalChannelParameters_chosen
#define rLCPs_mPs_h223LCPs              h223LogicalChannelParameters
#define rLCPs_mPs_v76LCPs               v76LogicalChannelParameters
#define rLCPs_mPs_h2250LCPs             h2250LogicalChannelParameters
#define rLCPs_mPs_h223AALCPs            h223AnnexALogicalChannelParameters

// OpenLogicalChannel
#define OLCl_rLCPs_present              OpenLogicalChannel_reverseLogicalChannelParameters_present
#define OpnLgclChnnl_sprtStck_present   OpenLogicalChannel_separateStack_present
#define fLCPs_prtNmbr_present           OpenLogicalChannel_forwardLogicalChannelParameters_portNumber_present
#define fLCPs_prtNmbr                   portNumber
#define OLCl_rLCPs_mltplxPrmtrs_present OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_present
#define OLCl_rLCPs_mltplxPrmtrs         multiplexParameters
#define OLCl_rLCPs                      reverseLogicalChannelParameters
#define OpnLgclChnnl_sprtStck           separateStack

// MultiplexElement_type
#define typ_logicalChannelNumber_chosen MultiplexElement_type_logicalChannelNumber_chosen
#define typ_logicalChannelNumber        logicalChannelNumber

// MultiplexElement_repeatCount
#define repeatCount_finite_chosen       MultiplexElement_repeatCount_finite_chosen
#define repeatCount_finite              finite

// H261VideoMode_resolution
#define H261VdMd_resolution_qcif_chosen H261VideoMode_resolution_qcif_chosen
#define H261VdMd_resolution_cif_chosen  H261VideoMode_resolution_cif_chosen

// H262VideoMode_profileAndLevel
#define prflAndLvl_SpatialatH_14_chosen profileAndLevel_SpatialatH_14_chosen

// H262VideoMode
#define H262VdMd_videoBitRate_present   H262VideoMode_videoBitRate_present
#define H262VdMd_vbvBufferSize_present  H262VideoMode_vbvBufferSize_present
#define H262VdMd_samplesPerLine_present H262VideoMode_samplesPerLine_present
#define H262VdMd_linesPerFrame_present  H262VideoMode_linesPerFrame_present
#define H262VdMd_frmsPrScnd_present     H262VideoMode_framesPerSecond_present
#define H262VdMd_lmnncSmplRt_present    H262VideoMode_luminanceSampleRate_present
#define H262VdMd_videoBitRate           videoBitRate
#define H262VdMd_vbvBufferSize          vbvBufferSize
#define H262VdMd_samplesPerLine         samplesPerLine
#define H262VdMd_linesPerFrame          linesPerFrame
#define H262VdMd_frmsPrScnd             framesPerSecond
#define H262VdMd_lmnncSmplRt            luminanceSampleRate

// H263VideoMode_resolution
#define H263VdMd_resolution_qcif_chosen H263VideoMode_resolution_qcif_chosen
#define H263VdMd_resolution_cif_chosen  H263VideoMode_resolution_cif_chosen

// H263VideoMode
#define H263VdMd_errrCmpnstn_present    H263VideoMode_errorCompensation_present
#define H263VdMd_errrCmpnstn            errorCompensation

// IS11172VideoMode
#define IS11172VdMd_vdBtRt_present      IS11172VideoMode_videoBitRate_present
#define IS11172VdMd_vbvBffrSz_present   IS11172VideoMode_vbvBufferSize_present
#define IS11172VdMd_smplsPrLn_present   IS11172VideoMode_samplesPerLine_present
#define IS11172VdMd_lnsPrFrm_present    IS11172VideoMode_linesPerFrame_present
#define IS11172VdMd_pictureRate_present IS11172VideoMode_pictureRate_present
#define IS11172VdMd_lmnncSmplRt_present IS11172VideoMode_luminanceSampleRate_present
#define IS11172VdMd_vdBtRt              videoBitRate
#define IS11172VdMd_vbvBffrSz           vbvBufferSize
#define IS11172VdMd_smplsPrLn           samplesPerLine
#define IS11172VdMd_lnsPrFrm            linesPerFrame
#define IS11172VdMd_pictureRate         pictureRate
#define IS11172VdMd_lmnncSmplRt         luminanceSampleRate

// VideoMode
#define VideoMode_nonStandard           nonStandard

// IS11172AudioMode_audioLayer
#define audioLayer1_chosen      IS11172AudioMode_audioLayer_audioLayer1_chosen
#define audioLayer2_chosen      IS11172AudioMode_audioLayer_audioLayer2_chosen
#define audioLayer3_chosen      IS11172AudioMode_audioLayer_audioLayer3_chosen

// IS11172AudioMode_audioSampling
#define IS11172AMd_aSg_aS32k_chosen     IS11172AudioMode_audioSampling_audioSampling32k_chosen
#define IS11172AMd_aSg_aS441_chosen     IS11172AudioMode_audioSampling_audioSampling44k1_chosen
#define IS11172AMd_aSg_aS48k_chosen     IS11172AudioMode_audioSampling_audioSampling48k_chosen

// IS11172AudioMode_multichannelType
#define IS11172AMd_mTp_snglChnnl_chosen IS11172AudioMode_multichannelType_singleChannel_chosen
#define IS11172AMd_mTp_tCSr_chosen      IS11172AudioMode_multichannelType_twoChannelStereo_chosen
#define IS11172AMd_mTp_twChnnlDl_chosen IS11172AudioMode_multichannelType_twoChannelDual_chosen

// IS13818AudioMode_audioSampling
#define IS13818AMd_aSg_aS32k_chosen     IS13818AudioMode_audioSampling_audioSampling32k_chosen
#define IS13818AMd_aSg_aS441_chosen     IS13818AudioMode_audioSampling_audioSampling44k1_chosen
#define IS13818AMd_aSg_aS48k_chosen     IS13818AudioMode_audioSampling_audioSampling48k_chosen

// IS13818AudioMode_multichannelType
#define IS13818AMd_mTp_snglChnnl_chosen IS13818AudioMode_multichannelType_singleChannel_chosen
#define IS13818AMd_mTp_tCSr_chosen      IS13818AudioMode_multichannelType_twoChannelStereo_chosen
#define IS13818AMd_mTp_twChnnlDl_chosen IS13818AudioMode_multichannelType_twoChannelDual_chosen

// AudioMode_g7231
#define nSlncSpprssnLwRt_chosen         noSilenceSuppressionLowRate_chosen
#define nSlncSpprssnHghRt_chosen        noSilenceSuppressionHighRate_chosen
#define slncSpprssnLwRt_chosen          silenceSuppressionLowRate_chosen
#define slncSpprssnHghRt_chosen         silenceSuppressionHighRate_chosen

// AudioMode
#define AMd_g729AASSn_chosen            AudioMode_g729AnnexAwSilenceSuppression_chosen
#define AudioMode_nonStandard           nonStandard
#define AudioMode_g7231                 g7231

// DataMode_application
#define DtMd_applctn_nonStandard_chosen DataMode_application_nonStandard_chosen
#define DtMd_application_t120_chosen    DataMode_application_t120_chosen
#define DtMd_application_dsm_cc_chosen  dsm_cc_chosen
#define DtMd_applctn_userData_chosen    DataMode_application_userData_chosen
#define DtMd_application_t434_chosen    DataMode_application_t434_chosen
#define DtMd_application_h224_chosen    DataMode_application_h224_chosen
#define DtMd_application_nlpid_chosen   DataMode_application_nlpid_chosen
#define DtMd_applctn_dsvdControl_chosen DataMode_application_dsvdControl_chosen
#define DMd_an_h222DtPrttnng_chosen     DataMode_application_h222DataPartitioning_chosen
#define DtMd_applctn_nonStandard        nonStandard
#define DtMd_application_t120           t120
#define DtMd_application_dsm_cc         dsm_cc
#define DtMd_applctn_userData           userData
#define DataMode_application_t84        t84
#define DtMd_application_t434           t434
#define DtMd_application_h224           h224
#define DtMd_application_nlpid          nlpid
#define DMd_an_h222DtPrttnng            h222DataPartitioning

// H223ModeParameters_adaptationLayerType
#define H223MPs_aLTp_nnStndrd_chosen    H223ModeParameters_adaptationLayerType_nonStandard_chosen
#define H223MPs_aLTp_al1Frmd_chosen     H223ModeParameters_adaptationLayerType_al1Framed_chosen
#define H223MPs_aLTp_al1NtFrmd_chosen   H223ModeParameters_adaptationLayerType_al1NotFramed_chosen
#define H223MPs_aLTp_a2WSNs_1_chosen    H223ModeParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen
#define H223MPs_aLTp_a2WSNs_2_chosen    H223ModeParameters_adaptationLayerType_al2WithSequenceNumbers_chosen
#define H223MPs_adpttnLyrTyp_al3_chosen H223ModeParameters_adaptationLayerType_al3_chosen
#define H223MPs_aLTp_nnStndrd           nonStandard
#define H223MPs_adpttnLyrTyp_al3        al3

// ModeElement
#define h223AnnxAMdPrmtrs_present       h223AnnexAModeParameters_present
#define h223AnnxAMdPrmtrs               h223AnnexAModeParameters

// MaintenanceLoopRequest_type
#define systemLoop_chosen               MaintenanceLoopRequest_type_systemLoop_chosen // MaintenanceLoopReject_type_systemLoop_chosen
#define mediaLoop_chosen                MaintenanceLoopRequest_type_mediaLoop_chosen // MaintenanceLoopReject_type_mediaLoop_chosen
#define logicalChannelLoop_chosen       MaintenanceLoopRequest_type_logicalChannelLoop_chosen // MaintenanceLoopReject_type_logicalChannelLoop_chosen

// RequestMessage
#define RqstMssg_nonStandard_chosen     RequestMessage_nonStandard_chosen
#define h223AnnxARcnfgrtn_chosen        h223AnnexAReconfiguration_chosen
#define RqstMssg_nonStandard            nonStandard
#define h223AnnxARcnfgrtn               h223AnnexAReconfiguration

// TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded
#define hghstEntryNmbrPrcssd_chosen     highestEntryNumberProcessed_chosen
#define hghstEntryNmbrPrcssd            highestEntryNumberProcessed

// TerminalCapabilitySetReject_cause
#define TCSRt_cs_unspcfd_chosen         TerminalCapabilitySetReject_cause_unspecified_chosen
#define dscrptrCpctyExcdd_chosen        descriptorCapacityExceeded_chosen
#define tblEntryCpctyExcdd_chosen       tableEntryCapacityExceeded_chosen
#define tblEntryCpctyExcdd              tableEntryCapacityExceeded

// H2250LgclChnnlAckPrmtrs vs H2250LogicalChannelAckParameters
#define H2250LgclChnnlAckPrmtrs         H2250LogicalChannelAckParameters
#define H2250LCAPs_nnStndrd_present     H2250LogicalChannelAckParameters_nonStandard_present
#define H2250LCAPs_mdChnnl_present      H2250LogicalChannelAckParameters_mediaChannel_present
#define H2250LCAPs_mdCntrlChnnl_present H2250LogicalChannelAckParameters_mediaControlChannel_present
#define H2250LCAPs_dRTPPTp_present      H2250LogicalChannelAckParameters_dynamicRTPPayloadType_present
#define H2250LCAPs_nnStndrd             nonStandard
#define H2250LCAPs_mdChnnl              mediaChannel
#define H2250LCAPs_mdCntrlChnnl         mediaControlChannel
#define H2250LCAPs_dRTPPTp              dynamicRTPPayloadType

// OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters
#define rLCPs_mPs_h222LCPs_chosen       OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen
#define mPs_h2250LgclChnnlPrmtrs_chosen OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen
#define rLCPs_mPs_h222LCPs              h222LogicalChannelParameters
#define mPs_h2250LgclChnnlPrmtrs        h2250LogicalChannelParameters

// OpenLogicalChannelAck_forwardMultiplexAckParameters
#define h2250LgclChnnlAckPrmtrs_chosen  h2250LogicalChannelAckParameters_chosen
#define h2250LgclChnnlAckPrmtrs         h2250LogicalChannelAckParameters

// OpenLogicalChannelAck
#define OLCAk_rLCPs_present             OpenLogicalChannelAck_reverseLogicalChannelParameters_present
#define OLCAk_sprtStck_present          OpenLogicalChannelAck_separateStack_present
#define frwrdMltplxAckPrmtrs_present    forwardMultiplexAckParameters_present
#define rLCPs_prtNmbr_present           OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber_present
#define OLCAk_rLCPs_mPs_present         OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_present
#define rLCPs_prtNmbr                   portNumber
#define OLCAk_rLCPs_mPs                 multiplexParameters
#define OLCAk_rLCPs                     reverseLogicalChannelParameters
#define OLCAk_sprtStck                  separateStack
#define frwrdMltplxAckPrmtrs            forwardMultiplexAckParameters

// OpenLogicalChannelReject_cause
#define OLCRt_cs_unspcfd_chosen         OpenLogicalChannelReject_cause_unspecified_chosen
#define unstblRvrsPrmtrs_chosen         unsuitableReverseParameters_chosen
#define dtTypALCmbntnNtSpprtd_chosen    dataTypeALCombinationNotSupported_chosen
#define mltcstChnnlNtAllwd_chosen       multicastChannelNotAllowed_chosen
#define sprtStckEstblshmntFld_chosen    separateStackEstablishmentFailed_chosen

// MultiplexEntryRejectionDescriptions_cause
#define MERDs_cs_unspcfdCs_chosen       MultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen

// MltplxEntryRjctnDscrptns vs MultiplexEntryRejectionDescriptions
#define MltplxEntryRjctnDscrptns        MultiplexEntryRejectionDescriptions

// RequestMultiplexEntryRejectionDescriptions_cause
#define RMERDs_cs_unspcfdCs_chosen      RequestMultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen

// RqstMltplxEntryRjctnDscrptns vs RequestMultiplexEntryRejectionDescriptions
#define RqstMltplxEntryRjctnDscrptns    RequestMultiplexEntryRejectionDescriptions

// RequestModeAck_response
#define wllTrnsmtMstPrfrrdMd_chosen     willTransmitMostPreferredMode_chosen
#define wllTrnsmtLssPrfrrdMd_chosen     willTransmitLessPreferredMode_chosen

// CommunicationModeTableEntry_dataType
#define dataType_videoData_chosen       CommunicationModeTableEntry_dataType_videoData_chosen
#define dataType_audioData_chosen       CommunicationModeTableEntry_dataType_audioData_chosen
#define dataType_data_chosen            CommunicationModeTableEntry_dataType_data_chosen
#define dataType_videoData              videoData
#define dataType_audioData              audioData
#define dataType_data                   data

// CommunicationModeTableEntry
#define CMTEy_nnStndrd_present          CommunicationModeTableEntry_nonStandard_present
#define CMTEy_assctdSssnID_present      CommunicationModeTableEntry_associatedSessionID_present
#define CMTEy_mdChnnl_present           CommunicationModeTableEntry_mediaChannel_present
#define CMTEy_mdGrntdDlvry_present      CommunicationModeTableEntry_mediaGuaranteedDelivery_present
#define CMTEy_mdCntrlChnnl_present      CommunicationModeTableEntry_mediaControlChannel_present
#define CMTEy_mdCntrlGrntdDlvry_present CommunicationModeTableEntry_mediaControlGuaranteedDelivery_present
#define CMTEy_nnStndrd                  nonStandard
#define CMTEy_assctdSssnID              associatedSessionID
#define CMTEy_mdChnnl                   mediaChannel
#define CMTEy_mdGrntdDlvry              mediaGuaranteedDelivery
#define CMTEy_mdCntrlChnnl              mediaControlChannel
#define CMTEy_mdCntrlGrntdDlvry         mediaControlGuaranteedDelivery

// ResponseMessage
#define RspnsMssg_nonStandard_chosen    ResponseMessage_nonStandard_chosen
#define mstrSlvDtrmntnAck_chosen        masterSlaveDeterminationAck_chosen
#define mstrSlvDtrmntnRjct_chosen       masterSlaveDeterminationReject_chosen
#define trmnlCpbltyStRjct_chosen        terminalCapabilitySetReject_chosen
#define rqstChnnlClsRjct_chosen         requestChannelCloseReject_chosen
#define rqstMltplxEntryRjct_chosen      requestMultiplexEntryReject_chosen
#define cmmnctnMdRspns_chosen           communicationModeResponse_chosen
#define h223AnnxARcnfgrtnAck_chosen     h223AnnexAReconfigurationAck_chosen
#define h223AnnxARcnfgrtnRjct_chosen    h223AnnexAReconfigurationReject_chosen
#define RspnsMssg_nonStandard           nonStandard
#define mstrSlvDtrmntnAck               masterSlaveDeterminationAck
#define mstrSlvDtrmntnRjct              masterSlaveDeterminationReject
#define trmnlCpbltyStRjct               terminalCapabilitySetReject
#define rqstChnnlClsRjct                requestChannelCloseReject
#define rqstMltplxEntryRjct             requestMultiplexEntryReject
#define cmmnctnMdRspns                  communicationModeResponse
#define h223AnnxARcnfgrtnAck            h223AnnexAReconfigurationAck
#define h223AnnxARcnfgrtnRjct           h223AnnexAReconfigurationReject

// SendTerminalCapabilitySet
#define cpbltyTblEntryNmbrs_present     capabilityTableEntryNumbers_present
#define cpbltyDscrptrNmbrs_present      capabilityDescriptorNumbers_present
#define cpbltyTblEntryNmbrs             capabilityTableEntryNumbers
#define cpbltyDscrptrNmbrs              capabilityDescriptorNumbers

// FlowControlCommand_scope
#define FCCd_scp_lgclChnnlNmbr_chosen   FlowControlCommand_scope_logicalChannelNumber_chosen
#define FlwCntrlCmmnd_scp_rsrcID_chosen FlowControlCommand_scope_resourceID_chosen
#define FCCd_scp_whlMltplx_chosen       FlowControlCommand_scope_wholeMultiplex_chosen
#define FCCd_scp_lgclChnnlNmbr          logicalChannelNumber
#define FlwCntrlCmmnd_scp_rsrcID        resourceID

// EndSessionCommand
#define EndSssnCmmnd_nonStandard_chosen EndSessionCommand_nonStandard_chosen
#define EndSssnCmmnd_nonStandard        nonStandard

// MiscellaneousCommand_type
#define cnclMltpntMdCmmnd_chosen        cancelMultipointModeCommand_chosen
#define MCd_tp_vdTmprlSptlTrdOff_chosen MiscellaneousCommand_type_videoTemporalSpatialTradeOff_chosen
#define vdSndSyncEvryGOBCncl_chosen     videoSendSyncEveryGOBCancel_chosen
#define MCd_tp_vdTmprlSptlTrdOff        videoTemporalSpatialTradeOff

// ConferenceCommand
#define brdcstMyLgclChnnl_chosen        ConferenceCommand_broadcastMyLogicalChannel_chosen
#define cnclBrdcstMyLgclChnnl_chosen    cancelBroadcastMyLogicalChannel_chosen
#define cnclMkTrmnlBrdcstr_chosen       cancelMakeTerminalBroadcaster_chosen
#define brdcstMyLgclChnnl               broadcastMyLogicalChannel
#define cnclBrdcstMyLgclChnnl           cancelBroadcastMyLogicalChannel
             
// CommandMessage
#define CmmndMssg_nonStandard_chosen    CommandMessage_nonStandard_chosen
#define mntnncLpOffCmmnd_chosen         maintenanceLoopOffCommand_chosen
#define sndTrmnlCpbltySt_chosen         sendTerminalCapabilitySet_chosen
#define CmmndMssg_nonStandard           nonStandard
#define mntnncLpOffCmmnd                maintenanceLoopOffCommand
#define sndTrmnlCpbltySt                sendTerminalCapabilitySet

// FunctionNotUnderstood
#define FnctnNtUndrstd_request_chosen   FunctionNotUnderstood_request_chosen
#define FnctnNtUndrstd_response_chosen  FunctionNotUnderstood_response_chosen
#define FnctnNtUndrstd_command_chosen   FunctionNotUnderstood_command_chosen
#define FnctnNtUndrstd_request          request
#define FnctnNtUndrstd_response         response
#define FnctnNtUndrstd_command          command

// MiscellaneousIndication_type
#define cnclMltpntCnfrnc_chosen         cancelMultipointConference_chosen
#define mltpntScndryStts_chosen         multipointSecondaryStatus_chosen
#define cnclMltpntScndryStts_chosen     cancelMultipointSecondaryStatus_chosen
#define vdIndctRdyTActvt_chosen         videoIndicateReadyToActivate_chosen
#define MIn_tp_vdTmprlSptlTrdOff_chosen MiscellaneousIndication_type_videoTemporalSpatialTradeOff_chosen
#define MIn_tp_vdTmprlSptlTrdOff        videoTemporalSpatialTradeOff

// JitterIndication_scope
#define JIn_scp_lgclChnnlNmbr_chosen    JitterIndication_scope_logicalChannelNumber_chosen
#define JttrIndctn_scp_rsrcID_chosen    JitterIndication_scope_resourceID_chosen
#define JttrIndctn_scp_whlMltplx_chosen JitterIndication_scope_wholeMultiplex_chosen
#define JIn_scp_lgclChnnlNmbr           logicalChannelNumber
#define JttrIndctn_scp_rsrcID           resourceID

// UserInputIndication
#define UsrInptIndctn_nnStndrd_chosen   UserInputIndication_nonStandard_chosen
#define UsrInptIndctn_nnStndrd          nonStandard

// ConferenceIndication
#define cnclSnByAtLstOnOthr_chosen      cancelSeenByAtLeastOneOther_chosen

// IndicationMessage
#define IndctnMssg_nonStandard_chosen   IndicationMessage_nonStandard_chosen
#define mstrSlvDtrmntnRls_chosen        masterSlaveDeterminationRelease_chosen
#define trmnlCpbltyStRls_chosen         terminalCapabilitySetRelease_chosen
#define opnLgclChnnlCnfrm_chosen        openLogicalChannelConfirm_chosen
#define rqstChnnlClsRls_chosen          requestChannelCloseRelease_chosen
#define mltplxEntrySndRls_chosen        multiplexEntrySendRelease_chosen
#define rqstMltplxEntryRls_chosen       requestMultiplexEntryRelease_chosen
#define h2250MxmmSkwIndctn_chosen       h2250MaximumSkewIndication_chosen
#define IndctnMssg_nonStandard          nonStandard
#define mstrSlvDtrmntnRls               masterSlaveDeterminationRelease
#define trmnlCpbltyStRls                terminalCapabilitySetRelease
#define opnLgclChnnlCnfrm               openLogicalChannelConfirm
#define rqstChnnlClsRls                 requestChannelCloseRelease
#define mltplxEntrySndRls               multiplexEntrySendRelease
#define rqstMltplxEntryRls              requestMultiplexEntryRelease
#define h2250MxmmSkwIndctn              h2250MaximumSkewIndication

// MltmdSystmCntrlMssg vs MultimediaSystemControlMessage
#define MltmdSystmCntrlMssg             MultimediaSystemControlMessage
#define MltmdSystmCntrlMssg_PDU         MultimediaSystemControlMessage_PDU
#define MltmdSystmCntrlMssg_rqst_chosen MultimediaSystemControlMessage_request_chosen
#define MSCMg_rspns_chosen              MultimediaSystemControlMessage_response_chosen
#define MSCMg_cmmnd_chosen              MultimediaSystemControlMessage_command_chosen
#define MltmdSystmCntrlMssg_rqst        request
#define MSCMg_rspns                     response
#define MSCMg_cmmnd                     command


#ifdef __cplusplus
}
#endif

#endif // H245ASN1_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h245api.h ===
#ifndef H245API_H
#define H245API_H

/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   h245api.h  $
 *  $Revision:   1.64  $
 *  $Modtime:   04 Mar 1997 16:51:38  $
 *  $Log:   S:/sturgeon/src/include/vcs/h245api.h_v  $
 *
 *    Rev 1.64   04 Mar 1997 17:32:36   MANDREWS
 * H245CopyCap() and H245CopyCapDescriptor() now return HRESULTs.
 *
 *    Rev 1.63   26 Feb 1997 10:56:20   MANDREWS
 * Added H245_MAX_CAPID.
 *
 *    Rev 1.62   Feb 24 1997 18:28:26   tomitowx
 * multiple modedescriptor support
 *
 *    Rev 1.61   19 Dec 1996 17:16:10   EHOWARDX
 * Now using ASN.1 compiler C++ flag.
 *
 *    Rev 1.60   17 Dec 1996 17:14:12   EHOWARDX
 * Added pSeparateStack to IND_OPEN_T.
 *
 *    Rev 1.59   12 Dec 1996 11:24:38   EHOWARDX
 * Backed out H245_CONF_H323_OLD change.
 *
 *    Rev 1.57   11 Dec 1996 13:46:46   SBELL1
 * Changed H245Init to return linkLayer Physical ID
 *
 *    Rev 1.56   24 Oct 1996 15:57:54   MANDREWS
 * Fixed typo in last update.
 *
 *    Rev 1.55   Oct 21 1996 17:11:00   mandrews
 * Fixed type in last check-in.
 *
 *    Rev 1.54   Oct 21 1996 16:41:20   mandrews
 * Added H245_MASTER_SLAVE_CONFLICT as an additional openChannelReject
 * reason code.
 *
 *    Rev 1.53   17 Oct 1996 18:17:54   EHOWARDX
 * Changed general string to always be Unicode.
 *
 *    Rev 1.52   14 Oct 1996 14:00:28   EHOWARDX
 *
 * Unicode changes.
 *
 *    Rev 1.51   03 Sep 1996 18:09:54   EHOWARDX
 *
 * Changed some parameters to const.
 * Changed H245_REQ_ENTRY_H243_CONFERENCE_ID to H245_REQ_ENTER_H243_CONFERENCE
 *
 *    Rev 1.50   15 Aug 1996 14:33:48   EHOWARDX
 * Changed definition of H245_COMM_MODE_ENTRY_T as per Mike Andrews' request.
 *
 *    Rev 1.49   24 Jul 1996 15:18:16   EHOWARDX
 * Backed out change of IndNonstandardRequest to IndNonstandardReq,
 * IndNonstandardResponse to IndNonStandardRsp, and IndNonstandardCommand to
 * IndNonstandardCmd to make less work for upper layers (CCTEST).
 *
 *    Rev 1.48   19 Jul 1996 14:12:20   EHOWARDX
 *
 * Added indication callback structure for CommunicationModeResponse and
 * CommunicationModeCommand.
 *
 *    Rev 1.47   19 Jul 1996 12:50:30   EHOWARDX
 *
 * Multipoint clean-up.
 *
 *    Rev 1.46   16 Jul 1996 17:53:48   unknown
 * Added FNS indication.
 *
 *    Rev 1.45   16 Jul 1996 11:51:58   EHOWARDX
 *
 * Changed ERROR_LOCAL_BASE_ID to ERROR_BASE_ID.
 *
 *    Rev 1.44   16 Jul 1996 11:46:10   EHOWARDX
 *
 * Eliminated H245_ERROR_MUX_CAPS_ALREADY_SET (changing the existing
 * mux cap should not be an error).
 *
 *    Rev 1.43   11 Jul 1996 18:42:14   rodellx
 *
 * Fixed bug where HRESULT ids were in violation of Facility and/or Code
 * value rules.
 *
 *    Rev 1.42   10 Jul 1996 11:33:42   unknown
 * Changed error base.
 *
 *    Rev 1.41   01 Jul 1996 22:07:24   EHOWARDX
 * Added Conference and CommunicationMode structures and API functions.
 *
 *    Rev 1.40   18 Jun 1996 14:48:54   EHOWARDX
 *
 * Bumped version number to 2 and modified H245MaintenanceLoopRelease()
 * and associated Confirms.
 *
 *    Rev 1.39   14 Jun 1996 18:59:38   EHOWARDX
 * Geneva update.
 *
 *    Rev 1.38   31 May 1996 18:19:46   EHOWARDX
 * Brought error codes in line with STURERR.DOC guidelines.
 *
 *    Rev 1.37   30 May 1996 23:37:26   EHOWARDX
 * Clean up.
 *
 *    Rev 1.36   30 May 1996 13:55:02   EHOWARDX
 * Changed H245EndConnection to H245EndSession.
 * Removed H245_CONF_ENDCONNECTION.
 *
 *    Rev 1.35   29 May 1996 14:23:58   EHOWARDX
 * Changed definition of H245_ERROR_OK back to 0 (NOERROR == S_OK == 0).
 *
 *    Rev 1.34   29 May 1996 13:19:50   EHOWARDX
 * RESULT to HRESULT conversion.
 *
 *    Rev 1.33   24 May 1996 23:12:56   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.32   21 May 1996 18:23:58   EHOWARDX
 *
 * Added dwTransId parameter to H245RequestMultiplexEntry,
 * H245RequestMode, and H245MaintenanceLoopRequest.
 *
 *    Rev 1.31   20 May 1996 14:14:42   EHOWARDX
 * Fixed typo.
 *
 *    Rev 1.30   20 May 1996 14:05:20   EHOWARDX
 * Removed dwTransId formal parameter from H245EndConnection().
 *
 *    Rev 1.29   16 May 1996 15:51:56   EHOWARDX
 * Fixed typo in H245_INVALID_CAPDESCID.
 *
 *    Rev 1.28   16 May 1996 10:57:46   unknown
 * Added H245_INVALID_CAPDESCID.
 *
 *    Rev 1.27   14 May 1996 20:20:14   EHOWARDX
 * Removed H245_IND_SYS.
 *
 *    Rev 1.26   14 May 1996 19:00:58   EHOWARDX
 * Deleted unused H245_SYSCON_xxx values.
 *
 *    Rev 1.25   14 May 1996 16:58:48   EHOWARDX
 * Changed H245_IND_CAPDESC_T To H245_TOTCAPDESC_T.
 * H245EnumCaps() cap desc callback now takes single pointer to
 * H245_TOTCAPDESC_T instead of separate H245_CAPDESCID_T and
 * H245_CAPDESC_T pointer.
 *
 *    Rev 1.24   13 May 1996 23:13:46   EHOWARDX
 * Everything ready for Micrsoft drop on the 17th.
 *
 *    Rev 1.23   13 May 1996 15:43:16   EHOWARDX
 * Changed return type of H245CopyCapDescriptor from H245_CAPDESC_T pointer
 * to H245_TOTCAPDESC_T pointer.
 *
 *    Rev 1.22   13 May 1996 14:05:16   EHOWARDX
 * Added H245CopyCapDescriptor() and H245FreeCapDescriptor().
 *
 *    Rev 1.21   11 May 1996 20:00:34   EHOWARDX
 * Changed IS1381 to IS13818 (correct name for capability).
 * Changed H245SystemControl() - eliminated dwTransId and added
 * H245_SYSCON_GET_XXX requests.
 *
 *    Rev 1.20   10 May 1996 17:38:28   unknown
 * Changed H245GetCaps and H245EnumCaps to also return Cap Descriptors.
 *
 *    Rev 1.19   09 May 1996 20:22:58   EHOWARDX
 * Latest and greatest...
 *
 *    Rev 1.35   09 May 1996 19:38:14   EHOWARDX
 * Redesigned locking logic and added new functionality.
 *
 *    Rev 1.34   06 May 1996 13:19:44   EHOWARDX
 * Moved enums out of structures.
 * Added H245NonStandardH221() and H245NonStandardObject().
 *
 *    Rev 1.33   01 May 1996 19:29:16   EHOWARDX
 * Added H245CopyCap(), H245FreeCap(), H245CopyMux(), H245FreeMux().
 * Changed H2250_xxx definitions for H.225.0 address to H245_xxx.
 *
 *    Rev 1.32   27 Apr 1996 21:04:26   EHOWARDX
 * Changed channel numbers to words, added new open/open ack fields.
 *
 *    Rev 1.31   26 Apr 1996 15:57:14   EHOWARDX
 * Added new Terminal Capabilities.
 *
 *    Rev 1.27.1.6   25 Apr 1996 17:53:06   EHOWARDX
 * Added H245_INVALID_ID, currently set to zero, should be 0xFFFFFFFF later.
 *
 *    Rev 1.27.1.5   25 Apr 1996 16:50:04   EHOWARDX
 * Added new functions as per API Changes spec.
 *
 *    Rev 1.27.1.4   24 Apr 1996 20:57:30   EHOWARDX
 * Added new OpenLogicalChannelAck/OpenLogicalChannelReject support.
 *
 *    Rev 1.27.1.3   18 Apr 1996 15:56:42   EHOWARDX
 * Updated to 1.30.
 *
 *    Rev 1.27.1.2   16 Apr 1996 20:09:52   EHOWARDX
 * Added new H2250LogicalChannelParameter fields.
 *
 *    Rev 1.27.1.1   16 Apr 1996 18:45:24   EHOWARDX
 * Added silenceSupression to H.225.0 Logical Channel Parameters.
 *
 *    Rev 1.27.1.0   03 Apr 1996 15:56:14   cjutzi
 * Branched for H.323.
 *
 *    Rev 1.27   02 Apr 1996 08:29:44   cjutzi
 * - Changed CapDescriptor API
 *
 *    Rev 1.26   01 Apr 1996 16:46:50   cjutzi
 *
 * - Completed ENdConnection, and made asynch.. rather
 * than sync.. as before
 * Changed H245ShutDown to be sync rather than async..
 *
 *    Rev 1.25   29 Mar 1996 14:55:52   cjutzi
 *
 * - added USERINPUT stuff
 * - Added hooks for stats in SYSCON H245SystemControl
 *
 *    Rev 1.24   27 Mar 1996 10:55:40   cjutzi
 * - added c++ wrapper for API calls..
 *
 *    Rev 1.23   20 Mar 1996 14:42:46   cjutzi
 * - added ERROR NO_CAPDESC
 *
 *    Rev 1.22   18 Mar 1996 15:14:56   cjutzi
 *
 * - added RxPort and TEST_TIMER
 *
 *    Rev 1.21   12 Mar 1996 15:49:24   cjutzi
 *
 * - implemented locking
 * - added EndSession
 * - added Shutdown
 *
 *
 *    Rev 1.20   08 Mar 1996 14:06:04   cjutzi
 *
 * - Removed Simultanious capability api
 * - added CapabilityDescriptor api.. (very similar.. made more sence)
 * - compeleted Mux Table upcall information..
 *
 *    Rev 1.19   06 Mar 1996 08:45:58   cjutzi
 *
 * - added ERROR ASN1
 *
 *    Rev 1.18   05 Mar 1996 17:32:24   cjutzi
 *
 * - master slave indication message from Hani.. implemented..
 *   added H245_IND_MSTSLV ..
 *
 *    Rev 1.17   05 Mar 1996 16:36:46   cjutzi
 *
 * - removed MUX_ENTRY_DESC_T .. cleaned it up.. don't need it..
 *
 *    Rev 1.16   05 Mar 1996 10:06:30   cjutzi
 *
 * - added mux table entry stuff
 * - changed errors to map to 10000
 *
 *    Rev 1.15   01 Mar 1996 13:46:20   cjutzi
 * - added more error messages
 *
 *    Rev 1.14   29 Feb 1996 17:27:38   cjutzi
 *
 * - bi-directional channel working
 *
 *    Rev 1.13   29 Feb 1996 11:33:50   cjutzi
 * - fixed bug w/ H245_CONF_IND_T .. as global union.. fixed to be
 *   struct
 *
 *    Rev 1.12   29 Feb 1996 08:26:48   cjutzi
 *
 * - added 2 error messages (SIMCAPID and DATA_FORMAT)
 *
 *    Rev 1.11   27 Feb 1996 13:28:50   cjutzi
 * - added global protocol id H245_PROTOID
 *
 *    Rev 1.10   26 Feb 1996 17:24:10   cjutzi
 *
 * -  added MiscCommand.. had to add channel to H245_IND_MISC_T..
 *
 *    Rev 1.9   26 Feb 1996 11:07:24   cjutzi
 *
 * - added simultanoius caps..
 *
 *    Rev 1.8   16 Feb 1996 12:59:26   cjutzi
 * - added tracing and debug..
 * - got close to work.. Added structure to H245_IND_T.. new CLOSE indication
 *
 *    Rev 1.7   15 Feb 1996 14:13:08   cjutzi
 *
 * - re-arranged the AL_T entries for more clairity..
 *
 *    Rev 1.6   15 Feb 1996 10:48:30   cjutzi
 *
 * - major changes..
 * - added MUX_T
 * - changed H245_IND_T
 * - changed IND_OPEN/IND_OPEN_NEEDSRSP etc..
 *
 *    Rev 1.5   09 Feb 1996 16:14:04   cjutzi
 *
 * - removed init_success
 * - removed shutdown success
 * - added masterslave type for callback/confirm
 * - added SYSCON TraceLvl
 *
 *****************************************************************************/

//
// H.245 return codes
//
#if defined(OIL)

#include "common.x"
#define HRESULT RESULT
#define ERROR_BASE_ID             0x8000
#define MAKE_H245_ERROR(error)          (error)
#define H245_ERROR_OK                   0
#define H245_ERROR_INVALID_DATA_FORMAT  MAKE_H245_ERROR(ERROR_BASE_ID+0x01) /* Data Structure passed down is somehow invalid    */
#define H245_ERROR_NOMEM                MAKE_H245_ERROR(ERROR_BASE_ID+0x02) /* memory allocation failure                        */
#define H245_ERROR_NOSUP                MAKE_H245_ERROR(ERROR_BASE_ID+0x03) /* H245 feature not valid, or not in this H245 spec */
#define H245_ERROR_PARAM                MAKE_H245_ERROR(ERROR_BASE_ID+0x04) /* invalid parameter or data structure passed to API*/
#define H245_ERROR_ALREADY_INIT         MAKE_H245_ERROR(ERROR_BASE_ID+0x05) /* system has already been initialized              */
#define H245_ERROR_NOT_CONNECTED        MAKE_H245_ERROR(ERROR_BASE_ID+0x06) /* system is not in the connected state             */

#else

#pragma warning( disable : 4115 4201 4214 4514 )
#include "apierror.h"
#define H245_ERROR_OK                   NOERROR
#define H245_ERROR_INVALID_DATA_FORMAT  MAKE_H245_ERROR(ERROR_INVALID_DATA)       /* Data Structure passed down is somehow invalid    */
#define H245_ERROR_NOMEM                MAKE_H245_ERROR(ERROR_OUTOFMEMORY)        /* memory allocation failure                        */
#define H245_ERROR_NOSUP                MAKE_H245_ERROR(ERROR_NOT_SUPPORTED)      /* H245 feature not valid, or not in this H245 spec */
#define H245_ERROR_PARAM                MAKE_H245_ERROR(ERROR_INVALID_PARAMETER)  /* invalid parameter or data structure passed to API*/
#define H245_ERROR_ALREADY_INIT         MAKE_H245_ERROR(ERROR_ALREADY_INITIALIZED)/* system has already been initialized              */
#define H245_ERROR_NOT_CONNECTED        MAKE_H245_ERROR(ERROR_NOT_CONNECTED)      /* system is not in the connected state             */

#endif

#define H245_ERROR_NORESOURCE           MAKE_H245_ERROR(ERROR_BASE_ID+0x10) /* No resources left for this call                  */
#define H245_ERROR_NOTIMP               MAKE_H245_ERROR(ERROR_BASE_ID+0x11) /* H245 feature should be implemented.. but is not  */
#define H245_ERROR_SUBSYS               MAKE_H245_ERROR(ERROR_BASE_ID+0x12) /* subsystem failure.. error unknown                */
#define H245_ERROR_FATAL                MAKE_H245_ERROR(ERROR_BASE_ID+0x13) /* fatal error.. system will be coming down..       */
#define H245_ERROR_MAXTBL               MAKE_H245_ERROR(ERROR_BASE_ID+0x14) /* you have reached the maxium number of tbl entries*/
#define H245_ERROR_CHANNEL_INUSE        MAKE_H245_ERROR(ERROR_BASE_ID+0x15) /* channel is currently in use                      */
#define H245_ERROR_INVALID_CAPID        MAKE_H245_ERROR(ERROR_BASE_ID+0x16) /* Invalid Cap ID.. can not be found                */
#define H245_ERROR_INVALID_OP           MAKE_H245_ERROR(ERROR_BASE_ID+0x17) /* Invalid operation at this time..                 */
#define H245_ERROR_UNKNOWN              MAKE_H245_ERROR(ERROR_BASE_ID+0x18) /* unknown error                                    */
#define H245_ERROR_NOBANDWIDTH          MAKE_H245_ERROR(ERROR_BASE_ID+0x19) /* Bandwidth will not allow this                    */
#define H245_ERROR_LOSTCON              MAKE_H245_ERROR(ERROR_BASE_ID+0x1A) /* System connection .. channel 0 was lost          */
#define H245_ERROR_INVALID_MUXTBLENTRY  MAKE_H245_ERROR(ERROR_BASE_ID+0x1B) /* Invalid Multiplex Table Entry                    */
#define H245_ERROR_INVALID_INST         MAKE_H245_ERROR(ERROR_BASE_ID+0x1C) /* instance is either no longer valid or is invalid */
#define H245_ERROR_INPROCESS            MAKE_H245_ERROR(ERROR_BASE_ID+0x1D) /* request is denied.. action already in process    */
#define H245_ERROR_INVALID_STATE        MAKE_H245_ERROR(ERROR_BASE_ID+0x1E) /* Not proper state to process request              */
#define H245_ERROR_TIMEOUT              MAKE_H245_ERROR(ERROR_BASE_ID+0x1F) /* Timeout occured                                  */
#define H245_ERROR_INVALID_CHANNEL      MAKE_H245_ERROR(ERROR_BASE_ID+0x20) /* Invalid channel                                  */
#define H245_ERROR_INVALID_CAPDESCID    MAKE_H245_ERROR(ERROR_BASE_ID+0x21) /* Invalid Capbility Descriptor ID                  */
#define H245_ERROR_CANCELED             MAKE_H245_ERROR(ERROR_BASE_ID+0x22) /* operation you are responding to has been canceled*/
#define H245_ERROR_MUXELEMENT_DEPTH     MAKE_H245_ERROR(ERROR_BASE_ID+0x23) /* Mux Table Entry is too complex.. MAX recursion   */
#define H245_ERROR_MUXELEMENT_WIDTH     MAKE_H245_ERROR(ERROR_BASE_ID+0x24) /* Mux Table Entry has reached max subelement width */
#define H245_ERROR_ASN1                 MAKE_H245_ERROR(ERROR_BASE_ID+0x25) /* ASN1 PDU compiler error - see PDU log            */
#define H245_ERROR_NO_MUX_CAPS          MAKE_H245_ERROR(ERROR_BASE_ID+0x26) /* Mux Capabilities have not been loaded            */
#define H245_ERROR_NO_CAPDESC           MAKE_H245_ERROR(ERROR_BASE_ID+0x27) /* No Capability Descriptors set                    */


#if(0)  // it's all in one DLL, no need for export
// declare exported functions
#if defined(H245DLL_EXPORT)
#define H245DLL __declspec (dllexport)
#else   // (H245DLL_EXPORT)
#define H245DLL __declspec (dllimport)
#endif  // (H245DLL_EXPORT)
#else
#define H245DLL
#endif


/************************************/
/* ASN.1 DATASTRUCTURES ABSTRACTION */
/************************************/

#include "h245asn1.h"

typedef struct NonStandardIdentifier    H245_NONSTANDID_T;

typedef struct NonStandardParameter     H245_NONSTANDARD_PARAMETER_T;

typedef H245_NONSTANDARD_PARAMETER_T    H245_CAP_NONSTANDARD_T;

typedef struct H261VideoCapability      H245_CAP_H261_T;

typedef struct H262VideoCapability      H245_CAP_H262_T;

typedef struct H263VideoCapability      H245_CAP_H263_T;

typedef struct IS11172VideoCapability   H245_CAP_VIS11172_T;

typedef struct IS11172AudioCapability   H245_CAP_AIS11172_T;

typedef struct IS13818AudioCapability   H245_CAP_IS13818_T;

typedef struct DataApplicationCapability H245_CAP_DATAAPPLICATION_T;

typedef struct H222Capability           H245_CAP_H222_T;

typedef struct H223Capability           H245_CAP_H223_T;

typedef struct V76Capability            H245_CAP_VGMUX_T;

typedef struct H2250Capability          H245_CAP_H2250_T;

typedef struct ConferenceCapability     H245_CAP_CONFERENCE_T;

typedef struct TerminalLabel            H245_TERMINAL_LABEL_T;

#define PDU_T           MltmdSystmCntrlMssg
#define H245_ACCESS_T   NetworkAccessParameters
typedef DWORD_PTR  H245_INST_T;
typedef unsigned short H245_CHANNEL_T;
typedef unsigned long  H245_PORT_T;
#define H245_INVALID_ID          ((H245_INST_T)0)
#define H245_INVALID_CHANNEL     ((H245_CHANNEL_T)0)
#define H245_INVALID_PORT_NUMBER ((H245_PORT_T)-1)

typedef struct
{
  unsigned int    length;
  unsigned char  *value;
} H245_OCTET_STRING_T;



/************************/
/* H245 ABSTRACTION     */
/************************/

/* H245_CAPDIR_T */
typedef enum
{
  H245_CAPDIR_DONTCARE = 0,
  H245_CAPDIR_RMTRX,
  H245_CAPDIR_RMTTX,
  H245_CAPDIR_RMTRXTX,
  H245_CAPDIR_LCLRX,
  H245_CAPDIR_LCLTX,
  H245_CAPDIR_LCLRXTX
} H245_CAPDIR_T;

/* H245_DATA_T */
typedef enum
{
  H245_DATA_DONTCARE = 0,
  H245_DATA_NONSTD,
  H245_DATA_NULL,
  H245_DATA_VIDEO,
  H245_DATA_AUDIO,
  H245_DATA_DATA,
  H245_DATA_ENCRYPT_D,
  H245_DATA_CONFERENCE,
  H245_DATA_MUX         /* mux parameters */
} H245_DATA_T;

/* H245_CLIENT_T */
typedef enum
{
  H245_CLIENT_DONTCARE = 0,     // For H245EnumCap/H245GetCap
  H245_CLIENT_NONSTD,

  H245_CLIENT_VID_NONSTD,
  H245_CLIENT_VID_H261,
  H245_CLIENT_VID_H262,
  H245_CLIENT_VID_H263,
  H245_CLIENT_VID_IS11172,

  H245_CLIENT_AUD_NONSTD,
  H245_CLIENT_AUD_G711_ALAW64,
  H245_CLIENT_AUD_G711_ALAW56,
  H245_CLIENT_AUD_G711_ULAW64,
  H245_CLIENT_AUD_G711_ULAW56,
  H245_CLIENT_AUD_G722_64,
  H245_CLIENT_AUD_G722_56,
  H245_CLIENT_AUD_G722_48,
  H245_CLIENT_AUD_G723,
  H245_CLIENT_AUD_G728,
  H245_CLIENT_AUD_G729,
  H245_CLIENT_AUD_GDSVD,
  H245_CLIENT_AUD_IS11172,
  H245_CLIENT_AUD_IS13818,

  H245_CLIENT_DAT_NONSTD,
  H245_CLIENT_DAT_T120,
  H245_CLIENT_DAT_DSMCC,
  H245_CLIENT_DAT_USERDATA,
  H245_CLIENT_DAT_T84,
  H245_CLIENT_DAT_T434,
  H245_CLIENT_DAT_H224,
  H245_CLIENT_DAT_NLPID,
  H245_CLIENT_DAT_DSVD,
  H245_CLIENT_DAT_H222,

  H245_CLIENT_ENCRYPTION_TX,
  H245_CLIENT_ENCRYPTION_RX,
  H245_CLIENT_CONFERENCE,

  // Multiplex capabilities
  H245_CLIENT_MUX_NONSTD,
  H245_CLIENT_MUX_H222,
  H245_CLIENT_MUX_H223,
  H245_CLIENT_MUX_VGMUX,
  H245_CLIENT_MUX_H2250,
  H245_CLIENT_MUX_H223_ANNEX_A

} H245_CLIENT_T;


/* H245_CAP_T */
typedef union
{
  H245_CAP_NONSTANDARD_T        H245_NonStd;            /* not implemented */

  H245_CAP_NONSTANDARD_T        H245Vid_NONSTD;
  H245_CAP_H261_T               H245Vid_H261;
  H245_CAP_H262_T               H245Vid_H262;
  H245_CAP_H263_T               H245Vid_H263;
  H245_CAP_VIS11172_T           H245Vid_IS11172;

  H245_CAP_NONSTANDARD_T        H245Aud_NONSTD;
  unsigned short                H245Aud_G711_ALAW64;
  unsigned short                H245Aud_G711_ALAW56;
  unsigned short                H245Aud_G711_ULAW64;
  unsigned short                H245Aud_G711_ULAW56;
  unsigned short                H245Aud_G722_64;
  unsigned short                H245Aud_G722_56;
  unsigned short                H245Aud_G722_48;
  H245_CAP_G723_T               H245Aud_G723;
  unsigned short                H245Aud_G728;
  unsigned short                H245Aud_G729;
  unsigned short                H245Aud_GDSVD;
  H245_CAP_AIS11172_T           H245Aud_IS11172;
  H245_CAP_IS13818_T            H245Aud_IS13818;

  H245_CAP_DATAAPPLICATION_T    H245Dat_NONSTD;
  H245_CAP_DATAAPPLICATION_T    H245Dat_T120;
  H245_CAP_DATAAPPLICATION_T    H245Dat_DSMCC;
  H245_CAP_DATAAPPLICATION_T    H245Dat_USERDATA;
  H245_CAP_DATAAPPLICATION_T    H245Dat_T84;
  H245_CAP_DATAAPPLICATION_T    H245Dat_T434;
  H245_CAP_DATAAPPLICATION_T    H245Dat_H224;
  H245_CAP_DATAAPPLICATION_T    H245Dat_NLPID;
  H245_CAP_DATAAPPLICATION_T    H245Dat_DSVD;
  H245_CAP_DATAAPPLICATION_T    H245Dat_H222;

  ASN1_BOOL                     H245Encryption_TX;
  unsigned char                 H245Encryption_RX;
  H245_CAP_CONFERENCE_T         H245Conference;

  // Multiplex capabilities
  H245_CAP_NONSTANDARD_T        H245Mux_NONSTD;
  H245_CAP_H222_T               H245Mux_H222;
  H245_CAP_H223_T               H245Mux_H223;
  H245_CAP_VGMUX_T              H245Mux_VGMUX;
  H245_CAP_H2250_T              H245Mux_H2250;

} H245_CAP_T;

/* H245_CAPID_T */
typedef unsigned short H245_CAPID_T;
#define H245_INVALID_CAPID      ((H245_CAPID_T)-1)
#define H245_MAX_CAPID			(((H245_CAPID_T)-1) / 2)

/* H245_CAPDESCID_T */
typedef unsigned short H245_CAPDESCID_T;
#define H245_INVALID_CAPDESCID  ((H245_CAPDESCID_T)-1)

/* H245_SIMCAP_T */
#define H245_MAX_ALTCAPS        16
typedef struct
{
  unsigned short Length;                     /* number of CapId's in Array   */
  H245_CAPID_T AltCaps[H245_MAX_ALTCAPS];   /* list of alternatives CapId's */

} H245_SIMCAP_T;

#define H245_MAX_SIMCAPS        16
/* H245_CAPDESC_T */
typedef struct
{
  unsigned short Length;
  H245_SIMCAP_T SimCapArray[H245_MAX_SIMCAPS];

} H245_CAPDESC_T;

/* H245_TOTCAPDESC_T */
typedef struct
{
  H245_CAPDESCID_T      CapDescId;
  H245_CAPDESC_T        CapDesc;

} H245_TOTCAPDESC_T;

/* H245_TOTCAP_T */
typedef struct
{
  H245_CAPDIR_T   Dir;
  H245_DATA_T     DataType;
  H245_CLIENT_T   ClientType;
  H245_CAPID_T    CapId;
  H245_CAP_T      Cap;

} H245_TOTCAP_T;



/* H245_CONFIG_T */
typedef enum
{
  H245_CONF_H324 = 1,
  H245_CONF_H323,
  H245_CONF_H310,
  H245_CONF_GVD

} H245_CONFIG_T;




/* H245_ACC_REJ_T */

typedef unsigned long H245_ACC_REJ_T;

#define H245_ACC                        0
#define H245_REJ                        1 // unspecified

// Master Slave Determination reject causes
#define H245_REJ_MSD_IDENTICAL          identicalNumbers_chosen

// Terminal Capability Set reject causes
#define H245_REJ_UNDEF_TBL_ENTRY        undefinedTableEntryUsed_chosen
#define H245_REJ_DIS_CAP_EXCEED         dscrptrCpctyExcdd_chosen
#define H245_REJ_TBLENTRY_CAP_EXCEED    tblEntryCpctyExcdd_chosen

// Open Logical Channel reject causes
#define H245_REJ_REV_PARAM              unstblRvrsPrmtrs_chosen
#define H245_REJ_TYPE_NOTSUPPORT        dataTypeNotSupported_chosen
#define H245_REJ_TYPE_NOTAVAIL          dataTypeNotAvailable_chosen
#define H245_REJ_TYPE_UNKNOWN           unknownDataType_chosen
#define H245_REJ_AL_COMB                dtTypALCmbntnNtSpprtd_chosen
#define H245_REJ_MULTICAST              mltcstChnnlNtAllwd_chosen
#define H245_REJ_BANDWIDTH              insufficientBandwidth_chosen
#define H245_REJ_STACK                  sprtStckEstblshmntFld_chosen
#define H245_REJ_SESSION_ID             invalidSessionID_chosen
#define H245_REJ_MASTER_SLAVE_CONFLICT  masterSlaveConflict_chosen

// Request Channel Close reject causes - use H245_REJ

// Multiplex Table Entry Send reject causes
#define H245_REJ_MUX_COMPLICATED        descriptorTooComplex_chosen

// Request Mode reject causes
#define H245_REJ_UNAVAILABLE            modeUnavailable_chosen
#define H245_REJ_MULTIPOINT             multipointConstraint_chosen
#define H245_REJ_DENIED                 requestDenied_chosen




/* H245_ACC_REJ_MUX_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;
  unsigned long         MuxEntryId;

} H245_ACC_REJ_MUX_T[15];

/* H245_H222_LOGICAL_PARAM_T */
typedef struct
{
  unsigned short        resourceID;
  unsigned short        subChannelID;
  ASN1_BOOL             pcr_pidPresent;
  unsigned short        pcr_pid;                // optional
  H245_OCTET_STRING_T   programDescriptors;     // optional
  H245_OCTET_STRING_T   streamDescriptors;      // optional
} H245_H222_LOGICAL_PARAM_T;

/* H245_H223_LOGICAL_PARAM_T */
typedef enum
{
  H245_H223_AL_NONSTD        = H223LCPs_aLTp_nnStndrd_chosen,
  H245_H223_AL_AL1FRAMED     = H223LCPs_aLTp_al1Frmd_chosen,
  H245_H223_AL_AL1NOTFRAMED  = H223LCPs_aLTp_al1NtFrmd_chosen,
  H245_H223_AL_AL2NOSEQ      = H223LCPs_aLTp_a2WSNs_1_chosen,
  H245_H223_AL_AL2SEQ        = H223LCPs_aLTp_a2WSNs_2_chosen,
  H245_H223_AL_AL3           = H223LCPs_aLTp_al3_chosen

} H245_H223_AL_T;

typedef struct
{
  H245_H223_AL_T                AlType;
  unsigned int                  SndBufSize;   // 0..16777215
  unsigned char                 CtlFldOctet;  // 0..2
  ASN1_BOOL                     SegmentFlag;
  H245_NONSTANDARD_PARAMETER_T  H223_NONSTD;

} H245_H223_LOGICAL_PARAM_T;

/* H245_VGMUX_LOGICAL_PARAM_T */
typedef enum
{
  H245_V76_CRC8BIT  = crc8bit_chosen,
  H245_V76_CRC16BIT = crc16bit_chosen,
  H245_V76_CRC32BIT = crc32bit_chosen
} H245_V76_CRC_LENGTH_T;


typedef enum
{
  H245_V76_NONE = noSuspendResume_chosen,
  H245_V76_WITH_ADDRESS    = V76LogicalChannelParameters_suspendResume_suspendResumewAddress_chosen,
  H245_V76_WITHOUT_ADDRESS = V76LogicalChannelParameters_suspendResume_suspendResumewoAddress_chosen
// the older (Version 2?) ASN had these spellings
//  H245_V76_WITH_ADDRESS    = wAddress_chosen,
//  H245_V76_WITHOUT_ADDRESS = woAddress_chosen
} H245_V76_SUSPEND_RESUME_T;

typedef enum
{
  H245_V76_ERM   = eRM_chosen,
  H245_V76_UNERM = uNERM_chosen
} H245_V76_MODE_T;

typedef enum
{
  H245_V76_REJ   = rej_chosen,
  H245_V76_SREJ  = sREJ_chosen,
  H245_V76_MSREJ = mSREJ_chosen
} H245_V76_RECOVERY_T;

typedef struct
{
  H245_V76_CRC_LENGTH_T       crcLength;
  unsigned short              n401;
  ASN1_BOOL                   loopbackTestProcedure;
  H245_V76_SUSPEND_RESUME_T   suspendResume;
  ASN1_BOOL                   uIH;
  H245_V76_MODE_T             mode;
  unsigned short              windowSize;       // Only valid if mode = ERM
  H245_V76_RECOVERY_T         recovery;         // Only valid if mode = ERM
  ASN1_BOOL                   audioHeaderPresent;
} H245_VGMUX_LOGICAL_PARAM_T;


typedef struct
{
  unsigned char               type;
  /* Note: All unicast types should be odd */
#define H245_IP_UNICAST       1
#define H245_IP_MULTICAST     2
#define H245_IP6_UNICAST      3
#define H245_IP6_MULTICAST    4
#define H245_IPSSR_UNICAST    5  // IP Strict Source Route
#define H245_IPLSR_UNICAST    6  // IP Loose  Source Route
#define H245_IPX_UNICAST      9
#define H245_NETBIOS_UNICAST 11
  union
  {
    // type == H245_IP_UNICAST or H245_IP_MULTICAST
    struct
    {
       unsigned short         tsapIdentifier;
       unsigned char          network[4];
    } ip;

    // type == H245_IP6_UNICAST or H245_IP6_MULTICAST
    struct
    {
       unsigned short         tsapIdentifier;
       unsigned char          network[16];
    } ip6;

    // type == H245_IPSSR_UNICAST or H245_IPLSR_UNICAST
    struct
    {
       unsigned short         tsapIdentifier;
       unsigned char          network[4];
       unsigned char *        route;            // Routing info
       unsigned long          dwCount;          // Number of addresses in above
    } ipSourceRoute;

    // type == H245_IPX_UNICAST
    struct
    {
       unsigned char          node[6];
       unsigned char          netnum[4];
       unsigned char          tsapIdentifier[2];
    } ipx;

    // type == H245_NETBIOS_UNICAST
    unsigned char             netBios[16];
  } u;
} H245_TRANSPORT_ADDRESS_T;

/* H245_H2250_LOGICAL_PARAM_T */
typedef struct
{
  // Note: first 8 fields MUST be same as H245_H2250ACK_LOGICAL_PARAM_T
  H2250LCPs_nnStndrdLink      nonStandardList;              // Optional
  H245_TRANSPORT_ADDRESS_T    mediaChannel;                 // Media Channel Address
  ASN1_BOOL                   mediaChannelPresent;          // TRUE if previous field used
  H245_TRANSPORT_ADDRESS_T    mediaControlChannel;          // Reverse RTCP channel
  ASN1_BOOL                   mediaControlChannelPresent;   // TRUE if previous field used
  unsigned char               dynamicRTPPayloadType;        // 96..127
  ASN1_BOOL                   dynamicRTPPayloadTypePresent; // TRUE if previous field used
  unsigned char               sessionID;                    // 0..255
  unsigned char               associatedSessionID;          // 1..255
  ASN1_BOOL                   associatedSessionIDPresent;   // TRUE if previous field used
  ASN1_BOOL                   mediaGuaranteed;              // TRUE if guaranteed delivery
  ASN1_BOOL                   mediaGuaranteedPresent;       // TRUE if previous field used
  ASN1_BOOL                   mediaControlGuaranteed;       // TRUE if previous field used
  ASN1_BOOL                   mediaControlGuaranteedPresent;// TRUE if previous field used
  ASN1_BOOL                   silenceSuppression;           // TRUE if using silence suppression
  ASN1_BOOL                   silenceSuppressionPresent;    // TRUE if previous field used
  H245_TERMINAL_LABEL_T       destination;                  // Terminal label for destination
  ASN1_BOOL                   destinationPresent;           // TRUE if previous field used
  ASN1_BOOL                   h261aVideoPacketization;
} H245_H2250_LOGICAL_PARAM_T;

/* H245_H2250ACK_LOGICAL_PARAM_T */
typedef struct
{
  H2250LCAPs_nnStndrdLink     nonStandardList;             // Optional
  H245_TRANSPORT_ADDRESS_T    mediaChannel;                // Transport address
  ASN1_BOOL                   mediaChannelPresent;         // TRUE if previous field used
  H245_TRANSPORT_ADDRESS_T    mediaControlChannel;         // Forward RTCP channel
  ASN1_BOOL                   mediaControlChannelPresent;  // TRUE if previous field used
  unsigned char               dynamicRTPPayloadType;       // 96..127
  ASN1_BOOL                   dynamicRTPPayloadTypePresent;// TRUE if previous field used
  unsigned char               sessionID;                   // 1..255
  ASN1_BOOL                   sessionIDPresent;            // TRUE if previous field used
} H245_H2250ACK_LOGICAL_PARAM_T;


// 07/17/98, mikev comments: this enum is hacky - it's using the ASN.1 choice
// integers to tag internal structures.   The internal structures don't always
// have a 1:1 relationship with the ASN.1. For example, H245_H2250ACK_LOGICAL_PARAM_T
// is tagged H245_H2250ACK, and there is no real "choice" for that

/* H245_MUX_T */
typedef enum
{
  H245_H222     = fLCPs_mPs_h222LCPs_chosen,
  H245_H223     = fLCPs_mPs_h223LCPs_chosen,
  H245_VGMUX    = fLCPs_mPs_v76LCPs_chosen,
  H245_H2250    = fLCPs_mPs_h2250LCPs_chosen,
  H245_H2250ACK = H245_H2250 + 1        //
} H245_MUX_KIND_T;

typedef struct
{
  H245_MUX_KIND_T Kind;
  union
  {
    H245_H222_LOGICAL_PARAM_T     H222;
    H245_H223_LOGICAL_PARAM_T     H223;
    H245_VGMUX_LOGICAL_PARAM_T    VGMUX;
    H245_H2250_LOGICAL_PARAM_T    H2250;
    H245_H2250ACK_LOGICAL_PARAM_T H2250ACK;
  } u;
} H245_MUX_T;


/*
   H245_MUX_ENTRY_ELEMENT_T

   This structure defines the multiplex pattern
   which will be used to decode bit patterns in
   a given mux table entry.  the Kind defines
   whether this is a recursive structure (i.e.
   pointing to yet another Mux Entry Element) or
   whether it is a terminating leaf in the recursive
   mux tree.

   RepeatCount indicates how many bits should be
   used for this channel.  If bit count == 0 this
   indicates repeat sequence until close flag
*/

typedef enum
{
  H245_MUX_LOGICAL_CHANNEL = 1,     /* logical channel number (Terminate list) */
  H245_MUX_ENTRY_ELEMENT            /* recursive.. yet another one             */
} H245_MUX_ENTRY_KIND_T;

typedef struct H245_MUX_ENTRY_ELEMENT_T
{
  struct H245_MUX_ENTRY_ELEMENT_T      *pNext;
  H245_MUX_ENTRY_KIND_T                 Kind;
  union
  {
      H245_CHANNEL_T                    Channel;
      struct H245_MUX_ENTRY_ELEMENT_T  *pMuxTblEntryElem;
  } u;

  /* RepeatCount                                */
  /* RepeatCount == 0 -> repeat until close     */
  /* RepeatCount != 0 -> repeate count          */
  unsigned long                         RepeatCount;

} H245_MUX_ENTRY_ELEMENT_T;


/*
   H245_MUX_TABLE_T

   an H245 Mux Table is defined as a linked list of
   Mux Entry Descriptors.  Each descriptor has an
   associated entry number.  These entry numbers
   range from 1-15 and must be unique within the table.
   The end of the list is designated by a pNext == NULL
*/

typedef  struct H245_MUX_TABLE_T
{
  struct H245_MUX_TABLE_T       *pNext;
  unsigned long                  MuxEntryId;
  H245_MUX_ENTRY_ELEMENT_T      *pMuxTblEntryElem;      /* NULL indicates delete entry */

} H245_MUX_TABLE_T;

/********************/
/********************/
/*  Indicator Code  */
/********************/
/********************/

#define H245_IND_MSTSLV                 0x01
#define H245_IND_CAP                    0x02
#define H245_IND_CESE_RELEASE           0x30
#define H245_IND_OPEN                   0x03
#define H245_IND_OPEN_CONF              0x04
#define H245_IND_CLOSE                  0x05
#define H245_IND_REQ_CLOSE              0x06
#define H245_IND_CLCSE_RELEASE          0x31
#define H245_IND_MUX_TBL                0x07
#define H245_IND_MTSE_RELEASE           0x08
#define H245_IND_RMESE                  0x09
#define H245_IND_RMESE_RELEASE          0x0A
#define H245_IND_MRSE                   0x0B
#define H245_IND_MRSE_RELEASE           0x0C
#define H245_IND_MLSE                   0x0D
#define H245_IND_MLSE_RELEASE           0x0E
#define H245_IND_NONSTANDARD_REQUEST    0x0F
#define H245_IND_NONSTANDARD_RESPONSE   0x10
#define H245_IND_NONSTANDARD_COMMAND    0x11
#define H245_IND_NONSTANDARD            0x12
#define H245_IND_MISC_COMMAND           0x13
#define H245_IND_MISC                   0x14
#define H245_IND_COMM_MODE_REQUEST      0x15
#define H245_IND_COMM_MODE_RESPONSE     0x16
#define H245_IND_COMM_MODE_COMMAND      0x17
#define H245_IND_CONFERENCE_REQUEST     0x18
#define H245_IND_CONFERENCE_RESPONSE    0x19
#define H245_IND_CONFERENCE_COMMAND     0x1A
#define H245_IND_CONFERENCE             0x1B
#define H245_IND_SEND_TERMCAP           0x1C
#define H245_IND_ENCRYPTION             0x1D
#define H245_IND_FLOW_CONTROL           0x1E
#define H245_IND_ENDSESSION             0x1F
#define H245_IND_FUNCTION_NOT_UNDERSTOOD 0x20
#define H245_IND_JITTER                 0x21
#define H245_IND_H223_SKEW              0x22
#define H245_IND_NEW_ATM_VC             0x23
#define H245_IND_USERINPUT              0x24
#define H245_IND_H2250_MAX_SKEW         0x25
#define H245_IND_MC_LOCATION            0x26
#define H245_IND_VENDOR_ID              0x27
#define H245_IND_FUNCTION_NOT_SUPPORTED 0x28
#define H245_IND_H223_RECONFIG          0x29
#define H245_IND_H223_RECONFIG_ACK      0x2A
#define H245_IND_H223_RECONFIG_REJECT   0x2B

/* H245_MSTSLV_T */
typedef enum
{
  H245_INDETERMINATE = 0,       // Master/Slave Determination failed
  H245_MASTER = master_chosen,  // Local terminal is Master
  H245_SLAVE  = slave_chosen    // Local terminal is Slave

} H245_MSTSLV_T;

/* H245_IND_OPEN_T */
typedef struct
{
  /* for receive */
  H245_CHANNEL_T RxChannel;
  H245_PORT_T    RxPort;        // optional
  H245_DATA_T    RxDataType;
  H245_CLIENT_T  RxClientType;
  H245_CAP_T    *pRxCap;
  H245_MUX_T    *pRxMux;

  /* for bi-directional channel */
  /* requested transmit stuff   */

  H245_DATA_T    TxDataType;
  H245_CLIENT_T  TxClientType;
  H245_CAP_T    *pTxCap;
  H245_MUX_T    *pTxMux;

  H245_ACCESS_T *pSeparateStack; // optional

} H245_IND_OPEN_T;

/* H245_IND_OPEN_CONF_T */
typedef struct
{
  /* receive channel              */
  /* remote requested channel #   */
  H245_CHANNEL_T          RxChannel;

  /* transmit channel                     */
  /* locally opened transmit channel #    */
  H245_CHANNEL_T          TxChannel;

} H245_IND_OPEN_CONF_T;

/* H245_IND_CLOSE_T */
typedef enum
{
  H245_USER = user_chosen,
  H245_LCSE = lcse_chosen

} H245_IND_CLOSE_REASON_T;

typedef struct
{
  H245_CHANNEL_T          Channel;
  H245_IND_CLOSE_REASON_T Reason;

} H245_IND_CLOSE_T;

/* H245_IND_MUX_TBL */
typedef struct
{
  H245_MUX_TABLE_T      *pMuxTbl;
  unsigned long          Count;

} H245_IND_MUXTBL_T;

/* H245_RMESE_T */
typedef struct
{
  unsigned short        awMultiplexTableEntryNumbers[15];
  unsigned long         dwCount;

} H245_RMESE_T;

/* H245_IND_MRSE_T */
typedef struct
{
  RequestedModesLink pRequestedModes;

} H245_IND_MRSE_T;

/* H245_MLSE_T */
typedef enum
{
  H245_SYSTEM_LOOP  = systemLoop_chosen,
  H245_MEDIA_LOOP   = mediaLoop_chosen,
  H245_CHANNEL_LOOP = logicalChannelLoop_chosen

} H245_LOOP_TYPE_T;

typedef struct
{
  H245_LOOP_TYPE_T      LoopType;
  H245_CHANNEL_T        Channel;

} H245_MLSE_T;

/* H245_IND_ENDSESSION_T */
typedef enum
{
  H245_ENDSESSION_NONSTD     = EndSssnCmmnd_nonStandard_chosen,
  H245_ENDSESSION_DISCONNECT = disconnect_chosen,
  H245_ENDSESSION_TELEPHONY,
  H245_ENDSESSION_V8BIS,
  H245_ENDSESSION_V34DSVD,
  H245_ENDSESSION_V34DUPFAX,
  H245_ENDSESSION_V34H324

} H245_ENDSESSION_T;

typedef struct
{
  H245_ENDSESSION_T             SessionMode;
  /* if non standard chosen */
  H245_NONSTANDARD_PARAMETER_T  SessionNonStd;

} H245_IND_ENDSESSION_T;

/* H245_IND_NONSTANDARD_T */
typedef struct
{
  unsigned char *        pData;
  unsigned long          dwDataLength;
  unsigned short *       pwObjectId;
  unsigned long          dwObjectIdLength;
  unsigned char          byCountryCode;
  unsigned char          byExtension;
  unsigned short         wManufacturerCode;
} H245_IND_NONSTANDARD_T;

typedef struct
{
  CMTEy_nnStndrdLink          pNonStandard;                 // NULL if not present
  unsigned char               sessionID;                    // 0..255
  unsigned char               associatedSessionID;          // 1..255
  ASN1_BOOL                   associatedSessionIDPresent;   // TRUE if previous field used
  H245_TERMINAL_LABEL_T       terminalLabel;
  ASN1_BOOL                   terminalLabelPresent;
  unsigned short *            pSessionDescription;
  unsigned short              wSessionDescriptionLength;
  H245_TOTCAP_T               dataType;
  H245_TRANSPORT_ADDRESS_T    mediaChannel;                 // Media Channel Address
  ASN1_BOOL                   mediaChannelPresent;          // TRUE if previous field used
  H245_TRANSPORT_ADDRESS_T    mediaControlChannel;          // Reverse RTCP channel
  ASN1_BOOL                   mediaControlChannelPresent;   // TRUE if previous field used
  ASN1_BOOL                   mediaGuaranteed;              // TRUE if guaranteed delivery
  ASN1_BOOL                   mediaGuaranteedPresent;       // TRUE if previous field used
  ASN1_BOOL                   mediaControlGuaranteed;       // TRUE if previous field used
  ASN1_BOOL                   mediaControlGuaranteedPresent;// TRUE if previous field used
} H245_COMM_MODE_ENTRY_T;

typedef struct
{
  H245_COMM_MODE_ENTRY_T *pTable;
  unsigned char          byTableCount;
} H245_IND_COMM_MODE_T;

typedef enum
{
  H245_REQ_TERMINAL_LIST            = terminalListRequest_chosen,
  H245_REQ_MAKE_ME_CHAIR            = makeMeChair_chosen,
  H245_REQ_CANCEL_MAKE_ME_CHAIR     = cancelMakeMeChair_chosen,
  H245_REQ_DROP_TERMINAL            = dropTerminal_chosen,
  H245_REQ_TERMINAL_ID              = requestTerminalID_chosen,
  H245_REQ_ENTER_H243_PASSWORD      = enterH243Password_chosen,
  H245_REQ_ENTER_H243_TERMINAL_ID   = enterH243TerminalID_chosen,
  H245_REQ_ENTER_H243_CONFERENCE_ID = enterH243ConferenceID_chosen
} H245_CONFER_REQ_ENUM_T;

typedef struct
{
  H245_CONFER_REQ_ENUM_T  RequestType;
  unsigned char           byMcuNumber;
  unsigned char           byTerminalNumber;
} H245_CONFER_REQ_T;

typedef enum
{
  H245_RSP_MC_TERMINAL_ID           = mCTerminalIDResponse_chosen,
  H245_RSP_TERMINAL_ID              = terminalIDResponse_chosen,
  H245_RSP_CONFERENCE_ID            = conferenceIDResponse_chosen,
  H245_RSP_PASSWORD                 = passwordResponse_chosen,
  H245_RSP_TERMINAL_LIST            = terminalListResponse_chosen,
  H245_RSP_VIDEO_COMMAND_REJECT     = videoCommandReject_chosen,
  H245_RSP_TERMINAL_DROP_REJECT     = terminalDropReject_chosen,
  H245_RSP_DENIED_CHAIR_TOKEN,
  H245_RSP_GRANTED_CHAIR_TOKEN
} H245_CONFER_RSP_ENUM_T;

typedef struct
{
  H245_CONFER_RSP_ENUM_T  ResponseType;
  unsigned char           byMcuNumber;
  unsigned char           byTerminalNumber;
  unsigned char          *pOctetString;
  unsigned char           byOctetStringLength;
  TerminalLabel          *pTerminalList;
  unsigned short          wTerminalListCount;
} H245_CONFER_RSP_T;

typedef enum
{
  H245_CMD_BROADCAST_CHANNEL        = brdcstMyLgclChnnl_chosen,
  H245_CMD_CANCEL_BROADCAST_CHANNEL = cnclBrdcstMyLgclChnnl_chosen,
  H245_CMD_BROADCASTER              = ConferenceCommand_makeTerminalBroadcaster_chosen,
  H245_CMD_CANCEL_BROADCASTER       = cnclMkTrmnlBrdcstr_chosen,
  H245_CMD_SEND_THIS_SOURCE         = ConferenceCommand_sendThisSource_chosen,
  H245_CMD_CANCEL_SEND_THIS_SOURCE  = cancelSendThisSource_chosen,
  H245_CMD_DROP_CONFERENCE          = dropConference_chosen
} H245_CONFER_CMD_ENUM_T;

typedef struct
{
  H245_CONFER_CMD_ENUM_T  CommandType;
  H245_CHANNEL_T          Channel;
  unsigned char           byMcuNumber;
  unsigned char           byTerminalNumber;
} H245_CONFER_CMD_T;

typedef enum
{
  H245_IND_SBE_NUMBER               = sbeNumber_chosen,
  H245_IND_TERMINAL_NUMBER_ASSIGN   = terminalNumberAssign_chosen,
  H245_IND_TERMINAL_JOINED          = terminalJoinedConference_chosen,
  H245_IND_TERMINAL_LEFT            = terminalLeftConference_chosen,
  H245_IND_SEEN_BY_ONE_OTHER        = seenByAtLeastOneOther_chosen,
  H245_IND_CANCEL_SEEN_BY_ONE_OTHER = cnclSnByAtLstOnOthr_chosen,
  H245_IND_SEEN_BY_ALL              = seenByAll_chosen,
  H245_IND_CANCEL_SEEN_BY_ALL       = cancelSeenByAll_chosen,
  H245_IND_TERMINAL_YOU_ARE_SEEING  = terminalYouAreSeeing_chosen,
  H245_IND_REQUEST_FOR_FLOOR        = requestForFloor_chosen
} H245_CONFER_IND_ENUM_T;

typedef struct
{
  H245_CONFER_IND_ENUM_T  IndicationType;
  unsigned char           bySbeNumber;
  unsigned char           byMcuNumber;
  unsigned char           byTerminalNumber;
} H245_CONFER_IND_T;

typedef enum
{
  H245_SCOPE_CHANNEL_NUMBER   = FCCd_scp_lgclChnnlNmbr_chosen,
  H245_SCOPE_RESOURCE_ID      = FlwCntrlCmmnd_scp_rsrcID_chosen,
  H245_SCOPE_WHOLE_MULTIPLEX  = FCCd_scp_whlMltplx_chosen
} H245_SCOPE_T;

#define H245_NO_RESTRICTION 0xFFFFFFFFL

typedef struct
{
  H245_SCOPE_T           Scope;
  H245_CHANNEL_T         Channel;       // only used if Scope is H245_SCOPE_CHANNEL_NUMBER
  unsigned short         wResourceID;   // only used if Scope is H245_SCOPE_RESOURCE_ID
  unsigned long          dwRestriction; // H245_NO_RESTRICTION if no restriction
} H245_IND_FLOW_CONTROL_T;

/* H245_USERINPUT_T */
typedef enum
{
  H245_USERINPUT_NONSTD = UsrInptIndctn_nnStndrd_chosen,
  H245_USERINPUT_STRING = alphanumeric_chosen
} H245_USERINPUT_KIND_T;

typedef struct
{
  H245_USERINPUT_KIND_T     Kind;
  union
  {
    WCHAR *                           pGenString;
    H245_NONSTANDARD_PARAMETER_T      NonStd;
  } u;
} H245_IND_USERINPUT_T;

typedef struct
{
  H245_CHANNEL_T        LogicalChannelNumber1;
  H245_CHANNEL_T        LogicalChannelNumber2;
  unsigned short        wSkew;
} H245_IND_SKEW_T;

typedef struct
{
  H245_NONSTANDID_T      Identifier;
  unsigned char         *pProductNumber;
  unsigned char          byProductNumberLength;
  unsigned char         *pVersionNumber;
  unsigned char          byVersionNumberLength;
} H245_IND_VENDOR_ID_T;

typedef enum
{
  UNKNOWN,
  REQ_NONSTANDARD,
  REQ_MASTER_SLAVE,
  REQ_TERMCAP_SET,
  REQ_OPEN_LOGICAL_CHANNEL,
  REQ_CLOSE_LOGICAL_CHANNEL,
  REQ_REQUEST_CHANNEL_CLOSE,
  REQ_MULTIPLEX_ENTRY_SEND,
  REQ_REQUEST_MULTIPLEX_ENTRY,
  REQ_REQUEST_MODE,
  REQ_ROUND_TRIP_DELAY,
  REQ_MAINTENANCE_LOOP,
  REQ_COMMUNICATION_MODE,
  REQ_CONFERENCE,
  REQ_H223_ANNEX_A_RECONFIG,
  RSP_NONSTANDARD,
  RSP_MASTER_SLAVE_ACK,
  RSP_MASTER_SLAVE_REJECT,
  RSP_TERMCAP_SET_ACK,
  RSP_TERMCAP_SET_REJECT,
  RSP_OPEN_LOGICAL_CHANNEL_ACK,
  RSP_OPEN_LOGICAL_CHANNEL_REJECT,
  RSP_CLOSE_LOGICAL_CHANNEL_ACK,
  RSP_REQUEST_CHANNEL_CLOSE_ACK,
  RSP_REQUEST_CHANNEL_CLOSE_REJECT,
  RSP_MULTIPLEX_ENTRY_SEND_ACK,
  RSP_MULTIPLEX_ENTRY_SEND_REJECT,
  RSP_REQUEST_MULTIPLEX_ENTRY_ACK,
  RSP_REQUEST_MULTIPLEX_ENTRY_REJECT,
  RSP_REQUEST_MODE_ACK,
  RSP_REQUEST_MODE_REJECT,
  RSP_ROUND_TRIP_DELAY,
  RSP_MAINTENANCE_LOOP_ACK,
  RSP_MAINTENANCE_LOOP_REJECT,
  RSP_COMMUNICATION_MODE,
  RSP_CONFERENCE,
  RSP_H223_ANNEX_A_RECONFIG_ACK,
  RSP_H223_ANNEX_A_RECONFIG_REJECT,
  CMD_NONSTANDARD,
  CMD_MAINTENANCE_LOOP_OFF,
  CMD_SEND_TERMCAP,
  CMD_ENCRYPTION,
  CMD_FLOW_CONTROL,
  CMD_END_SESSION,
  CMD_MISCELLANEOUS,
  CMD_COMMUNICATION_MODE,
  CMD_CONFERENCE,
  IND_NONSTANDARD,
  IND_FUNCTION_NOT_UNDERSTOOD,
  IND_MASTER_SLAVE_RELEASE,
  IND_TERMCAP_SET_RELEASE,
  IND_OPEN_LOGICAL_CHANNEL_CONFIRM,
  IND_REQUEST_CHANNEL_CLOSE_RELEASE,
  IND_MULTIPLEX_ENTRY_SEND_RELEASE,
  IND_REQUEST_MULTIPLEX_ENTRY_RELEASE,
  IND_REQUEST_MODE_RELEASE,
  IND_MISCELLANEOUS,
  IND_JITTER,
  IND_H223_SKEW,
  IND_NEW_ATM_VC,
  IND_USER_INPUT,
  IND_H2250_MAX_SKEW,
  IND_MC_LOCATION,
  IND_CONFERENCE_INDICATION,
  IND_VENDOR_IDENTIFICATION,
  IND_FUNCTION_NOT_SUPPORTED,
} H245_SUBMESSAGE_T;

typedef enum
{
  H245_SYNTAX_ERROR     = syntaxError_chosen,
  H245_SEMANTIC_ERROR   = semanticError_chosen,
  H245_UNKNOWN_FUNCTION = unknownFunction_chosen
} H245_FNS_CAUSE_T;

typedef struct
{
  H245_FNS_CAUSE_T      Cause;
  H245_SUBMESSAGE_T     Type;
} H245_IND_FNS_T;

/**************/
/* H245_IND_T */
/**************/

typedef struct
{
  unsigned long         Indicator;              // Type
  DWORD_PTR             dwPreserved;            // User supplied dwPreserved from H245Init()
  union
  {
    H245_MSTSLV_T            IndMstSlv;         // H245_IND_MSTSLV
                                                // H245_IND_CAP
                                                // H245_IND_CESE_RELEASE
    H245_IND_OPEN_T          IndOpen;           // H245_IND_OPEN
    H245_IND_OPEN_CONF_T     IndOpenConf;       // H245_IND_OPEN_CONF
    H245_IND_CLOSE_T         IndClose;          // H245_IND_CLOSE
    H245_CHANNEL_T           IndReqClose;       // H245_IND_REQ_CLOSE
                                                // H245_IND_CLCSE_RELEASE
    H245_IND_MUXTBL_T        IndMuxTbl;         // H245_IND_MUX_TBL
                                                // H245_IND_MTSE_RELEASE
    H245_RMESE_T             IndRmese;          // H245_IND_RMESE
                                                // H245_IND_RMESE_RELEASE
    H245_IND_MRSE_T          IndMrse;           // H245_IND_MRSE
                                                // H245_IND_MRSE_RELEASE
    H245_MLSE_T              IndMlse;           // H245_IND_MLSE
                                                // H245_IND_MLSE_RELEASE
    H245_IND_NONSTANDARD_T   IndNonstandardRequest; // H245_IND_NONSTANDARD_REQUEST
    H245_IND_NONSTANDARD_T   IndNonstandardResponse; // H245_IND_NONSTANDARD_RESPONSE
    H245_IND_NONSTANDARD_T   IndNonstandardCommand; // H245_IND_NONSTANDARD_COMMAND
    H245_IND_NONSTANDARD_T   IndNonstandard;    // H245_IND_NONSTANDARD
                                                // H245_IND_MISC_COMMAND
                                                // H245_IND_MISC
                                                // H245_IND_COMM_MODE_REQUEST
    H245_IND_COMM_MODE_T     IndCommRsp;        // H245_IND_COMM_MODE_RESPONSE
    H245_IND_COMM_MODE_T     IndCommCmd;        // H245_IND_COMM_MODE_COMMAND
    H245_CONFER_REQ_T        IndConferReq;      // H245_IND_CONFERENCE_REQUEST
    H245_CONFER_RSP_T        IndConferRsp;      // H245_IND_CONFERENCE_RESPONSE
    H245_CONFER_CMD_T        IndConferCmd;      // H245_IND_CONFERENCE_COMMAND
    H245_CONFER_IND_T        IndConfer;         // H245_IND_CONFERENCE
                                                // H245_IND_SEND_TERMCAP
                                                // H245_IND_ENCRYPTION
    H245_IND_FLOW_CONTROL_T  IndFlowControl;    // H245_IND_FLOW_CONTROL
    H245_IND_ENDSESSION_T    IndEndSession;     // H245_IND_ENDSESSION
                                                // H245_IND_FUNCTION_NOT_UNDERSTOOD
                                                // H245_IND_JITTER
    H245_IND_SKEW_T          IndH223Skew;       // H245_IND_H223_SKEW
                                                // H245_IND_NEW_ATM_VC
    H245_IND_USERINPUT_T     IndUserInput;      // H245_IND_USERINPUT
    H245_IND_SKEW_T          IndH2250MaxSkew;   // H245_IND_H2250_MAX_SKEW
    H245_TRANSPORT_ADDRESS_T IndMcLocation;     // H245_IND_MC_LOCATION
    H245_IND_VENDOR_ID_T     IndVendorId;       // H245_IND_VENDOR_ID
    H245_IND_FNS_T           IndFns;            // H245_IND_FUNCTION_NOT_SUPPORTED
                                                // H245_IND_H223_RECONFIG
                                                // H245_IND_H223_RECONFIG_ACK
                                                // H245_IND_H223_RECONFIG_REJECT
  } u;
} H245_IND_T;


/********************/
/********************/
/*  Confirm   Code  */
/********************/
/********************/

#define H245_CONF_INIT_MSTSLV    0x101
#define H245_CONF_SEND_TERMCAP   0x102
#define H245_CONF_OPEN           0x103
#define H245_CONF_NEEDRSP_OPEN   0x104
#define H245_CONF_CLOSE          0x105
#define H245_CONF_REQ_CLOSE      0x106
#define H245_CONF_MUXTBL_SND     0x107

#define H245_CONF_RMESE          0x109
#define H245_CONF_RMESE_REJECT   0x10A
#define H245_CONF_RMESE_EXPIRED  0x10B
#define H245_CONF_MRSE           0x10C
#define H245_CONF_MRSE_REJECT    0x10D
#define H245_CONF_MRSE_EXPIRED   0x10E
#define H245_CONF_MLSE           0x10F
#define H245_CONF_MLSE_REJECT    0x110
#define H245_CONF_MLSE_EXPIRED   0x111
#define H245_CONF_RTDSE          0x112
#define H245_CONF_RTDSE_EXPIRED  0x113

/* H245_CONF_SEND_TERMCAP_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;

} H245_CONF_SEND_TERMCAP_T;

/* H245_CONF_OPEN_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;
  H245_CHANNEL_T        TxChannel;
  H245_MUX_T *          pTxMux;         // optional
  H245_CHANNEL_T        RxChannel;      // bi-dir only
  H245_MUX_T *          pRxMux;         // bi-dir only
  H245_PORT_T           RxPort;         // bi-dir only
  H245_ACCESS_T *       pSeparateStack; // optional

} H245_CONF_OPEN_T;

typedef H245_CONF_OPEN_T H245_CONF_NEEDRSP_OPEN_T;

/* H245_CONF_CLOSE_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;
  H245_CHANNEL_T        Channel;

} H245_CONF_CLOSE_T;

/* H245_CONF_REQ_CLOSE_T */
typedef H245_CONF_CLOSE_T H245_CONF_REQ_CLOSE_T;

/* H245_CONF_MUXTBL_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;
  unsigned long         MuxEntryId;

} H245_CONF_MUXTBL_T;



/***************/
/* H245_CONF_T */
/***************/

typedef struct
{
  unsigned long         Confirm;                // Type
  DWORD_PTR             dwPreserved;            // User supplied dwPreserved from H245Init()
  DWORD_PTR             dwTransId;              // User supplied dwTransId from originating call
  HRESULT               Error;                  // Error code
  union                                         // Data for specific indications:
  {
    H245_MSTSLV_T             ConfMstSlv;       // H245_CONF_INIT_MSTSLV
    H245_CONF_SEND_TERMCAP_T  ConfSndTcap;      // H245_CONF_SEND_TERMCAP
    H245_CONF_OPEN_T          ConfOpen;         // H245_CONF_OPEN
    H245_CONF_NEEDRSP_OPEN_T  ConfOpenNeedRsp;  // H245_CONF_NEEDRSP_OPEN
    H245_CONF_CLOSE_T         ConfClose;        // H245_CONF_CLOSE
    H245_CONF_REQ_CLOSE_T     ConfReqClose;     // H245_CONF_REQ_CLOSE
    H245_CONF_MUXTBL_T        ConfMuxSnd;       // H245_CONF_MUXTBL_SND
    H245_RMESE_T              ConfRmese;        // H245_CONF_RMESE
    H245_RMESE_T              ConfRmeseReject;  // H245_CONF_RMESE_REJECT
                                                // H245_CONF_RMESE_EXPIRED
    unsigned short            ConfMrse;         // H245_CONF_MRSE
    unsigned short            ConfMrseReject;   // H245_CONF_MRSE_REJECT
                                                // H245_CONF_MRSE_EXPIRED
    H245_MLSE_T               ConfMlse;         // H245_CONF_MLSE
    H245_MLSE_T               ConfMlseReject;   // H245_CONF_MLSE_REJECT
                                                // H245_CONF_MLSE_EXPIRED
                                                // H245_CONF_RTDSE
                                                // H245_CONF_RTDSE_EXPIRED
  } u;
} H245_CONF_T;



typedef enum
{
  H245_MESSAGE_REQUEST     = MltmdSystmCntrlMssg_rqst_chosen,
  H245_MESSAGE_RESPONSE    = MSCMg_rspns_chosen,
  H245_MESSAGE_COMMAND     = MSCMg_cmmnd_chosen,
  H245_MESSAGE_INDICATION  = indication_chosen
} H245_MESSAGE_TYPE_T;



/*******************/
/* H245_CONF_IND_T */
/*******************/
typedef enum
{
  H245_CONF = 1,
  H245_IND
} H245_CONF_IND_KIND_T;

typedef struct
{
  H245_CONF_IND_KIND_T  Kind;
  union
  {
    H245_CONF_T         Confirm;
    H245_IND_T          Indication;
  } u;

} H245_CONF_IND_T;



/***************************/
/* SYSTEM CONTROL MESSAGES */
/***************************/

typedef struct
{
  unsigned long NumPduTx;       /* number of tranmitted pdu's    */
  unsigned long NumPduRx;       /* number of received pdu's      */
  unsigned long NumCRCErrors;   /* number of crc errors          */
  unsigned long NumPduReTx;     /* number of pdu's retransmitted */

} H245_SYSCON_STATS_T;

#define H245_SYSCON_TRACE_LVL           0x0100  /* pData = &dwTraceLevel   */
#define H245_SYSCON_DUMP_TRACKER        0x0200  /* pData = NULL (debug)    */
#define H245_SYSCON_GET_STATS           0x0300  /* pData = &H245_SYSCON_STATS_T */
#define H245_SYSCON_RESET_STATS         0x0400  /* pData = NULL            */

#define H245_SYSCON_SET_FSM_N100        0x1000  /* pData = &dwRetryCount   */
#define H245_SYSCON_SET_FSM_T101        0x1100  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T102        0x1200  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T103        0x1300  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T104        0x1400  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T105        0x1500  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T106        0x1600  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T107        0x1700  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T108        0x1800  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T109        0x1900  /* pData = &dwMilliseconds */

#define H245_SYSCON_GET_FSM_N100        0x2000  /* pData = &dwRetryCount   */
#define H245_SYSCON_GET_FSM_T101        0x2100  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T102        0x2200  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T103        0x2300  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T104        0x2400  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T105        0x2500  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T106        0x2600  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T107        0x2700  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T108        0x2800  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T109        0x2900  /* pData = &dwMilliseconds */



/************************/
/* PROTOCOL ID FOR H245 */
/************************/
#define H245_PROTOID                    "0.0.8.245.0.3"



/**************************************************/
/* API Procedure Call Typedefs and API Prototypes */
/**************************************************/

typedef DWORD_PTR H245_INST_T;
typedef HRESULT (*H245_CONF_IND_CALLBACK_T)(H245_CONF_IND_T *, void *);
typedef int (*H245_CAP_CALLBACK_T)(DWORD_PTR, H245_TOTCAP_T *);
typedef int (*H245_CAPDESC_CALLBACK_T)(DWORD_PTR, H245_TOTCAPDESC_T *);

#ifdef __cplusplus
extern "C" {
#endif

H245DLL H245_INST_T
H245Init                (
                         H245_CONFIG_T            Configuration,
                         unsigned long            dwPhysId,
                         unsigned long            *pdwLinkLayerPhysId,
                         DWORD_PTR                dwPreserved,
                         H245_CONF_IND_CALLBACK_T CallBack,
                         unsigned char            byTerminalType
                        );

H245DLL HRESULT
H245EndSession          (
                         H245_INST_T                    dwInst,
                         H245_ENDSESSION_T              Mode,
                         const H245_NONSTANDARD_PARAMETER_T * pNonStd
                        );

H245DLL HRESULT
H245ShutDown            (H245_INST_T            dwInst);

H245DLL HRESULT
H245InitMasterSlave     (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId
                        );

H245DLL HRESULT
H245SetLocalCap         (
                         H245_INST_T            dwInst,
                         H245_TOTCAP_T *        pTotCap,
                         H245_CAPID_T  *        pCapId
                        );

H245DLL HRESULT
H245DelLocalCap         (
                         H245_INST_T            dwInst,
                         H245_CAPID_T           CapId
                        );

H245DLL HRESULT
H245SetCapDescriptor    (
                         H245_INST_T            dwInst,
                         H245_CAPDESC_T        *pCapDesc,
                         H245_CAPDESCID_T      *pCapDescId
                        );

H245DLL HRESULT
H245DelCapDescriptor    (
                         H245_INST_T            dwInst,
                         H245_CAPDESCID_T       CapDescId
                        );

H245DLL HRESULT
H245SendTermCaps        (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId
                        );

H245DLL HRESULT
H245EnumCaps            (
                         H245_INST_T              dwInst,
                         DWORD_PTR                dwTransId,
                         H245_CAPDIR_T            Direction,
                         H245_DATA_T              DataType,
                         H245_CLIENT_T            ClientType,
                         H245_CAP_CALLBACK_T      pfCapCallback,
                         H245_CAPDESC_CALLBACK_T  pfCapDescCallback
                        );

H245DLL HRESULT
H245GetCaps             (
                         H245_INST_T            dwInst,
                         H245_CAPDIR_T          Direction,
                         H245_DATA_T            DataType,
                         H245_CLIENT_T          ClientType,
                         H245_TOTCAP_T      * * ppTotCap,
                         unsigned long *        pdwTotCapLen,
                         H245_TOTCAPDESC_T  * * ppCapDesc,
                         unsigned long *        pdwCapDescLen
                        );

H245DLL HRESULT
H245CopyCap             (H245_TOTCAP_T		   **ppDestTotCap,
						 const H245_TOTCAP_T   *pTotCap);

H245DLL HRESULT
H245FreeCap             (H245_TOTCAP_T          *pTotCap);

H245DLL HRESULT
H245CopyCapDescriptor   (H245_TOTCAPDESC_T		 **ppDestCapDesc,
						 const H245_TOTCAPDESC_T *pCapDesc);

H245DLL HRESULT
H245FreeCapDescriptor   (H245_TOTCAPDESC_T     *pCapDesc);

H245DLL H245_MUX_T *
H245CopyMux             (const H245_MUX_T *     pMux);

H245DLL HRESULT
H245FreeMux             (H245_MUX_T *           pMux);

H245DLL HRESULT
H245OpenChannel         (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
                         H245_CHANNEL_T         wTxChannel,
                         const H245_TOTCAP_T *  pTxMode,
                         const H245_MUX_T    *  pTxMux,
                         H245_PORT_T            dwTxPort,       // optional
                         const H245_TOTCAP_T *  pRxMode,        // bi-dir only
                         const H245_MUX_T    *  pRxMux,         // bi-dir only
                         const H245_ACCESS_T *  pSeparateStack  // optional
                        );

H245DLL HRESULT
H245OpenChannelAccept   (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
                         H245_CHANNEL_T         wRxChannel,     // RxChannel from IND_OPEN
                         const H245_MUX_T *     pRxMux,         // optional H2250LogicalChannelAckParameters
                         H245_CHANNEL_T         wTxChannel,     // bi-dir only
                         const H245_MUX_T *     pTxMux,         // bi-dir only optional H2250LogicalChannelParameters
                         H245_PORT_T            dwTxPort,       // bi-dir only optional
                         const H245_ACCESS_T *  pSeparateStack  // optional
                        );

H245DLL HRESULT
H245OpenChannelReject   (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wRxChannel, // RxChannel from IND_OPEN
                         unsigned short         wCause
                        );

H245DLL HRESULT
H245CloseChannel        (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
                         H245_CHANNEL_T         wTxChannel
                        );

H245DLL HRESULT
H245CloseChannelReq     (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
                         H245_CHANNEL_T         wRxChannel
                        );

H245DLL HRESULT
H245CloseChannelReqResp (
                         H245_INST_T            dwInst,
                         H245_ACC_REJ_T         AccRej,
                         H245_CHANNEL_T         wChannel
                        );

H245DLL HRESULT
H245SendLocalMuxTable   (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
                         H245_MUX_TABLE_T      *pMuxTable
                        );

H245DLL HRESULT
H245MuxTableIndResp     (
                         H245_INST_T            dwInst,
                         H245_ACC_REJ_MUX_T     AccRejMux,
                         unsigned long          dwCount
                        );

H245DLL HRESULT
H245RequestMultiplexEntry (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        );

H245DLL HRESULT
H245RequestMultiplexEntryAck (
                         H245_INST_T            dwInst,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        );

H245DLL HRESULT
H245RequestMultiplexEntryReject (
                         H245_INST_T            dwInst,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        );

/*
H245DLL HRESULT
H245RequestMode         (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
                         const ModeElement *    pModeElements,
                         unsigned long          dwCount
                        );
*/
H245DLL HRESULT
H245RequestMode         (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
//                         const ModeElement *    pModeElements,
//tomitowoju@intel.com
						 ModeDescription 		ModeDescriptions[],
//tomitowoju@intel.com
                         unsigned long          dwCount
                        ) ;



H245DLL HRESULT
H245RequestModeAck      (
                         H245_INST_T            dwInst,
                         unsigned short         wResponse
                        );

H245DLL HRESULT
H245RequestModeReject   (
                         H245_INST_T            dwInst,
                         unsigned short         wCause
                        );

H245DLL HRESULT
H245RoundTripDelayRequest (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId
                        );

H245DLL HRESULT
H245MaintenanceLoop     (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
                         H245_LOOP_TYPE_T       dwLoopType,
                         H245_CHANNEL_T         wChannel
                        );

H245DLL HRESULT
H245MaintenanceLoopRelease (H245_INST_T         dwInst);

H245DLL HRESULT
H245MaintenanceLoopAccept (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wChannel
                        );

H245DLL HRESULT
H245MaintenanceLoopReject (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wChannel,
                         unsigned short         wCause
                        );

H245DLL HRESULT
H245NonStandardObject   (
                         H245_INST_T            dwInst,
                         H245_MESSAGE_TYPE_T    MessageType,
                         const unsigned char *  pData,
                         unsigned long          dwDataLength,
                         const unsigned short * pwObjectId,
                         unsigned long          dwObjectIdLength
                        );

H245DLL HRESULT
H245NonStandardH221     (
                         H245_INST_T            dwInst,
                         H245_MESSAGE_TYPE_T    MessageType,
                         const unsigned char *  pData,
                         unsigned long          dwDataLength,
                         unsigned char          byCountryCode,
                         unsigned char          byExtension,
                         unsigned short         wManufacturerCode
                        );

H245DLL HRESULT
H245CommunicationModeRequest(H245_INST_T            dwInst);

H245DLL HRESULT
H245CommunicationModeResponse(
                         H245_INST_T            dwInst,
                         const H245_COMM_MODE_ENTRY_T *pTable,
                         unsigned char          byTableCount
                        );

H245DLL HRESULT
H245CommunicationModeCommand(
                         H245_INST_T            dwInst,
                         const H245_COMM_MODE_ENTRY_T *pTable,
                         unsigned char          byTableCount
                        );

H245DLL HRESULT
H245ConferenceRequest   (
                         H245_INST_T            dwInst,
                         H245_CONFER_REQ_ENUM_T RequestType,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        );

H245DLL HRESULT
H245ConferenceResponse  (
                         H245_INST_T            dwInst,
                         H245_CONFER_RSP_ENUM_T ResponseType,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber,
                         const unsigned char   *pOctetString,
                         unsigned char          byOctetStringLength,
                         const TerminalLabel   *pTerminalList,
                         unsigned short         wTerminalListCount
                        );

H245DLL HRESULT
H245ConferenceCommand   (
                         H245_INST_T            dwInst,
                         H245_CONFER_CMD_ENUM_T CommandType,
                         H245_CHANNEL_T         Channel,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        );

H245DLL HRESULT
H245ConferenceIndication(
                         H245_INST_T            dwInst,
                         H245_CONFER_IND_ENUM_T IndicationType,
                         unsigned char          bySbeNumber,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        );

H245DLL HRESULT
H245UserInput           (
                         H245_INST_T                    dwInst,
                         const WCHAR *                  pGenString,
                         const H245_NONSTANDARD_PARAMETER_T * pNonStd
                        );

H245DLL HRESULT
H245FlowControl         (
                         H245_INST_T            dwInst,
                         H245_SCOPE_T           Scope,
                         H245_CHANNEL_T         Channel,       // only used if Scope is H245_SCOPE_CHANNEL_NUMBER
                         unsigned short         wResourceID,   // only used if Scope is H245_SCOPE_RESOURCE_ID
                         unsigned long          dwRestriction  // H245_NO_RESTRICTION if no restriction
                        );

H245DLL HRESULT
H245H223SkewIndication  (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wLogicalChannelNumber1,
                         H245_CHANNEL_T         wLogicalChannelNumber2,
                         unsigned short         wSkew
                        );

H245DLL HRESULT
H245H2250MaximumSkewIndication(
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wLogicalChannelNumber1,
                         H245_CHANNEL_T         wLogicalChannelNumber2,
                         unsigned short         wMaximumSkew
                        );

H245DLL HRESULT
H245MCLocationIndication(
                         H245_INST_T                dwInst,
                         const H245_TRANSPORT_ADDRESS_T * pSignalAddress
                        );

H245DLL HRESULT
H245VendorIdentification(
                         H245_INST_T            dwInst,
                         const H245_NONSTANDID_T *pIdentifier,
                         const unsigned char   *pProductNumber,       // optional
                         unsigned char          byProductNumberLength,// optional
                         const unsigned char   *pVersionNumber,       // optional
                         unsigned char          byVersionNumberLength // optional
                        );

H245DLL HRESULT
H245SendPDU             (
                         H245_INST_T            dwInst,
                         PDU_T *                pPdu
                        );

H245DLL HRESULT
H245SystemControl       (
                         H245_INST_T            dwInst,
                         unsigned long          dwRequest,
                         void   *               pData
                        );

#ifdef __cplusplus
        }
#endif
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\h225asn.c ===
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for H.235 Security Messages v1 (H.235) */
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for Multimedia System Control (H.245) */
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for H.323 Messages v2 (H.225) */

#include <windows.h>
#include "h225asn.h"

ASN1module_t H225ASN_Module = NULL;

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_routing(ASN1encoding_t enc, TransportAddress_ipSourceRoute_routing *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route *val);
static int ASN1CALL ASN1Enc_RTPSession_associatedSessionIds(ASN1encoding_t enc, PRTPSession_associatedSessionIds *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_preGrantedARQ(ASN1encoding_t enc, RegistrationConfirm_preGrantedARQ *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_algorithmOIDs(ASN1encoding_t enc, PGatekeeperRequest_algorithmOIDs *val);
static int ASN1CALL ASN1Enc_TransportAddress_ip6Address(ASN1encoding_t enc, TransportAddress_ip6Address *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipxAddress(ASN1encoding_t enc, TransportAddress_ipxAddress *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute(ASN1encoding_t enc, TransportAddress_ipSourceRoute *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipAddress(ASN1encoding_t enc, TransportAddress_ipAddress *val);
static int ASN1CALL ASN1Enc_Progress_UUIE_fastStart(ASN1encoding_t enc, PProgress_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_fastStart(ASN1encoding_t enc, PFacility_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_fastStart(ASN1encoding_t enc, PSetup_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_conferenceGoal(ASN1encoding_t enc, Setup_UUIE_conferenceGoal *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCRV(ASN1encoding_t enc, PSetup_UUIE_destExtraCRV *val);
static int ASN1CALL ASN1Enc_Connect_UUIE_fastStart(ASN1encoding_t enc, PConnect_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_CallProceeding_UUIE_fastStart(ASN1encoding_t enc, PCallProceeding_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_Alerting_UUIE_fastStart(ASN1encoding_t enc, PAlerting_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_H323_UU_PDU_h245Control(ASN1encoding_t enc, PH323_UU_PDU_h245Control *val);
static int ASN1CALL ASN1Enc_H323_UU_PDU_h4501SupplementaryService(ASN1encoding_t enc, PH323_UU_PDU_h4501SupplementaryService *val);
static int ASN1CALL ASN1Enc_H323_UserInformation_user_data(ASN1encoding_t enc, H323_UserInformation_user_data *val);
static int ASN1CALL ASN1Enc_H235NonStandardParameter(ASN1encoding_t enc, H235NonStandardParameter *val);
static int ASN1CALL ASN1Enc_DHset(ASN1encoding_t enc, DHset *val);
static int ASN1CALL ASN1Enc_TypedCertificate(ASN1encoding_t enc, TypedCertificate *val);
static int ASN1CALL ASN1Enc_AuthenticationMechanism(ASN1encoding_t enc, AuthenticationMechanism *val);
static int ASN1CALL ASN1Enc_ClearToken(ASN1encoding_t enc, ClearToken *val);
static int ASN1CALL ASN1Enc_Params(ASN1encoding_t enc, Params *val);
static int ASN1CALL ASN1Enc_EncodedGeneralToken(ASN1encoding_t enc, EncodedGeneralToken *val);
static int ASN1CALL ASN1Enc_PwdCertToken(ASN1encoding_t enc, PwdCertToken *val);
static int ASN1CALL ASN1Enc_EncodedPwdCertToken(ASN1encoding_t enc, EncodedPwdCertToken *val);
static int ASN1CALL ASN1Enc_ReleaseCompleteReason(ASN1encoding_t enc, ReleaseCompleteReason *val);
static int ASN1CALL ASN1Enc_FacilityReason(ASN1encoding_t enc, FacilityReason *val);
static int ASN1CALL ASN1Enc_H221NonStandard(ASN1encoding_t enc, H221NonStandard *val);
static int ASN1CALL ASN1Enc_H225NonStandardIdentifier(ASN1encoding_t enc, H225NonStandardIdentifier *val);
static int ASN1CALL ASN1Enc_PublicTypeOfNumber(ASN1encoding_t enc, PublicTypeOfNumber *val);
static int ASN1CALL ASN1Enc_PrivateTypeOfNumber(ASN1encoding_t enc, PrivateTypeOfNumber *val);
static int ASN1CALL ASN1Enc_AltGKInfo(ASN1encoding_t enc, AltGKInfo *val);
static int ASN1CALL ASN1Enc_Q954Details(ASN1encoding_t enc, Q954Details *val);
static int ASN1CALL ASN1Enc_CallIdentifier(ASN1encoding_t enc, CallIdentifier *val);
static int ASN1CALL ASN1Enc_ICV(ASN1encoding_t enc, ICV *val);
static int ASN1CALL ASN1Enc_GatekeeperRejectReason(ASN1encoding_t enc, GatekeeperRejectReason *val);
static int ASN1CALL ASN1Enc_RegistrationRejectReason(ASN1encoding_t enc, RegistrationRejectReason *val);
static int ASN1CALL ASN1Enc_UnregRequestReason(ASN1encoding_t enc, UnregRequestReason *val);
static int ASN1CALL ASN1Enc_UnregRejectReason(ASN1encoding_t enc, UnregRejectReason *val);
static int ASN1CALL ASN1Enc_CallType(ASN1encoding_t enc, CallType *val);
static int ASN1CALL ASN1Enc_CallModel(ASN1encoding_t enc, CallModel *val);
static int ASN1CALL ASN1Enc_TransportQOS(ASN1encoding_t enc, TransportQOS *val);
static int ASN1CALL ASN1Enc_UUIEsRequested(ASN1encoding_t enc, UUIEsRequested *val);
static int ASN1CALL ASN1Enc_AdmissionRejectReason(ASN1encoding_t enc, AdmissionRejectReason *val);
static int ASN1CALL ASN1Enc_BandRejectReason(ASN1encoding_t enc, BandRejectReason *val);
static int ASN1CALL ASN1Enc_LocationRejectReason(ASN1encoding_t enc, LocationRejectReason *val);
static int ASN1CALL ASN1Enc_DisengageReason(ASN1encoding_t enc, DisengageReason *val);
static int ASN1CALL ASN1Enc_DisengageRejectReason(ASN1encoding_t enc, DisengageRejectReason *val);
static int ASN1CALL ASN1Enc_InfoRequestNakReason(ASN1encoding_t enc, InfoRequestNakReason *val);
static int ASN1CALL ASN1Enc_UnknownMessageResponse(ASN1encoding_t enc, UnknownMessageResponse *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_tokens *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_tokens(ASN1encoding_t enc, PResourcesAvailableConfirm_tokens *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_tokens(ASN1encoding_t enc, PResourcesAvailableIndicate_tokens *val);
static int ASN1CALL ASN1Enc_RequestInProgress_tokens(ASN1encoding_t enc, PRequestInProgress_tokens *val);
static int ASN1CALL ASN1Enc_UnknownMessageResponse_tokens(ASN1encoding_t enc, PUnknownMessageResponse_tokens *val);
static int ASN1CALL ASN1Enc_H225NonStandardMessage_tokens(ASN1encoding_t enc, PH225NonStandardMessage_tokens *val);
static int ASN1CALL ASN1Enc_InfoRequestNak_tokens(ASN1encoding_t enc, PInfoRequestNak_tokens *val);
static int ASN1CALL ASN1Enc_InfoRequestAck_tokens(ASN1encoding_t enc, PInfoRequestAck_tokens *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_tokens(ASN1encoding_t enc, PInfoRequestResponse_tokens *val);
static int ASN1CALL ASN1Enc_InfoRequest_tokens(ASN1encoding_t enc, PInfoRequest_tokens *val);
static int ASN1CALL ASN1Enc_DisengageReject_tokens(ASN1encoding_t enc, PDisengageReject_tokens *val);
static int ASN1CALL ASN1Enc_DisengageConfirm_tokens(ASN1encoding_t enc, PDisengageConfirm_tokens *val);
static int ASN1CALL ASN1Enc_DisengageRequest_tokens(ASN1encoding_t enc, PDisengageRequest_tokens *val);
static int ASN1CALL ASN1Enc_LocationReject_tokens(ASN1encoding_t enc, PLocationReject_tokens *val);
static int ASN1CALL ASN1Enc_LocationConfirm_tokens(ASN1encoding_t enc, PLocationConfirm_tokens *val);
static int ASN1CALL ASN1Enc_LocationRequest_tokens(ASN1encoding_t enc, PLocationRequest_tokens *val);
static int ASN1CALL ASN1Enc_BandwidthReject_tokens(ASN1encoding_t enc, PBandwidthReject_tokens *val);
static int ASN1CALL ASN1Enc_BandwidthConfirm_tokens(ASN1encoding_t enc, PBandwidthConfirm_tokens *val);
static int ASN1CALL ASN1Enc_BandwidthRequest_tokens(ASN1encoding_t enc, PBandwidthRequest_tokens *val);
static int ASN1CALL ASN1Enc_AdmissionReject_tokens(ASN1encoding_t enc, PAdmissionReject_tokens *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_tokens(ASN1encoding_t enc, PAdmissionConfirm_tokens *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_tokens(ASN1encoding_t enc, PAdmissionRequest_tokens *val);
static int ASN1CALL ASN1Enc_UnregistrationReject_tokens(ASN1encoding_t enc, PUnregistrationReject_tokens *val);
static int ASN1CALL ASN1Enc_UnregistrationConfirm_tokens(ASN1encoding_t enc, PUnregistrationConfirm_tokens *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest_tokens(ASN1encoding_t enc, PUnregistrationRequest_tokens *val);
static int ASN1CALL ASN1Enc_RegistrationReject_tokens(ASN1encoding_t enc, PRegistrationReject_tokens *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_tokens(ASN1encoding_t enc, PRegistrationConfirm_tokens *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_tokens(ASN1encoding_t enc, PRegistrationRequest_tokens *val);
static int ASN1CALL ASN1Enc_GatekeeperReject_tokens(ASN1encoding_t enc, PGatekeeperReject_tokens *val);
static int ASN1CALL ASN1Enc_GatekeeperConfirm_tokens(ASN1encoding_t enc, PGatekeeperConfirm_tokens *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_authenticationCapability(ASN1encoding_t enc, PGatekeeperRequest_authenticationCapability *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_tokens(ASN1encoding_t enc, PGatekeeperRequest_tokens *val);
static int ASN1CALL ASN1Enc_Endpoint_tokens(ASN1encoding_t enc, PEndpoint_tokens *val);
static int ASN1CALL ASN1Enc_Progress_UUIE_tokens(ASN1encoding_t enc, PProgress_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_tokens(ASN1encoding_t enc, PFacility_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_tokens(ASN1encoding_t enc, PSetup_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_Connect_UUIE_tokens(ASN1encoding_t enc, PConnect_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_CallProceeding_UUIE_tokens(ASN1encoding_t enc, PCallProceeding_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_Alerting_UUIE_tokens(ASN1encoding_t enc, PAlerting_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_SIGNED_EncodedGeneralToken(ASN1encoding_t enc, SIGNED_EncodedGeneralToken *val);
static int ASN1CALL ASN1Enc_ENCRYPTED(ASN1encoding_t enc, ENCRYPTED *val);
static int ASN1CALL ASN1Enc_HASHED(ASN1encoding_t enc, HASHED *val);
static int ASN1CALL ASN1Enc_SIGNED_EncodedPwdCertToken(ASN1encoding_t enc, SIGNED_EncodedPwdCertToken *val);
static int ASN1CALL ASN1Enc_Information_UUIE(ASN1encoding_t enc, Information_UUIE *val);
static int ASN1CALL ASN1Enc_ReleaseComplete_UUIE(ASN1encoding_t enc, ReleaseComplete_UUIE *val);
static int ASN1CALL ASN1Enc_VendorIdentifier(ASN1encoding_t enc, VendorIdentifier *val);
static int ASN1CALL ASN1Enc_H225NonStandardParameter(ASN1encoding_t enc, H225NonStandardParameter *val);
static int ASN1CALL ASN1Enc_PublicPartyNumber(ASN1encoding_t enc, PublicPartyNumber *val);
static int ASN1CALL ASN1Enc_PrivatePartyNumber(ASN1encoding_t enc, PrivatePartyNumber *val);
static int ASN1CALL ASN1Enc_SecurityServiceMode(ASN1encoding_t enc, SecurityServiceMode *val);
static int ASN1CALL ASN1Enc_SecurityCapabilities(ASN1encoding_t enc, SecurityCapabilities *val);
static int ASN1CALL ASN1Enc_H245Security(ASN1encoding_t enc, H245Security *val);
static int ASN1CALL ASN1Enc_QseriesOptions(ASN1encoding_t enc, QseriesOptions *val);
static int ASN1CALL ASN1Enc_EncryptIntAlg(ASN1encoding_t enc, EncryptIntAlg *val);
static int ASN1CALL ASN1Enc_NonIsoIntegrityMechanism(ASN1encoding_t enc, NonIsoIntegrityMechanism *val);
static int ASN1CALL ASN1Enc_IntegrityMechanism(ASN1encoding_t enc, IntegrityMechanism *val);
static int ASN1CALL ASN1Enc_FastStartToken(ASN1encoding_t enc, FastStartToken *val);
static int ASN1CALL ASN1Enc_EncodedFastStartToken(ASN1encoding_t enc, EncodedFastStartToken *val);
static int ASN1CALL ASN1Enc_DataRate(ASN1encoding_t enc, DataRate *val);
static int ASN1CALL ASN1Enc_GatekeeperReject(ASN1encoding_t enc, GatekeeperReject *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm(ASN1encoding_t enc, RegistrationConfirm *val);
static int ASN1CALL ASN1Enc_RegistrationReject(ASN1encoding_t enc, RegistrationReject *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest(ASN1encoding_t enc, UnregistrationRequest *val);
static int ASN1CALL ASN1Enc_UnregistrationConfirm(ASN1encoding_t enc, UnregistrationConfirm *val);
static int ASN1CALL ASN1Enc_UnregistrationReject(ASN1encoding_t enc, UnregistrationReject *val);
static int ASN1CALL ASN1Enc_AdmissionReject(ASN1encoding_t enc, AdmissionReject *val);
static int ASN1CALL ASN1Enc_BandwidthRequest(ASN1encoding_t enc, BandwidthRequest *val);
static int ASN1CALL ASN1Enc_BandwidthConfirm(ASN1encoding_t enc, BandwidthConfirm *val);
static int ASN1CALL ASN1Enc_BandwidthReject(ASN1encoding_t enc, BandwidthReject *val);
static int ASN1CALL ASN1Enc_LocationReject(ASN1encoding_t enc, LocationReject *val);
static int ASN1CALL ASN1Enc_DisengageRequest(ASN1encoding_t enc, DisengageRequest *val);
static int ASN1CALL ASN1Enc_DisengageConfirm(ASN1encoding_t enc, DisengageConfirm *val);
static int ASN1CALL ASN1Enc_DisengageReject(ASN1encoding_t enc, DisengageReject *val);
static int ASN1CALL ASN1Enc_InfoRequestAck(ASN1encoding_t enc, InfoRequestAck *val);
static int ASN1CALL ASN1Enc_InfoRequestNak(ASN1encoding_t enc, InfoRequestNak *val);
static int ASN1CALL ASN1Enc_H225NonStandardMessage(ASN1encoding_t enc, H225NonStandardMessage *val);
static int ASN1CALL ASN1Enc_RequestInProgress(ASN1encoding_t enc, RequestInProgress *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate(ASN1encoding_t enc, ResourcesAvailableIndicate *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm(ASN1encoding_t enc, ResourcesAvailableConfirm *val);
static int ASN1CALL ASN1Enc_GatekeeperConfirm_integrity(ASN1encoding_t enc, PGatekeeperConfirm_integrity *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_integrity(ASN1encoding_t enc, PGatekeeperRequest_integrity *val);
static int ASN1CALL ASN1Enc_CryptoH323Token_cryptoGKPwdHash(ASN1encoding_t enc, CryptoH323Token_cryptoGKPwdHash *val);
static int ASN1CALL ASN1Enc_NonStandardProtocol_dataRatesSupported(ASN1encoding_t enc, PNonStandardProtocol_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_T120OnlyCaps_dataRatesSupported(ASN1encoding_t enc, PT120OnlyCaps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_VoiceCaps_dataRatesSupported(ASN1encoding_t enc, PVoiceCaps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H324Caps_dataRatesSupported(ASN1encoding_t enc, PH324Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H323Caps_dataRatesSupported(ASN1encoding_t enc, PH323Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H322Caps_dataRatesSupported(ASN1encoding_t enc, PH322Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H321Caps_dataRatesSupported(ASN1encoding_t enc, PH321Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H320Caps_dataRatesSupported(ASN1encoding_t enc, PH320Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H310Caps_dataRatesSupported(ASN1encoding_t enc, PH310Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_h245SecurityCapability(ASN1encoding_t enc, PSetup_UUIE_h245SecurityCapability *val);
static int ASN1CALL ASN1Enc_H323_UU_PDU_nonStandardControl(ASN1encoding_t enc, PH323_UU_PDU_nonStandardControl *val);
static int ASN1CALL ASN1Enc_CryptoToken_cryptoHashedToken(ASN1encoding_t enc, CryptoToken_cryptoHashedToken *val);
static int ASN1CALL ASN1Enc_CryptoToken_cryptoSignedToken(ASN1encoding_t enc, CryptoToken_cryptoSignedToken *val);
static int ASN1CALL ASN1Enc_CryptoToken_cryptoEncryptedToken(ASN1encoding_t enc, CryptoToken_cryptoEncryptedToken *val);
static int ASN1CALL ASN1Enc_CryptoToken(ASN1encoding_t enc, CryptoToken *val);
static int ASN1CALL ASN1Enc_SIGNED_EncodedFastStartToken(ASN1encoding_t enc, SIGNED_EncodedFastStartToken *val);
static int ASN1CALL ASN1Enc_TransportAddress(ASN1encoding_t enc, TransportAddress *val);
static int ASN1CALL ASN1Enc_GatewayInfo(ASN1encoding_t enc, GatewayInfo *val);
static int ASN1CALL ASN1Enc_H310Caps(ASN1encoding_t enc, H310Caps *val);
static int ASN1CALL ASN1Enc_H320Caps(ASN1encoding_t enc, H320Caps *val);
static int ASN1CALL ASN1Enc_H321Caps(ASN1encoding_t enc, H321Caps *val);
static int ASN1CALL ASN1Enc_H322Caps(ASN1encoding_t enc, H322Caps *val);
static int ASN1CALL ASN1Enc_H323Caps(ASN1encoding_t enc, H323Caps *val);
static int ASN1CALL ASN1Enc_H324Caps(ASN1encoding_t enc, H324Caps *val);
static int ASN1CALL ASN1Enc_VoiceCaps(ASN1encoding_t enc, VoiceCaps *val);
static int ASN1CALL ASN1Enc_T120OnlyCaps(ASN1encoding_t enc, T120OnlyCaps *val);
static int ASN1CALL ASN1Enc_NonStandardProtocol(ASN1encoding_t enc, NonStandardProtocol *val);
static int ASN1CALL ASN1Enc_McuInfo(ASN1encoding_t enc, McuInfo *val);
static int ASN1CALL ASN1Enc_TerminalInfo(ASN1encoding_t enc, TerminalInfo *val);
static int ASN1CALL ASN1Enc_GatekeeperInfo(ASN1encoding_t enc, GatekeeperInfo *val);
static int ASN1CALL ASN1Enc_PartyNumber(ASN1encoding_t enc, PartyNumber *val);
static int ASN1CALL ASN1Enc_AlternateGK(ASN1encoding_t enc, AlternateGK *val);
static int ASN1CALL ASN1Enc_GatekeeperConfirm(ASN1encoding_t enc, GatekeeperConfirm *val);
static int ASN1CALL ASN1Enc_AdmissionRequest(ASN1encoding_t enc, AdmissionRequest *val);
static int ASN1CALL ASN1Enc_LocationRequest(ASN1encoding_t enc, LocationRequest *val);
static int ASN1CALL ASN1Enc_InfoRequest(ASN1encoding_t enc, InfoRequest *val);
static int ASN1CALL ASN1Enc_TransportChannelInfo(ASN1encoding_t enc, TransportChannelInfo *val);
static int ASN1CALL ASN1Enc_RTPSession(ASN1encoding_t enc, RTPSession *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_data *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_video *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_audio *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq(ASN1encoding_t enc, InfoRequestResponse_perCallInfo_Seq *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_callSignalAddress(ASN1encoding_t enc, PInfoRequestResponse_callSignalAddress *val);
static int ASN1CALL ASN1Enc_AdmissionReject_callSignalAddress(ASN1encoding_t enc, PAdmissionReject_callSignalAddress *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest_callSignalAddress(ASN1encoding_t enc, PUnregistrationRequest_callSignalAddress *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_alternateGatekeeper(ASN1encoding_t enc, PRegistrationConfirm_alternateGatekeeper *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_callSignalAddress(ASN1encoding_t enc, PRegistrationConfirm_callSignalAddress *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_rasAddress(ASN1encoding_t enc, PRegistrationRequest_rasAddress *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_callSignalAddress(ASN1encoding_t enc, PRegistrationRequest_callSignalAddress *val);
static int ASN1CALL ASN1Enc_GatekeeperConfirm_alternateGatekeeper(ASN1encoding_t enc, PGatekeeperConfirm_alternateGatekeeper *val);
static int ASN1CALL ASN1Enc_AltGKInfo_alternateGatekeeper(ASN1encoding_t enc, PAltGKInfo_alternateGatekeeper *val);
static int ASN1CALL ASN1Enc_Endpoint_rasAddress(ASN1encoding_t enc, PEndpoint_rasAddress *val);
static int ASN1CALL ASN1Enc_Endpoint_callSignalAddress(ASN1encoding_t enc, PEndpoint_callSignalAddress *val);
static int ASN1CALL ASN1Enc_EndpointType(ASN1encoding_t enc, EndpointType *val);
static int ASN1CALL ASN1Enc_SupportedProtocols(ASN1encoding_t enc, SupportedProtocols *val);
static int ASN1CALL ASN1Enc_AliasAddress(ASN1encoding_t enc, AliasAddress *val);
static int ASN1CALL ASN1Enc_Endpoint(ASN1encoding_t enc, Endpoint *val);
static int ASN1CALL ASN1Enc_SupportedPrefix(ASN1encoding_t enc, SupportedPrefix *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest(ASN1encoding_t enc, GatekeeperRequest *val);
static int ASN1CALL ASN1Enc_RegistrationRequest(ASN1encoding_t enc, RegistrationRequest *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm(ASN1encoding_t enc, AdmissionConfirm *val);
static int ASN1CALL ASN1Enc_LocationConfirm(ASN1encoding_t enc, LocationConfirm *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse(ASN1encoding_t enc, InfoRequestResponse *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_protocols(ASN1encoding_t enc, PResourcesAvailableIndicate_protocols *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_endpointAlias(ASN1encoding_t enc, PInfoRequestResponse_endpointAlias *val);
static int ASN1CALL ASN1Enc_LocationConfirm_alternateEndpoints(ASN1encoding_t enc, PLocationConfirm_alternateEndpoints *val);
static int ASN1CALL ASN1Enc_LocationConfirm_remoteExtensionAddress(ASN1encoding_t enc, PLocationConfirm_remoteExtensionAddress *val);
static int ASN1CALL ASN1Enc_LocationConfirm_destExtraCallInfo(ASN1encoding_t enc, PLocationConfirm_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_LocationConfirm_destinationInfo(ASN1encoding_t enc, PLocationConfirm_destinationInfo *val);
static int ASN1CALL ASN1Enc_LocationRequest_sourceInfo(ASN1encoding_t enc, PLocationRequest_sourceInfo *val);
static int ASN1CALL ASN1Enc_LocationRequest_destinationInfo(ASN1encoding_t enc, PLocationRequest_destinationInfo *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_alternateEndpoints(ASN1encoding_t enc, PAdmissionConfirm_alternateEndpoints *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_remoteExtensionAddress(ASN1encoding_t enc, PAdmissionConfirm_remoteExtensionAddress *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_destExtraCallInfo(ASN1encoding_t enc, PAdmissionConfirm_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_destinationInfo(ASN1encoding_t enc, PAdmissionConfirm_destinationInfo *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_destAlternatives(ASN1encoding_t enc, PAdmissionRequest_destAlternatives *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_srcAlternatives(ASN1encoding_t enc, PAdmissionRequest_srcAlternatives *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_srcInfo(ASN1encoding_t enc, PAdmissionRequest_srcInfo *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_destExtraCallInfo(ASN1encoding_t enc, PAdmissionRequest_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_destinationInfo(ASN1encoding_t enc, PAdmissionRequest_destinationInfo *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest_alternateEndpoints(ASN1encoding_t enc, PUnregistrationRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest_endpointAlias(ASN1encoding_t enc, PUnregistrationRequest_endpointAlias *val);
static int ASN1CALL ASN1Enc_RegistrationRejectReason_duplicateAlias(ASN1encoding_t enc, PRegistrationRejectReason_duplicateAlias *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_terminalAlias(ASN1encoding_t enc, PRegistrationConfirm_terminalAlias *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_alternateEndpoints(ASN1encoding_t enc, PRegistrationRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_terminalAlias(ASN1encoding_t enc, PRegistrationRequest_terminalAlias *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_alternateEndpoints(ASN1encoding_t enc, PGatekeeperRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_endpointAlias(ASN1encoding_t enc, PGatekeeperRequest_endpointAlias *val);
static int ASN1CALL ASN1Enc_CryptoH323Token_cryptoEPPwdHash(ASN1encoding_t enc, CryptoH323Token_cryptoEPPwdHash *val);
static int ASN1CALL ASN1Enc_Endpoint_destExtraCallInfo(ASN1encoding_t enc, PEndpoint_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_Endpoint_remoteExtensionAddress(ASN1encoding_t enc, PEndpoint_remoteExtensionAddress *val);
static int ASN1CALL ASN1Enc_Endpoint_aliasAddress(ASN1encoding_t enc, PEndpoint_aliasAddress *val);
static int ASN1CALL ASN1Enc_NonStandardProtocol_supportedPrefixes(ASN1encoding_t enc, PNonStandardProtocol_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_T120OnlyCaps_supportedPrefixes(ASN1encoding_t enc, PT120OnlyCaps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_VoiceCaps_supportedPrefixes(ASN1encoding_t enc, PVoiceCaps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H324Caps_supportedPrefixes(ASN1encoding_t enc, PH324Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H323Caps_supportedPrefixes(ASN1encoding_t enc, PH323Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H322Caps_supportedPrefixes(ASN1encoding_t enc, PH322Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H321Caps_supportedPrefixes(ASN1encoding_t enc, PH321Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H320Caps_supportedPrefixes(ASN1encoding_t enc, PH320Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H310Caps_supportedPrefixes(ASN1encoding_t enc, PH310Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_GatewayInfo_protocol(ASN1encoding_t enc, PGatewayInfo_protocol *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_destExtraCallInfo(ASN1encoding_t enc, PFacility_UUIE_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_alternativeAliasAddress(ASN1encoding_t enc, PFacility_UUIE_alternativeAliasAddress *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCallInfo(ASN1encoding_t enc, PSetup_UUIE_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_destinationAddress(ASN1encoding_t enc, PSetup_UUIE_destinationAddress *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_sourceAddress(ASN1encoding_t enc, PSetup_UUIE_sourceAddress *val);
static int ASN1CALL ASN1Enc_Alerting_UUIE(ASN1encoding_t enc, Alerting_UUIE *val);
static int ASN1CALL ASN1Enc_CallProceeding_UUIE(ASN1encoding_t enc, CallProceeding_UUIE *val);
static int ASN1CALL ASN1Enc_Connect_UUIE(ASN1encoding_t enc, Connect_UUIE *val);
static int ASN1CALL ASN1Enc_Setup_UUIE(ASN1encoding_t enc, Setup_UUIE *val);
static int ASN1CALL ASN1Enc_Facility_UUIE(ASN1encoding_t enc, Facility_UUIE *val);
static int ASN1CALL ASN1Enc_ConferenceList(ASN1encoding_t enc, ConferenceList *val);
static int ASN1CALL ASN1Enc_Progress_UUIE(ASN1encoding_t enc, Progress_UUIE *val);
static int ASN1CALL ASN1Enc_CryptoH323Token(ASN1encoding_t enc, CryptoH323Token *val);
static int ASN1CALL ASN1Enc_RasMessage(ASN1encoding_t enc, RasMessage *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_cryptoTokens(ASN1encoding_t enc, PResourcesAvailableConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_cryptoTokens(ASN1encoding_t enc, PResourcesAvailableIndicate_cryptoTokens *val);
static int ASN1CALL ASN1Enc_RequestInProgress_cryptoTokens(ASN1encoding_t enc, PRequestInProgress_cryptoTokens *val);
static int ASN1CALL ASN1Enc_UnknownMessageResponse_cryptoTokens(ASN1encoding_t enc, PUnknownMessageResponse_cryptoTokens *val);
static int ASN1CALL ASN1Enc_H225NonStandardMessage_cryptoTokens(ASN1encoding_t enc, PH225NonStandardMessage_cryptoTokens *val);
static int ASN1CALL ASN1Enc_InfoRequestNak_cryptoTokens(ASN1encoding_t enc, PInfoRequestNak_cryptoTokens *val);
static int ASN1CALL ASN1Enc_InfoRequestAck_cryptoTokens(ASN1encoding_t enc, PInfoRequestAck_cryptoTokens *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_cryptoTokens(ASN1encoding_t enc, PInfoRequestResponse_cryptoTokens *val);
static int ASN1CALL ASN1Enc_InfoRequest_cryptoTokens(ASN1encoding_t enc, PInfoRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_DisengageReject_cryptoTokens(ASN1encoding_t enc, PDisengageReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_DisengageConfirm_cryptoTokens(ASN1encoding_t enc, PDisengageConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_DisengageRequest_cryptoTokens(ASN1encoding_t enc, PDisengageRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_LocationReject_cryptoTokens(ASN1encoding_t enc, PLocationReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_LocationConfirm_cryptoTokens(ASN1encoding_t enc, PLocationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_LocationRequest_cryptoTokens(ASN1encoding_t enc, PLocationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_BandwidthReject_cryptoTokens(ASN1encoding_t enc, PBandwidthReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_BandwidthConfirm_cryptoTokens(ASN1encoding_t enc, PBandwidthConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_BandwidthRequest_cryptoTokens(ASN1encoding_t enc, PBandwidthRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_AdmissionReject_cryptoTokens(ASN1encoding_t enc, PAdmissionReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_cryptoTokens(ASN1encoding_t enc, PAdmissionConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_cryptoTokens(ASN1encoding_t enc, PAdmissionRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_UnregistrationReject_cryptoTokens(ASN1encoding_t enc, PUnregistrationReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_UnregistrationConfirm_cryptoTokens(ASN1encoding_t enc, PUnregistrationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest_cryptoTokens(ASN1encoding_t enc, PUnregistrationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_RegistrationReject_cryptoTokens(ASN1encoding_t enc, PRegistrationReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_cryptoTokens(ASN1encoding_t enc, PRegistrationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_cryptoTokens(ASN1encoding_t enc, PRegistrationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_GatekeeperReject_cryptoTokens(ASN1encoding_t enc, PGatekeeperReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_GatekeeperConfirm_cryptoTokens(ASN1encoding_t enc, PGatekeeperConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_cryptoTokens(ASN1encoding_t enc, PGatekeeperRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Endpoint_cryptoTokens(ASN1encoding_t enc, PEndpoint_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Progress_UUIE_cryptoTokens(ASN1encoding_t enc, PProgress_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_conferences(ASN1encoding_t enc, PFacility_UUIE_conferences *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_cryptoTokens(ASN1encoding_t enc, PFacility_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_cryptoTokens(ASN1encoding_t enc, PSetup_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Connect_UUIE_cryptoTokens(ASN1encoding_t enc, PConnect_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_CallProceeding_UUIE_cryptoTokens(ASN1encoding_t enc, PCallProceeding_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Alerting_UUIE_cryptoTokens(ASN1encoding_t enc, PAlerting_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_H323_UU_PDU_h323_message_body(ASN1encoding_t enc, H323_UU_PDU_h323_message_body *val);
static int ASN1CALL ASN1Enc_H323_UU_PDU(ASN1encoding_t enc, H323_UU_PDU *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(ASN1encoding_t enc, InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_pdu *val);
static int ASN1CALL ASN1Enc_H323_UserInformation(ASN1encoding_t enc, H323_UserInformation *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_routing(ASN1decoding_t dec, TransportAddress_ipSourceRoute_routing *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route *val);
static int ASN1CALL ASN1Dec_RTPSession_associatedSessionIds(ASN1decoding_t dec, PRTPSession_associatedSessionIds *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_preGrantedARQ(ASN1decoding_t dec, RegistrationConfirm_preGrantedARQ *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_algorithmOIDs(ASN1decoding_t dec, PGatekeeperRequest_algorithmOIDs *val);
static int ASN1CALL ASN1Dec_TransportAddress_ip6Address(ASN1decoding_t dec, TransportAddress_ip6Address *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipxAddress(ASN1decoding_t dec, TransportAddress_ipxAddress *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute(ASN1decoding_t dec, TransportAddress_ipSourceRoute *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipAddress(ASN1decoding_t dec, TransportAddress_ipAddress *val);
static int ASN1CALL ASN1Dec_Progress_UUIE_fastStart(ASN1decoding_t dec, PProgress_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_fastStart(ASN1decoding_t dec, PFacility_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_fastStart(ASN1decoding_t dec, PSetup_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_conferenceGoal(ASN1decoding_t dec, Setup_UUIE_conferenceGoal *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCRV(ASN1decoding_t dec, PSetup_UUIE_destExtraCRV *val);
static int ASN1CALL ASN1Dec_Connect_UUIE_fastStart(ASN1decoding_t dec, PConnect_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_CallProceeding_UUIE_fastStart(ASN1decoding_t dec, PCallProceeding_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_Alerting_UUIE_fastStart(ASN1decoding_t dec, PAlerting_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_H323_UU_PDU_h245Control(ASN1decoding_t dec, PH323_UU_PDU_h245Control *val);
static int ASN1CALL ASN1Dec_H323_UU_PDU_h4501SupplementaryService(ASN1decoding_t dec, PH323_UU_PDU_h4501SupplementaryService *val);
static int ASN1CALL ASN1Dec_H323_UserInformation_user_data(ASN1decoding_t dec, H323_UserInformation_user_data *val);
static int ASN1CALL ASN1Dec_H235NonStandardParameter(ASN1decoding_t dec, H235NonStandardParameter *val);
static int ASN1CALL ASN1Dec_DHset(ASN1decoding_t dec, DHset *val);
static int ASN1CALL ASN1Dec_TypedCertificate(ASN1decoding_t dec, TypedCertificate *val);
static int ASN1CALL ASN1Dec_AuthenticationMechanism(ASN1decoding_t dec, AuthenticationMechanism *val);
static int ASN1CALL ASN1Dec_ClearToken(ASN1decoding_t dec, ClearToken *val);
static int ASN1CALL ASN1Dec_Params(ASN1decoding_t dec, Params *val);
static int ASN1CALL ASN1Dec_EncodedGeneralToken(ASN1decoding_t dec, EncodedGeneralToken *val);
static int ASN1CALL ASN1Dec_PwdCertToken(ASN1decoding_t dec, PwdCertToken *val);
static int ASN1CALL ASN1Dec_EncodedPwdCertToken(ASN1decoding_t dec, EncodedPwdCertToken *val);
static int ASN1CALL ASN1Dec_ReleaseCompleteReason(ASN1decoding_t dec, ReleaseCompleteReason *val);
static int ASN1CALL ASN1Dec_FacilityReason(ASN1decoding_t dec, FacilityReason *val);
static int ASN1CALL ASN1Dec_H221NonStandard(ASN1decoding_t dec, H221NonStandard *val);
static int ASN1CALL ASN1Dec_H225NonStandardIdentifier(ASN1decoding_t dec, H225NonStandardIdentifier *val);
static int ASN1CALL ASN1Dec_PublicTypeOfNumber(ASN1decoding_t dec, PublicTypeOfNumber *val);
static int ASN1CALL ASN1Dec_PrivateTypeOfNumber(ASN1decoding_t dec, PrivateTypeOfNumber *val);
static int ASN1CALL ASN1Dec_AltGKInfo(ASN1decoding_t dec, AltGKInfo *val);
static int ASN1CALL ASN1Dec_Q954Details(ASN1decoding_t dec, Q954Details *val);
static int ASN1CALL ASN1Dec_CallIdentifier(ASN1decoding_t dec, CallIdentifier *val);
static int ASN1CALL ASN1Dec_ICV(ASN1decoding_t dec, ICV *val);
static int ASN1CALL ASN1Dec_GatekeeperRejectReason(ASN1decoding_t dec, GatekeeperRejectReason *val);
static int ASN1CALL ASN1Dec_RegistrationRejectReason(ASN1decoding_t dec, RegistrationRejectReason *val);
static int ASN1CALL ASN1Dec_UnregRequestReason(ASN1decoding_t dec, UnregRequestReason *val);
static int ASN1CALL ASN1Dec_UnregRejectReason(ASN1decoding_t dec, UnregRejectReason *val);
static int ASN1CALL ASN1Dec_CallType(ASN1decoding_t dec, CallType *val);
static int ASN1CALL ASN1Dec_CallModel(ASN1decoding_t dec, CallModel *val);
static int ASN1CALL ASN1Dec_TransportQOS(ASN1decoding_t dec, TransportQOS *val);
static int ASN1CALL ASN1Dec_UUIEsRequested(ASN1decoding_t dec, UUIEsRequested *val);
static int ASN1CALL ASN1Dec_AdmissionRejectReason(ASN1decoding_t dec, AdmissionRejectReason *val);
static int ASN1CALL ASN1Dec_BandRejectReason(ASN1decoding_t dec, BandRejectReason *val);
static int ASN1CALL ASN1Dec_LocationRejectReason(ASN1decoding_t dec, LocationRejectReason *val);
static int ASN1CALL ASN1Dec_DisengageReason(ASN1decoding_t dec, DisengageReason *val);
static int ASN1CALL ASN1Dec_DisengageRejectReason(ASN1decoding_t dec, DisengageRejectReason *val);
static int ASN1CALL ASN1Dec_InfoRequestNakReason(ASN1decoding_t dec, InfoRequestNakReason *val);
static int ASN1CALL ASN1Dec_UnknownMessageResponse(ASN1decoding_t dec, UnknownMessageResponse *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_tokens *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_tokens(ASN1decoding_t dec, PResourcesAvailableConfirm_tokens *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_tokens(ASN1decoding_t dec, PResourcesAvailableIndicate_tokens *val);
static int ASN1CALL ASN1Dec_RequestInProgress_tokens(ASN1decoding_t dec, PRequestInProgress_tokens *val);
static int ASN1CALL ASN1Dec_UnknownMessageResponse_tokens(ASN1decoding_t dec, PUnknownMessageResponse_tokens *val);
static int ASN1CALL ASN1Dec_H225NonStandardMessage_tokens(ASN1decoding_t dec, PH225NonStandardMessage_tokens *val);
static int ASN1CALL ASN1Dec_InfoRequestNak_tokens(ASN1decoding_t dec, PInfoRequestNak_tokens *val);
static int ASN1CALL ASN1Dec_InfoRequestAck_tokens(ASN1decoding_t dec, PInfoRequestAck_tokens *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_tokens(ASN1decoding_t dec, PInfoRequestResponse_tokens *val);
static int ASN1CALL ASN1Dec_InfoRequest_tokens(ASN1decoding_t dec, PInfoRequest_tokens *val);
static int ASN1CALL ASN1Dec_DisengageReject_tokens(ASN1decoding_t dec, PDisengageReject_tokens *val);
static int ASN1CALL ASN1Dec_DisengageConfirm_tokens(ASN1decoding_t dec, PDisengageConfirm_tokens *val);
static int ASN1CALL ASN1Dec_DisengageRequest_tokens(ASN1decoding_t dec, PDisengageRequest_tokens *val);
static int ASN1CALL ASN1Dec_LocationReject_tokens(ASN1decoding_t dec, PLocationReject_tokens *val);
static int ASN1CALL ASN1Dec_LocationConfirm_tokens(ASN1decoding_t dec, PLocationConfirm_tokens *val);
static int ASN1CALL ASN1Dec_LocationRequest_tokens(ASN1decoding_t dec, PLocationRequest_tokens *val);
static int ASN1CALL ASN1Dec_BandwidthReject_tokens(ASN1decoding_t dec, PBandwidthReject_tokens *val);
static int ASN1CALL ASN1Dec_BandwidthConfirm_tokens(ASN1decoding_t dec, PBandwidthConfirm_tokens *val);
static int ASN1CALL ASN1Dec_BandwidthRequest_tokens(ASN1decoding_t dec, PBandwidthRequest_tokens *val);
static int ASN1CALL ASN1Dec_AdmissionReject_tokens(ASN1decoding_t dec, PAdmissionReject_tokens *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_tokens(ASN1decoding_t dec, PAdmissionConfirm_tokens *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_tokens(ASN1decoding_t dec, PAdmissionRequest_tokens *val);
static int ASN1CALL ASN1Dec_UnregistrationReject_tokens(ASN1decoding_t dec, PUnregistrationReject_tokens *val);
static int ASN1CALL ASN1Dec_UnregistrationConfirm_tokens(ASN1decoding_t dec, PUnregistrationConfirm_tokens *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest_tokens(ASN1decoding_t dec, PUnregistrationRequest_tokens *val);
static int ASN1CALL ASN1Dec_RegistrationReject_tokens(ASN1decoding_t dec, PRegistrationReject_tokens *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_tokens(ASN1decoding_t dec, PRegistrationConfirm_tokens *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_tokens(ASN1decoding_t dec, PRegistrationRequest_tokens *val);
static int ASN1CALL ASN1Dec_GatekeeperReject_tokens(ASN1decoding_t dec, PGatekeeperReject_tokens *val);
static int ASN1CALL ASN1Dec_GatekeeperConfirm_tokens(ASN1decoding_t dec, PGatekeeperConfirm_tokens *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_authenticationCapability(ASN1decoding_t dec, PGatekeeperRequest_authenticationCapability *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_tokens(ASN1decoding_t dec, PGatekeeperRequest_tokens *val);
static int ASN1CALL ASN1Dec_Endpoint_tokens(ASN1decoding_t dec, PEndpoint_tokens *val);
static int ASN1CALL ASN1Dec_Progress_UUIE_tokens(ASN1decoding_t dec, PProgress_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_tokens(ASN1decoding_t dec, PFacility_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_tokens(ASN1decoding_t dec, PSetup_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_Connect_UUIE_tokens(ASN1decoding_t dec, PConnect_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_CallProceeding_UUIE_tokens(ASN1decoding_t dec, PCallProceeding_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_Alerting_UUIE_tokens(ASN1decoding_t dec, PAlerting_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_SIGNED_EncodedGeneralToken(ASN1decoding_t dec, SIGNED_EncodedGeneralToken *val);
static int ASN1CALL ASN1Dec_ENCRYPTED(ASN1decoding_t dec, ENCRYPTED *val);
static int ASN1CALL ASN1Dec_HASHED(ASN1decoding_t dec, HASHED *val);
static int ASN1CALL ASN1Dec_SIGNED_EncodedPwdCertToken(ASN1decoding_t dec, SIGNED_EncodedPwdCertToken *val);
static int ASN1CALL ASN1Dec_Information_UUIE(ASN1decoding_t dec, Information_UUIE *val);
static int ASN1CALL ASN1Dec_ReleaseComplete_UUIE(ASN1decoding_t dec, ReleaseComplete_UUIE *val);
static int ASN1CALL ASN1Dec_VendorIdentifier(ASN1decoding_t dec, VendorIdentifier *val);
static int ASN1CALL ASN1Dec_H225NonStandardParameter(ASN1decoding_t dec, H225NonStandardParameter *val);
static int ASN1CALL ASN1Dec_PublicPartyNumber(ASN1decoding_t dec, PublicPartyNumber *val);
static int ASN1CALL ASN1Dec_PrivatePartyNumber(ASN1decoding_t dec, PrivatePartyNumber *val);
static int ASN1CALL ASN1Dec_SecurityServiceMode(ASN1decoding_t dec, SecurityServiceMode *val);
static int ASN1CALL ASN1Dec_SecurityCapabilities(ASN1decoding_t dec, SecurityCapabilities *val);
static int ASN1CALL ASN1Dec_H245Security(ASN1decoding_t dec, H245Security *val);
static int ASN1CALL ASN1Dec_QseriesOptions(ASN1decoding_t dec, QseriesOptions *val);
static int ASN1CALL ASN1Dec_EncryptIntAlg(ASN1decoding_t dec, EncryptIntAlg *val);
static int ASN1CALL ASN1Dec_NonIsoIntegrityMechanism(ASN1decoding_t dec, NonIsoIntegrityMechanism *val);
static int ASN1CALL ASN1Dec_IntegrityMechanism(ASN1decoding_t dec, IntegrityMechanism *val);
static int ASN1CALL ASN1Dec_FastStartToken(ASN1decoding_t dec, FastStartToken *val);
static int ASN1CALL ASN1Dec_EncodedFastStartToken(ASN1decoding_t dec, EncodedFastStartToken *val);
static int ASN1CALL ASN1Dec_DataRate(ASN1decoding_t dec, DataRate *val);
static int ASN1CALL ASN1Dec_GatekeeperReject(ASN1decoding_t dec, GatekeeperReject *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm(ASN1decoding_t dec, RegistrationConfirm *val);
static int ASN1CALL ASN1Dec_RegistrationReject(ASN1decoding_t dec, RegistrationReject *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest(ASN1decoding_t dec, UnregistrationRequest *val);
static int ASN1CALL ASN1Dec_UnregistrationConfirm(ASN1decoding_t dec, UnregistrationConfirm *val);
static int ASN1CALL ASN1Dec_UnregistrationReject(ASN1decoding_t dec, UnregistrationReject *val);
static int ASN1CALL ASN1Dec_AdmissionReject(ASN1decoding_t dec, AdmissionReject *val);
static int ASN1CALL ASN1Dec_BandwidthRequest(ASN1decoding_t dec, BandwidthRequest *val);
static int ASN1CALL ASN1Dec_BandwidthConfirm(ASN1decoding_t dec, BandwidthConfirm *val);
static int ASN1CALL ASN1Dec_BandwidthReject(ASN1decoding_t dec, BandwidthReject *val);
static int ASN1CALL ASN1Dec_LocationReject(ASN1decoding_t dec, LocationReject *val);
static int ASN1CALL ASN1Dec_DisengageRequest(ASN1decoding_t dec, DisengageRequest *val);
static int ASN1CALL ASN1Dec_DisengageConfirm(ASN1decoding_t dec, DisengageConfirm *val);
static int ASN1CALL ASN1Dec_DisengageReject(ASN1decoding_t dec, DisengageReject *val);
static int ASN1CALL ASN1Dec_InfoRequestAck(ASN1decoding_t dec, InfoRequestAck *val);
static int ASN1CALL ASN1Dec_InfoRequestNak(ASN1decoding_t dec, InfoRequestNak *val);
static int ASN1CALL ASN1Dec_H225NonStandardMessage(ASN1decoding_t dec, H225NonStandardMessage *val);
static int ASN1CALL ASN1Dec_RequestInProgress(ASN1decoding_t dec, RequestInProgress *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate(ASN1decoding_t dec, ResourcesAvailableIndicate *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm(ASN1decoding_t dec, ResourcesAvailableConfirm *val);
static int ASN1CALL ASN1Dec_GatekeeperConfirm_integrity(ASN1decoding_t dec, PGatekeeperConfirm_integrity *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_integrity(ASN1decoding_t dec, PGatekeeperRequest_integrity *val);
static int ASN1CALL ASN1Dec_CryptoH323Token_cryptoGKPwdHash(ASN1decoding_t dec, CryptoH323Token_cryptoGKPwdHash *val);
static int ASN1CALL ASN1Dec_NonStandardProtocol_dataRatesSupported(ASN1decoding_t dec, PNonStandardProtocol_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_T120OnlyCaps_dataRatesSupported(ASN1decoding_t dec, PT120OnlyCaps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_VoiceCaps_dataRatesSupported(ASN1decoding_t dec, PVoiceCaps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H324Caps_dataRatesSupported(ASN1decoding_t dec, PH324Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H323Caps_dataRatesSupported(ASN1decoding_t dec, PH323Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H322Caps_dataRatesSupported(ASN1decoding_t dec, PH322Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H321Caps_dataRatesSupported(ASN1decoding_t dec, PH321Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H320Caps_dataRatesSupported(ASN1decoding_t dec, PH320Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H310Caps_dataRatesSupported(ASN1decoding_t dec, PH310Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_h245SecurityCapability(ASN1decoding_t dec, PSetup_UUIE_h245SecurityCapability *val);
static int ASN1CALL ASN1Dec_H323_UU_PDU_nonStandardControl(ASN1decoding_t dec, PH323_UU_PDU_nonStandardControl *val);
static int ASN1CALL ASN1Dec_CryptoToken_cryptoHashedToken(ASN1decoding_t dec, CryptoToken_cryptoHashedToken *val);
static int ASN1CALL ASN1Dec_CryptoToken_cryptoSignedToken(ASN1decoding_t dec, CryptoToken_cryptoSignedToken *val);
static int ASN1CALL ASN1Dec_CryptoToken_cryptoEncryptedToken(ASN1decoding_t dec, CryptoToken_cryptoEncryptedToken *val);
static int ASN1CALL ASN1Dec_CryptoToken(ASN1decoding_t dec, CryptoToken *val);
static int ASN1CALL ASN1Dec_SIGNED_EncodedFastStartToken(ASN1decoding_t dec, SIGNED_EncodedFastStartToken *val);
static int ASN1CALL ASN1Dec_TransportAddress(ASN1decoding_t dec, TransportAddress *val);
static int ASN1CALL ASN1Dec_GatewayInfo(ASN1decoding_t dec, GatewayInfo *val);
static int ASN1CALL ASN1Dec_H310Caps(ASN1decoding_t dec, H310Caps *val);
static int ASN1CALL ASN1Dec_H320Caps(ASN1decoding_t dec, H320Caps *val);
static int ASN1CALL ASN1Dec_H321Caps(ASN1decoding_t dec, H321Caps *val);
static int ASN1CALL ASN1Dec_H322Caps(ASN1decoding_t dec, H322Caps *val);
static int ASN1CALL ASN1Dec_H323Caps(ASN1decoding_t dec, H323Caps *val);
static int ASN1CALL ASN1Dec_H324Caps(ASN1decoding_t dec, H324Caps *val);
static int ASN1CALL ASN1Dec_VoiceCaps(ASN1decoding_t dec, VoiceCaps *val);
static int ASN1CALL ASN1Dec_T120OnlyCaps(ASN1decoding_t dec, T120OnlyCaps *val);
static int ASN1CALL ASN1Dec_NonStandardProtocol(ASN1decoding_t dec, NonStandardProtocol *val);
static int ASN1CALL ASN1Dec_McuInfo(ASN1decoding_t dec, McuInfo *val);
static int ASN1CALL ASN1Dec_TerminalInfo(ASN1decoding_t dec, TerminalInfo *val);
static int ASN1CALL ASN1Dec_GatekeeperInfo(ASN1decoding_t dec, GatekeeperInfo *val);
static int ASN1CALL ASN1Dec_PartyNumber(ASN1decoding_t dec, PartyNumber *val);
static int ASN1CALL ASN1Dec_AlternateGK(ASN1decoding_t dec, AlternateGK *val);
static int ASN1CALL ASN1Dec_GatekeeperConfirm(ASN1decoding_t dec, GatekeeperConfirm *val);
static int ASN1CALL ASN1Dec_AdmissionRequest(ASN1decoding_t dec, AdmissionRequest *val);
static int ASN1CALL ASN1Dec_LocationRequest(ASN1decoding_t dec, LocationRequest *val);
static int ASN1CALL ASN1Dec_InfoRequest(ASN1decoding_t dec, InfoRequest *val);
static int ASN1CALL ASN1Dec_TransportChannelInfo(ASN1decoding_t dec, TransportChannelInfo *val);
static int ASN1CALL ASN1Dec_RTPSession(ASN1decoding_t dec, RTPSession *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_data *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_video *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_audio *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq(ASN1decoding_t dec, InfoRequestResponse_perCallInfo_Seq *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_callSignalAddress(ASN1decoding_t dec, PInfoRequestResponse_callSignalAddress *val);
static int ASN1CALL ASN1Dec_AdmissionReject_callSignalAddress(ASN1decoding_t dec, PAdmissionReject_callSignalAddress *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest_callSignalAddress(ASN1decoding_t dec, PUnregistrationRequest_callSignalAddress *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_alternateGatekeeper(ASN1decoding_t dec, PRegistrationConfirm_alternateGatekeeper *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_callSignalAddress(ASN1decoding_t dec, PRegistrationConfirm_callSignalAddress *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_rasAddress(ASN1decoding_t dec, PRegistrationRequest_rasAddress *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_callSignalAddress(ASN1decoding_t dec, PRegistrationRequest_callSignalAddress *val);
static int ASN1CALL ASN1Dec_GatekeeperConfirm_alternateGatekeeper(ASN1decoding_t dec, PGatekeeperConfirm_alternateGatekeeper *val);
static int ASN1CALL ASN1Dec_AltGKInfo_alternateGatekeeper(ASN1decoding_t dec, PAltGKInfo_alternateGatekeeper *val);
static int ASN1CALL ASN1Dec_Endpoint_rasAddress(ASN1decoding_t dec, PEndpoint_rasAddress *val);
static int ASN1CALL ASN1Dec_Endpoint_callSignalAddress(ASN1decoding_t dec, PEndpoint_callSignalAddress *val);
static int ASN1CALL ASN1Dec_EndpointType(ASN1decoding_t dec, EndpointType *val);
static int ASN1CALL ASN1Dec_SupportedProtocols(ASN1decoding_t dec, SupportedProtocols *val);
static int ASN1CALL ASN1Dec_AliasAddress(ASN1decoding_t dec, AliasAddress *val);
static int ASN1CALL ASN1Dec_Endpoint(ASN1decoding_t dec, Endpoint *val);
static int ASN1CALL ASN1Dec_SupportedPrefix(ASN1decoding_t dec, SupportedPrefix *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest(ASN1decoding_t dec, GatekeeperRequest *val);
static int ASN1CALL ASN1Dec_RegistrationRequest(ASN1decoding_t dec, RegistrationRequest *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm(ASN1decoding_t dec, AdmissionConfirm *val);
static int ASN1CALL ASN1Dec_LocationConfirm(ASN1decoding_t dec, LocationConfirm *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse(ASN1decoding_t dec, InfoRequestResponse *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_protocols(ASN1decoding_t dec, PResourcesAvailableIndicate_protocols *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_endpointAlias(ASN1decoding_t dec, PInfoRequestResponse_endpointAlias *val);
static int ASN1CALL ASN1Dec_LocationConfirm_alternateEndpoints(ASN1decoding_t dec, PLocationConfirm_alternateEndpoints *val);
static int ASN1CALL ASN1Dec_LocationConfirm_remoteExtensionAddress(ASN1decoding_t dec, PLocationConfirm_remoteExtensionAddress *val);
static int ASN1CALL ASN1Dec_LocationConfirm_destExtraCallInfo(ASN1decoding_t dec, PLocationConfirm_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_LocationConfirm_destinationInfo(ASN1decoding_t dec, PLocationConfirm_destinationInfo *val);
static int ASN1CALL ASN1Dec_LocationRequest_sourceInfo(ASN1decoding_t dec, PLocationRequest_sourceInfo *val);
static int ASN1CALL ASN1Dec_LocationRequest_destinationInfo(ASN1decoding_t dec, PLocationRequest_destinationInfo *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_alternateEndpoints(ASN1decoding_t dec, PAdmissionConfirm_alternateEndpoints *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_remoteExtensionAddress(ASN1decoding_t dec, PAdmissionConfirm_remoteExtensionAddress *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_destExtraCallInfo(ASN1decoding_t dec, PAdmissionConfirm_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_destinationInfo(ASN1decoding_t dec, PAdmissionConfirm_destinationInfo *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_destAlternatives(ASN1decoding_t dec, PAdmissionRequest_destAlternatives *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_srcAlternatives(ASN1decoding_t dec, PAdmissionRequest_srcAlternatives *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_srcInfo(ASN1decoding_t dec, PAdmissionRequest_srcInfo *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_destExtraCallInfo(ASN1decoding_t dec, PAdmissionRequest_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_destinationInfo(ASN1decoding_t dec, PAdmissionRequest_destinationInfo *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest_alternateEndpoints(ASN1decoding_t dec, PUnregistrationRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest_endpointAlias(ASN1decoding_t dec, PUnregistrationRequest_endpointAlias *val);
static int ASN1CALL ASN1Dec_RegistrationRejectReason_duplicateAlias(ASN1decoding_t dec, PRegistrationRejectReason_duplicateAlias *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_terminalAlias(ASN1decoding_t dec, PRegistrationConfirm_terminalAlias *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_alternateEndpoints(ASN1decoding_t dec, PRegistrationRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_terminalAlias(ASN1decoding_t dec, PRegistrationRequest_terminalAlias *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_alternateEndpoints(ASN1decoding_t dec, PGatekeeperRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_endpointAlias(ASN1decoding_t dec, PGatekeeperRequest_endpointAlias *val);
static int ASN1CALL ASN1Dec_CryptoH323Token_cryptoEPPwdHash(ASN1decoding_t dec, CryptoH323Token_cryptoEPPwdHash *val);
static int ASN1CALL ASN1Dec_Endpoint_destExtraCallInfo(ASN1decoding_t dec, PEndpoint_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_Endpoint_remoteExtensionAddress(ASN1decoding_t dec, PEndpoint_remoteExtensionAddress *val);
static int ASN1CALL ASN1Dec_Endpoint_aliasAddress(ASN1decoding_t dec, PEndpoint_aliasAddress *val);
static int ASN1CALL ASN1Dec_NonStandardProtocol_supportedPrefixes(ASN1decoding_t dec, PNonStandardProtocol_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_T120OnlyCaps_supportedPrefixes(ASN1decoding_t dec, PT120OnlyCaps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_VoiceCaps_supportedPrefixes(ASN1decoding_t dec, PVoiceCaps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H324Caps_supportedPrefixes(ASN1decoding_t dec, PH324Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H323Caps_supportedPrefixes(ASN1decoding_t dec, PH323Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H322Caps_supportedPrefixes(ASN1decoding_t dec, PH322Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H321Caps_supportedPrefixes(ASN1decoding_t dec, PH321Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H320Caps_supportedPrefixes(ASN1decoding_t dec, PH320Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H310Caps_supportedPrefixes(ASN1decoding_t dec, PH310Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_GatewayInfo_protocol(ASN1decoding_t dec, PGatewayInfo_protocol *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_destExtraCallInfo(ASN1decoding_t dec, PFacility_UUIE_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_alternativeAliasAddress(ASN1decoding_t dec, PFacility_UUIE_alternativeAliasAddress *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCallInfo(ASN1decoding_t dec, PSetup_UUIE_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_destinationAddress(ASN1decoding_t dec, PSetup_UUIE_destinationAddress *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_sourceAddress(ASN1decoding_t dec, PSetup_UUIE_sourceAddress *val);
static int ASN1CALL ASN1Dec_Alerting_UUIE(ASN1decoding_t dec, Alerting_UUIE *val);
static int ASN1CALL ASN1Dec_CallProceeding_UUIE(ASN1decoding_t dec, CallProceeding_UUIE *val);
static int ASN1CALL ASN1Dec_Connect_UUIE(ASN1decoding_t dec, Connect_UUIE *val);
static int ASN1CALL ASN1Dec_Setup_UUIE(ASN1decoding_t dec, Setup_UUIE *val);
static int ASN1CALL ASN1Dec_Facility_UUIE(ASN1decoding_t dec, Facility_UUIE *val);
static int ASN1CALL ASN1Dec_ConferenceList(ASN1decoding_t dec, ConferenceList *val);
static int ASN1CALL ASN1Dec_Progress_UUIE(ASN1decoding_t dec, Progress_UUIE *val);
static int ASN1CALL ASN1Dec_CryptoH323Token(ASN1decoding_t dec, CryptoH323Token *val);
static int ASN1CALL ASN1Dec_RasMessage(ASN1decoding_t dec, RasMessage *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_cryptoTokens(ASN1decoding_t dec, PResourcesAvailableConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_cryptoTokens(ASN1decoding_t dec, PResourcesAvailableIndicate_cryptoTokens *val);
static int ASN1CALL ASN1Dec_RequestInProgress_cryptoTokens(ASN1decoding_t dec, PRequestInProgress_cryptoTokens *val);
static int ASN1CALL ASN1Dec_UnknownMessageResponse_cryptoTokens(ASN1decoding_t dec, PUnknownMessageResponse_cryptoTokens *val);
static int ASN1CALL ASN1Dec_H225NonStandardMessage_cryptoTokens(ASN1decoding_t dec, PH225NonStandardMessage_cryptoTokens *val);
static int ASN1CALL ASN1Dec_InfoRequestNak_cryptoTokens(ASN1decoding_t dec, PInfoRequestNak_cryptoTokens *val);
static int ASN1CALL ASN1Dec_InfoRequestAck_cryptoTokens(ASN1decoding_t dec, PInfoRequestAck_cryptoTokens *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_cryptoTokens(ASN1decoding_t dec, PInfoRequestResponse_cryptoTokens *val);
static int ASN1CALL ASN1Dec_InfoRequest_cryptoTokens(ASN1decoding_t dec, PInfoRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_DisengageReject_cryptoTokens(ASN1decoding_t dec, PDisengageReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_DisengageConfirm_cryptoTokens(ASN1decoding_t dec, PDisengageConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_DisengageRequest_cryptoTokens(ASN1decoding_t dec, PDisengageRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_LocationReject_cryptoTokens(ASN1decoding_t dec, PLocationReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_LocationConfirm_cryptoTokens(ASN1decoding_t dec, PLocationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_LocationRequest_cryptoTokens(ASN1decoding_t dec, PLocationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_BandwidthReject_cryptoTokens(ASN1decoding_t dec, PBandwidthReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_BandwidthConfirm_cryptoTokens(ASN1decoding_t dec, PBandwidthConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_BandwidthRequest_cryptoTokens(ASN1decoding_t dec, PBandwidthRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_AdmissionReject_cryptoTokens(ASN1decoding_t dec, PAdmissionReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_cryptoTokens(ASN1decoding_t dec, PAdmissionConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_cryptoTokens(ASN1decoding_t dec, PAdmissionRequest_cryptoTokens *val);
static int ASN1CALL ASN1