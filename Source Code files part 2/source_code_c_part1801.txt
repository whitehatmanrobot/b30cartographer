UE;
			//}
		}
	}
	return returnVal;
}



BOOL CRegWizard::GetInputParameterString(short paramID, LPTSTR szParam)
/***************************************************************************
This function retrieves an input parameter string.  The paramID parameter
must be the resource ID of the Registration Database key whose contents are
to be returned in the szParam parameter.

Allowable values for paramID:
- IDS_INPUT_PRODUCTNAME
- IDS_INPUT_PRODUCTID
- IDS_INPUT_INVENTORYPATH
- IDS_INPUT_ISREGISTERED

Returns:
- FALSE if the specified key cannot be found in the Registry.
****************************************************************************/
{
	BOOL returnVal = FALSE;
	_TCHAR szFullParamRegKey[300];
	_TCHAR szParamSubKey[64];
	LPTSTR szValueName;
	szParam[0] = NULL;
	_tcscpy(szFullParamRegKey,m_szParamRegKey);
	int resSize = LoadString(m_hInstance,paramID,szParamSubKey,63);
	#ifdef USE_INPUT_SUBKEYS
	{
		_tcscat(szFullParamRegKey,_T"\\");
		_tcscat(szFullParamRegKey,szParamSubKey);
		szValueName = NULL;
	}
	#else
	{
		szValueName = szParamSubKey;
	}
	#endif

	HKEY hKey;
	LONG regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szFullParamRegKey,0,KEY_READ,&hKey);
	if (regStatus == ERROR_SUCCESS)
	{
		unsigned long infoSize;
		infoSize = kRegBufferSize;
		regStatus = RegQueryValueEx(hKey,szValueName,NULL,0,(LPBYTE) szParam,&infoSize);
		if (regStatus == ERROR_SUCCESS)
		{
			returnVal = TRUE;
		}
		RegCloseKey(hKey);
	}
	return returnVal;
}


BOOL CRegWizard::IsRegistered( void )
/***************************************************************************
This function returns TRUE if registration for the product specified by
the input parameters (via the Registration Database) has already been
performed.
****************************************************************************/
{
	_TCHAR szIsRegistered[kRegBufferSize];
	BOOL goodParam = GetInputParameterString(IDS_INPUT_ISREGISTERED,szIsRegistered);
	return goodParam == TRUE && szIsRegistered[0] == _T('1') ? TRUE : FALSE;

}


int CRegWizard::AddProduct(LPTSTR szProductName,LPTSTR szProductPath)
/***************************************************************************
This function adds the product whose name is given by the szProductName
parameter to the inventory of our user's installed products.

Returns: the new count of products on the list.
****************************************************************************/
{
	short strLenName = (_tcslen(szProductName)+1) * sizeof(_TCHAR);
	short strLenPath = (_tcslen(szProductPath)+1) * sizeof(_TCHAR);
	if (m_productNameCount < kMaxProductCount)
	{
		m_rgszProductName[m_productNameCount] = (LPTSTR) LocalAlloc(0,strLenName );
		_tcscpy(m_rgszProductName[m_productNameCount],szProductName);

		m_rgszProductPath[m_productNameCount] = (LPTSTR) LocalAlloc(0,strLenPath);
		_tcscpy(m_rgszProductPath[m_productNameCount],szProductPath);

		m_rghProductIcon[m_productNameCount] = NULL;
		m_productNameCount++;
	}
	return m_productNameCount;
}


void CRegWizard::GetProductName(LPTSTR szProductName,INT_PTR index)
/***************************************************************************
This function returns the product name whose index is given by the 'index'
parameter.  If index is greater than the number of products on the list, an
empty string will be returned.
****************************************************************************/
{
	szProductName[0] = NULL;
	if (index < m_productNameCount)
	{
		_tcscpy(szProductName, m_rgszProductName[index]);
	}
}

HICON CRegWizard::GetProductIcon(INT_PTR index)
/***************************************************************************
This function returns an icon for the product whose index is given by the
'index' parameter. If index is greater than the number of products on the
list, NULL will be returned.
****************************************************************************/
{
	if (index < m_productNameCount)
	{
		if (m_rghProductIcon[index] == NULL)
		{
			m_rghProductIcon[index] = ExtractIcon(m_hInstance,m_rgszProductPath[index],0);
			//m_rghProductIcon[index] = LoadImage(m_hInstance,m_rgszProductPath[index],IMAGE_ICON,32,32,LR_LOADFROMFILE);
			DWORD lastErr = GetLastError();
			if (m_rghProductIcon[index] == NULL)
			{
				m_rghProductIcon[index] = LoadIcon(m_hInstance,MAKEINTRESOURCE(IDI_REGWIZ));
			}
		}
		return m_rghProductIcon[index];
	}
	else
	{
		return NULL;
	}
}



short CRegWizard::GetProductCount( void )
/***************************************************************************
This function returns a count of the current number of products occupying
the inventory list.
****************************************************************************/
{
	return m_productNameCount;
}



void CRegWizard::SetInformationString(InfoIndex index, LPTSTR szInfo)
/***************************************************************************
This function saves the given string interally, associating it with info
attribute whose ID is given by the 'index' parameter.
****************************************************************************/
{
	short strLen ;
	if (index < kInfoLastIndex)
	{
		if (m_rgszInfoArray[index] != NULL)
		{
			LocalFree(m_rgszInfoArray[index]);
			m_rgszInfoArray[index] = NULL;
		}
		if(szInfo == NULL ) return;

		strLen = (_tcslen(szInfo)+1) * sizeof(_TCHAR);
		m_rgszInfoArray[index] = (LPTSTR) LocalAlloc(0, strLen);
		_tcscpy(m_rgszInfoArray[index],szInfo);
	}
}


BOOL CRegWizard::GetInformationString(InfoIndex index, LPTSTR szInfo)
/***************************************************************************
This function retrieves the information string whose ID is given by the
'index' parameter.  If the requested string has not been set yet, FALSE
will be returned as the function result, and an empty string will be
returned in szInfo.

Note: if you are interested only in determining whether the value is set
for a particular information string, you can pass NULL for szInfo.
****************************************************************************/
{
	if (index < kInfoLastIndex && m_rgszInfoArray[index] && m_rgszInfoArray[index][0]!=_T('\0') )
	{
		if (szInfo) _tcscpy(szInfo,m_rgszInfoArray[index]);
		return TRUE;
	}
	else
	{

		//if (szInfo) szInfo[0] = NULL;  by Suresh 06/6/97
		szInfo[0] = _T('\0');
		return FALSE;
	}
}


void CRegWizard::SetTriStateInformation(InfoIndex index, TriState infoValue)
/***************************************************************************
This function saves the given TriState value interally, associating it with
the info attribute whose ID is given by the 'index' parameter.

Note: if infoValue is kTriStateTrue, the value will be saved as "1"; if
kTriStateFalse or kTriStateUndefined, it will be saved as "0".
****************************************************************************/
{
	_TCHAR szInfo[4];
	_stprintf(szInfo,_T("%i"),infoValue == kTriStateTrue ? 1 : 0);
	SetInformationString(index,szInfo);
}


TriState CRegWizard::GetTriStateInformation(InfoIndex index)
/***************************************************************************
This function retrieves the TriState value whose ID is given by the 'index'
parameter.

Returns:
- kTriStateTrue
- kTriStateFalse
- kTriStateUndefined: value has not been set yet.
****************************************************************************/
{
	_TCHAR szInfo[kRegBufferSize];
	BOOL goodString = GetInformationString(index,szInfo);
	if (goodString == FALSE)
	{
		return kTriStateUndefined;
	}
	else
	{
		return szInfo[0] == _T('0') ? kTriStateFalse : kTriStateTrue;
	}
}


void CRegWizard::WriteEnableInformation(InfoIndex index, BOOL shouldWrite)
/***************************************************************************
If shouldWrite is TRUE, the information associated with the given index
will be enabled for writing to the Registration Database; otherwise, the
value for this index will be written as a NULL string.  By default, all
information members are write-enabled.
****************************************************************************/
{
	m_writeEnable[index] = shouldWrite;
}


BOOL CRegWizard::IsInformationWriteEnabled(InfoIndex index)
/***************************************************************************
Returns TRUE if the information associated with the given index is enabled
for writing to the Registration Database.
****************************************************************************/
{
	return m_writeEnable[index];
}


void CRegWizard::SetProductSearchStatus(TriState searchCompleted)
/***************************************************************************
This function needs to be called with a searchCompleted value of
kTriStateTrue when the product searching thread completes, or
kTriStateUndefined if an error prevents the search from being completed.
****************************************************************************/
{
	m_searchCompleted = searchCompleted;
}


TriState CRegWizard::GetProductSearchStatus( void )
/***************************************************************************
This function returns:
- kTriStateTrue if the product searching thread has completed.
- kTriStateFalse if the search is still in progress.
- kTriStateUndefined if an error prevented the search from being completed.
****************************************************************************/
{
	return m_searchCompleted;
}


void CRegWizard::SetSystemInventoryStatus(BOOL invCompleted)
/***************************************************************************
This function needs to be called with a invCompleted value of TRUE when
the system inventory compilation thread completes.
****************************************************************************/
{
	m_systemInventoryCompleted = invCompleted;
}


BOOL CRegWizard::GetSystemInventoryStatus( void )
/***************************************************************************
This function returns TRUE if the system inventory compilation thread has
completed.
****************************************************************************/
{
	return m_systemInventoryCompleted;
}


void CRegWizard::WriteInfoToRegistry( void )
/***************************************************************************
Writes all the information gathered by the RegWizard to the appropriate keys
in the Registration Database.
****************************************************************************/
{

	short index = kInfoFirstName;
	_TCHAR szRegKey[kRegBufferSize];
	_TCHAR szLogBuffer[kRegBufferSize];
	HKEY hKey;
	DWORD dwReserved=0;
	DWORD dwDisposition;
	TBYTE* lpbData;
	DWORD  dwStrSz;

	#ifndef WRITE_COUNTRY_AS_STRING
	wsprintf(szLogBuffer,_T("%li"),GetCountryCode());
	SetInformationString(kInfoCountry,szLogBuffer);
	#endif
	
	_tcscpy(szLogBuffer,_T("=== Microsoft Registration Wizard ==="));
	WriteToLogFile(szLogBuffer);

	GetInfoRegistrationParentKey(szRegKey);	

	LONG regStatus = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
					szRegKey,
					dwReserved,
					NULL,
					REG_OPTION_NON_VOLATILE,
					KEY_ALL_ACCESS,
					NULL,
					&hKey,
					&dwDisposition);

	if (regStatus != ERROR_SUCCESS) return;

	while (index != kInfoLastIndex)
	{
		_TCHAR szInfo[kRegBufferSize];
		_TCHAR szValueName[kRegBufferSize];
		GetInfoRegValueName((InfoIndex) index,szValueName);

		// The value of any information entry that has been "write-disabled"
		// will be blanked out (i.e. the key will be written, but with an
		// empty string as the value).
		if (m_writeEnable[index] == FALSE)
		{
			szInfo[0] = NULL;
		}
		else
		{
			GetInformationString((InfoIndex) index,szInfo);
		}
		
		// First, write to our log file
		wsprintf(szLogBuffer,_T("%s = %s"),szValueName,szInfo);
		WriteToLogFile(szLogBuffer);
		if(szInfo[0] == _T('\0')) {
			lpbData = (TBYTE*) _T("\0");
			dwStrSz = _tcslen((const TCHAR *) lpbData)* sizeof(_TCHAR);
			regStatus = RegSetValueEx(hKey,szValueName,NULL,REG_SZ,(CONST BYTE*) lpbData,sizeof(TCHAR));
			

		}else{
		 lpbData = (TBYTE*) szInfo;
		 dwStrSz = _tcslen(szInfo)* sizeof(_TCHAR);
		 	regStatus = RegSetValueEx(hKey,szValueName,NULL,REG_SZ,(CONST BYTE *)lpbData, dwStrSz);
		}
		
		index++;
	}

	// If the kInfoIncludeProducts flag is FALSE, we want to write the ProductX keys,
	// but blank out the values.
	BOOL shouldIncludeProducts = GetTriStateInformation(kInfoIncludeProducts);
	index = 0;
	_TCHAR szProductBase[64];
	int resSize = LoadString(m_hInstance,IDS_PRODUCTBASEKEY,szProductBase,64);
	while (index < kMaxProductCount)
	{
		_TCHAR szProductValueName[kRegBufferSize];
		_TCHAR szProductName[kRegBufferSize];
		_stprintf(szProductValueName,_T("%s %i"),szProductBase,index + 1);
		if (shouldIncludeProducts == kTriStateTrue)
		{
			GetProductName(szProductName,index);
		}
		else
		{
			szProductName[0] = NULL;
		}
		wsprintf(szLogBuffer,_T("%s = %s"),szProductValueName,szProductName);
		WriteToLogFile(szLogBuffer);
		regStatus = RegSetValueEx(hKey,szProductValueName,NULL,REG_SZ,(CONST BYTE*) szProductName,_tcslen(szProductName)* sizeof(_TCHAR));
		index++;
	}

	RegCloseKey(hKey);
	CloseLogFile();
}
									

void CRegWizard::ReadInfoFromRegistry( void )
/***************************************************************************
Reads any information written to the Registration Database by previous runs
of RegWizard, and populates all information strings accordingly.
****************************************************************************/
{
	short index = kInfoFirstName;
	_TCHAR szRegKey[kRegBufferSize];
	HKEY hKey;

	GetInfoRegistrationParentKey(szRegKey);	
#ifdef SURESH
	LONG regStatus = RegOpenKeyEx(HKEY_CURRENT_USER,szRegKey,0,KEY_READ,&hKey);
#endif
	LONG regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szRegKey,0,KEY_READ,&hKey);

	if (regStatus == ERROR_SUCCESS)
	{
		while (index != kInfoLastIndex)
		{
			_TCHAR szInfo[kRegBufferSize];
			_TCHAR szValueName[kRegBufferSize];
			unsigned long infoSize;
			BOOL refresh = GetInfoRegValueName((InfoIndex) index,szValueName);
			if (refresh)
			{
				infoSize = kRegBufferSize;
				regStatus = RegQueryValueEx(hKey,szValueName,NULL,0,(LPBYTE) szInfo,&infoSize);
				if (regStatus == ERROR_SUCCESS)
				{
					SetInformationString((InfoIndex) index,szInfo);
				}
			}
			index++;
		}
		RegCloseKey(hKey);
	}

	// Two of the information fields are fed to RegWizard as input parameters;
	// we'll read these from our input parameter block.
	_TCHAR szParam[kRegBufferSize];
	GetInputParameterString(IDS_INPUT_PRODUCTNAME,szParam);
	SetInformationString(kInfoApplicationName,szParam);
	GetInputParameterString(IDS_INPUT_PRODUCTID,szParam);
	SetInformationString(kInfoProductID,szParam);
}


BOOL CRegWizard::GetInfoRegValueName(InfoIndex infoIndex,LPTSTR szValueName)
/***************************************************************************
Returns in buffer pointed to by szValueName the value name associated with
the information item specified by infoIndex.

Returns:
If this key represents a value that should be used to refresh the value in
memory when RegWizard starts up,TRUE will be returned as the function result.
****************************************************************************/
{
	_TCHAR szOrigValueName[kRegBufferSize];
	LPTSTR szValueNamePtr;
	BOOL shouldRefresh = FALSE;
	short infoResIndex ;
	int resSize;

	if(infoIndex < kDivisionName ){
		infoResIndex = IDS_INFOKEY1 + infoIndex;
		resSize = LoadString(m_hInstance,infoResIndex,szOrigValueName,255);
	}else {
		infoResIndex = IDS_DIVISIONNAME_KEY + (infoIndex-kDivisionName);
		resSize = LoadString(m_hInstance,infoResIndex,szOrigValueName,255);

	}
	// After 03/03/98 in corporationg extra fields for Division and UserID, assuming
	// more fields can be added in the future a set of 15 more ID is reserver in the resource
	// so for Division and USEID, this pool of resource ID  will be used



	// SubKeys are flagged as 'refresh' keys by a leading underscore
	szValueNamePtr = szOrigValueName;
	if (szOrigValueName[0] == _T('_'))
	{
		shouldRefresh = TRUE;
		szValueNamePtr = _tcsinc(szValueNamePtr);
	}
	_tcscpy(szValueName,szValueNamePtr);
	return shouldRefresh;
}


void CRegWizard::GetInfoRegistrationParentKey(LPTSTR szRegKey)
/***************************************************************************
Returns the Registration Database key that specifies the parent of all our
information keys.
****************************************************************************/
{
	if (m_szInfoParentKey[0] == NULL)
	{
		_TCHAR szPartialKey[kRegBufferSize];
		int resSize = LoadString(m_hInstance,IDS_KEY2,szRegKey,255);
		_tcscat(szRegKey,_T("\\"));
		resSize = LoadString(m_hInstance,IDS_KEY3,szPartialKey,255);
		_tcscat(szRegKey,szPartialKey);
		_tcscat(szRegKey,_T("\\"));
		resSize = LoadString(m_hInstance,IDS_KEY4,szPartialKey,255);
		_tcscat(szRegKey,szPartialKey);
		#ifdef USE_INFO_SUBKEYS
		_tcscat(szRegKey,_T("\\"));
		#endif
		_tcscpy(m_szInfoParentKey,szRegKey);
	}
	else
	{
		_tcscpy(szRegKey,m_szInfoParentKey);
	}
}


void CRegWizard::GetRegKey(LPTSTR szRegKey)
/**************************************************************************
Returns the country code selected by the user in the Address dialog.
****************************************************************************/
{
	_tcscpy(szRegKey,m_szParamRegKey);
}


HINSTANCE CRegWizard::GetInstance( void )
/***************************************************************************
Returns the instance handle of the application that created this
CRegWiz object.
****************************************************************************/
{
	return m_hInstance;
}


void CRegWizard::SetCountryCode(DWORD countryCode)
/***************************************************************************
Saves off the country code selected by the user in the Address dialog.
****************************************************************************/
{
	m_countryCode = countryCode;
}


DWORD CRegWizard::GetCountryCode( void )
/**************************************************************************
Returns the country code selected by the user in the Address dialog.
****************************************************************************/
{
	return m_countryCode;
}


void CRegWizard::GetCountryAddrSpec(LONG lCountryID,ADDRSPEC* addrSpec )
/**************************************************************************
Returns a ADDRSPEC structure based on the specified countryID value.
****************************************************************************/
{
	if (lCountryID >= 0 && m_addrJumpTable != NULL)
	{
		JTE* addrJumpTable = (JTE*) GlobalLock(m_addrJumpTable);
		JTE jumpIndex = addrJumpTable[lCountryID];
		if (addrSpec)
		{
			ADDRSPEC* addrSpecTable = (ADDRSPEC*) GlobalLock(m_addrSpecTable);
			*addrSpec = addrSpecTable[jumpIndex];
			GlobalUnlock(m_addrSpecTable);
		}
		GlobalUnlock(m_addrJumpTable);
	}
}


void CRegWizard::GetAddrSpecProperties(DWORD dwCountryCode, ADDRSPEC_FIELD addrSpecField, MAXLEN* maxLen,BOOL* isRequired)
/*********************************************************************
Returns the maximum char length and "required?" properties associated
with the editable field specified by addrSpecField, and the country
code specified in the dwCountryCode parameter.
**********************************************************************/
{
	BOOL lclIsRequired = TRUE;
	ADDRSPEC addrSpec;
	GetCountryAddrSpec(dwCountryCode,&addrSpec);
	if (maxLen)
	{
		*maxLen = addrSpec.maxLen[addrSpecField];
		if (*maxLen < 0)
		{
			*maxLen = abs(*maxLen);
			lclIsRequired = FALSE;
		}
	}
	if((dwCountryCode == 0)&&(addrSpecField == kAddrSpecState))
	{
			*maxLen = (MAXLEN)2;
	}
	if((dwCountryCode == 0)&&(addrSpecField == kAddrSpecResellerState))
	{
			*maxLen = (MAXLEN)2;
	}
	
	RW_DEBUG << "COUNTRY CODE:" << dwCountryCode << "SPEC FIELD" << addrSpecField<<"LENGTH:" << (int) (*maxLen) << endl;

	if (isRequired) *isRequired = lclIsRequired;
}


BOOL CRegWizard::IsEditTextFieldValid(HWND hwndDlg,int editID)
/*********************************************************************
Returns TRUE if the edit text field specified by the editID parameter
contains at least one character, OR has been marked as 'not required'
by a call to the ConfigureEditTextField function.

Note: if the edit text field has been disabled, it will considered to
be "not required", regardless of the state set by ConfigureEditText-
Field.
**********************************************************************/
{
	HWND hwndEdit = GetDlgItem(hwndDlg,editID);
	BOOL isEnabled = IsWindowEnabled(hwndEdit);
	BOOL isRequired = isEnabled == FALSE ? FALSE : (BOOL) HIWORD(GetWindowLongPtr(hwndEdit,GWLP_USERDATA));
	LRESULT editTextLen = SendMessage(hwndEdit,WM_GETTEXTLENGTH,0,0L);
	return isRequired == FALSE || editTextLen > 0 ? TRUE : FALSE;
}



void CRegWizard::GetEditTextFieldAttachedString(HWND hwndDlg,int editID,LPTSTR szAttached,int cbBufferSize)
/*********************************************************************
Returns the string whose resource ID was attached to the specified
edit control by a call to ConfigureEditTextField
**********************************************************************/
{
	_TCHAR szBuffer[kRegBufferSize];
	HWND hwndEdit = GetDlgItem(hwndDlg,editID);
	WORD wLabelID = LOWORD(GetWindowLongPtr(hwndEdit,GWLP_USERDATA));
	HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndDlg,GWLP_HINSTANCE);
	GetDlgItemText(hwndDlg,wLabelID,szAttached,cbBufferSize);
	StripCharFromString(szAttached, szBuffer, _T('&'));
	StripCharFromString(szBuffer, szAttached, _T(':'));
}



void CRegWizard::ConfigureEditTextField(HWND hwndDlg,int editFieldID,ADDRSPEC_FIELD addrSpecField,int iAttachedStrID)
/*********************************************************************
Sets the maximum character limit and "required?" status for the edit
field whose ID is given by the editFieldID parameter.  The
addrSpecField parameter specifies which field within the AddrSpec
(as defined by the currently selected country) to use to determine
the char limit and "required?" values.

If the text currently residing in the edit control is longer than
the maximum allowed for that field, ConfigureEditTextField will
truncate it to the allowable value.

Note: the current country code MUST be set via a call to
SetCountryCode before calling ConfigureEditTextField.
**********************************************************************/
{
	MAXLEN maxLen;
	BOOL isRequired;
	DWORD dwTapiCntryId;
	maxLen = 0;
	isRequired = FALSE;
	dwTapiCntryId = gTapiCountryTable.GetTapiIDForTheCountryIndex(m_countryCode);
	//GetAddrSpecProperties(m_countryCode,addrSpecField,&maxLen,&isRequired);
	GetAddrSpecProperties(dwTapiCntryId,addrSpecField,&maxLen,&isRequired);
	SendDlgItemMessage(hwndDlg,editFieldID,EM_LIMITTEXT,maxLen,0L);
	
	LRESULT dwTextLen = SendDlgItemMessage(hwndDlg,editFieldID,WM_GETTEXTLENGTH,0,0L);
	if (dwTextLen > (LRESULT) maxLen)
	{
		_TCHAR szText[256];
		SendDlgItemMessage(hwndDlg,editFieldID,WM_GETTEXT,255,(LPARAM) szText);
		szText[maxLen] = NULL;
		SendDlgItemMessage(hwndDlg,editFieldID,WM_SETTEXT,0,(LPARAM) szText);
	}

	HWND hwndEdit = GetDlgItem(hwndDlg,editFieldID);
	LONG_PTR lWindowLong = (isRequired << 16) | iAttachedStrID;
	SetWindowLongPtr(hwndEdit,GWLP_USERDATA,(LONG_PTR)lWindowLong);
}



void CRegWizard::BuildAddrSpecTables( void )
/*********************************************************************
Builds country code-dependent name/address specification table (by
reading and parsing the specification strings for each country from
string resources.
**********************************************************************/
{
	// Build country-code dependent address spec tables
	LONG lMaxCntryCode = GetResNumber(m_hInstance,IDS_CNTRY_MAXCODE);
	m_addrJumpTable = GlobalAlloc(GHND, sizeof(JTE) * (lMaxCntryCode + 1));
	JTE* addrJumpTable = (JTE*) GlobalLock(m_addrJumpTable);

	LONG lUniqueCount = GetResNumber(m_hInstance,IDS_CNTRY_UNIQUECOUNT);
	m_addrSpecTable = GlobalAlloc(GHND, sizeof(ADDRSPEC) * (lUniqueCount + 1));
	ADDRSPEC* addrSpecTable = (ADDRSPEC*) GlobalLock(m_addrSpecTable);

	LONG lSpecTableIndex = 0;
	int iStrResID = IDS_CNTRY_DEFAULT;
	while (iStrResID < IDS_CNTRY_END && lSpecTableIndex < kMaxAddrSpecTableSize)
	{
		_TCHAR szSpecString[64];
		int iStrLen = LoadString(m_hInstance,iStrResID,szSpecString,64);
		// Gaps are allowable in the string resource ID numbering, so watch out.
		if (iStrLen > 0)
		{						
			LPTSTR szSpecPtr = szSpecString;
			LPTSTR szNext;						
			long lCntryCode = _tcstol(szSpecPtr,&szNext,10);
			if (lCntryCode < lMaxCntryCode && lCntryCode >= 0 && szNext[0] == _T(':'))
			{
				//szSpecPtr += _tcsclen(szNext + 1);
				szSpecPtr = szNext + 1;
				LONG lInterTableReference = _tcstol(szSpecPtr,&szNext,10);
				if (szNext[0] == NULL || szNext[0] == _T(' '))
				{
					addrJumpTable[lCntryCode] = addrJumpTable[lInterTableReference];
				}
				else
				{
					addrJumpTable[lCntryCode] = (JTE) lSpecTableIndex;
					WORD wSpecIndex = 0;
					do
					{
						LONG lMaxLen = _tcstol(szSpecPtr,&szNext,10);

						// A missing 'y' or 'n' specifier is considered a
						// syntax error, and we'll stop processing that line.
						if (szNext[0] == _T('y') || szNext[0] == _T('n'))
						{
							if (lMaxLen > kMaxLenSize) lMaxLen = kMaxLenSize;
							if (szNext[0] == _T('n')) lMaxLen *= -1;
							addrSpecTable[lSpecTableIndex].maxLen[wSpecIndex++] = (MAXLEN) lMaxLen;
							szSpecPtr = szNext + 1;
						}
						else
						{
							szSpecPtr = NULL;
						}
					}while (szSpecPtr && szSpecPtr[0] && wSpecIndex < kAddrSpecCount);
					lSpecTableIndex++;
				}
			}
		}
		iStrResID++;	
	}
	GlobalUnlock(m_addrJumpTable);
	GlobalUnlock(m_addrSpecTable);
}


void CRegWizard::ResolveCurrentCountryCode( void )
/*********************************************************************
If the user has run RegWizard previously, we'll use the last selection
as the current country code.  Otherwise, we'll ask Tapi for the
current system country code.
**********************************************************************/
{
	_TCHAR szCountry[kRegBufferSize];
	DWORD dwCountryCode=0;
		
	if( GetInformationString(kInfoCountry,szCountry) )
	{
		dwCountryCode = _ttol(szCountry);
	}
	else
	{
		// Get TAPI Country Code
		if (GetTapiCurrentCountry(m_hInstance,&dwCountryCode)){
			RW_DEBUG << "\n TAPI Country Code :[" << dwCountryCode << flush;
				

			dwCountryCode= gTapiCountryTable.GetCountryCode(dwCountryCode);
			RW_DEBUG << "]=Mapping Index : " << dwCountryCode << flush;
		}else {
			dwCountryCode = 0; // Fore it to USA

		}
	}
	SetCountryCode(dwCountryCode);
}


void CRegWizard::SetLogFileName(LPTSTR lpszLogFilePath)
/*********************************************************************
If this function is called with a valid full pathname to a file,
CRegWizard will write all registration information, as text, to this
file, in addition to writing it to the Registration Database.
**********************************************************************/
{
	_tcscpy(m_szLogFilePath,lpszLogFilePath);
}


void CRegWizard::CreateLogFile( void )
/**********************************************************************
This function attempts to create a logfile into which all pertinent
registration information will be dumped, if that file has not been
created already (by a previous call to CreateLogFile).

Note: CreateLogFile is called automatically by WriteToLogFile if the
log file does not exist, so you don't need to call CreateLogFile first.
***********************************************************************/
{
	if (m_szLogFilePath[0] && m_hLogFile == INVALID_HANDLE_VALUE)
	{
		m_hLogFile = CreateFile(m_szLogFilePath,GENERIC_WRITE,FILE_SHARE_READ,NULL,CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL,NULL);
	}
}


void CRegWizard::WriteToLogFile(LPTSTR lpszLine)
/**********************************************************************
This function first checks to see if registration logging has been
enabled (via a call to SetLogFileName), and if so, writes the given
line to the designated log file.

Note: WriteToLogFile automatically appends CR/LF to the given string.

Note: If the log file does not yet exist, WriteToLogFile will create
it automatically.
***********************************************************************/
{
	#define chEol	_T('\n')
	#define chCR	_T('\r')

	if (m_hLogFile == INVALID_HANDLE_VALUE)
	{
		CreateLogFile();
	}
	
	if (m_hLogFile != INVALID_HANDLE_VALUE)
	{
		DWORD dwBytesWritten;
		DWORD wLen = _tcslen(lpszLine);
		lpszLine[wLen]   = chCR;
		lpszLine[wLen + 1] = chEol;
		lpszLine[wLen + 2] = NULL;
		WriteFile(m_hLogFile,lpszLine, _tcslen(lpszLine)* sizeof(_TCHAR),&dwBytesWritten,NULL);
	}		
}


void CRegWizard::CloseLogFile( void )
/**********************************************************************
If the RegWizard log file is open, this function closes it.
***********************************************************************/
{
	if (m_hLogFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(m_hLogFile);
	}
}


HWND CRegWizard::GetCurrDialog(void )
{
	return m_hwndCurrDialog;
}

void CRegWizard::SetDialogHide(HWND hDialogToHide)
{
	m_hwndDialogToHide = hDialogToHide;
}

BOOL CRegWizard::ShowPrevDialog(void)
{
	if(m_hwndPrevDialog != NULL)
	{
		RECT r;
		HWND hwndTmpDialog;
		GetWindowRect(m_hwndDialogToHide, &r);
		SetWindowPos(m_hwndPrevDialog, NULL, r.left, r.top,0,0,SWP_NOSIZE|SWP_NOZORDER);
		ShowWindow(m_hwndDialogToHide,SW_HIDE);
		m_hwndDialogToHide = NULL;
		hwndTmpDialog = m_hwndCurrDialog;
		m_hwndCurrDialog = m_hwndPrevDialog;
		m_hwndPrevDialog = hwndTmpDialog;
		
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

void CRegWizard::SetWindowCaption(LPTSTR lpszWindowsCaption)
{
	_TCHAR szTitle[64];
	LoadString(m_hInstance,IDS_WINDOWS_CAPTION,szTitle,64);
	_tcscpy(m_szWindowsCaption,lpszWindowsCaption);
	_tcscat(m_szWindowsCaption,szTitle);
}


LPTSTR CRegWizard::GetWindowCaption(void)
{
	return m_szWindowsCaption;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\cstattxt.cpp ===
/*********************************************************************
Registration Wizard
Class: CStaticText

--- This class subclasses a Window control to create a custom static 
text control.

11/14/94 - Tracy Ferrier
04/15/97 - Modified to take care of crashing in Memphis as the default destoy was not handled 

(c) 1994-95 Microsoft Corporation
**********************************************************************/
#include <Windows.h>
#include <stdio.h>
#include "cstattxt.h"
#include "Resource.h"

LRESULT PASCAL StaticTextWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

CStaticText::CStaticText(HINSTANCE hInstance, HWND hwndDlg,int idControl,int idString1,int idString2)
/*********************************************************************
Constructor for our CStaticText class.  
**********************************************************************/
{
	m_hInstance = hInstance;
	m_szText = LoadExtendedString(hInstance,idString1,idString2);

	HWND hwndCtl = GetDlgItem(hwndDlg,idControl);
	m_lpfnOrigWndProc = (FARPROC) GetWindowLongPtr(hwndCtl,GWLP_WNDPROC);
	SetWindowLongPtr(hwndCtl,GWLP_WNDPROC,(LONG_PTR) StaticTextWndProc);
	SetWindowLongPtr(hwndCtl,GWLP_USERDATA,(LONG_PTR) this);

	HFONT hfont = (HFONT)SendMessage(hwndDlg, WM_GETFONT, 0, 0L);
	if (hfont != NULL)
	{
		LOGFONT lFont;
		if (!GetObject(hfont, sizeof(LOGFONT), (LPTSTR)&lFont))
		{
			m_hFont = NULL;
		}
		else
		{
			lFont.lfWeight = FW_NORMAL;
			hfont = CreateFontIndirect((LPLOGFONT)&lFont);
			if (hfont != NULL)
			{
				m_hFont = hfont;
			}
		}
	}

}


CStaticText::~CStaticText()
/*********************************************************************
Destructor for our CStaticText class
**********************************************************************/
{
	if (m_szText) GlobalFree(m_szText);
	if (m_hFont) DeleteObject(m_hFont);
}


LPTSTR CStaticText::LoadExtendedString(HINSTANCE hInstance,int idString1,int idString2)
/*********************************************************************
This function builds a single string out of the string resources whose 
ID's are given by the idString1 and idString2 parameters (if the
idString2 parameter is given as NULL, only the string resource 
specified by idString1 will be used.  LoadExtendedString allocates
space for the extended string on the heap, and returns a pointer to
it as the function result.
**********************************************************************/
{
	_TCHAR szTextBuffer[512];
	int resSize = LoadString(hInstance,idString1,szTextBuffer,255);
	if (idString2 != NULL)
	{
		_TCHAR szTextBuffer2[256];
		resSize = LoadString(hInstance,idString2,szTextBuffer2,255);
		_tcscat(szTextBuffer,szTextBuffer2);
	}
	HGLOBAL szReturnBuffer = GlobalAlloc(LMEM_FIXED,(_tcslen(szTextBuffer) + 1)* sizeof(_TCHAR));
	_tcscpy((LPTSTR) szReturnBuffer,szTextBuffer);
	return (LPTSTR) szReturnBuffer;
}


LRESULT PASCAL CStaticText::CtlWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
/*********************************************************************
**********************************************************************/
{
	switch (message)
	{
		case WM_PAINT:
		{
			PAINTSTRUCT ps;
			RECT wndRect;
			GetClientRect(hwnd,&wndRect);
			HDC hdc = BeginPaint(hwnd,&ps);
			SelectObject(hdc,m_hFont);
			SetBkMode(hdc,TRANSPARENT);
			DrawText(hdc,m_szText,-1,&wndRect,DT_LEFT | DT_WORDBREAK);
			EndPaint(hwnd,&ps);
			break;
		}
		case WM_GETTEXT:
		{
			LPTSTR szBuffer = (LPTSTR) lParam;
			WPARAM userBufferSize = wParam;
			_tcsncpy(szBuffer,m_szText,(size_t)userBufferSize);
			break;
		}
		case WM_SETTEXT:
		{
			if (m_szText) GlobalFree(m_szText);
			LPTSTR szBuffer = (LPTSTR) lParam;
			m_szText = (LPTSTR) GlobalAlloc(LMEM_FIXED,(_tcslen(szBuffer) + 1)* sizeof(_TCHAR));
			_tcscpy(m_szText,szBuffer);
			break;
		}
	
		case WM_DESTROY:
			SetWindowLongPtr(hwnd,GWLP_WNDPROC,(LONG_PTR) m_lpfnOrigWndProc);

		default:
#ifdef _WIN95
		return CallWindowProc(m_lpfnOrigWndProc,hwnd,message,wParam,lParam);
#else
		return CallWindowProc((WNDPROC) m_lpfnOrigWndProc,hwnd,message,wParam,lParam);
#endif

			break;
	}
	return 0;
}


LRESULT PASCAL StaticTextWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
/*********************************************************************
**********************************************************************/
{
	CStaticText* pclStaticText = (CStaticText*) GetWindowLongPtr(hwnd,GWLP_USERDATA);
	LRESULT lret;
	switch (message)
	{
		case WM_DESTROY:
			lret = pclStaticText->CtlWndProc(hwnd,message,wParam,lParam);

			delete pclStaticText;
			return lret;
		default:
			return pclStaticText->CtlWndProc(hwnd,message,wParam,lParam);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\exitdlg.cpp ===
/*********************************************************************
Registration Wizard

exitdlg.cpp
10/13/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
Modification History:
	MXX1 
	Date :02/17/99: 
	By   :SK 
	Change Request :Cancel Dialog should not be displayed
	Function : CancelRegWizard()

**********************************************************************/

#include <Windows.h>
#include "Resource.h"
#include "regutil.h"
#include <stdio.h>

static INT_PTR CALLBACK ExitDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern _TCHAR szWindowsCaption[256];

INT_PTR CancelRegWizard(HINSTANCE hInstance,HWND hwndParentDlg)
/*********************************************************************
Returns TRUE if the user confirms that RegWizard should be canceled.
**********************************************************************/
{
//	HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndParentDlg,GWLP_HINSTANCE);
	
	// MXX1  --- Start
	//NT_PTR hitButton = DialogBox(hInstance,MAKEINTRESOURCE(IDD_CANCEL),hwndParentDlg, ExitDialogProc);
	//return hitButton == IDB_YES ? TRUE : FALSE;
	
	// MXX1  --- Finish

	// MXX1  --- Start
	return TRUE;
	// MXX1  --- Finish
}


INT_PTR CALLBACK ExitDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
/*********************************************************************
Proc for dialog displayed when the user hits the 'cancel' button
**********************************************************************/
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
		{
			RECT parentRect,dlgRect;
			HWND hwndParent = GetParent(hwndDlg);

			GetWindowRect(hwndParent,&parentRect);
			GetWindowRect(hwndDlg,&dlgRect);
			int newX = parentRect.left + (parentRect.right - parentRect.left)/2 - (dlgRect.right - dlgRect.left)/2;
			int newY = parentRect.top + (parentRect.bottom - parentRect.top)/2 - (dlgRect.bottom - dlgRect.top)/2;
			MoveWindow(hwndDlg,newX,newY,dlgRect.right - dlgRect.left,dlgRect.bottom - dlgRect.top,FALSE);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT2);
			
			SetWindowText(hwndDlg,szWindowsCaption);


            return TRUE;
		}
        case WM_COMMAND:
            switch (wParam)
            {
                case IDB_YES:
				case IDB_NO:
					EndDialog(hwndDlg,wParam);
					break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\dialscr.cpp ===
/*
	File : DialScr.cpp
	Dialup Screen for RegWiz using Wizard 97 control

	02/13/98  Suresh Krishnan
	Modifications :
	Date 5/27/98 : Suresh

	DisplayPhoneNumber() was displaying  junk if countries do not have area code
	This is because the TAPI  call was failing because of the format represented in canonical form .
	Presently if are code is NULL then,  araecode is ignored in canonical form.
	


*/

#include <Windows.h>
#include "RegPage.h"
#include <stdio.h>
#include "ATK_RAS.h"

#include <tchar.h>
#include "resource.h"
#include "RegWizMain.h"
#include "dialogs.h"
#include <sudefs.h>
#include "rw_common.h"
#include "rwpost.h"
#include "regutil.h"
#include "mcm.h"

extern BOOL bPostSuccessful;

static  RASENTRY	 theRasEntry;
static  TCHAR szIspUserName[256];   // Temporary ISP Acoount Name
static  TCHAR szIspUserPassword[256]; // temp ISP Account Password

#define  MSN_SITE_DUN  _T("REGWIZ")

void  DialingProperties (HINSTANCE hIns, HWND hParent); //

DWORD ConfigureDUN ( HWND hWnd, HINSTANCE hInstance,
					 RASENTRY	*pRasEntry,
					 TCHAR		*szUserName,
					 TCHAR		*szPassword,
					 int    iModemIndex);

//
//  Global Variables
static HINSTANCE	m_hInstance;
static HWND			m_hWnd;
static HANDLE		m_hThread;
static HANDLE		hRasNotifyEvt;
static HANDLE		hRasKillEvt;
static HRASCONN		hRasConn;
static int siExitThread = 0;   // Set if the USer wants to Terminate
static DWORD    dwRasError = 0; // To Store Ras reported Error
static  int siPreviousRasState = RASCS_OpenPort;
static  int siCurrentRasState  = RASCS_OpenPort;

static DWORD DialThread(PVOID pData);  // the thread fun used for RAS connection
static void  RasDialFunc( UINT unMsg, RASCONNSTATE rasconnstate, DWORD dwError );
class  DialupHelperClass {
public :
	DialupHelperClass(HINSTANCE hIns, HWND hWnd);
	~DialupHelperClass();
	BOOL InvokeDialupSettings();
	BOOL CheckForDialingProperties();
    BOOL DisplayPhoneNumber();

	DWORD	CreateRasDialThread();
	BOOL	WaitForRasThread( HANDLE	hThread, BOOL fTimeOut);
	void	InitForStaticFunction( HINSTANCE hIns, HWND hWnd);
	void	DestroyRasThread(BOOL bRetry);

};


//
//  FUNCTION: GetRasConnState( RASCONNSTATE )
//
//  PURPOSE: get the index to the corresponding string
//
//  PARAMETERS:
//    rasconn - ras connection state
//
//  RETURN VALUE:
//    index into stringtable.
//
//  COMMENTS:
//
UINT GetRasConnState( RASCONNSTATE rasconn )
{
	

    switch( rasconn )
    {
        case RASCS_OpenPort:
            return IDS_OPENPORT;
        case RASCS_PortOpened:
            return IDS_PORTOPENED;
        case RASCS_ConnectDevice:
            return IDS_CONNECTDEVICE;
        case RASCS_DeviceConnected:
            return IDS_DEVICECONNECTED;
        case RASCS_AllDevicesConnected:
            return IDS_ALLDEVICESCONNECTED;
        case RASCS_Authenticate:
            return IDS_AUTHENTICATE;
        case RASCS_AuthNotify:
            return IDS_AUTHNOTIFY;
        case RASCS_AuthRetry:
            return IDS_AUTHRETRY;
        case RASCS_AuthCallback:
            return IDS_AUTHCALLBACK;
        case RASCS_AuthChangePassword:
            return IDS_AUTHCHANGEPASSWORD;
        case RASCS_AuthProject:
            return IDS_AUTHPROJECT;
        case RASCS_AuthLinkSpeed:
            return IDS_AUTHLINKSPEED;
        case RASCS_AuthAck:
            return IDS_AUTHACK;
        case RASCS_ReAuthenticate:
            return IDS_REAUTHENTICATE;
        case RASCS_Authenticated:
            return IDS_AUTHENTICATED;
        case RASCS_PrepareForCallback:
            return IDS_PREPAREFORCALLBACK;
        case RASCS_WaitForModemReset:
            return IDS_WAITFORMODEMRESET;
        case RASCS_WaitForCallback:
            return IDS_WAITFORCALLBACK;
        case RASCS_Interactive:
            return IDS_INTERACTIVE;
        case RASCS_RetryAuthentication:
            return IDS_RETRYAUTHENTICATION;
        case RASCS_CallbackSetByCaller:
            return IDS_CALLBACKSETBYCALLER;
        case RASCS_PasswordExpired:
            return IDS_PASSWORDEXPIRED;
        case RASCS_Connected:
            return IDS_CONNECTED;
        case RASCS_Disconnected:
            return IDS_DISCONNECTED;
        default:
            return IDS_RAS_UNDEFINED_ERROR;
    }
}


//
//  This function Enable or Disables the Controls of Wizard 97 control
//  Cancel, Back, Next buttons
//  the hDlg passed is the child of the Wizard control. So we use
//  GetParent to get the handle of Wizard control
//
BOOL RW_EnableWizControl(
					HWND hDlg,
					int	 idControl,
					BOOL fEnable
					)
{
	if (hDlg ==NULL ){
		return FALSE;
	}

	HWND hWnd = GetDlgItem(GetParent( hDlg),idControl);
	if (hWnd){
		EnableWindow(hWnd,fEnable);
	}
	return TRUE;

}



BOOL FEnableControl(
					HWND hDlg,
					int	 idControl,
					BOOL fEnable
					)
{
	if (NULL == hDlg)
	{
		//AssertSz(0,"Null Param");
		return FALSE;
	}

	HWND hWnd = GetDlgItem(hDlg,idControl);
	if (hWnd)
	{
		EnableWindow(hWnd,fEnable);
	}
	return TRUE;
}





DialupHelperClass :: DialupHelperClass( HINSTANCE hIns, HWND hWnd)
{
	m_hInstance = hIns;
	m_hWnd = hWnd;
	hRasNotifyEvt = NULL;
	hRasKillEvt = NULL;
	m_hThread = NULL;
	hRasConn = NULL;

}

DialupHelperClass :: ~DialupHelperClass()
{

}

//
// This function invokes Telephoney Settings of the control Panel
//

BOOL DialupHelperClass :: InvokeDialupSettings()
{	
/*********************************************************************
This function puts up the "Telephon properties " control panel, and
returns only when the user has dismissed the dialog (either after
installing a new modem, or canceling).
Returns: FALSE if an error prevented the dialog from being displayed.
**********************************************************************/

	_TCHAR 				szCmdLine[128];
	STARTUPINFO 		si;
	PROCESS_INFORMATION pi;
	BOOL 				fControlProcessDone = FALSE;
	BOOL 				fProcessStatus;
	//HWND				hwndProcess;
	

	LoadString(m_hInstance ,IDS_DIALINGPROPERTIES,szCmdLine,128);

	si.cb = sizeof(STARTUPINFO);
	si.lpReserved = NULL;
	si.lpDesktop = NULL;
	si.lpTitle = NULL;
	si.dwFlags = 0L;
	si.cbReserved2 = 0;
	si.lpReserved2 = NULL;

	fProcessStatus = CreateProcess(NULL,szCmdLine,NULL,NULL,FALSE,
		CREATE_DEFAULT_ERROR_MODE | CREATE_NEW_PROCESS_GROUP | NORMAL_PRIORITY_CLASS,NULL,NULL,&si,&pi);
	if (fProcessStatus == FALSE)
	{
		return FALSE;
	}
	else
	{
		CloseHandle(pi.hThread);

		DWORD dwRet;
		dwRet = WaitForSingleObject(pi.hProcess, INFINITE);
		switch(dwRet) {
		case WAIT_ABANDONED :
			break;
		case WAIT_OBJECT_0:
			break;
		case WAIT_TIMEOUT:
			break;
		case WAIT_FAILED:
			DWORD dwLastError;
			dwLastError = GetLastError();
			break;
		default :
			break;
		}
	
	}
	CloseHandle(pi.hProcess);
	return TRUE;
}

//Cancel..
void DialupHelperClass :: DestroyRasThread(BOOL bRetry)
{
	
	if(!bRetry)
	{
		siExitThread  = 1;
		if(hRasNotifyEvt)
		{
			SetEvent (hRasNotifyEvt);
		}
	
		if(m_hThread)
		WaitForSingleObject(m_hThread, INFINITE);
	}

	if( hRasConn != NULL )
	{
		int i =0;
		DWORD dwConnectStatus = 0;
		DWORD dwHangupRet =0;
		RASCONNSTATUS rasConn;
		rasConn.dwSize = sizeof(RASCONNSTATUS);
		try
		{
		
			RW_DEBUG << "Hanging up the connection" << endl;

			dwHangupRet = ATK_RasHangUp( hRasConn );
			if(!dwHangupRet)
			{
				do
				{
					RW_DEBUG << "chek connection status" << endl;
					dwConnectStatus = ATK_RasGetConnectionStatus(hRasConn,&rasConn) ;
					Sleep(100);
					i++;
				}while ((dwConnectStatus != ERROR_INVALID_HANDLE ) || (i < 200));
			}
			else
			{
				RW_DEBUG << "Hangup result: " << dwHangupRet << endl;
			}

			RW_DEBUG << "connection shot dead" << endl;
			hRasConn = NULL;
		}
		catch(...)
		{
			RW_DEBUG << "Error Caught dwHangupRet:" << dwHangupRet << endl;
			//RW_DEBUG << "hRasConn:" << hRasConn << endl;
		}
	}

	if(!bRetry)
	{
		siExitThread  = 0;
		m_hThread = NULL;
	}

	RW_DEBUG << "Exiting DestroyRasThread" << endl;
	return ;	
}

BOOL DialupHelperClass ::  CheckForDialingProperties()
{
	HKEY    hKey;
	TCHAR   szTel[256] = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations");
	TCHAR   szCI [48] = _T("CurrentID");
	_TCHAR  czLastStr[48];
	_TCHAR  czNewKey[256];
	DWORD   dwCurrentId;

	LONG	lStatus;
	DWORD   dwInfoSize = 48;
	BOOL    bRetValue;
	bRetValue = TRUE;

	LoadString(m_hInstance,IDS_TELEPHONE_LOC,szTel,256);
	LoadString(m_hInstance,IDS_TELEPHONE_CID,szCI,48);

	lStatus= RegOpenKeyEx(HKEY_LOCAL_MACHINE,szTel,0,KEY_READ,&hKey);
	if (lStatus == ERROR_SUCCESS)
	{
		//  Get Index
		//
		dwInfoSize = sizeof(dwCurrentId);
		lStatus = RegQueryValueEx(hKey,szCI,NULL,0,(  LPBYTE )&dwCurrentId,&dwInfoSize);
		if( lStatus !=  ERROR_SUCCESS)
		{
			RegCloseKey(hKey);
			bRetValue = FALSE;
		}
		RegCloseKey(hKey);
	}

	//
	// Now Contine to scan
	//for (int iCount =0; iCount < dwNumEntries; iCount ++ )
		
	_stprintf(czLastStr,_T("\\Location%d"),dwCurrentId);
	_tcscpy(czNewKey,szTel);
	_tcscat(czNewKey,czLastStr);

	lStatus= RegOpenKeyEx(HKEY_LOCAL_MACHINE,czNewKey,0,KEY_READ,&hKey);

	if (lStatus == ERROR_SUCCESS)
	{
			bRetValue = TRUE;
	}
	
	if(!bRetValue)
	{
		_TCHAR szMessage[256];
		LoadString(m_hInstance,IDS_DIALING_MESSAGE,szMessage,256);
		RegWizardMessageEx(m_hInstance,m_hWnd,IDD_INVALID_DLG,szMessage);
		return InvokeDialupSettings();
	}
	return bRetValue;
}

BOOL DialupHelperClass :: DisplayPhoneNumber(void)
{
	HLINEAPP hLineApp;
	_TCHAR szAddressIn[256];
	HWND hCtl;

	DWORD dwAPI,dwDevice,dwAPIHighVersion = 0x30000;
	
    LPLINETRANSLATEOUTPUT lpTranslateOutput;
	
	lpTranslateOutput = (LPLINETRANSLATEOUTPUT)LocalAlloc (LPTR, sizeof(LINETRANSLATEOUTPUT));

    lpTranslateOutput->dwTotalSize = sizeof(LINETRANSLATEOUTPUT);

    if(FGetDeviceID(m_hInstance, &hLineApp, &dwAPI, &dwDevice,0))
	{
		_TCHAR szTemp[256];
	#ifdef _LOG_IN_FILE
		 RW_DEBUG  << "\n After FGetDeviceID" << flush;
	#endif
	
		// Put the number in the canonical form -> +1 (201) 2220577
		
		_itot(theRasEntry.dwCountryCode,szTemp,10);
		_tcscpy(szAddressIn,_T("+"));
		_tcscat(szAddressIn,szTemp);
		if(theRasEntry.szAreaCode[0] == 0 ) {
			_tcscat(szAddressIn,_T(" "));;
		}else {
			_tcscat(szAddressIn,_T(" ("));
			_tcscat(szAddressIn,theRasEntry.szAreaCode);
			_tcscat(szAddressIn,_T(") "));
		}
		
		_tcscat(szAddressIn,theRasEntry.szLocalPhoneNumber);

	#ifdef _LOG_IN_FILE
		 RW_DEBUG  << "\n Device:" <<dwDevice << "Phone number:" <<ConvertToANSIString(szAddressIn)<< flush;
	#endif
	
		long lRet = lineTranslateAddress(hLineApp,dwDevice,dwAPIHighVersion,(LPCTSTR)szAddressIn,0,0,
										lpTranslateOutput);
	
		if(lRet == 0)
		{
			size_t sizeNeeded;
			sizeNeeded = lpTranslateOutput->dwNeededSize;
			
			LocalFree(lpTranslateOutput);


			// Make sure the buffer exists, is valid and big enough.
		    lpTranslateOutput = (LPLINETRANSLATEOUTPUT)LocalAlloc (LPTR,sizeNeeded);
			
			lpTranslateOutput->dwTotalSize = sizeNeeded;

			if (lpTranslateOutput == NULL)
		        return FALSE;


			lRet = lineTranslateAddress(hLineApp,dwDevice,dwAPIHighVersion,(LPCTSTR)szAddressIn,0,0,
										lpTranslateOutput);
			if(lRet == 0)
			{
				_TCHAR szTemp[256] ;
				#ifdef _LOG_IN_FILE
					 RW_DEBUG  << "\n lineTranslateAddress  returns true:" << flush;
				#endif
				
				RW_DEBUG  << "\n dwTotalSize:" << lpTranslateOutput->dwTotalSize<< endl;
				RW_DEBUG  << "\n dwNeededSize:" << lpTranslateOutput->dwNeededSize  << endl;
				RW_DEBUG  << "\n dwUsedSize:" << lpTranslateOutput->dwUsedSize << endl;
				RW_DEBUG  << "\n dwDisplayableStringSize:" << lpTranslateOutput->dwDisplayableStringSize << endl;
				RW_DEBUG  << "\n dwDisplayableStringOffset:" << lpTranslateOutput->dwDisplayableStringOffset << endl;
				RW_DEBUG  << "\n dwDialableStringSize:" << lpTranslateOutput->dwDialableStringSize << endl;
				RW_DEBUG  << "\n dwDialableStringOffset:" << lpTranslateOutput->dwDialableStringOffset << endl;
				RW_DEBUG  << "\n dwDestCountry:" << lpTranslateOutput->dwDestCountry << endl;
				RW_DEBUG  << "\n dwCurrentCountry:" << lpTranslateOutput->dwCurrentCountry << endl;
			
				hCtl = GetDlgItem(m_hWnd,IDC_PHONENUMBER);
				if (hCtl)
				{
					#ifdef _LOG_IN_FILE
					// RW_DEBUG  << "\n Full Phone number:" <<ConvertToANSIString(szTemp)<< flush;
					#endif

					SetWindowText(hCtl,(LPCTSTR)(((LPCSTR)lpTranslateOutput) + lpTranslateOutput->dwDisplayableStringOffset ));

					LocalFree(lpTranslateOutput);

					return TRUE;
				}
				else
				{
					LocalFree(lpTranslateOutput);
				}
			}
		}
		else
		{
			
			#ifdef _LOG_IN_FILE
				 RW_DEBUG  << "\n*Error in  lineTranslateAddress  returned:" << lRet << flush;
			#endif
   		    hCtl = GetDlgItem(m_hWnd,IDC_PHONENUMBER);
			SetWindowText(hCtl,szAddressIn);

		}
	}
	else
	{
		#ifdef _LOG_IN_FILE
			 RW_DEBUG  << "\n FGetDeviceID failed" << flush;
		#endif

	}
	return FALSE;
}




DWORD  DialupHelperClass :: CreateRasDialThread()
{
	DWORD	dwTID;
	DWORD	dwEnd;
		 					
	if (m_hThread)	//if we are already doing this..
	{
		if (STILL_ACTIVE == GetExitCodeThread(m_hThread,&dwEnd)) //pass back the exit code from the thread.
		{
			//AssertSz(0,"Already have a thread dialing..");
			WaitForRasThread(m_hThread,FALSE);			//wait for thread as long as it takes.
		}	
		CloseHandle(m_hThread);
		m_hThread = NULL;
	}
	hRasNotifyEvt = CreateEvent(NULL, FALSE,FALSE,NULL);
	hRasKillEvt   = CreateEvent(NULL, FALSE,FALSE,NULL);

	if(hRasNotifyEvt == NULL ) {
		return DIALFAILED;
	}
    //launch a thread to do dialing.
	m_hThread = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)
		DialThread ,NULL,0,&dwTID);						
	if (NULL == m_hThread)
	{
		
		return DIALFAILED;
	}
		
	return DIALSUCCESS;
	
}



DWORD  DialThread(PVOID pData)
{
    RASDIALPARAMS rdParams;
    DWORD dwRet;
    _TCHAR  szBuf[256];
	int iExit;
	DWORD dwPostRet;
	int iTimeOut;

    // setup RAS Dial Parameters
    rdParams.dwSize = sizeof(RASDIALPARAMS);
    lstrcpy(rdParams.szEntryName,MSN_SITE_DUN);
    rdParams.szPhoneNumber[0] = '\0';
	
	GetDlgItemText(m_hWnd,IDC_PHONENUMBER,rdParams.szPhoneNumber,RAS_MaxPhoneNumber+1);

    rdParams.szCallbackNumber[0] = '*';
    rdParams.szCallbackNumber[1] = '\0';

    //rdParams.szUserName[0] = '\0';
    //rdParams.szPassword[0] = '\0';
	_tcscpy(szIspUserName,_T("RegWizNT30@gn.microsoft.com"));
	_tcscpy(szIspUserPassword,_T("RegSupNT"));

	_tcscpy(rdParams.szUserName,szIspUserName);
	_tcscpy(rdParams.szPassword,szIspUserPassword);
    rdParams.szDomain[0] = '*';
    rdParams.szDomain[1] = '\0';
    hRasConn = NULL;
	#ifdef _LOG_IN_FILE
		 RW_DEBUG  << "\n Before RAS Dial " << flush;
	     RW_DEBUG  << "\n UserName:" << ConvertToANSIString(szIspUserName) << flush;
		 RW_DEBUG  << "\n UserPassword:" << ConvertToANSIString(szIspUserPassword) << flush;
	#endif


    dwRet = ATK_RasDial( NULL, NULL, &rdParams, 0L, (RASDIALFUNC) RasDialFunc, &hRasConn);
		#ifdef _LOG_IN_FILE
			 RW_DEBUG  << "\n After  RAS Dial " << flush;
			
		#endif

    if ( dwRet ){
        if ( ATK_RasGetErrorString( (UINT)dwRet, (LPTSTR)szBuf, 256 ) != 0 )
            wsprintf( (LPTSTR)szBuf, _T("Undefined RAS Dial Error (%ld)."), dwRet );
		LoadString(m_hInstance, IDS_MODEM_ALREADY_INUSE, szBuf, 64 );
		#ifdef _LOG_IN_FILE
			RW_DEBUG  << "\n" << "Undefined Error"  << flush;
		#endif
		SetDlgItemText( m_hWnd, ID_LABELINIT, (LPCTSTR) szBuf );
		PostMessage( m_hWnd, WM_COMMAND,
						(WPARAM) IDEND, RWZ_ERROR_MODEM_IN_USE );
		
        return TRUE;
    }
	iExit = 0;
	iTimeOut = 0;
	do
	{
		dwRet = WaitForSingleObject(hRasNotifyEvt,100);
		switch(dwRet)
		{
		case WAIT_ABANDONED :
			iExit = 1;
			break;
		case WAIT_OBJECT_0:
			break;
		case WAIT_TIMEOUT:
			break;
		default :
			break;
		}
		//
		//  Check if it is necessary to  kill this thread operation
		//
		if( siExitThread  )
		{
			iExit = 1;
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n RAS Thread : User request to Kill The RAS Thread " << dwRasError << flush;
			#endif
		}
		else
		{
			// Check if there is any RAS Error
			if(  dwRasError )
			{
				#ifdef _LOG_IN_FILE
					RW_DEBUG << "\n RAS Thread : Error  " << dwRasError << flush;
				#endif
				iExit = 1;
				PostMessage( m_hWnd, WM_COMMAND,
				(WPARAM) IDD_DIALUP_ERROR, dwRasError );
				dwRasError = 0;

			}
			else
			{
			//
			// Check if RAS Connection is established
				if(siCurrentRasState   == RASCS_Connected )
				{

					#ifdef _LOG_IN_FILE
						RW_DEBUG << "\n RAS Thread : Connected To MSN Site \n Txmit Data  " << flush;
						
					#endif
					iExit =1;
					dwPostRet = SendHTTPData(m_hWnd, m_hInstance);
					#ifdef _LOG_IN_FILE
						RW_DEBUG << "\n RAS Thread : After Posting Data  " << dwPostRet  << flush;
						
					#endif
					PostMessage( m_hWnd, WM_COMMAND,
						(WPARAM) IDEND, dwPostRet );

					//
					// Send Data by HTP Post
					//
				}
			}
		}

	}while(!iExit);
	//
	//  Action  to be done while exiting the Thread
	//

	if(hRasNotifyEvt)
	{
		CloseHandle(hRasNotifyEvt); // CLose The Event Object
	}

	#ifdef _LOG_IN_FILE
		 RW_DEBUG  << "\n Before  Exiting RAS Dial Thread " << flush;
	#endif

    return TRUE;
}

VOID  RasDialFunc( UINT unMsg, RASCONNSTATE rasconnstate, DWORD dwError )
{

    _TCHAR szMessage[256];
	
	DWORD dwRet = WaitForSingleObject(hRasKillEvt,3);
	// We Were killed Hangup
	if(dwRet ==  WAIT_OBJECT_0)
	{
		if(hRasConn != NULL)
		{
			ATK_RasHangUp( hRasConn );
			RW_DEBUG << "Hanging up in RasDialFunc" << endl;
		}
		else
		{
			RW_DEBUG << "Tried Hanging up in RasDialFunc but hRasConn is NULL" << endl;
		}

		if(hRasKillEvt)
		{
			CloseHandle(hRasKillEvt); // CLose The Event Object
		}
		return;
	}

    LoadString(m_hInstance, GetRasConnState( (RASCONNSTATE) rasconnstate), szMessage, 64 );
	//SetWindowText(m_hDlg,(LPCTSTR) szMessage);
	RW_DEBUG  << "\n" << ConvertToANSIString(szMessage) << flush;
    SetDlgItemText( m_hWnd, ID_LABELINIT, (LPCTSTR) szMessage );
	
    if (dwError)  // error occurred


    {
        if ( ATK_RasGetErrorString( (UINT)dwError, szMessage, 256 ) != 0 )
            wsprintf( (LPTSTR)szMessage, _T("Undefined RAS Dial Error.") );

        RW_DEBUG  << "\n Exiting with Error " << ConvertToANSIString(szMessage);
		
		if( dwError == ERROR_USER_DISCONNECTION )
			return;
		dwRasError  = dwError; // Set The Error


        //PostMessage( m_hDlg, WM_COMMAND, (WPARAM) IDD_DIALUP_ERROR, dwError );

    }
    else if ( RASCS_DONE & rasconnstate)
    {
		RW_DEBUG  << "\n" << " RACS_DONE .... " ;
		
        //EndDialog(m_hDlg, TRUE);          // Exit the dialog
    }
    siPreviousRasState = siCurrentRasState ;
	siCurrentRasState  = rasconnstate;
	if( hRasNotifyEvt) {
		// Set The Event So the RAS Processing Thread can wake up
		SetEvent(hRasNotifyEvt);
	}
	

    return ;

}


BOOL DialupHelperClass :: WaitForRasThread(
					HANDLE	hThread,
					BOOL fTimeOut
					)
{
	BOOL 	fRet = TRUE;

	if (hThread){
		DWORD dwRet=WAIT_TIMEOUT;
		if (WAIT_TIMEOUT == dwRet){
			TerminateThread(hThread,0);
			fRet = FALSE;
		}
	}
	return fRet;
}





INT_PTR CALLBACK DialupScreenProc(HWND hwndDlg,
					  UINT uMsg, WPARAM wParam, LPARAM lParam)
/*********************************************************************
Main entry point for the Registration Wizard.
**********************************************************************/
{
	CRegWizard*    pclRegWizard = NULL;
	DialupHelperClass  *pDH;
	int    iMsgId;
	static int iRetry =0;
	static BOOL bIsPhoneBookCreated = TRUE;
	static int    iModemIndex=1; // Index of the Modem
	INT_PTR iRet;
	_TCHAR szInfo[256];
	_TCHAR szMessage[256];	

	
	BOOL bStatus = TRUE;
	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
		pDH          = pi->pDialupHelper;
	};

    switch (uMsg)
    {
				
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;				
        case WM_INITDIALOG:
		{
			_TCHAR szInfo[256];
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pclRegWizard = pi->pclRegWizard;
			
			if(pi->pDialupHelper ==  NULL ) {
					pi->pDialupHelper = new DialupHelperClass(pi->hInstance,
										hwndDlg);
			}
			pDH   = pi->pDialupHelper;



			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);

			//UpgradeDlg(hwndDlg);
			
			NormalizeDlgItemFont(hwndDlg,IDC_TITLE,RWZ_MAKE_BOLD);
			NormalizeDlgItemFont(hwndDlg,IDC_SUBTITLE);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);
			
			pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szInfo);
			ReplaceDialogText(hwndDlg,ID_LABELCALLONE,szInfo);
			SetDlgItemText( hwndDlg, IDC_PHONENUMBER, (LPCTSTR) "1 800 795 5675");
			SetWindowText(hwndDlg,pclRegWizard->GetWindowCaption());
			FEnableControl(hwndDlg,IDC_DISCONNECT,FALSE);
			return TRUE;
		}// WM_INIT
		break;
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
				

				pi->ErrorPage  = kDialupDialog;
				pi->iError     = RWZ_NOERROR;
				
				bPostSuccessful = TRUE;
				//
				// Check if RAS is installed
				if( ATK_IsRasDllOk() != RAS_DLL_LOADED ) {
				//
				// Error as no RAS DLL
					pi->iError     = RWZ_ERROR_RASDLL_NOTFOUND;
					bPostSuccessful = FALSE;
				
				}else
				{
				// Check if Telephoney is configured
					pDH->CheckForDialingProperties( );
					if(!ConfigureDUN(hwndDlg,
						pi->hInstance,
						&theRasEntry,
						szIspUserName,szIspUserPassword,
						iModemIndex) )
					{
						pi->iError  = RWZ_ERROR_LOCATING_DUN_FILES;
						bPostSuccessful = FALSE;
						#ifdef _LOG_IN_FILE
							RW_DEBUG  << "\n ConfigureDUN PostUnSuccessful" << flush;
						#endif

					}
					else
					{
						
						#ifdef _LOG_IN_FILE
							RW_DEBUG  << "\n ConfigureDUN Successful" << flush;
						#endif
					}
				}
				
				 iRetry = 1;
				//  Check for Errors
				if(pi->iError) {
					pi->iCancelledByUser = RWZ_ABORT_TOFINISH;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);
				}else {
					bIsPhoneBookCreated = TRUE;	
					pDH->DisplayPhoneNumber();
					//PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK PSWIZB_NEXT );
					pi->iCancelledByUser = RWZ_PAGE_OK;
					PropSheet_SetWizButtons( GetParent( hwndDlg ), 0);
				}
            break;

			case PSN_KILLACTIVE :
				if(pi->pDialupHelper) {
					delete pi->pDialupHelper;
					
				}
				pi->pDialupHelper = NULL;
			break;

            case PSN_WIZNEXT:
				iRet=0;
									//
				// Delete any RAS Connection

				pDH->DestroyRasThread(FALSE);

				ATK_RasDeleteEntry(NULL,MSN_SITE_DUN);

				if(pi->iCancelledByUser  == RWZ_CANCELLED_BY_USER  ||
					pi->iCancelledByUser == RWZ_ABORT_TOFINISH)
				{
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);
				}else {
					pi->CurrentPage++;	
				}
			
				break;

            case PSN_WIZBACK:
                pi->CurrentPage--;

                break;
			case PSN_QUERYCANCEL :
				iRet=0;
				
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet = 1;
					pi->ErrorPage  = kDialupDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					bPostSuccessful = FALSE;

					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (LONG_PTR) iRet);
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);


				}else {
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;

				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet);
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        }
        break;
		case WM_COMMAND:
			switch (LOWORD(wParam)){
			case IDDIAL :
					 RW_DEBUG  << "\n IN IDDIAL ....." << flush;
					//
					//

					if(!bIsPhoneBookCreated){
						// Go To the Next Modem
						iModemIndex ++;
						iRetry = 1;
						if(!ConfigureDUN(hwndDlg,
							pi->hInstance,
							&theRasEntry,
							szIspUserName,szIspUserPassword,
							iModemIndex) )
						{
								pi->iError  = RWZ_ERROR_MODEM_CFG_ERROR;
								pi->iCancelledByUser = RWZ_ABORT_TOFINISH;
								bPostSuccessful = FALSE;
								#ifdef _LOG_IN_FILE
									RW_DEBUG  << "\n ConfigureDUN PostUnSuccessful" << flush;
								#endif
								goto PrepareForExit;							
						}
						else
						{
							#ifdef _LOG_IN_FILE
								RW_DEBUG  << "\n ConfigureDUN Successful" << flush;
								RW_DEBUG  << "\n Phone number:" <<ConvertToANSIString(theRasEntry.szAreaCode)<<ConvertToANSIString(theRasEntry.szLocalPhoneNumber)<< flush;
							#endif
						}

						
						pDH->DisplayPhoneNumber();
#ifdef _DISPLAY_MODEM_NAME
						SetDlgItemText( m_hDlg, IDC_MODEM_NAME, (LPCTSTR) theRasEntry.szDeviceName );
#endif
					}
					bIsPhoneBookCreated = TRUE;
					FEnableControl(hwndDlg,IDDIAL,FALSE);
					FEnableControl(hwndDlg,IDC_DISCONNECT,TRUE);
					//FEnableControl(hwndDlg,ID_BTNSETTINGS,FALSE);
					pi->ErrorPage  = kDialupDialog;
					pi->iError     =  0; // Dialup Errors
					bPostSuccessful = TRUE;

					if (pDH->CreateRasDialThread() == DIALFAILED ){
						pi->iError = RWZ_ERROR_SYSTEMERROR;
						bPostSuccessful = FALSE;
						goto  PrepareForExit;
							
					}
					goto CoolExit;
		 	 	
PrepareForExit :
					pi->iCancelledByUser = RWZ_ABORT_TOFINISH;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);

CoolExit:			
                FEnableControl(hwndDlg,IDC_DISCONNECT,TRUE);

				break;
			case  IDC_DISCONNECT:
				FEnableControl(hwndDlg,IDC_DISCONNECT,FALSE);
				
				SetDlgItemText(hwndDlg, ID_LABELINIT, (LPCTSTR) _T("Disconnecting device"));
				
				SetEvent(hRasKillEvt);

				pDH->DestroyRasThread(FALSE);
				Sleep(1000);
				// Retry
				pDH->DestroyRasThread(TRUE);
				Sleep(3000);
				
				//RW_DEBUG  << "RasConnection: " << hRasConn <<endl;

				hRasConn = NULL;
				FEnableControl(hwndDlg,IDDIAL,TRUE);
				SetDlgItemText(hwndDlg, ID_LABELINIT, (LPCTSTR) _T("  "));
				break;
			case IDEND: // This Message is sent Afetr Posting
					if (m_hThread){
						CloseHandle(m_hThread);
						m_hThread = NULL;
					}
					pi->iError = lParam;
					if(pi->iError == RWZ_POST_SUCCESS)
					{
						bPostSuccessful = TRUE;
						pi->iCancelledByUser = RWZ_PAGE_OK;
						RW_DEBUG  << "\n Post Successful" << flush;
					}
					else
					{
						bPostSuccessful = FALSE;
						pi->iCancelledByUser = RWZ_ABORT_TOFINISH;
						RW_DEBUG  << "\n Post UNSuccessful" << flush;
					}
					
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);
			break;

			case IDD_DIALUP_ERROR :
				iMsgId = IDS_MODEM_NODIALTONE;
				RW_DEBUG << "\n IN IDS_DIALUP_ERROR " << (ULONG)lParam << flush;
				switch( lParam ) {
					case ERROR_NO_DIALTONE :
						iMsgId = IDS_MODEM_NODIALTONE;
						goto CntPrcs;
					case ERROR_NO_ANSWER   :
					
						iMsgId = IDS_MODEM_NOANSWER;
						 goto CntPrcs;
	      	            case ERROR_PORT_OR_DEVICE : // 692
					case ERROR_HARDWARE_FAILURE :
					case ERROR_DISCONNECTION : // 628
					case ERROR_FROM_DEVICE  :  // 651 :
						iMsgId = IDS_HARDWARE_FAILURE;
CntPrcs :				pDH->DestroyRasThread(FALSE);
						pDH->DestroyRasThread(TRUE);
						if( iRetry > 3 ){
							 RW_DEBUG  << "\n Automatic  Switch ...." << flush;

							pDH->DestroyRasThread(FALSE);
							bIsPhoneBookCreated = FALSE;
							PostMessage( hwndDlg, WM_COMMAND, (WPARAM) IDDIAL,0 );
							goto LReturn;
						}
						
						if(iRetry++ > 0){
						
							LoadString(m_hInstance,iMsgId,szMessage,256);
							RegWizardMessageEx(m_hInstance,hwndDlg ,IDD_INVALID_DLG,szMessage);
							//MessageBox(m_hDlg,szMessage,szWindowsCaption,MB_OK|MB_ICONEXCLAMATION);
						}
						SetDlgItemText( m_hWnd, ID_LABELINIT, (LPCTSTR) _T("  "));
						FEnableControl(hwndDlg,IDDIAL,TRUE);		//ensure that these are enabled..
						FEnableControl(hwndDlg,IDC_DISCONNECT,FALSE);		
						//FEnableControl(hwndDlg,ID_BTNSETTINGS,TRUE);

						//PostMessage( m_hDlg, WM_COMMAND, (WPARAM) IDOK,0 );
						break;
					case ERROR_LINE_BUSY :
						
						pi->iError = RWZ_ERROR_NO_ANSWER;
						pi->iCancelledByUser = RWZ_ABORT_TOFINISH;
						bPostSuccessful = FALSE;
						PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);
						break;
					case ERROR_PORT_NOT_AVAILABLE:
					case ERROR_DEVICE_NOT_READY :
					default :

						RW_DEBUG << "\n RAS ERROR PORT NOT AVAILABLE " << flush;
						pi->iError = RWZ_ERROR_MODEM_CFG_ERROR;
						pi->iCancelledByUser = RWZ_ABORT_TOFINISH;
						bPostSuccessful = FALSE;
						PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);
						break;

					}

					break;


			}
		break;
		// WM_COMMAND
        default:
			bStatus = FALSE;
            break;
    }
LReturn :
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\failscr.cpp ===
/*
	File : FAILSCR.CPP
	The final screen of Registration Wizard using Wizard 97 control
	This screen displays the staus of the Online registration
	Date : 02/12/98  Suresh Krishnan

  Modification History:
  08/20/98 :
  FormRegWizErrorMsgString() is added to form Error string
*/



#include <Windows.h>
#include "RegWizMain.h"
#include "Resource.h"
#include <RegPage.h>
#include "Dialogs.h"
#include "regutil.h"
#include <rw_common.h>
#include <commctrl.h>

static   TCHAR  szClosingMsg[2048]=_T("");
extern BOOL RW_EnableWizControl(HWND hDlg,int	 idControl,	BOOL fEnable);

void FormRegWizErrorMsgString(TCHAR *czDest,HINSTANCE hIns,UINT iS1)
{
	_TCHAR szText2[1024];
	//LoadString(hIns,IDS_FINAL_UNSUCCESS_PREFIX,czDest,1024);
	LoadString(hIns,iS1,szText2,1024);
	_tcscat(czDest,szText2);
	//LoadString(hIns,IDS_FINAL_UNSUCCESS_SUFFIX,szText2,1024);
	//_tcscat(czDest,szText2);

}

/********************************************************************************

   AddErrorToList
   This function adds the error in the list view

******************************************************************************/

BOOL AddErrorToList( HWND hwndList, HINSTANCE hInstance,TCHAR *szErrorMsg)
{
	LV_ITEM     lvItem;
	int         i,
		        nIndex,
			    nImageCount;
				

	HIMAGELIST  himl;
	IMAGEINFO   ii;
	
	SendMessage(hwndList, LVM_DELETEALLITEMS, 0, 0);

	lvItem.mask = LVIF_TEXT;
	lvItem.pszText = szErrorMsg;
	lvItem.iItem = (int)SendMessage(hwndList, LVM_GETITEMCOUNT, 0, 0);
	lvItem.iSubItem = 0;
	nIndex = (int)SendMessage(hwndList, LVM_INSERTITEM, (WPARAM)0, (LPARAM)&lvItem);

	SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);
	UpdateWindow(hwndList);
	return TRUE;
}

INT CALLBACK FinalFailedScreenDialogProc(HWND hwndDlg,
					   UINT uMsg,
					   WPARAM wParam, LPARAM lParam)
/*********************************************************************
Dialog Proc for the Registration Wizard dialog that presents the
Product Identification number to the user.
**********************************************************************/
{
	CRegWizard* pclRegWizard;
	int iRet;
	_TCHAR szInfo[256];
    BOOL bStatus;
 	 HKEY  hKey;
	_TCHAR szText1[2048];
	_TCHAR szText2[1024];
	_TCHAR szRegDone[10]= _T("1");
	_TCHAR uszRegKey[128];
	short resSize;
	PTBYTE lpbData;

	pclRegWizard = NULL;
	bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
	}

    switch (uMsg)
    {
		case WM_CLOSE:
			break;
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;				

        case WM_INITDIALOG:
		{
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pi->iCancelledByUser = RWZ_PAGE_OK;

			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDC_TEXT1);
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDC_LIST1);
			
			pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szInfo);
			RW_DEBUG << "\n In Final Screen ["  << (INT)pi->iError << flush;
			ReplaceDialogText(hwndDlg, IDT_TEXT1,szInfo);
			ReplaceDialogText(hwndDlg, IDC_TEXT3,szInfo);
			
			//  pi->iError = RWZ_POST_FAILURE ;
			switch(pi->iError)
			{
				case RWZ_POST_SUCCESS :
					{
						SendDlgItemMessage(hwndDlg,IDC_TEXT1,WM_SETTEXT,0,(LPARAM) _T("You have successfully completed the registration wizard."));
						ShowWindow(GetDlgItem(hwndDlg,IDC_LIST1),SW_HIDE);
					}
				break;
				case RWZ_ERROR_NOTCPIP :
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),IDS_FINAL_NOTCP1_MSG);

					//_stprintf(szClosingMsg,szText1,szInfo);
				break;
				case CONNECTION_CANNOT_BE_ESTABLISHED:
					//
					// Modem  not found
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),IDS_FINAL_MODEMCFG_MSG1);
					
				break;
				case RWZ_ERROR_NO_ANSWER: // Site Busy Try Later Modem Error
				case RWZ_POST_FAILURE :
				case RWZ_POST_MSN_SITE_BUSY:
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),IDS_FINAL_SITEBUSY_MSG);
				break;

				case RWZ_ERROR_TXFER_CANCELLED_BY_USER:
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),IDS_FINAL_CANCEL_MSG);
					
					break;

				case RWZ_ERROR_REGISTERLATER :
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),
						IDS_FINAL_REGISTERLATER_MSG);
				break;
				case RWZ_ERROR_RASDLL_NOTFOUND :
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),IDS_FINAL_RASCFG_MSG);

				break;					
				case RWZ_ERROR_MODEM_IN_USE: // Can not Dial as another app is using the COM port
				case RWZ_ERROR_MODEM_CFG_ERROR:
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),
						IDS_FINAL_MODEMINUSE_MSG);
				break;
				case RWZ_ERROR_LOCATING_DUN_FILES:
					LoadString(pclRegWizard->GetInstance(),IDS_FINAL_UNSUCCESS_PREFIX,
						szClosingMsg,1024);
					LoadString(pclRegWizard->GetInstance(),IDS_FINAL_SYSTEMERROR_MSG,
							szText2,1024);
					_tcscat(szClosingMsg,szText2);
				default : // System Error ...
				break;

			}

			if(pi->iError != RWZ_NOERROR)
			{
				TCHAR  szTmp[2048];
				_stprintf(szTmp,szClosingMsg,szInfo);
				AddErrorToList(GetDlgItem(hwndDlg,IDC_LIST1),pclRegWizard->GetInstance(),szTmp);
			}

			return TRUE;
		}
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
				pi->iCancelledByUser = RWZ_PAGE_OK;
                PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_FINISH );
				RW_EnableWizControl(hwndDlg,RWZ_WIZ97_CANCEL_ID,FALSE);
				break;

            case PSN_WIZNEXT:
				if(pi->iCancelledByUser == RWZ_CANCELLED_BY_USER ) {
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);

				}else {
					pi->CurrentPage++;
				}
				break;

            case PSN_WIZBACK:
                pi->CurrentPage--;

                break;
			case PSN_QUERYCANCEL :
				iRet=0;
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (LONG_PTR) iRet);
				break;
				default:
                break;
            }
        } // WM_Notify
		break;
		case WM_COMMAND:
        default:
		bStatus = FALSE;
         break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\fe_util.cpp ===
/*
	FE_UTIL.CPP
	FareEastCountries heper functions
	Author : Suresh Krishnan
	Date   :03/02/98

*/

#include <fe_util.h>
#include <tchar.h>
#include <windows.h>
#include <winnls.h>
#include <rw_common.h>
#include <resource.h>


FeCountriesIndex gWhatFECountry    = kNotInitialised;
FeScreenType     gWhichFEScreenTye =kFEWithNonJapaneaseScreen;



typedef struct {
	int m_iMaxCountries;
	int m_iCountryCode[MAX_FE_COUNTRIES_SUPPORTED];
	FeScreenType m_iScreenType[MAX_FE_COUNTRIES_SUPPORTED];
}FEInfoTable;

static FEInfoTable     sFETable;




void GetFECountryListFromResource(HINSTANCE hIns )
{
	sFETable.m_iMaxCountries=0;
	int iCount =0;
	int iTokLen;
	int iResLen;
	_TCHAR	seps[] = _T(",");
	_TCHAR *pDummy;

	LPTSTR	token;
	TCHAR 	buf[80];
    TCHAR   tcSrc[512];
	iResLen = LoadString(hIns,IDS_FECOUNTRY_LIST,tcSrc,512);
	token = _tcstok( tcSrc, seps );
    sFETable.m_iMaxCountries = 0;
//	token = _tcstok( NULL, seps );
	while( token != NULL ) {
		
		_tcscpy(buf,token);
		iTokLen= _tcslen(token);
		if( iTokLen < 3) {
			goto  FinishScan; // Error in string format so skip
		}
		sFETable.m_iMaxCountries = iCount+1;
		// Get What Type of screen to use
		if( token[iTokLen-1] == _T('1')) {
			sFETable.m_iScreenType[iCount]=kFEWithJapaneaseScreen;
		}else{
			sFETable.m_iScreenType[iCount]=kFEWithNonJapaneaseScreen;
		}
		//Get the Country Code
		//buf[iTokLen-2] = _T('\0');
		sFETable.m_iCountryCode[iCount]= _tcstol(buf,&pDummy,16);
		
		iCount++;
		if(iCount >= MAX_FE_COUNTRIES_SUPPORTED ) {
			goto FinishScan;
			// Presently our Table supports 256  entries

		}
		/* Get next token: */
		token = _tcstok( NULL, seps );

   }

   FinishScan :
   RW_DEBUG  << "\n Total FE Countries Cfg " << sFETable.m_iMaxCountries;
   for(int ij=0;ij<sFETable.m_iMaxCountries;ij++) {
	   RW_DEBUG  <<"\nCountry " << sFETable.m_iCountryCode[ij] << " ScreenType" << sFETable.m_iScreenType[ij] << flush;
   }

}

//
//  This function checks if the dwCurCountry has an entry in the FE Table
//  if so it pFeType as FE country and gives the corrosponding screen type
//  in pFeScrType
//
DWORD MapCountryLcidWithFETable(DWORD dwCurCountry,
						  FeCountriesIndex *pFeType,
						  FeScreenType      *pFeScrType
						  )
{
	DWORD dwReturn;
	int iIndex;
	dwReturn = 0;
	for(iIndex = 0; iIndex < sFETable.m_iMaxCountries;iIndex++) {
		if( (DWORD)sFETable.m_iCountryCode[iIndex] == dwCurCountry ) {
			// It matches in the FE list
			*pFeType  = kFarEastCountry;
			*pFeScrType =sFETable.m_iScreenType[iIndex];
			return dwReturn;

		}

	}
	return dwReturn;

}


//
//	This fucntion gets the current LCID of the system
//  uisng GetSystemDefaultLCID().
//
//
FeCountriesIndex IsFarEastCountry(HINSTANCE hIns)
{
	LCID  lcRet;
	int   RegSettings;
	if( gWhatFECountry == kNotInitialised ) {
		GetFECountryListFromResource(hIns);
		lcRet = GetSystemDefaultLCID();

		RW_DEBUG << "\n GetSystemLCID Returns :"<< lcRet << flush;	
		gWhatFECountry = kNotAFECountry;
		MapCountryLcidWithFETable(lcRet, &gWhatFECountry,
			&gWhichFEScreenTye);
	}else {
		
		;
	}
	return gWhatFECountry;
}

FeScreenType  GetFeScreenType()
{
	return gWhichFEScreenTye;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\finalscr.cpp ===
/*
	File : FINALSCR.CPP
	The final screen of Registration Wizard using Wizard 97 control
	This screen displays the staus of the Online registration
	Date : 02/12/98  Suresh Krishnan

  Modification History:
  08/20/98 :
  FormRegWizErrorMsgString() is added to form Error string
  02/16/99 :
  In case if the user presses CANCEL the Final screen should not be 
  displayed
  02/17/99 :
  Back to original feature . In case of Cancel the final screen will be displayed
*/



#include <Windows.h>
#include "RegWizMain.h"
#include "Resource.h"
#include <RegPage.h>
#include "Dialogs.h"
#include "regutil.h"
#include <rw_common.h>
#include <commctrl.h>

static   TCHAR  szClosingMsg[2048]=_T("");
extern BOOL RW_EnableWizControl(HWND hDlg,int	 idControl,	BOOL fEnable);
extern void FormRegWizErrorMsgString(TCHAR *czDest, HINSTANCE hIns,UINT iS1);

INT_PTR
CALLBACK
FinalScreenDialogProc(
                      HWND hwndDlg,
					  UINT uMsg,
					  WPARAM wParam,
                      LPARAM lParam
                      )
/*********************************************************************
Dialog Proc for the Registration Wizard dialog that presents the
Product Identification number to the user.
**********************************************************************/
{
	CRegWizard* pclRegWizard;
	int iRet;
	_TCHAR szInfo[256];
    INT_PTR bStatus;
 	 HKEY  hKey;
	_TCHAR szText1[2048];
	_TCHAR szText2[1024];
	_TCHAR szRegDone[10]= _T("1");
	_TCHAR uszRegKey[128];
	int resSize;
	PTBYTE lpbData;
	static int iDonotShowThisPage=0;

	
	pclRegWizard = NULL;
	bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
	}

    switch (uMsg)
    {
		case WM_CLOSE:
			break;
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;				

        case WM_INITDIALOG:
		{
			LV_COLUMN   lvColumn;

			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pi->iCancelledByUser = RWZ_PAGE_OK;

			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);
			
			pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szInfo);
			RW_DEBUG << "\n In Final Screen [" << (ULONG)pi->iError << flush;
			ReplaceDialogText(hwndDlg, IDT_TEXT1,szInfo);
			ReplaceDialogText(hwndDlg, IDC_TEXT3,szInfo);

			//initialize the columns
			lvColumn.mask = LVCF_FMT|LVCF_WIDTH;
			lvColumn.fmt  = LVCFMT_LEFT;
			lvColumn.cx   = 700;

			ListView_InsertColumn(GetDlgItem(hwndDlg,IDC_LIST1), 0, &lvColumn);

			//  pi->iError = RWZ_POST_FAILURE ;
			switch(pi->iError)
			{
				case RWZ_POST_SUCCESS :
					{
						RECT Rect;
						_TCHAR szSuccessTxt[256];
						LoadString(pclRegWizard->GetInstance(),IDS_SUCCESS_TEXT,szSuccessTxt,256);
						SendDlgItemMessage(hwndDlg,IDC_TEXT1,WM_SETTEXT,0,(LPARAM) szSuccessTxt);
						ShowWindow(GetDlgItem(hwndDlg,IDC_TEXT2),SW_HIDE);
						ShowWindow(GetDlgItem(hwndDlg,IDC_LIST1),SW_HIDE);
						ShowWindow(GetDlgItem(hwndDlg,IDC_TEXT3),SW_HIDE);
						ShowWindow(GetDlgItem(hwndDlg,IDC_ERROR),SW_HIDE);
						
						uszRegKey[0] = _T('\0');
						resSize = LoadString(pclRegWizard->GetInstance(),IDS_INPUT_ISREGISTERED,uszRegKey,128);
						GetProductRoot (pi->pszProductPath , &hKey);
						lpbData = (PTBYTE) szRegDone;
						RegSetValueEx(hKey,uszRegKey,NULL,REG_SZ,(CONST BYTE *)lpbData,_tcsclen(szRegDone)*sizeof(_TCHAR));
								
						//GetWindowRect(GetDlgItem(hwndDlg,IDC_TEXT2),&Rect);
						//MoveWindow(GetDlgItem(hwndDlg,IDC_TEXT4),Rect.left,Rect.top,(Rect.right - Rect.left),(Rect.bottom - Rect.top),TRUE);
					}
				break;
				case RWZ_ERROR_NOTCPIP :
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),IDS_FINAL_NOTCP1_MSG);

					//_stprintf(szClosingMsg,szText1,szInfo);
				break;
				case CONNECTION_CANNOT_BE_ESTABLISHED:
					//
					// Modem  not found
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),IDS_FINAL_MODEMCFG_MSG1);
					
				break;
				case RWZ_ERROR_NO_ANSWER: // Site Busy Try Later Modem Error
				case RWZ_POST_FAILURE :
				case RWZ_POST_MSN_SITE_BUSY:
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),IDS_FINAL_SITEBUSY_MSG);
				break;

				case RWZ_ERROR_TXFER_CANCELLED_BY_USER:
			
					iDonotShowThisPage =0;
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),IDS_FINAL_CANCEL_MSG);
					
					break;

				case RWZ_ERROR_REGISTERLATER :
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),
						IDS_FINAL_REGISTERLATER_MSG);
				break;
				case RWZ_ERROR_RASDLL_NOTFOUND :
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),IDS_FINAL_RASCFG_MSG);

				break;					
				case RWZ_ERROR_MODEM_IN_USE: // Can not Dial as another app is using the COM port
				case RWZ_ERROR_MODEM_CFG_ERROR:
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),
						IDS_FINAL_MODEMINUSE_MSG);
				break;
				
				case RWZ_ERROR_LOCATING_DUN_FILES:
				default:
					//LoadString(pclRegWizard->GetInstance(),IDS_FINAL_UNSUCCESS_PREFIX,szClosingMsg,1024);
					LoadString(pclRegWizard->GetInstance(),IDS_FINAL_SYSTEMERROR_MSG,szText2,1024);
					_tcscat(szClosingMsg,szText2);
				//default : // System Error ...
				break;

			}

			if(pi->iError != RWZ_POST_SUCCESS)
			{
				TCHAR  szTmp[2048];
				_stprintf(szTmp,szClosingMsg,szInfo);
				
				SetDlgItemText(hwndDlg,IDC_ERROR,szTmp);
				//AddErrorToList(GetDlgItem(hwndDlg,IDC_LIST1),pclRegWizard->GetInstance(),szClosingMsg);
			}

			return TRUE;
		}
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
				
            switch( pnmh->code ){
				

            case PSN_SETACTIVE:
				
				pi->iCancelledByUser = RWZ_PAGE_OK;
                PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_FINISH );
				RW_EnableWizControl(hwndDlg,RWZ_WIZ97_CANCEL_ID,FALSE);
				if(iDonotShowThisPage ) {
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_FINISH);
				}
				
				break;

            case PSN_WIZNEXT:
				
				if(pi->iCancelledByUser == RWZ_CANCELLED_BY_USER ) {
					
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);

				}else {
					
					pi->CurrentPage++;
				}
				break;

            case PSN_WIZBACK:
                pi->CurrentPage--;

                break;
			case PSN_QUERYCANCEL :
				iRet=0;
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, iRet);
				break;
			default:

                break;
            }
        } // WM_Notify
		break;
		case WM_COMMAND:
        default:
		bStatus = FALSE;
         break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\home.cpp ===
/*********************************************************************
Registration Wizard

Home user related questions

  04/26/98 - Suresh Krishnan
(c) 1994-95 Microsoft Corporation
**********************************************************************/

#include <Windows.h>
#include <stdio.h>
#include "RegPage.h"
#include "regwizmain.h"
#include "resource.h"
#include "dialogs.h"
#include "regutil.h"
#include <rw_common.h>

#define  LIMIT_INFLUENCE  9
#define  LIMIT_EXCITED    9
#define  LIMIT_SKILL      5   

#define _INCLUDE_3RDPARTYLOGIC_CODE

#ifdef _INCLUDE_3RDPARTYLOGIC_CODE 	
static int vDeclineOffers = -1;
#endif

BOOL ValidateHomeUserDialog(HWND hwndDlg,int iStrID);
void FillListEntry(HWND hwnd,int iLimit);

int  GetListIndexFromValue(TCHAR * czValue, int iMax)
{	int iIndex;
	iIndex = _ttoi(czValue);
	if(iIndex == 0) {
		return 0;
	}else {
		return (iMax - iIndex)+1;
	}
}
int GetValueFromListIndex(int iIndex, int iMax)
{
    if(iIndex == 0) {
         return 0;
    }
	return (iMax -iIndex)+1;
}

INT_PTR  CALLBACK HomeUserDialogProc(HWND hwndDlg, UINT uMsg, 
										 WPARAM wParam, LPARAM lParam)
/*********************************************************************
Dialog Proc for the Registration Wizard dialog that displays 
Business related Question 
network type, etc.
**********************************************************************/
{


	CRegWizard* pclRegWizard;
	INT_PTR iRet;
	_TCHAR szInfo[256];
    INT_PTR bStatus;
	BOOL NotboughtByCompany;
	HWND hwCmpSw,hwExcite, hwPcSw; 
	LRESULT dwIndex;
	int iIndex;
#ifdef _INCLUDE_3RDPARTYLOGIC_CODE 	
	TriState shouldInclude;
#endif


	

	static int iShowThisPage= DO_SHOW_THIS_PAGE; 


	pclRegWizard = NULL;
	bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
		hwCmpSw  = GetDlgItem(hwndDlg,IDC_LIST2);
		hwExcite = GetDlgItem(hwndDlg,IDC_LIST4);
		hwPcSw   = GetDlgItem(hwndDlg,IDC_LIST5);;
	}
	

    switch (uMsg)
    {
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;
		case WM_CLOSE:
			 break;			
        case WM_INITDIALOG:
		{
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);
			hwCmpSw  = GetDlgItem(hwndDlg,IDC_LIST2);
			hwExcite = GetDlgItem(hwndDlg,IDC_LIST4);
			hwPcSw   = GetDlgItem(hwndDlg,IDC_LIST5);;

			FillListEntry(hwCmpSw,LIMIT_INFLUENCE);
			FillListEntry(hwExcite,LIMIT_EXCITED);
			FillListEntry(hwPcSw, LIMIT_SKILL);
			
			SetFocus(hwCmpSw);

		    vDialogInitialized = FALSE;
            return TRUE;
		} // WM_INIT
		break;
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:

			NotboughtByCompany = pclRegWizard->IsInformationWriteEnabled(kInfoCompany);
			if(NotboughtByCompany) 
			{
				iShowThisPage= DO_NOT_SHOW_THIS_PAGE;
			}else {
				iShowThisPage= DO_SHOW_THIS_PAGE;
			}
			if(iShowThisPage== DO_SHOW_THIS_PAGE) {
				NormalizeDlgItemFont(hwndDlg,IDC_TITLE,RWZ_MAKE_BOLD);
				NormalizeDlgItemFont(hwndDlg,IDC_SUBTITLE);
				
			}
			if( iShowThisPage== DO_NOT_SHOW_THIS_PAGE ) 
			{
				pi->iCancelledByUser = RWZ_SKIP_AND_GOTO_NEXT;
				if( pi->iLastKeyOperation == RWZ_BACK_PRESSED){
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_BACK);
				}else {
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);
				}
			}
			else {
				// Show thi  page
				pi->iCancelledByUser = RWZ_PAGE_OK;
				pi->iLastKeyOperation = RWZ_UNRECOGNIZED_KEYPESS;
				PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT);
			
				// Update Indexes 
				if(pclRegWizard->GetInformationString(kHomeSwKnow,szInfo)) {
					iIndex = GetListIndexFromValue(szInfo,LIMIT_INFLUENCE);
					SendMessage(hwCmpSw, LB_SETCURSEL,iIndex, 0);
				}else {
					
				}
				
				if( pclRegWizard->GetInformationString(kHomeExcited,szInfo)){
					iIndex = GetListIndexFromValue(szInfo,LIMIT_INFLUENCE);
					SendMessage(hwExcite, LB_SETCURSEL ,iIndex, 0);
				}
					
				if(pclRegWizard->GetInformationString(kHomePcSwKnow,szInfo)) {
					iIndex = GetListIndexFromValue(szInfo,LIMIT_SKILL);
					SendMessage(hwPcSw, LB_SETCURSEL ,iIndex,0);
				}
#ifdef _INCLUDE_3RDPARTYLOGIC_CODE 	
				
				// 
				// radio buttons
				shouldInclude = pclRegWizard->GetTriStateInformation(kInfoDeclinesNonMSProducts);
				if (shouldInclude == kTriStateTrue ){
					CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1);
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					vDeclineOffers = 1;
				}
				else if (shouldInclude == kTriStateFalse){
					CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2);
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					vDeclineOffers = 0;
				}else if (shouldInclude == kTriStateUndefined){
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK );
					vDeclineOffers = -1;
				}
				// Enable for previpously entred value in screen
				if(IsDlgButtonChecked(hwndDlg,IDC_RADIO1)){
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
				}
				if(IsDlgButtonChecked(hwndDlg,IDC_RADIO2)){
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
				}
#endif

				vDialogInitialized = TRUE;



			}
            break;
            case PSN_WIZNEXT:
				switch(pi->iCancelledByUser) 
				{
				case  RWZ_CANCELLED_BY_USER : 
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);
					break;
				case RWZ_PAGE_OK:
					{
						RW_DEBUG << "Home questionaire RWZ_PAGE_OK " << endl;
						iRet=0;
						if( ValidateHomeUserDialog(hwndDlg,IDS_BAD_SYSINV)) 
						{
#ifdef _INCLUDE_3RDPARTYLOGIC_CODE 	
						BOOL yesChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO1);
						BOOL noChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO2);
#endif

						// Get Selected Value 
						dwIndex =  SendMessage(hwCmpSw, LB_GETTOPINDEX , 0, 0);
					
						if(dwIndex != LB_ERR)
						{
						 	dwIndex = GetValueFromListIndex((int) dwIndex,LIMIT_INFLUENCE); 	
							_stprintf(szInfo,_T("%d"),dwIndex);
							
							RW_DEBUG << "Home questionaire kHomeSwKnow "<< ConvertToANSIString(szInfo) << endl;

							pclRegWizard->SetInformationString(kHomeSwKnow,szInfo);
						}
						else 
						{
							RW_DEBUG << "Home questionaire kHomeSwKnow NULL " << endl;
							pclRegWizard->SetInformationString(kHomeSwKnow,NULL);
						}

						// Get 
						dwIndex =  SendMessage(hwExcite, LB_GETTOPINDEX , 0, 0);
						if(dwIndex !=  LB_ERR) 
						{
							dwIndex = GetValueFromListIndex((int) dwIndex,LIMIT_INFLUENCE); 	
							_stprintf(szInfo,_T("%d"),dwIndex);
							
							RW_DEBUG << "Home questionaire kHomeExcited "<< ConvertToANSIString(szInfo) << endl;

							pclRegWizard->SetInformationString(kHomeExcited,szInfo);
						}
						else 
						{
							RW_DEBUG << "Home questionaire kHomeExcited NULL " << endl;
							pclRegWizard->SetInformationString(kHomeExcited,NULL);
						}
						//
						// Get Home PC Know
						dwIndex =  SendMessage(hwPcSw, LB_GETTOPINDEX , 0, 0);
						_stprintf(szInfo,_T("%d"),dwIndex);

						if(dwIndex !=  LB_ERR) 
						{
							dwIndex = GetValueFromListIndex((int) dwIndex,LIMIT_SKILL); 	
							_stprintf(szInfo,_T("%d"),dwIndex);
							RW_DEBUG << "Home questionaire kHomePcSwKnow "<< ConvertToANSIString(szInfo) << endl;

							pclRegWizard->SetInformationString(kHomePcSwKnow,szInfo);
						}
						else 
						{
							RW_DEBUG << "Home questionaire kHomePcSwKnow NULL " << endl;
							pclRegWizard->SetInformationString(kHomePcSwKnow,NULL);
						}

#ifdef _INCLUDE_3RDPARTYLOGIC_CODE 	
 						if(vDeclineOffers == -1)
						{
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateUndefined);
						}
						else
						if(vDeclineOffers == 0)
						{
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateFalse);
						}
						else
						{
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateTrue);
						}
						_stprintf(szInfo,_T("%i"),vDeclineOffers);
						pclRegWizard->SetInformationString(kInfoDeclinesNonMSProducts,szInfo);
#endif
						RW_DEBUG << "Home questionaire done " << endl;
					// *****
						pi->CurrentPage++;
						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;
					// Set as Next Key Button Pressed
					}
					else 
					{
					// Force it it be in this screen
						iRet=-1;
					}
						SetWindowLongPtr( hwndDlg ,DWLP_MSGRESULT, (INT_PTR) iRet); 
					}
					break;
					case RWZ_SKIP_AND_GOTO_NEXT:
					default:
						// Do not Validate the page and just go to the next page 
						pi->CurrentPage++;
						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;

					break;
				} // end of switch pi->iCancelledByUser
				break;
            case PSN_WIZBACK:
                pi->CurrentPage--;
				pi->iLastKeyOperation = RWZ_BACK_PRESSED;
				break;
			case PSN_QUERYCANCEL :
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet = 1;
					pi->ErrorPage  = kHomeUserDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					pi->iLastKeyOperation = RWZ_CANCEL_PRESSED;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);

				}else {
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;
				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 				
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        } // WM_Notify
		break;
        case WM_COMMAND:
		{
			switch (wParam)
            {
#ifdef _INCLUDE_3RDPARTYLOGIC_CODE 	
              case IDC_RADIO2:
			  case IDC_RADIO1:
					if (vDialogInitialized){
					// If the 'No' button is checked, the user is declining
					// the "Non-Microsoft product" offers
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO1)){
						vDeclineOffers = 1;
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
					}else
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO2)){
						vDeclineOffers = 0;
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
					}else{
						vDeclineOffers = -1;
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK  );
						//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),FALSE);
					}

				}
				break;
#endif

			  default:
				  break;
            }
		}// End of WM_COMMAND
        break;
        default:
		bStatus = FALSE;
        break;
    }
    return bStatus;
       
}



BOOL ValidateHomeUserDialog(HWND hwndDlg,int iStrID)
{
	return TRUE;
}

void FillListEntry(HWND hwnd, int iLimit)
{
	TCHAR szTemp[20];
	SendMessage(hwnd, LB_ADDSTRING , 0, (LPARAM) " ");
	for(int i=iLimit; i > 0;i--){
		_stprintf(szTemp,_T("%d"),i);
		SendMessage(hwnd, LB_ADDSTRING , 0, (LPARAM) szTemp);
	}
	
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\inetdlg.cpp ===
#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include "resource.h"
#include "rw_common.h"
#include "rwpost.h"
#include "sysinv.h"
#include "regutil.h"

#define POST_DATA_WITH_DISPLAY 1

static HWND  m_hDlg = NULL;
static HINSTANCE m_hInst=NULL;
static DWORD    dwRasError = 0; // To Store Ras reported Error
static HANDLE hRasNotifyEvt=  NULL ; // Event handle used for RAS Notififiation
static int siMsgType=0;  // used to choose the message to be displayed
static int siOperation=0;
extern BOOL bOemDllLoaded;
extern HANDLE hOemDll;
extern _TCHAR szWindowsCaption[256];

INT_PTR CALLBACK  DisplayDlgWindowWithOperation(
				HWND hDlg, 			//dialog window
				UINT uMsg,
				WPARAM wParam,
				LPARAM lParam
			)
			
//BOOL CALLBACK  DisplayMSNConnection(
	//	HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	
	DWORD	dwEnd = 0;
	BOOL	fRet = TRUE;
	HWND hwndParent ;
	switch(uMsg){
		case WM_INITDIALOG:	
			
			RECT parentRect,dlgRect;
			m_hDlg = hDlg;
			m_hInst   = ( HINSTANCE) lParam;
			hwndParent = GetParent(hDlg);
						
			if (hwndParent)
			{
				GetWindowRect(hwndParent,&parentRect);
				GetWindowRect(hDlg,&dlgRect);
				int newX = parentRect.left + (parentRect.right - parentRect.left)/2 - (dlgRect.right - dlgRect.left)/2;
				int newY = parentRect.top + (parentRect.bottom - parentRect.top)/2 - (dlgRect.bottom - dlgRect.top)/2;
				MoveWindow(hDlg,newX,newY,dlgRect.right - dlgRect.left,dlgRect.bottom - dlgRect.top,FALSE);
			}
			else
			{
				int horiz,vert;
				GetDisplayCharacteristics(&horiz,&vert,NULL);
				GetWindowRect(hDlg,&dlgRect);
				int newX = horiz/2 - (dlgRect.right - dlgRect.left)/2;
				int newY = vert/2 - (dlgRect.bottom - dlgRect.top)/2;
				MoveWindow(hDlg,newX,newY,dlgRect.right - dlgRect.left,dlgRect.bottom - dlgRect.top,FALSE);
			}
			NormalizeDlgItemFont(hDlg,IDC_TEXT1);
			
			SetWindowText(hDlg,szWindowsCaption);

			ReplaceDialogText(hDlg,IDC_TEXT1,GetProductBeingRegistred());

			if(siMsgType)
			{
				ReplaceDialogText(hDlg,IDC_TEXT1,GetProductBeingRegistred());
			}
			else
			{

				if(siOperation == POST_DATA_WITH_DISPLAY)
				{
					TCHAR szValueName[256] = _T("");
					HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hDlg,GWLP_HINSTANCE);
					LoadString(hInstance,IDS_POST_MESSAGE,szValueName,128);
					SendDlgItemMessage(hDlg,IDC_TEXT1,WM_SETTEXT,0,(LPARAM)szValueName);
				}
			}
			
			PostMessage( m_hDlg, WM_COMMAND, (WPARAM) IDOK,0 );
			return TRUE;
  			goto LReturn;
			break;
		case WM_COMMAND:
		switch (LOWORD(wParam)){
			case IDOK  :
				if(siOperation == POST_DATA_WITH_DISPLAY) {
					dwEnd = SendHTTPData(m_hDlg,m_hInst);
					goto LEnd;

				}
			
				dwEnd = CheckInternetConnectivityExists(m_hDlg,
					m_hInst);
				goto LEnd;

			case IDCANCEL:
				goto LEnd;
			default:
				fRet = FALSE;
				goto LReturn;
			}
		break;
		default :
		fRet = FALSE;
		goto LReturn;
		break;
	}
LEnd:
	EndDialog(hDlg,dwEnd);
	m_hDlg = NULL;	//no more dialog	
LReturn:	
	return fRet;
}



//  Function : CheckWithDisplayInternetConnectivityExists( )
//  This function calls the Background fucntion CheckInternetConnectivityExists() 		
//  whcih checks for the  connectivity cfg to the MSN.
//  The return value is based on the return value of CheckInternetConnectivityExists()
//	Returns
//	DIALUP_NOT_REQUIRED  : Use Network for tx
//  DIALUP_REQUIRED       : Use Dialupo for Tx
//  RWZ_ERROR_NOTCPIP      : No TCP/IPO
//  CONNECTION_CANNOT_BE_ESTABLISHED  : No modem or RAS setup


DWORD_PTR CheckWithDisplayInternetConnectivityExists(HINSTANCE hIns,HWND hwnd,int iMsgType)
{
	
	INT_PTR dwRet;	
	siMsgType = iMsgType;
	RW_DEBUG << "\n Before invoking Dlg   Display Internet Connection "  <<  flush;
	dwRet=DialogBoxParam(hIns, MAKEINTRESOURCE(IDD_VERIFY_CONNECTION), hwnd,DisplayDlgWindowWithOperation,
			 (LPARAM)hIns);
	siMsgType = 0;
	if(dwRet == -1 ) {
			 // Error in creating the Dialogue
	
	}
	RW_DEBUG << "\n In Chk With Display Internet Connection "  <<  flush;
	return dwRet;
}


DWORD_PTR PostDataWithWindowMessage( HINSTANCE hIns)
{
	INT_PTR dwRet;	
	siMsgType = 0;
	siOperation = POST_DATA_WITH_DISPLAY;
	RW_DEBUG << "\n Invoking PostDataDlg   Display Internet Connection "  <<  flush;
	dwRet=DialogBoxParam(hIns, MAKEINTRESOURCE(IDD_VERIFY_CONNECTION), NULL,DisplayDlgWindowWithOperation,
			 (LPARAM)hIns);
	siMsgType = 0;
	siOperation = 0;
	if(dwRet == -1 ) {
			 // Error in creating the Dialogue
	
	}
	return dwRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\msgdlg.cpp ===
/*********************************************************************
Registration Wizard

msgdlg.cpp
11/22/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
**********************************************************************/

#include <Windows.h>
#include "Resource.h"
#include "regutil.h"
#include <stdio.h>
#include "sysinv.h"

#define REPLACE_TITLE	     0
#define RETAIN_DEFAUT_TITLE  1

extern _TCHAR szWindowsCaption[256];

static INT_PTR CALLBACK MsgDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
static int iShowTitle =REPLACE_TITLE;

int RegWizardMessage(HINSTANCE hInstance,HWND hwndParent, int dlgID)
/*********************************************************************
Puts up the dialog box with the given ID, and maintains control until
the user dismisses it.  The ID of the control used for the dismissal
will be returned as the function result.

Note: pass NULL for hwndParent if there is to be no parent window
for the message dialog.
**********************************************************************/
{
	iShowTitle =REPLACE_TITLE;
	if(dlgID == IDD_INPUTPARAM_ERR ||
		dlgID == IDD_ANOTHERCOPY_ERROR ) {
		iShowTitle = RETAIN_DEFAUT_TITLE;
	}
	int hitButton = (int) DialogBoxParam(hInstance,MAKEINTRESOURCE(dlgID),hwndParent, MsgDialogProc, NULL);
	return hitButton;
}


int RegWizardMessageEx(HINSTANCE hInstance,HWND hwndParent, int dlgID, LPTSTR szSub)
/*********************************************************************
Puts up the dialog box with the given ID, and maintains control until
the user dismisses it.  The ID of the control used for the dismissal
will be returned as the function result.

If the specified dialog has a text field with IDT_TEXT1, and the
text within that field has a %s specifier, that specifier will be
replaced with the string pointed to by the szSub parameter.

Note: pass NULL for hwndParent if there is to be no parent window
for the message dialog.
**********************************************************************/
{
	iShowTitle =REPLACE_TITLE;
	int hitButton = (int) DialogBoxParam(hInstance,MAKEINTRESOURCE(dlgID),hwndParent, MsgDialogProc,(LPARAM) szSub);
	return hitButton;
}



INT_PTR CALLBACK MsgDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
/*********************************************************************
Proc for a standard "message" dialog box.
**********************************************************************/
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
		{
			RECT parentRect,dlgRect;
			HWND hwndParent = GetParent(hwndDlg);
			if (hwndParent)
			{
				GetWindowRect(hwndParent,&parentRect);
				GetWindowRect(hwndDlg,&dlgRect);
				int newX = parentRect.left + (parentRect.right - parentRect.left)/2 - (dlgRect.right - dlgRect.left)/2;
				int newY = parentRect.top + (parentRect.bottom - parentRect.top)/2 - (dlgRect.bottom - dlgRect.top)/2;
				MoveWindow(hwndDlg,newX,newY,dlgRect.right - dlgRect.left,dlgRect.bottom - dlgRect.top,FALSE);
			}
			else
			{
				int horiz,vert;
				GetDisplayCharacteristics(&horiz,&vert,NULL);
				GetWindowRect(hwndDlg,&dlgRect);
				int newX = horiz/2 - (dlgRect.right - dlgRect.left)/2;
				int newY = vert/2 - (dlgRect.bottom - dlgRect.top)/2;
				MoveWindow(hwndDlg,newX,newY,dlgRect.right - dlgRect.left,dlgRect.bottom - dlgRect.top,FALSE);
			}
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);

			if( iShowTitle ==REPLACE_TITLE )
			SetWindowText(hwndDlg,szWindowsCaption);

			if (lParam != NULL)
			{
				LPTSTR szSub = (LPTSTR) lParam;
				ReplaceDialogText(hwndDlg,IDT_TEXT1,szSub);
			}
            return TRUE;
		}
        case WM_COMMAND:
			EndDialog(hwndDlg,wParam);
			break;
        default:
            break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\modem.cpp ===
/*********************************************************************
Registration Wizard

This file houses a set of functions that use TAPI to access
information about installed modems.

11/15/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation

Original source: MOS development
**********************************************************************/
#include <windows.h>
#include <mcx.h>
#include <tapi.h>
#include <devcfg.h>

#include "mcm.h"
#include "resource.h"
#include "ATK_RAS.h"

#include  "rw_common.h"


#define pcszDataModem		_T("comm/datamodem")
#define pcszWaitLineCreate	_T("MCMLineCreate")
#define PTSTR(wszID)		GetSz(hInst, wszID)
#define chBackslash		'\\'
#define irgMaxSzs		5
// Globals
static _TCHAR		szStrTable[irgMaxSzs][256];
static INT			iSzTable = 0;

MODEMSTATUS MSDetectModemTAPI(HINSTANCE hInstance);
BOOL DoInstallDialog(HINSTANCE hInstance,int nDialogType);
INT_PTR CALLBACK NoModemDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
void SetWaitLineCreateEvent(void);
void CenterDlg(HWND hWnd);
PVOID PVReadRegSt(HINSTANCE hInst, WORD wiszKey, WORD wiszVal);
PVOID PVReadReg(HKEY hKeyM, HINSTANCE hInst, WORD wiszKey, WORD wiszVal);
PTSTR GetSz(HINSTANCE hInst, WORD wszID);
void CALLBACK LineCallback(DWORD hDevice, DWORD dwMessage, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2, DWORD dwParam3);

void CALLBACK CountryLineCallback1(DWORD hDevice, DWORD dwMessage, DWORD dwInstance, DWORD dwParam1,
										  DWORD dwParam2, DWORD dwParam3)
{

}





MODEMSTATUS MSEnsureModemTAPI(HINSTANCE hInstance,HWND hwnd)
/*********************************************************************
Ensures that a modem is installed and that tapi is setup. if not, user
will be prompted to do so.

Returns:
- kMsModemOk
- kMsModemNotFound
- kMsModemTooSlow
**********************************************************************/
{
	MODEMSTATUS			msReturnVal = kMsModemNotFound;
	do
	{
		msReturnVal = MSDetectModemTAPI(hInstance);
		if (msReturnVal != kMsModemOk)
		{	
			INT_PTR dlgReturn;
			int iDialogID = msReturnVal == kMsModemNotFound ? IDD_NOMODEM : IDD_MODEM_TOO_SLOW;
			dlgReturn = DialogBox(hInstance, MAKEINTRESOURCE(iDialogID), hwnd,
				NoModemDlgProc);
			if (!dlgReturn)
			{
				return kMsModemNotFound;
			}
			msReturnVal = MSDetectModemTAPI(hInstance);
		}
	}while (msReturnVal != kMsModemOk);
	return (msReturnVal);
}


MODEMSTATUS MSDetectModemTAPI(HINSTANCE hInstance)
/*********************************************************************
Returns:
- kMsModemOk
- kMsModemNotFound
- kMsModemTooSlow
**********************************************************************/
{
	HLINEAPP 	hLineApp;
	DWORD 		dwAPI;
	DWORD 		dwDevice;
	BOOL		fModem;
	const DWORD cMarvelBpsMin = 2400;
	MODEMSTATUS	msReturnVal = kMsModemNotFound;
	DWORD 		dwIndex = 0;
	#ifdef _LOG_IN_FILE
		RW_DEBUG  <<"\n Inside MSDetectModemTAPI "  << flush;
	#endif

	do
	{
		fModem = FGetDeviceID(hInstance, &hLineApp, &dwAPI, &dwDevice,dwIndex++);
		if (fModem)
		{
			DWORD dwSpeed;
			if (FGetModemSpeed(hInstance, dwDevice,&dwSpeed))
			{
				if (dwSpeed >= cMarvelBpsMin || 0 == dwSpeed )
				{
					msReturnVal = kMsModemOk; 	//modem speed is ok
				}
				else
				{
					msReturnVal = kMsModemTooSlow;
				}
			}
			lineShutdown(hLineApp);
		}
		
		RW_DEBUG << "\n Index:" << dwIndex << "fModem:"<<fModem <<flush;

	}while (fModem == TRUE && msReturnVal != kMsModemOk);
	return msReturnVal;
}



BOOL DoInstallDialog(HINSTANCE hInstance,int nDialogType)
/*********************************************************************
This function puts up the "Install new modem" control panel, and
returns only when the user has dismissed the dialog (either after
installing a new modem, or canceling).
Returns: FALSE if an error prevented the dialog from being displayed.
**********************************************************************/
{
	_TCHAR 				szCmdLine[128];
	STARTUPINFO 		si;
	PROCESS_INFORMATION pi;
	BOOL 				fControlProcessDone = FALSE;
	BOOL 				fProcessStatus;
	//HWND				hwndProcess;

	if(nDialogType == 1)
	{
		LoadString(hInstance,IDS_ADDMODEMCOMMAND,szCmdLine,128);
	}
	else
	{
		_tcscpy(szCmdLine,_T(""));
		LoadString(hInstance,IDS_DIALINGPROPERTIES,szCmdLine,128);
	}
	si.cb = sizeof(STARTUPINFO);
	si.lpReserved = NULL;
	si.lpDesktop = NULL;
	si.lpTitle = NULL;
	si.dwFlags = 0L;
	si.cbReserved2 = 0;
	si.lpReserved2 = NULL;
	fProcessStatus = CreateProcess(NULL,szCmdLine,NULL,NULL,FALSE,
		CREATE_DEFAULT_ERROR_MODE | CREATE_NEW_PROCESS_GROUP | NORMAL_PRIORITY_CLASS,NULL,NULL,&si,&pi);
	if (fProcessStatus == FALSE)
	{
		return FALSE;
	}
	return TRUE;
}

// ======================== NoModemDlgProc ==============================

INT_PTR CALLBACK NoModemDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	static fInstallModemDlgStarted = FALSE;
	static fDialingPropertiesStarted = FALSE;

	HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hWnd,GWLP_HINSTANCE);
	switch (uMsg)
	{
		case WM_INITDIALOG:
			CenterDlg(hWnd);
			SetForegroundWindow(hWnd);
			return fTrue;

		case WM_ACTIVATE:
			if (wParam != 0 && fInstallModemDlgStarted == TRUE)
			{
				DoInstallDialog(hInstance,2);
				fDialingPropertiesStarted = TRUE;
				fInstallModemDlgStarted = FALSE;
			}
			
			if (wParam != 0 && fDialingPropertiesStarted == TRUE)
			{
				fDialingPropertiesStarted = FALSE;
				EndDialog(hWnd,fTrue);
			}
			break;
		case WM_CLOSE:
			EndDialog(hWnd, fFalse);
			break;
		case WM_COMMAND:
			switch (LOWORD(wParam))
				{
				case IDCANCEL:
					EndDialog(hWnd, fFalse);
					break;
				case IDYES:
					DoInstallDialog(hInstance,1);
					fInstallModemDlgStarted = TRUE;
					EnableWindow(GetDlgItem(hWnd,IDYES),FALSE);
					break;
				case IDNO:
					EndDialog(hWnd, fFalse);
					return (fTrue);
				}		
			break;
		}

	return (fFalse);
}


BOOL FGetModemSpeed(HINSTANCE hInstance, DWORD dwDevice, PDWORD pdwSpeed)
/*********************************************************************
Given a lineDevice ID in the dwDevice parameter, FGetModemSpeed
returns the operating speed of the device represented by that ID.
**********************************************************************/
{
	BOOL		fRet = fFalse;
	PSTR		pvs = NULL;
	DWORD		dwRet;

	*pdwSpeed = 0;	//7/12/94 UmeshM. Init the variable
	Try
		{
		VARSTRING	vs;
		
		vs.dwTotalSize = sizeof(vs);
		dwRet = lineGetDevConfig(dwDevice, &vs, pcszDataModem);
		if (dwRet != 0 && dwRet != LINEERR_STRUCTURETOOSMALL)
			{
			//Dprintf("linegetdevconfig = %X\n", dwRet);
			Leave;
			}

		pvs =(char *)  LocalAlloc(LPTR, vs.dwNeededSize);
		if (!pvs)
			Leave;
			
		((VARSTRING *) pvs)->dwTotalSize = vs.dwNeededSize;
		dwRet = lineGetDevConfig(dwDevice, (LPVARSTRING)  pvs, pcszDataModem);
		if (dwRet != 0)
			{
			//Dprintf("linegetdevconfig = %X\n", dwRet);
			Leave;
			}

			{
			LPDEVCFG pDevCfg = (LPDEVCFG)(pvs + sizeof(VARSTRING));
			COMMCONFIG *pConf = (COMMCONFIG*)(pvs + sizeof(VARSTRING) + sizeof(DEVCFGHDR));
			MODEMSETTINGS *pSet;
			
			pSet = (MODEMSETTINGS*)( ((char*)pConf) + pConf->dwProviderOffset);
			
			//if (FAmIOnline())
			//	*pdwSpeed = pSet->dwNegotiatedDCERate;
			//else
				*pdwSpeed = pConf->dcb.BaudRate;
			fRet = fTrue;
			}
		} // Try
		
	Finally
		{
		if (pvs)
			LocalFree(pvs);
			
		}
		
	return (fRet);
} // FGetModemSpeed()



// ======================== FGetDeviceID ==============================
BOOL FGetDeviceID(HINSTANCE hInstance, HLINEAPP *phLineApp, PDWORD pdwAPI, PDWORD pdwDevice, DWORD dwIndex)
{
	DWORD				dwDevices, iDevice, dwRet;
	LINEEXTENSIONID		ExtID;
	LINEDEVCAPS			dc, *pdc;
	PSTR				pszCL;

	DWORD				dwLocalIndex;
	#ifdef _LOG_IN_FILE
		RW_DEBUG  <<"\n Inside FGetDeviceID "  << flush;
	#endif

	//Assert(phLineApp && pdwDevice && pdwAPI);
	if ((dwRet = lineInitialize(phLineApp, hInstance, (LINECALLBACK) LineCallback, NULL, &dwDevices)) != 0)
		{
			#ifdef _LOG_IN_FILE
				RW_DEBUG  <<"\n lineInitialize Error "  << dwRet << flush;
			#endif
			return (fFalse);
		}

	pszCL = (PSTR) PVReadRegSt(hInstance, iszLoginKey, IDS_CURRENTCOMMDEV);
	*pdwDevice = INVALID_PORTID;
	dc.dwTotalSize = sizeof(LINEDEVCAPS);
	
	dwLocalIndex = 0;
	
	RW_DEBUG << "dwDevices: " << dwDevices << flush;

	for (iDevice = 0; iDevice < dwDevices; iDevice ++)
	{
		DWORD dwAPILowVersion = 0 << 16;
		DWORD dwAPIHighVersion = 3 << 16;
		
		RW_DEBUG << "\n Enter 0" << flush;
	
		dwRet = lineNegotiateAPIVersion(*phLineApp, iDevice,  dwAPILowVersion,dwAPIHighVersion, pdwAPI, &ExtID);
		dwRet |= lineGetDevCaps(*phLineApp, iDevice, *pdwAPI, 0, &dc);
		
		if (dc.dwMediaModes & LINEMEDIAMODE_DATAMODEM && dwRet == 0)
		{
			RW_DEBUG << "\ndwIndex:" <<dwIndex<< " dwLocalIndex:" << dwLocalIndex <<flush;

			if (dwLocalIndex++ == dwIndex)
			{
				RW_DEBUG << "\n Enter 2 iDevice:" << iDevice << flush;

				if (*pdwDevice == INVALID_PORTID)
					*pdwDevice = iDevice;
				
				pdc = (LINEDEVCAPS *) LocalAlloc(LPTR, dc.dwNeededSize);
				if (pdc)
				{
					RW_DEBUG << "\n Enter 3" << flush;

					pdc->dwTotalSize = dc.dwNeededSize;
					dwRet |= lineGetDevCaps(*phLineApp, iDevice, *pdwAPI, 0, pdc);
					if (pdc->dwLineNameSize > 0 && pszCL)
					{
						RW_DEBUG << "\n Enter 3" << flush;
						PSTR	pszLineName;
					
			            pszLineName = (LPSTR)(pdc) + pdc->dwLineNameOffset;
		
			            // Use if specified in registry
			            if (strcmp(pszCL, pszLineName) == 0)
							*pdwDevice = iDevice;
					}
					LocalFree(pdc);
					RW_DEBUG << "\n Exit 3" << flush;
				}
				RW_DEBUG << "\n Exit 2" << flush;
			}
			RW_DEBUG << "\n Exit 1" << flush;
		}
		RW_DEBUG << "\n Exit 0" << flush;
	}
								
	if (*pdwDevice == INVALID_PORTID)
		{ // no data modem found
			#ifdef _LOG_IN_FILE
				RW_DEBUG  <<"\n lineGetDevCaps returned INVALID_PORTID Error"  << flush;
			#endif

			lineShutdown(*phLineApp);
			return (fFalse);
		}
		
	return (fTrue);
} // FGetDeviceID()				



void CenterDlg(HWND hWnd)
{
	HWND	hwndOwner;
	RECT	rcOwner, rcDlg, rc;
	
	if (((hwndOwner = GetParent(hWnd)) == NULL) || IsIconic(hwndOwner) || !IsWindowVisible(hWnd))
		hwndOwner = GetDesktopWindow();
	GetWindowRect(hwndOwner, &rcOwner);
	GetWindowRect(hWnd, &rcDlg);
	CopyRect(&rc, &rcOwner);

	
	// Offset the owner and dialog box rectangles so that
	// right and bottom values represent the width and
	// height, and then offset the owner again to discard
	// space taken up by the dialog box.

	OffsetRect(&rcDlg, -rcDlg.left, -rcDlg.top);
	OffsetRect(&rc, -rc.left, -rc.top);
	OffsetRect(&rc, -rcDlg.right, -rcDlg.bottom);

	// The new position is the sum of half the remaining
	// space and the owner's original position.

	SetWindowPos(hWnd,HWND_TOP, rcOwner.left + (rc.right / 2),
		rcOwner.top + (rc.bottom / 2),	0, 0, SWP_NOSIZE);
} // CenterDlg


// ======================== PVReadRegSt ==============================

PVOID PVReadRegSt(HINSTANCE hInst, WORD wiszKey, WORD wiszVal)
{
	return (PVReadReg(HKEY_CURRENT_USER, hInst, wiszKey, wiszVal));
} // PVReadRegSt()

// ======================== PVReadReg ==============================

// returns pointer to struct. REMEMBER to free the pointer(LocalFree)

PVOID PVReadReg(HKEY hKeyM, HINSTANCE hInst, WORD wiszKey, WORD wiszVal)
{
	HKEY	hKey = NULL;
	PVOID	pVal = NULL;
	DWORD	dwCb;
	BOOL	fRead = fFalse;
		

	Try
		{
		if (RegOpenKey(hKeyM, PTSTR(wiszKey), &hKey) != ERROR_SUCCESS)
			Leave;
			
		if (!(RegQueryValueEx(hKey, PTSTR(wiszVal), NULL, NULL, NULL, &dwCb) == ERROR_SUCCESS && dwCb))
			Leave;
			
		pVal = LocalAlloc(LPTR, dwCb);
		if (pVal == NULL)
			Leave;
				
		if (RegQueryValueEx(hKey, PTSTR(wiszVal), NULL,
			NULL,(LPBYTE ) pVal, &dwCb) != ERROR_SUCCESS)
			Leave;
		fRead = fTrue;
		}
		
	Finally
		{
		RegCloseKey(hKey);
		if (fRead == fFalse)
			{
				if(pVal != NULL)
				{
					LocalFree(pVal);
					pVal = NULL;
				}
			}
		}
		
	return (pVal);
} // PVReadReg()


// BEWARE uses static variable.
PTSTR GetSz(HINSTANCE hInst, WORD wszID)
{
	PTSTR	psz = szStrTable[iSzTable];
	
	iSzTable ++;
	if (iSzTable >= irgMaxSzs)
		iSzTable = 0;
		
	if (!LoadString(hInst, wszID, psz, 256))
		{	// now u could return a error but then everybody will have to check
			// the return value
		//AssertGLE(0);
		*psz = 0;
		}
		
	return (psz);
} // GetSz()


void SetWaitLineCreateEvent(void)
{
	HANDLE hEvent;

	hEvent = OpenEvent(SYNCHRONIZE, fFalse, pcszWaitLineCreate);
	if (hEvent)
		{
		SetEvent(hEvent);
		CloseHandle(hEvent);
		}
}

void CALLBACK LineCallback(DWORD hDevice, DWORD dwMessage, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2, DWORD dwParam3)
{
	switch (dwMessage)
	{
		case LINE_LINEDEVSTATE:
		{
			if (dwParam1 == LINEDEVSTATE_REINIT)
			{
				SetWaitLineCreateEvent();
			}
		}
			break;
	}
} // LineCallback

#define  MAX_RAS_DEVICES   10
#define  SZ_BUF_RET_SZ     256
//
// iModemIndex : Index of Modem Nane required, should be starting from 1 to MAX_RAS_DEVICES
//
//
TCHAR * GetModemDeviceInformation(HINSTANCE hInstance, int iModemIndex)
{

	static  TCHAR  szRetValue[MAX_RAS_DEVICES][SZ_BUF_RET_SZ]
		={	_T(""),_T(""),_T(""),
			_T(""),_T(""),_T(""),
			_T(""),_T(""),_T(""),
			_T("")};
	static  TCHAR szNoModem[] = _T("NOMODEM");
	static  int iFirstTimeCall=0;
	static  int nNoofModemDevice = 0;
		
	RASDEVINFO  *pdi,*pDevInfo;

	DWORD dwSize=0,dwNum=0,dwRet;
	int iEntries;
	int i;

	if( iModemIndex < 1 ) {
		return szNoModem;
	}
	if(iFirstTimeCall == 0 )
	{
		iFirstTimeCall = 1;
		if( ATK_IsRasDllOk() == RAS_DLL_LOADED)
		{
			dwRet = ATK_RasEnumDevices(NULL,&dwSize,&dwNum);
			iEntries = dwSize /sizeof(RASDEVINFO);
		
			pDevInfo = (LPRASDEVINFO)LocalAlloc(LPTR,dwSize);

            if (pDevInfo)
            {
			    pdi = pDevInfo;
			    
			    for(i=0; i< iEntries;i++) {
				    pdi->dwSize = sizeof(RASDEVINFO);
				    pdi++;
			    }
			    dwRet = ATK_RasEnumDevices(pdi,&dwSize,&dwNum);
			    if(dwRet == 0)
			    {
			    
				    for(i=0; i< iEntries;i++)
				    {
					    #ifdef _LOG_IN_FILE
						    RW_DEBUG << "\n Device Name:"<< ConvertToANSIString(pdi->szDeviceName) << flush;
						    RW_DEBUG << "\n Device Type:"<< ConvertToANSIString(pdi->szDeviceType) << flush;
					    #endif

						    if( !_tcscmp(pdi->szDeviceType, RASDT_Modem) )
						    {
							    _tcscpy(szRetValue[nNoofModemDevice],pdi->szDeviceName);
							    nNoofModemDevice++;
							    //i=iEntries+1;
						    }
					    pdi++;
				    }
			    }
			    else
			    {
				    switch(dwRet)
				    {
					    case ERROR_BUFFER_TOO_SMALL:
						    RW_DEBUG <<"\n ERROR_BUFFER_TOO_SMALL"<< flush;
						    break;
					    case ERROR_NOT_ENOUGH_MEMORY:
						    RW_DEBUG <<"\n ERROR_NOT_ENOUGH_MEMORY"<< flush;
						    break;
					    case ERROR_INVALID_PARAMETER:
						    RW_DEBUG <<"\n ERROR_INVALID_PARAMETER"<< flush;
						    break;
					    case ERROR_INVALID_USER_BUFFER :
						    RW_DEBUG <<"\n ERROR_INVALID_USER_BUFFER"<< flush;
						    break;
					    default:
						    RW_DEBUG <<"\n UNKNOWN_ERROR"<< flush;
						    break;
				    }

			    }
			    LocalFree(pDevInfo);
            }
		}
		else
		{
			return szNoModem;
		}	
	}

	// Return the  modem device name
	if( iModemIndex  > nNoofModemDevice ) {
			return szNoModem;
	}else {
			return &szRetValue[iModemIndex-1][0];
	}
		
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\informdlg.cpp ===
/*********************************************************************
Registration Wizard

InformDialog.cpp
10/19/94 - Tracy Ferrier
02/11/98 - Suresh Krishnan
(c) 1994-95 Microsoft Corporation
**********************************************************************/

#include <Windows.h>
#include "RegWizMain.h"
#include "Resource.h"
#include <RegPage.h>
#include "Dialogs.h"
#include "regutil.h"
#include <rw_common.h>

INT_PTR CALLBACK InformDialogProc(HWND hwndDlg, 
					   UINT uMsg, 
					   WPARAM wParam, LPARAM lParam)
/*********************************************************************
Dialog Proc for the Registration Wizard dialog that presents the
Product Identification number to the user.
**********************************************************************/
{
	CRegWizard* pclRegWizard;
	INT_PTR iRet;
	_TCHAR szInfo[256];
    INT_PTR bStatus;

	pclRegWizard = NULL;
	bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
	}

    switch (uMsg)
    {
		case WM_CLOSE:
			if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) pclRegWizard->EndRegWizardDialog(IDB_EXIT);
            break;
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;				

        case WM_INITDIALOG:
		{
			
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pi->iCancelledByUser = RWZ_PAGE_OK;

			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			//SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);
			pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szInfo);
			ReplaceDialogText(hwndDlg,IDT_TEXT2,szInfo);
			return TRUE;
		}
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
				pi->iCancelledByUser = RWZ_PAGE_OK;
                PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
                break;

            case PSN_WIZNEXT:
				if(pi->iCancelledByUser == RWZ_CANCELLED_BY_USER ) {
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);

				}else {
					pi->CurrentPage++;
				}
				break;

            case PSN_WIZBACK:
                pi->CurrentPage--;

                break;
			case PSN_QUERYCANCEL :
				iRet=0;
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet =0;
					iRet = 1;
					pi->ErrorPage  = kInformDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);

				}else {
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;

				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        } // WM_Notify
		break;
		case WM_COMMAND:
        default:
		bStatus = FALSE;
         break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\namedlg.cpp ===
/*********************************************************************
Registration Wizard

NameDialog.cpp
10/13/94 - Tracy Ferrier
02/11/98 - Suresh Krishnan
(c) 1994-95 Microsoft Corporation
Modification History :
	MDX1 :   Suresh
	Date    : 2/12/99
	Function: Modified in void ConfigureNameEditFields(CRegWizard* pclRegWizard,HWND hwndDlg)
	Reason	: The Middle name is set to Null, This looks like the filed validation is not taking
	from the Resoure settings for each TAPI id
**********************************************************************/

#include <Windows.h>
#include "RegPage.h"
#include "RegWizMain.h"
#include "Resource.h"
#include "Dialogs.h"
#include "regutil.h"
#include "rw_common.h"

typedef enum
{
	kPurchaseUndefined,
	kPurchaseBySelf,
	kPurchaseByCompany
}PurchaseType;

static PurchaseType vPurchaseType = kPurchaseUndefined;
void ConfigureNameEditFields(CRegWizard* pclRegWizard,HWND hwndDlg);
BOOL ValidateNameDialog(HWND hwndDlg);
int ValidateNameEditFields(HWND hwndDlg);
BOOL GetDefaultCompanyName(CRegWizard* pclRegWizard,LPTSTR szValue);

INT_PTR CALLBACK NameDialogProc(	HWND hwndDlg,
								UINT uMsg,
								WPARAM wParam,
								LPARAM lParam )
/*********************************************************************
Dialog Proc for the Registration Wizard dialog that requests the
user's name and company.
**********************************************************************/
{
	CRegWizard* pclRegWizard = NULL;
	static INT_PTR iRet;
	_TCHAR szInfo[256];
    INT_PTR bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
	}

    switch (uMsg)
    {

		case WM_CLOSE:
			if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) pclRegWizard->EndRegWizardDialog(IDB_EXIT);
            break;		
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;			
        case WM_INITDIALOG:
		{
			_TCHAR szCallingContext[64];
			
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			RW_DEBUG << "\n  INIT DIALOG " << pi->iCancelledByUser << flush;
			pi->iCancelledByUser = RWZ_PAGE_OK;
			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);

			//UpgradeDlg(hwndDlg);
			
			HWND hwndNameField = GetDlgItem(hwndDlg,IDC_EDIT1);
			SetFocus(hwndNameField);
			NormalizeDlgItemFont(hwndDlg,IDC_SUBTITLE);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT2);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT3);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT4);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT12);
			NormalizeDlgItemFont(hwndDlg,IDC_GROUP1);
			
			SetWindowText(hwndDlg,pclRegWizard->GetWindowCaption());

			pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szCallingContext);
			ReplaceDialogText(hwndDlg,IDT_TEXT1,szCallingContext);
			
			if (pclRegWizard->GetInformationString(kInfoFirstName,szInfo)){
				SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_SETTEXT,0,(LPARAM) szInfo);
				vPurchaseType = kPurchaseBySelf;
			}
			
			if (pclRegWizard->GetInformationString(kInfoLastName,szInfo)){
				SendDlgItemMessage(hwndDlg,IDC_EDIT2,WM_SETTEXT,0,(LPARAM) szInfo);
				vPurchaseType = kPurchaseBySelf;
			}
			if (pclRegWizard->GetInformationString(kMiddleName,szInfo)){
				SendDlgItemMessage(hwndDlg,IDC_EDIT4,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			OutputDebugString(_T("\n Middle Name "));
			OutputDebugString(szInfo);

			if (pclRegWizard->GetInformationString(kInfoEmailName,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT5,WM_SETTEXT,0,(LPARAM) szInfo);
			}

			OutputDebugString(_T("\n Email "));
			OutputDebugString(szInfo);

			BOOL isCompanyNameValid = FALSE;
			if (pclRegWizard->GetInformationString(kInfoCompany,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_SETTEXT,0,(LPARAM) szInfo);
				if (szInfo[0])
				{
					isCompanyNameValid = TRUE;
					vPurchaseType = kPurchaseByCompany;
					CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2);
					EnableWindow(GetDlgItem(hwndDlg,IDC_EDIT3),TRUE);
					EnableWindow(GetDlgItem(hwndDlg,IDT_TEXT4),TRUE);
					EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
				}
				else
				{
					vPurchaseType = kPurchaseBySelf;
					CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1);
					EnableWindow(GetDlgItem(hwndDlg,IDC_EDIT3),FALSE);
					EnableWindow(GetDlgItem(hwndDlg,IDT_TEXT4),FALSE);
					EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
				}
			}
			else
			{
				if(	vPurchaseType != kPurchaseBySelf)
				{
					vPurchaseType = kPurchaseUndefined;
					EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),FALSE);
				}
				else
				{
					CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1);
					EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
				}
			}

			SendDlgItemMessage(hwndDlg,IDC_EDIT1,EM_SETSEL,0,-1);
			ConfigureNameEditFields(pclRegWizard,hwndDlg);
			vDialogInitialized = TRUE;
			//pclRegWizard->ActivateRegWizardDialog();
            return TRUE;
		}
		break;
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
				pi->iCancelledByUser = RWZ_PAGE_OK;
				PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
                break;

            case PSN_WIZNEXT:
				if(pi->iCancelledByUser == RWZ_CANCELLED_BY_USER ) {
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);

				}else {
				// Cancel is not Pressed
					iRet=0;
					if( ValidateNameDialog(hwndDlg)) {
						SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoFirstName,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT2,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoLastName,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoCompany,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT4,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kMiddleName,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT5,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoEmailName,szInfo);
						pclRegWizard->WriteEnableInformation(kInfoCompany,vPurchaseType == kPurchaseBySelf ? FALSE : TRUE);
						pclRegWizard->EndRegWizardDialog(wParam);
						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;
						pi->CurrentPage++;
					
					}else {
						// Force it it be in this screen
						iRet=-1;
					}
					SetWindowLongPtr( hwndDlg ,DWLP_MSGRESULT, (INT_PTR) iRet);
				}
				break;

            case PSN_WIZBACK:
				pi->iLastKeyOperation = RWZ_BACK_PRESSED;
                pi->CurrentPage--;

                break;
			case PSN_QUERYCANCEL :
				iRet=0;
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet = 1;
					pi->ErrorPage  = kNameDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet);
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);

				}else {
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;

				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet);
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        }
        break;
		case WM_COMMAND:{
            if (vPurchaseType == kPurchaseUndefined){
                PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK );
            }
            BOOL selfChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO1);
            BOOL companyChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO2);
            if (selfChecked)
            {
                vPurchaseType = kPurchaseBySelf;
                PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_NEXT | PSWIZB_BACK );
                //EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
            }
            else if (companyChecked)
            {
                vPurchaseType = kPurchaseByCompany;
                PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_NEXT | PSWIZB_BACK);
                // EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
            }
            BOOL shouldEnable = vPurchaseType == kPurchaseByCompany ? TRUE : FALSE;
            HWND hwndCompanyField = GetDlgItem(hwndDlg,IDC_EDIT3);
            HWND hwndCompanyLabel = GetDlgItem(hwndDlg,IDT_TEXT4);
            if (IsWindowEnabled(hwndCompanyField) != shouldEnable)
            {
                EnableWindow(hwndCompanyField,shouldEnable);
                EnableWindow(hwndCompanyLabel,shouldEnable);
                if(!shouldEnable)
                {
                    SetDlgItemText(hwndDlg,IDC_EDIT3,_T(""));
                }
                else
                {
                    SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_GETTEXT,255,
                                                            (LPARAM) szInfo);
                    if(!szInfo[0])
                    {
                        if(GetDefaultCompanyName(pclRegWizard,szInfo))	
                        {
                            SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_SETTEXT,
                                                        255,(LPARAM) szInfo);
                        }
                    }
                }
            }
		 }// WM_COMMAND
		break;
        default:
		bStatus = FALSE;
        break;
    }
    return bStatus;
}


BOOL GetDefaultCompanyName(CRegWizard* pclRegWizard,LPTSTR szValue)
{
	HKEY hKey;
	_TCHAR szKeyName[256];
	
	pclRegWizard->GetRegKey(szKeyName);	
	
	DWORD dwStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szKeyName,0,KEY_READ,&hKey);

	if (dwStatus == ERROR_SUCCESS)
	{
	  _TCHAR szValueName[64];
	  unsigned long infoSize = 255;
	  LoadString(pclRegWizard->GetInstance(),IDS_COMPANY_NAME,szValueName,64);
	  dwStatus = RegQueryValueEx(hKey,szValueName,NULL,0,(LPBYTE) szValue,&infoSize);
	  if (dwStatus == ERROR_SUCCESS)
	  {
		return TRUE;
	  }
	}
	return FALSE;
}

BOOL ValidateNameDialog(HWND hwndDlg)
/*********************************************************************
Returns TRUE if all required user input is valid in the Name
dialog.  If any required edit field input is empty, ValidateNameDialog
will put up a message box informing the user of the problem, and set
the focus to the offending control.
**********************************************************************/
{
	int iInvalidEditField = ValidateNameEditFields(hwndDlg);
	if (iInvalidEditField == NULL)
	{
		return TRUE;
	}
	else
	{
		_TCHAR szAttached[256];
		_TCHAR szMessage[256];
		CRegWizard::GetEditTextFieldAttachedString(hwndDlg,iInvalidEditField,szAttached,256);
		HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndDlg,GWLP_HINSTANCE);
		LoadAndCombineString(hInstance,szAttached,IDS_BAD_PREFIX,szMessage);
		RegWizardMessageEx(hInstance,hwndDlg,IDD_INVALID_DLG,szMessage);
		HWND hwndNameField = GetDlgItem(hwndDlg,iInvalidEditField);
		SetFocus(hwndNameField);
		return FALSE;
	}
}



int ValidateNameEditFields(HWND hwndDlg)
/*********************************************************************
ValidateAddrEditFields validates all edit fields in the Address
dialog.  If any required field is empty, the ID of the edit field
control will be returned as the function result.  If all fields are
OK, NULL will be returned.
**********************************************************************/
{
	
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT1)) return IDC_EDIT1;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT2)) return IDC_EDIT2;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT3)) return IDC_EDIT3;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT4)) return IDC_EDIT4;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT5)) return IDC_EDIT5;
	return NULL;
}

 
void ConfigureNameEditFields(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
**********************************************************************/
{
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT1,kAddrSpecFirstName,IDT_TEXT2);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT2,kAddrSpecLastName,IDT_TEXT3);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT3,kAddrSpecCompanyName,IDT_TEXT4);
	//pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT4,kAddrMiddleName,IDT_TEXT5);	
	// comented on 2/12/99  to take Middle initial
	// MDX1
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT5,kAddrSpecEmailName,IDT_TEXT12);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\invdlg.cpp ===
/*********************************************************************
Registration Wizard

InventoryDialog.cpp
10/21/94 - Tracy Ferrier
02/12/98 - Suresh Krishnan
07/20/98 -  Modified as System Inventory items to be displayed using ListView control
		    and added an Edit control for Computer Manufacturer and Model entry
			EnabelOrDisableSIItems() function sets the flag if the SI info need
			to be sent to the backend

(c) 1994-95 Microsoft Corporation
**********************************************************************/

#include <Windows.h>
#include <stdio.h>
#include "RegPage.h"
#include "regwizmain.h"
#include "resource.h"
#include "dialogs.h"
#include "regutil.h"
#include <sysinv.h>
#include <rw_common.h>

//#include <windowsx.h>
#include <commctrl.h>

// ListVive control related supporting functions
HWND CreateListView(HINSTANCE hInstance,
					HWND hwndParent,
					RECT *pRect);

void AddIconToListView(HINSTANCE hInstance, HWND hwndListView);
BOOL InitListViewHeaders(HINSTANCE hInstance, HWND hwndListView);
BOOL AddSI_ItemsToListView(HWND hwndSIListView, CRegWizard* pRegWizard);
void ConfigureSIEditFields(CRegWizard* pclRegWizard,HWND hwndDlg);

void ConfigureSIEditFields(CRegWizard* pclRegWizard,HWND hwndDlg);
BOOL ValidateSIDialog(CRegWizard* pclRegWizard,HWND hwndDlg);
int ValidateSIEditFields(CRegWizard* pclRegWizard,HWND hwndDlg);

//
void EnabelOrDisableSIItems( BOOL bAction, CRegWizard* pclRegWizard);

void DestroyListViewResources();



#define NO_OF_SI_ITEMS          13
#define NUMBER_OF_SI_ICONS		5
#define NO_SI_ICONS_FORFUTURE   1
#define  MAX_NO_SI_COLUMNS                       2 // Number of columns
#define  MAX_COLUMNITEM_DESCRIPTION_LEN          25 // Length of Description item on header

//
// Global and Static variables

static HIMAGELIST  himlSmall = NULL;
static HIMAGELIST  himlLarge =NULL;

//  This structure that maps the Device Name in the resource with the ICON and corrosponding
//  index in RegWiz to get the Device Description
//
//
typedef struct  SIItemMapping{
	int iResIndexForDevice;
	int iIconIndex;
	InfoIndex  iIndexToGetDeviceDescription;
} _SIItemMapping ;

static _SIItemMapping  SITable[NO_OF_SI_ITEMS]= {
	{IDS_INFOKEY13,0,kInfoProcessor},// Processor
	{IDS_INFOKEY15,1,kInfoTotalRAM}, // Total RAM
	{IDS_INFOKEY16,2,kInfoTotalDiskSpace}, // Total HardDisk Space
	{IDS_INFOKEY17,3,kInfoRemoveableMedia}, // Removable Media
	{IDS_INFOKEY18,4,kInfoDisplayResolution}, // Display Resolution
	{IDS_INFOKEY20,5,kInfoPointingDevice}, // Pointing Device
	{IDS_INFOKEY21,6,kInfoNetwork}, // Network
	{IDS_SCSI_ADAPTER,7,kScsiAdapterInfo}, // SCSI
	{IDS_INFOKEY22,8,kInfoModem}, // Modem
	{IDS_INFOKEY23,9,kInfoSoundCard}, // SoundCard
	{IDS_INFOKEY24,10,kInfoCDROM}, // CD ROM
	{IDS_INFOKEY25,11,kInfoOperatingSystem},  // Operating System
	{IDS_COMPUTER_MODEL,12,kComputerManufacturer}  // Operating System
};

INT_PTR
CALLBACK
SystemInventoryDialogProc(
                          HWND hwndDlg,
                          UINT uMsg,
                          WPARAM wParam,
                          LPARAM lParam
                          )
/*********************************************************************
Dialog Proc for the Registration Wizard dialog that displays system
inventory information, such as processor type, RAM, display type,
network type, etc.
**********************************************************************/
{

      _TCHAR  szInventory[256];
	CRegWizard* pclRegWizard;
	INT_PTR iRet;
	_TCHAR szInfo[256];
    INT_PTR bStatus;
	static HBITMAP fHBitmap = NULL;
	static int iMaxLabelWidth = 0;
	static BOOL fMaxWidthCalcDone = FALSE;
	static int iShowThisPage= DO_SHOW_THIS_PAGE;
	TriState shouldInclude;

	HWND hSI;
	RECT SIRect;
	RECT SICRect,DlgRect,CliDlgRect;
	HWND	hwndSIListView;

	pclRegWizard = NULL;
	bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
	}
	

    switch (uMsg)
    {
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			if(fHBitmap) {
				DeleteObject(fHBitmap);
			}
			fHBitmap = NULL;
			break;
		case WM_CLOSE:
			 break;			
        case WM_INITDIALOG:
		{
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);
			//
			// Check if System Inv DLL is present
			if( CheckSysInvDllPresent() != SYSINV_DLL_PRESENT) {
				iShowThisPage= DO_NOT_SHOW_THIS_PAGE;
			}


			if(iShowThisPage== DO_SHOW_THIS_PAGE) {
				 GetModemString(pclRegWizard->GetInstance(),szInventory);
				 pclRegWizard->SetInformationString(kInfoModem,szInventory);
				 fHBitmap = LoadBitmap(pclRegWizard->GetInstance(),MAKEINTRESOURCE(IDB_SYSINV_ICONS));
				 NormalizeDlgItemFont(hwndDlg,IDC_TITLE,RWZ_MAKE_BOLD);
				 NormalizeDlgItemFont(hwndDlg,IDC_SUBTITLE);
				 NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);
				 NormalizeDlgItemFont(hwndDlg,IDT_TEXT2);
				 NormalizeDlgItemFont(hwndDlg,IDT_TEXT3);
				 NormalizeDlgItemFont(hwndDlg,IDC_RADIO1);
				 NormalizeDlgItemFont(hwndDlg,IDC_RADIO2);
				 SetWindowText(hwndDlg,pclRegWizard->GetWindowCaption());
				 hwndSIListView = GetDlgItem(hwndDlg,IDC_LIST1);
				 AddIconToListView(pclRegWizard->GetInstance(), hwndSIListView);
				if(!hwndSIListView) {
						// Error in creating List view control  so skip to the next page
						// This a system error which should occure
					iShowThisPage= DO_NOT_SHOW_THIS_PAGE;
				}else {
					// Add SI entries
					InitListViewHeaders(pclRegWizard->GetInstance(), hwndSIListView);
					AddSI_ItemsToListView(hwndSIListView,
							pclRegWizard);
					//ConfigureSIEditFields(pclRegWizard,hwndDlg);
				}
				
			}
			

   	        vDialogInitialized = TRUE;
            return TRUE;
		} // WM_INIT
		break;
		
		break;
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
				if( iShowThisPage== DO_NOT_SHOW_THIS_PAGE ) {
					pclRegWizard->SetTriStateInformation(kInfoIncludeSystem,kTriStateFalse);
					pi->iCancelledByUser = RWZ_SKIP_AND_GOTO_NEXT;
					if( pi->iLastKeyOperation == RWZ_BACK_PRESSED){
						PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_BACK);
					}else {
						PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);
					}

				}
				else {
					pi->iCancelledByUser = RWZ_PAGE_OK;
					pi->iLastKeyOperation = RWZ_UNRECOGNIZED_KEYPESS;
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK);

					shouldInclude = pclRegWizard->GetTriStateInformation(kInfoIncludeSystem);
					RW_DEBUG << "INV DLG  ; ACTIVE  " << shouldInclude << flush;
					if (shouldInclude == kTriStateTrue ){
						CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1);
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					}
					else if (shouldInclude == kTriStateFalse){
						CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2);
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					}
					else if (shouldInclude == kTriStateUndefined){
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK);
			
					}
					//
					// Enable for previpously entred value in screen
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO1)){
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					}
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO2)){
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					}
					/*
					//
					// Init Computer Model Field
					if (pclRegWizard->GetInformationString(kComputerManufacturer,szInfo)){
						SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_SETTEXT,0,(LPARAM) szInfo);
					}*/

				}

                break;

            case PSN_WIZNEXT:
					switch(pi->iCancelledByUser) {
					case  RWZ_CANCELLED_BY_USER :
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);
					break;
					case RWZ_PAGE_OK:
						iRet=0;
					/*	if( ValidateInvDialog(hwndDlg,IDS_BAD_SYSINV) &&
							ValidateSIDialog(pclRegWizard,hwndDlg))*/
						if( ValidateInvDialog(hwndDlg,IDS_BAD_SYSINV))
						{
							BOOL yesChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO1);
							BOOL noChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO2);
							if (yesChecked){
								//pclRegWizard->WriteEnableSystemInventory(TRUE);
								// send info to backend
								EnabelOrDisableSIItems(TRUE,pclRegWizard);
								pclRegWizard->SetTriStateInformation(kInfoIncludeSystem,kTriStateTrue);
							}else if (noChecked){
								//pclRegWizard->WriteEnableSystemInventory(FALSE);

								// Do not send to the back end
								EnabelOrDisableSIItems(FALSE,pclRegWizard);
								pclRegWizard->SetTriStateInformation(kInfoIncludeSystem,kTriStateFalse);
							}
						/*
							// Get Computer Model Information
							SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_GETTEXT,255,(LPARAM) szInfo);
							pclRegWizard->SetInformationString(kComputerManufacturer,szInfo);
							RW_DEBUG << "\n Computer Model " << szInfo << flush;
*/
							pi->CurrentPage++;
							pi->iLastKeyOperation = RWZ_NEXT_PRESSED;
						// Set as Next Key Button Pressed
						}else {
						// Force it it be in this screen
							iRet=-1;
						}
						SetWindowLongPtr( hwndDlg ,DWLP_MSGRESULT, (INT_PTR) iRet);
					break;
					case RWZ_SKIP_AND_GOTO_NEXT:
					default:
						// Do not Validate the page and just go to the next page
						pi->CurrentPage++;
						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;

					break;
				} // end of switch pi->iCancelledByUser
				break;
            case PSN_WIZBACK:
                pi->CurrentPage--;
				pi->iLastKeyOperation = RWZ_BACK_PRESSED;
				break;
			case PSN_QUERYCANCEL :
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet = 1;
					pi->ErrorPage  = kSysInventoryDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet);
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					pi->iLastKeyOperation = RWZ_CANCEL_PRESSED;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);

				}else {
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;
				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 				
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        } // WM_Notify
		break;
        case WM_COMMAND:
		{
			switch (wParam)
            {
              case IDC_RADIO2:
			  case IDC_RADIO1:
					if (vDialogInitialized){
						// If the 'No' button is checked, the user is declining
						// the "Non-Microsoft product" offers
						if(IsDlgButtonChecked(hwndDlg,IDC_RADIO1)){
							PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						}
						if(IsDlgButtonChecked(hwndDlg,IDC_RADIO2)){
							PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						}
					}
				break;
			  default:
				  break;
            }
		}// End of WM_COMMAND
        break;
        default:
		bStatus = FALSE;
        break;
    }
    return bStatus;

}



BOOL ValidateInvDialog(HWND hwndDlg,int iStrID)
/*********************************************************************
This function checks the two radio buttons in the System Inventory or
Product Inventory dialog boxes.  If neither button is selected,
ValidateInvDialog will put up a validation error dialog, and return
FALSE as the function result; otherwise, TRUE will be returned.

If an error dialog is presented, the string whose resource ID is
passed in the iStrID parameter will displayed in the dialog text
field.
**********************************************************************/
{
	BOOL isYesChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO1) == 1 ? TRUE : FALSE;
	BOOL isNoChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO2) == 1 ? TRUE : FALSE;

	if (isYesChecked == TRUE || isNoChecked == TRUE)
	{
		return TRUE;
	}
	else
	{
		_TCHAR szMessage[256];
		HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndDlg,GWLP_HINSTANCE);
		LoadString(hInstance,iStrID,szMessage,256);
		RegWizardMessageEx(hInstance,hwndDlg,IDD_INVALID_DLG,szMessage);
		return FALSE;
	}
	


}







//
//
//
//
HWND CreateListView(HINSTANCE hInstance,
					HWND hwndParent,
					RECT *pRect)
{
	DWORD       dwStyle;
	HWND        hwndListView;
	HIMAGELIST  himlSmall;
	HIMAGELIST  himlLarge;
	BOOL        bSuccess = TRUE;
	dwStyle =   WS_TABSTOP  |
				WS_CHILD |
				WS_BORDER |
				LVS_REPORT |//LVS_LIST |
                LVS_SHAREIMAGELISTS | // LVS_NOCOLUMNHEADER |
				WS_VISIBLE;

	hwndListView = CreateWindowEx( WS_EX_CLIENTEDGE | WS_EX_TOPMOST,          // ex style
                                   WC_LISTVIEW,               // class name - defined in commctrl.h
                                   NULL,                      // window text
                                   dwStyle,                   // style
                                   pRect->left,                         // x position
                                   pRect->top,
								   pRect->right,
								   pRect->bottom,
								  //pRect->right - pRect->left, // width
								  //pRect->bottom - pRect->top,//  height
                                   hwndParent,                // parent
                                   (HMENU) IDC_LIST1,       // ID
                                   hInstance,                // instance
                                 NULL);                     // no extra data

   if(!hwndListView)
   return NULL;
	
   AddIconToListView(hInstance, hwndListView);
   return hwndListView;

}


void AddIconToListView( HINSTANCE hInstance, HWND hwndListView )
{
	HICON hIconItem;

	himlSmall = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
		GetSystemMetrics(SM_CYSMICON),TRUE,NUMBER_OF_SI_ICONS,
		NO_SI_ICONS_FORFUTURE);

	himlLarge = ImageList_Create(GetSystemMetrics(SM_CXICON),
		GetSystemMetrics(SM_CYICON),TRUE,NUMBER_OF_SI_ICONS,
		NO_SI_ICONS_FORFUTURE);


	// Add Icon to image List
	for (int i=0; i <NO_OF_SI_ITEMS ;i++ ) {
		hIconItem =  LoadIcon(hInstance, MAKEINTRESOURCE(IDI_SIICON1+i));
		ImageList_AddIcon(himlSmall,hIconItem);
		ImageList_AddIcon(himlLarge,hIconItem);
		DeleteObject(hIconItem );
	}
/***
	hIconItem =  LoadIcon(hInstance, MAKEINTRESOURCE(IDI_BADREGWIZ));
	ImageList_AddIcon(himlSmall,hIconItem);
	ImageList_AddIcon(himlLarge,hIconItem);
	DeleteObject(hIconItem );

	hIconItem =  LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WORLD));
	ImageList_AddIcon(himlSmall,hIconItem);
	ImageList_AddIcon(himlLarge,hIconItem);
	DeleteObject(hIconItem );

	hIconItem =  LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ENVELOPE));
	ImageList_AddIcon(himlSmall,hIconItem);
	ImageList_AddIcon(himlLarge,hIconItem);
	DeleteObject(hIconItem );

	hIconItem =  LoadIcon(hInstance, MAKEINTRESOURCE(IDI_REGWIZ));
	ImageList_AddIcon(himlSmall,hIconItem);
	ImageList_AddIcon(himlLarge,hIconItem);
	DeleteObject(hIconItem );
	**/
	
	// Assign  the image lists  to the list view control
	ListView_SetImageList(hwndListView, himlSmall, LVSIL_SMALL);
	ListView_SetImageList(hwndListView, himlLarge, LVSIL_NORMAL);

}

BOOL InitListViewHeaders(HINSTANCE hInstance, HWND hwndListView)
{
	LV_COLUMN   lvColumn;
	RECT         CliRect;
	int         i = 0;
	TCHAR       szString[MAX_NO_SI_COLUMNS][MAX_COLUMNITEM_DESCRIPTION_LEN] =
	{	 TEXT("Device"),
		 TEXT("Description")
	};

	LoadString(hInstance,IDS_SI_DEVICENAME, szString[0],MAX_COLUMNITEM_DESCRIPTION_LEN);
	LoadString(hInstance,IDS_SI_DEVICEDESCRIPTION, szString[1],MAX_COLUMNITEM_DESCRIPTION_LEN);
	//initialize the columns
	lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvColumn.fmt = LVCFMT_LEFT;
	//lvColumn.cx = 100;
	GetClientRect(hwndListView,&CliRect);

	lvColumn.cx = 133;
	lvColumn.pszText = szString[0];
	SendMessage(hwndListView, LVM_INSERTCOLUMN, (WPARAM)i, (LPARAM)&lvColumn);
	
	i = 1;
	lvColumn.cx = CliRect.right - 149;
	lvColumn.pszText = szString[1];
	SendMessage(hwndListView, LVM_INSERTCOLUMN, (WPARAM)i, (LPARAM)&lvColumn);

   return TRUE;

}



/********************************************************************************

   AddSI_ItemsToLIstVIew
   This function adds the SI items in the list view

******************************************************************************/

BOOL AddSI_ItemsToListView( HWND hwndListView, CRegWizard* pclRegWizard)
{
	LV_ITEM     lvItem;
	int         i,nImageCount;
	TCHAR       szTempDevice[MAX_PATH];
				

	HIMAGELIST  himl;
	IMAGEINFO   ii;
	HINSTANCE hInstance;
	BOOL bOemInfoPresent = TRUE;

	 hInstance = pclRegWizard->GetInstance();

	// SendMessage(hwndListView, WM_SETREDRAW, FALSE, 0);
	//empty the list
	SendMessage(hwndListView, LVM_DELETEALLITEMS, 0, 0);
	//get the number of icons in the image list
	himl = (HIMAGELIST)SendMessage(hwndListView, LVM_GETIMAGELIST, (WPARAM)LVSIL_SMALL, 0);
	nImageCount = ImageList_GetImageCount(himl);
	for(i = 0; i < NO_OF_SI_ITEMS ; i++) {
		// Get Device Name
		LoadString(hInstance,SITable[i].iResIndexForDevice, szTempDevice, 256);
		//fill in the LV_ITEM structure for the first item
		lvItem.mask = LVIF_TEXT | LVIF_IMAGE;
		lvItem.pszText = szTempDevice;
		lvItem.iImage = SITable[i].iIconIndex;
		lvItem.iItem = (INT)SendMessage(hwndListView, LVM_GETITEMCOUNT, 0, 0);
		lvItem.iSubItem = 0;
	   //add the item - get the index in case the ListView is sorted
		SendMessage(hwndListView, LVM_INSERTITEM, (WPARAM)0, (LPARAM)&lvItem);

	   //GetDevice Description
		if(!pclRegWizard->GetInformationString(SITable[i].iIndexToGetDeviceDescription,
			szTempDevice))
		{
			if(i == 12)
			{
				bOemInfoPresent = FALSE;
			}

			LoadString(hInstance,IDS_SYSINV_NOTFOUND,szTempDevice, 256);
		}
		lvItem.iSubItem = 1;
		SendMessage(hwndListView, LVM_SETITEM, 0, (LPARAM)&lvItem);
		
   	}
	
	if(!bOemInfoPresent)
	{
		ListView_DeleteItem(hwndListView,12);
	}

	SendMessage(hwndListView, WM_SETREDRAW, TRUE, 0);
	UpdateWindow(hwndListView);
	//EnableWindow(hwndListView, FALSE);
	return TRUE;
}


//
//  This function should be called before exiting RegWiz this will release the resources allocated
//  for list view control (image list)
//
//
void DestroyListViewResources()
{
	if(himlSmall) {
		ImageList_Destroy(himlSmall);
		himlSmall = NULL;
	}
	if(himlLarge) {
		ImageList_Destroy(himlLarge);
		himlLarge = NULL;
	}

}

//
//    bAction : TRUE  ( Enabel send info to  backend)
//              FALSE ( Do not send info to backend )
//
//

void EnabelOrDisableSIItems( BOOL bAction, CRegWizard* pclRegWizard)
{

	int iIndex;
	// Itens in the List View Control
	for(iIndex = 0; iIndex < NO_OF_SI_ITEMS ; iIndex++) {
		pclRegWizard->WriteEnableInformation(SITable[iIndex].iIndexToGetDeviceDescription,
			bAction);

	}
	// Computer Model
//	pclRegWizard->WriteEnableInformation(kComputerManufacturer, bAction);

}

//BOOL ValidateSIDialog(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
Returns TRUE if all required user input is valid in the Address
dialog.  If any required edit field input is empty, ValidateAddrDialog
will put up a message box informing the user of the problem, and set
the focus to the offending control.
**********************************************************************/
/*{
	int iInvalidEditField = ValidateSIEditFields(pclRegWizard,hwndDlg);
	if (iInvalidEditField == NULL)
	{
		return TRUE;
	}
	else
	{
		_TCHAR szLabel[128];
		_TCHAR szMessage[256];
		CRegWizard::GetEditTextFieldAttachedString(hwndDlg,iInvalidEditField,szLabel,128);
		HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndDlg,GWLP_HINSTANCE);
		LoadAndCombineString(hInstance,szLabel,IDS_BAD_PREFIX,szMessage);
		RegWizardMessageEx(hInstance,hwndDlg,IDD_INVALID_DLG,szMessage);
		HWND hwndInvField = GetDlgItem(hwndDlg,iInvalidEditField);
		SetFocus(hwndInvField);
		return FALSE;
	}
}*/


//int ValidateSIEditFields(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
ValidateFEAddrEditFields validates all edit fields in the Address
dialog.  If any required field is empty, the ID of the first empty
edit field control will be returned as the function result.  If all
fields are OK, NULL will be returned.
**********************************************************************/
/*{

	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT1)) return IDC_EDIT1;
	return NULL;
}


void ConfigureSIEditFields(CRegWizard* pclRegWizard,HWND hwndDlg)
{
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT1,kSIComputerManufacturer,IDC_COMPUTER_MODEL);
}*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\name_fe.cpp ===
/*********************************************************************
Registration Wizard

Name_FE.cpp
03/11/98 - Suresh Krishanan
Name Screen for Far East Countries

Specification : 02/28/98
	- The Pronunciation field is enable only for JAPAN and for other
	FE countries it is disabled.

	- The USER ID is only for JAPAN and for other FarEast countries
	it should be deleted i.e do not display.

	- While sending the information to the back end, the name will
	be sent as FirstName and the Pronunciation will be
	sent as Last Name.
(c) 1994-95 Microsoft Corporation
**********************************************************************/

#include <Windows.h>
#include "RegPage.h"
#include "RegWizMain.h"
#include "Resource.h"
#include "Dialogs.h"
#include "regutil.h"
#include "rw_common.h"
#include <fe_util.h>


typedef enum
{
	kPurchaseUndefined,
	kPurchaseBySelf,
	kPurchaseByCompany
}PurchaseType;

static PurchaseType vPurchaseType = kPurchaseUndefined;
void ConfigureFENameEditFields(CRegWizard* pclRegWizard,HWND hwndDlg);
BOOL ValidateFENameDialog(HWND hwndDlg);
int ValidateFENameEditFields(HWND hwndDlg);
BOOL GetDefaultCompanyName(CRegWizard* pclRegWizard,LPTSTR szValue);

INT_PTR CALLBACK NameFEDialogProc(	HWND hwndDlg,
								UINT uMsg,
								WPARAM wParam,
								LPARAM lParam )
/*********************************************************************
Dialog Proc for the Registration Wizard dialog that requests the
user's name and company.
**********************************************************************/
{
	CRegWizard* pclRegWizard = NULL;
	static INT_PTR iRet;
	_TCHAR szInfo[256];
    BOOL bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
	}

    switch (uMsg)
    {

		case WM_CLOSE:
			if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) pclRegWizard->EndRegWizardDialog(IDB_EXIT);
            break;		
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;			
        case WM_INITDIALOG:
		{
			_TCHAR szCallingContext[64];
			
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			RW_DEBUG << "\n  INIT DIALOG " << pi->iCancelledByUser << flush;
			pi->iCancelledByUser = RWZ_PAGE_OK;
			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);

			//UpgradeDlg(hwndDlg);
			
			
			NormalizeDlgItemFont(hwndDlg,IDC_SUBTITLE);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT2);
			
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT4); // Company
			NormalizeDlgItemFont(hwndDlg,IDT_DIVISION); //Division

			if(GetFeScreenType() == kFEWithJapaneaseScreen ) {
				// Enable USER ID
				ShowWindow(GetDlgItem(hwndDlg,IDT_USERID),SW_SHOW);
				ShowWindow(GetDlgItem(hwndDlg,IDC_USERID), SW_SHOW);
				EnableWindow (GetDlgItem(hwndDlg,IDC_USERID), TRUE);
				NormalizeDlgItemFont(hwndDlg,IDT_USERID); //Division
			}

			NormalizeDlgItemFont(hwndDlg,IDC_GROUP1);
			
			SetWindowText(hwndDlg,pclRegWizard->GetWindowCaption());

			//pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szCallingContext);
			//ReplaceDialogText(hwndDlg,IDT_TEXT1,szCallingContext);
			
			if (pclRegWizard->GetInformationString(kInfoFirstName,szInfo)){
				SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_SETTEXT,0,(LPARAM) szInfo);
				vPurchaseType = kPurchaseBySelf;
			}


			if(GetFeScreenType() == kFEWithJapaneaseScreen ) {
				// FOR JAPAN fill the Pronunciation info  and User ID
				if (pclRegWizard->GetInformationString(kInfoLastName,szInfo)){
					SendDlgItemMessage(hwndDlg,IDC_EDIT2,WM_SETTEXT,0,(LPARAM) szInfo);
				}
				if (pclRegWizard->GetInformationString(kUserId,szInfo)){
					SendDlgItemMessage(hwndDlg,IDC_USERID,WM_SETTEXT,0,(LPARAM) szInfo);
				}
			}else {
				//
				// Disable Pronunciation for other FE countries
				EnableWindow(GetDlgItem(hwndDlg,IDC_EDIT2),FALSE);
				EnableWindow(GetDlgItem(hwndDlg,IDT_TEXT3),FALSE);
			}


             // fix 381069

            if (pclRegWizard->GetInformationString(kInfoEmailName,szInfo))
            {
                SendDlgItemMessage(hwndDlg,IDC_EDIT4,WM_SETTEXT,0,(LPARAM) szInfo);
            }			
			
			BOOL isCompanyNameValid = FALSE;
			if (pclRegWizard->GetInformationString(kInfoCompany,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_SETTEXT,0,(LPARAM) szInfo);
				if (szInfo[0])
				{
					isCompanyNameValid = TRUE;
					vPurchaseType = kPurchaseByCompany;
					CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2);
					EnableWindow(GetDlgItem(hwndDlg,IDC_EDIT3),TRUE);
					SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_SETTEXT,0,(LPARAM) szInfo);
					EnableWindow(GetDlgItem(hwndDlg,IDT_TEXT4),TRUE);
					EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
					// Enable  Division Name
					EnableWindow(GetDlgItem(hwndDlg,IDC_DIVISION),TRUE);
					EnableWindow(GetDlgItem(hwndDlg,IDT_DIVISION),TRUE);
					//
					//
					if (pclRegWizard->GetInformationString(kDivisionName,szInfo)){
						SendDlgItemMessage(hwndDlg,IDC_DIVISION,WM_SETTEXT,0,(LPARAM) szInfo);
					}

				}
				else
				{
					vPurchaseType = kPurchaseBySelf;
					CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1);
					EnableWindow(GetDlgItem(hwndDlg,IDC_EDIT3),FALSE);
					EnableWindow(GetDlgItem(hwndDlg,IDT_TEXT4),FALSE);
					EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
					// Disable Division Name
					EnableWindow(GetDlgItem(hwndDlg,IDC_DIVISION),FALSE);
				}
			}
			else
			{
				if(	vPurchaseType != kPurchaseBySelf)
				{
					vPurchaseType = kPurchaseUndefined;
					EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),FALSE);
				}
				else
				{
					CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1);
					EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
				}
			}

			SendDlgItemMessage(hwndDlg,IDC_EDIT1,EM_SETSEL,0,-1);
			ConfigureFENameEditFields(pclRegWizard,hwndDlg);

			HWND hwndNameField = GetDlgItem(hwndDlg,IDC_EDIT1);
			SetFocus(hwndNameField);

			vDialogInitialized = TRUE;
			//pclRegWizard->ActivateRegWizardDialog();
            return TRUE;
		}
		break;
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
				pi->iCancelledByUser = RWZ_PAGE_OK;
				PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
                break;

            case PSN_WIZNEXT:
				if(pi->iCancelledByUser == RWZ_CANCELLED_BY_USER ) {
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);

				}else {
				// Cancel is not Pressed
					iRet=0;
					if( ValidateFENameDialog(hwndDlg)) {
						SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoFirstName,szInfo);
						// pronunciation
						if ( GetFeScreenType() == kFEWithJapaneaseScreen ) {
							SendDlgItemMessage(hwndDlg,IDC_EDIT2,WM_GETTEXT,255,(LPARAM) szInfo);
							pclRegWizard->SetInformationString(kInfoLastName,szInfo);
						}

						SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoCompany,szInfo);

						// Division
						SendDlgItemMessage(hwndDlg,IDC_DIVISION,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kDivisionName,szInfo);

                        // E-mail:  fix 381069 
 
                        SendDlgItemMessage(hwndDlg,IDC_EDIT4,WM_GETTEXT,255,(LPARAM) szInfo);
                        pclRegWizard->SetInformationString(kInfoEmailName,szInfo);
						
						// User ID
						if ( GetFeScreenType() == kFEWithJapaneaseScreen ) {
							SendDlgItemMessage(hwndDlg,IDC_USERID,WM_GETTEXT,255,(LPARAM) szInfo);
							pclRegWizard->SetInformationString(kUserId,szInfo);
						}


						pclRegWizard->WriteEnableInformation(kInfoCompany,vPurchaseType == kPurchaseBySelf ? FALSE : TRUE);
						// pclRegWizard->EndRegWizardDialog(wParam);
						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;
						pi->CurrentPage++;
					
					}else {
						// Force it it be in this screen
						iRet=-1;
					}
					SetWindowLongPtr( hwndDlg ,DWLP_MSGRESULT, (INT_PTR) iRet);
				}
				break;

            case PSN_WIZBACK:
				pi->iLastKeyOperation = RWZ_BACK_PRESSED;
                pi->CurrentPage--;

                break;
			case PSN_QUERYCANCEL :
				iRet=0;
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet = 1;
					pi->ErrorPage  = kNameDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet);
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);

				}else {
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;

				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet);
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        }
        break;
		case WM_COMMAND:{
            if (vPurchaseType == kPurchaseUndefined){
                PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK );
            }
            BOOL selfChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO1);
            BOOL companyChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO2);
            if (selfChecked)
            {
                vPurchaseType = kPurchaseBySelf;
                PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_NEXT | PSWIZB_BACK );
                //EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
            }
            else if (companyChecked)
            {
                vPurchaseType = kPurchaseByCompany;
                PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_NEXT | PSWIZB_BACK);
                // EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
            }
            BOOL shouldEnable = vPurchaseType == kPurchaseByCompany ? TRUE : FALSE;
            HWND hwndCompanyField = GetDlgItem(hwndDlg,IDC_EDIT3);
            HWND hwndCompanyLabel = GetDlgItem(hwndDlg,IDT_TEXT4);
            if (IsWindowEnabled(hwndCompanyField) != shouldEnable)
            {
                EnableWindow(hwndCompanyField,shouldEnable);
                EnableWindow(hwndCompanyLabel,shouldEnable);
                // Division enable
                EnableWindow(GetDlgItem(hwndDlg,IDT_DIVISION),shouldEnable);
                EnableWindow(GetDlgItem(hwndDlg,IDC_DIVISION),shouldEnable);

                if(!shouldEnable)
                {
                    SetDlgItemText(hwndDlg,IDC_EDIT3,_T(""));
                    SetDlgItemText(hwndDlg,IDC_DIVISION,_T(""));
                }
                else
                {
                    SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_GETTEXT,255,
                                                            (LPARAM) szInfo);
                    if(!szInfo[0])
                    {
                        if(GetDefaultCompanyName(pclRegWizard,szInfo))	
                        {
                            SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_SETTEXT,
                                                        255,(LPARAM) szInfo);
                        }
                    }
                }
            }
		 }// WM_COMMAND
		break;
        default:
		bStatus = FALSE;
        break;
    }
    return bStatus;
}


BOOL ValidateFENameDialog(HWND hwndDlg)
/*********************************************************************
Returns TRUE if all required user input is valid in the Name
dialog.  If any required edit field input is empty, ValidateFENameDialog
will put up a message box informing the user of the problem, and set
the focus to the offending control.
**********************************************************************/
{
	int iInvalidEditField = ValidateFENameEditFields(hwndDlg);
	if (iInvalidEditField == NULL)
	{
		return TRUE;
	}
	else
	{
		_TCHAR szAttached[256];
		_TCHAR szMessage[256];
		CRegWizard::GetEditTextFieldAttachedString(hwndDlg,iInvalidEditField,szAttached,256);
		HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndDlg,GWLP_HINSTANCE);
		LoadAndCombineString(hInstance,szAttached,IDS_BAD_PREFIX,szMessage);
		RegWizardMessageEx(hInstance,hwndDlg,IDD_INVALID_DLG,szMessage);
		HWND hwndNameField = GetDlgItem(hwndDlg,iInvalidEditField);
		SetFocus(hwndNameField);
		return FALSE;
	}
}



int ValidateFENameEditFields(HWND hwndDlg)
/*********************************************************************
ValidateAddrEditFields validates all edit fields in the Address
dialog.  If any required field is empty, the ID of the edit field
control will be returned as the function result.  If all fields are
OK, NULL will be returned.
**********************************************************************/
{
	
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT1)) return IDC_EDIT1;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT2)) return IDC_EDIT2;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT3)) return IDC_EDIT3;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_DIVISION)) return IDC_DIVISION;
	if (GetFeScreenType() == kFEWithJapaneaseScreen ) {
		if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_USERID)) return IDC_USERID;
	}
	return NULL;
}


void ConfigureFENameEditFields(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
**********************************************************************/
{
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT1,kAddrSpecFirstName,IDT_TEXT2);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT2,kAddrSpecLastName,IDT_TEXT3);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT3,kAddrSpecCompanyName,IDT_TEXT4);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_DIVISION,kAddrSpecDivision,IDT_DIVISION);
	if(GetFeScreenType() == kFEWithJapaneaseScreen ) {
		pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_USERID,kAddrSpecUserId,IDT_USERID);

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\pr_psswd.cpp ===
/*

	File : PR_PSSWD.CPP
	
	Module for Displaying and getting the  Username and password for
	Proxy Server

*/


#include <Windows.h>
#include <tchar.h>
#include "RegWizMain.h"
#include "Resource.h"
#include "Dialogs.h"
#include "regutil.h"
#include "sysinv.h"
#include "rw_common.h"

#define MAX_USR_NAME_SZ   48
#define MAX_PSSWD_SZ      48
#define MAX_PRXOY_SRV_SZ  48

typedef struct _TmpProxyInfo{

	TCHAR  m_User[MAX_USR_NAME_SZ];
	TCHAR  m_Passwd[MAX_PSSWD_SZ];
	TCHAR  m_PrxySrv[MAX_PRXOY_SRV_SZ];
	HINSTANCE m_hInst;
}__TMPXX;

static _TmpProxyInfo  sPrInf;

INT_PTR CALLBACK  DisplayProxyAuthentication(
				HWND hDlg, 			//dialog window
				UINT uMsg,
				WPARAM wParam,
				LPARAM lParam
			)
			

{
	TCHAR szInfo[256];
	DWORD	dwEnd = 0;
	BOOL	fRet = TRUE;
	HWND hwndParent ;
	switch(uMsg){
		case WM_INITDIALOG:	
			
			RECT parentRect,dlgRect;
		
			hwndParent = GetParent(hDlg);
						
			if (hwndParent)
			{
				GetWindowRect(hwndParent,&parentRect);
				GetWindowRect(hDlg,&dlgRect);
				int newX = parentRect.left + (parentRect.right - parentRect.left)/2 - (dlgRect.right - dlgRect.left)/2;
				int newY = parentRect.top + (parentRect.bottom - parentRect.top)/2 - (dlgRect.bottom - dlgRect.top)/2;
				MoveWindow(hDlg,newX,newY,dlgRect.right - dlgRect.left,dlgRect.bottom - dlgRect.top,FALSE);
			}
			else
			{
				int horiz,vert;
				GetDisplayCharacteristics(&horiz,&vert,NULL);
				GetWindowRect(hDlg,&dlgRect);
				int newX = horiz/2 - (dlgRect.right - dlgRect.left)/2;
				int newY = vert/2 - (dlgRect.bottom - dlgRect.top)/2;
				MoveWindow(hDlg,newX,newY,dlgRect.right - dlgRect.left,dlgRect.bottom - dlgRect.top,FALSE);
			}
			NormalizeDlgItemFont(hDlg,IDC_TEXT1);
			
			//SetWindowText(hDlg,szWindowsCaption);

		
			if(sPrInf.m_User)
				SendDlgItemMessage(hDlg,IDC_USERNAME,WM_SETTEXT,0,(LPARAM) sPrInf.m_User);

			if(sPrInf.m_Passwd)
				SendDlgItemMessage(hDlg,IDC_PASSWORD,WM_SETTEXT,0,(LPARAM) sPrInf.m_Passwd);
			ReplaceDialogText(hDlg,IDC_TEXT1,sPrInf.m_PrxySrv);
			SendDlgItemMessage(hDlg,IDC_USERNAME,EM_SETSEL,0,-1);
			return TRUE;
  			goto LReturn;
			break;
		case WM_COMMAND:
		switch (LOWORD(wParam)){
			case IDOK  :
				SendDlgItemMessage(hDlg,IDC_USERNAME,WM_GETTEXT,255,
					(LPARAM) szInfo);
				_tcscpy(sPrInf.m_User,szInfo);

				SendDlgItemMessage(hDlg,IDC_PASSWORD,WM_GETTEXT,255,
					(LPARAM) szInfo);
				_tcscpy(sPrInf.m_Passwd,szInfo);
				goto LEnd;

			case IDCANCEL:
				dwEnd = 1;
				goto LEnd;
			default:
				fRet = FALSE;
				goto LReturn;
			}
		break;
		default :
		fRet = FALSE;
		goto LReturn;
		break;
	}
LEnd:
	EndDialog(hDlg,dwEnd);
LReturn:	
	return fRet;
}








//
//  returns 1 if Cancel is pressed
//

DWORD_PTR GetProxyAuthenticationInfo(HINSTANCE hIns,TCHAR *czProxy,
								 TCHAR *czUserName,TCHAR *czPswd)
{
	DWORD_PTR dwRet;	

	RW_DEBUG << "\n Invoking PROXY DIALOG "  <<  flush;

	sPrInf.m_hInst = hIns;
	if(czProxy) {
		_tcscpy(sPrInf.m_PrxySrv,czProxy);
	}
	else {
		//
		// Return from mfunction without displaying the Dld
		return -1;

	}
	if(czUserName) {
		_tcscpy(sPrInf.m_User,czUserName);
	}else {
		sPrInf.m_User[0] = _T('\0');
	}
	if(czPswd) {
		_tcscpy(sPrInf.m_Passwd,czPswd);
	}else {
		sPrInf.m_Passwd[0] = _T('\0');
	}

	dwRet=DialogBoxParam(hIns, MAKEINTRESOURCE(IDD_PROXY_LOG), NULL,DisplayProxyAuthentication,
			 (LPARAM)hIns);

	if(dwRet == -1 ) {
			 // Error in creating the Dialogue
		return 0;
	
	}

	//
	// Get from the Dialog
	if(sPrInf.m_User) {
		_tcscpy(czUserName, sPrInf.m_User);
	}else {
		czUserName[0] = _T('\0');
	}
	if(sPrInf.m_Passwd) {
		_tcscpy(czPswd,sPrInf.m_Passwd);
	}else {
		czPswd[0] = _T('\0');
	}
	RW_DEBUG << "\nAfter PROXY DIALOG \tUser[" << czUserName  << "]" << flush;
    //RW_DEBUG << "\n\t\tPassword[" << czPswd <<"]" << flush;
	return dwRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\pinvdlg.cpp ===
/*********************************************************************
Registration Wizard

ProdInventoryDialog.cpp
10/21/94 - Tracy Ferrier
02/12/98 - Suresh Krishnan
(c) 1994-95 Microsoft Corporation
**********************************************************************/

#include <Windows.h>
#include <stdio.h>
#include "RegPage.h"
#include "regwizmain.h"
#include "resource.h"
#include "dialogs.h"
#include "regutil.h"
#include <rw_common.h>

static HWND vhwndProdInvDlg = NULL;
static BOOL vProdInvListBusy = FALSE;

void DrawProdInventoryCell(CRegWizard* pclRegWizard,HDC hDC,INT_PTR productIndex, RECT* rc);
void BuildInventoryList(CRegWizard* pclRegWizard);


INT_PTR CALLBACK ProdInventoryDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
/*********************************************************************
Dialog Proc for the dialog that displays product information found by
Registration Wizard.
**********************************************************************/
{
	CRegWizard* pclRegWizard;
	INT_PTR iRet;
	_TCHAR szInfo[256];
	INT_PTR bStatus;
	static int iShowThisPage= DO_SHOW_THIS_PAGE;

	pclRegWizard = NULL;
	bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
	}
	switch (uMsg)
    {
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			vhwndProdInvDlg = NULL;
			break;
		case WM_CLOSE:
			 break;			
        case WM_INITDIALOG:
		{
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			
			//
			//
			// Verify is it necessary to show thi spage
			short productCount = pclRegWizard->GetProductCount();
			TriState prodSearchStatus = pclRegWizard->GetProductSearchStatus();
			TriState includeProdInventory = pclRegWizard->GetTriStateInformation(kInfoIncludeProducts);
			BOOL validSearch = productCount > 0;

			if ((validSearch == TRUE && includeProdInventory != kTriStateUndefined)){
				//
				// Ok continue Displaying
				iShowThisPage= DO_SHOW_THIS_PAGE;
				
			}else {
				//
				// Set To cancel
				iShowThisPage= DO_NOT_SHOW_THIS_PAGE;
			}
			

			//
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);
			vhwndProdInvDlg = hwndDlg;
			NormalizeDlgItemFont(hwndDlg,IDC_TITLE ,RWZ_MAKE_BOLD);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);
			NormalizeDlgItemFont(hwndDlg,IDC_GROUP1);
			NormalizeDlgItemFont(hwndDlg,IDC_GROUP2);
			NormalizeDlgItemFont(hwndDlg,IDC_RADIO1);
			NormalizeDlgItemFont(hwndDlg,IDC_RADIO2);
			SetWindowText(hwndDlg,pclRegWizard->GetWindowCaption());
			TriState shouldInclude = pclRegWizard->GetTriStateInformation(kInfoIncludeProducts);
			if (shouldInclude == kTriStateTrue )
			{
				CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1);
				//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
			}
			else if (shouldInclude == kTriStateFalse)
			{
				CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2);
				//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
			}
			else if (shouldInclude == kTriStateUndefined)
			{
				CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2);
				//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),FALSE);
			}
			
			
			BuildInventoryList(pclRegWizard);
			vDialogInitialized = TRUE;
            return TRUE;
		}// WM_INIT
		case WM_DRAWITEM:
		{
			const kMaxFirstColumnIndex = 5;
			const kMaxProductsPerColumn = 6;
			const kTextAreaWidth = 110;
			const kIconAreaWidth = 32;
			LPDRAWITEMSTRUCT	lpDraw = (LPDRAWITEMSTRUCT) lParam;
			if (lpDraw->itemAction == ODA_DRAWENTIRE)
			{
				RECT rcLine = lpDraw->rcItem;
				INT_PTR listItem = lpDraw->itemData;
				int itemHeight = rcLine.bottom - rcLine.top;
				int lastProductIndex = pclRegWizard->GetProductCount() - 1;

				if (listItem <= kMaxFirstColumnIndex)
				{
					RECT cellRect = rcLine;
					if (lastProductIndex > kMaxFirstColumnIndex)
					{
						cellRect.right = cellRect.left + kTextAreaWidth + kIconAreaWidth;
					}
					DrawProdInventoryCell(pclRegWizard,lpDraw->hDC,listItem,&cellRect);
					if (lastProductIndex >= listItem + kMaxProductsPerColumn)
					{
						cellRect = rcLine;
						cellRect.left = rcLine.right >> 1;
						cellRect.right = cellRect.left + kTextAreaWidth + kIconAreaWidth;
						DrawProdInventoryCell(pclRegWizard,lpDraw->hDC,listItem + kMaxProductsPerColumn,&cellRect);
					}
					if (lastProductIndex > kMaxFirstColumnIndex)
					{
						WORD grayScale = 210;
						HPEN hPen = CreatePen(PS_DOT,1,RGB(grayScale,grayScale,grayScale));
						SelectObject(lpDraw->hDC,hPen);
						
						#ifdef USE_HORIZ_LINES
						MoveToEx(lpDraw->hDC,rcLine.left,rcLine.bottom - 1,NULL);
						LineTo(lpDraw->hDC,rcLine.right,rcLine.bottom - 1);
						#endif

						RECT rcListbox;
						GetClientRect(lpDraw->hwndItem,&rcListbox);
						WORD hPos = (WORD)((rcListbox.right >> 1) - 2);
						MoveToEx(lpDraw->hDC,hPos,rcListbox.top,NULL);
						LineTo(lpDraw->hDC,hPos,rcListbox.bottom);
						MoveToEx(lpDraw->hDC,hPos-2,rcListbox.top,NULL);
						LineTo(lpDraw->hDC,hPos-2,rcListbox.bottom);
						DeleteObject(hPen);
					}
				}
			}
			break;
		}
		break;
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
				if( iShowThisPage== DO_NOT_SHOW_THIS_PAGE ) {
					pclRegWizard->SetTriStateInformation(kInfoIncludeProducts,kTriStateFalse);
					pi->iCancelledByUser = RWZ_SKIP_AND_GOTO_NEXT;
					if( pi->iLastKeyOperation == RWZ_BACK_PRESSED){
						PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_BACK);
					}else {
						PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);
					}

				}
				else {
	                pi->iCancelledByUser = RWZ_PAGE_OK;
					pi->iLastKeyOperation = RWZ_UNRECOGNIZED_KEYPESS;
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
				}
                break;

            case PSN_WIZNEXT:
				switch(pi->iCancelledByUser) {
				case RWZ_CANCELLED_BY_USER:
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);
					break;
				case RWZ_PAGE_OK:
					iRet=0;
					if( ValidateInvDialog(hwndDlg,IDS_BAD_SYSINV)) {
						BOOL yesChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO1);
						BOOL noChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO2);
						if (yesChecked){
							pclRegWizard->SetTriStateInformation(kInfoIncludeProducts,kTriStateTrue);
						}else if (noChecked){
							pclRegWizard->SetTriStateInformation(kInfoIncludeProducts,kTriStateFalse);
						}
						pi->CurrentPage++;
						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;
						// Set as Next Key Button Pressed
					}else {
						// Force it it be in this screen
						iRet=-1;
					}
					SetWindowLongPtr( hwndDlg ,DWLP_MSGRESULT, (INT_PTR) iRet);
					break;
					case RWZ_SKIP_AND_GOTO_NEXT:
					default:
						// Do not Validate the page and just go to the next page
						pi->CurrentPage++;
						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;
						
					break;
				}

				break;
            case PSN_WIZBACK:
                pi->CurrentPage--;
				pi->iLastKeyOperation = RWZ_BACK_PRESSED;
                break;
			case PSN_QUERYCANCEL :
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet = 1;
					pi->ErrorPage  = kProductInventoryDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet);
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					pi->iLastKeyOperation = RWZ_CANCEL_PRESSED;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);

				}else {
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;
				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 				
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        } // WM_Notify
		break;
		case WM_COMMAND:
		{
            if (vDialogInitialized)
            {
                // If the 'No' button is checked, the user is declining
                // the "Non-Microsoft product" offers
                if(IsDlgButtonChecked(hwndDlg,IDC_RADIO1)){
                     PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_NEXT | PSWIZB_BACK);
                    //EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
                }else
                if(IsDlgButtonChecked(hwndDlg,IDC_RADIO2)){
                    PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_NEXT | PSWIZB_BACK);
                    //EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
                }else{
                    PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK);
                    //EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),FALSE);
                }

            }
		}
		break;
        default:
		bStatus = FALSE;
        break;
    }
    return bStatus;
}

void BuildInventoryList(CRegWizard* pclRegWizard)
/*********************************************************************
Dialog Proc for the dialog that displays product information found by
Registration Wizard.
**********************************************************************/
{
	if (vhwndProdInvDlg)
	{
		vProdInvListBusy = TRUE;
		SendDlgItemMessage(vhwndProdInvDlg,IDC_LIST1,LB_RESETCONTENT,0,0);
		short productCount = pclRegWizard->GetProductCount();
		WORD wExtraSpace = ((6 - productCount) > 0 ? (6 - productCount) : 0) * 4;
		if (wExtraSpace > 8) wExtraSpace = 8;
		SendDlgItemMessage(vhwndProdInvDlg,IDC_LIST1,LB_SETITEMHEIGHT,0,36 + wExtraSpace);
		for (short x = 0;x < productCount;x++)
		{
			SendDlgItemMessage(vhwndProdInvDlg,IDC_LIST1,LB_ADDSTRING,0,(LPARAM) x);
		}
		vProdInvListBusy = FALSE;
	}
}


void DrawProdInventoryCell(CRegWizard* pclRegWizard, HDC hDC, INT_PTR productIndex, RECT* rc)
/*********************************************************************
Dialog Proc for the dialog that displays product information found by
Registration Wizard.
**********************************************************************/
{
	RECT rcCell = *rc;
	const kNameTab = 38;
	const kIconHeight = 32;
	_TCHAR szProductName[90];
	pclRegWizard->GetProductName(szProductName,productIndex);
	HICON hIcon = pclRegWizard->GetProductIcon(productIndex);
	WORD wIconTop = (WORD)(rcCell.top + (rcCell.bottom - rcCell.top - kIconHeight)/2);
	DrawIcon(hDC,rcCell.left + 2,wIconTop,hIcon);
	
	rcCell.left += kNameTab;

	SIZE sTextSize;
	GetTextExtentPoint32(hDC,szProductName,lstrlen(szProductName),&sTextSize);
	WORD wLineCount = sTextSize.cx > (rcCell.right - rcCell.left) ? 2 : 1;
	WORD wTextHeight = (WORD)(sTextSize.cy * wLineCount);
	rcCell.top += (rcCell.bottom - rcCell.top - wTextHeight)/2;
	DrawText(hDC,szProductName,-1,&rcCell,DT_LEFT | DT_WORDBREAK);
}


void RefreshInventoryList(CRegWizard* pclRegWizard)
/*********************************************************************
If the product inventory dialog is currently active, the given
product name will be added to the product list box.
**********************************************************************/
{
	while (vhwndProdInvDlg && vProdInvListBusy)
	{
		MSG msg;
		PeekMessage(&msg,NULL,0,0,PM_NOREMOVE);
	}
	if (vhwndProdInvDlg)
	{
		#ifdef _DEBUG
		MessageBeep(0xFFFFFFFF);
		#endif
		BuildInventoryList(pclRegWizard);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\reseldlg.cpp ===
/*********************************************************************
Registration Wizard

ResellerDialog
10/19/94 - Tracy Ferrier
02/12/98 - Suresh Krishnan
(c) 1994-95 Microsoft Corporation
**********************************************************************/

#include <Windows.h>
#include <stdio.h>
#include <RegPage.h>
#include "RegWizMain.h"
#include "Resource.h"
#include "Dialogs.h"
#include "regutil.h"
#include  <rw_common.h>

static int vDeclineOffers = -1;
static PROPSHEETPAGE  *spAddrSheet=NULL;
static TCHAR  szResellerSubTitle[256]=_T(""); // used for Sub Title

void ConfigureResellerEditFields(CRegWizard* pclRegWizard,HWND hwndDlg);
BOOL ValidateResellerDialog(HWND hwndDlg);
int ValidateResellerEditFields(HWND hwndDlg);

///////////////////////////////
//#define CREATE_TAB_ORDER_FILE
///////////////////////////////

INT_PTR CALLBACK ResellerDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
/*********************************************************************
Dialog Proc for the Registration Wizard dialog that requests the
name, city, and state of the reseller that sold the software to the
user.
**********************************************************************/
{
	CRegWizard* pclRegWizard;
	INT_PTR iRet;
	_TCHAR szInfo[256];
    INT_PTR bStatus;
	TriState shouldInclude;

	pclRegWizard = NULL;
	bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
	}

    switch (uMsg)
    {

		case WM_CLOSE:
			if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) pclRegWizard->EndRegWizardDialog(IDB_EXIT);
            break;
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;	
        case WM_INITDIALOG:
		{
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);
			
			//UpgradeDlg(hwndDlg);
			HWND hwndResellerNameField = GetDlgItem(hwndDlg,IDC_EDIT1);
			SetFocus(hwndResellerNameField);
			NormalizeDlgItemFont(hwndDlg,IDC_TITLE, RWZ_MAKE_BOLD);
			NormalizeDlgItemFont(hwndDlg,IDC_SUBTITLE);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT2);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT3);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT9);
						
			//SetWindowText(hwndDlg,pclRegWizard->GetWindowCaption());

			_TCHAR rgchCallingContext[256];
			pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,rgchCallingContext);
			LoadString(pi->hInstance,IDS_RESELLER_SCR_STITLE,szResellerSubTitle,256);
			_tcscat(szResellerSubTitle,_T(" "));
 			_tcscat(szResellerSubTitle,rgchCallingContext);
			_tcscat(szResellerSubTitle,_T("?"));
			spAddrSheet->pszHeaderSubTitle = szResellerSubTitle;


			//ReplaceDialogText(hwndDlg,IDC_SUBTITLE,rgchCallingContext);
			if (pclRegWizard->GetInformationString(kInfoResellerName,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_SETTEXT,0,(LPARAM) szInfo);
			}

			if (pclRegWizard->GetInformationString(kInfoResellerCity,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT2,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			else if (pclRegWizard->GetInformationString(kInfoCity,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT2,WM_SETTEXT,0,(LPARAM) szInfo);
			}

			if (pclRegWizard->GetInformationString(kInfoResellerState,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			else if (pclRegWizard->GetInformationString(kInfoState,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_SETTEXT,0,(LPARAM) szInfo);
			}

			ConfigureResellerEditFields(pclRegWizard,hwndDlg);

			SendDlgItemMessage(hwndDlg,IDC_EDIT1,EM_SETSEL,0,-1);
			// To remove the default checking of the radio button for the first entry

			shouldInclude = pclRegWizard->GetTriStateInformation(kInfoDeclinesNonMSProducts);
			if (shouldInclude == kTriStateTrue )
			{
				CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1);
				PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
				vDeclineOffers = 0;
			}
			else if (shouldInclude == kTriStateFalse)
			{
				CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2);
				PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
				vDeclineOffers = 1;
			}
			else if (shouldInclude == kTriStateUndefined)
			{
				PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK );
				vDeclineOffers = -1;
			}
			
			vDialogInitialized = TRUE;
            return TRUE;
		} // WM_INIT
		break;
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
				RW_DEBUG << "\n PSN_ACTIVE   " << (ULONG)wParam << flush;
                //PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK PSWIZB_NEXT );
				pi->iCancelledByUser = RWZ_PAGE_OK;
				//PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK  );
				shouldInclude = pclRegWizard->GetTriStateInformation(kInfoDeclinesNonMSProducts);
				if (shouldInclude == kTriStateTrue ){
					CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1);
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					vDeclineOffers = 0;
				}
				if (shouldInclude == kTriStateFalse){
					CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2);
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					vDeclineOffers = 1;
				}
				if (shouldInclude == kTriStateUndefined){
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK );
					vDeclineOffers = -1;
				}
				// Enable for previpously entred value in screen
				if(IsDlgButtonChecked(hwndDlg,IDC_RADIO1)){
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
				}
				if(IsDlgButtonChecked(hwndDlg,IDC_RADIO2)){
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
				}

                break;

            case PSN_WIZNEXT:
				RW_DEBUG << "\n PSN_NEXT  " << (ULONG)wParam << flush;
				
				if(pi->iCancelledByUser == RWZ_CANCELLED_BY_USER ) {
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);

				}else {
					iRet=0;
					if( ValidateResellerDialog(hwndDlg) ) {
						pclRegWizard->EndRegWizardDialog((int) wParam);
						SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoResellerName,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT2,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoResellerCity,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoResellerState,szInfo);
						if(vDeclineOffers == -1){
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateUndefined);
						}
						else
						if(vDeclineOffers == 0){
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateFalse);
						}
						else{
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateTrue);
						}
						_stprintf(szInfo,_T("%i"),vDeclineOffers);
						pclRegWizard->SetInformationString(kInfoDeclinesNonMSProducts,szInfo);
						pi->CurrentPage++;
						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;
					}else {
					// Force it it be in this screen
					iRet=-1;
					}
					SetWindowLongPtr( hwndDlg ,DWLP_MSGRESULT, (INT_PTR) iRet);
				}
				break;

            case PSN_WIZBACK:
				
				pi->iLastKeyOperation = RWZ_BACK_PRESSED;
				RW_DEBUG << "\n PSN_BACK  " << (ULONG)wParam << flush;
                pi->CurrentPage--;

                break;
			case PSN_QUERYCANCEL :
					RW_DEBUG << "\n PSN_CANCEL  " << (ULONG)wParam << flush;
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet = 1;
					pi->ErrorPage  = kProductInventoryDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet);
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);

				}else {
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;

				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 				
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        } // WM_Notify
		break;

		

        case WM_COMMAND:
		{
			
            switch (wParam)
            {
              case  IDC_RADIO1:
			  case  IDC_RADIO2:
				if (vDialogInitialized){
						// If the 'No' button is checked, the user is declining
						// the "Non-Microsoft product" offers
						if(IsDlgButtonChecked(hwndDlg,IDC_RADIO1))
						{
							vDeclineOffers = 1;
							PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
							//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
						}
						else
						if(IsDlgButtonChecked(hwndDlg,IDC_RADIO2))
						{
							vDeclineOffers = 0;
							PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
							//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
						}
						else
						{
							vDeclineOffers = -1;
							PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK  );
							//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),FALSE);
						}

					}
                    break;
			  default:
				  break;
			}
		}// WM_COMMAND
		break;
		
		
		default :
		bStatus = FALSE;

        break;
    }
    return bStatus;
}






BOOL ValidateResellerDialog(HWND hwndDlg)
/*********************************************************************
Returns TRUE if all required user input is valid in the Reseller
dialog.  If any required edit field input is empty,
ValidateResellerDialog will put up a message box informing the user
of the problem, and set the focus to the offending control.
**********************************************************************/
{
	int iInvalidEditField = ValidateResellerEditFields(hwndDlg);
	if (iInvalidEditField == NULL)
	{
		return TRUE;
	}
	else
	{
		_TCHAR szLabel[128];
		_TCHAR szMessage[256];
		CRegWizard::GetEditTextFieldAttachedString(hwndDlg,iInvalidEditField,szLabel,128);
		HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndDlg,GWLP_HINSTANCE);
		LoadAndCombineString(hInstance,szLabel,IDS_BAD_PREFIX,szMessage);
		RegWizardMessageEx(hInstance,hwndDlg,IDD_INVALID_DLG,szMessage);
		HWND hwndResellerField = GetDlgItem(hwndDlg,iInvalidEditField);
		SetFocus(hwndResellerField);
		return FALSE;
	}
}


int ValidateResellerEditFields(HWND hwndDlg)
/*********************************************************************
ValidateResellerEditFields validates all edit fields in the Reseller
dialog.  If any required field is empty, the ID of the first empty
edit field control will be returned as the function result.  If all
fields are OK, NULL will be returned.
**********************************************************************/
{
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT1)) return IDC_EDIT1;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT2)) return IDC_EDIT2;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT3)) return IDC_EDIT3;
	return NULL;
}


void ConfigureResellerEditFields(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
**********************************************************************/
{
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT1,kAddrSpecResellerName,IDT_TEXT1);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT2,kAddrSpecResellerCity,IDT_TEXT2);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT3,kAddrSpecResellerState,IDT_TEXT3);
}



//
//  This function is calles during the creation and deletion of
//  Address Property Sheet
//  Store the Address of PPROPSHEETPAGE so the Subtitle can be changed
//
//
//
UINT CALLBACK ResellerPropSheetPageProc(HWND hwnd,
								UINT uMsg,
								LPPROPSHEETPAGE ppsp
								)
{
	
	switch(uMsg) {
	case PSPCB_CREATE :
		spAddrSheet = ppsp;
	default:
		break;

	}
	return 1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\regwizmain.cpp ===
/*********************************************************************
Registration Wizard
10/12/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
**********************************************************************/

#include <Windows.h>
#include <RegPage.h>

#include <tapi.h>
#include "RegWizMain.h"
#include "Resource.h"
#include "Dialogs.h"
#include "regutil.h"
#include <process.h>
#include "sysinv.h"
#include <stdio.h>
#include "cntryinf.h"
#include "mcm.h"
#include "rw_common.h"
#include "rwpost.h"
#include "string.h"
#include <rpcdce.h>
#pragma comment(lib, "rpcrt4.lib")

// MSID Definitions
#define cchMaxSzMSID    32
#define cbMaxSzMSID     (cchMaxSzMSID + 1)
RECT gRect;

// Private functions
void __cdecl LaunchProductSearchThread(void*);
void __cdecl LaunchSystemInventoryThread(void* lParam);
void __cdecl LaunchOemCheckThread(void *);

typedef void (FAR PASCAL *LPFNPRODUCTSEARCH) (void (*pfnReceiveProductName) (LPTSTR,LPTSTR) );
void ReceiveProductName(LPTSTR szProductName,LPTSTR szProductPathName);
void ExitWithImproperBinary(HINSTANCE hInstance,HWND hParent);
void ExitWithInputParamError(HINSTANCE hInstance,HWND hParent);
void ExitWithTxferError(HINSTANCE hInstance,HWND hParent);
void ExitWithSuccessfulRegistration(HINSTANCE hInstance, LPTSTR szProductName);
void ExitWithModemError(HINSTANCE hInstance,HWND hParent);
void ExitWithModemCfgError(HINSTANCE hInstance,HWND hParent);
void ExitWithTcpCfgError(HINSTANCE hInstance,HWND hParent);
void ExitWithCompletedStatus(HINSTANCE hInstance,LPTSTR szProductName);
void ExitWithTryLater(HINSTANCE hInstance, HWND hParent);
void ExitWithConfigurationProblem(HINSTANCE hInstance, HWND hParent);
void ExitWithAnotherCopyRunning(HINSTANCE hInstance, HWND hParent);

BOOL ParseCmdLine(LPTSTR szCmdLine, LPTSTR szBuf, UINT cbBufMax,int *pSwitchType);
BOOL GetSignupLocation(HINSTANCE hInstance, LPTSTR szFileName,LPTSTR szDirectory);
void CopyCharToBuf ( _TCHAR** pszCur, _TCHAR** pszBuf, UINT* pcbBuf );

void RegWizStartupError(DWORD dwError, HINSTANCE hInstance, TCHAR *pszProductName=NULL);
int CheckOEMdll();
int OemPutDataInRegistry();

int CheckWin95OrNT();
int CheckIfProductIsRegistred(HINSTANCE hInstance ,
							  _TCHAR * szParamRegKey);
HBITMAP GetOemBmp();
HBITMAP BitmapFromDib (LPVOID pDIB, HPALETTE hpal,WORD wPalSize);

void GetWindowsDirectory(TCHAR *szParamRegKey,
						 TCHAR *czBuf);
/*****************************/
VOID	ReduceUUID(PSTR szUUID);
HRESULT HrTestHWID();
HRESULT GetNewGUID(PSTR pszGUID);
BOOL	CheckHWIDPresent();
void	MakeHWIDNotUsed(HINSTANCE hins);
/*****************************/
#ifdef _DEBUG
void DebugMessageBox(LPTSTR szMessage);
#else
#define DebugMessageBox(szMessage) 0
#endif

void CloseForTcpIcmp(); // TCP.CPP

#define chSpace 32
BOOL bOemDllLoaded = FALSE;
HINSTANCE hOemDll= NULL;
HANDLE hOemEvent =NULL;
HANDLE hProductEvent=NULL;
HANDLE hInventoryEvent=NULL;

_TCHAR szProductName[256];
_TCHAR szWindowsCaption[256];
_TCHAR szOEMIncenMsg[256];

static CRegWizard* vclRegWizard = NULL;
static LPTSTR lpszRegWizardClass = _T("RegWizard");

static HPALETTE gPal;

BOOL vDialogInitialized = FALSE;

//
//
//
#define SWITCH_WITH_UNKNOWNOPTION    0
#define SWITCH_WITH_I				 1
#define SWITCH_WITH_T				 2
#define SWITCH_WITH_R				 3



#define OEM_NO_ERROR		0
#define OEM_VALIDATE_FAILED 1
#define OEM_INTERNAL_ERROR  2

#define  WIN98_OS     1
#define  WINNT_OS     2
#define  UNKNOWN_OS   0

//
// returns 1 if Win95
//         2 if Win NT
//         0 if Error
int CheckWin95OrNT()
{
	int iRet = 0;
	OSVERSIONINFO  oi;
	oi.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
   	GetVersionEx(&oi);
	switch(oi.dwPlatformId) {
		case VER_PLATFORM_WIN32_NT:
			iRet = 2;
			break;
		case VER_PLATFORM_WIN32_WINDOWS:
			iRet = 1;
			break;
		default :
			break;
	}
	RW_DEBUG << "\n Check OS "  << iRet << flush;
	return iRet;
		


}


//
// Checks to make sure (8 RegWIz Binary is not used in NT
// and NT Binary is not being used in Windows 98
// returns :
//		NO_ERROR   if Binary is the one created for the OS it is running
//      RWZ_ERROR_INVALID_DLL : Dll is not intended for this OS
DWORD CheckForValidRegWizBinary()
{
	int iOsType;
	int iError;
	iError = NO_ERROR;
	iOsType = CheckWin95OrNT();
	#ifdef _WIN95
		if (iOsType != WIN98_OS )
		{
			// Error the OS is not Win 95
			iError = RWZ_ERROR_INVALID_DLL ;
			
		}
	#else
		if (iOsType != WINNT_OS )
		{
			// Error the OS is not Win NT
			iError = RWZ_ERROR_INVALID_DLL;
			
		}
	#endif
	return iError;


}

//int PASCAL _tWinMain( HANDLE hInstance, HANDLE hPrevInstance, LPTSTR lpszCmdParam, int nCmdShow)
// Returns 0 if invoked by /i
// Option : /t
// Returns	 0    if Not Registred
// Returns	 1    if Product is Registred
// Returns  -1  if errror in parameter /t option

int InvokeRegistration ( HINSTANCE hInstance  , LPCTSTR czPath)
/*********************************************************************
Main entry point for the Registration Wizard.
**********************************************************************/
{
	_TCHAR szParamRegKey[256];
	BOOL goodRegKey;
	HANDLE hMutexForInstanceCheck;
	TriState productSearchLibStatus;
	_TCHAR szTitle[64];
	_TCHAR szValue[256]; // used for MSID

	int iError;
	int iSwitchType;


	iSwitchType = SWITCH_WITH_UNKNOWNOPTION;
	hMutexForInstanceCheck = NULL;
	iError = NO_ERROR;

	//
	// Create a Mutex object to check for another copy of regWiz running
	//

	hMutexForInstanceCheck = CreateMutex(NULL,TRUE,_T("RegWizResource_1298345_ForRegistration"));
	if(hMutexForInstanceCheck != NULL ) {
		if( GetLastError() ==  ERROR_ALREADY_EXISTS){
			//
			// Already an instance of RegWiz is running
			iError = RWZ_ERROR_PREVIOUSCOPY_FOUND;
			goto StartupError_NOResourceCleanup;
		}
	}

	//
	//
	// Init variables for Font creation
	InitDlgNormalBoldFont();


	//
	// Check for Binary Validity
	if((iError=CheckForValidRegWizBinary()) ==
		RWZ_ERROR_INVALID_DLL)				{
			goto StartupError_NOResourceCleanup;
	}

	goodRegKey = ParseCmdLine((LPTSTR) czPath,szParamRegKey,256,
		&iSwitchType);

	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n After ParseCmdLine"  << flush;
	#endif
	if (!goodRegKey){
		// This is a special case for browser
		if(iSwitchType == SWITCH_WITH_T){
			return  -1;
		}
		iError = RWZ_ERROR_INVALID_PARAMETER;
		goto StartupError_NOResourceCleanup;
	}

	//
	//  This is a special case for Registration Wizard to be launched from Browsers.
	//  This is to check if the product is already registred
	//  This returns 1 if registred and 0 if it is not registred
	if(iSwitchType == SWITCH_WITH_T){
		return CheckIfProductIsRegistred(hInstance, szParamRegKey);
		
	}

	


	// 02/06/98 If REGWIZ.EXE is invoke with /r and the product info is not passed
	// then it has to regregister the OS
	// so if the product info is null it fills the proper OS reg details
	if(iSwitchType == SWITCH_WITH_R) {
		if(szParamRegKey[0] == NULL || szParamRegKey[0] == _T('\0')){
			// LOad the OS String
			switch(CheckWin95OrNT()) {
			case WIN98_OS:
				LoadString(hInstance,
					IDS_REREGISTER_OS1,
					szParamRegKey,
					256);
					
				break;
			case WINNT_OS :
				LoadString(hInstance,
					IDS_REREGISTER_OS2,
					szParamRegKey,
					256);
					//_tcscpy(szParamRegKey,_T("SOFTWARE\\Microsoft\\NT5.0"));
				break;
			default:
				break;
			}
		
		}				
		

	}

	RW_DEBUG << "\n Prod Key [" << szParamRegKey <<"]" <<  flush;
	vclRegWizard = new CRegWizard(hInstance,szParamRegKey);

	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n After new CRegWizard"  << flush;
	#endif

	if (vclRegWizard->GetInputParameterStatus() == FALSE){
		#ifdef _DEBUG
		DebugMessageBox(_T("One or more 'input parameter' registration keys are invalid."));
		#endif
		iError = RWZ_ERROR_INVALID_PARAMETER;
		goto StartupError_CloseRegWizard;
	}

	// Set the product name  globally so it can be accessed
	vclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szProductName);
	SetProductBeingRegistred(szProductName);
	vclRegWizard->SetWindowCaption(szProductName);
	

	LoadString(hInstance,IDS_WINDOWS_CAPTION,szTitle,64);
	_tcscpy(szWindowsCaption,szProductName);
	_tcscat(szWindowsCaption,szTitle);

	// If registration has already been done for this product
	// (as specified in the input parameters), we can just
	// inform the user and then exit.
	if(iSwitchType != SWITCH_WITH_R){
	
		if (vclRegWizard->IsRegistered()){
			vclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szProductName);
			iError = REGWIZ_ALREADY_CONFIGURED ;
			goto StartupError_CloseRegWizard;
		}
	}
	// If our CRegWizard object can't locate the product search
	// DLL (complinc.dll), we can't go on.
	productSearchLibStatus = vclRegWizard->GetProductSearchLibraryStatus();
	if (productSearchLibStatus == kTriStateFalse){
		#ifdef _DEBUG
			DebugMessageBox(_T("The Product Inventory DLL specified by the 'input parameter' registration key could")
			_T(" not be found, or has an invalid format."));
		#endif
		iError = RWZ_ERROR_INVALID_PARAMETER;
		goto StartupError_CloseRegWizard;
	}

	//
	//  Resource Allocation from now on has to be freed
	//  during Exit


	// Get Auto Dial Status
	GetAutoDialConfiguration();
	#ifdef _LOG_IN_FILE
		RW_DEBUG <<"\n After GetAutoDialConfiguration"  << flush;
	#endif
	InitializeInetThread(hInstance);

	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n After InitializeInetThread"  << flush;
	#endif

	//
	// Product Inventory Search in the background	
	hProductEvent = CreateEvent( NULL, TRUE, FALSE,NULL);
	hInventoryEvent = CreateEvent( NULL, TRUE, FALSE,NULL);
	if (productSearchLibStatus == kTriStateTrue){
		_beginthread(LaunchProductSearchThread,0,vclRegWizard);
	}
	else{
		vclRegWizard->SetProductSearchStatus(kTriStateTrue);
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\n Bypassed LaunchProductSearchThread"  << flush;
		#endif
		SetEvent(hProductEvent);
	}
	
	_beginthread(LaunchSystemInventoryThread,0,vclRegWizard);

	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n After LaunchSystemInventoryThread"  << flush;
	#endif
	// 03/11/99 Delete HWID Logic , Delete Existing HWID
	//if(CheckHWIDPresent() == FALSE)
	//	HrTestHWID();
	MakeHWIDNotUsed(hInstance);


	iError = (ULONG)DoRegistrationWizard(hInstance, vclRegWizard, szParamRegKey);

	#ifdef _LOG_IN_FILE
		RW_DEBUG <<"\n iError :  " << iError << flush;
	#endif

		

	if(hInventoryEvent)
	WaitForSingleObject(hInventoryEvent,INFINITE);
	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n System Inventory WAIT FINISHED" << flush;
	#endif
	if(hProductEvent)
	WaitForSingleObject(hProductEvent,INFINITE);
	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n Product Search WAIT FINISHED"<< flush;
	#endif
	
		

	if(hProductEvent)	CloseHandle(hProductEvent);
	if(hInventoryEvent) CloseHandle(hInventoryEvent);
	


	// Remove The MSID Entry
	RemoveMSIDEntry(hInstance);
	MakeHWIDNotUsed(hInstance);

	// Close any opened windows
	if(vclRegWizard)
	vclRegWizard->DestroyOpenedWindow();

	ResetAutoDialConfiguration();
	
	UnLoadInetCfgLib(); // Frees  INETCFG.DLL
	// comment the above line as it is creating a problem IE
	CloseForTcpIcmp(); //  Frees   ICMP.DLL and Closes Socket

	if(vclRegWizard) delete vclRegWizard;

	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n Exiting Regwiz....." << flush;
	#endif
	if(hMutexForInstanceCheck) {
		CloseHandle(hMutexForInstanceCheck);
	}

	goto CoolExit;

StartupError_CloseRegWizard:
	//
	// Close the
	RegWizStartupError(iError,hInstance,szProductName );
	if(hMutexForInstanceCheck) {
		CloseHandle(hMutexForInstanceCheck);
	}
	if(vclRegWizard) delete vclRegWizard;
	goto CoolExit;

StartupError_NOResourceCleanup:
	RegWizStartupError(iError,hInstance,szProductName );	
	if(hMutexForInstanceCheck) {
		CloseHandle(hMutexForInstanceCheck);
	}
		

CoolExit:
	//
	// Call function to destroy for the fonts that are created
	DeleteDlgNormalBoldFont();

	return iError;

}

void RegWizStartupError(DWORD dwError, HINSTANCE hInstance, TCHAR  *pszProductName)
{
	RW_DEBUG << "\n In RegWizStartupError " << dwError << flush;
	switch(dwError) {
		case  RWZ_ERROR_INVALID_DLL:
			ExitWithImproperBinary(hInstance, NULL);
			break;
		case  RWZ_ERROR_PREVIOUSCOPY_FOUND:
			ExitWithAnotherCopyRunning(hInstance, NULL);
			break;
		case  RWZ_ERROR_INVALID_PARAMETER:
			ExitWithInputParamError(hInstance,NULL);
			break;
		case  REGWIZ_ALREADY_CONFIGURED:
			ExitWithCompletedStatus(hInstance,pszProductName);
			break;

			

		default:
			break;
			//
			//
		break;

	}

}


/*   T R A N S M I T   R E G   W I Z   I N F O   */
/*-------------------------------------------------------------------------
    Owner: SteveBu

    REVIEW: add support fOEM, tricking RegWiz into posting both prodreg
    and OEM information.
-------------------------------------------------------------------------*/
void TransmitRegWizInfo(HINSTANCE hInstance,
						LPCTSTR szParams, BOOL fOEM)
	
{	
	
		
}







ModemStatus DetectModem(HINSTANCE hInstance)
/*********************************************************************
This function detects whether the user's machine has a modem connected
and properly configured.

Returns:
kNoneFound: No modem is connected.
kModemFound: A modem is connected and configured.
kConfigErr: A modem is connected, but it could not be configured
	correctly.
**********************************************************************/
{
	#ifdef _TAPI
		MODEMSTATUS msModemStatus = MSEnsureModemTAPI(hInstance,NULL);
		switch (msModemStatus)
		{
			case kMsModemOk:
				return kModemFound;
			case kMsModemNotFound:
				return kNoneFound;
			case kMsModemTooSlow:
				return kModemTooSlow;
			default:
				return kNoneFound;
		}
	#else
		if (vclRegWizard->GetInformationString(kInfoCountry,NULL) == NULL)
		{
			vclRegWizard->SetInformationString(kInfoCountry,_T("United States of America"));
		}
		return kModemFound;
	#endif
}



void __cdecl LaunchProductSearchThread(void* lParam)
/*********************************************************************
This function spawns a thread that builds an inventory list of the
products installed on the user's system.  The lParam parameter should
contain a pointer to our CRegWizard object.
**********************************************************************/
{
	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n LaunchProductSearchThread started" << flush;
	#endif
	
	CRegWizard* pclRegWizard = (CRegWizard*) lParam;
	pclRegWizard->SetProductSearchStatus(kTriStateFalse);

	LPFNPRODUCTSEARCH lpfnProdSearch;
	pclRegWizard->GetProductSearchProcAddress((FARPROC*) &lpfnProdSearch);
	if (lpfnProdSearch)
	{
		lpfnProdSearch(ReceiveProductName);
		pclRegWizard->SetProductSearchStatus(kTriStateTrue);
	}
	else
	{
		pclRegWizard->SetProductSearchStatus(kTriStateUndefined);
	}
	
	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n LaunchProductSearchThread finished" << flush;
	#endif

	SetEvent(hProductEvent);
	_endthread();
	
}

void __cdecl LaunchSystemInventoryThread(void* lParam)
/*********************************************************************
This function spawns a thread that builds an inventory list of
detected system information .  The lParam parameter should contain a
pointer to our CRegWizard object.
**********************************************************************/
{
	CRegWizard* pclRegWizard = (CRegWizard*) lParam;
	pclRegWizard->SetSystemInventoryStatus(FALSE);

	const int iInvBufSize = 256;
	_TCHAR szInventory[iInvBufSize];
	GetProcessorTypeString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kInfoProcessor,szInventory);

	GetTotalMemoryString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kInfoTotalRAM,szInventory);

	GetTotalHardDiskSpaceString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kInfoTotalDiskSpace,szInventory);

	GetDisplayResolutionString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kInfoDisplayResolution,szInventory);
	
	GetDisplayColorDepthString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kInfoDisplayColorDepth,szInventory);

	GetWindowsVersionString(pclRegWizard->GetInstance(), szInventory);
	pclRegWizard->SetInformationString(kInfoOperatingSystem,szInventory);

	GetNetworkCardString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kInfoNetwork,szInventory);

	GetModemString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kInfoModem,szInventory);

	GetPointingDeviceString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kInfoPointingDevice,szInventory);

	GetCDRomString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kInfoCDROM,szInventory);

	GetSoundCardString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kInfoSoundCard,szInventory);

	GetRemoveableMediaString(pclRegWizard->GetInstance(),szInventory,iInvBufSize);
	pclRegWizard->SetInformationString(kInfoRemoveableMedia,szInventory);

	GetOEMString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kComputerManufacturer,szInventory);

	GetSCSIAdapterString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kScsiAdapterInfo,szInventory);


	BOOL hasCoProcessor = IsCoProcessorAvailable(pclRegWizard->GetInstance());
	pclRegWizard->SetTriStateInformation(kInfoMathCoProcessor,
	hasCoProcessor == TRUE ? kTriStateTrue : kTriStateFalse);

	pclRegWizard->SetSystemInventoryStatus(TRUE);

	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n LaunchSystemInventoryThread finished" << flush;
	#endif
	SetEvent(hInventoryEvent);
	_endthread();
}



void ReceiveProductName(LPTSTR szProductName,LPTSTR szProductPathName)
/***************************************************************************
This function receives the given product name back from complinc.dll
****************************************************************************/
{
	vclRegWizard->AddProduct(szProductName,szProductPathName);
	RefreshInventoryList(vclRegWizard);
}


BOOL ParseCmdLine(LPTSTR szCmdLine, LPTSTR szBuf, UINT cbBufMax, int *pSwitchType)
/***************************************************************************
This function expects in the szCmdLine parameter a pointer to the
command line parameter string used when RegWiz was launched.  This string
will be parsed, and the bare command line argument (which should be a
RegDB key referencing our parameter block) will be returned in the
szBuf parameter.

If no valid command line parameter is located, an empty string will be
returned in szBuf, and FALSE will be returned as the function result.
****************************************************************************/
{

	TCHAR  cSwitch;
    *szBuf = 0; // Initialize the output buffer
	*pSwitchType = SWITCH_WITH_UNKNOWNOPTION;
	if (szCmdLine == NULL || szCmdLine[0] == 0)
	{
		return FALSE;
	}
	else
	{
		LPTSTR szCurr = szCmdLine;
		while (*szCurr == chSpace)
		{
			szCurr = CharNext(szCurr);
		}
	

		if (*szCurr != _T('/') && *szCurr != _T('-')) return FALSE;
		szCurr = CharNext(szCurr);

		cSwitch = *szCurr;
		cSwitch = _totupper(cSwitch);

		if (cSwitch != _T('I') && cSwitch != _T('T') && cSwitch != _T('R') )return FALSE;

		if(cSwitch ==_T('T'))
		{
			*pSwitchType = SWITCH_WITH_T;
		}
		else
		if(cSwitch ==_T('I'))
		{
			*pSwitchType =SWITCH_WITH_I;
		}
		else
		if(cSwitch ==_T('R'))
		{
			*pSwitchType =SWITCH_WITH_R;
		}
		else
		{
			*pSwitchType =SWITCH_WITH_UNKNOWNOPTION;
		}

		szCurr = CharNext(szCurr);
		while (*szCurr == chSpace)
		{
			szCurr = CharNext(szCurr);
		}

		BOOL fInQuoted = FALSE;
		while (*szCurr != NULL && (fInQuoted == TRUE || fInQuoted == FALSE && *szCurr != chSpace))
		{
			if (*szCurr == _T('"'))
			{
				szCurr = CharNext(szCurr);
				fInQuoted = fInQuoted == TRUE ? FALSE : TRUE;
			}
			else
			{
				CopyCharToBuf(&szCurr,&szBuf,&cbBufMax);
			}
		}
		*szBuf = NULL;
		while (*szCurr == chSpace)
		{
			szCurr = CharNext(szCurr);
		}
		if (*szCurr != NULL) return FALSE;

		#ifdef _DEBUG
			if (fInQuoted)
			{
				DebugMessageBox(_T("Unmatched quotes in '/i' command line parameter."));
			}
		#endif
		return fInQuoted == TRUE ? FALSE : TRUE;
	}
}


void CopyCharToBuf ( LPTSTR* pszCur, LPTSTR* pszBuf, UINT* pcbBuf )
{
	LPTSTR szEnd = CharNext(*pszCur);
	if (UINT(szEnd - *pszCur) <= *pcbBuf)
		{
		while (*pszCur < szEnd)
			{
				//*(*pszBuf)++ = *(*pszCur)++;
				_tcscpy(*pszBuf,*pszCur);
				(*pszBuf) = _tcsinc((*pszBuf));
				(*pszCur) = _tcsinc((*pszCur));
				//(*pcbBuf) = _tcsdec((*pcbBuf));
				(*pcbBuf)--;
			}
		}
	else
		{
		*pszCur = szEnd;
		*pcbBuf = 0;
		}
}



void ExitWithInputParamError(HINSTANCE hInstance,HWND hParent)
/***************************************************************************
Displays a message informing the user of a problem with the input parameters
(either the command line argument regkey, or the parameter subkeys in the
Reg Database), and then terminates the RegWizard.
****************************************************************************/
{
	RegWizardMessage(hInstance,hParent,IDD_INPUTPARAM_ERR);
	#ifdef _REGWIZ_EXE
		exit(EXIT_FAILURE);
	#endif
}


void 	ExitWithTxferError(HINSTANCE hInstance,HWND hParent)
{
	RegWizardMessage(hInstance,hParent,IDD_POST_ERROR);
	#ifdef _REGWIZ_EXE
		exit(EXIT_FAILURE);
	#endif
}

void 	ExitWithTryLater(HINSTANCE hInstance,HWND hParent)
{
	RegWizardMessage(hInstance,hParent,IDD_POST_PROBLEM);
	#ifdef _REGWIZ_EXE
		exit(EXIT_FAILURE);
	#endif
}

void ExitWithConfigurationProblem(HINSTANCE hInstance, HWND hParent)
{
	RegWizardMessage(hInstance,hParent,IDD_CFG_PROBLEM);
	#ifdef _REGWIZ_EXE
		exit(EXIT_FAILURE);
	#endif

}

void ExitWithModemError(HINSTANCE hInstance,HWND hParent)
/***************************************************************************
Displays a message informing the user of that RegWizard cannot run without
a properly configured modem, and then terminates.
****************************************************************************/
{

	RegWizardMessageEx(hInstance,hParent,IDD_MODEM_ERR, GetProductBeingRegistred());
	#ifdef _REGWIZ_EXE
		exit(EXIT_SUCCESS);
	#endif
}

void ExitWithTcpCfgError(HINSTANCE hInstance,HWND hParent)
{
	RegWizardMessage(hInstance,hParent,IDD_NETWORK_CFG_ERROR);
	#ifdef _REGWIZ_EXE
		exit(EXIT_SUCCESS);
	#endif
}

void ExitWithImproperBinary(HINSTANCE hInstance,HWND hParent)
{
	RegWizardMessage(hInstance,hParent,IDD_ERROR_INVALIDBINARY);
	#ifdef _REGWIZ_EXE
		exit(EXIT_SUCCESS);
	#endif

}

void ExitWithModemCfgError(HINSTANCE hInstance,HWND hParent)
{
	RegWizardMessage(hInstance,hParent,IDD_MODEM_CFG_ERROR);
	#ifdef _REGWIZ_EXE
		exit(EXIT_SUCCESS);
	#endif
}

void ExitWithAnotherCopyRunning(HINSTANCE hInstance, HWND hParent)
{
	RegWizardMessage(hInstance,hParent,IDD_ANOTHERCOPY_ERROR);
	#ifdef _REGWIZ_EXE
		exit(EXIT_SUCCESS);
	#endif
}
void ExitWithSuccessfulRegistration(HINSTANCE hInstance, LPTSTR szProductName)
{
	RegWizardMessageEx(hInstance,NULL,IDD_SUCCESSFUL_REGISTRATION,szProductName);
	#ifdef _REGWIZ_EXE
		exit(EXIT_SUCCESS);
	#endif
}


void ExitWithCompletedStatus(HINSTANCE hInstance,LPTSTR szProductName)
/***************************************************************************
Displays a message informing the user of registration has already been
performed for this product, and then exits.  The szProductName parameter
should contain a pointer to the product name.
****************************************************************************/
{
	RegWizardMessageEx(hInstance,NULL,IDD_ALREADY_REGISTERED,szProductName);
	#ifdef _REGWIZ_EXE
		exit(EXIT_FAILURE);
	#endif
}



BOOL GetSignupLocation(HINSTANCE hInstance, LPTSTR szFileName,LPTSTR szDirectory)
/***************************************************************************
Returns the filename and full pathname to the directory of the SignUp
executable.  If either value cannot be determined (i.e. the pathname cannot
be found in the Registration Database), FALSE will be returned as the
function result.
****************************************************************************/
{
	HKEY hKey;
	_TCHAR szKeyName[256];
	BOOL retValue = FALSE;
	int resSize = LoadString(hInstance,IDS_SIGNUPLOC_KEY,szKeyName,255);
	LONG regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szKeyName,0,KEY_READ,&hKey);
	if (regStatus == ERROR_SUCCESS)
	{
		_TCHAR szValueName[64];
		unsigned long infoSize = 255;
		resSize = LoadString(hInstance,IDS_SIGNUPLOC_VALUENAME,szValueName,64);
		regStatus = RegQueryValueEx(hKey,szValueName,NULL,0,(LPBYTE) szDirectory,&infoSize);
		if (regStatus == ERROR_SUCCESS)
		{
			retValue = TRUE;
			LoadString(hInstance,IDS_SIGNUPLOC_FILENAME,szFileName,255);
		}
		RegCloseKey(hKey);
	}
	return retValue;
}


int CheckOEMdll()
{
	return OEM_INTERNAL_ERROR;
}



#ifdef _DEBUG
void DebugMessageBox(LPTSTR szMessage)
/***************************************************************************
Displays the given message in a "Stop" message box (debug builds only).
****************************************************************************/
{
	MessageBox(NULL,szMessage,_T("Registration Wizard Error"),MB_ICONSTOP);
}
#endif



/*************************************
/*   R E D U C E   U   U   I   D   */
/*----------------------------------------------------------------------
    Owner: SteveBu
    Reduces a UUID to a string
----------------------------------------------------------------------*/
VOID ReduceUUID(PSTR szUUID)
{
        int i;
        for (i=9; i<13; i++) szUUID[i-1]=szUUID[i];
        for (i=14; i<18; i++) szUUID[i-2]=szUUID[i];
        for (i=19; i<23; i++) szUUID[i-3]=szUUID[i];
        for (i=24; i<36; i++) szUUID[i-4]=szUUID[i];
        szUUID[32]='\0';
}

/*   G E T   N E W   G   U   I   D   */
/*----------------------------------------------------------------------
    Owner: SteveBu
    Generates a new GUID.  Assumes passed in pszGUID is 32 characters in
    length.
	03/10/99:
	NUll String will be returned, GUID will no longer be created on 
	clients machine
-----------------------------------------------------------------------*/
HRESULT GetNewGUID(PSTR pszGUID)
{
        UUID    idNumber;
        PBYTE  uuidString;
        DWORD   dwErr;
		char szUidString[40];

		strcpy(pszGUID,"");
		return NO_ERROR;
		/******
        if ( (RPC_S_OK==(dwErr=UuidCreate(&idNumber))) &&
                 (RPC_S_OK==(dwErr=UuidToStringA(&idNumber,&uuidString))) )
        {
    		RW_DEBUG << "\n: Create New HWID :" << uuidString << flush;
                strcpy(szUidString, (PSTR)uuidString);
                RpcStringFreeA(&uuidString);
                ReduceUUID(szUidString);
				strcpy(pszGUID,szUidString);
                return NO_ERROR;
        }
        return HRESULT_FROM_WIN32(dwErr);
		**/
}

/**
BOOL CheckHWIDPresent()
{
	HKEY hKeyHWID;

	_TCHAR szKeyName[256];
	_TCHAR szValue[256];
	
	_tcscpy(szKeyName,_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"));
	
	LONG regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szKeyName,0,KEY_READ,&hKeyHWID);
	if (regStatus == ERROR_SUCCESS)
	{
		_TCHAR szValueName[64];
		unsigned long infoSize = 255;
		LoadString(vclRegWizard->GetInstance(),IDS_HWID,szValueName,64);
		regStatus = RegQueryValueEx(hKeyHWID,szValueName,NULL,0,(LPBYTE) szValue,&infoSize);
		if (regStatus == ERROR_SUCCESS)
		{
			vclRegWizard->SetInformationString(kInfoHWID,szValue);
			RegCloseKey(hKeyHWID);
			return TRUE;
		}

	}
	RegCloseKey(hKeyHWID);
	return FALSE;
}

HRESULT HrTestHWID()
{
 DWORD	dwRet;
 _TCHAR szKeyName[256];
 HRESULT hr;
 HKEY	hIDKey;
 char szHWID[cbMaxSzMSID+64];
 TCHAR  *TP;

 _tcscpy(szKeyName,_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"));

 if (FAILED(hr = GetNewGUID(szHWID)))
	  szHWID[0] = '\0';
 else
 {
    RW_DEBUG << "\n:HWID :" << szHWID << flush;
  // Store HWID into
	dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szKeyName,0,KEY_ALL_ACCESS,&hIDKey);
	if (dwRet == ERROR_SUCCESS)
	{
		TP = ConvertToUnicode(szHWID);
		dwRet = RegSetValueEx(hIDKey,_T("HWID"),NULL,REG_SZ,(CONST BYTE *)TP,
									_tcslen( TP) * sizeof(TCHAR) );
		vclRegWizard->SetInformationString(kInfoHWID,TP);
		RegCloseKey(hIDKey);
	}
 }

 return hr;
}
****/

void MakeHWIDNotUsed(HINSTANCE  hInstance)
{
	_TCHAR szKeyName[256];
	_TCHAR szValue[256];
	HRESULT hr;
	HKEY	hIDKey;
	DWORD dwRet;
	szValue[0] = _T('\0');
	LoadString(hInstance,IDS_NOTUSED,szValue,255);

	_tcscpy(szKeyName,_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"));
	dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szKeyName,0,KEY_ALL_ACCESS,&hIDKey);
	if (dwRet == ERROR_SUCCESS) {
		//RegDeleteValue(hIDKey,_T("HWID") );
		RegSetValueEx(hIDKey,_T("HWID"),NULL,REG_SZ,(CONST BYTE *)szValue,
								_tcslen((LPCTSTR)szValue)* sizeof(_TCHAR) );
		RegCloseKey(hIDKey);
	}
	// Delete From User Informatipon
	_tcscpy(szKeyName,_T("SOFTWARE\\Microsoft\\User Information"));
	dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szKeyName,0,KEY_ALL_ACCESS,&hIDKey);
	if (dwRet == ERROR_SUCCESS) {
		//RegDeleteValue(hIDKey,_T("HWID") );
		RegSetValueEx(hIDKey,_T("HWID"),NULL,REG_SZ,(CONST BYTE *)szValue,
								_tcslen((LPCTSTR)szValue) * sizeof(_TCHAR));
		RegCloseKey(hIDKey);
	}

}

//
// Return 0 : if not registred
//        1 : if Registred
//
int CheckIfProductIsRegistred(HINSTANCE hInstance ,
							  _TCHAR * szParamRegKey)
{
	int iReturn ;
	HKEY hKey;
	TCHAR szValueName[256] = _T("");
	TCHAR szRetVal[48];
	DWORD dwSize= 48;
	LONG regStatus ;
	int resSize = LoadString(hInstance,
				IDS_INPUT_ISREGISTERED,szValueName,128);

	iReturn  = 1;

	if (ERROR_SUCCESS != GetProductRoot(szParamRegKey , &hKey))
    {
		return iReturn;
	}
	regStatus = RegQueryValueEx(hKey,
		szValueName,
		NULL,
		0,
		(LPBYTE) szRetVal,
		&dwSize);
	if (regStatus == ERROR_SUCCESS){
		// Verifty the Value
		//
		if(szRetVal[0] == _T('1')) {
			iReturn = 0; // Product Registred flag is set
		}
	}
	RegCloseKey(hKey);
	
	return iReturn;

}



HBITMAP GetOemBmp()
{
       HDC  hDC;
       BOOL bRet;

       // detect this display is 256 colors or not
       hDC = GetDC(NULL);
       bRet = (GetDeviceCaps(hDC, BITSPIXEL) != 8);
       ReleaseDC(NULL, hDC);
       if (bRet)
	   {
		   // the display is not 256 colors, let Windows handle it
          return LoadBitmap(vclRegWizard->GetInstance(),MAKEINTRESOURCE(IDB_BITMAP1));
       }


       LPBITMAPINFO lpBmpInfo;               // bitmap informaiton
       int i;
       HRSRC hRsrc;
	   HANDLE hDib;
	   HBITMAP hBMP;

       struct
	   {
			   WORD            palVersion;
		       WORD            palNumEntries;
			   PALETTEENTRY    PalEntry[256];
	   } MyPal;

       hRsrc = FindResource(vclRegWizard->GetInstance(), MAKEINTRESOURCE(IDB_BITMAP1),RT_BITMAP);
       if (!hRsrc)
         return NULL;

       hDib = LoadResource(vclRegWizard->GetInstance(), hRsrc);
       if (!hDib)
         return NULL;

       if (!(lpBmpInfo = (LPBITMAPINFO) LockResource(hDib)))
               return NULL;

       MyPal.palVersion = 0x300;
       MyPal.palNumEntries = 1 << lpBmpInfo->bmiHeader.biBitCount;

       for (i = 0; i < MyPal.palNumEntries; i++)
	   {
         MyPal.PalEntry[i].peRed   = lpBmpInfo->bmiColors[i].rgbRed;
         MyPal.PalEntry[i].peGreen = lpBmpInfo->bmiColors[i].rgbGreen;
         MyPal.PalEntry[i].peBlue  = lpBmpInfo->bmiColors[i].rgbBlue;
         MyPal.PalEntry[i].peFlags = 0;
       }
       gPal = CreatePalette((LPLOGPALETTE)&MyPal);

       if (gPal == NULL)
	   {        // create palette fail, let window handle the bitmap
          return LoadBitmap(vclRegWizard->GetInstance(),MAKEINTRESOURCE(IDB_BITMAP1));
       }

       hBMP = BitmapFromDib(hDib,gPal,MyPal.palNumEntries);
       UnlockResource(hDib);
	   if( hBMP == NULL ) {
		   DeleteObject(gPal);
		   gPal = NULL;
		   hBMP = LoadBitmap(vclRegWizard->GetInstance(),MAKEINTRESOURCE(IDB_BITMAP1));
       }
	   return hBMP;
}



/****************************************************************************
 *                                                                          *
 *  FUNCTION   : BitmapFromDib(LPVOID hdib, HPALETTE hpal, WORD palSize)                  *
 *                                                                          *
 *  PURPOSE    : Will create a DDB (Device Dependent Bitmap) given a global *
 *               handle to a memory block in CF_DIB format                  *
 *                                                                          *
 *  RETURNS    : A handle to the DDB.                                       *
 *                                                                          *
 ****************************************************************************/

HBITMAP BitmapFromDib (
    LPVOID         pDIB,
    HPALETTE   hpal, WORD wPalSize)
{
    LPBITMAPINFOHEADER  lpbi;
    HPALETTE            hpalT;
    HDC                 hdc;
    HBITMAP             hbm;



    if (!pDIB || wPalSize == 16 )
        return NULL;

    lpbi = (LPBITMAPINFOHEADER)pDIB; // lock resource


    hdc = GetDC(NULL);

    if (hpal){
        hpalT = SelectPalette(hdc,hpal,FALSE);
        RealizePalette(hdc);
    }

    hbm = CreateDIBitmap(hdc,
                (LPBITMAPINFOHEADER)lpbi,
                (LONG)CBM_INIT,
                (LPSTR)lpbi + lpbi->biSize + wPalSize*sizeof(PALETTEENTRY),
                (LPBITMAPINFO)lpbi,
                DIB_RGB_COLORS );

    if (hpal)
        SelectPalette(hdc,hpalT,FALSE);

    ReleaseDC(NULL,hdc);

    return hbm;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\regutil.cpp ===
/*********************************************************************
Registration Wizard

regutil.cpp

Standard RegWizard utility functions 

12/7/94 - Tracy Ferrier
(c) 1994-96 Microsoft Corporation

  Modification History:
  5/26/99 : The Regsitration Version number should have the OS build number 
  The build number should be tahen from HKLM/SW/Ms/Windows NT/CurrentBuildNumber
  eg 3.0.nnnn 
**********************************************************************/

#include <Windows.h>
#include <winnt.h>
#include "regutil.h"
#include "resource.h"
#include <stdio.h>
#include "rwwin95.h"
#include "sysinv.h"
#include "version.h"
#include "rw_common.h"



void EncryptBlock (PTBYTE lpbBlock, DWORD dwBlockSize );
void DecryptBlock (PTBYTE lpbBlock, DWORD dwBlockSize );
#define BITS_PER_BYTE		8
WORD vrgwRot[] = {2,3,2,1,4,2,1,1};

_TUCHAR g_rgchCredits[] = {
#include "credits.h"
};
static  HFONT   shBoldFont;
static  HFONT   shNormalFont;

void InitDlgNormalBoldFont()
{
	shBoldFont   = NULL;
	shNormalFont = NULL;
}
void DeleteDlgNormalBoldFont()
{
	int iInd;
	if(shBoldFont) {
		DeleteObject(shBoldFont);
		RW_DEBUG << "\n In Delete Bold Font:[" << shBoldFont << flush;
	}
	if(shNormalFont){
		DeleteObject(shNormalFont);
		RW_DEBUG << "\n In Delete Normal Font:[" << shNormalFont<< flush;
	}

	shBoldFont   = NULL;
	shNormalFont = NULL;

		
}
// Modified on 04/07/98 
// Previously a font was created for all of the controls, when ever the function is called. 
// Now 2 fonts Normal and Bold is created only once and is used by all the controls calling this fn
//
//
HFONT NormalizeDlgItemFont(HWND hwndDlg,int idControl, int iMakeBold)
/*********************************************************************
This function removes any BOLD weight attribute attached to the
dialog control specified by hwndDlg and idControl.
**********************************************************************/
{
	// This is needed only when running under NT. Under
	// Win95, the dialog text is unbolded by default.
	
	HFONT hfont;
	hfont = NULL;
	
	//if(iMakeBold != RWZ_MAKE_BOLD){
	//	return hfont;
	//}
		if (Windows95OrGreater())
	{

		hfont = (HFONT)SendMessage(hwndDlg, WM_GETFONT, 0, 0L);
		if (hfont != NULL){
			LOGFONT lFont;
			if (!GetObject(hfont, sizeof(LOGFONT), (LPTSTR)&lFont))
			{
				hfont = NULL;
			}
			else
			{
				if(iMakeBold == RWZ_MAKE_BOLD){
						lFont.lfWeight = FW_BOLD;
						// Create Bold Font
						if(shBoldFont==NULL){
							shBoldFont = CreateFontIndirect((LPLOGFONT)&lFont);
							RW_DEBUG << "\n\tIn Create Bold Font:[" << shBoldFont << flush;
						}
						hfont = shBoldFont;
				}else {
					lFont.lfWeight = FW_NORMAL;
						// Create Normal Font
						if(shNormalFont==NULL){
							shNormalFont = CreateFontIndirect((LPLOGFONT)&lFont);
							RW_DEBUG << "\n\tIn Create Normal Font:[" << shNormalFont <<  flush;
						}
						hfont = shNormalFont;
				}

							
				if (hfont != NULL)
				{			
				
					SendDlgItemMessage(hwndDlg, idControl, WM_SETFONT,(WPARAM)hfont , 0L);
				}
			}
		}
	}
	
	return hfont;
}


//
//
// Old implementation of NormalizeDlgItemFont(),this fn was used till 
// 4/7/98
// 
void NormalizeDlgItemFont1(HWND hwndDlg,int idControl, int iMakeBold)
/*********************************************************************
This function removes any BOLD weight attribute attached to the
dialog control specified by hwndDlg and idControl.
**********************************************************************/
{
	// This is needed only when running under NT. Under
	// Win95, the dialog text is unbolded by default.
	if (!Windows95OrGreater())
	//if (Windows95OrGreater())
	{
		HFONT hfont = (HFONT)SendMessage(hwndDlg, WM_GETFONT, 0, 0L);
		if (hfont != NULL)
		{
			LOGFONT lFont;
			if (!GetObject(hfont, sizeof(LOGFONT), (LPTSTR)&lFont))
			{
				hfont = NULL;
			}
			else
			{
				if(iMakeBold == RWZ_MAKE_BOLD){
						lFont.lfWeight = FW_BOLD;
				}else {
					lFont.lfWeight = FW_NORMAL;
				}
			
				hfont = CreateFontIndirect((LPLOGFONT)&lFont);
				if (hfont != NULL)
				{
					SendDlgItemMessage(hwndDlg, idControl, WM_SETFONT,(WPARAM)hfont, 0L);
				}
			}
		}
	}
}


void ReplaceDialogText(HWND hwndDlg,int idControl,LPTSTR szText)
/*********************************************************************
For the dialog control indicated by hwndDlg and idControl, this
function replaces the first occurrence of '%s' with the text pointed
to by szText.
**********************************************************************/
{
	_TCHAR szCurrentText[512];
	_TCHAR szTextBuffer[512];
	LRESULT textLen = SendDlgItemMessage(hwndDlg, idControl, WM_GETTEXT, (WPARAM) 512, (LPARAM) szCurrentText);
	_stprintf(szTextBuffer,szCurrentText,szText);
	SendDlgItemMessage(hwndDlg,idControl,WM_SETTEXT,0,(LPARAM) szTextBuffer);
}



void UpgradeDlg(HWND hwndDlg)
/*********************************************************************
Applies an RegWizard defined set of "upgrades" to the dialog whose
handle is given in the hwndDlg parameter.
**********************************************************************/
{
	// Turn SS_BLACKFRAME line into SS_ETCHEDFRAME
	HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndDlg,GWLP_HINSTANCE);
	HWND hwndEtchedLine = GetDlgItem(hwndDlg,IDC_ETCHEDLINE);
	if (hwndEtchedLine)
	{
		SetWindowLongPtr(hwndEtchedLine,GWL_STYLE,SS_ETCHEDFRAME | WS_VISIBLE | WS_CHILD);
	}
	//CenterDlg(hwndDlg);// We now set the DS_CENTER window style instead

	if (Windows95OrGreater())
	{
		HICON hIcon = LoadIcon(hInstance,MAKEINTRESOURCE(IDI_REGWIZ));
		SendMessage(hwndDlg,WM_SETICON,(WPARAM) TRUE,(LPARAM) hIcon);
	}
}


void LoadAndCombineString(HINSTANCE hInstance,LPCTSTR szReplaceWith,int idReplacementString,LPTSTR szString)
/*********************************************************************
This function replaces the first occurrence of "%s" in szTarget with 
the string specified by the idReplacementString resource ID, and 
returns the resulting string in the szString parameter.
**********************************************************************/
{
	_TCHAR szTarget[256];
	LoadString(hInstance,idReplacementString,szTarget,256);
	_stprintf(szString,szTarget,szReplaceWith);
}



 void StripCharFromString(LPTSTR szInString, LPTSTR szOutString, _TCHAR charToStrip)
 /***********************************************************************
 Strips the given character from szInString, and returns the result in
 szOutString.
 ************************************************************************/
 {
 	while (1)
	{
		if (*szInString != charToStrip)
		{
		  //*szOutString++ = *szInString;
			_tcscpy(szOutString,szInString);
			szOutString = _tcsinc(szOutString);
		}
		//if (*szInString++ == NULL) return;
		if (*szInString == NULL) return;
		szInString = _tcsinc(szInString);
	};
 }



BOOL GetIndexedRegKeyValue(HINSTANCE hInstance, int enumIndex, LPTSTR szBaseKey,int valueStrID, LPTSTR szValue)
/*********************************************************************
Looks for a subkey, under the Registration Database key given in the
szBaseKey parameter, of the form "0000", "0001", etc.  The numerical
equivalent of the subkey is determined by the index value given in
the enumIndex parameter.  The value attached to the valueName
specified in the string resource whose ID is given in valueStrID will
be returned in szValue.

Returns: FALSE if the key specified is not found. 
**********************************************************************/
{
	_TCHAR szRegKey[256];
	_stprintf(szRegKey,_T("%s\\%04i"),szBaseKey,enumIndex);

	BOOL returnVal = FALSE;
	HKEY hKey;
	LONG regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szRegKey,0,KEY_READ,&hKey);
	if (regStatus == ERROR_SUCCESS)
	{
		_TCHAR szValueName[128];
		LoadString(hInstance,valueStrID,szValueName,128);
		unsigned long infoSize = 255;
		regStatus = RegQueryValueEx(hKey,szValueName,NULL,0,(LPBYTE) szValue,&infoSize);
		if (regStatus == ERROR_SUCCESS)
		{
			returnVal = TRUE;
		}
		RegCloseKey(hKey);
	}
	return returnVal;
}



BOOL FileExists(LPTSTR szPathName)
/***************************************************************************
Returns TRUE if the file specified by the given pathname actually exists.
****************************************************************************/
{
	SECURITY_ATTRIBUTES sa;
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = TRUE;
	HANDLE fileHandle = CreateFile(szPathName,GENERIC_READ,0,&sa,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);

	BOOL retValue;
	if (fileHandle == INVALID_HANDLE_VALUE)
	{
		retValue = FALSE;
	}
	else
	{
		retValue = TRUE;
		CloseHandle(fileHandle);
	}
	return retValue;
}


void UppercaseString(LPTSTR sz)
/*********************************************************************
Converts the given string to uppercase, in place.
**********************************************************************/
{
	if (sz)
	{
		while (*sz)
		{
			*sz = _totupper(*sz);
			//sz++;
			sz = _tcsinc(sz);
		}
	}
}

LONG GetResNumber(HINSTANCE hInstance, int iStrResID)
/*********************************************************************
Loads the string whose ID is given by the iStrResID parameter, and
returns the numerical equivalent of the string's value.
**********************************************************************/
{
	_TCHAR szRes[256];
	LoadString(hInstance,iStrResID,szRes,255);
	LONG lResNum = _ttol(szRes);
	return lResNum;
}


BOOL Windows95OrGreater( void )
/*********************************************************************
Returns TRUE if the current operating system is Windows 4.0 or better.
**********************************************************************/
{
	LONG lPlatform, lMajorVersion,lMinorVersion,lBuildNumber;
	GetWindowsVersion(&lPlatform,&lMajorVersion,&lMinorVersion,&lBuildNumber);
	return lMajorVersion >= 4 ? TRUE : FALSE;
}


void DrawTransparentBitmap(HDC hdc, HBITMAP hBitmap, int xStart,int yStart, 
	int xWidth, int yWidth, int xSrc, int ySrc, COLORREF cTransparentColor)
/*********************************************************************
Draws the given bitmap, treating the color given by the 
cTransparentColor parameter as transparent.
**********************************************************************/
{
	BITMAP     bm;
	COLORREF   cColor;
	HBITMAP    bmAndBack, bmAndObject, bmAndMem, bmSave;
	HBITMAP    bmBackOld, bmObjectOld, bmMemOld, bmSaveOld;
	HDC        hdcMem, hdcBack, hdcObject, hdcTemp, hdcSave;
	POINT      ptSize,ptBmSize;

	hdcTemp = CreateCompatibleDC(hdc);
	SelectObject(hdcTemp, hBitmap);   // Select the bitmap
	GetObject(hBitmap, sizeof(BITMAP), (LPTSTR)&bm);
	ptSize.x = xWidth;            // Get width of bitmap
	ptSize.y = yWidth;           // Get height of bitmap
	ptBmSize.x = bm.bmWidth;            // Get width of bitmap
	ptBmSize.y = bm.bmHeight;           // Get height of bitmap
	DPtoLP(hdcTemp, &ptSize, 1);      // Convert from device
										// to logical points
	// Create some DCs to hold temporary data.
	hdcBack   = CreateCompatibleDC(hdc);
	hdcObject = CreateCompatibleDC(hdc);
	hdcMem    = CreateCompatibleDC(hdc);
	hdcSave   = CreateCompatibleDC(hdc);
   
	// Create a bitmap for each DC. DCs are required for a number of GDI functions.
	// Monochrome DC
	bmAndBack   = CreateBitmap(ptSize.x, ptSize.y, 1, 1, NULL);
	
	// Monochrome DC
	bmAndObject = CreateBitmap(ptSize.x, ptSize.y, 1, 1, NULL);
	bmAndMem    = CreateCompatibleBitmap(hdc, ptSize.x, ptSize.y);
	bmSave      = CreateCompatibleBitmap(hdc, ptSize.x, ptSize.y);
   
	// Each DC must select a bitmap object to store pixel data.
	bmBackOld   = (HBITMAP) SelectObject(hdcBack, bmAndBack);
	bmObjectOld = (HBITMAP) SelectObject(hdcObject, bmAndObject);
	bmMemOld    = (HBITMAP) SelectObject(hdcMem, bmAndMem);
	bmSaveOld   = (HBITMAP) SelectObject(hdcSave, bmSave);
	
	// Set proper mapping mode.
	SetMapMode(hdcTemp, GetMapMode(hdc));
	
	// Save the bitmap sent here, because it will be overwritten.
	BitBlt(hdcSave, 0, 0, ptSize.x, ptSize.y, hdcTemp, xSrc, ySrc, SRCCOPY);
   
	// Set the background color of the source DC to the color.
	// contained in the parts of the bitmap that should be transparent
	cColor = SetBkColor(hdcTemp, cTransparentColor);
  
  	// Create the object mask for the bitmap by performing a BitBlt
	// from the source bitmap to a monochrome bitmap.
	BitBlt(hdcObject, 0, 0, ptSize.x, ptSize.y, hdcTemp, xSrc, ySrc,SRCCOPY);

	// Set the background color of the source DC back to the original color.
	SetBkColor(hdcTemp, cColor);
   
	// Create the inverse of the object mask.
	BitBlt(hdcBack, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0,NOTSRCCOPY);
   
	// Copy the background of the main DC to the destination.
	BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdc, xStart, yStart,SRCCOPY);
   
	// Mask out the places where the bitmap will be placed.
	BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0, SRCAND);
   
	// Mask out the transparent colored pixels on the bitmap.
	BitBlt(hdcTemp, xSrc, ySrc, ptSize.x, ptSize.y, hdcBack, 0, 0, SRCAND);
	
	// XOR the bitmap with the background on the destination DC.
	BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdcTemp, xSrc, ySrc, SRCPAINT);
   
	// Copy the destination to the screen.
	BitBlt(hdc, xStart, yStart, ptSize.x, ptSize.y, hdcMem, 0, 0,SRCCOPY);
   
	// Place the original bitmap back into the bitmap sent here.
	BitBlt(hdcTemp, xSrc, ySrc, ptSize.x, ptSize.y, hdcSave, 0, 0, SRCCOPY);
   
	// Delete the memory bitmaps.
	DeleteObject(SelectObject(hdcBack, bmBackOld));
	DeleteObject(SelectObject(hdcObject, bmObjectOld));
	DeleteObject(SelectObject(hdcMem, bmMemOld));
	DeleteObject(SelectObject(hdcSave, bmSaveOld));

	// Delete the memory DCs.
	DeleteDC(hdcMem);
	DeleteDC(hdcBack);
	DeleteDC(hdcObject);
	DeleteDC(hdcSave);
	DeleteDC(hdcTemp);
}


BOOL GetSystemLanguageInfo(LPTSTR lpszLanguage, DWORD dwBufferSize,LANGID* lpLangID)
/*********************************************************************
Returns, in the buffer pointed to by the lpszLanguage parameter, a
string describing the current system language setting.  The
corresponding language ID is returned in the buffer pointed to by
lpLangID (pass NULL for lpLangID if you don't need this value).
**********************************************************************/
{
	LANGID langID = GetSystemDefaultLangID();
	if (lpLangID) *lpLangID = langID;
	DWORD dwRet = VerLanguageName(langID,lpszLanguage,dwBufferSize);
	return dwRet == 0 ? FALSE : TRUE;
}


void GetRegWizardVersionString(HINSTANCE hInstance, LPTSTR lpszVersion)
/*********************************************************************
Returns a string representing the current release version of RegWizard
**********************************************************************/
{
	TCHAR  czBuildNo[24];
	DWORD  dwStatus;
	TCHAR  uszRegKey[128];
	HKEY  hKey; 
	DWORD dwBuildNo,dwInfoSize, dwValueType;

	dwBuildNo = 0;
	uszRegKey[0] = 0;
	LoadString(hInstance, IDS_REREGISTER_OS2, uszRegKey, sizeof(uszRegKey));
	
	czBuildNo[0] =0;
	dwStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, uszRegKey, 0, KEY_READ, &hKey);
	if(dwStatus == ERROR_SUCCESS) {
		LoadString(hInstance, IDS_OSBUILDNUMBER, uszRegKey, sizeof(uszRegKey));
		dwInfoSize = sizeof(czBuildNo);
		RegQueryValueEx(hKey, uszRegKey, NULL, &dwValueType, (LPBYTE)czBuildNo, &dwInfoSize);
		RegCloseKey(hKey);
	}
	wsprintf(lpszVersion,_T("%i.%i.%s"),rmj,rmm,czBuildNo);
	
}


void RegWizardInfo(HWND hwndDlg)
/*********************************************************************
**********************************************************************/
{
	if (GetKeyState(VK_CONTROL) < 0 && GetKeyState(VK_SHIFT) < 0)
	{
		static BOOL fDecrypt = FALSE;
		long iLen = _tcslen((LPTSTR)g_rgchCredits);
		if (fDecrypt == FALSE)
		{
			fDecrypt = TRUE;
			DecryptBlock((PTBYTE) g_rgchCredits,iLen);
			g_rgchCredits[iLen] = 0;
		}
		_TCHAR rgchVersion[60];
		HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndDlg,GWLP_HINSTANCE);
		GetRegWizardVersionString(hInstance, rgchVersion);

		_TCHAR rgchInfo[340];
		_TCHAR szAbout[256];
    

		LoadString(hInstance,IDD_MICROSOFT_ABOUT_MSG,szAbout,256);
		wsprintf(rgchInfo,szAbout,rgchVersion,0xA9,g_rgchCredits);
		LoadString(hInstance,IDD_MICROSOFT_ABOUT_CAPTION,szAbout,256);
		MessageBox(hwndDlg,rgchInfo,szAbout,MB_OK | MB_ICONINFORMATION);
	}
}

void DecryptBlock (PTBYTE lpbBlock, DWORD dwBlockSize )
/**************************************************************
EncryptBlock decrypts a data block that was encrypted by the
EncryptBlock function.
 
- lpbBlock: a pointer to the block to be decrypted.
- dwBlockSize: the size, in bytes, of the given block.

Returns: nothing.
**************************************************************/
{
	for (DWORD x = 0;x < dwBlockSize;x += 2)
	{
		if ((x + 1) < dwBlockSize)
		{
			lpbBlock[x + 1] = (TBYTE)(lpbBlock[x] ^ lpbBlock[x + 1]);
		}
		WORD wRot = vrgwRot[x & 0x07];
		lpbBlock[x] = (TBYTE) ((lpbBlock[x] >> wRot) + (lpbBlock[x] << (BITS_PER_BYTE - wRot)));

	} 
}



UINT GetRegKeyValue32 ( HKEY hRootKey, LPTSTR const cszcSubKey, LPTSTR const cszcValueName,
	 PDWORD pdwType, PTBYTE pbData, UINT cbData )
/**********************************************************************
Determines the value associated with the specified Registration
Database key and value name.

Returns:
	The cb of the key data if successful, 0 otherwise.
Notes:
	If hRootKey is NULL, HKEY_CLASSES_ROOT is used for the root
***********************************************************************/
{
	HKEY hSubKey;
	LONG lErr;
	DWORD cbSize = (DWORD)cbData;

	if (hRootKey == NULL)
		hRootKey = HKEY_CLASSES_ROOT;

	lErr = RegOpenKeyEx(hRootKey, cszcSubKey, 0, KEY_READ, &hSubKey);
	if (lErr != ERROR_SUCCESS)
	{
		pdwType[0] = NULL;
		return 0;	/* Return 0 if the key doesn't exist */
	}

	lErr = RegQueryValueEx(hSubKey, (LPTSTR)cszcValueName, NULL, pdwType, (LPBYTE)pbData,
						   &cbSize);
	RegCloseKey(hSubKey);
	if (lErr != ERROR_SUCCESS)
	{
		pdwType[0] = NULL;
		return 0;	/* Return 0 if the value doesn't exist */
	}

	return (UINT)cbSize;
}


BOOL FSetDialogTabOrder(HWND hwndDlg,LPTSTR szTabOrder)
/*********************************************************************
FSetDialogTabOrder sets the tabbing order of all controls in a dialog.
Optionally, the control that should initially have the focus can be
set at the same time.

hwndDlg: handle to the dialog containing the controls.
szTabOrder: a string containing the dlg ID's of all controls in the
dialog, separated by commas.  The order of the ID's in the string
determines what the new tabbing order will be.  If any ID is 
immediately followed with 'F', the corresponding control will be
given the initial input focus.
Example: "1001,1002,105F,72,1006,1005,1007,1008"

Returns:
- TRUE: Tabbing order successfully set
- FALSE: one or more ID's in szTabOrder did not correspond to a valid
			control in the given dialog.
**********************************************************************/
{
	if (szTabOrder == NULL || szTabOrder[0] == NULL) return FALSE;

	LPTSTR sz = szTabOrder;
	int iCtrl1 = 0;
	int iCtrl2 = 0;
	while (*sz)
	{
		LPTSTR szEnd;
		iCtrl1 = iCtrl2;
		iCtrl2 = _tcstol(sz,&szEnd,10);
		HWND hwndCtrl1 = GetDlgItem(hwndDlg, iCtrl1);
		HWND hwndCtrl2 = GetDlgItem(hwndDlg, iCtrl2);
		if (!hwndCtrl2) return FALSE;

		if (*szEnd == _T('F') || *szEnd == _T('f'))
		{
			if (hwndCtrl2) SetFocus(hwndCtrl2);
			//szEnd++;
			szEnd = _tcsinc(szEnd);
		}
		if (hwndCtrl1 && hwndCtrl2)
		{
			SetWindowPos(hwndCtrl2,hwndCtrl1,0,0,0,0,SWP_NOMOVE | SWP_NOSIZE);
		}
		//sz = *szEnd == NULL ? szEnd : szEnd+1;
		sz = (*szEnd == NULL) ? szEnd : _tcsinc(szEnd);
	}
	return TRUE;
}


BOOL FResSetDialogTabOrder(HWND hwndDlg, UINT wResStringID)
/*********************************************************************
Same as FSetDialogTabOrder, except that instead of passing a pointer
to a string, the wResStringID parameter specifies a string in the 
resource string table.  

Returns:
If the string represented by wResStringID cannot be loaded, or if one
or more of the ID's in the loaded string do not correspond to a valid
dialog control, FALSE will be returned as the function result.
**********************************************************************/
{
	_TCHAR rgchTabOrder[256];
	HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndDlg,GWLP_HINSTANCE);
	if (LoadString(hInstance,wResStringID,rgchTabOrder,256) > 0)
	{
		return FSetDialogTabOrder(hwndDlg,rgchTabOrder);
	}
	else
	{
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\regpage.cpp ===
/*
	File 	: RegPage.CPP
	Date 	: 02/11/98
	Author 	: Suresh Krishnan
	
	Registration Wizard Page Control using Wizard 97 control
	
	This file exposes
	DoRegistrationWizard () which creates the necessary screen pages for RegWIz
	Modification History:
	4/29/98 : Removed Reseller screen as per Microsoft Request
	4/28/98 : Added Business user and Homer user screen

*/
#include <tchar.h>
#include <Windows.h>
#include <Resource.h>
#include <rw_common.h>
#include <fe_util.h>
#include "RegWizMain.h"
#include "RegPage.h"

BOOL bPostSuccessful = FALSE;

UINT CALLBACK DefaultPropSheetPageProc(HWND hwnd,UINT uMsg, LPPROPSHEETPAGE ppsp);
UINT CALLBACK AddressPropSheetPageProc(HWND hwnd,UINT uMsg, LPPROPSHEETPAGE ppsp);
UINT CALLBACK AddressFEPropSheetPageProc(HWND hwnd,UINT uMsg, LPPROPSHEETPAGE ppsp);
UINT CALLBACK ResellerPropSheetPageProc(HWND hwnd,UINT uMsg, LPPROPSHEETPAGE ppsp);
UINT CALLBACK RegisterPropSheetPageProc(HWND hwnd,UINT uMsg, LPPROPSHEETPAGE ppsp);

INT_PTR CALLBACK WizardDlgProc(IN HWND     hwnd,IN UINT     uMsg,IN WPARAM   wParam,IN LPARAM   lParam);
extern INT_PTR  CALLBACK WelcomeDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK InformDialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);
extern INT_PTR  CALLBACK NameDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK NameFEDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK AddressDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK AddressFEDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK ResellerDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK SystemInventoryDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK ProdInventoryDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK RegisterDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK DialupScreenProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK FinalScreenDialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam, LPARAM lParam);
//extern INT_PTR  CALLBACK FinalFailedScreenDialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK BusinessUserDialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK HomeUserDialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam, LPARAM lParam);

typedef struct RegWizPageInfo{
	DLGPROC		pfnCallback;
	LPFNPSPCALLBACK  pfnPropSheetProc;
	WORD            wDlgId;
	WORD			wTitle;
	WORD			wSubTitle;
}_RegWizPageInfo;

RegWizPageInfo RwPgInf[] = {
{WelcomeDialogProc,DefaultPropSheetPageProc, IDD_WELCOME_FOR98,IDS_WELCOME_SCR_TITLE,IDS_WELCOME_SCR_STITLE}, // Welcome Screen
{InformDialogProc,DefaultPropSheetPageProc,IDD_INFORM, IDS_INFORM_SCR_TITLE,IDS_INFORM_SCR_STITLE},  // Inform Screen
{NameDialogProc,DefaultPropSheetPageProc,IDD_NAME,  IDS_NAME_SCR_TITLE,IDS_NAME_SCR_STITLE},  // Name Screen
{AddressDialogProc,AddressPropSheetPageProc ,IDD_ADDRESS,		IDS_ADDRESS_SCR_TITLE,IDS_ADDRESS_SCR_STITLE},  // Address Screen
//{ResellerDialogProc,ResellerPropSheetPageProc,IDD_RESELLER ,  IDS_RESELLER_SCR_TITLE,IDS_RESELLER_SCR_STITLE},  // Reseller Screen
{BusinessUserDialogProc,DefaultPropSheetPageProc,IDD_BUSINESS_QUESTIONS ,  IDS_BUSINESSUSER_SCR_TITLE,IDS_BUSINESSUSER_SCR_STITLE},  // Business User Screen
{HomeUserDialogProc,DefaultPropSheetPageProc,IDD_HOME_QUESTIONS ,  IDS_HOMEUSER_SCR_TITLE,IDS_HOMEUSER_SCR_STITLE},  // Home user  Screen
{SystemInventoryDialogProc,DefaultPropSheetPageProc,IDD_INVENTORY,		IDS_SYSINV_SCR_TITLE,IDS_SYSINV_SCR_STITLE},  // Sys Inv Screen
{ProdInventoryDialogProc,DefaultPropSheetPageProc,IDD_PRODINVENTORY, IDS_PRODINV_SCR_TITLE,IDS_PRODINV_SCR_STITLE},  // Product Inventory Screen
{RegisterDialogProc,RegisterPropSheetPageProc,IDD_REGISTER, IDS_REGISTER_SCR_TITLE,IDS_REGISTER_SCR_STITLE},  // Register Screen
{DialupScreenProc,DefaultPropSheetPageProc,IDD_DIAL, IDS_DIALUP_SCR_TITLE,IDS_DIALUP_SCR_STITLE}  // Dialup Screen

};

RegWizPageInfo RwFEPgInf[] = {
{NameFEDialogProc,DefaultPropSheetPageProc,IDD_NAME_FE,  IDS_NAME_SCR_TITLE,IDS_NAME_SCR_STITLE},  // Name Screen
{AddressFEDialogProc,AddressFEPropSheetPageProc ,IDD_ADDRESS_FE,		IDS_ADDRESS_SCR_TITLE,IDS_ADDRESS_SCR_STITLE},  // Address Screen

};


//
//  Default Property Sheet Procedure called during Property Sheet creatinion
//  and deletion
//
//
//
UINT CALLBACK DefaultPropSheetPageProc(HWND hwnd,
								UINT uMsg,
								LPPROPSHEETPAGE ppsp
								)
{
	
	switch(uMsg) {
	case PSPCB_CREATE :
	default:
		break;

	}
	return 1;

}

INT_PTR DoRegistrationWizard(HINSTANCE hInstance,
						  CRegWizard* pclRegWizard,
						  LPTSTR szProductPath)

{
    UINT				iPage;
	UINT			kNumPages           = kDialogExit+1;
	INT_PTR			iError;

	UINT            i                   = 0;
    BOOL            bStatus             = TRUE;
    PageInfo        PageInfo            = {0};
    PROPSHEETPAGE   psp                 = {0};
    HPROPSHEETPAGE  *ahpsp;
    PROPSHEETHEADER psh                 = {0};

	iError = RWZ_ERROR_CANCELLED_BY_USER;

	#ifdef _LOG_IN_FILE
		 RW_DEBUG  << "\n INFORM DIALOG HEADER"<< flush;
	#endif

	// Allocate and initialize
    ahpsp = (HPROPSHEETPAGE *) GlobalAlloc( GMEM_FIXED, sizeof( HPROPSHEETPAGE) *
										kNumPages);

	for(iPage=0;iPage < kNumPages;iPage++) {
		ahpsp[iPage] = 0;			
	}
	iPage = 0;
	// Create Welcome Page
	psp.pfnCallback         = DefaultPropSheetPageProc;
	psp.dwSize              = sizeof( psp );
    psp.dwFlags             = PSP_DEFAULT;
    psp.hInstance           = hInstance;
    psp.lParam              = (LPARAM)&PageInfo;
	psp.pfnDlgProc          = WelcomeDialogProc;
	psp.dwFlags             = PSP_DEFAULT | PSP_HIDEHEADER| PSP_USECALLBACK ;;
    psp.pszTemplate         = MAKEINTRESOURCE( IDD_WELCOME);
	ahpsp[iPage++]          = CreatePropertySheetPage( &psp );

	psp.dwFlags             = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE |PSP_USECALLBACK ;
	

	for(;iPage < kNumPages-1 ;){
		psp.pfnDlgProc          = RwPgInf[iPage].pfnCallback;
			//(int (__stdcall *)(void))NameDialogProc;
		psp.pfnCallback         =  RwPgInf[iPage].pfnPropSheetProc;
		//psp.pfnDlgProc          = WizardDlgProc;
		psp.pszHeaderTitle      = MAKEINTRESOURCE(RwPgInf[iPage].wTitle);
		psp.pszHeaderSubTitle   = MAKEINTRESOURCE(RwPgInf[iPage].wSubTitle);
		
		if(iPage == kInformDialog)
		{
			_TCHAR szheader[256],szheaderInfo[256],szInfo[256];
			LoadString(hInstance,IDS_INFORM_SCR_STITLE,szheaderInfo,256);
			pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szInfo);
			_stprintf(szheader,szheaderInfo,szInfo);
			psp.pszHeaderSubTitle   = szheader;
		}
		else
		if(iPage == kDialupDialog)
		{
			_TCHAR szheader[256],szheaderInfo[256],szInfo[256];
			LoadString(hInstance,IDS_DIALUP_SCR_STITLE,szheaderInfo,256);
			pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szInfo);
			_stprintf(szheader,szheaderInfo,szInfo);
			psp.pszHeaderSubTitle   = szheader;
		}

		psp.pszTemplate         = MAKEINTRESOURCE(RwPgInf[iPage].wDlgId  );

		// Change the
		if(IsFarEastCountry(hInstance) ==  kFarEastCountry ) {
			switch( iPage) {
			case kNameDialog   :
			case kAddressDialog:
				psp.pfnDlgProc          = RwFEPgInf[iPage-kNameDialog].pfnCallback;
				psp.pfnCallback         = RwFEPgInf[iPage-kNameDialog].pfnPropSheetProc;
				psp.pszHeaderTitle      = MAKEINTRESOURCE(RwFEPgInf[iPage-kNameDialog].wTitle);
				psp.pszHeaderSubTitle   = MAKEINTRESOURCE(RwFEPgInf[iPage-kNameDialog].wSubTitle);
				psp.pszTemplate         = MAKEINTRESOURCE(RwFEPgInf[iPage-kNameDialog].wDlgId);
				break;
			default :
			break;
			}
		}
		ahpsp[iPage++]          = CreatePropertySheetPage( &psp );
	}

	// Create Last Page
	//psp.dwFlags             = PSP_DEFAULT ;
	psp.pszTemplate         = MAKEINTRESOURCE(IDD_FAILURE_REGISTRATION);	
	psp.pfnDlgProc          = FinalScreenDialogProc;

	psp.dwFlags             = PSP_DEFAULT | PSP_HIDEHEADER;

    ahpsp[iPage++]          = CreatePropertySheetPage( &psp );

	psh.dwFlags             = PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
	psh.dwFlags             &= ~(PSH_HASHELP);
	psh.pszbmWatermark      = MAKEINTRESOURCE(IDB_WATERMARK);
    psh.pszbmHeader         = MAKEINTRESOURCE(IDB_BANNER);

    psh.dwSize              = sizeof( psh );
    psh.hInstance           = hInstance;
    psh.hwndParent          = NULL;
    psh.pszCaption          = _T("Registration Wizard for Windows NT ");//MAKEINTRESOURCE( IDS_TITLE );
    psh.phpage              = ahpsp;
    psh.nStartPage          = 0;
    psh.nPages              = iPage;
    PageInfo.TotalPages     = iPage;
	PageInfo.pclRegWizard   = pclRegWizard;
	PageInfo.hInstance		= hInstance;
	PageInfo.pDialupHelper  = NULL;
	PageInfo.ErrorPage      = -1;
	PageInfo.dwConnectionType   =1;
    PageInfo.pszProductPath = szProductPath;

    //
    // Create the bold fonts.
    //
    SetupFonts( hInstance, NULL, &PageInfo.hBigBoldFont, &PageInfo.hBoldFont );

    //
    // Validate all the pages.
    //
    for( i = 0; i < kNumPages; i++ )
    {
        if( ahpsp[i] == 0 )
        {
            bStatus = FALSE;
        }
    }

	INT_PTR iRetVal=0;
    //
    // Display the wizard.
    //
    if( bStatus )
    {
		iRetVal = PropertySheet( &psh );
        if(iRetVal  == -1 )
        {
            bStatus = FALSE;
        }
    }
	if( iRetVal == 0 ) {
		// Cancelled By the User
		if( PageInfo.ErrorPage  == kWelcomeDialog) {
				
				iError = PageInfo.iError;
				return iError;
			;
		}
	}
    if( !bStatus )
    {
        //
        // Manually destroy the pages if something failed.
        //
        for( i = 0; i < psh.nPages; i++)
        {
            if( ahpsp[i] )
            {
                DestroyPropertySheetPage( ahpsp[i] );
            }
        }
    }

    //
    // Destroy the fonts that were created.
    //
    DestroyFonts( PageInfo.hBigBoldFont, PageInfo.hBoldFont );

    return iError;


}



//
// Wizard dialog proc.
//
INT_PTR CALLBACK
WizardDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{
    BOOL bStatus = TRUE;
    PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwnd, GWLP_USERDATA );

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR)pi );
        if( ( pi->CurrentPage == 0 ) || ( pi->CurrentPage == pi->TotalPages - 1 ) )
        {
        	SetControlFont( pi->hBigBoldFont, hwnd, IDT_TEXT1);
	        //SetControlFont( pi->hBoldFont,    hwnd, IDC_BOLDTITLE);
        }
        break;

    case WM_DESTROY:
        SetWindowLongPtr( hwnd, GWLP_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:
                if( pi->CurrentPage == 0 )
                    PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT );
                else if( pi->CurrentPage == pi->TotalPages - 1 ) {
                    PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK | PSWIZB_FINISH );
					// PropSheet_SetFinishText(GetParent( hwnd ),"Register");
				}
                else
                    PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK );
                break;

            case PSN_WIZNEXT:
                pi->CurrentPage++;
                break;

            case PSN_WIZBACK:
                pi->CurrentPage--;
                break;
			case PSN_QUERYCANCEL :
				
				SetWindowLongPtr( GetParent( hwnd ),DWLP_MSGRESULT, (LONG_PTR) 5);
				break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}


VOID
SetControlFont(
    IN HFONT    hFont,
    IN HWND     hwnd,
    IN INT      nId
    )
{
	if( hFont )
    {
    	HWND hwndControl = GetDlgItem(hwnd, nId);

    	if( hwndControl )
        {
        	SetWindowFont(hwndControl, hFont, TRUE);

        }
    }
}

VOID
SetupFonts(
    IN HINSTANCE    hInstance,
    IN HWND         hwnd,
    IN HFONT        *pBigBoldFont,
    IN HFONT        *pBoldFont
    )
{
    //
	// Create the fonts we need based on the dialog font
    //
	NONCLIENTMETRICS ncm = {0};
	ncm.cbSize = sizeof(ncm);
	SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

	LOGFONT BigBoldLogFont  = ncm.lfMessageFont;
	LOGFONT BoldLogFont     = ncm.lfMessageFont;

    //
	// Create Big Bold Font and Bold Font
    //
    BigBoldLogFont.lfWeight   = FW_BOLD;
	BoldLogFont.lfWeight      = FW_BOLD;

    TCHAR FontSizeString[MAX_PATH];
    INT FontSize;

    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //
    if(!LoadString(hInstance,IDS_LARGEFONTNAME,BigBoldLogFont.lfFaceName,LF_FACESIZE))
    {
        lstrcpy(BigBoldLogFont.lfFaceName,TEXT("MS Shell Dlg"));
    }

    if(LoadString(hInstance,IDS_LARGEFONTSIZE,FontSizeString,sizeof(FontSizeString)/sizeof(TCHAR)))
    {
        FontSize = _tcstoul( FontSizeString, NULL, 10 );
    }
    else
    {
        FontSize = 12;
    }

	HDC hdc = GetDC( hwnd );

    if( hdc )
    {
        BigBoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);

        *pBigBoldFont = CreateFontIndirect(&BigBoldLogFont);
		*pBoldFont    = CreateFontIndirect(&BoldLogFont);

        ReleaseDC(hwnd,hdc);
    }
}

VOID
DestroyFonts(
    IN HFONT        hBigBoldFont,
    IN HFONT        hBoldFont
    )
{
    if( hBigBoldFont )
    {
        DeleteObject( hBigBoldFont );
    }

    if( hBoldFont )
    {
        DeleteObject( hBoldFont );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\rw_common.cpp ===
/*

	File : RW_COMMON.CPP
	Date : 04/22/97
	Author : Suresh Krishnan

	Common functions for RegWiz 

*/

#include "RW_Common.h"
#include "resource.h"
#include <ATKInternet.h>

#define STRCONVERT_MAXLEN    1024
static TCHAR gszProductBeingRegistred[128]= _T("");
static TCHAR gszTempProdWithOem[256] =_T("");
//
// This Function returns the Security Descriptor
//
REGSAM RW_GetSecDes() 
{ 
#ifdef _WINDOWS95
	return NULL; 
#else 
	return NULL;
	//
	// To be implemented for NT
#endif
}


void RWDebug :: UseStandardOutput()
{
	fp = stdout;
}

void RWDebug :: CreateLogFile(char *czFName)
{
	char   czTmpPath[256] = "";
	char   czLogFile[256];
	czLogFile[0] = '\0';

#ifdef _LOG_IN_FILE
	if( GetEnvironmentVariableA("TEMP",czTmpPath,228) > 0 ) {
			strcpy(czLogFile,czTmpPath);
	}
	strcat(czLogFile,"\\");
	strcat(czLogFile,czFName);
	fp = fopen(czLogFile,"w");
	if(fp == NULL) {
		m_iError = -1;
	}
#else
	UseStandardOutput();
#endif

		
}

RWDebug& RWDebug:: Write (char *czP)
{
	
	if(m_iError < 0  ) return *this;

	if(fp == NULL) {
		CreateLogFile("REGWIZ.LOG");
		// Fail to create file
		if(m_iError < 0) return *this;
	}

	

	if(czP  && *czP) {
		//OutputDebugStringA(czP);
		
		m_iError = fputs(czP,fp);
		m_iError = fflush(fp);
	}
    return *this;
}


RWDebug& RWDebug:: operator << (int  iv)
{
	sprintf(czTemp,"%d",iv);
	return Write(czTemp);;
}

RWDebug& RWDebug:: operator << (unsigned int  iv)
{
	sprintf(czTemp,"%d",iv);
	return Write(czTemp);;
    
}

RWDebug& RWDebug:: operator << (long  iv)
{
	
	sprintf(czTemp,"%d",iv);
	return Write(czTemp);
    
}

RWDebug& RWDebug:: operator << (unsigned long  iv)
{
	sprintf(czTemp,"%d",iv);
	return Write(czTemp);;
	
}


RWDebug& RWDebug:: operator << (short   iv)
{
	
	sprintf(czTemp,"%d",iv);
	return Write(czTemp);;
    
}

RWDebug& RWDebug:: operator << (unsigned short  iv)
{
	
	sprintf(czTemp,"%d",iv);
	return Write(czTemp);
}

RWDebug& RWDebug:: operator << (char cV)
{
	
	sprintf(czTemp,"%c",cV);
	return Write(czTemp);
    
}

RWDebug& RWDebug:: operator << (float  iv)
{
	
	sprintf(czTemp,"%10.4f",iv);
	return Write(czTemp);
    
}

RWDebug& RWDebug:: operator << (char *czP)
{
	return Write(czP);
	
}

RWDebug& RWDebug:: operator << (const char *czP)
{
	return Write((char *) czP);
	
}
RWDebug& RWDebug :: operator << ( unsigned short *usv) 
{ 
	char *czP;
	if(usv && *usv) {
		czP = ConvertToANSIString(usv);
		if(czP && *czP)
		Write((char *) czP);

	}
	return *this;
}

RWDebug& RWDebug :: operator << ( void *p) 
{ 
	
	if(p) {
		sprintf(czTemp,"Addr :0x%p",p);
		Write(czTemp);

	}
	return *this;
}
 
RWDebug& GetDebugLogStream()
{
	static RWDebug  rwD;
	return rwD;
}
/***
ostream &GetDebugLogStream()
{
	static ostream *os;
	char   czTmpPath[256] = "";
	char   czLogFile[256];

	czLogFile[0] = '\0';
	if(os == NULL)  {
#ifdef _LOG_IN_FILE
		if( GetEnvironmentVariableA("TEMP",czTmpPath,228) > 0 ) {
			strcpy(czLogFile,czTmpPath);
		}
		strcat(czLogFile,"\\REGWIZ.LOG");
		
		os = new ofstream (czLogFile);
		if( os == NULL ){
			os = &cout;
		}
#else
		os = &cout;
#endif

	}
	return *os;
			
}
***/
/*	Value  -- > "CurrentDriveLetterAssignment"		Data -- > "A"
	Value  -- > "Removable"							Data -- > 01
	Value  -- > "Class"								Data -- > "DiskDrive"*/


int RegFindValueInAllSubKey(HINSTANCE hInstance,HKEY key ,LPCTSTR szSubKeyNameToFind,LPCTSTR szValueToFind,LPTSTR szIdentifier,int nType )
{
   DWORD   dwRet,dwIndex,dwSubkeyLen;
   TCHAR   szSubKey[256],szFloppy[256];
   BOOL    bType = FALSE,bRemovable = FALSE,bPrevMassStorage,bPrevFloppy;
   HKEY    hKey;
   static BOOL bMassStorage = FALSE;
   static BOOL bFloppy = FALSE;
	
   bPrevMassStorage =	bMassStorage;
   bPrevFloppy		=	bFloppy;

   if (szSubKeyNameToFind != NULL)
   {
     dwRet=RegOpenKeyEx(
						 key,
						 szSubKeyNameToFind,
						 0,
						 KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
						 &hKey 
						 );

	 if( dwRet == ERROR_SUCCESS)
	 {	 dwIndex = 0;
         while (dwRet == ERROR_SUCCESS )
         {
            dwSubkeyLen = 256;
			dwRet=RegEnumKeyEx(
                           hKey,
                           dwIndex,       
                           szSubKey,
                           &dwSubkeyLen,
                           NULL,
                           NULL,
                           NULL,
                           NULL
                         );
 
            if(dwRet == ERROR_NO_MORE_ITEMS)
            {
				_TCHAR		valueName[80];
				DWORD		valueNameSize,valueSize,n = 0;
				TBYTE		value[80];
				
                do
				{
					valueNameSize=80* sizeof(_TCHAR);
					valueSize=80* sizeof(TBYTE);
					dwRet = RegEnumValue(
										 hKey,
										 n,
										 valueName,
										 &valueNameSize,
										 NULL,
										 NULL,
										 (LPBYTE) value,
										 &valueSize
										 );
					if(dwRet == ERROR_SUCCESS)
					{
						
						if(nType == 1)
						{
							if (!_tcscmp(valueName,_T("Type"))) 
							{
								if (!_tcscmp(szValueToFind,(LPCTSTR)value))
								{
									bType = TRUE;
								}
							}
							if (!_tcscmp(valueName,_T("Identifier"))) 
							{
								_tcscpy(szIdentifier,(LPCTSTR)value);
							}
						}
						else
						if(nType == 2)
						{
							if (!_tcscmp(valueName,_T("Class"))) 
							{
								if (!_tcscmp(szValueToFind,(LPCTSTR)value))
								{
									bType = TRUE;
								}
							}
							if (!_tcscmp(valueName,_T("DeviceDesc"))) 
							{
// bFloppy and bMassStorage are used for handling the conditions when there are multiple 
// Floppy and mass storage media present.
								_tcscpy(szFloppy,(LPCTSTR)value);
								_tcsupr(szFloppy);
								if(_tcsstr(szFloppy,_T("FLOPPY")) != NULL)
								{
									if(!bFloppy)
									{
										_tcscpy(szFloppy,(LPCTSTR)value);
										bFloppy = TRUE;
									}
								}
								else
// if it is not removable or it is a cdrom the condition for type and removable 
// takes care of it.
								{
									if(!bMassStorage)
									{
										bMassStorage = TRUE;
									}
								}

							}
							if (!_tcscmp(valueName,_T("Removable"))) 
							{
								if (*value == 0x01 )
								{
									bRemovable = TRUE;
								}
							}
							/*if (!_tcscmp(valueName,_T("CurrentDriveLetterAssignment"))) 
							{
								_tcscpy(szRemovableTemp,(LPCTSTR)value);
							}*/
							
						}
						n++;
					}

				} while (dwRet == ERROR_SUCCESS);

				if(nType == 1)
				{
					if(bType)
					{
						return REGFIND_FINISH;
					}
					else
					{
						return REGFIND_RECURSE;
					}
				}
				else
				if(nType == 2)
				{

					if(bType && bRemovable )
					{
					/*	_tcscat(szRemovableTemp,_T(":"));
						_tcscat(szRemovableTemp,szIdentifier);
						_tcscpy(szIdentifier,szRemovableTemp);*/
						if(bFloppy != bPrevFloppy )
						{						
							_tcscpy(szIdentifier,szFloppy);	
						}
						if(bFloppy && bMassStorage)
						{
							_TCHAR szMassString[64];
							LoadString(hInstance,IDS_MASS_STRORAGE_ENTRY,szMassString,64);
							_tcscat(szIdentifier,szMassString);	
							return REGFIND_FINISH;
						}
						return REGFIND_RECURSE;
					}
// The bMassStorage flag has to be reset to the previous state. 
					else
					{
						bMassStorage = bPrevMassStorage;
						if(bFloppy != bPrevFloppy)
							bFloppy = bPrevFloppy;
						return REGFIND_RECURSE;
					}
				}            
			}
            else
			{
				if(dwRet == ERROR_SUCCESS)
				{
					int nStatus;
					nStatus = RegFindValueInAllSubKey(hInstance,hKey, szSubKey,szValueToFind,szIdentifier,nType);

					switch(nStatus)
					{
						case REGFIND_FINISH:
							{
								return REGFIND_FINISH;
							}
						case REGFIND_ERROR:
							{
								return REGFIND_ERROR;
							}
						default :
							{
								if(bFloppy != bPrevFloppy)
								  bPrevFloppy = bFloppy;
						
							}
							break;
					}
					
					dwIndex++;
				}
			}
         }
         RegCloseKey(hKey);
      }
	  else
	  {
		  RW_DEBUG << "Error Opening the key " << ConvertToANSIString(szSubKeyNameToFind)<< flush;
	  }
   }
   else
   {
	   RW_DEBUG << "Error: key cannot be NULL" << flush;
   }
 
   return REGFIND_ERROR;
}


BOOL RegFindTheSubKey(HKEY key,LPCTSTR szSubKeyName,LPCTSTR szSubKeyNameToFind,LPTSTR szData )
{
   DWORD   dwRet,dwIndex,dwSubkeyLen;
   TCHAR   szSubKey[256];
   HKEY    hKey;

   if (szSubKeyName != NULL)
   {
     dwRet=RegOpenKeyEx(
						 key,
						 szSubKeyName,
						 0,
						 KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
						 &hKey 
						);

	 if( dwRet == ERROR_SUCCESS)
	 {	 dwIndex = 0;
         while (dwRet == ERROR_SUCCESS )
         {
            dwSubkeyLen = 256;
			dwRet=RegEnumKeyEx(
                           hKey,
                           dwIndex,       
                           szSubKey,
                           &dwSubkeyLen,
                           NULL,
                           NULL,
                           NULL,
                           NULL
                         );
 
            if(dwRet == ERROR_NO_MORE_ITEMS)
            {
					return FALSE;
            }
            else
			{
  			 if(dwRet == ERROR_SUCCESS)
			 {
				if(!_tcscmp(szSubKey,szSubKeyNameToFind))
				{
					if(RegGetPointingDevice(hKey,szSubKey,szData))
					{
						RegCloseKey(hKey);
						return TRUE;
					}
					else
						return FALSE;
				}
				else
				if(RegFindTheSubKey(hKey,szSubKey,szSubKeyNameToFind,szData))
				{
					return TRUE;
				}
			 }
			 dwIndex++;
			}
         }
         RegCloseKey(hKey);
      }
	  else
	  {
		  RW_DEBUG << "Error Opening the key " << ConvertToANSIString(szSubKeyNameToFind) << flush;
	  }
   }
   else
   {
	   RW_DEBUG << "Error: key cannot be NULL"<< flush;
   }
 
   return FALSE;
}


BOOL RegGetPointingDevice(HKEY Key,LPCTSTR szSubKeyName,LPTSTR szData)
{
   DWORD	dwRet,dwSubkeyLen;
   _TCHAR	szSubKey[256];
   _TCHAR	valueName[80];
   DWORD	valueNameSize;
   TBYTE	value[80];
   DWORD	valueSize;
   DWORD	n = 0;
   HKEY		hKey,hKey2;

   dwRet=RegOpenKeyEx(
						 Key,
						 szSubKeyName,
						 0,
						 KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
						 &hKey 
						);

   if( dwRet == ERROR_SUCCESS)
	{
	  dwSubkeyLen = 256;
      dwRet=RegEnumKeyEx(
                           hKey,
                           0,       
                           szSubKey,
                           &dwSubkeyLen,
                           NULL,
                           NULL,
                           NULL,
                           NULL
                         );

	  dwRet=RegOpenKeyEx(
						 hKey,
						 szSubKey,
						 0,
						 KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
						 &hKey2 
						);
      if (dwRet == ERROR_SUCCESS)
      {
         do
		   {
			   valueNameSize=80 * sizeof(TCHAR);
			   valueSize=80 * sizeof(TCHAR);

               dwRet = RegEnumValue(
								     hKey2,
								     n,
								     valueName,
								     &valueNameSize,
								     NULL,
								     NULL,
								     (LPBYTE) value,
								     &valueSize
								     );
			   if(dwRet == ERROR_SUCCESS)
			   {
				   if (!_tcscmp(valueName,_T("Identifier"))) 
				   {
					   _tcscpy(szData,(LPCTSTR)value);
			           RegCloseKey(hKey2);
				       RegCloseKey(hKey);
					   return TRUE;
				   }
				   n++;
			   }
		    } while (dwRet == ERROR_SUCCESS);
         RegCloseKey(hKey2);
      }
      RegCloseKey(hKey);
   }
   return FALSE;
}


//
// This function Converts  an UNICODE to String
//
//
LPCTSTR BstrToSz(BSTR pszW)
{
#ifndef _UNICODE 
	ULONG cbAnsi, ulNoOfChars;
	DWORD dwError;
	LPTSTR lpString;
	if(pszW== NULL) 
		return NULL;
	ulNoOfChars = wcslen(pszW)+1;
	cbAnsi =   ulNoOfChars +2;
	lpString = (LPTSTR) CoTaskMemAlloc(cbAnsi);
	if( NULL == lpString )
		return NULL;
	if( WideCharToMultiByte(CP_ACP,0,pszW,ulNoOfChars,lpString,cbAnsi,NULL,NULL) == 0) {
		dwError = GetLastError();
		CoTaskMemFree(lpString);
		lpString = NULL;
	}
	return lpString;
#endif
	return (LPCTSTR)  pszW;


}


int  GetProductRoot (LPTSTR pPath , PHKEY  phKey)
{

    LONG regStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
		pPath,0,KEY_READ |KEY_WRITE,phKey);
	if (regStatus != ERROR_SUCCESS) {
		return 1; // error
	}
	else{
		return 0; // Success 
	}

}


//
//  This function converts an UNICODE STRING to ANSI char String
//
//
char * ConvertToANSIString (LPCTSTR   pszW)
{

#ifdef _UNICODE 
	static char szAString[STRCONVERT_MAXLEN];
	ULONG cbAnsi, ulNoOfChars;
	DWORD dwError;
	LPSTR lpString;
	if(pszW == NULL) 
		return NULL;
	if(*pszW == 0) {
		return NULL;

	}
	ulNoOfChars = wcslen(pszW)+1;
	cbAnsi =   ulNoOfChars +2;
	lpString = (LPSTR) szAString;
	if( WideCharToMultiByte(CP_ACP,0,pszW,ulNoOfChars,lpString,STRCONVERT_MAXLEN,NULL,NULL) == 0) {
		dwError = GetLastError();
		lpString = NULL;
	}
	return lpString;
#else
	return (LPTSTR)  pszW;
#endif
 
}



#ifdef _UNICODE

TCHAR* ConvertToUnicode(char FAR* szA)
{
  static TCHAR  achW[STRCONVERT_MAXLEN]; 
  MultiByteToWideChar(CP_ACP, 0, szA, -1, achW, STRCONVERT_MAXLEN);  
  return achW; 
}

#else
//
//  in case of 
TCHAR * ConvertToUnicode(TCHAR * szW) 
{
	return szW;
}
#endif

TCHAR * GetProductBeingRegistred()
{
	return  gszProductBeingRegistred;
}

void SetProductBeingRegistred(TCHAR *szProduct)
{
	_tcscpy (gszProductBeingRegistred,szProduct);
}

void GetWindowsDirectory(TCHAR *szParamRegKey,
						 TCHAR *czBuf)
{
	HKEY hKey;
	TCHAR szRetVal[128];
	DWORD dwSize= 128;
	LONG regStatus ;

	_tcscpy(czBuf,_T("")); // Set Path to Blank


	GetProductRoot(szParamRegKey , &hKey);
	if(!hKey) {
		return ;
	}
	regStatus = RegQueryValueEx(hKey,
		_T("SystemRoot"),
		NULL,
		0,
		(LPBYTE) szRetVal,
		&dwSize);
	if (regStatus == ERROR_SUCCESS){
		// Verifty the Value 
		//
		_tcscpy(czBuf,szRetVal);
	}
	RegCloseKey(hKey);
	
}


/*
	Returns 1 if successful
	        0 if failure
*/
int GetOemManufacturer (TCHAR *szProductRegKey, TCHAR *szBuf )
{ 
	TCHAR szSection[] = _T("general");
	TCHAR szKeyName[] = _T("Manufacturer");
	TCHAR szOemFile[MAX_PATH] = _T("");
	
	GetSystemDirectory(szOemFile,MAX_PATH);
	_tcscat(szOemFile,_T("\\Oeminfo.ini"));

	if( CheckOEMdll()== OEM_NO_ERROR ) {
		GetPrivateProfileString (szSection,
							 szKeyName,
							 _T(""),
							 szBuf, 
							 256,
							 szOemFile
							 );
		return 1;
	}
	else {
		return 0;
	}
}

void SetMSID(HINSTANCE hInstance)
{
 
 DWORD	dwRet;
 _TCHAR szKeyName[256];
 HKEY	hIDKey;
 TCHAR  szMSID[256];
 
 
 if(!GetMSIDfromCookie(hInstance,szMSID)){
	 szMSID[0] = _T('\0');
 }
 else {
	
	_TCHAR szPartialKey[256];
	int resSize = LoadString(hInstance,IDS_KEY2,szKeyName,255);
	_tcscat(szKeyName,_T("\\"));
	resSize = LoadString(hInstance,IDS_KEY3,szPartialKey,255);
	_tcscat(szKeyName,szPartialKey);
	_tcscat(szKeyName,_T("\\"));
	resSize = LoadString(hInstance,IDS_KEY4,szPartialKey,255);
	_tcscat(szKeyName,szPartialKey);

	dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szKeyName,0,KEY_ALL_ACCESS,&hIDKey);
	if (dwRet == ERROR_SUCCESS) {
		// Store MSID into
		dwRet = RegSetValueEx(hIDKey,_T("MSID"),NULL,REG_SZ,(CONST BYTE *)szMSID,
								_tcslen((LPCTSTR)szMSID)*sizeof(TCHAR) );
		RegCloseKey(hIDKey);
	}

 }
}

void RemoveMSIDEntry(HINSTANCE hInstance)
{
    DWORD	dwRet;		
	 HKEY	hIDKey;
	_TCHAR szPartialKey[256];
	_TCHAR szValue[256];
	 _TCHAR szKeyName[256];
	int resSize = LoadString(hInstance,IDS_KEY2,szKeyName,255);
	_tcscat(szKeyName,_T("\\"));
	resSize = LoadString(hInstance,IDS_KEY3,szPartialKey,255);
	_tcscat(szKeyName,szPartialKey);
	_tcscat(szKeyName,_T("\\"));
	resSize = LoadString(hInstance,IDS_KEY4,szPartialKey,255);
	_tcscat(szKeyName,szPartialKey);
	szValue[0] = _T('\0');
	resSize = LoadString(hInstance,IDS_NOTUSED,szValue,255);

	dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szKeyName,0,KEY_ALL_ACCESS,&hIDKey);
	if (dwRet == ERROR_SUCCESS){
		// Store MSID into
		dwRet = RegSetValueEx(hIDKey,_T("MSID"),NULL,REG_SZ,(CONST BYTE *)szValue,
								_tcslen((LPCTSTR)szValue)* sizeof(_TCHAR));
		RegCloseKey(hIDKey);
	}
	// 
	// Set in Current User
	_tcscpy(szKeyName,_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"));
	dwRet = RegOpenKeyEx(HKEY_CURRENT_USER,szKeyName,0,KEY_ALL_ACCESS,&hIDKey);
	if (dwRet == ERROR_SUCCESS){
		// Store MSID into
		dwRet = RegSetValueEx(hIDKey,_T("MSID"),NULL,REG_SZ,(CONST BYTE *)szValue,
								_tcslen((LPCTSTR)szValue)* sizeof(_TCHAR));
		RegCloseKey(hIDKey);
	}


}

BOOL GetMSIDfromCookie(HINSTANCE hInstance,LPTSTR szMSID)
{	
	_TCHAR szCookieInfo[256],szRegisterSiteURL[256],szTmpURL1[256];
	_TCHAR szTmpURL2[256];
	DWORD dwSize = 256;
	
	_tcscpy(szTmpURL1,_T("http://"));
	LoadString(hInstance, IDS_HTTP_SERVER,szRegisterSiteURL, 255);
	_tcscat(szTmpURL1,szRegisterSiteURL);
	LoadString(hInstance, IDS_HTTP_SERVER_PATH,szTmpURL2, 255);
	
	InternetCombineUrl(	szTmpURL1,	szTmpURL2,	szRegisterSiteURL,
									&dwSize,	ICU_DECODE );

	dwSize = 256;
	//
	
	BOOL bRet = ATK_InternetGetCookie(szRegisterSiteURL,
		_T(""),szCookieInfo,&dwSize );
   
	if(bRet)
	{
		if(szCookieInfo[0] != _T('\0')){
			RW_DEBUG <<"\nAfterInternetGetCookie "  << ConvertToANSIString(szCookieInfo) << flush;
		}

		BOOL bfound = FALSE;

		_TCHAR seps[] = _T("=");
		_TCHAR *token;

		token = _tcstok( szCookieInfo, seps );
	
	    while( token != NULL )
		{
		  if(!_tcscmp(token,_T("GUID")))
		  {
			  bfound = TRUE;
			  break;
		  }
	      token = _tcstok( NULL, seps );
		}

		if(bfound)
		{
		  token = _tcstok( NULL, seps );
		  _tcscpy(szMSID,token);
		 RW_DEBUG <<"\n Cookie Found " << ConvertToANSIString(szMSID) << flush;
		  return TRUE;
	    }
		else
		{
			_tcscpy(szMSID,_T(""));
		}
	}
	else
	{
		_tcscpy(szMSID,_T(""));
	}
	return FALSE;
}

BOOL GetMSIDfromRegistry(HINSTANCE hInstance,LPTSTR szValue)
{
	HKEY hKeyMSID;

	_TCHAR szKeyName[256];
	
	_tcscpy(szKeyName,_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"));
	
	LONG regStatus = RegOpenKeyEx(HKEY_CURRENT_USER,szKeyName,0,KEY_READ,&hKeyMSID);
	if (regStatus == ERROR_SUCCESS)
	{
		_TCHAR szValueName[64];
		unsigned long infoSize = 255;
		LoadString(hInstance,IDS_MSID,szValueName,64);
		regStatus = RegQueryValueEx(hKeyMSID,szValueName,NULL,0,(LPBYTE) szValue,&infoSize);
		if (regStatus == ERROR_SUCCESS)
		{
			RegCloseKey(hKeyMSID);
			RW_DEBUG <<"\n GetCookie from Registry "  << ConvertToANSIString(szValue) << flush;
			return TRUE;
		}
	}
	RegCloseKey(hKeyMSID);
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\sysinv.cpp ===
/*********************************************************************
Registration Wizard

sysinv.cpp
02/24/98  - Suresh Krishnan
07/20/98  - Suresh Krishnan
		    GetSCSIAdapterString() function is addded to get SCSI adapter details
	
(c) 1994-95 Microsoft Corporation
08/06/98   GetDisplayResolutionString() is  modified so it now gets Display Adapter with Resolution
**********************************************************************/
#include <tchar.h>
#include <Windows.h>
#include <stdio.h>
#include "sysinv.h"
#include "resource.h"


// The packed structures below get messed up with optimizations turned on
#pragma optimize( _T(""), off )

typedef BOOL   (APIENTRY *GETSYSTEMINVENTORY) ( INT ,LPTSTR );
HINSTANCE   hSiDllInst=NULL;
GETSYSTEMINVENTORY m_fp = NULL ;
BOOL WINAPI GetSystemInventory(INT type, LPTSTR szInventory)
{
	static int iEntry=0;
	if(!iEntry) {
		hSiDllInst = LoadLibrary(_T("SYSINV.DLL"));

		if(hSiDllInst == NULL ) {
			m_fp = NULL;
			iEntry = 1;
			return FALSE;
		}

	#ifdef UNICODE
		m_fp = (GETSYSTEMINVENTORY ) GetProcAddress(hSiDllInst, "GetSystemInventoryW");
	#else
		m_fp = (GETSYSTEMINVENTORY ) GetProcAddress(hSiDllInst, "GetSystemInventoryA");
	#endif
		iEntry = 1;
	}
	if(m_fp){
		return (*m_fp)(type ,szInventory);
	}else {
		return FALSE;
	}

}

int CheckSysInvDllPresent()
{
	int iRet;
	iRet = SYSINV_DLL_NOTPRESENT;
	HANDLE  hSi;
	hSi = LoadLibrary(_T("SYSINV.DLL"));
	if(hSi) {
		iRet = SYSINV_DLL_PRESENT;
	}
	return iRet;

}

void GetOEMString(HINSTANCE hInstance, LPTSTR szOEM)
/*********************************************************************
Returns a string containing the name of the Original Equipment
Manufacturer.
**********************************************************************/
{
	GetSystemInventory(INV_OEM, szOEM);
	
}


void GetProcessorTypeString(HINSTANCE hInstance, LPTSTR szProcessor)

{
	GetSystemInventory(INV_PROCESSORTYPE, szProcessor);
}

void GetTotalMemoryString(HINSTANCE hInstance, LPTSTR szTotalMemory)
{
	GetSystemInventory(INV_TOTALMEMORY,szTotalMemory);
}

void GetTotalHardDiskSpaceString(HINSTANCE hInstance, LPTSTR szTotalHardDiskSpace)
{
	GetSystemInventory(INV_TOTALHDSPACE,szTotalHardDiskSpace);
}

void GetDisplayResolutionString(HINSTANCE hInstance, LPTSTR szDisplayResolution)

{	
	GetSystemInventory(INV_DISPLAY_WITH_RESOLUTION,szDisplayResolution);
}


void GetDisplayColorDepthString(HINSTANCE hInstance, LPTSTR szDisplayColorDepth)
/*********************************************************************
Returns a string that describes the color depth (number of colors
available).
**********************************************************************/
{
	GetSystemInventory(INV_DISPCOLORDEPTH,szDisplayColorDepth);
}


void GetWindowsVersionString(HINSTANCE hInstance, LPTSTR szVersion)
/*********************************************************************
Returns a string describing the platform and verson of the currently
operating Windows OS.
**********************************************************************/
{
	GetSystemInventory(INV_WINVERSION,szVersion);
}


void GetNetworkCardString(HINSTANCE hInstance, LPTSTR szNetwork)
{
	GetSystemInventory(INV_NETCARD,szNetwork);
}


void GetModemString(HINSTANCE hInstance, LPTSTR szModem)
{
	GetSystemInventory(INV_MODEM,szModem);
}

void GetSCSIAdapterString(HINSTANCE hInstance, LPTSTR szScsi)
{
	GetSystemInventory(INV_SCSIADAPTER,szScsi);
}

void GetPointingDeviceString(HINSTANCE hInstance, LPTSTR szPointingDevice)
/*********************************************************************
Returns a string describing all pointing devices (mouse, tablet, etc.)
available.
**********************************************************************/
{

	GetSystemInventory(INV_POINTDEVICE,szPointingDevice);	

		
}



void GetCDRomString(HINSTANCE hInstance, LPTSTR szCDRom)
{
	GetSystemInventory(INV_CDROM,szCDRom);	
}



void GetSoundCardString(HINSTANCE hInstance, LPTSTR szSoundCard)
{

	GetSystemInventory(INV_SOUNDCARD,szSoundCard);	
}



void GetRemoveableMediaString(HINSTANCE hInstance, LPTSTR szRemoveableMedia, int iBufSize)
/*********************************************************************
Returns a string describing the capacity and format of removeable
drives.
**********************************************************************/
{

		GetSystemInventory(INV_REMOVEABLEMEDIA,szRemoveableMedia);	
}


BOOL IsCoProcessorAvailable(HINSTANCE hInstance)
/*********************************************************************
Returns TRUE if a co-processor is installed in the user's system.
**********************************************************************/
{
	TCHAR czRet[256];
	BOOL  bRet = TRUE;
	GetSystemInventory(INV_COPRECESSOR,czRet);
	if(czRet[0] == _T('\0')){
		bRet = FALSE;
	}
	return bRet;
}




void GetDisplayCharacteristics(PINT lpHorizResolution, PINT lpVertResolution,PINT lpColorDepth)
/*********************************************************************
Returns the horizontal and vertical resolution (in pixels) of the 
user's main screen, as well as the color depth (bits per pixel).

Note: NULL can be passed for any parameter that is not of interest.
**********************************************************************/
{
	HWND hwnd = GetDesktopWindow();
	HDC hdc = GetDC(hwnd);
	if (lpHorizResolution) *lpHorizResolution = GetDeviceCaps(hdc,HORZRES);
	if (lpVertResolution) *lpVertResolution = GetDeviceCaps(hdc,VERTRES);
	if (lpColorDepth) *lpColorDepth = GetDeviceCaps(hdc,BITSPIXEL);
	ReleaseDC(hwnd,hdc);
}


void GetWindowsVersion(LONG* lpPlatform, LONG* lpMajorVersion,LONG* lpMinorVersion,LONG* lpBuildNo)
/*********************************************************************
Returns integers representing the platform, major version number, and
minor version number of the currently running Windows OS.

Platform:
VER_PLATFORM_WIN32_NT:		Windows NT
VER_PLATFORM_WIN32s: 		Win32s with Windows 3.1
VER_PLATFORM_WIN32_WINDOWS:	Win32 on Windows 4.0 or later

Note: NULL can be passed for any parameter that is not of interest.
**********************************************************************/
{
	OSVERSIONINFO osvi;
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osvi);
	if (lpMajorVersion) *lpMajorVersion = osvi.dwMajorVersion;
	if (lpMinorVersion) *lpMinorVersion = osvi.dwMinorVersion;
	if (lpPlatform) *lpPlatform = osvi.dwPlatformId;
	if (lpBuildNo) *lpBuildNo = osvi.dwBuildNumber;
}







#pragma optimize( _T(""), on )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\regdlg.cpp ===
/*********************************************************************
Registration Wizard

RegDlg.cpp
10/28/94 - Tracy Ferrier
02/12/98 - Suresh Krishnan
(c) 1994-95 Microsoft Corporation
08/20/98  : Removed the substitution of Product name in SubTitle
**********************************************************************/

#include <Windows.h>
#include "RegPage.h"
#include "RegWizMain.h"
#include "Resource.h"
#include "Dialogs.h"
#include "regutil.h"
#include <stdio.h>
#include "cntryinf.h"
#include <rw_common.h>
#include <rwpost.h>

static TCHAR szRegisterSubTitle[1024]=_T("");
static PROPSHEETPAGE  *spAddrSheet=NULL;
// Private functions
int LogFileQuery(HWND hwndParentDlg);
INT_PTR CALLBACK LogFileQueryDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK RegisterDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
/*********************************************************************
Main entry point for the Registration Wizard.
**********************************************************************/
{
	CRegWizard* pclRegWizard = NULL;
	static INT_PTR iRet;
	_TCHAR szInfo[256];
    INT_PTR bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi)
	{
		pclRegWizard = pi->pclRegWizard;
	};

    switch (uMsg)
    {
		case WM_CLOSE:
			if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) pclRegWizard->EndRegWizardDialog(IDB_EXIT);
            break;	
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;				
        case WM_INITDIALOG:
		{
			_TCHAR szInfo[256];
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);

			//UpgradeDlg(hwndDlg);
			
			//NormalizeDlgItemFont(hwndDlg,IDC_TITLE,RWZ_MAKE_BOLD);
			//NormalizeDlgItemFont(hwndDlg,IDC_SUBTITLE);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT2);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT3);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT4);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT5);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT6);
			
			pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szInfo);
			ReplaceDialogText(hwndDlg,IDT_TEXT1,szInfo);


			SetWindowText(hwndDlg,pclRegWizard->GetWindowCaption());
			
			
			
			if (pclRegWizard->GetInformationString(kInfoProductID,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDT_TEXT6,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			/***
			// Update the Sub title by substituting the product name
			_TCHAR rgchCallingContext[256];
			pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,rgchCallingContext);
			LoadString(pi->hInstance,IDS_REGISTER_SCR_STITLE,szRegisterSubTitle,256);
			_tcscat(szRegisterSubTitle,_T(" "));
 			_tcscat(szRegisterSubTitle,rgchCallingContext);
			_tcscat(szRegisterSubTitle,_T("."));
			spAddrSheet->pszHeaderSubTitle = szRegisterSubTitle;
			**/


			if (pclRegWizard->GetCountryCode() == kCountryCodeUnitedStates)
			{
				HWND hwndCtrl;
				hwndCtrl = GetDlgItem(hwndDlg,IDT_TEXT3);
				ShowWindow(hwndCtrl,SW_HIDE);
				hwndCtrl = GetDlgItem(hwndDlg,IDT_TEXT4);
				ShowWindow(hwndCtrl,SW_HIDE);
				hwndCtrl = GetDlgItem(hwndDlg,IDT_TEXT5);
				ShowWindow(hwndCtrl,SW_HIDE);
				hwndCtrl = GetDlgItem(hwndDlg,IDC_ENVELOPE);
				ShowWindow(hwndCtrl,SW_HIDE);
			}

            return TRUE;
		}// WM_INIT
		break;
		case WM_NOTIFY:
        {
			LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code )
			{
            case PSN_SETACTIVE:
                //PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK PSWIZB_NEXT );
				pi->iCancelledByUser = RWZ_PAGE_OK;
				PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
                break;

            case PSN_WIZNEXT:
				iRet=0;
				if(pi->iCancelledByUser == RWZ_CANCELLED_BY_USER )
				{
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);
				}
				else
				{
					if (pclRegWizard->GetTriStateInformation(kInfoIncludeProducts) == kTriStateUndefined){	
						pclRegWizard->SetTriStateInformation(kInfoIncludeProducts,kTriStateFalse);
					}
					pclRegWizard->WriteInfoToRegistry();
					
					//
					// Check  for the type of Connectivity
					//
					if(pi->dwConnectionType == DIALUP_REQUIRED)
					{
						pi->CurrentPage++;
						// go to the Dialup Screen
					}
					else
					{
						//
						//
						// Post The  Date
						pi->iError =PostDataWithWindowMessage(pclRegWizard->GetInstance());
						pi->CurrentPage=pi->TotalPages-1;
						PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);
					}
					pi->iLastKeyOperation = RWZ_NEXT_PRESSED;
				}

				//SetWindowLongPtr( hwndDlg ,DWLP_MSGRESULT, (INT_PTR) iRet);
				break;

            case PSN_WIZBACK:
				pi->iLastKeyOperation = RWZ_BACK_PRESSED;
                pi->CurrentPage--;

                break;
			case PSN_QUERYCANCEL :
				iRet=0;
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet = 1;
					pi->ErrorPage  = kRegisterDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet);
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);
				}
				else
				{
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;
				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet);
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        }
        break;

        default:
			bStatus = FALSE;
            break;
    }
    return bStatus;
}



int LogFileQuery(HWND hwndParentDlg)
/**********************************************************************
Puts up a dialog asking the user if he/she would like a text log of all
registration information.

Returns:
IDB_YES
IDB_NO
IDB_CANCEL
***********************************************************************/
{
	HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndParentDlg,GWLP_HINSTANCE);
	int hitButton = (int) DialogBox(hInstance,MAKEINTRESOURCE(IDD_LOGFILE_QUERY),hwndParentDlg,
		LogFileQueryDialogProc);
	return hitButton;
}


INT_PTR CALLBACK LogFileQueryDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
/*********************************************************************
Proc for our "Do you want a log file" dialog.
**********************************************************************/
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
		{
			RECT parentRect,dlgRect;
			HWND hwndParent = GetParent(hwndDlg);
			GetWindowRect(hwndParent,&parentRect);
			GetWindowRect(hwndDlg,&dlgRect);
			int newX = parentRect.left + (parentRect.right - parentRect.left)/2 - (dlgRect.right - dlgRect.left)/2;
			int newY = parentRect.top + (parentRect.bottom - parentRect.top)/2 - (dlgRect.bottom - dlgRect.top)/2;
			MoveWindow(hwndDlg,newX,newY,dlgRect.right - dlgRect.left,dlgRect.bottom - dlgRect.top,FALSE);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT2);
            return TRUE;
		}
        case WM_COMMAND:
            switch (wParam)
            {
                case IDB_YES:
				case IDB_NO:
					EndDialog(hwndDlg,wParam);
					break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    return FALSE;
}

//
//  This function is calles during the creation and deletion of
//  Address Property Sheet
//  Store the Address of PPROPSHEETPAGE so the Subtitle can be changed
//
//
//
UINT CALLBACK RegisterPropSheetPageProc(HWND hwnd,
								UINT uMsg,
								LPPROPSHEETPAGE ppsp
								)
{
	
	switch(uMsg) {
	case PSPCB_CREATE :
		spAddrSheet = ppsp;
	default:
		break;

	}
	return 1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\welcdlg.cpp ===
/*********************************************************************
Registration Wizard

WelcomeDialog.cpp
10/13/94 -  Tracy Ferrier
02/11/98 -  Suresh Krishnan
(c) 1994-95 Microsoft Corporation
8/20/98 - The "Use Windows Update .."  text is disabled for non OS products
**********************************************************************/

#include <Windows.h>
#include <RegPage.h>
#include <Resource.h>
#include "RegWizMain.h"
#include "Dialogs.h"
#include "regutil.h"
#include <stdio.h>
#include "version.h"
#include "rwwin95.h"
#include "rw_common.h"
#include "rwpost.h"

//
//
//  Returns 1 if Success
//          0 if failure
int GetOsName(HINSTANCE hIns, TCHAR *szOsName)
{
	HKEY hKey;
	TCHAR szOsPath[256];
	TCHAR szParamSubKey[64];
	int iRet;
	unsigned long infoSize;
	infoSize = 256; // Size of Buffer

	iRet = 0;
	LONG regStatus ;
	LoadString(hIns,IDS_REREGISTER_OS2,szOsPath,255);
	LoadString(hIns,IDS_INPUT_PRODUCTNAME,szParamSubKey,63);

	regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szOsPath,0,KEY_READ,&hKey);
	if (regStatus == ERROR_SUCCESS) {
		
		regStatus = RegQueryValueEx(hKey ,szParamSubKey, NULL,0,(LPBYTE) szOsName,&infoSize);
		if (regStatus == ERROR_SUCCESS)
		{
			iRet = 1;
		}
		RegCloseKey(hKey);
	}

	return iRet;

	
}

INT_PTR CALLBACK WelcomeDialogProc(HWND hwndDlg, 
						UINT uMsg, 
						WPARAM wParam, LPARAM lParam)
/*********************************************************************
Main entry point for the Registration Wizard.
**********************************************************************/
{
	 INT_PTR bStatus = TRUE;
	 CRegWizard* pclRegWizard = NULL;
	_TCHAR szCallingContext[256];
	_TCHAR szText2[256];
	_TCHAR szTemp[128];
	_TCHAR szButtonText[48];
	_TCHAR szOsName[256];
	DWORD  dwConnectivity;
	 INT_PTR iRet;
	 int iCurPage;
	 static int iFirstTimeEntry=1; // This is to verify for Network connection
	LONG_PTR lStyle;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
	}

    switch (uMsg)
    {				
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
        break;
        case WM_INITDIALOG:
		{
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pi->iCancelledByUser = RWZ_PAGE_OK;
			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);
			pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szCallingContext);
			_tcscpy(szText2,szCallingContext);

			// appending ,so Microsoft can  
			//LoadString(pclRegWizard->GetInstance(),
			//IDS_WELCOME_SCR_TEXT22,szTemp,128);
			//_tcscat(szText2,szTemp);
					
								
			ReplaceDialogText(hwndDlg,IDT_TEXT1,szCallingContext);
			ReplaceDialogText(hwndDlg,IDT_TEXT2,szText2);
			// if the product being registered is not Windows NT OS  then do not 
			// display the Windows Updat site text
			szOsName[0] = _T('\0');
			GetOsName(pclRegWizard->GetInstance(),szOsName);

			
			HWND hParent = GetParent(hwndDlg);

			lStyle = GetWindowLongPtr( hParent, GWL_STYLE);
			lStyle &= ~WS_SYSMENU;
			SetWindowLongPtr(hParent,GWL_STYLE,lStyle);
			
			if(_tcscmp(szCallingContext,szOsName)){
				ShowWindow(GetDlgItem(hwndDlg,IDC_TEXT7),SW_HIDE);//SW_SHOW);
			}

            return TRUE;
		}
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
				pi->iCancelledByUser = RWZ_PAGE_OK;
				PropSheet_SetTitle(GetParent( hwndDlg ),0,pclRegWizard->GetWindowCaption());
                PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_NEXT);
				LoadString(pclRegWizard->GetInstance(),
						IDS_REGISTERLATER_BUTTONTEXT,
						szButtonText,16);

				// Limiting the Button Text to 16
				// As mo
				SetWindowText(GetDlgItem( GetParent( hwndDlg ),2),szButtonText); 
            break;
			case PSN_KILLACTIVE  :
				LoadString(pclRegWizard->GetInstance(),
						IDS_CANCEL_BUTTONTEXT,
						szButtonText,16);

				// Limiting the Button Text to 16
				// As mo
				SetWindowText(GetDlgItem( GetParent( hwndDlg ),2),szButtonText); 
				 
			break;
            case PSN_WIZNEXT:
			//  Check if it is cancelled bt the user
			//  if so then switch to the last Page
			//					
				if(pi->iCancelledByUser == RWZ_CANCELLED_BY_USER ) {
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);

				}else {
				//
				// User Has Not pressed Next 					
					if(iFirstTimeEntry) {
						iFirstTimeEntry = 0;
						pi->dwConnectionType = 0; // Init to Zero
						dwConnectivity =  (DWORD)CheckWithDisplayInternetConnectivityExists(pi->hInstance,hwndDlg);  
						//dwConnectivity = DIALUP_REQUIRED;
						switch(dwConnectivity) {
							case DIALUP_NOT_REQUIRED :
							case DIALUP_REQUIRED     :
								pi->dwConnectionType = dwConnectivity;
								break;
								//
								// The System is OK so proceed to the next screen 
							case RWZ_ERROR_NOTCPIP: // NO TCP_IP
							case CONNECTION_CANNOT_BE_ESTABLISHED: // NO Proper Modem or RAS
							default :
								// Set the NEXT so it goes to the lase Page
								pi->ErrorPage  = kWelcomeDialog;
								pi->iError     = dwConnectivity;
								pi->CurrentPage=pi->TotalPages-1;
								PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);

								//pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
								//PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);
							break;
						}
												
					}
					pi->CurrentPage++;
				}
					
					
				
			break;
            case PSN_WIZBACK:
                pi->CurrentPage--;

                break;
			case PSN_QUERYCANCEL :
				iRet = 1;
				pi->ErrorPage  = kWelcomeDialog;
				pi->iError     = RWZ_ERROR_REGISTERLATER ;
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 
				pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
				PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);
			break;
            default:
                //bStatus = FALSE;
                break;
            }
        }
        break;
      
        default:
			bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizctrl\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__50E5E3CC_C07E_11D0_B9FD_00A0249F6B00__INCLUDED_)
#define AFX_DLLDATAX_H__50E5E3CC_C07E_11D0_B9FD_00A0249F6B00__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__50E5E3CC_C07E_11D0_B9FD_00A0249F6B00__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizctrl\crwctrl.cpp ===
// CRegWizCtrl.cpp : Implementation of CRegWizCtrl
#include "stdafx.h"
#include "RegwizCtrl.h"
#include "CRwCtrl.h"
#include "rw_common.h"
#include "regutil.h"

int TstFn1 ( HANDLE hInstance  );

_TCHAR szProductPath[256];

/////////////////////////////////////////////////////////////////////////////
// CRegWizCtrl

STDMETHODIMP CRegWizCtrl::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IRegWizCtrl,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CRegWizCtrl::InvokeRegWizard(BSTR ProductPath)
{
	LPCTSTR  pPath;
	int      iRet;
	iRet = 0; // No Error
	// TODO: Add your implementation code here
	//TstFn1 ( _Module.GetModuleInstance(), m_ctlButton.m_hWnd);
	#ifndef _UNICODE
	pPath	= BstrToSz(ProductPath);
	#else
	pPath   = ProductPath;
	#endif
	if(pPath) {
		//MessageBox("TransferRegWizInformation",lpInfo);
		iRet = InvokeRegistration ( _Module.GetModuleInstance()  ,pPath );
#ifndef _UNICODE
		CoTaskMemFree((void *) pPath);
#endif

	}
	//return (HRESULT) iRet;
	//return iRet == NO_ERROR ? S_OK:E_FAIL;
	return S_OK;
}

STDMETHODIMP CRegWizCtrl::TransferRegWizInformation(BSTR InformationPath)
{
	// TODO: Add your implementation code here
	LPCTSTR lpInfo;
	//::MessageBox(NULL,"TransferRegWizInformation","SSS ",MB_OK);

#ifndef _UNICODE
	lpInfo	= BstrToSz(InformationPath);
#else
	lpInfo = InformationPath;
#endif

	if(lpInfo) {
	//	MessageBox("TransferRegWizInformation",lpInfo);
		TransmitRegWizInfo(_Module.GetModuleInstance(), lpInfo,FALSE);
#ifndef _UNICODE
		CoTaskMemFree((void *) lpInfo);
#endif

	}


	return S_OK;
}

STDMETHODIMP CRegWizCtrl::put_IsRegistered(BSTR InformationPath)
{
	LPCTSTR lpInfo;

	#ifndef _UNICODE
		lpInfo	= BstrToSz(InformationPath);
	#else
		lpInfo = InformationPath;
	#endif

	_tcscpy(szProductPath,lpInfo);
	return S_OK;
}

STDMETHODIMP CRegWizCtrl::get_IsRegistered(VARIANT_BOOL * pbStatus)
{
	int iReturn ;
	HKEY hKey;
	TCHAR szValueName[256] = _T("");
	TCHAR szRetVal[48];
	DWORD dwSize= 48;
	LONG regStatus ;
	
	*pbStatus = FALSE;

	HINSTANCE hInstance = _Module.GetModuleInstance();

	int resSize = LoadString(hInstance,
				IDS_INPUT_ISREGISTERED,szValueName,128);

	iReturn  = 1;

    regStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
	szProductPath,0,KEY_READ |KEY_WRITE,&hKey);
	if (regStatus != ERROR_SUCCESS) 
	{
		return E_FAIL; // error
	}
	
	regStatus = RegQueryValueEx(hKey,
		szValueName,
		NULL,
		0,
		(LPBYTE) szRetVal,
		&dwSize);
	if (regStatus == ERROR_SUCCESS){
		// Verifty the Value 
		//
		if(szRetVal[0] == _T('1')) {
			*pbStatus = TRUE; // Product Registred flag is set
		}
	}
	RegCloseKey(hKey);
	return S_OK;
}

/*   B S T R   C R E A T E   S Z   */
/*-------------------------------------------------------------------------
    Owner: SteveBu
 
    Creates a BSTR from a string
-------------------------------------------------------------------------*/
#ifndef _UNICODE
BSTR BstrCreateSz(LPCSTR lpa)
{
    BSTR bsz;
    UINT cch;

    cch = lstrlen(lpa);

    bsz = SysAllocStringLen(NULL, cch);
    
    if (bsz == NULL)
        return NULL;

    if (cch > 0)
	    MultiByteToWideChar(CP_ACP, 0, lpa, cch, bsz, cch);

	bsz[cch] = NULL;
	return bsz;
}
#endif 


/*   G E T _   M   S   I   D   */
/*-------------------------------------------------------------------------
    Owner: SteveBu
 
    Returns a user's MSID from the Registry.  If it does not exist, this 
    code issues a MSID using GetNewGUID.
-------------------------------------------------------------------------*/
STDMETHODIMP CRegWizCtrl::get_MSID(BSTR *pbstrMSID)
{
	HRESULT hr = S_OK;
	_TCHAR szValue[256];
	char   czNewGuid[256];
	BOOL fPutMSID = FALSE;

	szValue[0] = '\0';

	*pbstrMSID = NULL;

	if(!GetMSIDfromRegistry(_Module.GetModuleInstance(), szValue))
		{
		GetNewGUID(czNewGuid);
		_tcscpy(szValue,ConvertToUnicode(czNewGuid));

		fPutMSID = TRUE;
		}

	// TODO: Add your implementation code here

#ifndef _UNICODE
	if ((*pbstrMSID = BstrCreateSz(szValue)) == NULL)
#else
	if ((*pbstrMSID = SysAllocString(szValue)) == NULL)
#endif // _UNICODE
		{
		hr = E_OUTOFMEMORY;
		}


	if (SUCCEEDED(hr) && fPutMSID && *pbstrMSID)
		return put_MSID(*pbstrMSID);
	
	return hr;
}

/*   P U T _   M   S   I   D   */
/*-------------------------------------------------------------------------
    Owner: SteveBu
 
    Adds a MSID to the registry
-------------------------------------------------------------------------*/
STDMETHODIMP CRegWizCtrl::put_MSID(BSTR bstrMSID)
{
	DWORD	dwRet;
	_TCHAR szKeyName[256];
	HKEY	hIDKey;
	TCHAR  szMSID[256];
	HINSTANCE hInstance = _Module.GetModuleInstance();

	_tcscpy(szKeyName,_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"));

#ifndef _UNICODE
	WideCharToMultiByte(CP_ACP, 0, bstrMSID, -1, szMSID, 256, NULL, NULL);
#else
	_tcscpy(szMSID, bstrMSID);
#endif // _UNICODE

	dwRet = RegOpenKeyEx(HKEY_CURRENT_USER,szKeyName,0,KEY_ALL_ACCESS,&hIDKey);
	if (dwRet == ERROR_SUCCESS) 
		{
		szMSID[32]=_T('\0');
		// Store MSID into
		dwRet = RegSetValueEx(hIDKey,_T("MSID"),NULL,REG_SZ,(CONST BYTE *)szMSID,
								_tcslen((LPCTSTR)szMSID));
		RegCloseKey(hIDKey);
		}

	_TCHAR szPartialKey[256];
	int resSize = LoadString(hInstance,IDS_KEY2,szKeyName,255);
	_tcscat(szKeyName,_T("\\"));
	resSize = LoadString(hInstance,IDS_KEY3,szPartialKey,255);
	_tcscat(szKeyName,szPartialKey);
	_tcscat(szKeyName,_T("\\"));
	resSize = LoadString(hInstance,IDS_KEY4,szPartialKey,255);
	_tcscat(szKeyName,szPartialKey);

	dwRet = RegOpenKeyEx(HKEY_CURRENT_USER,szKeyName,0,KEY_ALL_ACCESS,&hIDKey);
	if (dwRet == ERROR_SUCCESS) 
		{
		// Store MSID into
		dwRet = RegSetValueEx(hIDKey,_T("MSID"),NULL,REG_SZ,(CONST BYTE *)szMSID, _tcslen((LPCTSTR)szMSID));
		RegCloseKey(hIDKey);
		}

	return S_OK;
}

/*   G E T _   H   W   I   D   */
/*-------------------------------------------------------------------------
    Owner: SteveBu
 
    Returns the machine HWID or creates it.
-------------------------------------------------------------------------*/
STDMETHODIMP CRegWizCtrl::get_HWID(BSTR * pbstrHWID)
{
	HKEY hKeyHWID;
	HRESULT hr = S_OK;
	BOOL fPutHWID = FALSE;

	_TCHAR szKeyName[256];
	_TCHAR szValue[256];
	char   czNewGuid[256];

	*pbstrHWID = NULL;
	szValue[0] = '\0';

	
	_tcscpy(szKeyName,_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"));
	
	LONG regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKeyName, 0, KEY_READ, &hKeyHWID);
	
	if (regStatus == ERROR_SUCCESS)
		{
		_TCHAR szValueName[64];
		unsigned long infoSize = 255;
		
		LoadString(_Module.GetModuleInstance(),IDS_HWID, szValueName,64);
		regStatus = RegQueryValueEx(hKeyHWID,szValueName,NULL,0,(LPBYTE) szValue,&infoSize);
		if (regStatus != ERROR_SUCCESS)
			{
			GetNewGUID(czNewGuid);
			_tcscpy(szValue,ConvertToUnicode(czNewGuid));
			fPutHWID = TRUE;
			}
			
		RegCloseKey(hKeyHWID);
		}

#ifndef _UNICODE
	if ((*pbstrHWID = BstrCreateSz(szValue)) == NULL)
#else
	if ((*pbstrHWID = SysAllocString(szValue)) == NULL)
#endif // _UNICODE
		{
		hr = E_OUTOFMEMORY;
		}

	if (SUCCEEDED(hr) && fPutHWID && *pbstrHWID)
		return put_HWID(*pbstrHWID);
	
	return hr;
}

/*   P U T _   H   W   I   D   */
/*-------------------------------------------------------------------------
    Owner: SteveBu
 
    Adds the passed in HWID to the registry
-------------------------------------------------------------------------*/
STDMETHODIMP CRegWizCtrl::put_HWID(BSTR bstrHWID)
{
	DWORD	dwRet;
	_TCHAR szKeyName[256];
	HKEY	hIDKey;
 
	_tcscpy(szKeyName,_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"));

	// Store HWID into Registry
	dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szKeyName,0,KEY_ALL_ACCESS,&hIDKey);
	
	if (dwRet == ERROR_SUCCESS) 
		{
		_TCHAR szHWID[256];
		
#ifndef _UNICODE
		WideCharToMultiByte(CP_ACP, 0, bstrHWID, -1, szHWID, 256, NULL, NULL);
#else
		_tcscpy(szHWID, bstrHWID);
#endif // _UNICODE		

		dwRet = RegSetValueEx(hIDKey,_T("HWID"),NULL, REG_SZ,(CONST BYTE *)szHWID, _tcslen((LPCTSTR)szHWID));
		RegCloseKey(hIDKey);
		}

	return S_OK;
}

/*   T R A N S F E R   O   E   M   R E G   W I Z   I N F O R M A T I O N   */
/*-------------------------------------------------------------------------
    Owner: SteveBu
 
    Transfer product registration and OEM information.
-------------------------------------------------------------------------*/
STDMETHODIMP CRegWizCtrl::TransferOEMRegWizInformation(BSTR InformationPath)
{
	LPCTSTR lpInfo;
	//::MessageBox(NULL,"TransferOEMRegWizInformation","SSS ",MB_OK);

#ifndef _UNICODE
	lpInfo	= BstrToSz(InformationPath);
#else
	lpInfo = InformationPath;
#endif

	if(lpInfo) {
	//	MessageBox("TransferRegWizInformation",lpInfo);
		TransmitRegWizInfo(_Module.GetModuleInstance(), lpInfo, TRUE);
#ifndef _UNICODE
		CoTaskMemFree((void *) lpInfo);
#endif
	}


	return S_OK;
}

/*   G E T _   V E R S I O N   */
/*-------------------------------------------------------------------------
    Owner: SteveBu
 
    Returns the RegWiz Version Number
-------------------------------------------------------------------------*/
STDMETHODIMP CRegWizCtrl::get_Version(BSTR * pbstr)
{
	_TCHAR szValue[256];
	
	GetRegWizardVersionString(_Module.GetModuleInstance(),szValue);

#ifndef _UNICODE
	if ((*pbstr = BstrCreateSz(szValue)) == NULL)
#else
	if ((*pbstr = SysAllocString(szValue)) == NULL)
#endif // _UNICODE
		{
		return E_OUTOFMEMORY;
		}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizctrl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizctrl\crwctrl.h ===
// CRegWizCtrl.h : Declaration of the CRegWizCtrl

#ifndef __REGWIZCTRL_H_
#define __REGWIZCTRL_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CRegWizCtrl
class ATL_NO_VTABLE CRegWizCtrl : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CRegWizCtrl, &CLSID_RegWizCtrl>,
	public IObjectWithSiteImpl<CRegWizCtrl>,
	public ISupportErrorInfo,
	public IDispatchImpl<IRegWizCtrl, &IID_IRegWizCtrl, &LIBID_REGWIZCTRLLib>
{
public:
	CRegWizCtrl()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_REGWIZCTRL)

BEGIN_COM_MAP(CRegWizCtrl)
	COM_INTERFACE_ENTRY(IRegWizCtrl)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_IMPL(IObjectWithSite)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IRegWizCtrl
public:
	STDMETHOD(get_Version)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(TransferOEMRegWizInformation)(BSTR InformationPath);
	STDMETHOD(get_HWID)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_HWID)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_MSID)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_MSID)(/*[in]*/ BSTR newVal);
	STDMETHOD(TransferRegWizInformation)(BSTR  InformationPath);
	STDMETHOD(InvokeRegWizard)(BSTR ProductPath);
	STDMETHOD(get_IsRegistered)(VARIANT_BOOL *pbStatus);
	STDMETHOD(put_IsRegistered)(BSTR ProductPath);
};

#endif //__REGWIZCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizctrl\cathelp.cpp ===
//=--------------------------------------------------------------------------=
// CatHelp.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the Component Category helper functions.
//
#include "stdafx.h"

#include <comcat.h>

//const CATID CATID_SafeForScripting      = {0x7dd95801,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};

//const CATID CATID_SafeForInitializing   = {0x7dd95802,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
	{

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (FAILED(hr))
		return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

	// Make sure the provided description is not too long.
	// Only copy the first 127 characters if it is
	int len = wcslen(catDescription);
	if (len>127)
		len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
	// Make sure the description is null terminated
	catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
	pcr->Release();

	return hr;
	}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();
  
	return hr;
	}

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();
  
	return hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizctrl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__50E5E3C4_C07E_11D0_B9FD_00A0249F6B00__INCLUDED_)
#define AFX_STDAFX_H__50E5E3C4_C07E_11D0_B9FD_00A0249F6B00__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__50E5E3C4_C07E_11D0_B9FD_00A0249F6B00__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizctrl\regwizctrl.cpp ===
// RegwizCtrl.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f RegwizCtrlps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "RegwizCtrl.h"

#include "RegwizCtrl_i.c"
#include "CRWCtrl.h"
#include "cathelp.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_RegWizCtrl, CRegWizCtrl)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	HRESULT hr;
#ifdef _MERGE_PROXYSTUB
	HRESULT hRes = PrxDllRegisterServer();
	if (FAILED(hRes))
		return hRes;
#endif

	// registers object, typelib and all interfaces in typelib
	if ( SUCCEEDED(hr =_Module.RegisterServer(TRUE)) &&
		 SUCCEEDED(hr = CreateComponentCategory(CATID_SafeForScripting, 
						L"Controls that are safely scriptable")) &&
		 SUCCEEDED(hr = CreateComponentCategory(CATID_SafeForInitializing, 
						L"Controls safely initializable from persistent data")) &&
		 SUCCEEDED(hr = RegisterCLSIDInCategory(CLSID_RegWizCtrl, 
												CATID_SafeForScripting)) )
	{
		hr = RegisterCLSIDInCategory(CLSID_RegWizCtrl, CATID_SafeForInitializing);
	}

	return hr;
	
	
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
	PrxDllUnregisterServer();
#endif
	_Module.UnregisterServer();

	// Remove CATID information.
    UnRegisterCLSIDInCategory(CLSID_RegWizCtrl, CATID_SafeForScripting);
    UnRegisterCLSIDInCategory(CLSID_RegWizCtrl, CATID_SafeForInitializing);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizexe\res.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by hellctrl.ico
//
#define IDI_ICON1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizexe\regwizc_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.00.0140 */
/* at Thu Mar 11 12:57:09 1999
 */
/* Compiler settings for regwizctrl.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IRegWizCtrl = {0x50E5E3CF,0xC07E,0x11D0,{0xB9,0xFD,0x00,0xA0,0x24,0x9F,0x6B,0x00}};


const IID LIBID_REGWIZCTRLLib = {0x50E5E3C0,0xC07E,0x11D0,{0xB9,0xFD,0x00,0xA0,0x24,0x9F,0x6B,0x00}};


const CLSID CLSID_RegWizCtrl = {0x50E5E3D1,0xC07E,0x11D0,{0xB9,0xFD,0x00,0xA0,0x24,0x9F,0x6B,0x00}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizexe\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rwExe.rc
//
#define IDS_RWNOTFOUND                  1
#define IIDS_ERROR                      2
#define IDI_REGWIZ                      117

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizexe\rwexemain.h ===
#ifdef WIN32

#ifdef UNICODE
    #define FROM_OLE_STRING(str) str
    #define TO_OLE_STRING(str) str 
#else
    #define FROM_OLE_STRING(str) ConvertToAnsi(str)
    char* ConvertToAnsi(OLECHAR FAR* szW);  
    #define TO_OLE_STRING(str) ConvertToUnicode(str)
    OLECHAR* ConvertToUnicode(char FAR* szA);   
    // Maximum length of string that can be converted between Ansi & Unicode
    #define STRCONVERT_MAXLEN 500         
#endif

#else  // WIN16
//#include <tchar.h>


  #define APIENTRY far pascal  
  #define TCHAR char
  #define TEXT(sz) sz 
  #define FROM_OLE_STRING(str) str  
  #define TO_OLE_STRING(str) str 
  #define LPTSTR LPSTR   
  #define LPCTSTR LPCSTR

  
  // Windows NT defines the following in windowsx.h
  #define GET_WM_COMMAND_ID(w,l) (w)
  #define GET_WM_COMMAND_CMD(w,l) HIWORD(l)
  #define GET_WM_COMMAND_HWND(w,l) LOWORD(l)
#endif



// MAX len of string table entries
#define STR_LEN   100

// String table constants
#define IDS_PROGNAME                   1
#define IDS_RESULT                     2
#define IDS_ERROR                      3

// Function prototypes
int PASCAL WinMain (HINSTANCE, HINSTANCE, LPSTR, int);
BOOL InitApplication (HINSTANCE);
BOOL InitInstance (HINSTANCE, int);
void DisplayError(IRegWizCtrl FAR* phello);
#ifdef WIN16
LRESULT __export CALLBACK MainWndProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
#else
LRESULT CALLBACK MainWndProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizexe\rwinter.h ===
/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: Hello */

#ifndef _REGWIZ_H_
#define _REGWIZ_H_

const IID IID_IRegWizCtrl = {0x50E5E3CF,0xC07E,0x11D0,{0xB9,0xFD,0x00,0xA0,0x24,0x9F,0x6B,0x00}};


const IID LIBID_REGWIZCTRLLib = {0x50E5E3C0,0xC07E,0x11D0,{0xB9,0xFD,0x00,0xA0,0x24,0x9F,0x6B,0x00}};


const CLSID CLSID_RegWizCtrl = {0x50E5E3D1,0xC07E,0x11D0,{0xB9,0xFD,0x00,0xA0,0x24,0x9F,0x6B,0x00}};



/* Definition of interface: IHello */
DECLARE_INTERFACE_(IRegWizCtrl, IDispatch)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IHello methods */
	STDMETHOD(get_Window ) () PURE;
    STDMETHOD(put_Text )(THIS_ BSTR InformationPath) PURE; 
    STDMETHOD(get_Text ) () PURE;
    STDMETHOD(InvokeRegWizard)(THIS_ BSTR ProductPath) PURE;
    STDMETHOD(TransferRegWizInformation)(THIS_ BSTR InformationPath) PURE;
};


class RegWizCtrl;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizexe\rwexe_m.cpp ===
/*************************************************************************
**
**    
**	File 	:    RWExeMain.cpp
**      Product  :	
**	Date 	:    05/07/97
**	Author 	:    Suresh Krishnan	
**
**   Registration Wizard Exe programs main file
**   The Exe version of Registration Wizard is implemented using the Active X 
**   component
** Modification History	
**     07/20/98 : The RegWizControl is changed  from Button control to an IE object,
**                some of the properties like Text, HWND  of the button no longer exists.
*************************************************************************/

#include <stdio.h>
#include <tchar.h>
#include "rwexe_m.h"
#include "regwizC_i.c"

#define STRCONVERT_MAXLEN 256
OLECHAR* ConvertToUnicode(char FAR* szA)
{
  static OLECHAR achW[STRCONVERT_MAXLEN]; 

  MultiByteToWideChar(CP_ACP, 0, szA, -1, achW, STRCONVERT_MAXLEN);  
  return achW; 
}


int LoadAndUseRegWizCtrl(TCHAR *lpCmdLine)
{
	HRESULT hr;
	IRegWizCtrl *pRegWiz;


	hr = CoCreateInstance( CLSID_RegWizCtrl,
	                       NULL,
	                       CLSCTX_ALL,
	                       IID_IRegWizCtrl,
	                       (void**)&pRegWiz);

	if(FAILED(hr) ){
		//printf("\n Error Creating Interface...");
		return 0;
	}else {
		//printf("\n Created Interface (IExeTest)...");
	}
	// Invoke register
	#ifndef _UNICODE 
		hr = pRegWiz->InvokeRegWizard(ConvertToUnicode(lpCmdLine));
	#else
		hr = pRegWiz->InvokeRegWizard(lpCmdLine);
	#endif
		return 0;
}


int APIENTRY WinMain (HINSTANCE hinst, 
					  HINSTANCE hinstPrev, 
					  LPSTR lpCmdLine, 
					  int nCmdShow)
{
	CoInitialize(NULL);
	LoadAndUseRegWizCtrl(lpCmdLine);
	CoUninitialize();
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizexe\rwexemain.cpp ===
/*************************************************************************
**
**    
**	File 	:    RWExeMain.cpp
**      Product  :	
**	Date 	:    05/07/97
**	Author 	:    Suresh Krishnan	
**
**   Registration Wizard Exe programs main file
**   The Exe version of Registration Wizard is implemented using the Active X 
**   component
**
*************************************************************************/
#define STRICT

#include <windows.h>
#include <windowsx.h>
#ifdef WIN16   
  #include <ole2.h>
  #include <compobj.h>    
  #include <dispatch.h> 
  #include <variant.h>
  #include <olenls.h>
  #include <commdlg.h>  
#endif  
#include <initguid.h>   
#include "RWInterface.h" 
#include "RWExeMain.h"      
#include "resource.h"


// Globals
HINSTANCE g_hinst;                          // Instance of application
HWND      g_hwnd;                           // Toplevel window handle

TCHAR g_szNotFound[STR_LEN];
TCHAR g_szError[STR_LEN]; 

#define INVOKDE_REGISTRATION   1
#define INVOKE_TRANSFER        2 
#define INVOKE_ERROR           3
#define chSpace 32
int ProcessCmdLine(LPTSTR lpCmd) 
{
	int iC=0;
	int iExit=1;
	LPTSTR szCurr = lpCmd;
	if (lpCmd  == NULL || lpCmd[0] == 0)
	{
		return INVOKE_ERROR;
	}
	while (*szCurr == chSpace)
		{
			szCurr = CharNext(szCurr);
		}
	if (*szCurr != '/' && *szCurr != '-') {
		return INVOKE_ERROR ;
	}
		szCurr = CharNext(szCurr);
		if (*szCurr == 'I' || *szCurr == 'i') {
			return INVOKDE_REGISTRATION ;
		}
		if (*szCurr == 'T' || *szCurr == 't') {
			return INVOKE_TRANSFER ;
		}
		
		return INVOKE_ERROR;


}
/*
 * WinMain
 *
 * Purpose:
 *  Main entry point of application. Should register the app class
 *  if a previous instance has not done so and do any other one-time
 *  initializations.
 *
 */
/*
int _tWinMain   ( HINSTANCE hinst, 
				  HINSTANCE hinstPrev, 
				  LPTSTR lpCmdLine, 
				  int nCmdShow)
*/
int APIENTRY WinMain (HINSTANCE hinst, 
					  HINSTANCE hinstPrev, 
					  LPSTR lpCmdLine, 
					  int nCmdShow)

{
   MSG msg;
   static IRegWizCtrl FAR* pRegWiz = NULL;    
   HRESULT hr;
   LPUNKNOWN punk;
   
   
   //  It is recommended that all OLE applications set
   //  their message queue size to 96. This improves the capacity
   //  and performance of OLE's LRPC mechanism.
   int cMsg = 96;                  // Recommend msg queue size for OLE
   while (cMsg && !SetMessageQueue(cMsg))  // take largest size we can get.
       cMsg -= 8;
   if (!cMsg)
       return -1;                  // ERROR: we got no message queue
	LoadString(hinst, IDS_RWNOTFOUND, g_szNotFound, STR_LEN);
    LoadString(hinst, IDS_ERROR, g_szError, STR_LEN);
   
   
   if (!hinstPrev)
      if (!InitApplication(hinst))
         return (FALSE);

   if(OleInitialize(NULL) != NOERROR)
      return FALSE;
      
   if (!InitInstance(hinst, nCmdShow))
      return (FALSE);

   hr = CoCreateInstance(CLSID_RegWizCtrl, NULL, CLSCTX_INPROC_SERVER, 
        IID_IUnknown, (void FAR* FAR*)&punk);
	if (FAILED(hr))                 {
            MessageBox(NULL,g_szNotFound , g_szError, MB_OK); 
            return 0L;
        }                     
        hr = punk->QueryInterface(IID_IRegWizCtrl ,  (void FAR* FAR*)&pRegWiz);   
        if (FAILED(hr))  
        {
            MessageBox(NULL, TEXT("QueryInterface(IID_IHello)"), g_szError, MB_OK);
            punk->Release(); 
            return 0L;
        }
#ifndef _UNICODE 
			hr = pRegWiz->InvokeRegWizard(ConvertToUnicode(lpCmdLine));
#else
			hr = pRegWiz->InvokeRegWizard(lpCmdLine);
#endif

/*
	int iStatus = ProcessCmdLine(lpCmdLine);
	switch(iStatus ) 
	{
	case INVOKDE_REGISTRATION :
#ifndef _UNICODE 
			hr = pRegWiz->InvokeRegWizard(ConvertToUnicode(lpCmdLine));
#else
			hr = pRegWiz->InvokeRegWizard(lpCmdLine);
#endif
			break;
	case INVOKE_TRANSFER :
#ifndef _UNICODE 
			hr = pRegWiz->TransferRegWizInformation(ConvertToUnicode(lpCmdLine));
#else
			hr = pRegWiz->TransferRegWizInformation(lpCmdLine);
#endif
	default:
		break;

	}
*/
	//	ConvertToUnicode("/i \"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\"")	);
	
   OleUninitialize();
   if(SUCCEEDED(hr))
	   return NO_ERROR;
   else
	   return 1;

   //return (msg.wParam); // Returns the value from PostQuitMessage
}

/*
 * InitApplication
 *
 * Purpose:
 *  Registers window class
 *
 * Parameters:
 *  hinst       hInstance of application
 *
 * Return Value:
 *  TRUE if initialization succeeded, FALSE otherwise.
 */
BOOL InitApplication (HINSTANCE hinst)
{
   WNDCLASS wc;

   wc.style = CS_DBLCLKS;
   wc.lpfnWndProc = MainWndProc;
   wc.cbClsExtra = 0;
   wc.cbWndExtra = 0;
   wc.hInstance = hinst;
   wc.hIcon =0; // LoadIcon(hinst, TEXT("ControlIcon"));
   wc.hCursor =0; // LoadCursor(NULL, IDC_ARROW);
   wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
   wc.lpszMenuName = NULL ;//TEXT("");
   wc.lpszClassName = TEXT("RegistrationWizard");
   return RegisterClass(&wc);
 }

/*
 * InitInstance
 *
 * Purpose:
 *  Creates and shows main window
 *
 * Parameters:
 *  hinst           hInstance of application
 *  nCmdShow        specifies how window is to be shown
 *
 * Return Value:
 *  TRUE if initialization succeeded, FALSE otherwise.
 */
BOOL InitInstance (HINSTANCE hinst, int nCmdShow)
{
  
   g_hinst   = hinst;
   return TRUE;
}

/*
 * MainWndProc
 *
 * Purpose:
 *  Window procedure for main window
 *
 */
LRESULT CALLBACK MainWndProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
   switch (msg)
   {
         
      case WM_DESTROY:
         PostQuitMessage(0);
         break;
      default:                         
         return DefWindowProc(hwnd, msg, wParam, lParam);
   }
   
   return NULL;
}

/*
 * DisplayError
 *
 * Purpose:
 *  Obtains Rich Error Information about the automation error from
 *  the IErrorInfo interface.
 *
 */
void DisplayError(IRegWizCtrl FAR* phello)
{  
   IErrorInfo FAR* perrinfo;    
   BSTR bstrDesc;
   HRESULT hr;
   ISupportErrorInfo FAR* psupporterrinfo;  

   hr = phello->QueryInterface(IID_ISupportErrorInfo, (LPVOID FAR*)&psupporterrinfo);
   if (FAILED(hr)) 
   {
      MessageBox(NULL, TEXT("QueryInterface(IID_ISupportErrorInfo)"), g_szError, MB_OK);
      return;
   }
   
   hr = psupporterrinfo->InterfaceSupportsErrorInfo(IID_IRegWizCtrl);   
   if (hr != NOERROR)
   {   
       psupporterrinfo->Release();
       return;
   }
   psupporterrinfo->Release();
  
   // In this example only the error description is obtained and displayed. 
   // See the IErrorInfo interface for other information that is available. 
   hr = GetErrorInfo(0, &perrinfo); 
   if (FAILED(hr))
       return;   
   hr = perrinfo->GetDescription(&bstrDesc);
   if (FAILED(hr)) 
   {
       perrinfo->Release(); 
       return;
   }  
   
   MessageBox(NULL, FROM_OLE_STRING(bstrDesc), g_szError, MB_OK);   
   SysFreeString(bstrDesc);
}

#ifdef WIN32

#ifndef UNICODE
char* ConvertToAnsi(OLECHAR FAR* szW)
{
  static char achA[STRCONVERT_MAXLEN]; 
  
  WideCharToMultiByte(CP_ACP, 0, szW, -1, achA, STRCONVERT_MAXLEN, NULL, NULL);  
  return achA; 
} 

OLECHAR* ConvertToUnicode(char FAR* szA)
{
  static OLECHAR achW[STRCONVERT_MAXLEN]; 

  MultiByteToWideChar(CP_ACP, 0, szA, -1, achW, STRCONVERT_MAXLEN);  
  return achW; 
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizexe\rwinterface.h ===
/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: Hello */

#ifndef _REGWIZ_H_
#define _REGWIZ_H_

const IID IID_IRegWizCtrl = {0x50E5E3CF,0xC07E,0x11D0,{0xB9,0xFD,0x00,0xA0,0x24,0x9F,0x6B,0x00}};


const IID LIBID_REGWIZCTRLLib = {0x50E5E3C0,0xC07E,0x11D0,{0xB9,0xFD,0x00,0xA0,0x24,0x9F,0x6B,0x00}};


const CLSID CLSID_RegWizCtrl = {0x50E5E3D1,0xC07E,0x11D0,{0xB9,0xFD,0x00,0xA0,0x24,0x9F,0x6B,0x00}};



/* Definition of interface: IHello */
DECLARE_INTERFACE_(IRegWizCtrl, IDispatch)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IHello methods */
	STDMETHOD(get_Window ) () PURE;
    STDMETHOD(put_Text )(THIS_ BSTR InformationPath) PURE; 
    STDMETHOD(get_Text ) () PURE;
    STDMETHOD(put_IsRegistered )(THIS_ BSTR InformationPath) PURE; 
    STDMETHOD(get_IsRegistered ) () PURE;
    STDMETHOD(InvokeRegWizard)(THIS_ BSTR ProductPath) PURE;
    STDMETHOD(TransferRegWizInformation)(THIS_ BSTR InformationPath) PURE;
};


class RegWizCtrl;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizexe\rwexe_m.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.00.0140 */
/* at Thu Mar 11 12:57:09 1999
 */
/* Compiler settings for regwizctrl.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __regwizctrl_h__
#define __regwizctrl_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IRegWizCtrl_FWD_DEFINED__
#define __IRegWizCtrl_FWD_DEFINED__
typedef interface IRegWizCtrl IRegWizCtrl;
#endif 	/* __IRegWizCtrl_FWD_DEFINED__ */


#ifndef __RegWizCtrl_FWD_DEFINED__
#define __RegWizCtrl_FWD_DEFINED__

#ifdef __cplusplus
typedef class RegWizCtrl RegWizCtrl;
#else
typedef struct RegWizCtrl RegWizCtrl;
#endif /* __cplusplus */

#endif 	/* __RegWizCtrl_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IRegWizCtrl_INTERFACE_DEFINED__
#define __IRegWizCtrl_INTERFACE_DEFINED__

/* interface IRegWizCtrl */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRegWizCtrl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50E5E3CF-C07E-11D0-B9FD-00A0249F6B00")
    IRegWizCtrl : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_IsRegistered( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbStatus) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_IsRegistered( 
            /* [in] */ BSTR strText) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InvokeRegWizard( 
            BSTR ProductPath) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRegWizCtrlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRegWizCtrl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRegWizCtrl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRegWizCtrl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRegWizCtrl __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRegWizCtrl __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRegWizCtrl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRegWizCtrl __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsRegistered )( 
            IRegWizCtrl __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbStatus);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_IsRegistered )( 
            IRegWizCtrl __RPC_FAR * This,
            /* [in] */ BSTR strText);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvokeRegWizard )( 
            IRegWizCtrl __RPC_FAR * This,
            BSTR ProductPath);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Version )( 
            IRegWizCtrl __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        END_INTERFACE
    } IRegWizCtrlVtbl;

    interface IRegWizCtrl
    {
        CONST_VTBL struct IRegWizCtrlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRegWizCtrl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRegWizCtrl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRegWizCtrl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRegWizCtrl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRegWizCtrl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRegWizCtrl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRegWizCtrl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRegWizCtrl_get_IsRegistered(This,pbStatus)	\
    (This)->lpVtbl -> get_IsRegistered(This,pbStatus)

#define IRegWizCtrl_put_IsRegistered(This,strText)	\
    (This)->lpVtbl -> put_IsRegistered(This,strText)

#define IRegWizCtrl_InvokeRegWizard(This,ProductPath)	\
    (This)->lpVtbl -> InvokeRegWizard(This,ProductPath)

#define IRegWizCtrl_get_Version(This,pVal)	\
    (This)->lpVtbl -> get_Version(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRegWizCtrl_get_IsRegistered_Proxy( 
    IRegWizCtrl __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbStatus);


void __RPC_STUB IRegWizCtrl_get_IsRegistered_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IRegWizCtrl_put_IsRegistered_Proxy( 
    IRegWizCtrl __RPC_FAR * This,
    /* [in] */ BSTR strText);


void __RPC_STUB IRegWizCtrl_put_IsRegistered_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRegWizCtrl_InvokeRegWizard_Proxy( 
    IRegWizCtrl __RPC_FAR * This,
    BSTR ProductPath);


void __RPC_STUB IRegWizCtrl_InvokeRegWizard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRegWizCtrl_get_Version_Proxy( 
    IRegWizCtrl __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRegWizCtrl_get_Version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRegWizCtrl_INTERFACE_DEFINED__ */



#ifndef __REGWIZCTRLLib_LIBRARY_DEFINED__
#define __REGWIZCTRLLib_LIBRARY_DEFINED__

/* library REGWIZCTRLLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_REGWIZCTRLLib;

EXTERN_C const CLSID CLSID_RegWizCtrl;

#ifdef __cplusplus

class DECLSPEC_UUID("50E5E3D1-C07E-11D0-B9FD-00A0249F6B00")
RegWizCtrl;
#endif
#endif /* __REGWIZCTRLLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizpost\atkinter.cpp ===
/*
	File : ATKInternet.cpp

	This is a wrapper function for internet API which accepts UNICODE.
	Basically these wrapper converts the UNICODE string to normal SBCS and invokes the
	appropriate SBCS  internet function


*/
#ifdef _UNICODE


#include <tchar.h>
#include "AtkInternet.h"
#include "rw_common.h"


#define MAX_SZ   260

HINTERNET  ATK_InternetOpenW(
    IN LPCWSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCWSTR lpszProxy OPTIONAL,
    IN LPCWSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    )

{
	char *pRet;

	char  szAgent[MAX_SZ] = "" ;
	char  szProxy[MAX_SZ] ="";
	char  szProxyByPass[MAX_SZ]="";

	pRet =  ConvertToANSIString (lpszAgent);
	if(pRet) {
	strcpy(szAgent, pRet);
	}

	pRet = ConvertToANSIString (lpszProxy);
	if(pRet) {
	strcpy(szProxy, pRet);
	}

	pRet = ConvertToANSIString (lpszProxyBypass);
	if(pRet) {
	strcpy(szProxyByPass, ConvertToANSIString (lpszProxyBypass));
	}

	return InternetOpenA(
    szAgent,
    dwAccessType,
    szProxy ,
    szProxyByPass,
	dwFlags);


}




HINTERNET
ATK_InternetConnectW(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpszUserName OPTIONAL,
    IN LPCWSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD dwContext
    )
{

	char szServerName[MAX_SZ]="";
	char szUserName[MAX_SZ]="";
	char szPassword[MAX_SZ]="";
	char *pRet;

	pRet = ConvertToANSIString (lpszServerName);
	if(pRet) {
		strcpy(szServerName,pRet);
	}

	pRet = ConvertToANSIString (lpszUserName);
	if(pRet) {
		strcpy(szUserName,pRet);
	}
	pRet = ConvertToANSIString (lpszPassword);
	if(pRet) {
		strcpy(szPassword,pRet);
	}

	return InternetConnectA(
    hInternet,
    szServerName,
    nServerPort,
    szUserName ,
    szPassword ,
    dwService,
    dwFlags,
    dwContext
    );


}



HINTERNET
ATK_HttpOpenRequestW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR FAR * lpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

{
	char szVerb[MAX_SZ]= "";
	char szObjectName[MAX_SZ]="";
	char szVersion[MAX_SZ]="";
	char szReferrer[MAX_SZ]="";
	char szAcceptTypes[MAX_SZ]="";
	char *pRet;

	pRet = ConvertToANSIString (lpszVerb);
	if(pRet) {
		strcpy(szVerb,pRet);
	}

	pRet = ConvertToANSIString (lpszObjectName);
	if(pRet) {
		strcpy(szObjectName,pRet);
	}

	pRet = ConvertToANSIString (lpszVersion);
	if(pRet) {
		strcpy(szVersion,pRet);
	}
	pRet = ConvertToANSIString (lpszReferrer);
	if(pRet) {
		strcpy(szReferrer,pRet);
	}
//	strcpy(szAcceptTypes,ConvertToANSIString (lpszAcceptTypes));

	return HttpOpenRequestA(
    hConnect,
    szVerb,
    szObjectName,
    szVersion,
    szReferrer ,
    NULL,
    dwFlags,
    dwContext
    );

}



BOOL
ATK_HttpSendRequestW(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    )
{
	char szHeaders[MAX_SZ]="";
	char *pRet;
	pRet =  ConvertToANSIString (lpszHeaders);
	if(pRet) {
		strcpy(szHeaders,pRet);
	}
	return HttpSendRequestA(
    hRequest,
    szHeaders ,
    dwHeadersLength,
    lpOptional,
    dwOptionalLength);


}


BOOL
ATK_InternetGetLastResponseInfoW(
    OUT LPDWORD lpdwError,
    OUT LPWSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )
{
	DWORD dwError;
	DWORD dwErrorLen;
	CHAR szErrorInfo[256];	
	dwErrorLen = 256;
	BOOL bRet;

	bRet = InternetGetLastResponseInfoA(&dwError,
							szErrorInfo,
							&dwErrorLen);
#ifdef _DEBUG
	RW_DEBUG << "\nInternet GetLastResponse ErrorNo:" << dwError ;
	RW_DEBUG << "\n\tErrorInfo:"<<szErrorInfo<<flush;
#endif

	return bRet;
	

}


BOOL ATK_HttpQueryInfoW(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
	)
{
	BOOL bRet;

	bRet = HttpQueryInfoA(hRequest, dwInfoLevel,lpBuffer,
			lpdwBufferLength, lpdwIndex);
#ifdef _DEBUG
	RW_DEBUG << "\nHttpQueryInfo:" ;
	RW_DEBUG << "\n\tBuffer  Length "<< *lpdwBufferLength <<flush;
#endif
	return bRet;


}




BOOL ATK_InternetGetCookieW(IN TCHAR *lpszUrl,
						      IN TCHAR *lpszCookieName,
							  OUT TCHAR *lpCookieData,
							  OUT LPDWORD lpdwSize)
{
	char czUrl[256]="";
	char czCookieName[128]="";
	char czCookieData[256]="";
	char *pRet= NULL;
	TCHAR *pTP;
	BOOL  bRetVal;
#ifdef _UNICODE
	
	// Presently the UNICODE version is not implemented in
	// the NT SDK
	//and the declaration defined in WININET.H is
	//	BOOLAPI
	//	InternetGetCookieW(
    //	IN LPCSTR lpszUrl,
    //	IN LPCWSTR lpszCookieName,
    //	OUT LPWSTR lpCookieData,
    //	IN OUT LPDWORD lpdwSize
    //);
// So Convert the first parameter to  ANSI String
	pRet = ConvertToANSIString(lpszUrl);
	if(pRet) strcpy(czUrl,pRet);

	pRet = ConvertToANSIString(lpszCookieName);
	if(pRet) strcpy(czCookieName,pRet);

	#ifdef  USE_ASTRATEK_WRAPPER
	bRetVal = InternetGetCookieA(czUrl,
							czCookieName,
							czCookieData,
							lpdwSize);
	//
	// Convert the Return Values to Unicode
	 pTP= ConvertToUnicode(czCookieData);
	 if(pTP) {
		 _tcscpy(lpCookieData,pTP);
	 }else {
		lpCookieData[0]= _T('\0');
	 }

	#else
	bRetVal = InternetGetCookieW(czUrl,
							lpszCookieName,
							lpCookieData,
							lpdwSize);

	#endif
	
	 return bRetVal;
#endif

}


BOOL ATK_InternetQueryOption(IN HINTERNET hInternet,
							 IN DWORD dwOption,
							 OUT LPVOID lpBuffer,
							 IN OUT LPDWORD lpdwBufferLength
							)
{
	BOOL  bRetVal;
	bRetVal = InternetQueryOptionA(hInternet,
							dwOption,
							lpBuffer,
							lpdwBufferLength);

    return bRetVal;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizpost\atk_ras.cpp ===
/*
	File : ASTRA_RAS.h

*/
#include <ATK_RAS.h>



static int siRasDllLoaded = RAS_DLL_NOT_LOADED ;
static HINSTANCE	hRasDllInst=NULL;

static RASGETENTRYPROPERTIES  pRasGetEntryProperties;
static RASSETENTRYPROPERTIES  pRasSetEntryProperties;
static RASDELETEENTRY         pRasDelEntry;
static RASGETERRORSTRING      pRasGetErrorString;
static RASDIAL                pRasDial;
static RASHANGUP              pRasHangup;
static RASENUMDEVICES         pRasEnumDevices;
static RASENUMCONNECTIONS     pRasEnumConnections;
static RASGETCOUNTRYINFO      pRasGetCountryInfo; 
static RASGETCOUNTRYINFO      pRasGetCountryInfoA;
static RASGETCONNECTIONSTATUS pRasGetConnectionStatus;  



int ATK_IsRasDllOk()
{
	if(siRasDllLoaded == RAS_DLL_NOT_LOADED  ) {
		hRasDllInst = LoadLibrary(_T("RASAPI32.DLL"));
		if(hRasDllInst == NULL) {
			siRasDllLoaded = ERROR_LOADING_RAS_DLL;

		}else {
			//
			//
			// Get All Function Pointers;
#ifdef _UNICODE
			pRasGetEntryProperties  = (RASGETENTRYPROPERTIES) 
				GetProcAddress(hRasDllInst, "RasGetEntryPropertiesW");
#else
			pRasGetEntryProperties  = (RASGETENTRYPROPERTIES) 
				GetProcAddress(hRasDllInst, "RasGetEntryPropertiesA");

#endif

#ifdef _UNICODE
			pRasSetEntryProperties=  (RASSETENTRYPROPERTIES)
				GetProcAddress(hRasDllInst, "RasSetEntryPropertiesW");
#else
			pRasSetEntryProperties=  (RASSETENTRYPROPERTIES)
				GetProcAddress(hRasDllInst, "RasSetEntryPropertiesA");
#endif

#ifdef _UNICODE
			pRasDelEntry = (RASDELETEENTRY) 
				GetProcAddress(hRasDllInst, "RasDeleteEntryW");
#else
			pRasDelEntry = (RASDELETEENTRY) 
				GetProcAddress(hRasDllInst, "RasDeleteEntryA");
#endif

#ifdef _UNICODE
			pRasGetErrorString = (RASGETERRORSTRING)
			GetProcAddress(hRasDllInst, "RasGetErrorStringW");
#else
			pRasGetErrorString = (RASGETERRORSTRING)
			GetProcAddress(hRasDllInst, "RasGetErrorStringA");
#endif


#ifdef _UNICODE
			pRasDial = (RASDIAL)
			GetProcAddress(hRasDllInst, "RasDialW");
#else
			pRasDial = (RASDIAL)
			GetProcAddress(hRasDllInst, "RasDialA");
#endif


#ifdef _UNICODE
			pRasHangup = (RASHANGUP)
			GetProcAddress(hRasDllInst, "RasHangUpW");
#else
			pRasHangup = (RASHANGUP)
			GetProcAddress(hRasDllInst, "RasHangUpA");
#endif


#ifdef _UNICODE
			pRasEnumDevices = (RASENUMDEVICES )
					GetProcAddress(hRasDllInst, "RasEnumDevicesW");
#else
				pRasEnumDevices = (RASENUMDEVICES )
					GetProcAddress(hRasDllInst, "RasEnumDevicesA");
#endif

#ifdef _UNICODE
			pRasEnumConnections = (RASENUMCONNECTIONS)
					GetProcAddress(hRasDllInst, "RasEnumConnectionsW");
#else
			pRasEnumConnections = (RASENUMCONNECTIONS)
					GetProcAddress(hRasDllInst, "RasEnumConnectionsA");
#endif

#ifdef _UNICODE
			pRasGetCountryInfo = (RASGETCOUNTRYINFO)
					GetProcAddress(hRasDllInst, "RasGetCountryInfoW");
#else
			pRasGetCountryInfo = (RASGETCOUNTRYINFO)
					GetProcAddress(hRasDllInst, "RasGetCountryInfoA");
#endif
		
			pRasGetCountryInfoA = (RASGETCOUNTRYINFO)
					GetProcAddress(hRasDllInst, "RasGetCountryInfoA");

#ifdef _UNICODE
			pRasGetConnectionStatus  = (RASGETCONNECTIONSTATUS) 
				GetProcAddress(hRasDllInst, "RasGetConnectionStatusW");
#else
			pRasGetConnectionStatus  = (RASGETCONNECTIONSTATUS) 
				GetProcAddress(hRasDllInst, "RasGetConnectionStatusA");
#endif


				
			siRasDllLoaded = RAS_DLL_LOADED;
  		}


	}
	return siRasDllLoaded;
	 
}


DWORD ATK_RasGetEntryProperties(
		LPTSTR lpszPhonebook, 
		LPTSTR lpszEntry, 
		LPRASENTRY lpRasEntry, 
		LPDWORD lpdwEntryInfoSize, 
		LPBYTE lpbDeviceInfo, 
		LPDWORD lpdwDeviceInfoSize )
{
	return (*pRasGetEntryProperties) ( lpszPhonebook, 
				 lpszEntry, 
				 lpRasEntry, 
			  	 lpdwEntryInfoSize, 
				 lpbDeviceInfo, 
				 lpdwDeviceInfoSize);

}


DWORD ATK_RasSetEntryProperties(
		LPTSTR lpszPhonebook, 
		LPTSTR lpszEntry, 
		LPRASENTRY lpRasEntry, 
		DWORD dwEntryInfoSize, 
		LPBYTE lpbDeviceInfo, 
		DWORD dwDeviceInfoSize )
{
	return (*pRasSetEntryProperties) ( 
				 lpszPhonebook, 
				 lpszEntry, 
				 lpRasEntry, 
			  	 dwEntryInfoSize, 
				 lpbDeviceInfo, 
				 dwDeviceInfoSize);


}

DWORD ATK_RasDeleteEntry( LPTSTR lpszPhonebook,
					   LPTSTR lpszEntry)
{
	return (*pRasDelEntry)(lpszPhonebook,lpszEntry);
}

DWORD ATK_RasGetErrorString( UINT uErrorValue, 
							 LPTSTR lpszErrorString, 
							 DWORD cBufSize )
{
	return (*pRasGetErrorString)(uErrorValue,lpszErrorString,cBufSize);

}

DWORD ATK_RasHangUp( HRASCONN hrasconn )
{
	return (*pRasHangup)(hrasconn);
}              


DWORD ATK_RasDial( LPRASDIALEXTENSIONS lpRasDial, 
			 LPTSTR  lpPhBk, 
			 LPRASDIALPARAMS lpDialParam,
			 DWORD dwNotifyType,
			 LPVOID lpNotifier,
			 LPHRASCONN lphRasConn)
{
	return (*pRasDial) ( lpRasDial, 
			 lpPhBk, 
			 lpDialParam,
			 dwNotifyType,
			 lpNotifier,
			 lphRasConn);

}



DWORD ATK_RasEnumDevices( LPRASDEVINFO lpRasDevInfo, 
						  LPDWORD lpcb, 
						  LPDWORD lpcDevices)

{
	return (*pRasEnumDevices)(lpRasDevInfo, 
		lpcb, 
		lpcDevices);

}

DWORD ATK_RasEnumConnections ( LPRASCONN lprasconn, 
							  LPDWORD lpcb, 
							  LPDWORD lpcConnections)
{
	return (*pRasEnumConnections) (lprasconn,lpcb, 
							  lpcConnections);
}

#define  MAX_ACTIVE_RAS_CONNECTION 5
/*

	Returns +VE value if there is an active connection

*/
int IsDialupConnectionActive()
{
	RASCONN RasConn[MAX_ACTIVE_RAS_CONNECTION];
	DWORD   dwSizeConn,dwConnections,dwRet;
	int		iCount;
	dwConnections = 0;
	for(iCount=0;iCount < MAX_ACTIVE_RAS_CONNECTION ;iCount++) {
		RasConn[iCount].dwSize= sizeof(RASCONN);
	}

	dwSizeConn = sizeof(RASCONN) * MAX_ACTIVE_RAS_CONNECTION;
	dwRet = ATK_RasEnumConnections ( RasConn, 
							 &dwSizeConn, 
							 &dwConnections);
	switch(dwRet) 
	{
	case ERROR_BUFFER_TOO_SMALL :
		;
		//cout << "\n Buffer Too Small "<< flush;
	case ERROR_NOT_ENOUGH_MEMORY :
		;
		//cout << "\n Not enough memory  "<< flush;
	default :
		break;
	} 

	if(dwConnections) {
		return ((int)dwConnections);
	}else {
		return 0;
	}


}

DWORD ATK_RasGetCountryInfo( LPRASCTRYINFO lpRasCtryInfo, 
					LPDWORD lpdwSize )
{
 return (*pRasGetCountryInfo) (lpRasCtryInfo,lpdwSize); 
				  
 
} 
 
DWORD ATK_RasGetCountryInfoA( LPRASCTRYINFO lpRasCtryInfo, 
					LPDWORD lpdwSize )
{
 return (*pRasGetCountryInfoA) (lpRasCtryInfo,lpdwSize); 
} 

DWORD ATK_RasGetConnectionStatus( HRASCONN hrasconn,LPRASCONNSTATUS lprasconnstatus )
{
 return (*pRasGetConnectionStatus) (hrasconn,lprasconnstatus); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizpost\dconv.cpp ===
//
//	File : DCONV.CPP
//  Date : 04/25/97
//	Author : Suresh Krishnan
//  This file has modules responsible for making the  buffer data to be transmitted to the IIS
//
//  MDF 1 : 05/07/97   Modified the Table as per StevBush modifications in the BackEnd
//  MFD 2 : 03/03/97   Added Division Name and UserID for FE screens
//                     Phone number will be prefixed with Area Code
//  MFD3  : 04/29/98   Added additional 4 fileds to be sent to the backend as a part of
//                     Taxanomy Screen changes.
//                     Fields risen from 60 to 64. Fileds added
//					   SoftwareRole,InfluenceLevel,EngagementLevel,SkillLevel
//  MFD4  : 07/21/98   Additional 2 fields  to be sent to the backend SCSIAdapter
//					   and ComputerManufacturer & Model of SystemInventory
//  MFD5  : 08/1/98    The MathCoprocessor and Color Depth are no longer necessary to be sent to the back end
//                     so the items that are sent to the back end are 66-2 = 64
//  MFD6  : 08/21/98   Added AreaCode and MiddleName( Middle Initial) fo posting
//                     So number of Fields for posting 64+2 = 66
//                     From now on Area code will be sent as a seperate field  to the backend
//                     the logic involved in prefixing with phone number will be removed
//
//	MFD7 :  03/10/99  HWID no longer will be Transmitted to the Backend 
//			  	      Total Entries to Backend 65	
// 
//
#include <mbstring.h>
#include "RW_Common.h"
#include "resource.h"
#include <tchar.h>
#include "dconv.h"
#include "cntryinf.h"
#include "RegWizMain.h"



extern BOOL bOemDllLoaded;
extern HINSTANCE  hOemDll;

#define  NAME_VALUE_SEPERATOR   _T("=")    // Seperator between name and its value
#define  NAME_SEPERATOR         _T("&") 	 // Seperator between the names
#define  RW_BLANK               _T(' ')      // The padding character
#define  RW_WITH_URL			1
#define  PHONE_NUMBER_SEPERATOR _T("-")

#define MAX_NAME_LENGTH    64	 // The Max size of the of the name field
#define VARIABLE_LEN       -2
#define REG_SEPERATOR   TEXT("\\")
#define MAX_TBL_ENTRIES   65     //  No of name fields to be sent to the IIS
#define MAX_REG_VAL_BUF_SZ    300 // The Maximum  size of a value associated with name field
#define STRCONVERT_MAXLEN  1024

static  TCHAR * GetNameString ( TCHAR **pRet,UINT iId,HINSTANCE hIns) ;
int  GetRootOfRegWizRegistry(HINSTANCE hInstance , PHKEY  phKey);
#ifdef _UNICODE
	char* ConvertToMB (TCHAR * szW)
	{
		static char achA[STRCONVERT_MAXLEN];
		WideCharToMultiByte(CP_ACP, 0, szW, -1, achA, STRCONVERT_MAXLEN, NULL, NULL);
		return achA;
	}
#else
	char* ConvertToMB (TCHAR * szW)
	{
		return szW;
	}
#endif

// Information processig functions
void	RW_Dummy (_TCHAR * tcSrc, _TCHAR * tcDes , HINSTANCE hIns )
{
};

void 	RW_LanguageTranslate (_TCHAR * tcSrc, _TCHAR * tcDes , HINSTANCE hIns )
{
	LANGID langID = GetSystemDefaultLangID();
	VerLanguageName(langID,tcDes,MAX_REG_VAL_BUF_SZ);
}

void 	RW_CreateDateProcess (_TCHAR * tcSrc, _TCHAR * tcDes , HINSTANCE hIns )
{
};

void 	RW_RegisterDateProcess (_TCHAR * tcSrc, _TCHAR * tcDes , HINSTANCE hIns )
{
};

void    RW_MailingAddressProcess (_TCHAR * tcSrc, _TCHAR * tcDes , HINSTANCE hIns )
{
	size_t iSrcLen = _tcslen(tcSrc);
	if(iSrcLen)
	{
		_tcscpy(tcDes,TEXT("1"));
	}
	else
	{
		_tcscpy(tcDes,TEXT("2"));
	}
}


void	RW_ValidateTapiCountryCode (_TCHAR * tcSrc, _TCHAR * tcDes , HINSTANCE hIns )
{
	DWORD dwTapiCntryId;
	DWORD dwCode = _ttol(tcSrc);
	dwTapiCntryId = gTapiCountryTable.GetTapiIDForTheCountryIndex(dwCode);
	_stprintf(tcDes,_T("%d"),dwTapiCntryId);


};

void	RW_TranslateCountryCode(_TCHAR * tcSrc, _TCHAR * tcDes , HINSTANCE hIns )
{
	DWORD dwCode = _ttol(tcSrc); // Convert the Current code in string to long
	_tcscpy(tcDes, gTapiCountryTable.GetCountryName(dwCode));

}

void	RW_ParsePhoneNumber(_TCHAR * tcSrc, _TCHAR * tcDes , HINSTANCE hIns )
{
	HKEY	hKey;
	DWORD   infoSize;
	TCHAR   szR[48];
	TCHAR   szParam[256];
	LONG    lRegStatus;
	TCHAR   szInBuf[256];
	//
	// As a part of FE screen changes it is necessary to Prefix the Area code
	// before the phone number
	hKey = NULL;
	if(GetRootOfRegWizRegistry(hIns, &hKey) ) {
		return;
		// Not able to open the Registry Tree for Area Code
		// so simply return ...
	}
	infoSize = 48;
	LoadString( hIns, IDS_AREACODE_KEY,
						szR,
						sizeof(szR)/ sizeof (TCHAR));
	lRegStatus = RegQueryValueEx(hKey,&szR[1],NULL,0,(LPBYTE)szParam,&infoSize);
	if(tcSrc[0] !=  _T('\0')){
		_tcscpy(szInBuf,tcSrc);
	}else {
		szInBuf[0] = _T('\0');
	}

	if (lRegStatus != ERROR_SUCCESS){
		   	return; //  	RWZ_INVALID_INFORMATION;
	}else {
		if(szParam[0] != _T('\0')) {
			_tcscpy(tcDes,szParam); // Area Code
			_tcscat(tcDes,PHONE_NUMBER_SEPERATOR);     // Separator
			_tcscat(tcDes,szInBuf);
			
		}else {
			//No need to do any thing
			;
		}
		if(hKey)
		RegCloseKey(hKey);
	}
	

}

void	RW_PrcsProductId (LPTSTR tcSrc, LPTSTR tcDes , HINSTANCE hIns )
{
	_TCHAR	seps[] = _T("-");
	LPTSTR	token;
	LPTSTR	buf;
	if (*tcSrc == 0 ) 
    {
		*tcDes=0;
		return;
	}

   buf = new _TCHAR[_tcslen(tcSrc) * sizeof(_TCHAR) +sizeof(_TCHAR)];
   if (buf)
   {
       token = _tcstok( tcSrc, seps );
       _tcscpy(buf,token);

       token = _tcstok( NULL, seps );
       while( token != NULL )
       {
	    /* Get next token: */
	    _tcscat(buf,token);
	    token = _tcstok( NULL, seps );
       }
	    
	    _tcscpy(tcDes,buf);

        delete[] buf;
   }
};

//
// void	RW_ParseTotalSize (_TCHAR * tcSrc, _TCHAR * tcDes  )
// This function retrives the the Size  wich is founs as the first  token in tcSrc
// After the end of this function the tcDes will be assiged with the Size
//
void	RW_ParseTotalSize (_TCHAR * tcSrc, _TCHAR * tcDes , HINSTANCE hIns )
{
	int isBlankPassed=0;
	TCHAR tcSteps[]   = TEXT(" ,\t\n");
	if(*tcSrc == 0 )
	{
		*tcDes=0;
		return;
	}

	// since the value in tcSrc is "RAM UNIT" so it is encouh if is pass only the first word
	TCHAR  *tcToken;
    tcToken =_tcstok(tcSrc, tcSteps);
	_tcscpy(tcDes,tcToken);

}

//
// void	RW_ParseUnits (_TCHAR * tcSrc, _TCHAR * tcDes  )
// This function retrives the the unit name wich is founs as the second token in tcSrc
// After the end of this function the tcDes will be assiged with the Units
//
void	RW_ParseUnits (_TCHAR * tcSrc, _TCHAR * tcDes , HINSTANCE hIns )
{
	int isBlankPassed=0;
	TCHAR tcSteps[]   = TEXT(" ,\t\n\0");
	if(*tcSrc == 0 )
	{
		*tcDes=0;
		return;
	}
	// since the value in tcSrc is "RAM UNIT" so it is encouh if is pass only the first word
	TCHAR  *tcToken;
    tcToken =_tcstok(tcSrc, tcSteps); // get the size
    tcToken = _tcstok( NULL, tcSteps); // get the units
	_tcscpy(tcDes,tcToken);

}

//
// RegWizInfoDetails
// This  structure is used to create a table which has the Namefiled,
// the value reference in the Resource  which is to  be used to retrive from registry
// and Function  to process the value
//
typedef struct  RegWizInfoDetails
{
	int    m_iIndex;
	TCHAR   m_czName[MAX_NAME_LENGTH];
	int    m_iLen;
	int    m_ResourceIndex;
	int    m_iParam;
	void (*m_fp)(_TCHAR * tcSrc, _TCHAR * tcDes, HINSTANCE hIns);
} _RegWizInfoDetails ;

static RegWizInfoDetails  sRegWizInfoTbl[MAX_TBL_ENTRIES] =
{
{ 1,    _T("RegWizVer")			,8,				IDS_INFOKEY30,		0, RW_Dummy },
{ 2,    _T("CodePage")			,5,				-1 ,				0, RW_Dummy },
{ 3,    _T("LangCode")			,5,				IDS_INFOKEY34 ,		0, RW_Dummy },
{ 4,    _T("LangName")			,30,			IDS_INFOKEY34 ,		0, RW_LanguageTranslate },
{ 5,    _T("CreatedDate")		,10,			-1 ,				0, RW_CreateDateProcess    },
{ 6,    _T("RegDate")			,10,			IDS_INFOKEY33,		0, RW_RegisterDateProcess },
{ 7,    _T("FName")				,VARIABLE_LEN,	IDS_INFOKEY1 ,		0, RW_Dummy },
{ 8,    _T("LName")				,VARIABLE_LEN,	IDS_INFOKEY2 ,		0, RW_Dummy },
{ 9,    _T("CompanyName")		,VARIABLE_LEN,	IDS_INFOKEY3,		0, RW_Dummy },
{ 10,   _T("AddrType")			,1,				IDS_INFOKEY3,		0, RW_MailingAddressProcess },
{ 11,   _T("Addr1")				,VARIABLE_LEN , IDS_INFOKEY4,		0, RW_Dummy },
{ 12,   _T("Addr2")				,VARIABLE_LEN,  IDS_INFOKEY5,		0, RW_Dummy },
{ 13,   _T("City")				,VARIABLE_LEN,  IDS_INFOKEY6,		0, RW_Dummy },
{ 14,   _T("State")				,VARIABLE_LEN , IDS_INFOKEY7,		0, RW_Dummy },
{ 15,   _T("Zip")				,VARIABLE_LEN , IDS_INFOKEY8,		0, RW_Dummy },
{ 16,   _T("CountryCode")		,4 ,            IDS_INFOKEY9 ,		0, RW_ValidateTapiCountryCode  },
{ 17,   _T("Country")			,60,            IDS_INFOKEY9 ,		0, RW_TranslateCountryCode },
{ 18,   _T("Phone")				,VARIABLE_LEN , IDS_INFOKEY10,		0, RW_Dummy },
{ 19,   _T("NoOther")			,1 ,			IDS_INFOKEY11,		0, RW_Dummy },
{ 20,   _T("Product")			,255,			IDS_INFOKEY28,		0, RW_Dummy },
{ 21,   _T("PID")				,20,			IDS_INFOKEY12,		0, RW_PrcsProductId },
{ 22,   _T("OEM")				,255 ,			IDS_INFOKEY29,		0, RW_Dummy },
{ 23,   _T("SysInv")			,1,				IDS_INFOKEY26,		0, RW_Dummy },
{ 24,   _T("OS")				,40,			IDS_INFOKEY25,		0, RW_Dummy },
{ 25,   _T("CPU")				,20 ,			IDS_INFOKEY13,		0, RW_Dummy },
//{ 26,   _T("MathCo")			,1  ,			IDS_INFOKEY14,		0, RW_Dummy },
{ 27,   _T("TotalRAM")			,8 ,			IDS_INFOKEY15,		0, RW_ParseTotalSize},
{ 28,   _T("RAMUnits")			,2 ,			IDS_INFOKEY15,		0, RW_ParseUnits},
{ 29,   _T("TotalDisk")			,8 ,			IDS_INFOKEY16,		0, RW_ParseTotalSize},
{ 30,   _T("DiskUnits")			,2 ,			IDS_INFOKEY16,		0, RW_ParseUnits},
{ 31,   _T("RemoveableMedia")	,60 ,			IDS_INFOKEY17,		0, RW_Dummy },
//{ 32,   _T("DisplayRes")		,16 ,			IDS_INFOKEY18 ,		0, RW_Dummy },
{ 33,   _T("DisplayColorDepth")	,8 ,			IDS_INFOKEY19 ,		0, RW_Dummy },
{ 34,   _T("PointingDevice")	,75,			IDS_INFOKEY20 ,		0, RW_Dummy },
{ 35,   _T("Network")			,75 ,			IDS_INFOKEY21 ,		0, RW_Dummy },
{ 36,   _T("Modem")				,75 ,			IDS_INFOKEY22 ,		0, RW_Dummy },
{ 37,   _T("Sound")				,60 ,			IDS_INFOKEY23 ,		0, RW_Dummy },
{ 38,   _T("CDROM")				,40 ,			IDS_INFOKEY24 ,		0, RW_Dummy },
{ 39,   _T("ProdInv")			,1 ,			IDS_INFOKEY27 ,		0, RW_Dummy },
{ 40,   _T("InvProd1")			,75,			IDS_PRODUCTBASEKEY, 1, RW_Dummy },
{ 41,   _T("InvProd2")			,75,			IDS_PRODUCTBASEKEY, 2, RW_Dummy },
{ 42,   _T("InvProd3")			,75,			IDS_PRODUCTBASEKEY, 3, RW_Dummy },
{ 43,   _T("InvProd4")			,75,			IDS_PRODUCTBASEKEY, 4, RW_Dummy },
{ 44,   _T("InvProd5")			,75,			IDS_PRODUCTBASEKEY, 5, RW_Dummy },
{ 45,   _T("InvProd6")			,75,			IDS_PRODUCTBASEKEY, 6, RW_Dummy },
{ 46,   _T("InvProd7")			,75,			IDS_PRODUCTBASEKEY, 7, RW_Dummy },
{ 47,   _T("InvProd8")			,75,			IDS_PRODUCTBASEKEY, 8, RW_Dummy },
{ 48,   _T("InvProd9")			,75,			IDS_PRODUCTBASEKEY, 9, RW_Dummy },
{ 49,   _T("InvProd10")			,75,			IDS_PRODUCTBASEKEY, 10,RW_Dummy },
{ 50,   _T("InvProd11")			,75,			IDS_PRODUCTBASEKEY, 11,RW_Dummy },
{ 51,   _T("InvProd12")			,75,			IDS_PRODUCTBASEKEY, 12,RW_Dummy },
{ 52,   _T("EmailName")			,50,            IDS_INFOKEY35,		0, RW_Dummy },
{ 53,   _T("Reseller")			,30,            IDS_INFOKEY36,		0, RW_Dummy },
{ 54,   _T("ResellerCity")		,20,            IDS_INFOKEY37,		0, RW_Dummy },
{ 55,   _T("ResellerState")		,3,             IDS_INFOKEY38,		0, RW_Dummy },
//{ 56,   _T("HWID")				,32,            IDS_INFOKEY39,		0, RW_Dummy },
{ 57,   _T("MSID")				,32,            IDS_INFOKEY40,		0, RW_Dummy },
{ 58,   _T("Extension")			,32,            IDS_INFOKEY41,		0, RW_Dummy },
{ 59,   _T("DivisionName")      ,50,            IDS_DIVISIONNAME_KEY,   0, RW_Dummy },
{ 60,   _T("UserID")            ,50,            IDS_USERID_KEY,     0, RW_Dummy },
{ 61,   _T("SoftwareRole")		,2,             IDS_BUSINESSQ1,		0, RW_Dummy },
{ 62,   _T("InfluenceLevel")	,2,             IDS_HOMEQ1,		0, RW_Dummy },
{ 63,   _T("EngagementLevel")   ,2,             IDS_HOMEQ2,   0, RW_Dummy },
{ 64,   _T("SkillLevel")        ,2,             IDS_HOMEQ3,     0, RW_Dummy },
{ 65,   _T("SCSIAdapter")       ,75,            IDS_SCSI_ADAPTER,     0, RW_Dummy },
{ 66,   _T("ComputerManf")     ,256,            IDS_COMPUTER_MODEL,     0, RW_Dummy },
{ 67,   _T("AreaCode")       ,30,            IDS_AREACODE_KEY,     0, RW_Dummy },
{ 68,   _T("Mname")     ,75,            IDS_MIDDLE_NAME,     0, RW_Dummy }
};





//
//  PadWithBlanks(TCHAR **pSrc, TCHAR ** pDes,int iLen)
//
//  This function adds space to the soiurce string so the resultant string is of the length
//  specified by iLen
//
//
//
void PadWithBlanks(TCHAR *pSrc, TCHAR * pDes,int iLen)
{
	int iSrcLen;

	iSrcLen = _tcslen(pSrc) * sizeof(_TCHAR);
	if(iLen < 0)
	{
		//  if it is  variable length then copy the string and return
		_tcscpy(pDes,pSrc);
		return;
	}
	
	//
	// Try to copy till iLen
	// the extra +1 is added to add a null terminator after copy
	_tcsnccpy(pDes,pSrc,iLen+ sizeof(_TCHAR));

	if(iSrcLen < iLen )
	{
		// the source string is less than the expected maximum length
		for(int iIndex = iSrcLen;iIndex < iLen;iIndex++)
		{
			pDes[iIndex] = RW_BLANK; // Adds blank
		}
		pDes[iIndex] = _T('\0');
	}
	
}

// int  GetRootOfRegWizRegistry(HINSTANCE hInstance , PHKEY  phKey)
//
// Description :
//	This function Opens the User  Information value in the registry for
//  regWizard configured values to be read
//
//	Return Information:
//	This function return the HANDLE of the registry in phKey and returns 0
//  If the Key is not found the  function returns 1
//
//


int  GetRootOfRegWizRegistry(HINSTANCE hInstance , PHKEY  phKey)
{
	TCHAR uszPartialKey[128];
	TCHAR uszRegKey[128];
	uszRegKey[0] = _T('\0');
	
	int resSize = LoadString(hInstance,IDS_KEY2,uszRegKey,128);
	_tcscat(uszRegKey,REG_SEPERATOR);
	resSize = LoadString(hInstance,IDS_KEY3,uszPartialKey,128);
	_tcscat(uszRegKey,uszPartialKey);
	_tcscat(uszRegKey,REG_SEPERATOR);
	resSize = LoadString(hInstance,IDS_KEY4,uszPartialKey,128);
	_tcscat(uszRegKey,uszPartialKey);
	
	#ifdef USE_INFO_SUBKEYS
		_tcscat(uszRegKey,REG_SEPERATOR);
	#endif

	LONG regStatus =RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		uszRegKey,
		0,
		KEY_ALL_ACCESS,
		phKey);

	if (regStatus != ERROR_SUCCESS)
	{
		return 1; // error
	}
	else
	{
		return 0; // Success
	}
}

//
// TCHAR * GetNameString ( TCHAR **pRet,UINT uId,HINSTANCE hIns)
//
//  Description :
//
//	This function retrives the Name field  for Transmission from the Resource
//  Some names in the  resouce is prefixed with '_' so this function  removes the
//  prefix character.
//
//  Return Information:
//  This function returns  NULL if the string is not found in the resource
//	It accepts the address of a TCHAR pointer  ,the string address is assigned in the
//  pointer.  It also returns the same address as a return Status
//
//  Note :
//  It is not required to delete the pointer returned by this function as it is static
//

TCHAR * GetNameString ( TCHAR **pRet,UINT uId,HINSTANCE hIns)
{
	static TCHAR tczRetValue[MAX_NAME_LENGTH ];
	int  iLoad = LoadString( hIns, uId,
						tczRetValue,
						sizeof(tczRetValue)/ sizeof (TCHAR));
	if(!iLoad )
	{
		pRet = NULL;
		return NULL;
	}

	if( tczRetValue[0]   == _T('_')   )
	{
		*pRet = &tczRetValue[1];
		return &tczRetValue[1];
	}
	else
	{
		*pRet = &tczRetValue[0];
		return &tczRetValue[0];
	}

}

//
//
// URL Encoding

/*===================================================================
URLEncodeLen

Return the storage requirements for a URL-Encoded string

Parameters:
	szSrc  - Pointer to the string to URL Encode

Returns:
	the number of bytes required to encode the string
===================================================================*/

int URLEncodeLen(const char *szSrc)
{
	int cbURL = 1;		// add terminator now
	while (*szSrc)
	{
		if (*szSrc & 0x80)				// encode foreign characters
			cbURL += 3;
		else
		if (*szSrc == ' ')			// encoded space requires only one character
			++cbURL;
		else
		if (! isalnum(*szSrc))		// encode non-alphabetic characters
			cbURL += 3;
		else
			++cbURL;

		++szSrc;
	}
	return cbURL;
}



/*===================================================================
URLEncode

URL Encode a string by changing space characters to '+' and escaping
non-alphanumeric characters in hex.

Parameters:
	szDest - Pointer to the buffer to store the URLEncoded string
	szSrc  - Pointer to the source buffer

Returns:
	A pointer to the NUL terminator is returned.
===================================================================*/

char *URLEncode(char *szDest, const char *szSrc)
{
	char hex[] = "0123456789ABCDEF";

	while (*szSrc)
	{
		if (*szSrc == ' ')
		{
			*szDest++ = '+';
			++szSrc;
		}
		else
		if (!isalnum(*szSrc) || (*szSrc & 0x80))
		{
			*szDest++ = '%';
			*szDest++ = hex[BYTE(*szSrc) >> 4];
			*szDest++ = hex[*szSrc++ & 0x0F];
		}
		else
			*szDest++ = *szSrc++;
	}

	*szDest = '\0';
	return szDest;
}



//
// This class is used to store the RegWiz Info in URL encode format
// This class is construected with the TxBuffer pointer
// The AppendToBuffer converts the string to URL encoded form and adds to the TxBuffer
// if the TxBuffer size  is less then it only computesthe size  and does not transfer
// the buffer contents
//

class RegWizTxBuffer
{

public :

	char *m_pBuf;
	int   m_iSizeExceeded; // set
	DWORD *m_pdInitialSize;
	DWORD m_dCurrentIndex;

	RegWizTxBuffer(char *tcTxBuf, DWORD * pRetLen)
	{
		m_pBuf = tcTxBuf; // Initial Pointer of the Destination Buffer
		m_pdInitialSize = pRetLen; // The Destination Buffer Size
		m_dCurrentIndex = 0; // Current Index of the number of bytes of information transmitted
		m_iSizeExceeded = 0;
		m_pBuf[0] = '\0';
	}

	void  AppendToBuffer(TCHAR *tcTxBuf, int iIsUrl=0)
	{
		int iLen=0;
		
		#ifdef _UNICODE
			unsigned char *mbpTxBuf;
		#endif

		// The TxBuffer has to be converted to MultiByte in case
		// Convert to MultByte

		#ifdef _UNICODE
			mbpTxBuf = (unsigned char *)ConvertToMB (tcTxBuf); // Convert to MultiByte
			iLen =  _mbslen (mbpTxBuf);
		#else
			iLen = _tcsclen(tcTxBuf);
		#endif

		if(iIsUrl)
		{
			#ifdef _UNICODE
				iLen= URLEncodeLen((const char *)mbpTxBuf);
			#else
				iLen = URLEncodeLen(tcTxBuf);
			#endif
		}

		if( m_dCurrentIndex + iLen >= *m_pdInitialSize )
		{
			// continue counting the lengthn required
			m_iSizeExceeded = 1;
	 	}
		else
		{
			if( iIsUrl)
			{
				#ifdef _UNICODE
					URLEncode(m_pBuf+m_dCurrentIndex,(const char *)mbpTxBuf);
				#else
					// for MBCS and SBCS
					URLEncode(m_pBuf+m_dCurrentIndex,tcTxBuf);
				#endif
			}
			else
			{
				#ifdef _UNICODE
					strcat(m_pBuf,(const char *)mbpTxBuf);
				#else
					_tcscat(m_pBuf,tcTxBuf);
				#endif
			}
		;

		}
		if(iIsUrl)
		m_dCurrentIndex +=  iLen-1;
		else
		m_dCurrentIndex +=  iLen;

	}

	int  IsValidBuffer()
	{
		m_pBuf[m_dCurrentIndex] = '\0';
		*m_pdInitialSize = m_dCurrentIndex;
		return m_iSizeExceeded ;
	}

};


int PrepareRegWizTxbuffer(HINSTANCE hIns, char *tcTxBuf, DWORD * pRetLen)
{
	int				iRetValue;
	HKEY			hKey;
	LONG			lRegStatus;
	TCHAR			*szR;
	TCHAR			tczTmp[10];
	TCHAR			szParam[MAX_REG_VAL_BUF_SZ]; // ?? chk in case of Unicode
	unsigned long	infoSize;
	RegWizTxBuffer  TxferBuf(tcTxBuf,pRetLen);

	iRetValue		= RWZ_NOERROR;
	infoSize		= MAX_REG_VAL_BUF_SZ;

	if(GetRootOfRegWizRegistry(hIns, &hKey) )
	{
		iRetValue = RWZ_NO_INFO_AVAILABLE;
		// No User Information is Available So Abort the program
	}
	else
	{
		// Process for all the information entries
		 for(int i =0;i <  MAX_TBL_ENTRIES ;i++)
		 {
			infoSize = MAX_REG_VAL_BUF_SZ;
			szParam[0] = '\0';
		
			#ifdef _LOG_IN_FILE			
		 		RW_DEBUG << "\n" << i+1  << "\t"  << ConvertToMB (sRegWizInfoTbl[i].m_czName) << "\t" << flush;
			#endif
			
			TxferBuf.AppendToBuffer(sRegWizInfoTbl[i].m_czName,RW_WITH_URL);
			
			TxferBuf.AppendToBuffer(NAME_VALUE_SEPERATOR);

			if( sRegWizInfoTbl[i].m_ResourceIndex < 1)
			{
				 // continue processing
			}
			else
			{
				if( GetNameString(&szR,sRegWizInfoTbl[i].m_ResourceIndex,hIns ) )
				{

					if(	sRegWizInfoTbl[i].m_iParam )
					{
						//  This block is  for appending Product name index
						_itot(sRegWizInfoTbl[i].m_iParam,tczTmp,10);
						_tcscat(szR,_T(" ")); // add a single blank
						_tcscat(szR,tczTmp);
						#ifdef _LOG_IN_FILE
							RW_DEBUG  << ConvertToMB (szR) << "\t";
						#endif
					}
					lRegStatus = RegQueryValueEx(hKey,szR,NULL,0,(  LPBYTE )   szParam,&infoSize);

					if (lRegStatus != ERROR_SUCCESS)
					{
					   	return 	RWZ_INVALID_INFORMATION;
					}

					#ifdef _LOG_IN_FILE
						RW_DEBUG  << "[" <<ConvertToMB (szParam )<< "]\t"   << flush;
					#endif
					
				}
				else
				{
 					//
					//  This condition can happen if information is not found in the Resource
					//  If the function  entres this block the it is necessary to verify the
					//  the resource string in the table mapping
					//
					return 	RWZ_INTERNAL_ERROR;

				}
			}

			if(szParam)
			{
				(*sRegWizInfoTbl[i].m_fp)(szParam,szParam,hIns); // Invoke processing Function
				//PadWithBlanks(szParam,szRet,sRegWizInfoTbl[i].m_iLen); // Add balnks
			}

			//TxferBuf.AppendToBuffer(szRet,RW_WITH_URL); with padded
			TxferBuf.AppendToBuffer(szParam,RW_WITH_URL);
			//
			//
			// Skip Name key seperator for the last entry
			if(i!= MAX_TBL_ENTRIES-1)
				TxferBuf.AppendToBuffer(NAME_SEPERATOR);

		 }// end of for loop
 	}

	if(TxferBuf.IsValidBuffer())
	{

		iRetValue=RWZ_BUFFER_SIZE_INSUFFICIENT;
	}
	
	return iRetValue;

}


DWORD OemTransmitBuffer(HINSTANCE hIns,char *sztxBuffer,DWORD *nInitialSize)
{	
	BOOL bValueExceeded = FALSE;
	
	if(bOemDllLoaded == TRUE)
	{
		DWORD nCount,nLen,nCurrentLen = 0;
		HKEY hOemKey;
			
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\n OEM: Inside OemTransmitBuffer" << flush;
		#endif
		
		GetRootOfRegWizRegistry(hIns, &hOemKey);

		OEMDataCount	pOEMDataCount;

		pOEMDataCount = (OEMDataCount) GetProcAddress(hOemDll, "OEMDataCount");
		if (pOEMDataCount == NULL)
		{
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n OEM: OEMDataCount Getproc Error" << flush;
			#endif
			return RWZ_INTERNAL_ERROR;
		}
		
		nCount = (DWORD)pOEMDataCount();
		
		if(nCount > 25)
		{
			nCount = 25;
		}

		for( DWORD index = 1; index <= nCount; index++	)
		{
			_TCHAR szOEMValueName[64];
			_TCHAR szOEMBase[64];
			char szBuffer[1024];
			BOOL   bIsUnicode;
			BYTE lpValue[256] ;
			_TCHAR szValue[256];
		
			LoadString(hIns,IDS_OEMBASEKEY,szOEMBase,64);
		
			_stprintf(szOEMValueName,_T("%s_%i"),szOEMBase,index);

			#ifdef _UNICODE
			  _mbscpy((unsigned char *)szBuffer,(const unsigned char *)ConvertToMB(szOEMValueName));
			#else
			  _tcscpy(szBuffer,szOEMValueName);
			#endif
			
			
			OEMGetData	pOEMGetData;

			pOEMGetData = (OEMGetData) GetProcAddress(hOemDll, "OEMGetData");
			if (pOEMGetData == NULL)
			{
				#ifdef _LOG_IN_FILE
					RW_DEBUG << "\n OEM: OEMGetData Getproc Error"<< flush;
				#endif
				return RWZ_INTERNAL_ERROR;
			}

            nLen = sizeof(lpValue);

			pOEMGetData((WORD)index,&bIsUnicode,lpValue,(WORD)nLen);

			#ifdef _UNICODE
				if(!bIsUnicode)
				{
				  MultiByteToWideChar(CP_ACP, 0, (LPCSTR)lpValue, -1, (LPTSTR)szValue, 256);
				}
				else
				{
					_tcscpy((LPTSTR)szValue,(LPCTSTR)lpValue);
				}
			#else
				if(bIsUnicode)
				{
				  WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)lpValue, -1, (LPTSTR)szValue, 256, NULL, NULL);
				}
				else
				{
					_tcscpy((LPTSTR)szValue,(LPCTSTR)lpValue);
				}
			#endif	
			
			if(	_tcscmp((LPCTSTR)szValue,_T("")))
			{
				nLen = strlen("&");
				if( nCurrentLen + nLen >= *nInitialSize )
				{
					bValueExceeded = TRUE;
			 	}
				else
				{
					strcat(sztxBuffer,"&");
				}
				nCurrentLen +=  nLen;

				nLen = URLEncodeLen(szBuffer);
				if( nCurrentLen + nLen >= *nInitialSize )
				{
					bValueExceeded = TRUE;
			 	}
				else
				{
					URLEncode(sztxBuffer+nCurrentLen,szBuffer);
				}

				nCurrentLen +=  nLen-1;
		
				RegSetValueEx(hOemKey,szOEMValueName,NULL,REG_SZ,(CONST BYTE *)szValue,_tcslen((LPCTSTR)szValue));
				
				if(bIsUnicode)
				{
					_mbscpy((unsigned char *)szBuffer,(unsigned char *)ConvertToMB((TCHAR *)lpValue));
				}
				else
				{
					_mbscpy((unsigned char *)szBuffer,(unsigned char *)lpValue);
				}

				#ifdef _LOG_IN_FILE			
		 		 RW_DEBUG << "\n OEM " << index << "\t"<< ConvertToMB(szOEMValueName)<< "\t"
										<< szBuffer <<flush;
				#endif
				
				nLen = strlen("=");
				if( nCurrentLen + nLen >= *nInitialSize )
				{
					bValueExceeded = TRUE;
			 	}
				else
				{
					strcat(sztxBuffer,"=");
				}
				nCurrentLen +=  nLen;

				
				nLen = URLEncodeLen(szBuffer);
				if( nCurrentLen + nLen >= *nInitialSize )
				{
					#ifdef _LOG_IN_FILE
						RW_DEBUG << "\n OEM:Buffer value Exceeded" << flush;
						RW_DEBUG << "\n OEM:Current Length:" << nCurrentLen << flush;
						RW_DEBUG << "\n OEM:Length of present value:" << nLen << flush;
						RW_DEBUG << "\n OEM:Initial Size:" << *nInitialSize << flush;
					#endif
					bValueExceeded = TRUE;
			 	}
				else
				{
					URLEncode(sztxBuffer+nCurrentLen,szBuffer);
				}

				nCurrentLen +=  nLen-1;
			}				
		}
		*nInitialSize = nCurrentLen;
		if(bValueExceeded )
		{
			return RWZ_BUFFER_SIZE_INSUFFICIENT;
		}
		else
		{
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n OEM: OemTransmitBuffer Successful" << flush;
			#endif
			return RWZ_NOERROR;
		}
	}
	else
	{
		*nInitialSize = 0;
	}

	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n OEM: OemTransmitBuffer Successful" << flush;
	#endif

	return RWZ_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizpost\connect.cpp ===
//#define STRICT
//   Include Files
//
#include <tchar.h>
#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
//#include <wininet.h>
#include  <ATKInternet.h>

#include "rwpost.h"
#include "rw_common.h"

#ifdef _DEBUG
#include <iostream.h>
#endif



static void _stdcall  myCallback(
    IN HINTERNET hInternet,
    IN DWORD_PTR dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation OPTIONAL,
    IN DWORD dwStatusInformationLength
	);

//
// returns
// #define  RWZ_SITE_CONNECTED   1
// #define  RWZ_FAIL_TOCONNECTTOSITE  0
// #define  RWZ_SITE_REQUIRES_AUTHENTICATION 2
//
DWORD   ChkSiteAvailability( HWND hwndProxyParent, LPCTSTR szIISServer,DWORD   dwTimeOut,LPTSTR szProxyServer ,LPTSTR	szUserName,
				LPTSTR  szPassword)
				
{
	DWORD						dwRet ;
	DWORD						dwLen=1024;
	DWORD						dwAccessType ;
	HANDLE						hEvent;		
	HINTERNET					hSession;
	HINTERNET					hConnect;
	HINTERNET					hHttpFile;
	INTERNET_STATUS_CALLBACK	hI;
	char  bufQuery[32]="" ;

	DWORD dwbufQuery;
	DWORD dwLengthBufQuery;
	BOOL bQuery;

	// Date : 2/4/98
	// The below var are added for incorporatinf IE Auth Dlg
	// We are changing the Connectivity Check Via Proxy using
	// INTERNET_OPEN_PRECONFIG
	DWORD	dwProxyAuthError; // Store error returned by InternetErrorDlg
	LPTSTR  pUserName;
	LPTSTR  pPassword;
	LPTSTR  pProxyServerName;


	
	pUserName		 =_T("");
	pPassword		 =_T("");
	pProxyServerName =NULL;
	

	if(_tcscmp(szProxyServer,_T(""))){
		dwAccessType = INTERNET_OPEN_TYPE_PRECONFIG;
	}else{
		dwAccessType = INTERNET_OPEN_TYPE_DIRECT;
	}

	#ifdef _DEBUG
		RW_DEBUG << "\nServer   is :" << ConvertToANSIString(szIISServer) <<"\n" <<flush;
		RW_DEBUG << "\nTimeout  is :" << dwTimeOut <<"\n" <<flush;
		if(_tcscmp(szProxyServer,_T(""))){
			RW_DEBUG << "Proxy    is :" << ConvertToANSIString(szProxyServer) <<"\n" <<flush;
		}else{
			RW_DEBUG << "Proxy    is : NULL" <<"\n" <<flush;
		}
	#endif
	
	hSession = ATK_InternetOpen	(	_T("Registration Wizard"),
										dwAccessType,
						                pProxyServerName,
										NULL, // List of Addesss to ByPass
										INTERNET_FLAG_ASYNC
				   					);

	if (hSession == NULL){
		dwRet = RWZ_FAIL_TOCONNECTTOSITE;
		#ifdef _DEBUG
			RW_DEBUG << "InternetOpen Failed\n" << flush;
		#endif
		return dwRet;
	}
    hConnect = ATK_InternetConnect(	hSession,
									szIISServer,
									INTERNET_INVALID_PORT_NUMBER,
									pUserName,
									pPassword,
									INTERNET_SERVICE_HTTP,
									0,
									1
								   );
	if(hConnect == NULL){
		::InternetCloseHandle(hSession);
		#ifdef _DEBUG
		RW_DEBUG << "InternetConnect Failed\n" << flush;
		#endif
		dwRet = RWZ_FAIL_TOCONNECTTOSITE;
		return dwRet;
	}
	hEvent		= CreateEvent(NULL, FALSE,FALSE,_T("HTTPConnect"));
	hHttpFile	= ATK_HttpOpenRequest(	hConnect,
										_T("GET"),
										_T("/register.asp"),	
										HTTP_VERSION,
										NULL,
										0,
										INTERNET_FLAG_DONT_CACHE,
										(DWORD_PTR)hEvent
										);
	if (hHttpFile == NULL){
	#ifdef _DEBUG
			RW_DEBUG << "HttpOpenRequest Failed\n" << flush;
	#endif
		dwRet =  RWZ_FAIL_TOCONNECTTOSITE;
		CloseHandle(hEvent);
		::InternetCloseHandle(hConnect);
		::InternetCloseHandle(hSession);
		return dwRet;
	}
	//
	// Http Open is Success so continue further
	hI = InternetSetStatusCallback(hHttpFile,myCallback);
	BOOL bSendRequest = ATK_HttpSendRequest(hHttpFile, NULL, 0, 0, 0);
	DWORD dwWaitStatus = WaitForSingleObject(hEvent,dwTimeOut) ;
	// Time out Error
	if( dwWaitStatus == WAIT_TIMEOUT ){
		#ifdef _DEBUG
		RW_DEBUG << "Timeout Happened\n" << flush;
		#endif
		RW_DEBUG << "Timeout Happened\n" << flush;
		dwRet = RWZ_FAIL_TOCONNECTTOSITE;
		goto FinishFn;
	}
	if(dwWaitStatus == WAIT_FAILED){
	#ifdef _DEBUG
		RW_DEBUG << "WAIT_FAILED returned from WaitForSingleObject\n" << flush;
	#endif
		dwRet = RWZ_FAIL_TOCONNECTTOSITE;
		goto FinishFn;
	}

	dwLengthBufQuery = sizeof (dwbufQuery);
	//DWORD dwLengthBufQuery = sizeof ( bufQuery);
	bQuery = ATK_HttpQueryInfo(	hHttpFile,
										HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
										//HTTP_QUERY_CONTENT_DESCRIPTION ,
										//HTTP_QUERY_CONTENT_LENGTH ,
										&dwbufQuery,
										//bufQuery ,
				                        &dwLengthBufQuery,
										NULL) ;
	RW_DEBUG << "\nChecking Connection  To Site  via Proxy Returns[" << dwbufQuery << "]" <<flush;
	switch(dwbufQuery) {
		case HTTP_STATUS_OK:
		case HTTP_STATUS_SERVICE_UNAVAIL:
		dwRet = RWZ_SITE_CONNECTED;
		break;
		case HTTP_STATUS_PROXY_AUTH_REQ:
		// Invoking the IE Proxy Server Authentication Dialog
				dwProxyAuthError = 	InternetErrorDlg(hwndProxyParent,hHttpFile,
				ERROR_INTERNET_INCORRECT_PASSWORD,
				FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS,
				NULL);
				RW_DEBUG << "\nInetErrorDialog REturns " << dwProxyAuthError << flush;
				dwRet = RWZ_SITE_REQUIRES_AUTHENTICATION;
				//
				// We are not checking  for the return value because
				// connection has to be reestablished to really check
				// the info provided is valid
				/**
				02/07/98
				switch (dwProxyAuthError) {
					case ERROR_SUCCESS:
						dwRet = RWZ_SITE_CONNECTED;
						break;
					case ERROR_CANCELLED :
					case ERROR_INTERNET_FORCE_RETRY:
						dwRet = RWZ_SITE_REQUIRES_AUTHENTICATION;
						default:
						break;
					}
					**/
			break; // End of Proxy Auth
		case 0:
		case HTTP_STATUS_SERVER_ERROR:
			dwRet = RWZ_FAIL_TOCONNECTTOSITE;
			RW_DEBUG << "\n Problem in Proxy Server With connection Via Proxy " << dwbufQuery << flush;
			break;
		default:
		dwRet = RWZ_SITE_CONNECTED;
		break;	
	}			

FinishFn :
	CloseHandle(hEvent);
	::InternetCloseHandle(hHttpFile);
	::InternetCloseHandle(hConnect);
	::InternetCloseHandle(hSession);
	return dwRet;
}

void _stdcall myCallback(
						    IN HINTERNET hInternet,
						    IN DWORD_PTR dwContext,
						    IN DWORD dwInternetStatus,
						    IN LPVOID lpvStatusInformation OPTIONAL,
						    IN DWORD dwStatusInformationLength
						)
{

switch(dwInternetStatus)
	{
	case INTERNET_STATUS_RESOLVING_NAME :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: RESOLVING_NAME\n" << flush;
#endif //_DEBUG
		 break;
	case INTERNET_STATUS_NAME_RESOLVED :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_NAME_RESOLVED\n" << flush;
#endif //_DEBUG
		 break;

	case INTERNET_STATUS_CONNECTING_TO_SERVER :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_CONNECTING_TO_SERVER\n" << flush;
#endif //_DEBUG
		 break;

	case INTERNET_STATUS_CONNECTED_TO_SERVER :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_CONNECTED_TO_SERVER\n" << flush;
#endif //_DEBUG
		 //::InternetCloseHandle(hInternet);
 		 break;

	case INTERNET_STATUS_SENDING_REQUEST :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_SENDING_REQUEST\n" << flush;
#endif //_DEBUG
		 break;

	case INTERNET_STATUS_REQUEST_SENT :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_REQUEST_SENT\n" << flush;
#endif //_DEBUG
		 break;

	case INTERNET_STATUS_RECEIVING_RESPONSE :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_RECEIVING_RESPONSE\n" << flush;
#endif //_DEBUG
		 break;

	case INTERNET_STATUS_RESPONSE_RECEIVED :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_RESPONSE_RECEIVED\n" << flush;
#endif //_DEBUG
		 break;

	case INTERNET_STATUS_REDIRECT :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_REDIRECT\n" << flush;
#endif //_DEBUG
		 break;

	case INTERNET_STATUS_CLOSING_CONNECTION :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_CLOSING_CONNECTION\n" << flush;
#endif //_DEBUG
		 break;

	case INTERNET_STATUS_CONNECTION_CLOSED :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_CONNECTION_CLOSED\n" << flush;
#endif //_DEBUG
		 break;
	case INTERNET_STATUS_HANDLE_CREATED :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_HANDLE_CREATED\n" << flush;
#endif //_DEBUG
		 break;
	case INTERNET_STATUS_REQUEST_COMPLETE :

#ifdef _DEBUG
		 RW_DEBUG << "\nCallback: INTERNET_STATUS_REQUEST_COMPLETE\n\n" << flush;

		 INTERNET_ASYNC_RESULT *x;
		 x = (INTERNET_ASYNC_RESULT *)lpvStatusInformation;
		 if(x->dwError == ERROR_SUCCESS)
		 {
			RW_DEBUG << "\nERROR_SUCCESS\n" << flush;
		 }
		 else
		 {
			RW_DEBUG << "\nERROR \ndwResult: " << (DWORD)x->dwResult <<flush;
		 }

		 if(dwStatusInformationLength == ERROR_INTERNET_EXTENDED_ERROR)
		 {
			RW_DEBUG << "\n-NO EXTENDED_ERROR\n" << flush;
		 }
			DWORD dwError;
			DWORD dwErrorLen;
			_TCHAR szErrorInfo[256];	
			dwErrorLen = 256;
			
			ATK_InternetGetLastResponseInfo(&dwError,szErrorInfo,&dwErrorLen) ;
			RW_DEBUG << "\nErrorNo:" << dwError ;
			RW_DEBUG << "\nErrorInfo:"<<szErrorInfo<<flush;
			RW_DEBUG << "\n\n" << flush;
#endif //_DEBUG
			
		 SetEvent((HANDLE)dwContext);
		 break;
	case INTERNET_STATUS_HANDLE_CLOSING :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_HANDLE_CLOSING\n" << flush;
#endif //_DEBUG
		 SetEvent((HANDLE)dwContext);
		 break;
#ifdef _DEBUG
	default :
		 RW_DEBUG <<"\n Callback : default " << flush;
#endif //_DEBUG

	}
}

#if  0
void main(int argc , char ** argv)
{

	if(argc < 2 )
	{
		RW_DEBUG << "\n\n\nThe Executable Requires the following parameters : \n" << endl;
		RW_DEBUG << " \t\tServer Name \n\t\tTimeout value \n\t\tProxyServer name\n\t\tUserName \n\t\tPassword\n\n" << endl;
		RW_DEBUG << "Following Parameters are mandatory\n\t\tServer Name \n\t\tTimeout value \n" << endl;
		return;
	}
	BOOL bRet = ChkSiteAvailability(	argv[1],atol(argv[2]),
			argv[3],argv[4],argv[5]	);

	if(bRet == TRUE)
	{
		RW_DEBUG << "Returned TRUE" << flush;
	}
	else
	{
		RW_DEBUG << "Returned FALSE" << flush;
	}

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizpost\icw.h ===
#ifndef __ICW_h__
#define __ICW_h__
/**************************************************************************

   File:          icw.h
   
   Description:   

**************************************************************************/
typedef HRESULT (WINAPI *INETGETPROXY)(LPBOOL lpfEnable, LPSTR lpszServer, DWORD cbServer, LPSTR lpszOverride, DWORD cbOverride);
typedef HRESULT (WINAPI *INETCONFIGSYSTEM) ( HWND hWndParent, DWORD dwfOptions, LPBOOL lpfNeedsRestart);



#ifdef __cplusplus
extern "C" 
{
#endif

	BOOL ICWGetProxy(PTCHAR szProxy, DWORD dwBufferLength);

#ifdef __cplusplus
}
#endif	

#endif	// __ICW_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizpost\atk_inet.cpp ===
//  File	 : ATK_INET.CPP
//  Author   : Suresh Krishnan 
//  Date     : 08/05/97
//  Wrapper for INetCFG.DLL exported functions
//  related  function declarations
//
//

#include <windows.h>
#include <tchar.h>
#include <winnt.h>
#include <wininet.h>
#include <stdio.h>
#include "rw_common.h"






typedef HRESULT (WINAPI *INETGETPROXY)(LPBOOL lpfEnable, LPSTR lpszServer, DWORD cbServer, LPSTR lpszOverride, DWORD cbOverride);
typedef HRESULT (WINAPI *INETCONFIGSYSTEM) ( HWND hWndParent, DWORD dwfOptions, LPBOOL lpfNeedsRestart);
typedef HRESULT (WINAPI *INETGETAUTODIAL) (LPBOOL lpEnable, LPSTR lpszEntryName, DWORD cbEntryName);
typedef HRESULT (WINAPI *INETSETAUTODIAL) (BOOL fEnable, LPCSTR lpszEntryName);

#define ERROR_IN_SET       -1
#define INET_DLL_FAILURE   -1

static HINSTANCE  hINetCfg= NULL;
static INETGETPROXY	    fpGetProxy=NULL;
static INETCONFIGSYSTEM fpGetConfigSystem=NULL;
static INETGETAUTODIAL  fpGetAutoDial=NULL;
static INETSETAUTODIAL  fpSetAutoDial=NULL;
static INETCONFIGSYSTEM fpInetConfig =NULL;  

typedef struct {
	char szActiveConnection[256];
	BOOL fStatus;
    enum ISPStateFlag {NotValidState,ValidState } iState ;
} ISPState; 

static ISPState  gIspState = { "",
						0,
						ISPState::NotValidState};




int INetCfgSetup()
{
	if(hINetCfg) {
		return 1;
	}
	hINetCfg = LoadLibrary( _T("INETCFG.DLL") );  //  Load INetCfg.DLL and store globally
	if( !hINetCfg )
	{                                   
	  //  return if the DLL can not loaded
	  //
	  return 0;
	}
	


	fpGetProxy = (INETGETPROXY) GetProcAddress(hINetCfg,"InetGetProxy");
	fpGetAutoDial = ( INETGETAUTODIAL) GetProcAddress(hINetCfg, "InetGetAutodial");
	fpSetAutoDial = ( INETSETAUTODIAL) GetProcAddress(hINetCfg, "InetSetAutodial");
	fpInetConfig = (INETCONFIGSYSTEM) GetProcAddress(hINetCfg, "InetConfigSystem");
	return 1;
	
}

HRESULT ATK_InetGetAutoDial(LPBOOL lpEnable, LPSTR lpszEntryName, DWORD cbEntryName)
{
	if(INetCfgSetup()) {
	return (*fpGetAutoDial)(lpEnable, lpszEntryName, cbEntryName);
	}else {
		return INET_DLL_FAILURE;
	}
}

HRESULT ATK_InetSetAutoDial(BOOL fEnable, LPCSTR lpszEntryName)
{
	if(INetCfgSetup()) {
		return (*fpSetAutoDial)(fEnable, lpszEntryName);
	}else{
		return INET_DLL_FAILURE;
	}
}

HRESULT ATK_InetConfigSystem( HWND hwndParent,
							 DWORD dwfOptions,
							 LPBOOL lpfNeedsRestart)
{
	if(INetCfgSetup()) {
		return (*fpInetConfig)( hwndParent,dwfOptions, 
			lpfNeedsRestart);
	}else{
		return INET_DLL_FAILURE;
	}

}

HRESULT ATK_InetGetProxy( LPBOOL lpfEnable,
						  LPSTR  lpszServer,
						  DWORD  cbServer,
						  LPSTR  lpszOverride,
						  DWORD  cbOverride)
{
	if(INetCfgSetup()) {
		return (*fpGetProxy)( lpfEnable,
						  lpszServer,
						  cbServer,
						  lpszOverride,
						  cbOverride);
	}else{
		return INET_DLL_FAILURE;
	}


}



void GetAutoDialConfiguration()
{

	DWORD dwError;
	DWORD dwSz=256;
	HRESULT  hr;
	ISPState *pS= &gIspState; 
	hr = ATK_InetGetAutoDial(&pS->fStatus,
		pS->szActiveConnection,
		dwSz);
	if(hr) {
		dwError = GetLastError();

		RW_DEBUG << "\nGet AutoDial :***Error " <<hr  << ":"<<  dwError << flush;
		pS->iState = ISPState::NotValidState;
	}else {
		pS->iState = ISPState::ValidState;
	}
	
}

DWORD SetAutoDialStateThread(void *vp)
{
	ISPState  *pState;
	pState = (ISPState *) vp;
	ATK_InetSetAutoDial(pState->fStatus,
		pState->szActiveConnection);
	RW_DEBUG <<"\nSet Auto Dial Configuration" << pState->szActiveConnection << " =>" << pState->fStatus << flush;
	ExitThread(0);
	return 0;

}

//
//  This function calls the ICW function InetSetAutoDial()
//  this function waits for the above function to be over by 10 seconds 
//  if it does not complete then it calls terminate thread and abondens the operation 
int ChangeInterNetAutoDial(ISPState *pStatus )
{
	int iReturn;
	DWORD dwTimeOut = 10*1000;
	DWORD dwCreationFlags=0; // Start without  CREATE_SUSPENDED 
	DWORD ThreadId;
	
	iReturn = NO_ERROR;

	HANDLE hParent = CreateThread(NULL, 
	0,
	(LPTHREAD_START_ROUTINE) SetAutoDialStateThread,
	(void *) pStatus,
	dwCreationFlags, 
	&ThreadId );
	iReturn = NO_ERROR;

	DWORD dwRet = WaitForSingleObject(hParent,
		dwTimeOut);
	switch(dwRet) {
	case WAIT_ABANDONED :
		break;
	case WAIT_OBJECT_0 :
		CloseHandle(hParent);
		break;
	case WAIT_TIMEOUT :
		//TerminateThread(hParent,0);
		iReturn = ERROR_IN_SET;
		break;
	default:
		break;
	}
	return iReturn;
	

}


int ResetAutoDialConfiguration()
{
	int iRet;
	iRet = NO_ERROR;
	if(gIspState.iState == ISPState::NotValidState ){
		//
		// Not alid So No need to Reset 
		return iRet;
	}
	return ChangeInterNetAutoDial(&gIspState);
}

int DisableAutoDial()
{
	ISPState  IspState = { "",
						0,
						ISPState::NotValidState};
	
	return ChangeInterNetAutoDial(&IspState);
}

void UnLoadInetCfgLib()
{
	if(hINetCfg){
		FreeLibrary(hINetCfg);  //  Load INetCfg.DLL and store globally
		hINetCfg = NULL;

	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizpost\dconv.h ===
/*
   File : DConv.H
   Header file for Data Conversion of  RegWiz Registry Information 

      

*/
#ifndef __DCONV__
#define __DCONV__

#ifdef __cplusplus
extern "C" 
{
#endif

int PrepareRegWizTxbuffer(HINSTANCE hIns, char *tcTxBuf, DWORD * pRetLen); 
DWORD OemTransmitBuffer(HINSTANCE hIns,char *sztxBuffer,DWORD * pRetLen);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizpost\ithread.h ===
#ifndef __InternetThread_h__
#define __InternetThread_h__

#include "ATKinternet.h"
//#include <tchar.h>



//  CInternetThread Class...manages worker thread which POSTS to 
//	Register.msn.com.
//
class CInternetThread
{
public:
   // Construction
   //
   CInternetThread();
   ~CInternetThread();



   // Re-initialized Internet functions. Used after changing access type.
   //
   void ResetSession();
      
   // Manage Buffer where HTML text is placed.
   //
	LPCSTR		GetBuffer()		{	return m_strBuffer; }
	void		SetBuffer(LPSTR strBuffer);
	void		SetBuffer(LPSTR strBuffer, DWORD dwLen);
	DWORD  PostData(HWND hWnd);

	void Initialize(HINSTANCE hIns)
	{
		m_hInstance = hIns;
		m_strIISServer = new TCHAR[256];
		m_strPath      = new TCHAR[256];
		m_UserName     = new TCHAR[256];
		m_Password     = new TCHAR[256];
		m_bPostWithSSL = TRUE;

		LoadString(m_hInstance, IDS_HTTP_SERVER,
			m_strIISServer, 255);
		LoadString(m_hInstance, IDS_HTTP_SERVER_PATH,
			m_strPath, 255);
		LoadString(m_hInstance, IDS_HTTP_USERNAME,
			m_UserName, 255);
		LoadString(m_hInstance, IDS_HTTP_PASSWORD, 
			m_Password, 255);
	}

	//
	//
	void SetHInstance ( HINSTANCE hIns) 
	{
			m_hInstance = hIns;
		//Initialize(hIns);
	}

	HINSTANCE GetHInstance ()
	{  
		return m_hInstance;
	}

	// Proxy Server name.
	//
	BOOL GetSystemProxyServer(  PCHAR szProxy, 
								DWORD dwBufferLength,
								int *ipProxyPort);
	// This gets proxy using ICW call 
	LPCTSTR GetProxyServer()	{	return m_strProxyServer; }
	void SetProxyServer(LPSTR strProxyServer, int iProxyPort);
	void GetSystemProxySettings( PCHAR szProxy, 
							   DWORD dwBufferLength);
	void SetSystemProxySettings( PCHAR szProxy ); 
   // HTTP Server name.
   //
	LPCTSTR GetIISServer()		{	return m_strIISServer; }
	void SetIISServer(LPTSTR strIISServer);

   // HTTP Server Path
   //
	LPCTSTR GetServerPath()		{	return m_strPath; }
	void SetServerPath(LPTSTR strPath);
	
	void SetSSLFlag(BOOL bFlag)	{	m_bPostWithSSL = bFlag;}
	
   // POST the Data in m_strBuffer into 
   //
   //DWORD  PostData(HWND hWnd);

   // Access Type: **** At present Not used  ***
   //
   //int	GetAccessTypeIndex();
   //void SetAccessTypeIndex(int index);

   //
   // General ICW DLL loading  related functions
   HINSTANCE LoadInetCfgDll();
   BOOL InstallModem(HWND hwnd);
   void UnLoadInetCfgDll(); 
//private:
   // Worker thread calls _PostDataWorker.
   static UINT PostDataThread(LPVOID pvThread) ;

   // This is where the actually work is done.
   UINT  _PostDataWorker(HWND hWnd);
   UINT	 GetBackEndResult(HINTERNET hConnect);


   LPTSTR	m_strIISServer;
   LPTSTR	m_strPath;
   LPTSTR	m_strProxyServer;
   DWORD	m_dwAccessType;
   BOOL		m_bPostWithSSL;

  
   LPSTR	 m_strBuffer;		// Buffer to be POSTed to Register.msn.com
   DWORD	 m_dwBufferLen;		// Buffer Len
   HINSTANCE m_hInstance;
   HINTERNET m_hSession;
   LPTSTR    m_UserName;
   LPTSTR    m_Password;
   HINSTANCE m_hICWDllInstance;
};

// Working Thread which does all the actually internet work.
//
UINT PostDataThread(LPVOID pvThreadData);
#endif 


// How to use this class
// 
//
////////// Check if connectivity to a an IIS exists //////////////////////
// i)  Call CInternetThread.SetProxyServer(szProxy) to set the Proxy if any exists.
// ii) Call CInternetThread.SetIISServer(szIISServer) to set the IP Address (URL)
//	   of the Internet Server.
// iii)Call CInternetThread.InternetConnectivityExists() which will return TRUE
//    if connectivity to the ISS server (szIISServer in 1) exists, else FALSE.
//
//
///////// Perform an HTTP Post to an IIS ////////////////////////////////
// i)  Call CInternetThread.SetProxyServer(szProxy) to set the Proxy if any exists.
// ii) Call CInternetThread.SetIISServer(szIISServer) to set the IP Address (URL)
//	   of the Internet Server.
// iii)Call CInternetThread.InternetConnectivityExists() which will return TRUE
//     if connectivity to the ISS (szIISServer in 1) exists, else FALSE.
// iv) Call CInternetThread.SetBuffer(szBuffer) to set the Data that has to be
//	   POSTed of the Internet Server.
// v)  Call CInternetThread.PostData() which will return TRUE, if the Data has been
//	   POSTed successfully to the IIS.
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizpost\phone.cpp ===
/*

	File : Phone.CPP
*/

#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <tchar.h>
#include <ATK_RAS.H>

#include "cntryinf.h"
#include "resource.h"
#include "phonebk.h"
#include "util.h"
#include "rw_common.h"


#define TYPE_SIGNUP_ANY			0x82
#define MASK_SIGNUP_ANY			0xB2

#define TYPE_REGULAR_USAGE		0x42
#define MASK_REGULAR_USAGE		0x73


#define MAX_BUFFER				1024 * 5
#define RAS_ENTRY_NAME			_T("REGWIZ")



//
//  This function expands and substitutes Environment variable
//  in input string
//
//
static void GetAbsolutePath( LPTSTR input,LPTSTR output)
	{
		if(_tcschr(input,_T('%')) == NULL) {
			_tcscpy(output,	input);
			return ;
		}

		if(input[0] == _T('%'))
		{
			LPTSTR token = _tcstok(input,_T("%"));
			if(token != NULL)
			{
				LPTSTR sztemp;
				sztemp = _tgetenv( token );
				if(sztemp != NULL)
				{
					_tcscpy(output ,sztemp);
				}
				token = _tcstok(NULL,_T("\0"));
				if(token != NULL)
				{
					_tcscat(output ,token);
				}
			}
		}
		else
		{
			LPTSTR token = _tcstok(input,_T("%"));
			if(token != NULL)
			{
				_tcscpy(output ,token);
				token = _tcstok(NULL,_T("%"));
				if(token != NULL)
				{
					LPTSTR sztemp;
					sztemp = _tgetenv( token );
					if(sztemp != NULL)
					{
						_tcscat(output ,sztemp);
					}
					token = _tcstok(NULL,_T("\0"));
					if(token != NULL)
					{
						_tcscat(output ,token);
					}
				}
			}
		}
		
		GetAbsolutePath(output,output);
	}




#define MAX_ALTERNATES     5
#define MAX_DUN_ENTRYNAME  256
class DUNFileProcess {
public :
	DUNFileProcess(HINSTANCE hIns, TCHAR *czFile);
	//~DUNFileProcess();
	DWORD CreateRasEntry( RASENTRY	*pRasEntry, // Pointer of the RASENTRY structre to be created
				    LPTSTR szUserName,  // User name of the ISP
				    LPTSTR szPassword); // Password for the ISP

	HINSTANCE m_hInstance;
	TCHAR     m_szDUNFile[MAX_PATH];
	TCHAR     m_szDunEntry[MAX_ALTERNATES][MAX_DUN_ENTRYNAME];
	TCHAR * GetDunFileRoot();
	TCHAR * GetFromResource(int iResId);

};

DUNFileProcess :: DUNFileProcess (HINSTANCE hIns, TCHAR *czFileName)
{
	m_hInstance = hIns;
	_tcscpy(m_szDUNFile,GetDunFileRoot());
	_tcscat(m_szDUNFile, _T("\\"));
	_tcscat(m_szDUNFile,czFileName);
	
		
}



//
// This gets the directory from where the ICWIP.DUN can be found
// The default is the C:\Progra~1\ICW-IN~1\\
//
TCHAR * DUNFileProcess :: GetDunFileRoot()
{
	HKEY    hKey;
	LONG  regStatus;
	TCHAR   czTemp[256];
	//TCHAR  uszRegKey[]="SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\ICWCONN1.EXE";
	//TCHAR  uszR[ ]= "Path";
	DWORD  dwInfoSize;
	static TCHAR  szDunRoot[256] = _T("c:\\Progra~1\\ICW-IN~1\\");

	dwInfoSize = 256;
	regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					GetFromResource(IDS_ICW_DIRECTORY_ENTRY),
					0,KEY_READ ,&hKey);
	if (regStatus == ERROR_SUCCESS) {
		// Get The Path
		dwInfoSize = MAX_PATH;
		RegQueryValueEx(hKey,
			GetFromResource(IDS_ICW_DIRECTORY_ENTRY_VALUE),
			NULL,0,
			(LPBYTE) czTemp,
			&dwInfoSize);
		GetAbsolutePath(czTemp,szDunRoot);
		size_t sLen = _tcslen(szDunRoot);
		szDunRoot[sLen-1] = _T('\0');
			
	}
	else {
		;
	}
	return szDunRoot;

}

TCHAR * DUNFileProcess ::GetFromResource(int iResId)
{
	
	
	static int iCount=0;
	if(iCount == MAX_ALTERNATES ) {
		iCount = 0;
	}
	LoadString(m_hInstance,iResId,m_szDunEntry[iCount],
		MAX_DUN_ENTRYNAME);
	
	return m_szDunEntry[iCount++];
}

void FillIpAddress1(_TCHAR *czStr, RASIPADDR * pRE )
{
	
	_TCHAR czTemp[4];
	int iCount=0;
	int iIndex=0;
	int Location =0;
	for(int Addr=0; Addr< 4; Addr++) {
		iCount = 0;
		for( ;czStr[iIndex] !=_T('.') && iCount <3;  )
		{
			czTemp[iCount] = czStr[iIndex];
			iCount += _tcslen( czTemp + iCount );
			iIndex += _tcslen( czStr + iIndex );

		}	
		iIndex += _tcslen( czStr + iIndex );
		czTemp[iCount] = _T('\0');
		
		switch(Addr) {
		case 0:
			pRE->a = (BYTE) _ttoi(czTemp);
			break;
		case 1:
			pRE->b = (BYTE) _ttoi(czTemp);
			break;
		case 2:
			pRE->c = (BYTE) _ttoi(czTemp);
			break;
		case 3:
			pRE->d = (BYTE) _ttoi(czTemp);
			break;
		default:
		break;
		}
	}


}


void FillIpAddress(_TCHAR *czStr, RASIPADDR * pRE )
{
	_TCHAR czTemp[4];
	int iCount=0;
	int iIndex=0;
	int Location =0;
	for(int Addr=0; Addr< 4; Addr++) {
		iCount = 0;
		for( ;czStr[iIndex] != _T('.') && iCount <3;  ) {
			czTemp[iCount++] =
				czStr[iIndex];
				iIndex++;

		}	
		iIndex++;
		czTemp[iCount] = _T('\0');
		switch(Addr) {
		case 0:
			pRE->a = (BYTE) _ttoi(czTemp);
			break;
		case 1:
			pRE->b = (BYTE) _ttoi(czTemp);
			break;
		case 2:
			pRE->c = (BYTE) _ttoi(czTemp);
			break;
		case 3:
			pRE->d = (BYTE) _ttoi(czTemp);
			break;
		default:
		break;
		}
	}


}






//
// Returns  1 if successful
//          0 failure
//
DWORD DUNFileProcess :: CreateRasEntry(
								   RASENTRY	*pRasEntry,
								   LPTSTR szUserName,
								   LPTSTR szPassword)
{
	TCHAR	szSection[MAX_PATH];
    TCHAR	szValue[MAX_PATH];
    TCHAR   szScript[MAX_PATH];
    TCHAR   szWinPath[MAX_PATH];
	DWORD   dwRead;

	BOOL	bRet= FALSE;

	pRasEntry->dwSize		 = sizeof(RASENTRY);

	pRasEntry->dwfOptions	 = RASEO_UseCountryAndAreaCodes |
							   RASEO_ModemLights;	
							


	// Framing
	//
	pRasEntry->dwFrameSize		  = 0;
	_tcscpy(pRasEntry->szScript, _T(""));

	// Auto-Dial
	//
	_tcscpy(pRasEntry->szAutodialDll, _T(""));
	_tcscpy(pRasEntry->szAutodialFunc, _T(""));

	// Device
	//
	_tcscpy(pRasEntry->szDeviceType, RASDT_Modem);
	// _tcscpy(pRasEntry->szDeviceName, GetModemDeviceInformation(m_hInstance));
	// The Modem entry will be created before creating  the Phone book entry

	// X.25
	//
	_tcscpy(pRasEntry->szX25PadType, _T(""));
	_tcscpy(pRasEntry->szX25Address, _T(""));
	_tcscpy(pRasEntry->szX25Facilities, _T(""));
	_tcscpy(pRasEntry->szX25UserData, _T(""));
	pRasEntry->dwChannels = 0;

	// Phone
	//
	_tcscpy(szSection,GetFromResource(IDS_DUN_PHONE_SECTION));
	
	// Area Code
    DWORD  dwAreaCode  = GetPrivateProfileInt (szSection,
		GetFromResource(IDS_DUN_PHONE_AREACODE),
		0,
		m_szDUNFile);
	_tprintf(pRasEntry->szAreaCode, "%d", dwAreaCode);
	
	// Country Code
	pRasEntry->dwCountryCode = GetPrivateProfileInt (szSection,
		GetFromResource(IDS_DUN_PHONE_COUNTRY),
		1, m_szDUNFile);
    RW_DEBUG <<"\n Country Code "  << pRasEntry->dwCountryCode;
	pRasEntry->dwCountryID = GetPrivateProfileInt (szSection, _T("Country_ID"), 1, m_szDUNFile);

    RW_DEBUG <<"\n Country ID "  << pRasEntry->dwCountryID;
	//
	GetPrivateProfileString (szSection,
		GetFromResource(IDS_DUN_PHONE_DIALAS),
		GetFromResource(IDS_DUN_VALUE_YES),
		szValue, sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);
	pRasEntry->dwAlternateOffset=0;

	// TODO : Set Phone No from  Phone Book
	_tcscpy(pRasEntry->szLocalPhoneNumber,_T(""));
	
	// Server
	//	

	// Framing Protocol
	_tcscpy(szSection,GetFromResource(IDS_DUN_SERVER_SECTION));
    GetPrivateProfileString (szSection,
		GetFromResource(IDS_DUN_SERVER_TYPE),
		GetFromResource(IDS_DUN_SERVER_TYPE_PPP), // PPP
		szValue, sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);

	if(!_tcsicmp(szValue,GetFromResource(IDS_DUN_SERVER_TYPE_PPP))) {
		pRasEntry->dwFramingProtocol  = RASFP_Ppp;
	}


	// SW Compression
    GetPrivateProfileString (szSection,GetFromResource(IDS_DUN_SERVER_SW_COMPRESS),
		GetFromResource(IDS_DUN_VALUE_YES),
		szValue, sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);

	if(!_tcsicmp(szValue,GetFromResource(IDS_DUN_VALUE_YES))) {
		pRasEntry->dwfOptions |=RASEO_SwCompression;
	}
	
	//	Negociate TCP		
    GetPrivateProfileString (szSection,
		GetFromResource(IDS_DUN_SERVER_TCPIP),
		GetFromResource(IDS_DUN_VALUE_YES),
		 szValue, sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);

	if(!_tcsicmp(szValue,GetFromResource(IDS_DUN_VALUE_YES))) {
		pRasEntry->dwfNetProtocols = RASNP_Ip;
	}

	// Disable LCP

    GetPrivateProfileString (szSection,
		GetFromResource(IDS_DUN_SERVER_LCP),
		GetFromResource(IDS_DUN_VALUE_YES),
		szValue, sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);
	if(!_tcsicmp(szValue,GetFromResource(IDS_DUN_VALUE_YES))) {
		pRasEntry->dwfOptions |=RASEO_DisableLcpExtensions;
	}


	// TCP/IP
	_tcscpy(szSection, GetFromResource(IDS_DUN_TCP_SECTION));
    GetPrivateProfileString (szSection,
		GetFromResource(IDS_DUN_TCP_IPADDRESS),
		GetFromResource(IDS_DUN_VALUE_NO),
		szValue, sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);

	if(!_tcsicmp(szValue,GetFromResource(IDS_DUN_VALUE_YES))) {
		pRasEntry->dwfOptions	 |=RASEO_SpecificIpAddr;
	}

    GetPrivateProfileString (szSection,
		GetFromResource(IDS_DUN_TCP_SERVERADDRESS),
		GetFromResource(IDS_DUN_VALUE_NO),
		szValue, sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);
	if(!_tcsicmp(szValue,GetFromResource(IDS_DUN_VALUE_YES))) {
		pRasEntry->dwfOptions	 |=RASEO_SpecificNameServers;
	}

    GetPrivateProfileString (szSection,
		GetFromResource(IDS_DUN_TCP_HEADERCOMPRESSION),
		GetFromResource(IDS_DUN_VALUE_NO),
		szValue, sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);
	if(!_tcsicmp(szValue,GetFromResource(IDS_DUN_VALUE_YES))) {
		pRasEntry->dwfOptions	 |=RASEO_IpHeaderCompression;
	}

    GetPrivateProfileString (szSection,
		GetFromResource(IDS_DUN_TCP_GATEWAY),
		GetFromResource(IDS_DUN_VALUE_NO),
		szValue, sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);
	if(!_tcsicmp(szValue,GetFromResource(IDS_DUN_VALUE_YES))) {
		pRasEntry->dwfOptions	 |=RASEO_RemoteDefaultGateway;
	}

	GetPrivateProfileString (szSection,
		GetFromResource(IDS_DUN_TCP_SERVERADDRESS),
		GetFromResource(IDS_DUN_VALUE_NO),
		szValue, sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);
	if(!_tcsicmp(szValue,GetFromResource(IDS_DUN_VALUE_YES))) {

		dwRead = GetPrivateProfileString (szSection,
			GetFromResource(IDS_DUN_TCP_DNS),
			_T("0"), szValue,
			sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);
		if( dwRead >2) {
			FillIpAddress(szValue,&pRasEntry->ipaddrDns);
		}
		//
		//  Get The Secondary Address
		dwRead = GetPrivateProfileString (szSection,
				GetFromResource(IDS_DUN_TCP_DNS_ALT),
				_T("0"), szValue,
			sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);
		if(dwRead > 2) {
			FillIpAddress(szValue,&pRasEntry->ipaddrDnsAlt);
		}
		
	}

	// User Section
	_tcscpy(szSection,
		GetFromResource(IDS_DUN_USER_SECTION));
	GetPrivateProfileString (szSection,
	GetFromResource(IDS_DUN_USER_NAME),
		_T(""), szUserName, MAX_PATH, m_szDUNFile);
	GetPrivateProfileString (szSection,
		GetFromResource(IDS_DUN_USER_PASSWORD),
		_T(""), szPassword, MAX_PATH, m_szDUNFile);



	// Scripting
	_tcscpy(szSection, _T("Scripting"));
    GetPrivateProfileString (szSection, _T("Name"), _T(""), szScript, MAX_PATH, m_szDUNFile);


    if ( lstrcmpi(szScript, _T("") ) != 0 ) {
       if (!GetWindowsDirectory(szWinPath, MAX_PATH) )
       {
          #ifdef _LOG_IN_FILE
            RW_DEBUG << "\n CreateRasEntry : Error 1- Fail to Get Windows Directory" << flush;
          #endif
          return TRUE;    
       }
       //APPCOMPAT:Needs specail procesing for win9x
       if ( _T('\\') != szWinPath[_tcslen(szWinPath)-1])
       {
           lstrcat(szWinPath,_T("\\"));
       }
       lstrcat(szWinPath,szScript);
       lstrcpy(szScript,szWinPath);
       if (_tcslen(szScript) >=MAX_PATH)
       {
           #ifdef _LOG_IN_FILE
			  RW_DEBUG << "\n CreateRasEntry : Error 1- Script File Path too long" << flush;
		   #endif
           return TRUE;    
       }

    }

    lstrcpy(pRasEntry->szScript,szScript);    

	// Script_File
	TCHAR	szScriptBuffer[MAX_BUFFER];
	_tcscpy(szSection, _T("Script_File"));
    GetPrivateProfileString (szSection, NULL, _T(""), szScriptBuffer, MAX_BUFFER, m_szDUNFile);
	


	
	// Create the .SCP File and Dump the script data
	PTSTR	pKey=szScriptBuffer;
	HANDLE fileHandle = CreateFile(pRasEntry->szScript, GENERIC_WRITE,0, 0, CREATE_ALWAYS, 0, 0);
	if (fileHandle == INVALID_HANDLE_VALUE)
	{
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\n Load DUN Strings : Error 1- Fail to create Script File " << flush;
		#endif
		return TRUE;
	}
	

	BOOL bWrite = TRUE;
	DWORD numWrite;
	while (*pKey && bWrite)
	{
        
		GetPrivateProfileString (szSection, pKey , _T(""), szValue, sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);
        _tcscat(szValue, _T("\x0d\x0a"));
#ifdef _UNICODE 
        char *czP;		
        czP = ConvertToANSIString(szValue);
        bWrite = WriteFile(fileHandle, czP, strlen(czP)*sizeof(char), &numWrite, 0);
#else
        bWrite = WriteFile(fileHandle, szValue, _tcslen(szValue)*sizeof(_TCHAR), &numWrite, 0);
#endif
		while (*pKey)
		{
			pKey = _tcsinc(pKey);
		}
		pKey = _tcsinc(pKey);
	}
	CloseHandle(fileHandle);
	return TRUE;
}	

int   GetDeaultCfgAreaCode(HINSTANCE hInstance, DWORD *CountryCode, DWORD *AreaCode)
{
	HKEY    hKey;
	TCHAR   szTel[256] = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations");
	TCHAR   szCI [48] = _T("CurrentID");
	TCHAR   szNE [48]  = _T("NumEntries");
	TCHAR   szID  [48] = _T("ID");
	TCHAR   szCountryReg[48] = _T("Country");
	_TCHAR  szAreaCodeReg[48];
	_TCHAR  czLastStr[48];
	_TCHAR  czNewKey[256];
	_TCHAR  szAreaCode[48];
	DWORD   dwCurrentId;
	DWORD   dwNumEntries;
	DWORD   dwId;

	LONG	lStatus;
	DWORD dwInfoSize = 48;
	DWORD   dwAreaCode = 0;
	int    iRetValue;
	iRetValue =0;
	*CountryCode=1;  // Default USA
	*AreaCode = 1; // Default Area Code

	LoadString(hInstance,IDS_TELEPHONE_LOC,szTel,256);
	LoadString(hInstance,IDS_TELEPHONE_CID,szCI,48);
	LoadString(hInstance,IDS_TELEPHONE_NENT,szNE,48);
	LoadString(hInstance,IDS_TELEPHONE_ID,szID,48);
	LoadString(hInstance,IDS_TELEPHONE_COUNTRY,szCountryReg,48);

	lStatus= RegOpenKeyEx(HKEY_LOCAL_MACHINE,szTel,0,KEY_READ,&hKey);
	if (lStatus == ERROR_SUCCESS)
	{
		//  Get Index
		//
		dwInfoSize = sizeof(dwCurrentId);
		lStatus = RegQueryValueEx(hKey,szCI,NULL,0,(  LPBYTE )&dwCurrentId,&dwInfoSize);
		if( lStatus !=  ERROR_SUCCESS)
		{
			RegCloseKey(hKey);
			return iRetValue;
		}
		//
		/*dwInfoSize = sizeof(dwNumEntries);
		lStatus = RegQueryValueEx(hKey,szNE,NULL,0,(  LPBYTE )&dwNumEntries,&dwInfoSize);
		if( lStatus !=  ERROR_SUCCESS)
		{
			RegCloseKey(hKey);
			return iRetValue;
		}*/
		
		RegCloseKey(hKey);

	}

	//
	// Now Contine to scan
	//for (int iCount =0; iCount < dwNumEntries; iCount ++ )
		
	_stprintf(czLastStr,_T("\\Location%d"),dwCurrentId);
	_tcscpy(czNewKey,szTel);
	_tcscat(czNewKey,czLastStr);

	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n RegKey Location:"<< czNewKey << flush;
	#endif

	lStatus= RegOpenKeyEx(HKEY_LOCAL_MACHINE,czNewKey,0,KEY_READ,&hKey);

	if (lStatus == ERROR_SUCCESS)
	{
			dwInfoSize = sizeof(dwCurrentId);
/*			lStatus = RegQueryValueEx(hKey,szID,NULL,0,(  LPBYTE )&dwId,&dwInfoSize);
			if( lStatus ==  ERROR_SUCCESS)
				if(dwId == dwCurrentId)
					dwInfoSize = sizeof(dwCurrentId);; */
			lStatus = RegQueryValueEx(hKey,szCountryReg,NULL,0,(  LPBYTE )CountryCode,&dwInfoSize);

			LoadString(hInstance,IDS_TAPI_AREA_CODE,szAreaCodeReg,48);
			dwInfoSize = 48;
			lStatus = RegQueryValueEx(hKey,szAreaCodeReg,NULL,0,(  LPBYTE )szAreaCode,&dwInfoSize);
			if( lStatus ==  ERROR_SUCCESS)
			{
				*AreaCode = _ttol(szAreaCode);
			}

			RegCloseKey(hKey);
			return dwAreaCode;
	}
	return iRetValue;
}



//
//  returns 0 if Error
//          1 if Succesful
//
//
DWORD  GetRASEntries(HINSTANCE hInstance,
					 RASENTRY *pRasEntry,
					 LPTSTR szUserName,
					 LPTSTR szPassword)
{
	HKEY    hKey;
	DWORD_PTR	dwPhoneID;
	DWORD	dwCountry;
	DWORD   dwCountryCode;
	DWORD   dwAreaCode = 0;
	TCHAR   szResEntry[256];

	
	dwPhoneID = 0;

	//LoadString(hInstance,IDS_PHONEBOOK_ENTRY,szResEntry,255);
	//
	//  Presently this string is not passed as the Phone bokk is
	//  still not a UNICODE version    CXG 6-0497
	//

	HRESULT hr	= PhoneBookLoad("MSICW", &dwPhoneID);
	if (!dwPhoneID)
	{
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\n Fn: GetRasEntries : Error-1 Unable to locate MSN.ISP " << flush;
		#endif
		return FALSE;
	}
	//if (!GetTapiCurrentCountry(m_hInst, &dwCountry)) { on6/4/97
	if (!GetTapiCurrentCountry(hInstance, &dwCountry))
	{

		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\n Fn: GetRasEntries : Error-2  Unable To Get Country Code " << flush;
		#endif
		return FALSE ;
	}
	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n Fn: GetRasEntries : Get Current Country " <<  dwCountry << flush;
	#endif

	GetDeaultCfgAreaCode(hInstance,&dwCountryCode,&dwAreaCode);

	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n Fn: GetRasEntries : GetDeaultCfgAreaCode  Country " <<  dwCountryCode << "Area " << dwAreaCode << flush;
		RW_DEBUG << "\n Country ID: " << dwCountry << flush;
	#endif

	SUGGESTINFO SuggestInfo;
	SuggestInfo.dwCountryID = dwCountry;
	SuggestInfo.bMask	= MASK_SIGNUP_ANY;
	SuggestInfo.fType	= TYPE_SIGNUP_ANY;
	SuggestInfo.wAreaCode	= dwAreaCode;
	SuggestInfo.wNumber  	= 1;
	
	int nIndex = PhoneBookSuggestNumbers(dwPhoneID, &SuggestInfo);
	if (nIndex != 0)
	{
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\n Fn: GetRasEntries : Error-3  In Phone Suggest Number" << flush;
		#endif
		return FALSE;
	}
	PACCESSENTRY m_rgAccessEntry = *(SuggestInfo.rgpAccessEntry);
	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n Fn: GetRasEntries : Phone Book Suggestions " << flush;
		RW_DEBUG << "\n\t Index " << m_rgAccessEntry->dwIndex ;
		RW_DEBUG << "\n\t Phone Number Type "  << m_rgAccessEntry->fType;
		RW_DEBUG << "\n\t StateId " << m_rgAccessEntry->wStateID;
		RW_DEBUG << "\n\t CountryId " << m_rgAccessEntry->dwCountryID;
		RW_DEBUG << "\n\t AreaCode "  <<  m_rgAccessEntry->dwAreaCode ;
		RW_DEBUG << "\n\t CityName " << m_rgAccessEntry-> szCity;
		RW_DEBUG << "\n\t Access Number " << m_rgAccessEntry->szAccessNumber;
		RW_DEBUG << "\n\t Actual Area Code "  << m_rgAccessEntry->szAreaCode << flush;
	#endif

	//BOOL FillRASEntries(RASENTRY	*pRasEntry);

	DUNFileProcess    dfp(hInstance,
		ConvertToUnicode(m_rgAccessEntry->szDataCenter));
	if(!dfp.CreateRasEntry(pRasEntry,szUserName,szPassword))
	{
		#ifdef _LOG_IN_FILE
		  RW_DEBUG << "\n GetRas Entries -Error 4 : Processinfg DUN File "  << flush;	
		#endif
		return FALSE;
	}
	pRasEntry->dwCountryID  = dwCountry;
	GetCountryCodeUsingTapiId(dwCountryCode,&dwCountryCode) ;
	pRasEntry->dwCountryCode  =dwCountryCode;

	_tcscpy(pRasEntry->szLocalPhoneNumber, ConvertToUnicode(m_rgAccessEntry->szAccessNumber));
	_tcscpy(pRasEntry->szAreaCode,ConvertToUnicode(m_rgAccessEntry->szAreaCode));

	RW_DEBUG << "\n Counntry ID " <<pRasEntry->dwCountryID  << " Country Code " << pRasEntry->dwCountryCode  << flush;

	RW_DEBUG << "\n AreaCode: " << ConvertToANSIString(pRasEntry->szAreaCode);
	RW_DEBUG << "Local No Real: " << m_rgAccessEntry->szAccessNumber << flush;
	RW_DEBUG << "Local No: " << ConvertToANSIString(pRasEntry->szLocalPhoneNumber) << flush;


	return TRUE;
}




DWORD ConfigureDUN ( HWND hWnd, HINSTANCE hInstance,
					 RASENTRY	*pRasEntry,
					 TCHAR	*szUserName,
					 TCHAR	*szPassword,
					 int        iModemIndex)
{
	
	DWORD dwEntrySize;
	DWORD dwRet;
	
	// Prepare RASENTRY for Dial-up
	//
	
	if(!GetRASEntries(hInstance,
		pRasEntry,
		szUserName,
		szPassword) )
	{
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\n Fn : ConfigureDUN   : Error3  Error Getting Ras Entries " << flush;
		#endif
		return FALSE;
	}
	_tcscpy(pRasEntry->szDeviceName, GetModemDeviceInformation(hInstance, iModemIndex));

#ifdef _WIN95
	//
	//  remove Old entry
	//  Verify if name exists in Registry
	//  if so remove the name from Registry
	//
	//
	//
	HANDLE  hRegKey ;
	LONG regStatus;
	DWORD dwInfoSize;
	char  szParam[512];

	regStatus = RegOpenKeyEx(HKEY_CURRENT_USER,
					"RemoteAccess\\Addresses",0,
					KEY_READ,&hRegKey);
	if (regStatus == ERROR_SUCCESS)	{
		//  Key Exists  so search if REG WIZ exists
		dwInfoSize = 512;
		regStatus = RegQueryValueEx(hRegKey,RAS_ENTRY_NAME,NULL,0,
			(unsigned char*) szParam,&dwInfoSize);
		if (regStatus == ERROR_SUCCESS)
		{
			// The Key Exits So delete the Entry
			RegDeleteValue(hRegKey,RAS_ENTRY_NAME);

			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\nRegistry Entry found  "  << RAS_ENTRY_NAME <<
				"  and Deleting the Entry "  <<  flush;
			#endif
			
		}
		 RegCloseKey(hRegKey);

	}
#else
	ATK_RasDeleteEntry(NULL,RAS_ENTRY_NAME);
#endif

	
	dwEntrySize  = sizeof(RASENTRY);
	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\nAfter Ras Get Properties :";
		RW_DEBUG << "\n\t Device Name " << ConvertToANSIString(pRasEntry->szDeviceName) << flush;
	#endif

	dwRet = ATK_RasSetEntryProperties( NULL,
						   RAS_ENTRY_NAME,
						   pRasEntry,
						   dwEntrySize ,
						   NULL,
						   0);
	
	if(dwRet ==  ERROR_CANNOT_OPEN_PHONEBOOK )
	{
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nFun  ConfigureDUN : ERROR_CANNOT_OPEN_PHONEBOOK  "  << dwRet  << flush;
		#endif
		return FALSE;
	}
	else
	if(dwRet ==  ERROR_BUFFER_INVALID )
	{
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nFun  ConfigureDUN : ERROR_BUFFER_INVALID  "  << dwRet  << flush;
		#endif
		return FALSE;
	}
	else
	if(dwRet)
	{
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\n ConfigureDUN : Unknown/Undocumented  Error "  << dwRet  << flush;
		#endif
		return FALSE;
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizpost\ithread.cpp ===
#include <windows.h>
#include <stdio.h>
#include "AtkInternet.h"

#include "resource.h"
#include <ithread.h>
#include "icw.h"
#include "util.h"
#include "rw_common.h"
#include "ATK_inet.h"

#define  RWZ_POST_MAX_RETRY  3

struct _MK
{
	DWORD dwQuery;
	char *s;
} ;

#define MK(x) {x,#x}


static  _MK Queries[] =
{
MK(HTTP_QUERY_MIME_VERSION),
MK(HTTP_QUERY_CONTENT_TYPE),
MK(HTTP_QUERY_CONTENT_TRANSFER_ENCODING),
MK(HTTP_QUERY_CONTENT_ID),
MK(HTTP_QUERY_CONTENT_DESCRIPTION),
MK(HTTP_QUERY_CONTENT_LENGTH),
MK(HTTP_QUERY_ALLOW),
MK(HTTP_QUERY_PUBLIC),
MK(HTTP_QUERY_DATE),
MK(HTTP_QUERY_EXPIRES),
MK(HTTP_QUERY_LAST_MODIFIED),
MK(HTTP_QUERY_MESSAGE_ID),
MK(HTTP_QUERY_URI),
MK(HTTP_QUERY_DERIVED_FROM),
MK(HTTP_QUERY_COST),
MK(HTTP_QUERY_PRAGMA),
MK(HTTP_QUERY_VERSION),
MK(HTTP_QUERY_STATUS_CODE),
MK(HTTP_QUERY_STATUS_TEXT),
MK(HTTP_QUERY_RAW_HEADERS),
MK(HTTP_QUERY_RAW_HEADERS_CRLF),
MK(HTTP_QUERY_REQUEST_METHOD)
};
void QueryForInfo(HINTERNET );
void GetQueryInfo(HINTERNET ,DWORD ,char *);

typedef BOOL (WINAPI *LPICP)(HWND,BOOL,BOOL);
LPICP lpICP;



static int InvokeModemInstallation()
{
	int iErr;
	DWORD dwPrS,dwRet;
	STARTUPINFOA startUpInfo;
	PROCESS_INFORMATION PrcsInfo;
	
	GetStartupInfoA(&startUpInfo);

#ifdef _WIN951
	ShellExecute(NULL,NULL,"control.exe","modem.cpl",
					NULL,SW_SHOW);
	return 1;
#else

	if( dwPrS=  CreateProcessA( NULL ,
				"rundll32.exe shell32.dll,Control_RunDLL modem.cpl", 0, 0,
				 FALSE,CREATE_NEW_CONSOLE, 0, 0,
				 &startUpInfo, &PrcsInfo) )
	{
		dwRet = WaitForSingleObject(PrcsInfo.hProcess, INFINITE);
		switch(dwRet)
		{
		case WAIT_ABANDONED  :
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n ABD " << flush;
			#endif
			break;
		case WAIT_OBJECT_0 :
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n OBJ " << flush;
			#endif
			break;
		case WAIT_TIMEOUT:
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n TOUT " << flush;
			#endif
			break;
		default :
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n Error  " <<  GetLastError() << flush;
			#endif
		}
		return 1;

	}
	else
	{
		iErr = GetLastError();
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\n Error In Modem Configuration"  << iErr << flush;
		#endif
		return 0;
	}
#endif

}

void QueryForInfo(HINTERNET hIntHandle)
{
	int nSize  = sizeof(Queries)/sizeof(_MK);
	for(int i=0;i< nSize;i++)
	{
		GetQueryInfo(hIntHandle,Queries[i].dwQuery,Queries[i].s);
	}
}

void GetQueryInfo(HINTERNET hIntHandle,DWORD dwQuery,char *s)
{
	char  dwbufQuery[512];
	DWORD dwLengthBufQuery;
	BOOL bQuery = ::ATK_HttpQueryInfo(	hIntHandle,
									dwQuery,
									&dwbufQuery,
			                        &dwLengthBufQuery,
									NULL) ;
	
	#ifdef _LOG_IN_FILE
		RW_DEBUG  << "\n" << s << dwbufQuery <<  flush;
	#endif
}



void _stdcall myCallback(   IN HINTERNET hInternet,
							IN DWORD dwContext,
							IN DWORD dwInternetStatus,
							IN LPVOID lpvStatusInformation OPTIONAL,
							IN DWORD dwStatusInformationLength)
{
	int iX= 100;
	iX++;

	switch(dwInternetStatus)
	{
	case INTERNET_STATUS_RESOLVING_NAME :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: RESOLVING_NAME\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_NAME_RESOLVED :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_NAME_RESOLVED\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_CONNECTING_TO_SERVER :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_CONNECTING_TO_SERVER\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_CONNECTED_TO_SERVER :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_CONNECTED_TO_SERVER\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_SENDING_REQUEST :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_SENDING_REQUEST\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_REQUEST_SENT :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_REQUEST_SENT\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_RECEIVING_RESPONSE :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_RECEIVING_RESPONSE\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_RESPONSE_RECEIVED :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_RESPONSE_RECEIVED\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_REDIRECT :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_REDIRECT\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_CLOSING_CONNECTION :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_CLOSING_CONNECTION\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_CONNECTION_CLOSED :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_CONNECTION_CLOSED\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_HANDLE_CREATED :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_HANDLE_CREATED\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_REQUEST_COMPLETE :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_REQUEST_COMPLETE\n" << flush;
		#endif
		break;
	default :
		#ifdef _LOG_IN_FILE
			RW_DEBUG <<"\n Callback : default " << flush;
		#endif
	}
}




void pickup(const char* in, char* out, int *ipProxy)
{
	char czProzy[10]= "80";
	char *pProxy;
	int iCount ;

	pProxy = czProzy;
	
	if( *in == '/' )
		in++;

	if( *in == '/' )
		in++;

	while( *in && (*in != ':') && (*in != ';') )
		*out++ = *in++;
	
	*out = 0;
	
	if(!*in)
		return;

	if ( *in != ':' || *in != ';' )
		*in++;
	
	iCount = 0;
	
	while(*in && ( isspace(*in) || isdigit(*in)) )
	{
		if( isdigit(*in) )
		{
			*pProxy++ = *in;
			iCount++;
		}

		*in++;
	}

	if(iCount)
		*pProxy = 0;
	
	*ipProxy = atoi(czProzy);
}


/* //remove all blabks immediately preceeding ':' and afterwards.
   // eg.  "HELLO WORLD  : 80 " =>
	//     "HELLO WORLD:80"
	Remove all blanks: No blanks are allowed in a machine name?
*/

void RemoveBlank(char *pszStr)
{
	char *p, *q;
	p = pszStr;
	q = p;

	for(;*p;*p++)
	{
		if(!isspace(*p))
		{
			*q++ = *p;
		}
	}
	*q = '\0';
}


int getProxy(const char *in, char *out,int *piPort)
{
	char *s;
	*piPort = 0;	
	if( s= strstr(in, "http://") )
	{
		pickup(s+7,out,piPort);
	}
	else
	if(s= strstr(in, "http=") )
	{
		pickup(s+5,out,piPort);
	}
	else
	if( s= strstr(in, "http:") )
	{
		pickup(s+5,out,piPort);
	}
	else
	if(s= strstr(in, "://") )
	{
		*out = 0;
		return 0;
	}
	else
	if(s= strstr(in, "=") )
	{
		*out = 0;
		return 0;
	}
	else
		pickup(in,out,piPort);	
	return 1;
}


// Constructor
//
CInternetThread::CInternetThread()
    : m_hSession(NULL),
      m_dwAccessType(PRE_CONFIG_INTERNET_ACCESS)
{
	m_strProxyServer = NULL;
	m_strBuffer = NULL;
	m_strIISServer = NULL;
	m_strPath = NULL;
	m_hICWDllInstance  = NULL ; // ICW DLL not loaded
}




// Closes the Internet session so InternetOpen will be called on next PostData.
//
void CInternetThread::ResetSession()
{
   if (m_hSession != NULL)
   {
      ::InternetCloseHandle(m_hSession);
      m_hSession = NULL ;
   }
}


//
//
CInternetThread::~CInternetThread()
{
   if (m_strBuffer)			delete []m_strBuffer;
   if (m_strIISServer)		delete []m_strIISServer;
   if (m_strProxyServer)	delete []m_strProxyServer;
   if (m_UserName) delete []  m_UserName;
   if (m_Password ) delete [] m_Password;
   if (m_strPath) delete [] m_strPath;

   //ResetSession();
   if(m_hICWDllInstance)
   {
	    FreeLibrary(m_hICWDllInstance);
	    #ifdef _LOG_IN_FILE
			RW_DEBUG << "\n Freeing INETCFG.DLL " << flush;
    	#endif
        m_hICWDllInstance = NULL;
   }
}

void CInternetThread ::UnLoadInetCfgDll()
{
	if( m_hICWDllInstance)
	FreeLibrary(m_hICWDllInstance);
	m_hICWDllInstance = NULL;

}

void	CInternetThread::SetBuffer(LPSTR strBuffer)	
{
   if (m_strBuffer)
		delete []m_strBuffer;
   if (strBuffer)
   {
	   m_dwBufferLen = strlen(strBuffer)+1;
	   m_strBuffer = (LPSTR) new CHAR[strlen(strBuffer)+1];
	   strcpy(m_strBuffer, strBuffer);
   }
}

void	CInternetThread::SetBuffer(LPSTR strBuffer, DWORD dwLen)	
{
   if (m_strBuffer)
		delete []m_strBuffer;
   if (strBuffer)
   {
	   m_dwBufferLen = dwLen-1;
	   m_strBuffer = (LPSTR) new CHAR[m_dwBufferLen+1];
	   memset(m_strBuffer, '\0', m_dwBufferLen+1);
	   strncpy(m_strBuffer, strBuffer, m_dwBufferLen);
   }
}

HINSTANCE CInternetThread:: LoadInetCfgDll()
{
	
	if(m_hICWDllInstance)
	{
		return m_hICWDllInstance;
	}
	m_hICWDllInstance = LoadLibrary(_T("INETCFG.DLL"));
	if (NULL == m_hICWDllInstance)
	{
		DisplayMessage("INETCFG.DLL LoadLibrary Failure", "");
		
	}
	return m_hICWDllInstance;

}

BOOL CInternetThread :: InstallModem(HWND hwnd)
{
	RW_DEBUG << "\n---Inside InstallModem" << flush;
#ifdef _WINNT
	/*
	STARTUPINFOA startUpInfo;
	PROCESS_INFORMATION PrcsInfo;
	GetStartupInfoA(&startUpInfo);
	DWORD dwPrS;
	int iErr;
	if( dwPrS=  CreateProcessA( NULL ,
			"rundll32.exe shell32.dll,Control_RunDLL modem.cpl", 0, 0,
			 FALSE,CREATE_NEW_CONSOLE, 0, 0,
			 &startUpInfo, &PrcsInfo) ) {
			WaitForSingleObject(PrcsInfo.hProcess, INFINITE);
	}
	else
	{
		iErr = GetLastError();
		RW_DEBUG << "\n Error In invoking Modem Init  "  << iErr << flush;
	}
	return 0;*/
	BOOL bRet;
	HINSTANCE hInstance = LoadLibrary(_T("modemui.dll"));
	if(hInstance != NULL)
	{
		lpICP = (LPICP) GetProcAddress(hInstance,"InvokeControlPanel");

		// Initialise the Control panel application
		bRet = lpICP(hwnd,FALSE,FALSE);
	
		FreeLibrary(hInstance);
	}
	else
	{
		bRet = FALSE;
		RW_DEBUG << "\n Error Loading modemui.dll" << flush;
	}
	
	return bRet;
	
#else

	HINSTANCE	hInst;
	BOOL        bRestart=FALSE;
	INETCONFIGSYSTEM fpS;

	hInst = LoadInetCfgDll();
	fpS = (INETCONFIGSYSTEM) GetProcAddress(hInst, "InetConfigSystem");
	HRESULT hrs  = (*fpS)(NULL,0x02,&bRestart);
	DWORD dwR = GetLastError();

	return bRestart;
#endif
}

/*
	05/05/97 : Proxy returns as http://XX:port
*/
BOOL CInternetThread::GetSystemProxyServer(PCHAR szProxy,
										   DWORD dwBufferLength,
										   int *piProxyPort)
{
  DWORD size = 0;  
  ATK_InternetQueryOption(NULL, INTERNET_OPTION_PROXY,NULL, &size);  
  #ifdef USE_ASTRATEK_WRAPPER
		BYTE* buf = new BYTE[size];
  #else
		BYTE* buf = new BYTE[size* sizeof(_TCHAR)];
  #endif
  ATK_INTERNET_PROXY_INFO* ipi = (ATK_INTERNET_PROXY_INFO*)buf;
  if (!ATK_InternetQueryOption(NULL, INTERNET_OPTION_PROXY,   ipi, &size))  
  {
		//MessageBox(NULL,_T("InternetQueryOption"),_T("False"),IDOK);
		delete[] buf;   
		return FALSE;  
  }
  else
  {
	  if(ipi->dwAccessType != 3)
	  {
			//MessageBox(NULL,_T("AccessType"),_T("False"),IDOK);
			delete[] buf;   
			return FALSE;
	  }
	  else
	  {
			//MessageBox(NULL,ConvertToUnicode(),ConvertToUnicode((LPSTR)ipi->lpszProxy),IDOK);
		  #ifdef USE_ASTRATEK_WRAPPER
			if( getProxy(ipi->lpszProxy,szProxy,piProxyPort)) 	
		  #else
			if( getProxy(ConvertToANSIString(ipi->lpszProxy),szProxy,piProxyPort)) 	
		  #endif
			{
				  RemoveBlank(szProxy);
				 // MessageBox(NULL,_T("after getproxy"),_T("TRUE"),IDOK);
					#ifdef _LOG_IN_FILE
						RW_DEBUG <<  "\n Actual HTTP Proxy [" <<szProxy << "] Port:" << *piProxyPort  << flush;
					#endif
				  delete[] buf;   
				  return TRUE;
			}
			else 
			{
				//MessageBox(NULL,_T("GetProxy"),_T("False"),IDOK);
	     	    delete[] buf;   
		    	return FALSE;
			}
	  }
  }
	
}

//
// This function gets the Actual proxy settings string
void CInternetThread :: GetSystemProxySettings( PCHAR szProxy,
										   DWORD dwBufferLength)

{
  DWORD size = 0;  
  ATK_InternetQueryOption(NULL, INTERNET_OPTION_PROXY,NULL, &size);  

  #ifdef USE_ASTRATEK_WRAPPER
		BYTE* buf = new BYTE[size];
  #else
		BYTE* buf = new BYTE[size* sizeof(_TCHAR)];
  #endif

  
  ATK_INTERNET_PROXY_INFO* ipi = (ATK_INTERNET_PROXY_INFO*)buf;
  ATK_InternetQueryOption(NULL, INTERNET_OPTION_PROXY,   ipi, &size);
  
  #ifdef USE_ASTRATEK_WRAPPER
		strcpy(szProxy,ipi->lpszProxy);
  #else
		strcpy(szProxy,ConvertToANSIString(ipi->lpszProxy));
  #endif
  
  dwBufferLength = strlen(szProxy) +1;
  delete[] buf;   
	
}

//
// IN Parameters:
// LPSTR strProxyServer : Proxy Server name in ANSI char
// int iProxyPort       : Proxy Server Port
//
void CInternetThread::SetSystemProxySettings(LPSTR strProxyServer)
{

   TCHAR  *pProxy;

   if (m_strProxyServer)
		delete []m_strProxyServer;
	
   if (strProxyServer)
   {
	   pProxy = ConvertToUnicode(strProxyServer);
	   m_strProxyServer = (LPTSTR) new TCHAR[_tcslen(pProxy)+11];
	   _tcscpy(m_strProxyServer, pProxy);
	
   }

}

// IN Parameters:
// LPSTR strProxyServer : Proxy Server name in ANSI char
// int iProxyPort       : Proxy Server Port
void CInternetThread::SetProxyServer(LPSTR strProxyServer, int iProxyPort)
{
   TCHAR  czTemp[10];
   TCHAR  *pProxy;

   if (m_strProxyServer)
		delete []m_strProxyServer;
	
   if (strProxyServer)
   {
	   pProxy = ConvertToUnicode(strProxyServer);
	   m_strProxyServer = (LPTSTR) new TCHAR[_tcslen(pProxy)+11];
	   _tcscpy(m_strProxyServer, pProxy);
	   _stprintf(czTemp,_T(":%d"),iProxyPort);
	   _tcscat(m_strProxyServer,czTemp);
   }

}

void CInternetThread::SetIISServer(LPTSTR strIISServer)
{
   if (m_strIISServer)
		delete []m_strIISServer;

   if (strIISServer)
   {
	  m_strIISServer = (LPTSTR) new TCHAR[_tcslen(strIISServer)+1];
	  _tcscpy(m_strIISServer, strIISServer);
   }
}

void CInternetThread::SetServerPath(LPTSTR strPath)
{
   if (m_strPath)
		delete []m_strPath;

   if (strPath)
   {
	  m_strPath = (LPTSTR) new TCHAR[_tcslen(strPath)+1];
	  _tcscpy(m_strPath, strPath);
   }
}

// Verify that rAddress is partially valid. Start the worker thread to get a web page.
DWORD CInternetThread::PostData(HWND hWnd)
{

	int iRetryCount;
	UINT uiRetVal;
	int iExit;

	iExit =0;
	iRetryCount = 0;
	uiRetVal = RWZ_POST_FAILURE;

	if (!m_strIISServer || !m_strPath)
	{
      DisplayMessage ("IIS Server path not found ");
    }
	/*
	do {
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nRetry Posting " << iRetryCount+1  << flush;
		#endif
	   uiRetVal = _PostDataWorker();

	   if(uiRetVal != RWZ_POST_SUCCESS) {
		   iRetryCount++;
	   }else {
		   iExit = 1;
	   }
	   if( uiRetVal == RWZ_POST_WITH_SSL_FAILURE) {
		   // Do not Retry if it is an SSL problem
		   iExit= 1;
	   }


	   if(iRetryCount > RWZ_POST_MAX_RETRY ){
		   iExit = 1;
	   }

   }while(!iExit);
   **/
	uiRetVal = _PostDataWorker(hWnd);
   return uiRetVal;
	
}


// This is the thread function.
//
UINT CInternetThread::PostDataThread(LPVOID pvThread)
{
	
   CInternetThread* pInternetThread = (CInternetThread*) pvThread ;
   if (pInternetThread == NULL || (!pInternetThread->m_strIISServer))
   {
      return FALSE;
   }

   return pInternetThread->_PostDataWorker(NULL) ;

}


// This is where all of the actually Internet work is done.
UINT CInternetThread::_PostDataWorker(HWND hWnd)
{
	UINT uiResult = RWZ_POST_FAILURE;
	BOOL bRead;
	HINTERNET hConnect;
	HINTERNET hHttpFile;
	_TCHAR	szHeader[240];
	BOOL bSendRequest;
	DWORD dwCL=0;
	DWORD dwLengthBufQuery ;
	DWORD dwInfoLevel;
	BOOL bQuery;
	CHAR	pBuffer [MAX_PATH] ; // ?? decide with Steve on Bugffer Sz
	DWORD dwBytesRead ;
	// Variables for the SSL / Normal operation
	INTERNET_PORT	nServerPort;
	DWORD			dwFlags;

	// Added for Proxy Server
	LPTSTR  pUserName;
	LPTSTR  pPassword;
	LPTSTR  pProxyServerName;
	pUserName		 =_T("");
	pPassword		 =_T("");
	pProxyServerName =NULL;



	if(m_bPostWithSSL){
		nServerPort	=	INTERNET_DEFAULT_HTTPS_PORT;
		dwFlags		=	INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_SECURE;
	}else {
		nServerPort	=	INTERNET_INVALID_PORT_NUMBER;
		dwFlags		=	INTERNET_FLAG_DONT_CACHE;
	}

	#ifdef _LOG_IN_FILE
				RW_DEBUG << "\nPost Data:\n" << flush;
	#endif

	if (m_hSession == NULL){
      // Initialize the Internet Functions.
		m_hSession = ATK_InternetOpen(_T("Registration Wizard"),
		                              m_dwAccessType,
									  pProxyServerName,
			                          NULL,
					                  0		
									  );

		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\n\tInternet Open:" << m_hSession << flush;
		#endif
		
		if (!Succeeded(m_hSession, "InternetOpen"))
		{
			goto EndFn;
		}
   }

   hConnect = ATK_InternetConnect(m_hSession,
                                          m_strIISServer,
										  nServerPort,
										  pUserName, //	 m_UserName, Changed on 2/4/98 for IE Proxy Auth
										  pPassword, //  m_Password,
                                          INTERNET_SERVICE_HTTP,
                                          0,
                                          0);
										


	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n\tInternet Connection:" << ConvertToANSIString(m_strIISServer) << flush;
	//	RW_DEBUG << "\n\tUserName :" << ConvertToANSIString(m_UserName) << flush;
	//	RW_DEBUG << "\n\tPassword :" << ConvertToANSIString(m_Password) << flush;
	#endif
	
	if (!Succeeded(hConnect, "InternetConnect"))
	{
		goto EndFn;
	}

	hHttpFile = ATK_HttpOpenRequest(hConnect,
                                              _T("POST"),
                                              m_strPath,
                                              HTTP_VERSION,
                                              NULL,
                                              NULL, //szAcceptType,
                                              dwFlags,//INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_SECURE,
                                              0) ;
	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n\t\tInternet Post :" << ConvertToANSIString(m_strPath) << flush;
	#endif
	
	if (! Succeeded(hHttpFile, "HttpOpenRequest"))
	{
		::InternetCloseHandle(hConnect);
		goto EndFn;
	}

	_tcscpy(szHeader, _T("Accept: */*\nContent-Type: application/x-www-form-urlencoded"));
	bSendRequest = ATK_HttpSendRequest(hHttpFile,
	szHeader, -1L , m_strBuffer, m_dwBufferLen);

	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n\t\tSendData:" << m_strBuffer << flush;
	#endif

	if (!Succeeded1(bSendRequest, "HttpSendRequest"))
	{
		::InternetCloseHandle(hConnect);
		goto EndFn;
	}

	// Get size of file.
	dwInfoLevel = HTTP_QUERY_CONTENT_TRANSFER_ENCODING;
	dwLengthBufQuery = sizeof( DWORD);
	bQuery = ATK_HttpQueryInfo(hHttpFile,
                          HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER,
							&dwCL,
                           &dwLengthBufQuery,
                           NULL) ;
			
	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n Query ContentLength : " << dwCL  << flush;
	#endif
	
	if (! Succeeded1(bQuery, "HttpQueryInfo") )
	{
		::InternetCloseHandle(hConnect);
		goto EndFn;
	}
	memset(pBuffer,0,MAX_PATH);

	bRead = ::InternetReadFile(hHttpFile,	
									pBuffer,	
									MAX_PATH, 	
									&dwBytesRead);	

	#ifdef _LOG_IN_FILE
		RW_DEBUG <<"\n ReturnBuffer " <<  pBuffer << flush;
	#endif
	
	if (!Succeeded1(bRead, "InternetReadFile"))
	{
		DisplayMessage("HTTP POST FAILURE ...");
			::InternetCloseHandle(hConnect);
		goto EndFn;
	}
	
	if(pBuffer[0] == _T('0' ))
	{
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\n Post Successful" << flush;
		#endif

		uiResult = RWZ_POST_SUCCESS;
	}
	else {
		// 438
		if ( (pBuffer[0] == _T('4')) &&  (pBuffer[1] == _T('3')) ) {
			uiResult = RWZ_POST_MSN_SITE_BUSY;
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n Post Failure " << flush;
			#endif

		}
		else {
		uiResult = RWZ_POST_WITH_SSL_FAILURE;

		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\n Post with SSL  Failure " << flush;
		#endif
		}
	}

	pBuffer[dwBytesRead] = 0 ;
	::InternetCloseHandle(hConnect);


EndFn:
   return uiResult ;
}

DWORD InvokePost(HWND hWnd, CInternetThread *p)
{
	return p->PostData(hWnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizpost\phonebk.h ===
#ifndef _PHONE_BOOK_
#define _PHONE_BOOK_
#include "phbk.h"
#ifdef __cplusplus
extern "C" {
#endif

DllExportH PhoneBookLoad(LPCSTR pszISPCode, DWORD_PTR far *pdwPhoneID);
DllExportH PhoneBookSuggestNumbers(DWORD_PTR dwPhoneID, PSUGGESTINFO lpSuggestInfo);
DllExportH PhoneBookDisplaySignUpNumbers (DWORD_PTR dwPhoneID,
														LPSTR far *ppszPhoneNumbers,
														LPSTR far *ppszDunFiles,
														WORD far *pwPhoneNumbers,
														DWORD far *pdwCountry,
														WORD far *pwRegion,
														BYTE fType,
														BYTE bMask,
														HWND hwndParent,
														DWORD dwFlags);


#ifdef __cplusplus
			}
#endif

#endif	// _PHONE_BOOK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizpost\tcp.h ===
#ifndef __TCP_h__
#define __TCP_h__
/**************************************************************************

   File:          icw.h
   
   Description:   

**************************************************************************/
// === Structures Required by the ICMP.DLL ====================================

typedef struct {
   unsigned char Ttl;                                           // Time To Live
   unsigned char Tos;                                        // Type Of Service
   unsigned char Flags;                                      // IP header flags
   unsigned char OptionsSize;                  // Size in bytes of options data
   unsigned char *OptionsData;                       // Pointer to options data
} IP_OPTION_INFORMATION, * PIP_OPTION_INFORMATION;


typedef struct {
   DWORD Address;                                           // Replying address
   unsigned long  Status;                                       // Reply status
   unsigned long  RoundTripTime;                         // RTT in milliseconds
   unsigned short DataSize;                                   // Echo data size
   unsigned short Reserved;                          // Reserved for system use
   void *Data;                                      // Pointer to the echo data
   IP_OPTION_INFORMATION Options;                              // Reply options
} IP_ECHO_REPLY, * PIP_ECHO_REPLY;


typedef	HANDLE (WINAPI *ICMPCREATEFILE)(VOID);
typedef	BOOL   (WINAPI *ICMPCLOSEHANDLE)(HANDLE);
typedef	DWORD  (WINAPI *ICMPSENDECHO )( 
									HANDLE, DWORD, LPVOID, WORD,
                                    PIP_OPTION_INFORMATION, LPVOID, 
                                    DWORD, DWORD 
									   );

#ifdef __cplusplus
extern "C" 
{
#endif
	DWORD  PingHost();
	BOOL Ping(LPSTR szIPAddress);
	BOOL CheckHostName(LPSTR szIISServer);

#ifdef __cplusplus
}
#endif	

#endif	// __TCP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizpost\util.h ===
/**************************************************************************

   File:          util.h
   
   Description:   

**************************************************************************/
#include <tchar.h>

#ifdef __cplusplus
extern "C" 
{
#endif

	BOOL GetRegKeyValue(HINSTANCE hInstance, HKEY hRootKey, LPTSTR szBaseKey,int valueStrID, LPTSTR szValue);
	void DisplayMessage(LPCSTR szMessage, LPCSTR szFormat=0);
	BOOL Succeeded(HANDLE h, LPCSTR strFunctionName);
	BOOL Succeeded1(BOOL h, LPCSTR strFunctionName);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizpost\util.cpp ===
#include <windows.h>
#include <stdio.h>
#include "util.h"
#include "rw_common.h"



/*********************************************************************
Looks for a subkey, under the Registration Database key given in the
szBaseKey parameter, of the form "0000", "0001", etc.  The numerical
equivalent of the subkey is determined by the index value given in
the enumIndex parameter.  The value attached to the valueName
specified in the string resource whose ID is given in valueStrID will
be returned in szValue.

Returns: FALSE if the key specified is not found. 
**********************************************************************/
BOOL GetRegKeyValue(HINSTANCE hInstance, HKEY hRootKey, LPTSTR szBaseKey,int valueStrID, LPTSTR szValue)
{
	BOOL returnVal = FALSE;
	HKEY hKey;
	LONG regStatus = RegOpenKeyEx(hRootKey, szBaseKey, 0, KEY_READ,&hKey);
	if (regStatus == ERROR_SUCCESS)
	{
		_TCHAR szValueName[128];
		//LoadString(hInstance,valueStrID,szValueName,128);
		_tcscpy(szValueName, _T("InternetProfile"));

		unsigned long infoSize = 255;
		//regStatus = RegQueryValueEx(hKey, szValueName, NULL, 0, (unsigned char*) szValue, &infoSize);
		regStatus = RegQueryValueEx(hKey, szValueName, NULL, 0, (LPBYTE) szValue, &infoSize);
		if (regStatus == ERROR_SUCCESS)
		{
			returnVal = TRUE;
		}
		RegCloseKey(hKey);
	}
	return returnVal;
}


void DisplayMessage(LPCSTR szMessage, LPCSTR szFormat) 
{
#ifdef _LOG_IN_FILE
   if (szFormat)
   {
      DWORD dwError = GetLastError() ;
      CHAR errString[1024] ;
	  sprintf(errString, szFormat, szMessage);
	  RW_DEBUG << "\n " << errString << flush;
   }
   else
   {
	   RW_DEBUG << "\n" << szMessage << flush;
   }
#endif
}

BOOL Succeeded1(BOOL h, LPCSTR strFunctionName)
{
   if (h == FALSE)
   {
	  char errString[1024] ;
	  sprintf(errString, "%s returns error %u",
				strFunctionName, GetLastError());

	  #ifdef _LOG_IN_FILE
		RW_DEBUG << "\n Succeeded " << errString << flush;
	  #endif 

      return FALSE;
	
   }
   else
   {
      return TRUE ;
   }
}

BOOL Succeeded(HANDLE h, LPCSTR strFunctionName)
{
   if (h == NULL)
   {
	  char errString[1024] ;
      sprintf(errString, "%s returns error %u", 
				strFunctionName, GetLastError());

	  #ifdef _LOG_IN_FILE
		RW_DEBUG << "\n Succeeded " << errString << flush;
	  #endif 

      return FALSE;
   }
   else
   {
      return TRUE ;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizpost\tcp.cpp ===
///////////////////////////////
//   File:          tcp.cpp
//   
//   Description:   

//	#include statements
//
#include <windows.h>
#include <stdio.h>
#include <winsock.h>
#include "tcp.h"
#include "util.h"
#include "rw_common.h"


#define   RW_TCP_NOT_INITILIZED   0
#define   RW_TCP_INITILIZED       1 

#define   RW_ICMP_NOT_INITILIZED   0
#define   RW_ICMP_INITILIZED       1

static int siTcpStatus = RW_TCP_NOT_INITILIZED;
static HINSTANCE  hIcmp= NULL;
static WSADATA wsa;

int ResolveHostByThread(LPSTR pHost);
int ResolveHostByAddrThread(LPSTR pHost);

#define GET_HOST_TOUT (15 * 1000)
#define PING_TOUT     (15 * 1000)
static struct hostent *gphostent= NULL;

BOOL InitForTcp()
{
	BOOL	bRet= FALSE;


	if( siTcpStatus == RW_TCP_INITILIZED ) 
	return TRUE;

	if (! WSAStartup(0x0101, &wsa )) {
		siTcpStatus = RW_TCP_INITILIZED;
		bRet= TRUE;
	}
	return bRet;

}

BOOL InitForIcmp()
{
	if(hIcmp)
		return TRUE;
	hIcmp = LoadLibrary( _T("ICMP.DLL") );  //  Load ICMP.DLL and store globally
	if( ! hIcmp )
	{                                   //  Whine if unable to load the DLL
	  DisplayMessage("Unable to locate ICMP.DLL");
	  return( FALSE );
	}
	return TRUE;

}

void CloseForTcpIcmp()
{
	if (hIcmp)
		FreeLibrary(hIcmp);  //  When app is closed, free the ICMP DLL
	if(siTcpStatus == RW_TCP_INITILIZED)
	WSACleanup();		  //  And clean up sockets
	hIcmp = NULL;
	siTcpStatus = RW_TCP_NOT_INITILIZED;

}
//
// Tries to get the host name and pings using ICMP
// returns
//  RWZ_PINGSTATUS_NOTCPIP : if no socket library or get hostname fails  
//  RWZ_PINGSTATUS_SUCCESS : if gethostname and ping is successful 
//  RWZ_PINGSTATUS_FAIL    : if gethostname is succesful and ping via icmp fails 

DWORD  PingHost()
{
	DWORD 	dwRet= 0;
	char	szIPAddress[80];
	dwRet = RWZ_PINGSTATUS_NOTCPIP;
	if(!InitForTcp()) {
		return dwRet; // Tcp is not installed 
	}
	memset(szIPAddress, '\0', 80);
	if (!gethostname(szIPAddress, 80))
	{
		 
		if (Ping(szIPAddress)){
			dwRet =  RWZ_PINGSTATUS_SUCCESS;
		}else {
			dwRet =  RWZ_PINGSTATUS_FAIL;
		}
	}

	return dwRet;
}


	



BOOL Ping(LPSTR szIPAddress)
{
	BOOL bRet= FALSE;

	if( !InitForIcmp())
		return bRet;

	if(!InitForTcp()) {
		return FALSE; // Tcp is not installed 
	}


	static struct sockaddr_in saDestAddr;

	char szBuffer[64];
	DWORD *dwIPAddr, dwStatus;
	HANDLE hIP;
	struct hostent *phostent;
	PIP_ECHO_REPLY pIpe;

	if(!ResolveHostByThread(szIPAddress)) {
		gphostent = gethostbyname(szIPAddress);
		phostent = gphostent;
	}else {
		phostent= NULL;
	}
	if( ! phostent ){
		RW_DEBUG << "\n Resolving by Address "  << flush;
		int iError;
		iError = 0;
		iError = WSAGetLastError ();
		RW_DEBUG << "\n Get Host By Name Error " << iError  << flush;
		if(iError){
			WSASetLastError (0);
			//return 0;
		}

		saDestAddr.sin_addr.s_addr = inet_addr(szIPAddress);
		if( saDestAddr.sin_addr.s_addr !=INADDR_NONE ) {
			if(!ResolveHostByAddrThread((LPSTR)&saDestAddr.sin_addr.s_addr)) {
				gphostent = gethostbyaddr((LPSTR)&saDestAddr.sin_addr.s_addr,4, PF_INET) ;
				phostent = gphostent;
			}else {
				phostent= NULL;
			}
			
		}
		if(!phostent)
		{
			DisplayMessage(szIPAddress , "Unable to obtain an IP address for %s");
			return bRet;
		}
		
	}
	



    dwIPAddr = (DWORD *)( *phostent->h_addr_list );

	ICMPCREATEFILE	pIcmpCreateFile;
	pIcmpCreateFile = (ICMPCREATEFILE) GetProcAddress(hIcmp, "IcmpCreateFile");
	if (NULL == pIcmpCreateFile)
	{
		DisplayMessage("IcmpCreateFile GetProc Error", "");
		return FALSE;
	}

    ICMPCLOSEHANDLE	pIcmpCloseHandle;
 	pIcmpCloseHandle = (ICMPCLOSEHANDLE) GetProcAddress(hIcmp, "IcmpCloseHandle");
	if (NULL == pIcmpCloseHandle)
	{
		DisplayMessage("IcmpCloseHandle GetProc Error", "");
		return bRet;
	}

	ICMPSENDECHO	pIcmpSendEcho;
	pIcmpSendEcho = (ICMPSENDECHO) GetProcAddress(hIcmp, "IcmpSendEcho");
	if (NULL == pIcmpSendEcho)
	{
		DisplayMessage("IcmpSendEcho GetProc Error", "");
		return bRet;
	}

	if( ! pIcmpCreateFile || ! pIcmpCloseHandle || ! pIcmpSendEcho )
	{
		DisplayMessage("Unable to locate required API functions", "");
		return bRet;
	}


	hIP = pIcmpCreateFile();
	if( hIP == INVALID_HANDLE_VALUE )
	{
	  DisplayMessage("Unable to open PING service");
	  return bRet;
	}

	memset( szBuffer, '\xAA', 64 );
	pIpe = (PIP_ECHO_REPLY)LocalAlloc(LPTR, sizeof(IP_ECHO_REPLY) + 64);
	if (pIpe)
	{
		pIpe->Data = szIPAddress;
		pIpe->DataSize = 64;      

		dwStatus = pIcmpSendEcho( hIP, *dwIPAddr, szBuffer, 64, NULL, pIpe, 
								sizeof(IP_ECHO_REPLY) + 64, PING_TOUT );
		if(dwStatus)
		{
			bRet = TRUE;
		}
		LocalFree(pIpe);
		pIcmpCloseHandle(hIP);
   }
   
   
   return bRet;
}


BOOL  CheckHostName(LPSTR szIISServer)
{
// WSAStartup() is already called	
	if(!InitForTcp()) {
		return FALSE; // Tcp is not installed 
	}
	struct hostent *phostent;
	
	if(!ResolveHostByThread(szIISServer)) {
		phostent = gphostent;
	}else {
		phostent= NULL;
	}
	
	if (phostent == NULL)
		return FALSE;
	else
		return TRUE;
// WSACleanup() will be called later
	
}


//
//  Returns 1 if there is an Error
//          0 if Successful 
DWORD GetHostThread(void *vp)
{
	DWORD dwIsError=1;
	LPSTR  szHost;
	szHost = (LPSTR) vp;
	int iError = 0;

	gphostent = gethostbyname(szHost);
	if( ! gphostent ){
		
		iError = WSAGetLastError ();
		if(iError) {
			WSASetLastError (0); // Reset the  error 
		}
	}
	else {
		dwIsError =0;
	}
	ExitThread(dwIsError);
	return dwIsError;
}

//
//  This function returns Calls the gethostbyname and 
//  returns 0 if Successful and 1 if failure 
//  the return 
//
//
int ResolveHostByThread(LPSTR pHost)
{
	int   iRet=0; 
	DWORD  dwThreadExitCode; 
	DWORD dwCreationFlags=0; // Start CREATE_SUSPENDED 
	DWORD ThreadId;
	RW_DEBUG << "\nResolve " << pHost <<  flush;

	HANDLE hParent = CreateThread(NULL, 
		0,
	(LPTHREAD_START_ROUTINE) GetHostThread,
	(void *) pHost,
	dwCreationFlags, 
	&ThreadId );

	DWORD dwRet = WaitForSingleObject(hParent,GET_HOST_TOUT);
	switch(dwRet) {
	case WAIT_ABANDONED :
		iRet = 1; // Error In Get Host Name 
		break;
	case WAIT_OBJECT_0 :
		RW_DEBUG << "\n\tResolved ( 1 Error, 0 Ok)  ";

		if( GetExitCodeThread(hParent,&dwThreadExitCode) ) {
			iRet = (int) dwThreadExitCode;

		}
		else {
			
		}
		RW_DEBUG << iRet;
		break;
	case WAIT_TIMEOUT :
		RW_DEBUG << "\n\t*** Error  Resolving " << flush;
		iRet = 1; // Error In Get Host Name 
		TerminateThread(hParent,0);
		break;
	default:
		break;
	}
	return iRet;


}


//
//  Returns 1 if there is an Error
//          0 if Successful 
DWORD GetHostByAddrThread(void *vp)
{
	DWORD dwIsError=1;
	LPSTR  szAddr;
	int iError = 0;
	szAddr = (LPSTR) vp;
	
	gphostent = gethostbyaddr(szAddr, 
		4, PF_INET) ;
	if( ! gphostent ){
		
		iError = WSAGetLastError ();
		if(iError) {
			WSASetLastError (0); // Reset the  error 
		}
	}
	else {
		dwIsError =0;
	}
	return dwIsError;
}

//
//  This function returns Calls the gethostbyaddr and 
//  returns 0 if Successful and 1 if failure 
//  the return 
//
//
int ResolveHostByAddrThread(LPSTR pHost)
{
	int   iRet=0; 
	DWORD  dwThreadExitCode; 
	DWORD dwCreationFlags=0; // Start CREATE_SUSPENDED 
	DWORD ThreadId;
	RW_DEBUG << "\nResolve " << pHost << " By Address " << flush;
	HANDLE hParent = CreateThread(NULL, 
		0,
	(LPTHREAD_START_ROUTINE) GetHostByAddrThread,
	(void *) pHost,
	dwCreationFlags, 
	&ThreadId );

	DWORD dwRet = WaitForSingleObject(hParent,GET_HOST_TOUT);
	switch(dwRet) {
	case WAIT_ABANDONED :
		iRet = 1; // Error In Get Host Name 
		break;
	case WAIT_OBJECT_0 :
		RW_DEBUG << "\n\tResolved ( 1 Error, 0 Ok)  ";
		if( GetExitCodeThread(hParent,&dwThreadExitCode) ) {
			iRet = (int) dwThreadExitCode;
		
		}
		else {
			
		}
		RW_DEBUG << iRet << flush;
		break;
	case WAIT_TIMEOUT :
		RW_DEBUG << "\n\t*** Error  Resolving " << flush;
		iRet = 1; // Error In Get Host Name 
		TerminateThread(hParent,0);
		break;
	default:
		break;
	}
	return iRet;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\sysinv\resource.h ===
//-------------------------------------------------
// String Resource ID
//-------------------------------------------------
#define IDS_OEM_INIFILE                 1001
#define IDS_OEM_INISECTION              1002
#define IDS_OEM_INIKEY                  1003
#define IDS_PROCESSOR_ENTRY             1004
#define IDS_CPU_VENDOR_ENTRY            1005
#define IDS_CPU_ENTRY                   1006
#define IDS_PROCESSOR_386               1007
#define IDS_PROCESSOR_486               1008
#define IDS_PROCESSOR_PENTIUM           1009
#define IDS_PROCESSOR_MIPS_R4000        1010
#define IDS_PROCESSOR_ALPHA_21064       1011
#define IDS_SIZE_SUFFIX1                1012
#define IDS_SIZE_SUFFIX2                1013
#define IDS_PLATFORM_WIN                1014
#define IDS_PLATFORM_WINNT              1015
#define IDS_PLATFORM_WIN95              1016
#define IDS_PRODUCT_NAME                1017
#define IDS_PRODUCT_VERSION             1018
#define IDS_PRODUCT_VERSION_DISPLAY     1019
#define IDS_DRV525_0360                 1020
#define IDS_DRV525_1200                 1021
#define IDS_DRV350_0720                 1022
#define IDS_DRV350_1440                 1023
#define IDS_DRV350_2880                 1024
#define IDS_REMOVABLE_MEDIA_ENTRY       1025
#define IDS_REMOVABLE_MEDIA_VALUE       1026
#define IDS_MASS_STRORAGE_ENTRY         1027
#define IDS_OEM_INIKEY2                 1028
#define IDS_ALPHA_PROCESSOR             1029
#define IDS_ALPHA_ARCHITECTURE          1030
#define IDS_ALPHA_IDENTIFIER            1031
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwizpost\rwpost.cpp ===
/////////////////////////////////////////
//   File:          RWPost.cpp
//
//////////////////////////////////////////   

//#define STRICT
//   Include Files
//
//Modifications :
//MDX1	03/11/99  Suresh
//	In SendHTTPData() the MSID will be got from Cookie 
//	it will no longer be red from the Registry 
//
//


#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include "resource.h"
#include "Ithread.h"
#include "icw.h"
#include "util.h"
#include "tcp.h"
#include "rw_common.h"
#include "dconv.h"
#include "RwPost.h"
#include "mcm.h"
#include "ATK_RAS.h"
#include "tcp.h"
#define  CONNECTION_TIME_OUT  1000 * 60 
#define  MAX_PROXY_AUTH_RETRY  2

static CInternetThread		theInternetClass;
extern BOOL bOemDllLoaded;
extern HANDLE hOemDll;
static  DWORD dwConnectionStatus = DIALUP_NOT_REQUIRED; 

extern DWORD InvokePost(HWND hWnd,CInternetThread *p);

void InitializeInetThread(HINSTANCE hIns)
{	
	theInternetClass.Initialize(hIns);
}

//
//	Returns 
//	DIALUP_NOT_REQUIRED  : Use Network for tx
//  DIALUP_REQUIRED       : Use Dialupo for Tx  
//  RWZ_ERROR_NOTCPIP      : No TCP/IPO
//  CONNECTION_CANNOT_BE_ESTABLISHED  : No modem or RAS setup

DWORD CheckInternetConnectivityExists(HWND hWnd, HINSTANCE hInstance)
{
	static  int iAuthRetry =0; // Retry count for the number of times to invoke Proxy Auth Dlg
	static	CHAR szProxyServer[MAX_PATH];
	CHAR    szProxySettings[MAX_PATH];
	static  int   iChkInternetConnection = 0; 
	static  DWORD sdwConnectionStatus = CONNECTION_CANNOT_BE_ESTABLISHED; 
	BOOL	bNeedsReboot;
	BOOL	bRet; 
	DWORD   dwPingStatus;
	DWORD	dwError= RWZ_NOERROR;
	BOOL	bProxyExists;
	MODEMSTATUS  mStatus;
	DWORD	dwTimeOut = CONNECTION_TIME_OUT;
	int		iProxyPort;
	TCHAR	szUserName[48] = _T(""),
			szPassword[48] = _T("");
	int     iDisableAutoDial;

	iDisableAutoDial=1;

	if( sdwConnectionStatus == DIALUP_NOT_REQUIRED )
	return DIALUP_NOT_REQUIRED;
	if( sdwConnectionStatus == DIALUP_REQUIRED  )
	return DIALUP_REQUIRED;

	// Disable Auto Dial only 
	// if there are not active Dialup Connection
	//
	if( ATK_IsRasDllOk() == RAS_DLL_LOADED ) 
	{
			if( IsDialupConnectionActive() ) 
			{
				iDisableAutoDial=0;
			}
	}
	if(iDisableAutoDial) 
	{
		DisableAutoDial();// Disable the Auto Dial
	}
	// Ping Current Host to check if TCP is 
	// installed /configured.
	// 
	// if it is for the first time 

	//  RWZ_PINGSTATUS_NOTCPIP : if no socket library or get hostname fails  
	//  RWZ_PINGSTATUS_SUCCESS : if gethostname and ping is successful 
	//  RWZ_PINGSTATUS_FAIL    : if gethostname is succesful and ping via icmp fails 
	dwPingStatus = PingHost();

	RW_DEBUG  <<"\n Ping To Host (40: No TCP/IP   41: Success  42: Failure)=: "   << dwPingStatus << flush;

	if (dwPingStatus == RWZ_PINGSTATUS_NOTCPIP )
	{
		return RWZ_ERROR_NOTCPIP;
	} 
	if( dwPingStatus == RWZ_PINGSTATUS_SUCCESS ){
		bProxyExists = theInternetClass.GetSystemProxyServer(szProxyServer,MAX_PATH, &iProxyPort);
		if (1 /*bProxyExists*/) 
		{
			//theInternetClass.GetSystemProxySettings(szProxySettings,MAX_PATH);
			//theInternetClass.SetSystemProxySettings(szProxySettings);
			theInternetClass.SetSystemProxySettings("itgproxy");
			
			if(1 /*Ping(szProxyServer)*/) 
			{
				DWORD dwChkSite;
				int   iExit;
				iExit =0;
				RW_DEBUG  <<"\n Ping Success" << flush;
					theInternetClass.m_UserName[0] = _T('\0');
					theInternetClass.m_Password[0] = _T('\0');

				
				do {
					dwChkSite = ChkSiteAvailability(hWnd, theInternetClass.m_strIISServer,
						dwTimeOut,
						(LPTSTR) theInternetClass.GetProxyServer(),
						theInternetClass.m_UserName,theInternetClass.m_Password);
						
						RW_DEBUG  <<"\n After  ChkSiteAvailability : " << dwChkSite  << flush;

						if( dwChkSite == RWZ_SITE_REQUIRES_AUTHENTICATION) {
							if( iAuthRetry++ > MAX_PROXY_AUTH_RETRY) {
								iExit =1;
							}
							// Modified on 2/4/98
							// No Need to call our Proxy Auth Dlg insted use
							// InternetErrorDlg() to invoke Auth Dlg
							//if(GetProxyAuthenticationInfo(hInstance,ConvertToUnicode(szProxyServer),
							//	theInternetClass.m_UserName,theInternetClass.m_Password)) {
							//}


						}else {
							// Exit because  Connectivity is OK 
							iExit = 1;
						}
				}while(!iExit);

				if( dwChkSite == RWZ_SITE_CONNECTED)
				{
					theInternetClass.m_dwAccessType = INTERNET_OPEN_TYPE_PRECONFIG;
					// Modified on 2/4/98to use the PRECONFIGIED rather than the PROXY specified by
					// the user programatically
					// The INTERNET_OPEN_TYPE_PROXY is changed .....
					// This change is done in order for IE Auth Dlg
					dwError = DIALUP_NOT_REQUIRED;
					sdwConnectionStatus = DIALUP_NOT_REQUIRED;
					dwConnectionStatus = DIALUP_NOT_REQUIRED;
					goto ExitChk;
				}

			}

		}
		
		// No Procy so check for connection using existing LAN 
		// already opened Dialup Connection 
		// Set to NULL Proxy  
		//
				
		theInternetClass.SetProxyServer("",80);// Set it To Null 
		theInternetClass.m_dwAccessType = INTERNET_OPEN_TYPE_DIRECT;
		if( ATK_IsRasDllOk() == RAS_DLL_LOADED ) 
		{
			if( IsDialupConnectionActive() ) 
			{
				// Already Dialup COnnection is Active
				dwError = DIALUP_NOT_REQUIRED;
				sdwConnectionStatus = DIALUP_NOT_REQUIRED;
				dwConnectionStatus = DIALUP_NOT_REQUIRED;
				goto ExitChk;
			}
		}

		//
		// Check Lan Connection
		bRet = CheckHostName( ConvertToANSIString(theInternetClass.m_strIISServer));
		if(bRet)
		{
			theInternetClass.m_dwAccessType = INTERNET_OPEN_TYPE_DIRECT;
			if(ChkSiteAvailability(NULL, theInternetClass.m_strIISServer,
			dwTimeOut,
			_T(""),szUserName,szPassword)) 
			{
				dwError = DIALUP_NOT_REQUIRED;
				sdwConnectionStatus = DIALUP_NOT_REQUIRED;
				dwConnectionStatus = DIALUP_NOT_REQUIRED;
				goto ExitChk;
			}
		}

	}	

	dwError = DIALUP_REQUIRED;	
	sdwConnectionStatus = DIALUP_REQUIRED;
	dwConnectionStatus = DIALUP_NOT_REQUIRED;
	theInternetClass.m_dwAccessType = INTERNET_OPEN_TYPE_DIRECT;
	
	RW_DEBUG << "\n Before  MDMCHK..." << flush;
	//MDMCHK:
	// Install Modem
	//
	/**bNeedsReboot = theInternetClass.InstallModem(hWnd);
	if(bNeedsReboot) 
	{
			// ?????
			//  This will be abnormally terminating the Registration Wizard, 
			//  So support modem installation in  OS which dosent call for a reboot
	}
	**/
	mStatus = MSDetectModemTAPI(hInstance);
	if(mStatus != kMsModemOk ) 
	{
			dwError = CONNECTION_CANNOT_BE_ESTABLISHED;
			sdwConnectionStatus = CONNECTION_CANNOT_BE_ESTABLISHED;
	}

	if(dwError == DIALUP_REQUIRED ) 
	{
		// Load RASPAI32.DLL and Exit if it can not be loaded
		if( ATK_IsRasDllOk() != RAS_DLL_LOADED ) 
		{
			//
			dwError = CONNECTION_CANNOT_BE_ESTABLISHED;
			sdwConnectionStatus = CONNECTION_CANNOT_BE_ESTABLISHED;
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n RASAPI32.DLL NOT FOUND ...";
			#endif
		}
	}

ExitChk:
	#ifdef _LOG_IN_FILE
		RW_DEBUG  <<"\n Chk Connection ( 1 = via NTWK, 2 = DIalup , 3 = Problem) "   << dwError << flush;
	#endif
	theInternetClass.UnLoadInetCfgDll();
	return dwError;


}

//
//	Returns 
//	DIALUP_NOT_REQUIRED  : Use Network for tx
//  DIALUP_REQUIRED       : Use Dialupo for Tx  
//  RWZ_ERROR_NOTCPIP      : No TCP/IPO
//  CONNECTION_CANNOT_BE_ESTABLISHED  : No modem or RAS setup

DWORD CheckInternetConnectivityExistsOldLogic(HWND hWnd, HINSTANCE hInstance)
{
	static  int iAuthRetry =0; // Retry count for the number of times to invoke Proxy Auth Dlg
	static	CHAR szProxyServer[MAX_PATH];
	CHAR    szProxySettings[MAX_PATH];
	static  int   iChkInternetConnection = 0; 
	static  DWORD sdwConnectionStatus = CONNECTION_CANNOT_BE_ESTABLISHED; 
	BOOL	bNeedsReboot;
	BOOL	bRet; 
	DWORD   dwPingStatus;
	DWORD	dwError= RWZ_NOERROR;
	BOOL	bProxyExists;
	MODEMSTATUS  mStatus;
	DWORD	dwTimeOut = CONNECTION_TIME_OUT;
	int		iProxyPort;
	TCHAR	szUserName[48] = _T(""),
			szPassword[48] = _T("");
	int     iDisableAutoDial;

	iDisableAutoDial=1;

	if( sdwConnectionStatus == DIALUP_NOT_REQUIRED )
	return DIALUP_NOT_REQUIRED;
	if( sdwConnectionStatus == DIALUP_REQUIRED  )
	return DIALUP_REQUIRED;

	// Disable Auto Dial only 
	// if there are not active Dialup Connection
	//
	if( ATK_IsRasDllOk() == RAS_DLL_LOADED ) 
	{
			if( IsDialupConnectionActive() ) 
			{
				iDisableAutoDial=0;
			}
	}
	if(iDisableAutoDial) 
	{
		DisableAutoDial();// Disable the Auto Dial
	}
	// Ping Current Host to check if TCP is 
	// installed /configured.
	// 
	// if it is for the first time 

	//  RWZ_PINGSTATUS_NOTCPIP : if no socket library or get hostname fails  
	//  RWZ_PINGSTATUS_SUCCESS : if gethostname and ping is successful 
	//  RWZ_PINGSTATUS_FAIL    : if gethostname is succesful and ping via icmp fails 
	dwPingStatus = PingHost();

	RW_DEBUG  <<"\n Ping To Host (40: No TCP/IP   41: Success  42: Failure)=: "   << dwPingStatus << flush;

	if (dwPingStatus == RWZ_PINGSTATUS_NOTCPIP )
	{
		return RWZ_ERROR_NOTCPIP;
	} 
	if( dwPingStatus == RWZ_PINGSTATUS_SUCCESS ){
		bProxyExists = theInternetClass.GetSystemProxyServer(szProxyServer,MAX_PATH, &iProxyPort);
		if (bProxyExists) 
		{
			theInternetClass.GetSystemProxySettings(szProxySettings,MAX_PATH);
			theInternetClass.SetSystemProxySettings(szProxySettings);
			
			
			if(Ping(szProxyServer)) 
			{
				DWORD dwChkSite;
				int   iExit;
				iExit =0;
				RW_DEBUG  <<"\n Ping Success" << flush;
					theInternetClass.m_UserName[0] = _T('\0');
					theInternetClass.m_Password[0] = _T('\0');

				
				do {
					dwChkSite = ChkSiteAvailability(hWnd, theInternetClass.m_strIISServer,
						dwTimeOut,
						(LPTSTR) theInternetClass.GetProxyServer(),
						theInternetClass.m_UserName,theInternetClass.m_Password);
						
						RW_DEBUG  <<"\n After  ChkSiteAvailability : " << dwChkSite  << flush;

						if( dwChkSite == RWZ_SITE_REQUIRES_AUTHENTICATION) {
							if( iAuthRetry++ > MAX_PROXY_AUTH_RETRY) {
								iExit =1;
							}
							// Modified on 2/4/98
							// No Need to call our Proxy Auth Dlg insted use
							// InternetErrorDlg() to invoke Auth Dlg
							//if(GetProxyAuthenticationInfo(hInstance,ConvertToUnicode(szProxyServer),
							//	theInternetClass.m_UserName,theInternetClass.m_Password)) {
							//}


						}else {
							// Exit because  Connectivity is OK 
							iExit = 1;
						}
				}while(!iExit);

				if( dwChkSite == RWZ_SITE_CONNECTED)
				{
					theInternetClass.m_dwAccessType = INTERNET_OPEN_TYPE_PRECONFIG;
					// Modified on 2/4/98to use the PRECONFIGIED rather than the PROXY specified by
					// the user programatically
					// The INTERNET_OPEN_TYPE_PROXY is changed .....
					// This change is done in order for IE Auth Dlg
					dwError = DIALUP_NOT_REQUIRED;
					sdwConnectionStatus = DIALUP_NOT_REQUIRED;
					dwConnectionStatus = DIALUP_NOT_REQUIRED;
					goto ExitChk;
				}

			}

		}
		
		// No Procy so check for connection using existing LAN 
		// already opened Dialup Connection 
		// Set to NULL Proxy  
		//
				
		theInternetClass.SetProxyServer("",80);// Set it To Null 
		theInternetClass.m_dwAccessType = INTERNET_OPEN_TYPE_DIRECT;
		if( ATK_IsRasDllOk() == RAS_DLL_LOADED ) 
		{
			if( IsDialupConnectionActive() ) 
			{
				// Already Dialup COnnection is Active
				dwError = DIALUP_NOT_REQUIRED;
				sdwConnectionStatus = DIALUP_NOT_REQUIRED;
				dwConnectionStatus = DIALUP_NOT_REQUIRED;
				goto ExitChk;
			}
		}

		//
		// Check Lan Connection
		bRet = CheckHostName( ConvertToANSIString(theInternetClass.m_strIISServer));
		if(bRet)
		{
			theInternetClass.m_dwAccessType = INTERNET_OPEN_TYPE_DIRECT;
			if(ChkSiteAvailability(NULL, theInternetClass.m_strIISServer,
			dwTimeOut,
			_T(""),szUserName,szPassword)) 
			{
				dwError = DIALUP_NOT_REQUIRED;
				sdwConnectionStatus = DIALUP_NOT_REQUIRED;
				dwConnectionStatus = DIALUP_NOT_REQUIRED;
				goto ExitChk;
			}
		}

	}	

	dwError = DIALUP_REQUIRED;	
	sdwConnectionStatus = DIALUP_REQUIRED;
	dwConnectionStatus = DIALUP_NOT_REQUIRED;
	theInternetClass.m_dwAccessType = INTERNET_OPEN_TYPE_DIRECT;
	
	RW_DEBUG << "\n Before  MDMCHK..." << flush;
//MDMCHK:
	// Install Modem
	//
	bNeedsReboot = theInternetClass.InstallModem(hWnd);
	if(bNeedsReboot) 
	{
			// ?????
			//  This will be abnormally terminating the Registration Wizard, 
			//  So support modem installation in  OS which dosent call for a reboot
	}

	mStatus = MSDetectModemTAPI(hInstance);
	if(mStatus != kMsModemOk ) 
	{
			dwError = CONNECTION_CANNOT_BE_ESTABLISHED;
			sdwConnectionStatus = CONNECTION_CANNOT_BE_ESTABLISHED;
	}

	if(dwError == DIALUP_REQUIRED ) 
	{
		// Load RASPAI32.DLL and Exit if it can not be loaded
		if( ATK_IsRasDllOk() != RAS_DLL_LOADED ) 
		{
			//
			dwError = CONNECTION_CANNOT_BE_ESTABLISHED;
			sdwConnectionStatus = CONNECTION_CANNOT_BE_ESTABLISHED;
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n RASAPI32.DLL NOT FOUND ...";
			#endif
		}
	}

ExitChk:
	#ifdef _LOG_IN_FILE
		RW_DEBUG  <<"\n Chk Connection ( 1 = via NTWK, 2 = DIalup , 3 = Problem) "   << dwError << flush;
	#endif
	theInternetClass.UnLoadInetCfgDll();
	return dwError;


}


DWORD SendHTTPData(HWND hWnd, HINSTANCE hInstance)
{
	char czB [MAX_BUFFER + 1]; // Buffer for Tx
	DWORD dwBufSize = MAX_BUFFER;
	DWORD dwOemBufSize;
	DWORD dwRet;
	_TCHAR szValue[256];


	DWORD	dwTimeOut = CONNECTION_TIME_OUT;

	// MDX : 03/11/99 
	// Get MSID From Cookie , No need to check from Registry
	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n*******Getting Cookie********\n"<< flush;
	#endif
	if(dwConnectionStatus == DIALUP_REQUIRED){
			ChkSiteAvailability(hWnd, theInternetClass.m_strIISServer,
				dwTimeOut,
				NULL,
				theInternetClass.m_UserName,
				theInternetClass.m_Password);
	}
	else{
		ChkSiteAvailability(hWnd, theInternetClass.m_strIISServer,
				dwTimeOut,
				(LPTSTR) theInternetClass.GetProxyServer(),
				theInternetClass.m_UserName,
				theInternetClass.m_Password);
	}

	SetMSID(hInstance);
	
	
	dwRet  = PrepareRegWizTxbuffer(hInstance, czB, &dwBufSize);
	dwOemBufSize = MAX_BUFFER - dwBufSize;
	dwRet  = OemTransmitBuffer(hInstance,czB + dwBufSize,&dwOemBufSize);
	dwBufSize += dwOemBufSize;

	switch(dwRet) 
	{
		case  RWZ_NOERROR:
			theInternetClass.SetBuffer(czB, dwBufSize+1);
			theInternetClass.SetSSLFlag(TRUE);
			dwRet = theInternetClass.PostData(hWnd);
			// dwRet = InvokePost(hWnd, &theInternetClass);

			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n PostData() returned: "<<dwRet << flush;
			#endif

			if( dwRet == RWZ_POST_FAILURE  ||  dwRet == RWZ_POST_WITH_SSL_FAILURE)
			{
				// Try posting without SSL only for the modem
				//if(dwConnectionStatus == DIALUP_REQUIRED)
				//{
					#ifdef _LOG_IN_FILE
						RW_DEBUG << "\n Posting Failure : Sending Data without SSL" << flush;
					#endif
					theInternetClass.SetSSLFlag(FALSE);
					dwRet = theInternetClass.PostData(hWnd);
					//dwRet = InvokePost(hWnd, &theInternetClass);
				//}
			}
			#ifdef _LOG_IN_FILE
				RW_DEBUG  << "\n Success ... \t"  << dwRet << flush;
				RW_DEBUG   <<"\n\n\nBuffer\t\t*[" << czB << "]" << flush;
			#endif
			break;
		case  RWZ_NO_INFO_AVAILABLE :
			#ifdef _LOG_IN_FILE
				RW_DEBUG  << _T("\n No Info Available ")  << flush;
			#endif
			break;
		case  RWZ_INVALID_INFORMATION :
			#ifdef _LOG_IN_FILE
				RW_DEBUG  << _T("\n Invalid Info  " ) << flush;
			#endif
			break;
		case  RWZ_BUFFER_SIZE_INSUFFICIENT :
			#ifdef _LOG_IN_FILE
				RW_DEBUG  <<_T("\n Buffer Length In Sufficient ...") << dwRet;
				RW_DEBUG   <<_T("\n\n\nBuffer\t\t") << czB;
			#endif
			break;
		case    RWZ_INTERNAL_ERROR	 :
			#ifdef _LOG_IN_FILE
				RW_DEBUG  << _T("\n Internal Error ....") ;
			#endif
		default:
			break;
	}
	#ifdef _LOG_IN_FILE
		RW_DEBUG  << flush;
	#endif
	return dwRet;
}


/*DWORD PostHTTPData(HINSTANCE hInstance)
{
	DWORD dwRet = RWZ_POST_FAILURE;
	DWORD dwRetStatus;

	dwRetStatus = CheckWithDisplayInternetConnectivityExists(hInstance,2);

	switch (dwRetStatus)
	{
	case DIALUP_NOT_REQUIRED  :
		if ((dwRet =  PostDataWithWindowMessage(hInstance)) 
				== RWZ_POST_SUCCESS){
			;
		}
		else {
		}
		break;
	case DIALUP_REQUIRED      :
		 dwRet=DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_DIAL), NULL,FDlgProc,
			 (LPARAM)hInstance);
		 if(dwRet == -1 ) {
			 // Error in creating the Dialogue

		 }
		switch ( dwRet)  {
		case RWZ_ERROR_LOCATING_MSN_FILES :
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n Signup :Error Locating MSN File " << flush;
			#endif
			break;
		case RWZ_ERROR_LOCATING_DUN_FILES   :
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n Signup :Error Locating DUN File " << flush;
			#endif
			break;
		case RWZ_ERROR_MODEM_IN_USE :
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n Signup :Error Modem Already in use by another Application " << flush;
			#endif
			break;
		case RWZ_ERROR_MODEM_CFG_ERROR:
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n Signup :Modem Configuration Error " << flush;
			#endif
		case RWZ_ERROR_TXFER_CANCELLED_BY_USER :
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n Signup     :HTTP Post Cancelled by User  " << flush;
			#endif
			break;
		case RWZ_ERROR_SYSTEMERROR :
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n Signup     : System Resource Allocation Error  " << flush;
			#endif
			break;
		case RWZ_ERROR_NODIALTONE :
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n Signup     : Modem Error No Dialtone " << flush;
			#endif
			break;
		default :
			break;
		}

				 
		
	case  CONNECTION_CANNOT_BE_ESTABLISHED  :
	default :
		// It is unexpected . ? to Do
	
	break;
	
	}
	return dwRet;
}
**/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\res\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RegWizCtrl.rc
//
#define IDS_KEY1                        1
#define IDS_KEY2                        2
#define IDS_KEY3                        3
#define IDS_KEY4                        4
#define IDS_INFOKEY1                    5
#define IDS_INFOKEY2                    6
#define IDS_INFOKEY3                    7
#define IDS_INFOKEY4                    8
#define IDS_INFOKEY5                    9
#define IDS_INFOKEY6                    10
#define IDS_INFOKEY7                    11
#define IDS_INFOKEY8                    12
#define IDS_INFOKEY9                    13
#define IDS_INFOKEY10                   14
#define IDS_INFOKEY11                   15
#define IDS_INFOKEY12                   16
#define IDS_INFOKEY13                   17
#define IDS_INFOKEY14                   18
#define IDS_INFOKEY15                   19
#define IDS_INFOKEY16                   20
#define IDS_INFOKEY17                   21
#define IDS_INFOKEY18                   22
#define IDS_INFOKEY19                   23
#define IDS_INFOKEY20                   24
#define IDS_INFOKEY21                   25
#define IDS_INFOKEY22                   26
#define IDS_INFOKEY23                   27
#define IDS_INFOKEY24                   28
#define IDS_INFOKEY25                   29
#define IDS_INFOKEY26                   30
#define IDS_INFOKEY27                   31
#define IDS_INFOKEY28                   32
#define IDS_INFOKEY29                   33
#define IDS_INFOKEY30                   34
#define IDS_INFOKEY31                   35
#define IDS_INFOKEY32                   36
#define IDS_INFOKEY33                   37
#define IDS_INFOKEY34                   38
#define IDS_INFOKEY35                   39
#define IDS_INFOKEY36                   40
#define IDS_INFOKEY37                   41
#define IDS_INFOKEY38                   42
#define IDS_INFOKEY39                   43
#define IDS_INFOKEY40                   44
#define IDS_INFOKEY41                   45
#define IDS_PROCESSOR_386               47
#define IDS_PROCESSOR_486               48
#define IDS_PROCESSOR_PENTIUM           49
#define IDS_PROCESSOR_MIPS_R2000        50
#define IDS_PROCESSOR_MIPS_R3000        51
#define IDS_PROCESSOR_MIPS_R4000        52
#define IDS_PROCESSOR_ALPHA_21064       53
#define IDS_PROCESSOR_860               54
#define IDS_SIZE_SUFFIX1                55
#define IDS_INVENTORY1                  56
#define IDS_INVENTORY2                  57
#define IDS_INVENTORY3                  58
#define IDS_INVENTORY4                  59
#define IDS_INVENTORY5                  60
#define IDS_INVENTORY6                  61
#define IDS_INVENTORY7                  62
#define IDS_INVENTORY8                  63
#define IDS_INVENTORY9                  64
#define IDS_INVENTORY10                 65
#define IDS_INVENTORY11                 66
#define IDS_INVENTORY12                 67
#define IDS_INVENTORY13                 68
#define IDS_SIZE_SUFFIX2                69
#define IDS_PLATFORM_WIN                79
#define IDS_PLATFORM_WINNT              80
#define IDS_PLATFORM_WIN95              81
#define IDS_PRODUCTBASEKEY              82
#define IDS_INPUT_PRODUCTNAME           83
#define IDS_INPUT_PRODUCTID             84
#define IDS_INPUT_INVENTORYPATH         85
#define IDS_INPUT_ISREGISTERED          86
#define IDS_CNTRY_MAXCODE               87
#define IDS_CNTRY_UNIQUECOUNT           88
#define IDS_BAD_PREFIX                  89
#define IDS_BAD_FIRSTNAME               90
#define IDS_BAD_LASTNAME                91
#define IDS_BAD_ADDRESS                 92
#define IDS_BAD_ADDRESS2                93
#define IDS_BAD_COMPANY                 94
#define IDS_BAD_CITY                    95
#define IDS_BAD_STATE                   96
#define IDS_BAD_POSTALCODE              97
#define IDS_BAD_PHONE                   98
#define IDS_BAD_SYSINV                  100
#define IDD_WELCOME                     101
#define IDS_BAD_PRODINV                 101
#define IDT_TEXT1                       102
#define IDDIAL                          102
#define IDT_TEXT2                       103
#define IDT_TEXT3                       104
#define IDB_BITMAP1                     104
#define IDT_TEXT4                       105
#define IDB_BITMAP2                     105
#define IDT_TEXT5                       106
#define IDD_NAME                        106
#define IDD_ADDRESS                     107
#define IDT_TEXT13                      107
#define IDT_TEXT7                       108
#define IDD_PID                         108
#define IDT_TEXT14                      108
#define IDT_TEXT8                       109
#define IDD_INVENTORY                   109
#define IDD_PRODINVENTORY               110
#define IDT_TEXT10                      110
#define IDD_REGISTER                    111
#define IDT_TEXT12                      111
#define IDB_BITMAP3                     113
#define IDI_REGWIZ                      117
#define IDD_CANCEL                      118
#define IDD_INPUTPARAM_ERR              121
#define IDC_ICON1                       122
#define IDI_BADREGWIZ                   122
#define IDD_MODEM_ERR                   122
#define IDB_SYSINV_ICONS                123
#define IDD_NOMODEM                     124
#define IDD_SIGNUP_ERR                  125
#define IDD_ALREADY_REGISTERED          126
#define IDB_BITMAP4                     126
#define IDI_WORLD                       127
#define IDD_INVALID_DLG                 127
#define IDB_BITMAP5                     128
#define IDD_MODEM_TOO_SLOW              128
#define IDI_ENVELOPE                    129
#define IDD_LOGFILE_QUERY               129
#define IDD_RESELLER                    130
#define IDS_ADDRDLG_TEXT1A              132
#define IDS_ADDRDLG_TEXT1B              133
#define IDS_ADDRDLG_TEXT2A              134
#define IDS_ADDRDLG_TEXT2B              135
#define IDS_WELCDLG_TEXT2A              136
#define IDS_WELCDLG_TEXT2B              137
#define IDS_PROJNAME                    150
#define IDR_REGWIZCTRL                  151
#define IDD_DIALUP_ERROR                160
#define IDD_RAS_ERROR                   161
#define IDB_WORLD                       201
#define IDD_VERIFY_CONNECTION           202
#define IDD_POST_ERROR                  203
#define IDD_SUCCESSFUL_REGISTRATION     204
#define IDD_WELCOME_FOR98               205
#define IDR_ACCELERATOR                 206
#define IDD_POST_PROBLEM                207
#define IDD_CFG_PROBLEM                 208
#define IDD_PROXY_LOG                   209
#define IDD_CONNECTION_STSTUS           210
#define IDD_CONNECTION_STATUS           210
#define IDD_PROXY_CFG                   211
#define IDD_MODEM_CFG_ERROR             212
#define IDD_NETWORK_CFG_ERROR           214
#define IDD_ANOTHERCOPY_ERROR           215
#define IDB_BANNER                      217
#define IDB_WATERMARK                   218
#define IDD_ERROR_INVALIDBINARY         219
#define IDD_ADDRESS_FE                  220
#define IDD_NAME_FE                     221
#define IDI_SIICON1                     222
#define IDI_SIICON2                     223
#define IDI_SIICON3                     224
#define IDI_SIICON4                     225
#define IDI_SIICON5                     226
#define IDI_SIICON6                     227
#define IDI_SIICON7                     228
#define IDI_SIICON8                     229
#define IDI_SIICON9                     230
#define IDI_SIICON10                    231
#define IDI_SIICON11                    232
#define IDI_SIICON12                    233
#define IDI_SIICON13                    234
#define IDI_SIICON14                    235
#define IDI_SIICON15                    236
#define IDI_SIICON16                    237
#define IDI_SIICON17                    238
#define IDI_SIICON18                    239
#define IDI_SIICON19                    240
#define IDI_SIICON20                    241
#define IDI_SIICONLAST                  249
#define IDI_DIALUP                      250
#define IDD_FAILURE_REGISTRATION        255
#define idh_installmodemyes             410
#define idh_installmodemno              411
#define IDT_TEXT11                      500
#define IDD_DIAL                        501
#define ID_LABELDIAL                    502
#define IDD_ADDRESSEMAIL                503
#define IDD_INFORM                      504
#define ID_LABELCONNECT                 505
#define IDD_HOME_QUESTIONS              506
#define ID_LABELCANCEL                  507
#define IDD_BUSINESS_QUESTIONS          508
#define ID_LABELCANCELLING              509
#define ID_LABELDISCONNECT              510
#define ID_LABELTRANSFER                511
#define ID_LABELINIT                    512
#define ID_LABELTRANSFERDONE            513
#define ID_LABELPHONEDONE               514
#define ID_LABELTASKFILE                515
#define ID_LABELTASKPHONE               516
#define ID_LABELCALLONE                 517
#define ID_LABELNUMBER                  518
#define ID_BTNSETTINGS                  519
#define IDC_DISCONNECT                  520
#define IDB_BACK                        1000
#define IDB_NEXT                        1001
#define IDB_EXIT                        1002
#define IDC_EDIT1                       1005
#define IDC_EDIT2                       1006
#define IDC_EDIT3                       1007
#define IDC_EDIT4                       1008
#define IDC_EDIT5                       1009
#define IDC_EDIT6                       1010
#define IDC_EDIT7                       1011
#define IDT_TEXT9                       1012
#define IDC_CHECK1                      1013
#define IDC_RADIO1                      1015
#define IDC_RADIO2                      1016
#define IDC_GROUP1                      1017
#define IDC_GROUP2                      1018
#define IDC_PICTFRAME                   1019
#define IDC_LIST1                       1021
#define IDC_STATIC1                     1022
#define IDC_COMBO1                      1023
#define IDB_YES                         1024
#define IDB_NO                          1025
#define IDT_VERSION                     1026
#define IDB_CANCEL                      1026
#define IDT_TEXT6                       1027
#define IDC_ETCHEDLINE                  1028
#define IDC_ETCHEDLINE2                 1029
#define IDC_ENVELOPE                    1030
#define IDC_WORLD                       1031
#define IDC_TEXT1                       1033
#define IDC_TITLE                       1034
#define IDC_SUBTITLE                    1035
#define IDT_SUBTITLE                    1036
#define IDB_REG_LATER                   1037
#define IDC_TEXT3                       1038
#define IDC_MSN_TEXT1                   1039
#define IDC_MSN_TEXT2                   1040
#define IDC_BUTTON1                     1041
#define IDEND                           1041
#define IDC_INCENTIVE                   1042
#define IDC_TEXT5                       1043
#define IDC_TEXT4                       1044
#define IDC_TEXT6                       1045
#define IDC_EDIT8                       1046
#define IDC_TEXT7                       1046
#define IDC_TEXT9                       1047
#define IDC_TEXT8                       1047
#define IDC_USERNAME                    1048
#define IDC_TEXT10                      1048
#define IDC_PASSWORD                    1049
#define IDC_TEXT11                      1049
#define IDC_EDIT9                       1049
#define IDC_CHECK2                      1050
#define IDC_TEXT12                      1050
#define IDC_CHECK3                      1051
#define IDC_CHECK6                      1052
#define IDC_CHECK7                      1053
#define IDC_CHECK4                      1054
#define IDC_MODEM_NAME                  1054
#define IDC_CHECK5                      1055
#define IDC_AREACODE                    1055
#define IDC_CHECK8                      1056
#define IDT_AREACODE                    1056
#define IDT_DIVISION                    1057
#define IDC_DIVISION                    1058
#define IDT_USERID                      1059
#define IDC_USERID                      1060
#define IDC_LIST2                       1067
#define IDC_LIST4                       1069
#define IDC_LIST5                       1070
#define IDC_COMBO2                      1072
#define IDC_COMPUTER_MODEL              1075
#define IDC_PHONENUMBER                 1077
#define IDC_TEXT2                       1078
#define IDC_ERROR                       1079
#define IDC_YESNOGRP                    1080
#define iszLoginKey                     2000
#define IDS_CURRENTCOMMDEV              2001
#define iszLocations                    2002
#define iszUserInfo                     2003
#define iszPref                         2004
#define iszComPort                      2005
#define iszBaud                         2006
#define iszMarvelError                  2007
#define IDS_ERRORTITLE                  2008
#define IDS_TIMEOUTRANGE                2009
#define IDS_EMPTYPASSWORD               2010
#define IDS_NOTSAMEPASSWORD             2011
#define IDS_INVALIDPASSWORD             2012
#define IDS_CHANGEDPASSWORD             2013
#define IDS_GUIDEEXENAME                2014
#define IDS_MARVEL                      2015
#define IDS_ADDMODEMCOMMAND             2016
#define IDS_ADDMODEMERROR               2017
#define IDS_DIALINGPROPERTIES           2017
#define IDS_ADDMODEMERROR_V             2018
#define IDS_INVALIDNEWPASSWORD          2019
#define IDS_PHONENO                     2020
#define IDS_BACKUPPHONENO               2021
#define IDS_SETUPMARVELKEY              2022
#define IDS_NOTAPIERROR                 2023
#define IDS_MODEMTOOSLOW                2024
#define IDS_TAPIINIFILECORRUPT          2025
#define IDS_WINCURRENT                  2026
#define IDS_REGOWNER                    2027
#define IDS_REGORG                      2028
#define IDS_SIGNUPLOC_KEY               2029
#define IDS_SYSINV_NOTFOUND             2038
#define IDS_YES                         2039
#define IDS_NO                          2040
#define IDS_OEM_INIFILE                 2045
#define IDS_OEM_INISECTION              2046
#define IDS_OEM_INIKEY                  2047
#define IDS_DRV525_0360                 2048
#define IDS_DRV525_1200                 2049
#define IDS_DRV350_0720                 2050
#define IDS_DRV350_1440                 2051
#define IDS_DRV350_2880                 2052
#define IDS_MAKERCOMPANY                2053
#define IDS_SIGNUPLOC_VALUENAME         2054
#define IDS_SIGNUPLOC_FILENAME          2055
#define IDS_CNTRY_DEFAULT               2056
#define IDS_CNTRY_AFGHANISTAN           2057
#define IDS_CNTRY_ALBANIA               2058
#define IDS_CNTRY_ALGERIA               2059
#define IDS_CNTRY_AMERICAN_SAMOA        2060
#define IDS_CNTRY_ANDORRA               2061
#define IDS_CNTRY_ANGOLA                2062
#define IDS_CNTRY_ANGUILLA              2063
#define IDS_CNTRY_ANTIGUA               2064
#define IDS_CNTRY_ARGENTINA             2065
#define IDS_CNTRY_ARMENIA               2066
#define IDS_CNTRY_ARUBA                 2067
#define IDS_CNTRY_ASCENSION_ISLAND      2068
#define IDS_CNTRY_AUSTRALIA             2069
#define IDS_CNTRY_AUSTRALIAN_ANTARCTIC_TERRITORY 2070
#define IDS_CNTRY_AUSTRIA               2071
#define IDS_CNTRY_AZERBAIJAN            2072
#define IDS_CNTRY_BAHAMAS               2073
#define IDS_CNTRY_BAHRAIN               2074
#define IDS_CNTRY_BANGLADESH            2075
#define IDS_CNTRY_BARBADOS              2076
#define IDS_CNTRY_BARBUDA               2077
#define IDS_CNTRY_BELARUS               2078
#define IDS_CNTRY_BELGIUM               2079
#define IDS_CNTRY_BELIZE                2080
#define IDS_CNTRY_BENIN                 2081
#define IDS_CNTRY_BERMUDA               2082
#define IDS_CNTRY_BHUTAN                2083
#define IDS_CNTRY_BOLIVIA               2084
#define IDS_CNTRY_BOSNIA_AND_HERZEGOVINA 2085
#define IDS_CNTRY_BOTSWANA              2086
#define IDS_CNTRY_BRAZIL                2087
#define IDS_CNTRY_BRITISH_VIRGIN_ISLANDS 2088
#define IDS_CNTRY_BRUNEI                2089
#define IDS_CNTRY_BULGARIA              2090
#define IDS_CNTRY_BURKINA_FASO          2091
#define IDS_CNTRY_BURUNDI               2092
#define IDS_CNTRY_CAMEROON              2093
#define IDS_CNTRY_CANADA                2094
#define IDS_CNTRY_CAPE_VERDE_ISLANDS    2095
#define IDS_CNTRY_CAYMAN_ISLANDS        2096
#define IDS_CNTRY_CENTRAL_AFRICAN_REPUBLIC 2097
#define IDS_CNTRY_CHAD                  2098
#define IDS_CNTRY_CHILE                 2099
#define IDS_CNTRY_CHINA                 2100
#define IDS_CNTRY_CHRISTMAS_ISLAND      2101
#define IDS_CNTRY_COCOS_KEELING_ISLANDS 2102
#define IDS_CNTRY_COLOMBIA              2103
#define IDS_CNTRY_COMOROS               2104
#define IDS_CNTRY_CONGO                 2105
#define IDS_CNTRY_COOK_ISLANDS          2106
#define IDS_CNTRY_COSTA_RICA            2107
#define IDS_CNTRY_CROATIA               2108
#define IDS_CNTRY_CUBA                  2109
#define IDS_CNTRY_CYPRUS                2110
#define IDS_CNTRY_CZECH_REPUBLIC        2111
#define IDS_CNTRY_DENMARK               2112
#define IDS_CNTRY_DIEGO_GARCIA          2113
#define IDS_CNTRY_DJIBOUTI              2114
#define IDS_CNTRY_DOMINICA              2115
#define IDS_CNTRY_DOMINICAN_REPUBLIC    2116
#define IDS_CNTRY_ECUADOR               2117
#define IDS_CNTRY_EGYPT                 2118
#define IDS_CNTRY_EL_SALVADOR           2119
#define IDS_CNTRY_EQUATORIAL_GUINEA     2120
#define IDS_CNTRY_ESTONIA               2121
#define IDS_CNTRY_ETHIOPIA              2122
#define IDS_CNTRY_FAEROE_ISLANDS        2123
#define IDS_CNTRY_FALKLAND_ISLANDS      2124
#define IDS_CNTRY_FIJI_ISLANDS          2125
#define IDS_CNTRY_FINLAND               2126
#define IDS_CNTRY_FRANCE                2127
#define IDS_CNTRY_FRENCH_ANTILLES       2128
#define IDS_CNTRY_FRENCH_GUIANA         2129
#define IDS_CNTRY_FRENCH_POLYNESIA      2130
#define IDS_CNTRY_GABON                 2131
#define IDS_CNTRY_GAMBIA                2132
#define IDS_CNTRY_GEORGIA               2133
#define IDS_CNTRY_GERMANY               2134
#define IDS_CNTRY_GHANA                 2135
#define IDS_CNTRY_GIBRALTAR             2136
#define IDS_CNTRY_GREECE                2137
#define IDS_CNTRY_GREENLAND             2138
#define IDS_CNTRY_GRENADA               2139
#define IDS_CNTRY_GUADELOUPE            2140
#define IDS_CNTRY_GUAM                  2141
#define IDS_CNTRY_GUANTANAMO_BAY        2142
#define IDS_CNTRY_GUATEMALA             2143
#define IDS_CNTRY_GUINEA                2144
#define IDS_CNTRY_GUINEA_BISSAU         2145
#define IDS_CNTRY_GUYANA                2146
#define IDS_CNTRY_HAITI                 2147
#define IDS_CNTRY_HONDURAS              2148
#define IDS_CNTRY_HONG_KONG             2149
#define IDS_CNTRY_HUNGARY               2150
#define IDS_CNTRY_ICELAND               2151
#define IDS_CNTRY_INDIA                 2152
#define IDS_CNTRY_INDONESIA             2153
#define IDS_CNTRY_INMARSAT_ATLANTIC_EAST 2154
#define IDS_CNTRY_INMARSAT_ATLANTIC_WEST 2155
#define IDS_CNTRY_INMARSAT_INDIAN       2156
#define IDS_CNTRY_INMARSAT_PACIFIC      2157
#define IDS_CNTRY_IRAN                  2158
#define IDS_CNTRY_IRAQ                  2159
#define IDS_CNTRY_IRELAND               2160
#define IDS_CNTRY_ISRAEL                2161
#define IDS_CNTRY_ITALY                 2162
#define IDS_CNTRY_IVORY_COAST           2163
#define IDS_CNTRY_JAMAICA               2164
#define IDS_CNTRY_JAPAN                 2165
#define IDS_CNTRY_JORDAN                2166
#define IDS_CNTRY_KAZAKHSTAN            2167
#define IDS_CNTRY_KENYA                 2168
#define IDS_CNTRY_CAMBODIA              2169
#define IDS_CNTRY_KIRIBATI_REPUBLIC     2170
#define IDS_CNTRY_KOREA_NORTH           2171
#define IDS_CNTRY_KOREA_SOUTH           2172
#define IDS_CNTRY_KUWAIT                2173
#define IDS_CNTRY_KYRGYZSTAN            2174
#define IDS_CNTRY_LAOS                  2175
#define IDS_CNTRY_LATVIA                2176
#define IDS_CNTRY_LEBANON               2177
#define IDS_CNTRY_LESOTHO               2178
#define IDS_CNTRY_LIBERIA               2179
#define IDS_CNTRY_LIBYA                 2180
#define IDS_CNTRY_LIECHTENSTEIN         2181
#define IDS_CNTRY_LITHUANIA             2182
#define IDS_CNTRY_LUXEMBOURG            2183
#define IDS_CNTRY_MACAO                 2184
#define IDS_CNTRY_FORMER_YUGOSLAV_REPUBLIC_OF_MACEDONIA 2185
#define IDS_CNTRY_MADAGASCAR            2186
#define IDS_CNTRY_MALAWI                2187
#define IDS_CNTRY_MALAYSIA              2188
#define IDS_CNTRY_MALDIVES              2189
#define IDS_CNTRY_MALI                  2190
#define IDS_CNTRY_MALTA                 2191
#define IDS_CNTRY_MARSHALL_ISLANDS      2192
#define IDS_CNTRY_MARTINIQUE            2193
#define IDS_CNTRY_MAURITANIA            2194
#define IDS_CNTRY_MAURITIUS             2195
#define IDS_CNTRY_MAYOTTE_ISLAND        2196
#define IDS_CNTRY_MEXICO                2197
#define IDS_CNTRY_MICRONESIA            2198
#define IDS_CNTRY_MOLDOVA               2199
#define IDS_CNTRY_MONACO                2200
#define IDS_CNTRY_MONGOLIA              2201
#define IDS_CNTRY_MONTSERRAT            2203
#define IDS_CNTRY_MOROCCO               2204
#define IDS_CNTRY_MOZAMBIQUE            2205
#define IDS_CNTRY_MYANMAR               2206
#define IDS_CNTRY_NAMIBIA               2207
#define IDS_CNTRY_NAURU                 2208
#define IDS_CNTRY_NEPAL                 2209
#define IDS_CNTRY_NETHERLANDS           2210
#define IDS_CNTRY_NETHERLANDS_ANTILLES  2211
#define IDS_CNTRY_NEVIS                 2212
#define IDS_CNTRY_NEW_CALEDONIA         2213
#define IDS_CNTRY_NEW_ZEALAND           2214
#define IDS_CNTRY_NICARAGUA             2215
#define IDS_CNTRY_NIGER                 2216
#define IDS_CNTRY_NIGERIA               2217
#define IDS_CNTRY_NIUE                  2218
#define IDS_CNTRY_NORFOLK_ISLAND        2219
#define IDS_CNTRY_ERITREA               2220
#define IDS_CNTRY_NORWAY                2221
#define IDS_CNTRY_OMAN                  2222
#define IDS_CNTRY_PAKISTAN              2223
#define IDS_CNTRY_PALAU                 2224
#define IDS_CNTRY_PANAMA                2225
#define IDS_CNTRY_PAPUA_NEW_GUINEA      2226
#define IDS_CNTRY_PARAGUAY              2227
#define IDS_CNTRY_PERU                  2228
#define IDS_CNTRY_PHILIPPINES           2229
#define IDS_CNTRY_POLAND                2230
#define IDS_CNTRY_PORTUGAL              2231
#define IDS_CNTRY_QATAR                 2232
#define IDS_CNTRY_REUNION_ISLAND        2233
#define IDS_CNTRY_ROMANIA               2234
#define IDS_CNTRY_ROTA_ISLAND           2235
#define IDS_CNTRY_RUSSIA                2236
#define IDS_CNTRY_RWANDA                2237
#define IDS_CNTRY_SAIPAN_ISLAND         2238
#define IDS_CNTRY_SAN_MARINO            2239
#define IDS_CNTRY_SAO_TOME_AND_PRINCIPE 2240
#define IDS_CNTRY_SAUDI_ARABIA          2241
#define IDS_CNTRY_SENEGAL_REPUBLIC      2242
#define IDS_CNTRY_YUGOSLAVIA            2243
#define IDS_CNTRY_SEYCHELLE_ISLANDS     2244
#define IDS_CNTRY_SIERRA_LEONE          2245
#define IDS_CNTRY_SINGAPORE             2246
#define IDS_CNTRY_SLOVAK_REPUBLIC       2247
#define IDS_CNTRY_SLOVENIA              2248
#define IDS_CNTRY_SOLOMON_ISLANDS       2249
#define IDS_CNTRY_SOMALIA               2250
#define IDS_CNTRY_SOUTH_AFRICA          2251
#define IDS_CNTRY_SPAIN                 2252
#define IDS_CNTRY_SRI_LANKA             2253
#define IDS_CNTRY_ST_HELENA             2254
#define IDS_CNTRY_ST_KITTS              2255
#define IDS_CNTRY_ST_PIERRE_AND_MIQUELON 2256
#define IDS_CNTRY_ST_VINCENT_AND_THE_GRENADINES 2257
#define IDS_CNTRY_SUDAN                 2258
#define IDS_CNTRY_SURINAME              2259
#define IDS_CNTRY_SWAZILAND             2260
#define IDS_CNTRY_SWEDEN                2261
#define IDS_CNTRY_SWITZERLAND           2262
#define IDS_CNTRY_SYRIA                 2263
#define IDS_CNTRY_TAIWAN                2264
#define IDS_CNTRY_TAJIKISTAN            2265
#define IDS_CNTRY_TANZANIA              2266
#define IDS_CNTRY_THAILAND              2267
#define IDS_CNTRY_TINIAN_ISLAND         2268
#define IDS_CNTRY_TOGO                  2269
#define IDS_CNTRY_TOKELAU               2270
#define IDS_CNTRY_TONGA                 2271
#define IDS_CNTRY_TRINIDAD_AND_TOBAGO   2272
#define IDS_CNTRY_TUNISIA               2273
#define IDS_CNTRY_TURKEY                2274
#define IDS_CNTRY_TURKMENISTAN          2275
#define IDS_CNTRY_TURKS_AND_CAICOS_ISLANDS 2276
#define IDS_CNTRY_TUVALU                2277
#define IDS_CNTRY_UGANDA                2278
#define IDS_CNTRY_UKRAINE               2279
#define IDS_CNTRY_UNITED_ARAB_EMIRATES  2280
#define IDS_CNTRY_UNITED_KINGDOM        2281
#define IDS_CNTRY_URUGUAY               2282
#define IDS_CNTRY_UZBEKISTAN            2283
#define IDS_CNTRY_VANUATU               2284
#define IDS_CNTRY_VATICAN_CITY          2285
#define IDS_CNTRY_VENEZUELA             2286
#define IDS_CNTRY_VIETNAM               2287
#define IDS_CNTRY_WALLIS_AND_FUTUNA_ISLANDS 2288
#define IDS_CNTRY_WESTERN_SAMOA         2289
#define IDS_CNTRY_YEMEN                 2291
#define IDS_CNTRY_ZAIRE                 2292
#define IDS_CNTRY_ZAMBIA                2293
#define IDS_CNTRY_ZIMBABWE              2294
#define IDS_CNTRY_UNITED_STATES_OF_AMERICA 2295
#define IDS_CNTRY_UNITED_STATES_VIRGIN_ISLANDS 2296
#define IDS_CNTRY_PUERTO_RICO           2297
#define IDS_CNTRY_SAINT_LUCIA           2298
#define IDS_CNTRY_END                   2299
#define IDS_TAB_ADDRESS                 2300
#define IDS_HTTP_SERVER_PATH            2301
#define IDS_HTTP_SERVER                 2302
#define IDS_HTTP_USERNAME               2303
#define IDS_HTTP_PASSWORD               2304
#define IDS_OPENPORT                    2305
#define IDS_PORTOPENED                  2306
#define IDS_CONNECTDEVICE               2307
#define IDS_DEVICECONNECTED             2308
#define IDS_AUTHENTICATE                2309
#define IDS_AUTHNOTIFY                  2310
#define IDS_AUTHRETRY                   2311
#define IDS_AUTHCALLBACK                2312
#define IDS_CONNECTED                   2313
#define IDS_DISCONNECTED                2314
#define IDS_ALLDEVICESCONNECTED         2315
#define IDS_AUTHCHANGEPASSWORD          2316
#define IDS_AUTHPROJECT                 2317
#define IDS_AUTHLINKSPEED               2318
#define IDS_AUTHACK                     2319
#define IDS_REAUTHENTICATE              2320
#define IDS_AUTHENTICATED               2321
#define IDS_PREPAREFORCALLBACK          2322
#define IDS_WAITFORMODEMRESET           2323
#define IDS_WAITFORCALLBACK             2324
#define IDS_INTERACTIVE                 2325
#define IDS_RETRYAUTHENTICATION         2326
#define IDS_CALLBACKSETBYCALLER         2327
#define IDS_PASSWORDEXPIRED             2328
#define IDS_RAS_UNDEFINED_ERROR         2329
#define IDS_MODEM_ALREADY_INUSE         2330
#define IDS_TELEPHONE_DETAILS           2331
#define IDS_OUTSIDE_ACCESS              2332
#define IDS_LONGDISTANCE_ACCESS         2333
#define IDS_TAPI_COUNTRY_CODE           2334
#define IDS_NT_NETWORK_ENTRY            2335
#define IDS_NT_NETWORK_DESCRIPTION      2336
#define IDS_NT_MODEM_ENTRY              2337
#define IDS_NT_MODEM_DESCRIPTION        2338
#define IDS_PHONEBOOK_ENTRY             2339
#define IDS_ICW_DIRECTORY_ENTRY         2340
#define IDS_ICW_DIRECTORY_ENTRY_VALUE   2341
#define IDS_DUN_PHONE_SECTION           2342
#define IDS_DUN_PHONE_AREACODE          2343
#define IDS_DUN_PHONE_COUNTRY           2344
#define IDS_DUN_VALUE_YES               2345
#define IDS_DUN_VALUE_NO                2346
#define IDS_DUN_PHONE_DIALAS            2347
#define IDS_DUN_SERVER_SECTION          2348
#define IDS_DUN_SERVER_TYPE             2349
#define IDS_DUN_SERVER_TYPE_PPP         2350
#define IDS_DUN_SERVER_SW_COMPRESS      2351
#define IDS_DUN_SERVER_TCPIP            2352
#define IDS_DUN_SERVER_LCP              2353
#define IDS_DUN_TCP_SECTION             2354
#define IDS_DUN_TCP_IPADDRESS           2355
#define IDS_DUN_TCP_SERVERADDRESS       2356
#define IDS_DUN_TCP_HEADERCOMPRESSION   2357
#define IDS_DUN_TCP_GATEWAY             2358
#define IDS_DUN_TCP_DNS                 2359
#define IDS_DUN_TCP_DNS_ALT             2360
#define IDS_DUN_USER_SECTION            2361
#define IDS_DUN_USER_NAME               2362
#define IDS_DUN_USER_PASSWORD           2363
#define IDS_NT_CDROM_ENTRY              2364
#define IDS_NT_POINTINGDEVICE_ENTRY     2365
#define IDS_NT_SOUNDCARD_DRIVER_DESC_ENTRY 2366
#define IDS_NT_SOUNDCARD_DRIVER_ENTRY   2367
#define IDS_NT_SOUNDCARD_DRIVER_VALUE   2368
#define IDS_OEM_DLL_ENTRY               2369
#define IDS_OEMBASEKEY                  2370
#define IDS_REMOVABLE_MEDIA_ENTRY       2371
#define IDS_HWID                        2372
#define IDS_MSID                        2373
#define IDS_PROCESSOR_ENTRY             2374
#define IDS_MASS_STRORAGE_ENTRY         2375
#define IDS_CPU_VENDOR_ENTRY            2376
#define IDS_CPU_ENTRY                   2377
#define IDS_PRODUCT_NAME                2378
#define IDS_PRODUCT_VERSION             2379
#define IDS_PRODUCT_VERSION_DISPLAY     2380
#define IDS_NT_POINTINGDEVICE_VALUE     2381
#define IDS_NT_CDROM_VALUE              2382
#define IDS_REMOVABLE_MEDIA_VALUE       2383
#define IDS_COMPANY_NAME                2384
#define IDS_WELCOMESCREEN_PROD_SEARCH   2385
#define IDS_WELCOME_SCR_TEXT21          2386
#define IDS_WELCOME_SCR_TEXT22          2387
#define IDS_ENTRY_FOR_WELCOME           2388
#define IDS_DIALING_MESSAGE             2389
#define IDS_POST_MESSAGE                2390
#define IDS_WINDOWS_CAPTION             2391
#define IDS_MODEM_NODIALTONE            2392
#define IDS_MODEM_ERROR                 2393
#define IDS_WELCOME_SCR_CONNECTOR       2394
#define IDD_MICROSOFT_ABOUT_MSG         2395
#define IDD_MICROSOFT_ABOUT_CAPTION     2396
#define IDS_TAPI_AREA_CODE              2397
#define IDS_MODEM_NOANSWER              2398
#define IDS_MODEM_LINE_BUSY             2399
#define IDS_HARDWARE_FAILURE            2400
#define IDS_REREGISTER_OS1              2401
#define IDS_REREGISTER_OS2              2402
#define IDS_WELCOME_SCR_TITLE           2403
#define IDS_WELCOME_SCR_STITLE          2404
#define IDS_INFORM_SCR_TITLE            2405
#define IDS_INFORM_SCR_STITLE           2406
#define IDS_NAME_SCR_TITLE              2407
#define IDS_NAME_SCR_STITLE             2408
#define IDS_ADDRESS_SCR_TITLE           2409
#define IDS_ADDRESS_SCR_STITLE          2410
#define IDS_RESELLER_SCR_TITLE          2411
#define IDS_RESELLER_SCR_STITLE         2412
#define IDS_SYSINV_SCR_TITLE            2413
#define IDS_SYSINV_SCR_STITLE           2414
#define IDS_PRODINV_SCR_TITLE           2415
#define IDS_PRODINV_SCR_STITLE          2416
#define IDS_REGISTER_SCR_TITLE          2417
#define IDS_REGISTER_SCR_STITLE         2418
#define IDS_DIALUP_SCR_TITLE            2419
#define IDS_DIALUP_SCR_STITLE           2420
#define IDS_LARGEFONTNAME               2421
#define IDS_LARGEFONTSIZE               2422
#define IDS_REGISTERLATER_BUTTONTEXT    2423
#define IDS_CANCEL_BUTTONTEXT           2424
#define IDS_FINAL_CANCEL_MSG            2425
#define IDS_FINAL_ERROR_MSG             2426
#define IDS_FINAL_MODEMCFG_MSG1         2427
#define IDS_FINAL_MODEMCFG_MSG2         2428
#define IDS_FINAL_NOTCP_MSG1            2429
#define IDS_FINAL_NOTCP_MSG2            2430
#define IDS_FINAL_POSTBUSY_MSG          2431
#define IDS_FINAL_POSTSUCCESS_MSG       2432
#define IDS_FINAL_NOTCP1_MSG            2433
#define IDS_FINAL_NOTCP2_MSG            2434
#define IDS_FINAL_MODEMCFG1_MSG         2435
#define IDS_FINAL_MODEMCFG2_MSG         2436
#define IDS_FINAL_SYSTEMERROR_MSG       2437
#define IDS_FINAL_SITEBUSY_MSG          2438
#define IDS_FINAL_REGISTERLATER_MSG     2439
#define IDS_FINAL_RASCFG_MSG            2441
#define IDS_FINAL_MODEMINUSE_MSG        2442
#define IDS_TELEPHONE_LOC               2443
#define IDS_TELEPHONE_CID               2444
#define IDS_TELEPHONE_NENT              2445
#define IDS_TELEPHONE_ID                2446
#define IDS_TELEPHONE_COUNTRY           2447
#define IDS_DUMMY_REMOVEDEY             2448
#define IDS_DIVISIONNAME_KEY            2449
#define IDS_USERID_KEY                  2450
#define IDS_AREACODE_KEY                2451
#define IDS_INFOKEY_51                  2452
#define IDS_HOMEQ1                      2452
#define IDS_INFOKEY_53                  2453
#define IDS_HOMEQ2                      2453
#define IDS_INFOKEY_54                  2454
#define IDS_HOMEQ3                      2454
#define IDS_INFOKEY_55                  2455
#define IDS_BUSINESSQ1                  2455
#define IDS_SCSI_ADAPTER                2456
#define IDS_COMPUTER_MODEL              2457
#define IDS_INFOKEY_58                  2458
#define IDS_MIDDLE_NAME                 2458
#define IDS_INFOKEY_59                  2459
#define IDS_INFOKEY_60                  2460
#define IDS_INFOKEY_61                  2461
#define IDS_INFOKEY_62                  2462
#define IDS_INFOKEY_63                  2463
#define IDS_INFOKEY_64                  2464
#define IDS_FECOUNTRY_LIST              2465
#define IDS_BUSINESSUSER_SCR_TITLE      2466
#define IDS_BUSINESSUSER_SCR_STITLE     2467
#define IDS_HOMEUSER_SCR_TITLE          2468
#define IDS_HOMEUSER_SCR_STITLE         2469
#define IDS_BUSINESSROLE_LIST           2470
#define IDS_SI_DEVICENAME               2471
#define IDS_SI_DEVICEDESCRIPTION        2472
#define IDS_STRING2473                  2473
#define IDS_SUCCESS_TEXT                2473
#define IDS_FINAL_UNSUCCESS_PREFIX      2474
#define IDS_FINAL_UNSUCCESS_SUFFIX      2475
#define IDS_NOTUSED                     2476
#define IDS_OSBUILDNUMBER               2477

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        256
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1081
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\rundll32\rundll.h ===
#ifndef STRICT
#define STRICT
#endif

#ifdef WINNT
#include <nt.h>             // We need these header files for the auto-version
#include <ntrtl.h>          // patching stuff...
#include <nturtl.h>
#endif

#define _INC_OLE
#include <windows.h>
#undef _INC_OLE

#ifdef WIN32
#include <shlobj.h>
#include <shellapi.h>
#include <shlapip.h>
#include <shlobjp.h>
#include <imagehlp.h>
#else
#include <shell.h>
#endif

#define IDI_DEFAULT     100

#define IDS_UNKNOWNERROR        0x100

#define IDS_LOADERR             0x300

#define IDS_GETPROCADRERR       0x400
#define IDS_CANTLOADDLL         0x401

//#include "port32.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\rundll32\precomp.h ===
#ifndef STRICT
#define STRICT
#endif

#define _INC_OLE
#include <windows.h>
#undef _INC_OLE

#ifdef WIN32
#include <shell2.h>
#else
#include <shell.h>
#endif

#define IDI_DEFAULT     100

#define IDS_UNKNOWNERROR        0x100

#define IDS_LOADERR             0x300

#define IDS_GETPROCADRERR       0x400
#define IDS_CANTLOADDLL         0x401

//#include "port32.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\sysinv\sysinv.c ===
/*********************************************************************
 * Hardware inventory check.  Works with Register Wizard 
 *
 * 02/20/97 - Denny Dong	Take the code from Sysinv.cpp
 * Copyright (c) 1998   Microsoft Corporation
 * 7/20/98  - Modified to get driver file name for Mouse,Sound card along with device names
              SCSI Adapter is added to the system inventory list. 
			  List of  Devices where Driver file info is gathered
				1) Mouse ( Pointing Device)
				2) Sound Card
				3) SCSI Adapter
			 Dispaly resolution is changed to  give additional information about color depth	
*  8/6/98   Prefix the Display Adapter with Driver string in the color resolution   
   8/17/98  Display Color Depth bug if Color depth is 32 bits aor more is fixed.The value is increased to DWORD LONG for storing the value
   3/9/99  GetSystemInformation() care is teken to release SetupAPI.Dll 's Buffer 
   5/27/99 ProcessType info for ALPHA  will be taken from the folloeing Registry Key
   HKLM\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment 
   - PROCESSOR_ARCHITECTURE"
   - PROCESSOR_IDENTIFIER
 *********************************************************************/

#include <Windows.h>
#include <stdio.h>
#include "sysinv.h"
#include "resource.h"
#include "SETUPAPI.H"

// The packed structures below get messed up with optimizations turned on
#pragma optimize( _T(""), off )

typedef struct _DEVIOCTL_REGISTERS
{
    DWORD reg_EBX;
    DWORD_PTR reg_EDX;
    DWORD reg_ECX;
    DWORD reg_EAX;
    DWORD reg_EDI;
    DWORD reg_ESI;
    DWORD reg_Flags;
} DEVIOCTL_REGISTERS, *PDEVIOCTL_REGISTERS;

#define MAX_SEC_PER_TRACK	64
#pragma pack(1)
typedef struct _DEVICEPARAMS
{
	TBYTE	dpSpecFunc;
	TBYTE	dpDevType;
	WORD	dpDevAttr;
	WORD	dpCylinders;
	TBYTE	dpMediaType;
	WORD	dpBytesPerSec;
	TBYTE	dpSecPerClust;
	WORD	dpResSectors;
	TBYTE	dpFATS;
	WORD	dpRootDirEnts;
	WORD	dpSectors;
	TBYTE	dpMedia;
	WORD	dpFATsecs;
	WORD 	dpSecsPerTrack;
	WORD	dpHeads;
	DWORD	dpHiddenSecs;
	DWORD	dpHugeSectors;
    TBYTE    A_BPB_Reserved[6];			 // Unused 6 BPB bytes
    TBYTE    TrackLayout[MAX_SEC_PER_TRACK * 4 + 2];
}DEVICEPARAMS,*PDEVICEPARAMS;
#pragma pack()

#define VWIN32_DIOC_DOS_IOCTL 1
#define kDrive525_0360   0
#define kDrive525_1200   1
#define kDrive350_0720   2
#define kDrive350_1440   7
#define kDrive350_2880   9
#define kDriveFIXED      5
#define kDriveBadDrvNum  0xFF

// Dynamic Registry enumeration declarations
#define DYNDESC_BUFFERSIZE	128
static _TCHAR vrgchDynDataKey[] = _T("Config Manager\\Enum");
static _TCHAR vrgchLocalMachineEnumKey[] = _T("Enum");
static _TCHAR vrgchHardWareKeyValueName[] = _T("HardWareKey");
static _TCHAR vrgchDriverValueName[] = _T("Driver");
static _TCHAR vrgchDeviceDescValueName[] = _T("DeviceDesc");
static _TCHAR vrgchDynNetExclusion[] = _T("Dial-Up Adapter");
static _TCHAR vrgchHardwareIDValueName[] = _T("HardwareID");
static BOOL vfIsFPUAvailable = TRUE;
static _TCHAR vrgchDynProcessorName[DYNDESC_BUFFERSIZE];
typedef enum
{
	dynNet		= 0,
	dynModem	= 1,
	dynMouse	= 2,
	dynCDRom	= 3,	
	dynMedia	= 4,
	dynSCSI     = 5,  
	dynSystem	= 6,
	dynEnd
}DYN;

static _TCHAR vrgchDynKey[dynEnd][12] = 
{
	_T("Net"),
	_T("Modem"),
	_T("Mouse"),
	_T("CDROM"),
	_T("Media"),
	_T("SCSIAdapter"),
	_T("System")
};

static _TCHAR vrgchDynDesc[dynEnd][DYNDESC_BUFFERSIZE] =
{
	_T(""),
	_T(""),
	_T(""),
	_T(""),
	_T(""),
	_T("")
};

static HANDLE hInstance = NULL;
static TCHAR  sszDriverFilename[256];

// Private functions
void EnumerateDynamicDevices( void );
void ProcessSystemDevices(LPTSTR rgchSystemKey);
BOOL GetProcessorTypeStringFromRegistry(LPTSTR);
void GetProcessorTypeStringFromSystem(LPTSTR);
UINT GetDriveTypeInv(UINT nDrive);
BOOL GetDeviceParameters(PDEVICEPARAMS pDeviceParams, UINT nDrive);
BOOL DoIOCTL(PDEVIOCTL_REGISTERS preg);
void GetSystemInformation(LPCTSTR szDeviceID,LPTSTR szDeviceName, LPTSTR szDriverName);
BOOL WINAPI GetSystemInventoryA(INT type, LPSTR szInventory);


/*
 * Function:
 *	BOOL DllMain(HINSTANCE, DWORD, LPVOID)
 *
 * Purpose:
 *	Entry point of DLL.
 */
BOOL WINAPI DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
		hInstance = hDll;
	return TRUE;
}

BOOL WINAPI GetSystemInventoryW(INT type, LPWSTR szInventory)
{

	/*char szInventory[1024];
	wszInventory[0] = 0;
	if (!GetSystemInventoryA(type, szInventory))
		return FALSE;
	if (type == INV_COPRECESSOR)
	{
		wszInventory[0] = szInventory[0];
		return TRUE;
	}
	if (szInventory[0] == 0)
		return TRUE;
	if (MultiByteToWideChar(CP_ACP,0,szInventory,-1,wszInventory,256) == 0)
		return FALSE;
	return TRUE;
	*/
	szInventory[0] = _T('\0');
	
	switch (type)
	{
	case INV_OEM:
		GetOEMString(szInventory);
		return TRUE;
	case INV_PROCESSORTYPE:
		GetProcessorTypeString(szInventory);
		return TRUE;
	case INV_TOTALMEMORY:
		GetTotalMemoryString(szInventory);
		return TRUE;
	case INV_TOTALHDSPACE:
		GetTotalHardDiskSpaceString(szInventory);
		return TRUE;
	case INV_DISPRESOLUTION:
		GetDisplayResolutionString(szInventory);
		return TRUE;
	case INV_DISPCOLORDEPTH:
		GetDisplayColorDepthString(szInventory);
		return TRUE;
	case INV_WINVERSION:
		GetWindowsVersionString(szInventory);
		return TRUE;
	case INV_NETCARD:
		GetNetworkCardString(szInventory);
		return TRUE;
	case INV_MODEM:
		GetModemString(szInventory);
		return TRUE;
	case INV_POINTDEVICE:
		GetPointingDeviceString(szInventory);
		return TRUE;
	case INV_CDROM:
		GetCDRomString(szInventory);
		return TRUE;
	case INV_SOUNDCARD:
		GetSoundCardString(szInventory);
		return TRUE;
	case INV_REMOVEABLEMEDIA:
		GetRemoveableMediaString(szInventory);
		return TRUE;
	case INV_COPRECESSOR:
		szInventory[0] = IsCoProcessorAvailable() ? 1 : 0;
		szInventory[1] = 0;
		return TRUE;
	case INV_SCSIADAPTER :
		GetScsiAdapterString(szInventory);
		return TRUE;
	case INV_DISPLAY_ADAPTER:
		GetDisplayAdapter(szInventory);
		return TRUE;
		break;
	case INV_DISPLAY_WITH_RESOLUTION:
		GetDisplayAdapterWithResolution(szInventory);
		return TRUE;
		break;
	default:
		break;
	}
	return FALSE;
}

BOOL WINAPI GetSystemInventoryA(INT type, LPSTR szInventory)
{
	BOOL bRet;
	int    iMaxOutStrLen;
	ULONG  ulNoOfChars;
	WCHAR  wszInventory[1024];
	iMaxOutStrLen = 256;

	bRet = GetSystemInventoryW(type, wszInventory);

	if(wszInventory[0]) {
		ulNoOfChars = wcslen(wszInventory)+1;
		memset((void *) szInventory,0,iMaxOutStrLen);
		if(WideCharToMultiByte(CP_ACP,0,wszInventory,ulNoOfChars,szInventory,
		iMaxOutStrLen,NULL,NULL) == 0) {
			//dwError = GetLastError();
			//
		}
		
	}else {
		// if empty string
		szInventory[0] = '\0';
	}
	return bRet;
}


/***************************************************************************
Returns TRUE if the file specified by the given pathname actually exists.
****************************************************************************/
BOOL FileExists(LPTSTR szPathName)
{
	SECURITY_ATTRIBUTES sa;
	HANDLE fileHandle;
	BOOL retValue;
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = TRUE;

	fileHandle = CreateFile(szPathName,GENERIC_READ,0,&sa,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
	if (fileHandle == INVALID_HANDLE_VALUE)
	{
		retValue = FALSE;
	}
	else
	{
		retValue = TRUE;
		CloseHandle(fileHandle);
	}
	return retValue;
}

/*********************************************************************
Returns a string containing the name of the Original Equipment
Manufacturer.
**********************************************************************/
void GetOEMString(LPTSTR szOEM)
{
	_TCHAR szPathName[512];
	DWORD oemLen;
	UINT pathLen = GetSystemDirectory(szPathName, 256);
	szOEM[0] = 0;
	if (pathLen > 0)
	{
		_TCHAR szIniName[256];
		LoadString(hInstance,IDS_OEM_INIFILE,szIniName,256);
		_tcscat(szPathName,_T("\\"));
		_tcscat(szPathName,szIniName);

		if (FileExists(szPathName))
		{
			_TCHAR szIniSection[64];
			_TCHAR szIniKey[64];
			_TCHAR szDefault[28];
			_TCHAR szModelTmp[128];
			LoadString(hInstance,IDS_OEM_INISECTION,szIniSection,64);
			LoadString(hInstance,IDS_OEM_INIKEY,szIniKey,64);
			szDefault[0] = 0;
			oemLen = GetPrivateProfileString(szIniSection,szIniKey,szDefault,szOEM,sizeof(szOEM)/sizeof(TCHAR),szPathName);

			LoadString(hInstance,IDS_OEM_INIKEY2,szIniKey,64);
			szDefault[0] = 0;
			oemLen = GetPrivateProfileString(szIniSection,szIniKey,szDefault,szModelTmp,sizeof(szModelTmp)/sizeof(TCHAR),szPathName);

			if(oemLen)
			{
				_tcscat(szOEM,_T(" ,"));
				_tcscat(szOEM,szModelTmp);
			}

		}
   }
}


/*********************************************************************
Returns a string that describes the processor in the user's system:
- "80386"
- "80486"
- "PENTIUM"
- "INTEL860"
- "MIPS_R2000"
- "MIPS_R3000"
- "MIPS_R4000"
- "ALPHA_21064"
Note: you must allocate at least 64 bytes for the buffer pointed to
by the szProcessor parameter.
**********************************************************************/
void GetProcessorTypeString(LPTSTR szProcessor)
{
	
	_TCHAR szTmp[256];
	_TCHAR szData[256]; 
	_TCHAR szString[256]; 
	HKEY  hKey; 
	LONG regStatus;
	DWORD dwInfoSize;

	SYSTEM_INFO systemInfo;
	GetSystemInfo(&systemInfo);

	szProcessor[0] = 0;
	if( PROCESSOR_ALPHA_21064 == systemInfo.dwProcessorType) {
	 
		// Alpha 
		// Default Value 
		LoadString(hInstance, IDS_PROCESSOR_ALPHA_21064,szProcessor,64);

		// Try to get from Registry
		LoadString(hInstance, IDS_ALPHA_PROCESSOR,szTmp,256);
		regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTmp, 0, KEY_READ, &hKey);
		if (regStatus != ERROR_SUCCESS) 
		return;
		
		dwInfoSize = 256;
		LoadString(hInstance, IDS_ALPHA_ARCHITECTURE, szString, 256);

		RegQueryValueEx(hKey, szString, NULL, 0, (LPBYTE)szData, &dwInfoSize);
		_tcscpy(szProcessor, szData);
		_tcscat(szProcessor, _T(", "));
		dwInfoSize = 256;
		
		LoadString(hInstance, IDS_ALPHA_IDENTIFIER, szString, 256);
		
		RegQueryValueEx(hKey, szString, NULL, 0, (LPBYTE)szData, &dwInfoSize);
		_tcscat(szProcessor, szData);
  	    RegCloseKey(hKey);



	}else {
		if (!GetProcessorTypeStringFromRegistry(szProcessor))
		GetProcessorTypeStringFromSystem(szProcessor);
	}
}


/*********************************************************************
Returns a string that describes the processor in the user's system:
- "80386"
- "80486"
- "PENTIUM"
- "INTEL860"
- "MIPS_R2000"
- "MIPS_R3000"
- "MIPS_R4000"
- "ALPHA_21064"
Note: you must allocate at least 64 bytes for the buffer pointed to
by the szProcessor parameter.
**********************************************************************/
void GetProcessorTypeStringFromSystem(LPTSTR szProcessor)
{
	SYSTEM_INFO systemInfo;
	GetSystemInfo(&systemInfo);
	switch (systemInfo.dwProcessorType)
	{
		case PROCESSOR_INTEL_386:
			LoadString(hInstance, IDS_PROCESSOR_386,szProcessor,64);
			break;
		case PROCESSOR_INTEL_486:
			LoadString(hInstance, IDS_PROCESSOR_486,szProcessor,64);
			break;
		case PROCESSOR_INTEL_PENTIUM:
			LoadString(hInstance, IDS_PROCESSOR_PENTIUM,szProcessor,64);
			break;
/*		case PROCESSOR_INTEL_860:
			LoadString(hInstance, IDS_PROCESSOR_860,szProcessor,64);
			break;
		case PROCESSOR_MIPS_R2000:
			LoadString(hInstance, IDS_PROCESSOR_MIPS_R2000,szProcessor,64);
			break;
		case PROCESSOR_MIPS_R3000:
			LoadString(hInstance, IDS_PROCESSOR_MIPS_R3000,szProcessor,64);
			break;														   */
		case PROCESSOR_MIPS_R4000:
			LoadString(hInstance, IDS_PROCESSOR_MIPS_R4000,szProcessor,64);
			break;
		case PROCESSOR_ALPHA_21064:
			LoadString(hInstance, IDS_PROCESSOR_ALPHA_21064,szProcessor,64);
			break;
		default:
			szProcessor[0] = 0;
			break;
	}
}


/*********************************************************************
Retrieves the name of the processor in use from the Registry.

Returns:
FALSE if the proper key in the Registry does not exist.
**********************************************************************/
BOOL GetProcessorTypeStringFromRegistry(LPTSTR szProcessor)
{
	HKEY  hKey; 
	_TCHAR uszRegKey[256];
	LONG regStatus;
	DWORD dwInfoSize;
	LoadString(hInstance, IDS_PROCESSOR_ENTRY, uszRegKey, 256);

	regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, uszRegKey, 0, KEY_READ, &hKey);
	if (regStatus != ERROR_SUCCESS) 
		return FALSE;
	else
	{
		_TCHAR szData[256]; 
		_TCHAR szString[256]; 
		dwInfoSize = 256;
		LoadString(hInstance, IDS_CPU_VENDOR_ENTRY, szString, 256);

		RegQueryValueEx(hKey, szString, NULL, 0, (LPBYTE)szData, &dwInfoSize);
		_tcscpy(szProcessor, szData);
		_tcscat(szProcessor, _T(", "));
		dwInfoSize = 256;
		
		LoadString(hInstance, IDS_CPU_ENTRY, szString, 256);
		
		RegQueryValueEx(hKey, szString, NULL, 0, (LPBYTE)szData, &dwInfoSize);
		_tcscat(szProcessor, szData);
  	    RegCloseKey(hKey);
	}
	return TRUE;
}

/*********************************************************************
Returns a string that describes the amount of physical RAM available.

Note: you must allocate at least 64 bytes for the buffer pointed to
by the szTotalMemory parameter.
**********************************************************************/
void GetTotalMemoryString(LPTSTR szTotalMemory)
{
	_TCHAR szSuffix[32];
	MEMORYSTATUS memoryStatus;
	DWORD_PTR totalRam;
	memoryStatus.dwLength = sizeof(MEMORYSTATUS);
	GlobalMemoryStatus(&memoryStatus);
	totalRam = memoryStatus.dwTotalPhys / 1024;
	LoadString(hInstance, IDS_SIZE_SUFFIX1, szSuffix, 31);
	_stprintf(szTotalMemory, _T("%li %s"), totalRam, szSuffix);
}

/*********************************************************************
Returns a string that describes the total amount of disk space
(in KB) available on all hard disk drives attached to the user's
system.

Note: you must allocate at least 64 bytes for the buffer pointed to
by the szTotalMemory parameter.
**********************************************************************/
void GetTotalHardDiskSpaceString(LPTSTR szTotalHardDiskSpace)
{
	_TCHAR szSuffix[32];
	LONG totalHardDiskSpace = GetTotalHardDiskSpace();
	LoadString(hInstance, IDS_SIZE_SUFFIX1, szSuffix, 31);
	_stprintf(szTotalHardDiskSpace, _T("%li %s"), totalHardDiskSpace, szSuffix);
}


/*********************************************************************
Returns a string that describes the horizontal x vertical resolution
(in pixels) of the user's main screen.
It also prefixes teh Display adapter Name
**********************************************************************/
void GetDisplayResolutionString(LPTSTR szDisplayResolution)
{
	int horizResolution, vertResolution;
	int colorBits;
	DWORDLONG colorDepth;
	_TCHAR szSuffix[24];
	char czDispAdapter[256];
	
	
	szSuffix[0] = _T('\0'); // 
	GetDisplayCharacteristics(&horizResolution, &vertResolution, NULL);
	// Color Depth 
	GetDisplayCharacteristics(NULL,NULL,&colorBits);
	colorDepth = (DWORDLONG) 1 << colorBits;
	
	szSuffix[0] = 0;
	if (colorBits > 15)
	{
		colorDepth = colorDepth / 1024;
		LoadString(hInstance,IDS_SIZE_SUFFIX2,szSuffix,24);
	}
	_stprintf(szDisplayResolution, _T("%i x %i x %I64d%s"), horizResolution, vertResolution, colorDepth,szSuffix);
}

void GetDisplayAdapterWithResolution( LPTSTR szDisplayWithResolution)
{
	TCHAR czDispAdapter[256];
	TCHAR czResolution[128];

	GetDisplayAdapter(czDispAdapter);
	GetDisplayResolutionString(czResolution);
	if(czDispAdapter[0] != _T('\0') )  {
		_tcscpy(szDisplayWithResolution,czDispAdapter);
		_tcscat(szDisplayWithResolution,_T("  "));
		_tcscat(szDisplayWithResolution,czResolution);
	}else {
		szDisplayWithResolution[0] = '\0';
	}

}

/*********************************************************************
Returns a string that describes the color depth (number of colors
available).
// We are  getting the 
**********************************************************************/
void GetDisplayColorDepthString(LPTSTR szDisplayColorDepth)
{
	int colorBits;
	LONG colorDepth;
	_TCHAR szSuffix[24];

	GetDisplayCharacteristics(NULL,NULL,&colorBits);
	colorDepth = 1 << colorBits;
	
	szSuffix[0] = 0;
	if (colorBits > 15)
	{
		colorDepth = colorDepth / 1024;
		LoadString(hInstance,IDS_SIZE_SUFFIX2,szSuffix,24);
	}
	_stprintf(szDisplayColorDepth,_T("%li%s"),colorDepth,szSuffix);
}


/*********************************************************************
Returns a string describing the platform and verson of the currently
operating Windows OS.
**********************************************************************/
void GetWindowsVersionString(LPTSTR szVersion)
{
	LONG platform, majorVersion, minorVersion, dwBuildNo;
	_TCHAR szPlatform[64];
	_TCHAR szOsName[128];
	HKEY  hKey; 
	_TCHAR uszRegKey[256];
	LONG dwStatus;
	DWORD dwInfoSize;
	_TCHAR szBuildNo[64];
	_TCHAR szString[64];
	int idsPlatform;

	GetWindowsVersion(&platform, &majorVersion, &minorVersion, &dwBuildNo);

	if (platform == VER_PLATFORM_WIN32_WINDOWS)
		idsPlatform = IDS_PLATFORM_WIN95;
	else if (platform == VER_PLATFORM_WIN32_NT)
		idsPlatform = IDS_PLATFORM_WINNT;
	else
		idsPlatform = IDS_PLATFORM_WIN;
	
	if(	idsPlatform == IDS_PLATFORM_WIN95)
	{
		

		_tcscpy(uszRegKey, _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"));
		dwStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, uszRegKey, 0, KEY_READ, &hKey);

		if (dwStatus != ERROR_SUCCESS) 
			LoadString(hInstance, idsPlatform, szPlatform, sizeof(szPlatform));
		else
		{
			dwInfoSize = 64;
			LoadString(hInstance, IDS_PRODUCT_NAME, szString, 64);
			RegQueryValueEx(hKey, szString, NULL, 0, (LPBYTE)szPlatform, &dwInfoSize);
  		    dwInfoSize = 64;
			LoadString(hInstance, IDS_PRODUCT_VERSION, szString, 64);
			RegQueryValueEx(hKey, szString, NULL, 0, (LPBYTE)szBuildNo,&dwInfoSize);
	    	RegCloseKey(hKey);
		}

		LoadString(hInstance,IDS_PRODUCT_VERSION_DISPLAY,szString,64);
		_tcscpy(szVersion,szPlatform);
		_tcscat(szVersion,szString);
		_tcscat(szVersion,szBuildNo);
	}
	else
	{
		// get OS name from Registry
		_tcscpy(uszRegKey, _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"));
		dwStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, uszRegKey, 0, KEY_READ, &hKey);
		if (dwStatus == ERROR_SUCCESS) {
			dwInfoSize = 128;
			LoadString(hInstance, IDS_PRODUCT_NAME, szString, 64);
			RegQueryValueEx(hKey, szString, NULL, 0, (LPBYTE)szOsName, &dwInfoSize);
	       	RegCloseKey(hKey);
		}


		LoadString(hInstance,idsPlatform,szPlatform,sizeof(szPlatform));
		_stprintf(szVersion,szPlatform,szOsName,dwBuildNo);
	}
}


/*********************************************************************
Returns a string describing the network card installed.  If no card
is installed, an empty string will be returned.
**********************************************************************/
void GetNetworkCardString(LPTSTR szNetwork)
{
	sszDriverFilename[0] = _T('\0');
	GetSystemInformation(_T("net"), szNetwork, sszDriverFilename);
	_tcscpy(vrgchDynDesc[dynNet],szNetwork);
}


/*********************************************************************
Returns a string describing the modem (if any) installed. If no modem
is installed, an empty string will be returned.
**********************************************************************/
void GetModemString(LPTSTR szModem)
{

	sszDriverFilename[0] = _T('\0');
	GetSystemInformation(_T("modem"), vrgchDynDesc[dynModem],sszDriverFilename);
	_tcscpy(szModem, vrgchDynDesc[dynModem]);
	

}


/*********************************************************************
Returns a string describing all pointing devices (mouse, tablet, etc.)
available.
**********************************************************************/
void GetPointingDeviceString(LPTSTR szPointingDevice)
{
	TCHAR czTemp[256];
	sszDriverFilename[0] = _T('\0');
	GetSystemInformation(_T("mouse"),vrgchDynDesc[dynMouse], sszDriverFilename);
	_tcscpy(szPointingDevice,vrgchDynDesc[dynMouse]);

	if( sszDriverFilename[0] != _T('\0')) {
		// Copy the Driver file Name
		_stprintf(czTemp,_T("  (%s.sys) "),sszDriverFilename);   
		_tcscat(szPointingDevice,czTemp);
	}
	_tcscpy(vrgchDynDesc[dynModem],szPointingDevice);

}


/*********************************************************************
Returns a string describing any CD-Rom devices installed.  If no
CD-ROM device is installed, an empty string will be returned.
**********************************************************************/
void GetCDRomString(LPTSTR szCDRom)
{
	sszDriverFilename[0] = _T('\0');
	GetSystemInformation(_T("cdrom"),vrgchDynDesc[dynCDRom],sszDriverFilename);
	_tcscpy(szCDRom,vrgchDynDesc[dynCDRom]);
}

/*********************************************************************
Returns a string describing any sound card with driver  installed.  If none are
installed, an empty string will be returned.
**********************************************************************/
void GetSoundCardString(LPTSTR szSoundCard)
{
	TCHAR czTemp[256];
	sszDriverFilename[0] = _T('\0');
	GetSystemInformation(_T("media"),vrgchDynDesc[dynMedia],sszDriverFilename);
	_tcscpy(szSoundCard,vrgchDynDesc[dynMedia]);

	if( sszDriverFilename[0] != _T('\0')) {
		// Copy the Driver file Name
		_stprintf(czTemp,_T("  (%s.sys) "),sszDriverFilename);   
		_tcscat(szSoundCard,czTemp);
	}
	_tcscpy(vrgchDynDesc[dynMedia],szSoundCard);
}

void GetDisplayAdapter( LPTSTR szDisplayAdapter)
{
	TCHAR czTemp[256];
	sszDriverFilename[0] = _T('\0');
	GetSystemInformation(_T("Display"),szDisplayAdapter,sszDriverFilename);
	

	if( sszDriverFilename[0] != _T('\0')) {
		// Copy the Driver file Name
		_stprintf(czTemp,_T("  (%s.sys) "),sszDriverFilename);   
		_tcscat(szDisplayAdapter,czTemp);
	}
}

/*
	Returns SCSI Adapter with Driver name persent in the system
*/
void GetScsiAdapterString(LPTSTR szScsiAdapter)
{
	TCHAR czTemp[256];
	sszDriverFilename[0] = _T('\0');
	GetSystemInformation(vrgchDynKey[dynSCSI],vrgchDynDesc[dynSCSI], sszDriverFilename);
	_tcscpy(szScsiAdapter,vrgchDynDesc[dynSCSI]);

	if( sszDriverFilename[0] != _T('\0')) {
		// Copy the Driver file Name
		_stprintf(czTemp,_T("  (%s.sys) "),sszDriverFilename);   
		_tcscat(szScsiAdapter,czTemp);
	}
	_tcscpy(vrgchDynDesc[dynSCSI],szScsiAdapter);

}

/*	Value  -- > "CurrentDriveLetterAssignment"		Data -- > "A"
	Value  -- > "Removable"							Data -- > 01
	Value  -- > "Class"								Data -- > "DiskDrive"*/
#define     REGFIND_ERROR      1
#define     REGFIND_RECURSE    2
#define     REGFIND_FINISH     3

int RegFindValueInAllSubKey(HKEY key, LPCTSTR szSubKeyNameToFind, LPCTSTR szValueToFind, LPTSTR szIdentifier, int nType)
{
	DWORD   dwRet = ERROR_PATH_NOT_FOUND, dwIndex, dwSubkeyLen;
	TCHAR   szSubKey[256], szFloppy[256];
	BOOL    bType = FALSE, bRemovable = FALSE, bPrevMassStorage, bPrevFloppy;
	HKEY    hKey;
	static BOOL bMassStorage = FALSE;
	static BOOL bFloppy = FALSE;
	
	bPrevMassStorage =	bMassStorage;
	bPrevFloppy		=	bFloppy;

	if (szSubKeyNameToFind != NULL)
		dwRet = RegOpenKeyEx(key, szSubKeyNameToFind, 0, KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE, &hKey);

	if (dwRet == ERROR_SUCCESS)
	{
		dwIndex = 0;
        while (dwRet == ERROR_SUCCESS )
        {
            dwSubkeyLen = 256;
			dwRet = RegEnumKeyEx(hKey, dwIndex, szSubKey, &dwSubkeyLen,
                           NULL, NULL, NULL, NULL);
 
            if (dwRet == ERROR_NO_MORE_ITEMS)
            {
				_TCHAR		valueName[80];
				DWORD		valueNameSize,valueSize,n = 0;
				TBYTE		value[80];
				
                do
				{
					valueNameSize=80* sizeof(_TCHAR);
					valueSize=80* sizeof(TBYTE);
					dwRet = RegEnumValue(hKey, n, valueName, &valueNameSize,
										 NULL, NULL, (LPBYTE)value, &valueSize);
					if (dwRet == ERROR_SUCCESS)
					{
						if (nType == 1)
						{
							if (!_tcscmp(valueName,_T("Type"))) 
							{
								if (!_tcscmp(szValueToFind,(LPCTSTR)value))
									bType = TRUE;
							}
							if (!_tcscmp(valueName,_T("Identifier"))) 
								_tcscpy(szIdentifier,(LPCTSTR)value);
						}
						else if(nType == 2)
						{
							if (!_tcscmp(valueName,_T("Class"))) 
							{
								if (!_tcscmp(szValueToFind,(LPCTSTR)value))
									bType = TRUE;
							}
							if (!_tcscmp(valueName,_T("DeviceDesc"))) 
							{
// bFloppy and bMassStorage are used for handling the conditions when there are multiple 
// Floppy and mass storage media present.
								_tcscpy(szFloppy,(LPCTSTR)value);
								_tcsupr(szFloppy);
								if(_tcsstr(szFloppy,_T("FLOPPY")) != NULL)
								{
									if(!bFloppy)
									{
										_tcscpy(szFloppy,(LPCTSTR)value);
										bFloppy = TRUE;
									}
								}
								else
// if it is not removable or it is a cdrom the condition for type and removable 
// takes care of it.
								{
									if(!bMassStorage)
										bMassStorage = TRUE;
								}

							}
							if (!_tcscmp(valueName,_T("Removable"))) 
							{
								if (*value == 0x01 )
									bRemovable = TRUE;
							}
						}
						n++;
					}

				} while (dwRet == ERROR_SUCCESS);

				if (nType == 1)
				{
					if(bType)
						return REGFIND_FINISH;
					else
						return REGFIND_RECURSE;
				}
				else if (nType == 2)
				{
					if( bType && bRemovable )
					{
						if (bFloppy != bPrevFloppy )
							_tcscpy(szIdentifier,szFloppy);	
						if (bFloppy && bMassStorage)
						{
							_TCHAR szMassString[64];
							LoadString(hInstance,IDS_MASS_STRORAGE_ENTRY,szMassString,64);
							_tcscat(szIdentifier,szMassString);	
							return REGFIND_FINISH;
						}
						return REGFIND_RECURSE;
					}
// The bMassStorage flag has to be reset to the previous state. 
					else
					{
						bMassStorage = bPrevMassStorage;
						if(bFloppy != bPrevFloppy)
							bFloppy = bPrevFloppy;
						return REGFIND_RECURSE;
					}
				}            
			}
            else
			{
				if (dwRet == ERROR_SUCCESS)
				{
					int nStatus;
					nStatus = RegFindValueInAllSubKey(hKey, szSubKey, szValueToFind, szIdentifier, nType);

					switch(nStatus)
					{
						case REGFIND_FINISH:
							return REGFIND_FINISH;
						case REGFIND_ERROR:
							return REGFIND_ERROR;
						default :
							if (bFloppy != bPrevFloppy)
								bPrevFloppy = bFloppy;
							break;
					}
					dwIndex++;
				}
			}
		}
		RegCloseKey(hKey);
	}
 
	return REGFIND_ERROR;
}

/*********************************************************************
Returns a string describing the capacity and format of removeable
drives.
**********************************************************************/
void GetRemoveableMediaString(LPTSTR szRemoveableMedia)
{
	LONG platform, majorVersion, minorVersion, dwBuildNo;
	GetWindowsVersion(&platform, &majorVersion, &minorVersion, &dwBuildNo);

	if (platform != VER_PLATFORM_WIN32_NT)
	{
		_TCHAR szSubKey[64];
		_TCHAR szSubKeyValue[64];
		LoadString(hInstance, IDS_REMOVABLE_MEDIA_ENTRY, szSubKey, 64);
		LoadString(hInstance, IDS_REMOVABLE_MEDIA_VALUE, szSubKeyValue, 64);
		RegFindValueInAllSubKey(HKEY_LOCAL_MACHINE,szSubKey,szSubKeyValue,szRemoveableMedia,2);
	}
	else
	{
		UINT driveType;
		_TCHAR szDrive[64];
		UINT nDrive;
		const iBufSize = 256;
		szRemoveableMedia[0] = 0;
		for (nDrive = 1; nDrive <= 26; nDrive++)
		{
			szDrive[0] = 0;
			driveType = GetDriveTypeInv(nDrive);
			switch (driveType)
			{
				case kDrive525_0360:
					LoadString(hInstance, IDS_DRV525_0360, szDrive, 64);
					break;
				case kDrive525_1200:
					LoadString(hInstance, IDS_DRV525_1200, szDrive, 64);
					break;
				case kDrive350_0720:
					LoadString(hInstance, IDS_DRV350_0720, szDrive, 64);
					break;
				case kDrive350_1440:
					LoadString(hInstance, IDS_DRV350_1440, szDrive, 64);
					break;
				case kDrive350_2880:
					LoadString(hInstance, IDS_DRV350_2880, szDrive, 64);
					break;
			}
			if (szDrive[0])
			{
				_TCHAR szFormattedDrive[70];
				int iNewStrLen;
				wsprintf(szFormattedDrive,_T("%c: %s"),_T('A') + nDrive - 1,szDrive);
				iNewStrLen = (_tcslen(szRemoveableMedia) +1+ _tcslen(szFormattedDrive) + 1);
				if (iNewStrLen < iBufSize)
				{
					if (szRemoveableMedia[0])
						_tcscat(szRemoveableMedia,_T(", ")); // We added 2 to iNewStrLen above to account to this
					_tcscat(szRemoveableMedia,szFormattedDrive);
				}
			}
		}
	}
}


/*********************************************************************
Returns TRUE if a co-processor is installed in the user's system.
**********************************************************************/
BOOL IsCoProcessorAvailable(void)
{
	EnumerateDynamicDevices();
	return vfIsFPUAvailable;
}


/**********************************************************************
Determines the value associated with the specified Registration
Database key and value name.

Returns:
	The cb of the key data if successful, 0 otherwise.
Notes:
	If hRootKey is NULL, HKEY_CLASSES_ROOT is used for the root
***********************************************************************/
UINT GetRegKeyValue32(HKEY hRootKey, LPTSTR const cszcSubKey, LPTSTR const cszcValueName,
					  PDWORD pdwType, PTBYTE pbData, UINT cbData )
{
	HKEY hSubKey;
	LONG lErr;
	DWORD cbSize = (DWORD)cbData;

	if (hRootKey == NULL)
		hRootKey = HKEY_CLASSES_ROOT;

	lErr = RegOpenKeyEx(hRootKey, cszcSubKey, 0, KEY_READ, &hSubKey);
	if (lErr != ERROR_SUCCESS)
	{
		pdwType[0] = 0;
		return 0;	/* Return 0 if the key doesn't exist */
	}

	lErr = RegQueryValueEx(hSubKey, (LPTSTR)cszcValueName, NULL, pdwType, (LPBYTE)pbData,
						   &cbSize);
	RegCloseKey(hSubKey);
	if (lErr != ERROR_SUCCESS)
	{
		pdwType[0] = 0;
		return 0;	/* Return 0 if the value doesn't exist */
	}

	return (UINT)cbSize;
}

/*********************************************************************
Enumerates through the HKEY_DYN_DATA\Config Manager\Enum branch of
the registry, and retrieves device information for all currently
installed Net cards, modems, pointing devices, CDROMs, and sound
cards.  All this information is stored in the static vrgchDynDesc
global array.
**********************************************************************/
void EnumerateDynamicDevices(void)
{
	HKEY hKey;
	// Open the "HKEY_DYN_DATA\Config Manager\Enum" subkey.
	LONG regStatus = RegOpenKeyEx(HKEY_DYN_DATA, vrgchDynDataKey, 0, KEY_READ, &hKey);
	if (regStatus == ERROR_SUCCESS)
	{
		DWORD dwIndex = 0;
		_TCHAR rgchSubkey[256];
		_TCHAR rgchValue[256];
		DWORD dwSubkeySize;
		LONG lEnumErr;
		DWORD dwType;
		DWORD dwValueSize;
		do
		{
			// Enumerate "HKEY_DYN_DATA\Config Manager\Enum\Cxxxxxxx"
			FILETIME ftLastWrite;
			dwSubkeySize = sizeof(rgchSubkey);
			lEnumErr = RegEnumKeyEx(hKey, dwIndex++, rgchSubkey, &dwSubkeySize,
									NULL,NULL,NULL,&ftLastWrite);
			if (lEnumErr == ERROR_SUCCESS)
			{
				// From each subkey, read the value from the "HardWareKey" value name,
				// and make a new HKEY_LOCAL_MACHINE subkey out of it.
				dwValueSize = GetRegKeyValue32(hKey, rgchSubkey, vrgchHardWareKeyValueName, &dwType,
								(PTBYTE)rgchValue, sizeof(rgchValue) );
				if (dwValueSize > 0 && dwType == REG_SZ)
				{
					_TCHAR rgchDriverKey[256];
					wsprintf(rgchDriverKey,_T("%s\\%s"),vrgchLocalMachineEnumKey,rgchValue);

					// From our HKEY_LOCAL_MACHINE subkey, read the value from the "Driver"
					// value name.
					dwValueSize = GetRegKeyValue32(HKEY_LOCAL_MACHINE, rgchDriverKey, vrgchDriverValueName,
												&dwType, (PTBYTE) rgchValue, sizeof(rgchValue) );
					if (dwValueSize > 0  && dwType == REG_SZ)
					{
						// Get the "main" subkey out of the "driver" value (which is of the
						// form "<main>\xxxx").
						LPTSTR sz = rgchValue;
						WORD wDynIndex = 0;
						BOOL fMatch = FALSE;

						while (*sz && *sz != _T('\\'))
							sz = _tcsinc(sz);
						*sz = 0;

						// If the "main" subkey matches any of our desired device types,
						// we get the description of that device from the "DriverDesc"
						// name value field, and save it in our device array.
						while (wDynIndex < dynEnd && fMatch == FALSE)
						{
							if (vrgchDynDesc[wDynIndex][0] == 0)
							{				
								if (_tcsicmp(vrgchDynKey[wDynIndex], rgchValue) == 0)
								{
									if (wDynIndex == dynSystem)
									{
										ProcessSystemDevices(rgchDriverKey);
										fMatch = TRUE;
									}
									else
									{
										dwValueSize = GetRegKeyValue32(HKEY_LOCAL_MACHINE,rgchDriverKey,
											vrgchDeviceDescValueName, &dwType, (PTBYTE) rgchValue, 
											sizeof(rgchValue) );
										if (dwValueSize > 0  && dwType == REG_SZ)
										{
											if (wDynIndex != dynNet || _tcsicmp(vrgchDynNetExclusion,
												rgchValue) != 0)
											{
												// In case the description value is bigger than our 
												// buffer, truncate it to fit.
												if (DYNDESC_BUFFERSIZE < sizeof(rgchValue))
													rgchValue[DYNDESC_BUFFERSIZE - (1*sizeof(_TCHAR))] = 0;
												_tcscpy(vrgchDynDesc[wDynIndex],rgchValue);
												fMatch = TRUE;
											}
										}
									}
								}
							}
							wDynIndex++;
						}
					}
				}
			}
		}while (lEnumErr == ERROR_SUCCESS);
	}
}


/*********************************************************************
Called when EnumerateDynamicDevices detects a "system" device (i.e.
a processor or FPU entry).  The string passed in rgchSystemKey is the
name of the HKEY_LOCAL_MACHINE subkey under which the "system" device
was found.
**********************************************************************/
void ProcessSystemDevices(LPTSTR rgchSystemKey)
{
	_TCHAR rgchValue[256];
	DWORD dwType, dwValueSize;
	// If we've got all the information we can use, we can bail out immediately
	if (vfIsFPUAvailable == TRUE && vrgchDynProcessorName[0] != 0)
		return;

	dwValueSize = GetRegKeyValue32(HKEY_LOCAL_MACHINE, rgchSystemKey, vrgchHardwareIDValueName,
								&dwType, (PTBYTE) rgchValue, sizeof(rgchValue));
	if (dwValueSize > 0 && dwType == REG_SZ)
	{
		if (_tcsstr(rgchValue,_T("*PNP0C04")))
		{
			vfIsFPUAvailable = TRUE;
		}
		else if (_tcsstr(rgchValue,_T("*PNP0C01")))
		{
			dwValueSize = GetRegKeyValue32(HKEY_LOCAL_MACHINE,rgchSystemKey,_T("CPU"),&dwType, 
				(PTBYTE) vrgchDynProcessorName, sizeof(vrgchDynProcessorName) );
		}
	}					
}


/*********************************************************************
Returns a LONG value representing the total amount of disk space
(in KB) available on all hard disk drives attached to the user's
system.
**********************************************************************/
LONG GetTotalHardDiskSpace(void)
{
	_TCHAR szDrivesBuffer[256];
	DWORD bufferLen = GetLogicalDriveStrings(256, szDrivesBuffer);
	LPTSTR szDrive = szDrivesBuffer;
	LONG totalHardDiskSpace = 0;
	while (szDrive[0] != 0)
	{
		UINT driveType = GetDriveType(szDrive);
		if (driveType == DRIVE_FIXED)
		{
			DWORD  sectorsPerCluster; 		
			DWORD  bytesPerSector;
			DWORD  freeClusters;
			DWORD  clusters;
			LONG kilobytesPerCluster;

			if (GetDiskFreeSpace(szDrive,&sectorsPerCluster,&bytesPerSector,&freeClusters,&clusters))
            {
			    kilobytesPerCluster = (bytesPerSector * sectorsPerCluster)/1024;
			    totalHardDiskSpace += kilobytesPerCluster * clusters;
            }
		}
		szDrive += ((_tcslen(szDrive)+1) );
	}
	return totalHardDiskSpace;
}


/*********************************************************************
Returns the horizontal and vertical resolution (in pixels) of the 
user's main screen, as well as the color depth (bits per pixel).

Note: NULL can be passed for any parameter that is not of interest.
**********************************************************************/
void GetDisplayCharacteristics(PINT lpHorizResolution, PINT lpVertResolution,PINT lpColorDepth)
{
	HWND hwnd = GetDesktopWindow();
	HDC hdc = GetDC(hwnd);
	if (lpHorizResolution) *lpHorizResolution = GetDeviceCaps(hdc,HORZRES);
	if (lpVertResolution) *lpVertResolution = GetDeviceCaps(hdc,VERTRES);
	if (lpColorDepth) *lpColorDepth = GetDeviceCaps(hdc,BITSPIXEL);
	ReleaseDC(hwnd,hdc);
}


/*********************************************************************
Returns integers representing the platform, major version number, and
minor version number of the currently running Windows OS.

Platform:
VER_PLATFORM_WIN32_NT:		Windows NT
VER_PLATFORM_WIN32s: 		Win32s with Windows 3.1
VER_PLATFORM_WIN32_WINDOWS:	Win32 on Windows 4.0 or later

Note: NULL can be passed for any parameter that is not of interest.
**********************************************************************/
void GetWindowsVersion(LONG* lpPlatform, LONG* lpMajorVersion,LONG* lpMinorVersion,LONG* lpBuildNo)
{
	OSVERSIONINFO osvi;
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osvi);
	if (lpMajorVersion) *lpMajorVersion = osvi.dwMajorVersion;
	if (lpMinorVersion) *lpMinorVersion = osvi.dwMinorVersion;
	if (lpPlatform) *lpPlatform = osvi.dwPlatformId;
	if (lpBuildNo) *lpBuildNo = osvi.dwBuildNumber;
}


/*********************************************************************
For the disk drive specified by the nDrive parameter (1 = A, 2 = B, 
etc), GetDriveTypeInv returns a code specifying the drive format.  The 
returned value will be one of the following:

driveSize:
- kDrive525_0360:	5.25", 360K floppy
- kDrive525_0720:	5.25", 720K floppy
- kDrive350_0720:	3.5", 720K floppy
- kDrive350_1440:	3.5", 1.4M floppy
- kDrive350_2880:	3.5", 2.88M floppy
- kDriveFixed:		Hard disk, any size
- kDriveBadDrvNum:	Bad drive number
**********************************************************************/
UINT GetDriveTypeInv(UINT nDrive)
{
	DEVICEPARAMS deviceParams;

	// Must initialize dpDevType, because if nDrive refers to a network
	// drive or a drive letter with no volume attached, DeviceIOControl
	// does not return an error - it just doesn't change .dpDevType at
	// all.
	deviceParams.dpDevType = kDriveBadDrvNum;
	GetDeviceParameters(&deviceParams,nDrive);
	return deviceParams.dpDevType;
}


/*********************************************************************
Returns a block of device parameters for the drive specified by the
nDrive parameter (a zero-based index).
**********************************************************************/
BOOL GetDeviceParameters(PDEVICEPARAMS pDeviceParams, UINT nDrive)
{
    DEVIOCTL_REGISTERS reg;

    reg.reg_EAX = 0x440D;      			 /* IOCTL for block devices */
    reg.reg_EBX = nDrive;      			 /* zero-based drive ID     */
    reg.reg_ECX = 0x0860;      			 /* Get Device Parameters command    */
    reg.reg_EDX = (DWORD_PTR) pDeviceParams; /* receives device parameters info  */

    if (!DoIOCTL(&reg))
        return FALSE;

    if (reg.reg_Flags & 0x8000) /* error if carry flag set */
        return FALSE;

    return TRUE;
}



/*********************************************************************
Performs an IOCTL (Int21h) call via the System virtual device driver.
**********************************************************************/
BOOL DoIOCTL(PDEVIOCTL_REGISTERS preg)
{
    HANDLE hDevice;
    BOOL fResult;
    DWORD cb;

    preg->reg_Flags = 0x8000; /* assume error (carry flag set) */

	 hDevice = CreateFile(_T("\\\\.\\vxdfile"),
        GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
        (LPSECURITY_ATTRIBUTES) NULL, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL, (HANDLE) NULL);

    if (hDevice == (HANDLE) INVALID_HANDLE_VALUE) 
        return FALSE;
    else
    { 
        fResult = DeviceIoControl(hDevice, VWIN32_DIOC_DOS_IOCTL,
								  preg, sizeof(*preg), preg, sizeof(*preg), &cb, 0);
        if (!fResult)
            return FALSE;
    }    
                                        
    CloseHandle(hDevice);

    return TRUE;
}

void GetSystemInformation(LPCTSTR szDeviceID, LPTSTR szDeviceName, LPTSTR szDriverName)
{
	HDEVINFO hDevInfo;
	DWORD dwMemberIndex = 0;
	SP_DEVINFO_DATA DeviceInfoData;
	DWORD dwPropertyRegDataType;
	DWORD dwPropertyBufferSize = 256;
	_TCHAR szPropertyBuffer[256];
	DWORD dwRequiredSize;
	DWORD dwReqSize;
	DWORD dwError = 0;
	DWORD dwClassGuidListSize = 256;
	GUID ClassGuidList[256];
	GUID * pGUID;
	DWORD i;
	
	_tcscpy(szPropertyBuffer,_T(""));

	SetupDiClassGuidsFromName(szDeviceID, ClassGuidList, dwClassGuidListSize, &dwRequiredSize);
	pGUID = ClassGuidList;
	DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

	for (i = 0; i < dwRequiredSize; i++)
	{
		hDevInfo  = NULL;
		hDevInfo = SetupDiGetClassDevs(pGUID++,	NULL, NULL,	DIGCF_PRESENT);
		dwMemberIndex = 0;
		do
		{
			BOOL bRet = SetupDiEnumDeviceInfo(hDevInfo, dwMemberIndex++, &DeviceInfoData);
			if (bRet == TRUE)
			{ 
				bRet = SetupDiGetDeviceRegistryProperty
						(hDevInfo, &DeviceInfoData, SPDRP_DEVICEDESC,
						 &dwPropertyRegDataType, /* optional */
						 (PBYTE)szPropertyBuffer, dwPropertyBufferSize,
						 &dwReqSize /* optional */
						); 
			
				if(!_tcscmp(szDeviceID,_T("net")))
				{
					if(!_tcsnicmp(szPropertyBuffer,_T("Dial-Up"),7))
						continue;
					if(!_tcsnicmp(szPropertyBuffer,_T("Microsoft Virtual Private Networking"),36))
						continue;
				}
				bRet = SetupDiGetDeviceRegistryProperty
						(hDevInfo, &DeviceInfoData, SPDRP_SERVICE,
						 &dwPropertyRegDataType, /* optional */
						 (PBYTE)szDriverName, dwPropertyBufferSize,
						 &dwReqSize /* optional */
						); 
				break;
			}
			else
				dwError = GetLastError();
		}
		while( dwError != ERROR_NO_MORE_ITEMS);
		if(hDevInfo != NULL) {
			SetupDiDestroyDeviceInfoList(hDevInfo);
		}	

	}
	_tcscpy(szDeviceName,szPropertyBuffer);
}

#pragma optimize( _T(""), on )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\rundll32\port32.h ===
#ifdef WIN32

// These things have direct equivalents.
#define hmemcpy memmove
#define lstrcpyn strncpy

// Shouldn't be using these things.
#define _huge
#define _export
#define _loadds
#define SELECTOROF(x)   ((UINT)(x))
#define OFFSETOF(x)     ((UINT)(x))
#define MAKELP(hmem,off) ((LPVOID)((LPBYTE)hmem+off))
#define MAKELRESULTFROMUINT(i)  ((LRESULT)i)
#define ISVALIDHINSTANCE(hinst) ((BOOL)hinst)

#define DATASEG_READONLY    ".rodata"
#define DATASEG_PERINSTANCE ".instance"
#define DATASEG_SHARED                      // default (".data")

#define GetWindowInt    GetWindowLong
#define SetWindowInt    SetWindowLong
#define SetWindowID(hwnd,id)    SetWindowLong(hwnd, GWL_ID, id)

#else  // WIN32

#define MAKELRESULTFROMUINT(i)  MAKELRESULT(i,0)
#define ISVALIDHINSTANCE(hinst) ((UINT)hinst>=HINSTANCE_ERROR)

#define DATASEG_READONLY    "_TEXT"
#define DATASEG_PERINSTANCE
#define DATASEG_SHARED

#define GetWindowInt    GetWindowWord
#define SetWindowInt    SetWindowWord
#define SetWindowID(hwnd,id)    SetWindowWord(hwnd, GWW_ID, id)

#endif // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\sysinv\sysinv.h ===
#ifndef __sysinv__
#define __sysinv__

#ifdef  __cplusplus
extern "C" {
#endif

/*
 * Function:
 *	BOOL WINAPI GetSystemInventory(INT type, LPTSTR szInventory);
 *
 * Description:
 *	Get system inventory information by type caller asked
 *
 * Parameters:
 *	INT type:	specify what type information caller.  Should be one of INV_* constants
 *	LPTSTR szInventory:	The description of specific item information on return.  The contents depends on item type.
 *						The length of the buffer has to be at least 256.
 *
 * Return Value:
 *	TRUE on success.
 *	FALSE on failure.  szInventory[0] is also assigned 0
 */
BOOL WINAPI GetSystemInventory(INT, LPTSTR);

#define INV_OEM				1	// szInventory: Descriptive string
#define INV_PROCESSORTYPE	2	// szInventory: Descriptive string
#define INV_TOTALMEMORY		3	// szInventory: Descriptive string
#define INV_TOTALHDSPACE	4	// szInventory: Descriptive string
#define INV_DISPRESOLUTION	5	// szInventory: Descriptive string
#define INV_DISPCOLORDEPTH	6	// szInventory: Descriptive string
#define INV_WINVERSION		7	// szInventory: Descriptive string
#define INV_NETCARD			8	// szInventory: Descriptive string
#define INV_MODEM			9	// szInventory: Descriptive string
#define INV_POINTDEVICE		10	// szInventory: Descriptive string
#define INV_CDROM			11	// szInventory: Descriptive string
#define INV_SOUNDCARD		12	// szInventory: Descriptive string
#define INV_REMOVEABLEMEDIA	13	// szInventory: Descriptive string
#define INV_COPRECESSOR		14	// szInventory[0] = 1 for available, 0 for nonavailable
#define INV_SCSIADAPTER     15  //  
#define INV_DISPLAY_ADAPTER 16  // Display Adapter with Driver
#define INV_DISPLAY_WITH_RESOLUTION 17 // Display Adapter and Color resolution
#ifdef __cplusplus
}   /* ... extern "C" */
#endif

#endif


#include <tchar.h>

void GetOEMString(LPTSTR);
void GetProcessorTypeString(LPTSTR);
void GetTotalMemoryString(LPTSTR);
void GetTotalHardDiskSpaceString(LPTSTR);
void GetDisplayResolutionString(LPTSTR);
void GetDisplayColorDepthString(LPTSTR);
void GetWindowsVersionString(LPTSTR);
void GetNetworkCardString(LPTSTR);
void GetModemString(LPTSTR);
void GetPointingDeviceString(LPTSTR);
void GetCDRomString(LPTSTR);
void GetSoundCardString(LPTSTR);
void GetRemoveableMediaString(LPTSTR);
void GetScsiAdapterString(LPTSTR szInventory);
void GetDisplayAdapter(LPTSTR szDisplayAdapter);
void GetDisplayAdapterWithResolution(LPTSTR);


BOOL IsCoProcessorAvailable(void);
LONG GetTotalHardDiskSpace(void);
void GetDisplayCharacteristics(PINT, PINT, PINT);
void GetWindowsVersion(LONG*, LONG*, LONG*,LONG*);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\rundll32\rundll.c ===
#include "rundll.h"
#include "tchar.h"

#ifndef WIN32
#include <w32sys.h>             // for IsPEFormat definition
#endif

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
#define Reference(x) ((x)=(x))

void WINAPI RunDllErrMsg(HWND hwnd, UINT idStr, LPCTSTR pszTitle, LPCTSTR psz1, LPCTSTR psz2);
int PASCAL WinMainT(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpszCmdLine, int nCmdShow);

TCHAR const g_szAppName [] = TEXT("RunDLL");
TCHAR const s_szRunDLL32[] = TEXT("RUNDLL32.EXE ");
TCHAR const c_szNULL[] = TEXT("");
TCHAR const c_szLocalizeMe[] = TEXT("RUNDLL");

HANDLE g_hActCtx = INVALID_HANDLE_VALUE;
ULONG_PTR g_dwActCtx = 0;
BOOL g_fCatchExceptions = TRUE;

HINSTANCE g_hinst;
HICON g_hIcon;

HINSTANCE g_hModule;
HWND g_hwndStub;
BOOL g_fUseCCV6 = FALSE;

#ifdef WX86

#include <wx86dll.h>

WX86LOADX86DLL_ROUTINE pWx86LoadX86Dll = NULL;
WX86THUNKPROC_ROUTINE pWx86ThunkProc = NULL;
HMODULE g_hWx86Dll = NULL;

#endif

RUNDLLPROC g_lpfnCommand;
#ifdef UNICODE
BOOL g_fCmdIsANSI;   // TRUE if g_lpfnCommand() expects ANSI strings
#endif


#ifndef WIN32
void WINAPI WinExecError(HWND hwnd, int err, LPCTSTR lpstrFileName, LPCTSTR lpstrTitle)
{
    RunDllErrMsg(hwnd, err+IDS_LOADERR, lpstrTitle, lpstrFileName, NULL);
}
#endif


LPTSTR NEAR PASCAL StringChr(LPCTSTR lpStart, TCHAR ch)
{
    for (; *lpStart; lpStart = CharNext(lpStart))
    {
        if (*lpStart == ch)
            return (LPTSTR)lpStart;
    }
    return NULL;
}

#ifdef WIN32
// stolen from the CRT, used to shirink our code

int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPTSTR pszCmdLine = GetCommandLine();

    if ( *pszCmdLine == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfo(&si);

    i = WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}

#endif // WIN32


BOOL NEAR PASCAL ParseCommand(LPTSTR lpszCmdLine, int nCmdShow)
{
    LPTSTR lpStart, lpEnd, lpFunction;
    ACTCTX act;
    TCHAR szManifest[MAX_PATH];
    LPTSTR pszFullPath;
    TCHAR szPath[MAX_PATH];
    TCHAR kszManifest[] = TEXT(".manifest");
    LPTSTR pszName;
    BOOL bManifest = FALSE;

#ifndef WIN32
    LPTSTR pCopy;

    // build a rundll32-based winexec string just in case
    pCopy = (LPTSTR)LocalAlloc(LPTR, lstrlen(lpszCmdLine)*sizeof(TCHAR) + sizeof(s_szRunDLL32));
    if (!pCopy)
            return FALSE;
    lstrcpy(pCopy, s_szRunDLL32);
    lstrcat(pCopy, lpszCmdLine);
#endif

#ifdef DEBUG
OutputDebugString(TEXT("RUNDLL: Command: "));
OutputDebugString(lpszCmdLine);
OutputDebugString(TEXT("\r\n"));
#endif
    for (lpStart=lpszCmdLine; ; )
    {
        // Skip leading blanks
        while (*lpStart == TEXT(' '))
        {
            ++lpStart;
        }

        // Check if there are any switches
        if (*lpStart != TEXT('/'))
        {
            break;
        }

        // Look at all the switches; ignore unknown ones
        for (++lpStart; ; ++lpStart)
        {
            switch (*lpStart)
            {
            case TEXT(' '):
            case TEXT('\0'):
                goto EndSwitches;
                break;

            // Put any switches we care about here
            case TEXT('d'):
            case TEXT('D'):
                // Disable exception catching.
                g_fCatchExceptions = FALSE;
                break;

            default:
                break;
            }
        }
EndSwitches:
        ;
    }

        // If the path is double-quoted, search for the next
        // quote, otherwise, look for a space 
                
        lpEnd = lpStart;
        if ( *lpStart == TEXT('\"') )
        {
            // Skip opening quote
            lpStart++;
                        
            // Scan, and skip over, subsequent characters until
            // another double-quote or a null is encountered.
             
            while ( *++lpEnd && (*lpEnd != TEXT('\"')) )
                NULL;
            if (!*lpEnd)
                return FALSE;
                            
            *lpEnd++ = TEXT('\0');
        }
        else
        {
            // No quotes, so run until a space or a comma
            while ( *lpEnd && (*lpEnd != TEXT(' ')) && (*lpEnd != TEXT(',')))
                lpEnd++;
            if (!*lpEnd)
                return FALSE;

            *lpEnd++ = TEXT('\0');
        }

        // At this point we're just past the terminated dll path.   We
        // then skip spaces and commas, which should take us to the start of the 
        // entry point (lpFunction)

        while ( *lpEnd && ((*lpEnd == TEXT(' ')) || (*lpEnd == TEXT(','))))
            lpEnd++;
        if (!*lpEnd)
            return FALSE;

        lpFunction = lpEnd;

        // If there's a space after the function name, we need to terminate 
        // the function name and move the end pointer, because that's where
        // the arguments to the function live.

        lpEnd = StringChr(lpFunction, TEXT(' '));
        if (lpEnd)
            *lpEnd++ = TEXT('\0');

        // Load the library and get the procedure address
        // Note that we try to get a module handle first, so we don't need
        // to pass full file names around
        //

#ifndef WIN32
        // if loading a 32 bit DLL out of 16bit rundll, exec the
        // 32 bit version of rundll and return
        if (IsPEFormat(lpStart, NULL))
        {
                int err = (int)WinExec(pCopy, nCmdShow);
                WinExecError(NULL, err, lpStart, c_szLocalizeMe);
                LocalFree((HLOCAL)pCopy);
                return FALSE;
        }
        else
        {
                LocalFree((HLOCAL)pCopy);
        }
#endif

        // Get the full name of the DLL
        pszFullPath = lpStart;

        // If the path is not specified, find it
        if (GetFileAttributes(lpStart) == -1)
        {
            if (SearchPath(NULL, lpStart, NULL, MAX_PATH, szPath, &pszName) > 0)
            {
                pszFullPath = szPath;
            }
        }

        // First see if there is an blah.dll.manifest
        act.cbSize = sizeof(act);
        act.dwFlags = 0;

        if (lstrlen(pszFullPath) + ARRAYSIZE(kszManifest) < ARRAYSIZE(szManifest))
        {
            lstrcpy(szManifest, pszFullPath);
            lstrcat(szManifest, kszManifest);
            bManifest = TRUE;
        }

        if (bManifest && GetFileAttributes(szManifest) != -1)
        {
            act.lpSource = szManifest;

            g_hActCtx = CreateActCtx(&act);
        }
        else
        {
            // No? See if there is one in the binary.
            act.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;
            act.lpSource = pszFullPath;
            act.lpResourceName = MAKEINTRESOURCE(123);

            g_hActCtx = CreateActCtx(&act);
        }

        if (g_hActCtx != INVALID_HANDLE_VALUE)
            ActivateActCtx(g_hActCtx, &g_dwActCtx);

        g_hModule = LoadLibrary(lpStart);
#ifdef WIN32

#ifdef WX86

        //
        // If the load fails try it thru wx86, since it might be an
        // x86 on risc binary
        //

        if (g_hModule==NULL) {

            g_hWx86Dll = LoadLibrary(TEXT("wx86.dll"));
            if (g_hWx86Dll) {
                pWx86LoadX86Dll = (PVOID)GetProcAddress(g_hWx86Dll, "Wx86LoadX86Dll");
                pWx86ThunkProc  = (PVOID)GetProcAddress(g_hWx86Dll, "Wx86ThunkProc");
                if (pWx86LoadX86Dll && pWx86ThunkProc) {
                    g_hModule = pWx86LoadX86Dll(lpStart, 0);
                    }
                }

            if (!g_hModule) {
                if (g_hWx86Dll) {
                    FreeLibrary(g_hWx86Dll);
                    g_hWx86Dll = NULL;
                    }
                }
            }
#endif


        if (g_hModule==NULL)
        {
            TCHAR szSysErrMsg[MAX_PATH];
            BOOL fSuccess = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                              NULL, GetLastError(), 0, szSysErrMsg, ARRAYSIZE(szSysErrMsg), NULL);
            if (fSuccess)
            {
                RunDllErrMsg(NULL, IDS_CANTLOADDLL, c_szLocalizeMe, lpStart, szSysErrMsg);
            }
            return FALSE;
        }
#else
        if ((UINT)g_hModule <= 32)
        {
            WinExecError(NULL, (int)g_hModule, lpStart, c_szLocalizeMe);
            return(FALSE);
        }
#endif

#ifdef WINNT        // REVIEW: May need this on Nashville too...
        //
        // Check whether we need to run as a different windows version
        //
        // Stolen from ntos\mm\procsup.c
        //
        //
        {
            PPEB Peb = NtCurrentPeb();
            PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)g_hModule;
            PIMAGE_NT_HEADERS pHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)g_hModule + pDosHeader->e_lfanew);
            PIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigData;
            ULONG ReturnedSize;

            if (pHeader->FileHeader.SizeOfOptionalHeader != 0 &&
                pHeader->OptionalHeader.Win32VersionValue != 0)
            {
                Peb->OSMajorVersion = pHeader->OptionalHeader.Win32VersionValue & 0xFF;
                Peb->OSMinorVersion = (pHeader->OptionalHeader.Win32VersionValue >> 8) & 0xFF;
                Peb->OSBuildNumber  = (USHORT)((pHeader->OptionalHeader.Win32VersionValue >> 16) & 0x3FFF);
                Peb->OSPlatformId   = (pHeader->OptionalHeader.Win32VersionValue >> 30) ^ 0x2;
            }

            ImageConfigData = ImageDirectoryEntryToData( Peb->ImageBaseAddress,
                                                         TRUE,
                                                         IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
                                                         &ReturnedSize
                                                   );
            if (ImageConfigData != NULL && ImageConfigData->CSDVersion != 0)
            {
                Peb->OSCSDVersion = ImageConfigData->CSDVersion;
            }
        }
#endif

#ifdef UNICODE
        {
            /*
             * Look for a 'W' tagged Unicode function.
             * If it is not there, then look for the 'A' tagged ANSI function
             * if we cant find that one either, then look for an un-tagged function
             */
            LPSTR lpstrFunctionName;
            UINT cchLength;

            cchLength = lstrlen(lpFunction)+1;
            g_fCmdIsANSI = FALSE;

            lpstrFunctionName = (LPSTR)LocalAlloc(LMEM_FIXED, (cchLength+1)*2);    // +1 for "W",  *2 for DBCS

            if (lpstrFunctionName && (WideCharToMultiByte (CP_ACP, 0, lpFunction, cchLength,
                             lpstrFunctionName, cchLength*2, NULL, NULL))) {

                cchLength = lstrlenA(lpstrFunctionName);
                lpstrFunctionName[cchLength] = 'W';        // convert name to Wide version
                lpstrFunctionName[cchLength+1] = '\0';

                g_lpfnCommand = (RUNDLLPROC)GetProcAddress(g_hModule, lpstrFunctionName);

                if (g_lpfnCommand == NULL) {
                    // No UNICODE version, try for ANSI
                    lpstrFunctionName[cchLength] = 'A';        // convert name to ANSI version
                    g_fCmdIsANSI = TRUE;

                    g_lpfnCommand = (RUNDLLPROC)GetProcAddress(g_hModule, lpstrFunctionName);

                    if (g_lpfnCommand == NULL) {
                        // No ANSI version either, try for non-tagged
                        lpstrFunctionName[cchLength] = '\0';        // convert name to ANSI version

                        g_lpfnCommand = (RUNDLLPROC)GetProcAddress(g_hModule, lpstrFunctionName);
                    }
                }
            }
            if (lpstrFunctionName) {
                LocalFree((LPVOID)lpstrFunctionName);
            }
        }
#else
        {
            /*
             * Look for 'A' tagged ANSI version.
             * If it is not there, then look for a non-tagged function.
             */
            LPSTR pszFunction;
            int  cchFunction;

            g_lpfnCommand = NULL;

            cchFunction = lstrlen(lpFunction);

            pszFunction = LocalAlloc(LMEM_FIXED, cchFunction + sizeof(CHAR) * 2);  // string + 'A' + '\0'
            if (pszFunction != NULL)

                CopyMemory(pszFunction, lpFunction, cchFunction);

                pszFunction[cchFunction++] = 'A';
                pszFunction[cchFunction] = '\0';

                g_lpfnCommand = (RUNDLLPROC)GetProcAddress(g_hModule, achFunction);

                LocalFree(pszFunction);
            }

            if (g_lpfnCommand == NULL) {
                // No "A" tagged function, just look for the non tagged name
                g_lpfnCommand = (RUNDLLPROC)GetProcAddress(g_hModule, lpFunction);
            }
        }
#endif

#ifdef WX86
        if (g_lpfnCommand && g_hWx86Dll) {
            g_lpfnCommand = pWx86ThunkProc(g_lpfnCommand, (PVOID)4, TRUE);
            }
#endif

        if (!g_lpfnCommand)
        {
                RunDllErrMsg(NULL, IDS_GETPROCADRERR, c_szLocalizeMe, lpStart, lpFunction);
                FreeLibrary(g_hModule);
                return(FALSE);
        }

        // Copy the rest of the command parameters down
        //
        if (lpEnd)
        {
                lstrcpy(lpszCmdLine, lpEnd);
        }
        else
        {
                *lpszCmdLine = TEXT('\0');
        }

        return(TRUE);
}

#ifdef WINNT

LRESULT NEAR PASCAL StubNotify(HWND hWnd, WPARAM wParam, RUNDLL_NOTIFY FAR *lpn)
{
        switch (lpn->hdr.code)
        {
        case RDN_TASKINFO:
// don't need to set title too
//              SetWindowText(hWnd, lpn->lpszTitle ? lpn->lpszTitle : c_szNULL);
                g_hIcon = lpn->hIcon ? lpn->hIcon :
                        LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_DEFAULT));

                SetClassLongPtr(hWnd, GCLP_HICON, (DWORD_PTR)g_hIcon);

                return 0L;

        default:
                return(DefWindowProc(hWnd, WM_NOTIFY, wParam, (LPARAM)lpn));
        }
}

#endif

LRESULT CALLBACK WndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
        switch(iMessage)
        {
        case WM_CREATE:
                g_hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_DEFAULT));
                break;

        case WM_DESTROY:
                break;

#ifdef WINNT
        case WM_NOTIFY:
                return(StubNotify(hWnd, wParam, (RUNDLL_NOTIFY *)lParam));
#endif

#ifdef COOLICON
        case WM_QUERYDRAGICON:
                return(MAKELRESULT(g_hIcon, 0));
#endif

        default:
                return DefWindowProc(hWnd, iMessage, wParam, lParam) ;
                break;
        }

        return 0L;
}


BOOL NEAR PASCAL InitStubWindow(HINSTANCE hInst, HINSTANCE hPrevInstance)
{
        WNDCLASS wndclass;

        if (!hPrevInstance)
        {
                wndclass.style         = 0 ;
                wndclass.lpfnWndProc   = WndProc ;
                wndclass.cbClsExtra    = 0 ;
                wndclass.cbWndExtra    = 0 ;
                wndclass.hInstance     = hInst ;
#ifdef COOLICON
                wndclass.hIcon         = NULL ;
#else
                wndclass.hIcon         = LoadIcon(hInst, MAKEINTRESOURCE(IDI_DEFAULT)) ;
#endif
                wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
                wndclass.hbrBackground = GetStockObject (WHITE_BRUSH) ;
                wndclass.lpszMenuName  = NULL ;
                wndclass.lpszClassName = g_szAppName ;

                if (!RegisterClass(&wndclass))
                {
                        return(FALSE);
                }
        }

        g_hwndStub = CreateWindowEx(WS_EX_TOOLWINDOW,
                                    g_szAppName, c_szNULL, WS_OVERLAPPED, CW_USEDEFAULT, CW_USEDEFAULT, 0, 0, NULL, NULL, hInst, NULL);

        return(g_hwndStub != NULL);
}


void NEAR PASCAL CleanUp(void)
{
        DestroyWindow(g_hwndStub);

        FreeLibrary(g_hModule);
}


int PASCAL WinMainT (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpszCmdLine, int nCmdShow)
{
        LPTSTR lpszCmdLineCopy;
        HANDLE hFusionManifest;

        g_hinst = hInstance;

        // make a copy of lpCmdLine, since ParseCommand modifies the string
        lpszCmdLineCopy = LocalAlloc(LPTR, (_tcslen(lpszCmdLine)+1)*sizeof(TCHAR));
        if (!lpszCmdLineCopy)
        {
            goto Error0;
        }
        _tcscpy(lpszCmdLineCopy, lpszCmdLine);

        if (!ParseCommand(lpszCmdLineCopy, nCmdShow))
        {
                goto Error1;
        }

        // turn off critical error bullshit
        SetErrorMode(g_fCatchExceptions ? (SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS) : SEM_NOOPENFILEERRORBOX);

        if (!InitStubWindow(hInstance, hPrevInstance))
        {
                goto Error2;
        }

        {
            LPVOID pchCmdLine;

            pchCmdLine = lpszCmdLineCopy;

#ifdef UNICODE

            if (g_fCmdIsANSI) {
                int cchCmdLine;

                cchCmdLine = WideCharToMultiByte(CP_ACP, 0, lpszCmdLineCopy, -1, NULL, 0, NULL, NULL);
                pchCmdLine = LocalAlloc( LMEM_FIXED, sizeof(char) * cchCmdLine );
                if (pchCmdLine == NULL) {
                    RunDllErrMsg(NULL, IDS_LOADERR+00, c_szLocalizeMe, lpszCmdLineCopy, NULL);
                    goto Error3;
                }

                WideCharToMultiByte(CP_ACP, 0, lpszCmdLineCopy, -1, pchCmdLine, cchCmdLine, NULL, NULL);
            }
#endif

            if (g_fCatchExceptions)
            {
                try
                {
                    g_lpfnCommand(g_hwndStub, hInstance, pchCmdLine, nCmdShow);
                }
                _except (EXCEPTION_EXECUTE_HANDLER)
                {
                    RunDllErrMsg(NULL, IDS_LOADERR+17, c_szLocalizeMe, lpszCmdLine, NULL);
                }
            }
            else
            {
                g_lpfnCommand(g_hwndStub, hInstance, pchCmdLine, nCmdShow);
            }

#ifdef UNICODE
Error3:
            if (g_fCmdIsANSI) {
                LocalFree(pchCmdLine);
            }
#endif
        }



Error2:
        CleanUp();
Error1:
        LocalFree(lpszCmdLineCopy);
Error0:
        if (g_hActCtx != INVALID_HANDLE_VALUE)
        {
            DeactivateActCtx(0, g_dwActCtx);
            ReleaseActCtx(g_hActCtx);
            g_hActCtx = NULL;
        }

        return(FALSE);
}

void WINAPI RunDllErrMsg(HWND hwnd, UINT idStr, LPCTSTR pszTitle, LPCTSTR psz1, LPCTSTR psz2)
{
    TCHAR szTmp[200];
    TCHAR szMsg[200 + MAX_PATH];

    if (LoadString(g_hinst, idStr, szTmp, ARRAYSIZE(szTmp)))
    {
        wsprintf(szMsg, szTmp, psz1, psz2);
        MessageBox(hwnd, szMsg, pszTitle, MB_OK|MB_ICONHAND);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\runonce\init.c ===
//---------------------------------------------------------------------------
// Windows 4.0 Task Switcher. Copyright Microsoft Corp. 1993.
// Insept: May 1993     IanEl.
// Bastardised for RunOnce by FelixA.
//---------------------------------------------------------------------------
// #include <windows.h>
#include "precomp.h"

//---------------------------------------------------------------------------
// Global to everybody...
HINSTANCE g_hinst;
HWND g_hwndLB = NULL;
HWND g_hwndMain = NULL;
HWND g_hwndStatus = NULL;
const TCHAR g_szNull[] = TEXT("");

// Icon sizes.
int g_cxIcon = 0;
int g_cyIcon = 0;
int g_cxSmIcon = 0;
int g_cySmIcon = 0;
// Extent of text in buttons.
DWORD g_dwBTextExt = 0;
SIZE g_SizeTextExt;

//---------------------------------------------------------------------------
// Global to this file only...

HFONT g_hfont = NULL;
HFONT g_hBoldFont=NULL;

static int g_iItemCur = 0;
static TCHAR g_szLotsaWs[] = TEXT("WWWWWWWWWW");
HBRUSH g_hbrBkGnd = NULL;

//---------------------------------------------------------------------------
BOOL   CreateGlobals(HWND hwndCtl)
{
    LOGFONT lf;
    HDC hdc;
    HFONT hfontOld;

    g_cxIcon = GetSystemMetrics(SM_CXICON);
    g_cyIcon = GetSystemMetrics(SM_CYICON);
    g_cxSmIcon = GetSystemMetrics(SM_CXSMICON);
    g_cySmIcon = GetSystemMetrics(SM_CYSMICON);
    g_hbrBkGnd = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
//    if (SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, 0))
    if ( (hfontOld = (HFONT)(WORD)SendMessage( hwndCtl, WM_GETFONT, 0, 0L )) != NULL )
    {
        if ( GetObject( hfontOld, sizeof(LOGFONT), (LPTSTR) &lf ) )
        {
            lf.lfWeight=400;
            g_hfont = CreateFontIndirect(&lf);
            lf.lfWeight=700;
            // lf.lfItalic=TRUE;
            g_hBoldFont = CreateFontIndirect(&lf);
        }
    }
        
    if (g_hfont)
    {
        // Calc sensible size for text in buttons.
        hdc = GetDC(NULL);
        hfontOld = SelectObject(hdc, g_hfont);
        GetTextExtentPoint(hdc, g_szLotsaWs, lstrlen(g_szLotsaWs), &g_SizeTextExt);
        SelectObject(hdc, hfontOld);
        ReleaseDC(NULL, hdc);
        return TRUE;
    }
    return FALSE;
}

//---------------------------------------------------------------------------
VOID   DestroyGlobals(void)
{
        if (g_hfont)
                DeleteObject(g_hfont);
        if (g_hBoldFont)
                DeleteObject(g_hBoldFont);
        if (g_hbrBkGnd)
                DeleteObject(g_hbrBkGnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\runonce\debug.c ===
#include "precomp.h"
#pragma  hdrstop

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "runonce"
#define SZ_MODULE           "RUNONCE"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\runonce\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by RUNONCE.RC
//
#define IDS_NEED_REBOOT                 1
#define IDS_NEED_RESTART                2
#define IDS_PAMPER                      3
#define IDD_RUNONCE                     101
#define IDB_BACK_WASH                   103
#define IDD_WASH                        104
#define IDB_BITMAP1                     105
#define IDI_SETUP                       106
#define IDC_LIST2                       1002
#define IDC_WASH_BMP                    1003
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\runonce\rodlg.c ===
// **************************************************************************
//
// rodlg.c
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1992-1993
//  All rights reserved
//
//  RunOnce wrapper. This encapsulates all applications that would like
//  to run the first time we re-boot. It lists these apps for the user
//      and allows the user to launce the apps (like apple at ease).
//
//      5 June 1994     FelixA  Started
//  8 June  Felix   Defined registry strings and functionality.
//                  Got small buttons displayed, but not working.
//  9 June  Felix   Both big and small buttons. Nice UI.
//                  Got single click app launching.
//
// 23 June  Felix   Moving it to a Chicago make thingy not Dolphin
//
// *************************************************************************/
//
#include "precomp.h"
#include <shlobj.h>
#include <stdlib.h>
#include <regstr.h>
#include <shellapi.h>
#include <shlobjp.h>
// #include <shsemip.h>

extern int g_iState;    // Command line args.

extern HINSTANCE g_hInst;          // current instance

#define WM_FINISHED (WM_USER+0x123)

#include "resource.h"

int g_fCleanBoot;
TCHAR c_szRunOnce[]=REGSTR_PATH_RUNONCE;
TCHAR c_szSetup[]=REGSTR_PATH_SETUP;
TCHAR g_szWallpaper[] = TEXT("wallpaper");
TCHAR szTileWall[] = TEXT("TileWallpaper");
TCHAR szFallback[] = TEXT("*DisplayFallback");
const TCHAR c_szTimeChangedRunOnce[] = TEXT("WarnTimeChanged"); //kernel32 and explorer use this

// Run time can be set for big or small buttons.
int g_Small=0;
HDC g_hdcMem=NULL;
DWORD g_dwThread;

//***************************************************************************
//
// <Function>()
// <Explanation>
//
// ENTRY:
//      <Params>
//
// EXIT:
//      <Params>
//
//***************************************************************************

//***************************************************************************
//
// DoAnyRandomOneTimeStuff()
//   Just a place to toss random stuff for RunOnce app to do.
//
// ENTRY:
//      void
//
// EXIT:
//      void
//
//***************************************************************************
void DoAnyRandomOneTimeStuff(void)
{
    HKEY runonce;

    // remove any time-changed warning added by kernel32 during boot
    if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szRunOnce, &runonce) == ERROR_SUCCESS)
    {
        RegDeleteValue(runonce, (LPCTSTR)c_szTimeChangedRunOnce);
        RegCloseKey(runonce);
    }
}

//***************************************************************************
//
// RunOnceFill()
//   Fills the List box in the run-once dlg.
//
// ENTRY:
//      HWND of the thing to fill.
//
// EXIT:
//      <Params>
// BOOL NEAR PASCAL RunRegApps(HKEY hkeyParent, LPCSTR szSubkey, BOOL fDelete, BOOL fWait)
//
//***************************************************************************
BOOL   RunOnceFill(HWND hWnd)
{
    HKEY hkey;
    // HKEY hDescKey;
    BOOL fShellInit = FALSE;
    HKEY hkeyParent = HKEY_LOCAL_MACHINE;
    TCHAR szSubkey[MAX_PATH];
    BOOL fDelete=FALSE;
    BOOL fWait=FALSE;

    // Enumerate HKLM\Runonce\Setup - *.*
    lstrcpy(szSubkey,c_szRunOnce);
    lstrcat(szSubkey,TEXT("\\Setup"));
    if (RegOpenKey(hkeyParent, szSubkey, &hkey) == ERROR_SUCCESS)
    {
        DWORD cbData, cchValue, dwType, i;
        TCHAR szValueName[MAX_PATH], szCmdLine[MAX_PATH];
        LRESULT lRes;
        DWORD dwNumSubkeys=1, dwNumValues=5;

        for (i = 0; ; i++)
        {
            cchValue = sizeof(szValueName) / sizeof(TCHAR);
            cbData = sizeof(szCmdLine);

            if (RegEnumValue(hkey, i, szValueName, &cchValue, NULL, &dwType, (LPBYTE) szCmdLine, &cbData) != ERROR_SUCCESS)
                break;

            if (dwType == REG_SZ)
            {
                PTASK pTask;
                pTask = (PTASK)LocalAlloc( LPTR ,sizeof(TASK));
                lstrcpyn(pTask->Text,szValueName, MAX_TEXT );
                lstrcpyn( pTask->Cmd, szCmdLine, MAX_PATH );
                lRes = SendMessage( hWnd, LB_ADDSTRING,  0, (LPARAM)pTask );
                if( lRes == LB_ERR || lRes == LB_ERRSPACE )
                {
                    LocalFree(pTask);
                    pTask=NULL;
                }
            }
        }
        RegCloseKey(hkey);
    }

    return(fShellInit);
}

//***************************************************************************
//
// LaunchApp()
//  Given an index into the list box, will spawn the task, wait for it to
// finish.
//
// ENTRY:
//      Index into list.
//
// EXIT:
//      <Params>
//
//***************************************************************************
int LaunchApp(HWND hWnd, WORD wItem )
{
    LPTSTR lpszCmdLine;
    STARTUPINFO startup;
#ifndef DEBUG
    PROCESS_INFORMATION pi;
#endif
    PTASK pTask;
    RECT rWnd;

    GetWindowRect(hWnd, &rWnd);
    SendMessage(hWnd,LB_SETCURSEL,wItem,0);
    pTask = (PTASK)SendMessage( hWnd, LB_GETITEMDATA, wItem, 0L);
    if(pTask != (PTASK)LB_ERR )
    {
        lpszCmdLine = &pTask->Cmd[0];

        // Now exec it.
        startup.cb = sizeof(startup);
        startup.lpReserved = NULL;
        startup.lpDesktop = NULL;
        startup.lpTitle = NULL;
        startup.dwFlags = STARTF_USEPOSITION; // Set start position
        startup.dwX=rWnd.right+5;
        startup.dwY=rWnd.top+5;
        startup.cbReserved2 = 0;
        startup.lpReserved2 = NULL;

#ifdef DEBUG
    MessageBox(hWnd, lpszCmdLine,TEXT("DebugRun"),MB_OK);
#else
        if (CreateProcess(NULL, lpszCmdLine, NULL, NULL, FALSE, CREATE_NEW_PROCESS_GROUP,
                          NULL, NULL, &startup, &pi))
        {
            WaitForSingleObjectEx(pi.hProcess, INFINITE, TRUE);
            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
        }
        else
        {
            MessageBeep( MB_ICONEXCLAMATION );
        }
#endif
    }
    else
    {
        MessageBeep( MB_ICONEXCLAMATION );
    }



    // Remove any selection after the app terminates.
    SendMessage( hWnd, LB_SETCURSEL, (WPARAM)-1, 0);
    return FALSE;
}

//***************************************************************************
//
// RunAppsInList()
// Enumerates all the items in the list box, spawning each in turn.
//
// ENTRY:
//      HWND of Parent.
//
// EXIT:
//      <Params>
//
//***************************************************************************
DWORD WINAPI RunAppsInList(LPVOID lp)
{
    HWND hWnd=(HWND)lp;
    WORD i,iNumItems;
    TCHAR szSubkey[MAX_PATH];
    TCHAR szWallpaper[MAX_PATH];
    DWORD cbSize;
    DWORD dwType;

    // Run all the applications in the list
    iNumItems = (WORD)SendMessage(hWnd,LB_GETCOUNT,0,0L);
    for(i=0;i<iNumItems;i++)
    {
        LaunchApp(hWnd,i);
    }

    // Delete the runonce subkey for setup.
#ifdef DEBUG
    MessageBox( hWnd, szSubkey, TEXT("Delete Key - not done"), MB_OK);
#else
    lstrcpy(szSubkey,c_szRunOnce);
    lstrcat(szSubkey,TEXT("\\Setup"));
    RegDeleteKey( HKEY_LOCAL_MACHINE, szSubkey );
#endif


    // Now see if we should reboot/restart.
    if (g_iState & (CMD_DO_REBOOT|CMD_DO_RESTART))
    {
        HKEY hkey;
        TCHAR achTitle[80];
        DWORD dwSetupFlags=0;

        //
        // because we are going to reboot, remove the VGA fallback.
        // line from OneRunce.
        //
        if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szRunOnce, &hkey) == ERROR_SUCCESS)
        {
            RegDeleteValue(hkey, szFallback);
            RegCloseKey(hkey);
        }

        szWallpaper[0]=0;
        LoadString(g_hInst, IDS_PAMPER, szWallpaper, sizeof(szWallpaper) / sizeof(TCHAR));
        GetWindowText(GetParent(hWnd), achTitle, sizeof(achTitle) / sizeof(TCHAR));

        // Get the setup flags.
        if(RegOpenKey(HKEY_LOCAL_MACHINE, c_szSetup, &hkey) == ERROR_SUCCESS)
        {
            cbSize=sizeof(dwSetupFlags);
            if(RegQueryValueEx(hkey, REGSTR_VAL_SETUPFLAGS, NULL , &dwType, (LPBYTE)&dwSetupFlags, &cbSize) != ERROR_SUCCESS )
                dwSetupFlags=0;
            RegCloseKey(hkey);
        }
        //
        //  always reboot the system, dont give the user a choice.
        //
        //  alow OEMs not to have to click OK.
#ifdef DEBUG
        MessageBox(hWnd,dwSetupFlags & SUF_BATCHINF?TEXT("Batchfile used"):TEXT("No batch"),TEXT("Batch"),MB_OK);
#endif
        if( !(dwSetupFlags & SUF_BATCHINF) || !GetPrivateProfileInt(TEXT("Setup"),TEXT("NoPrompt2Boot"),0,TEXT("MSBATCH.INF")))
            MessageBox(GetParent(hWnd),szWallpaper,achTitle,MB_OK|MB_ICONEXCLAMATION);
#ifndef DEBUG
        ExitWindowsEx(EWX_REBOOT, 0);
#endif
    }

    PostMessage(GetParent(hWnd),WM_FINISHED,0,0L);
    return 0;
}


//***************************************************************************
//
// <Function>()
// <Explanation>
//
// ENTRY:
//      <Params>
//
// EXIT:
//      <Params>
//
//***************************************************************************
#define CXBORDER 3

LRESULT   _HandleLBMeasureItem(HWND hwndLB, MEASUREITEMSTRUCT  *lpmi)
{
    RECT    rWnd;
    int     wWnd;
    HDC     hDC;
    HFONT   hfontOld;
    PTASK   pTask;

    // Get the Height and Width of the child window
    GetWindowRect (hwndLB, &rWnd);
    wWnd = rWnd.right - rWnd.left;

    lpmi->itemWidth = wWnd;

    pTask = (PTASK)lpmi->itemData;

    hDC= GetDC(NULL);
    if( (hfontOld  = SelectObject(hDC,g_hBoldFont)) != 0 )
    {
        rWnd.top    = 0;
        rWnd.left   = CXBORDER*2 + g_cxSmIcon;
        rWnd.right  = lpmi->itemWidth - rWnd.left - CXBORDER*2 - g_cxSmIcon;
        rWnd.bottom = 0;
        DrawText(hDC,pTask->Text, lstrlen(pTask->Text),&rWnd, DT_CALCRECT | DT_WORDBREAK );
        SelectObject(hDC, hfontOld);
    }
    ReleaseDC(NULL,hDC);

    lpmi->itemHeight = rWnd.bottom + 2*CXBORDER;

    return TRUE;
}

//---------------------------------------------------------------------------
//***************************************************************************
//
// <Function>()
// <Explanation>
//
// ENTRY:
//      <Params>
//
// EXIT:
//      <Params>
//
//***************************************************************************
LRESULT   _HandleMeasureItem(HWND hwnd, MEASUREITEMSTRUCT  *lpmi)
{
    if (lpmi->CtlType == ODT_LISTBOX)
        return _HandleLBMeasureItem(hwnd, lpmi);
    return TRUE;
}

//---------------------------------------------------------------------------
//***************************************************************************
//
// _HandleLBDrawItem()
//  Draws the Title, Text, and icon for an entry.
//
// ENTRY:
//      HWND and the Item to draw.
//
// EXIT:
//      <Params>
//
//***************************************************************************
LRESULT   _HandleLBDrawItem(HWND hwndLB, DRAWITEMSTRUCT  *lpdi)
{
    RECT rc;
    HFONT hfontOld;
    int xArrow,y;
    PTASK pTask;
    BITMAP bm;
    HGDIOBJ hbmArrow,hbmOld;

    // Don't draw anything for an empty list.
    if ((int)lpdi->itemID < 0)
        return TRUE;

    pTask = (PTASK)lpdi->itemData;
    if(pTask == (PTASK)LB_ERR || !pTask )
        return FALSE;

    if ((lpdi->itemAction & ODA_SELECT) || (lpdi->itemAction & ODA_DRAWENTIRE))
    {
        // Put in the Title text
        hfontOld  = SelectObject(lpdi->hDC,(lpdi->itemState & ODS_SELECTED)?g_hBoldFont:g_hfont);
        ExtTextOut(lpdi->hDC,
                   lpdi->rcItem.left+ CXBORDER*2 + g_cxSmIcon,
                   lpdi->rcItem.top+CXBORDER,
                   ETO_OPAQUE,
                   &lpdi->rcItem,
                   NULL, 0,
                   NULL);
        rc.top    = lpdi->rcItem.top    + CXBORDER;
        rc.left   = lpdi->rcItem.left   + CXBORDER*2 + g_cxSmIcon;
        rc.right  = lpdi->rcItem.right;
        rc.bottom = lpdi->rcItem.bottom;
        DrawText( lpdi->hDC,
                   pTask->Text, lstrlen(pTask->Text),
                   &rc,
                   DT_WORDBREAK);
        SelectObject(lpdi->hDC, hfontOld);

    // Draw the little triangle thingies.
    if(lpdi->itemState & ODS_SELECTED)
    {
        if (!g_hdcMem)
        {
            g_hdcMem = CreateCompatibleDC(lpdi->hDC);
        }
        // selected SRCSTENCIL=0x00d8074a
        // not selected SRCAND.
        if (g_hdcMem)
        {
            hbmArrow = LoadBitmap(NULL, MAKEINTRESOURCE(OBM_MNARROW));
            GetObject(hbmArrow, sizeof(bm), &bm);
            hbmOld = SelectObject(g_hdcMem, hbmArrow);
            xArrow = lpdi->rcItem.left + CXBORDER; // - bm.bmWidth;
            y = ((g_SizeTextExt.cy - bm.bmHeight)/2) + CXBORDER + lpdi->rcItem.top;
            BitBlt(lpdi->hDC, xArrow, y, bm.bmWidth, bm.bmHeight, g_hdcMem, 0, 0, SRCAND); // dwRop);
            SelectObject(g_hdcMem, hbmOld);
            DeleteObject(hbmArrow);
        }
    }
    }
    return TRUE;
}

//---------------------------------------------------------------------------
LRESULT   _HandleCtlColorListbox(HWND hwnd, HDC hdc)
{
    SetBkColor(hdc, GetSysColor(COLOR_BTNFACE));
    return (LRESULT) g_hbrBkGnd;
}

//---------------------------------------------------------------------------
LRESULT   _HandleDrawItem(HWND hwnd, DRAWITEMSTRUCT  *lpdi)
{
    if (lpdi->CtlType == ODT_LISTBOX)
        return _HandleLBDrawItem(hwnd, lpdi);
    return TRUE;
}

//---------------------------------------------------------------------------
LRESULT   _HandleDeleteItem(HWND hwnd, DELETEITEMSTRUCT  *lpdi)
{
    if(lpdi)
        if(lpdi->itemData)
        {
            LocalFree( (HLOCAL)lpdi->itemData );
            return TRUE;
        }
    return FALSE;
}

//***************************************************************************
//
// ShrinkToFit()
//     Makes the List box no bigger then it has to be
//     makes the parent window rsize to the LB size.
//
// ENTRY:
//     hwnd Parent
//     hwnd List box
//
// EXIT:
//
//***************************************************************************
void ShrinkToFit( HWND hWnd, HWND hLb )
{
    LONG lCount;
    LONG lNumItems;
    LONG lTotalHeight;
    LONG lHeight;
    RECT rWnd;
    LONG lChange;

    lNumItems = (LONG)SendMessage( hLb, LB_GETCOUNT, 0, 0L );
    lTotalHeight =0;
    for( lCount=0;lCount<lNumItems; lCount++ )
    {
         lHeight = (LONG)SendMessage( hLb, LB_GETITEMHEIGHT, lCount, 0L );
         lTotalHeight+=lHeight;
    }

    // Set the height of the ListBox to the number of items in it.
    GetWindowRect (hLb, &rWnd);
    SetWindowPos( hLb, hWnd, 0,0,
        rWnd.right - rWnd.left - (CXBORDER*2 + g_cxSmIcon) ,
        lTotalHeight,
        SWP_NOMOVE | SWP_SHOWWINDOW | SWP_NOZORDER );

    // Work out how much it changed in height
    lChange = lTotalHeight - (rWnd.bottom-rWnd.top);

    // Size the parent to fit around the child.
    GetWindowRect(hWnd, &rWnd);
    SetWindowPos( hWnd,0, 0,0,
        rWnd.right - rWnd.left,
        rWnd.bottom-rWnd.top + lChange,
        SWP_NOMOVE | SWP_SHOWWINDOW | SWP_NOZORDER );
}


//***************************************************************************
//
// <Function>()
// <Explanation>
//
// ENTRY:
//      <Params>
//
// EXIT:
//      <Params>
//
//***************************************************************************
LRESULT CALLBACK dlgProcRunOnce(
                HWND hWnd,         // window handle
                UINT message,      // type of message
                WPARAM uParam,     // additional information
                LPARAM lParam)     // additional information
{
    int wmId, wmEvent;
    HANDLE hThread;

    switch (message)
    {
        case WM_DELETEITEM:
            return _HandleDeleteItem( hWnd, (LPDELETEITEMSTRUCT)lParam );

        case WM_MEASUREITEM:
            return _HandleMeasureItem(hWnd, (MEASUREITEMSTRUCT  *) lParam);

        case WM_DRAWITEM:
            return _HandleDrawItem(hWnd, (DRAWITEMSTRUCT  *) lParam);

        case WM_INITDIALOG:
            CreateGlobals( hWnd );
            DoAnyRandomOneTimeStuff();
            g_fCleanBoot = GetSystemMetrics(SM_CLEANBOOT);
            TopLeftWindow( hWnd, GetParent(hWnd) );
            RunOnceFill( GetDlgItem(hWnd,IDC_LIST2) );
            // Now calculate the size needed for the LB and resize LB and parent.
            ShrinkToFit( hWnd, GetDlgItem(hWnd,IDC_LIST2));
            hThread = CreateThread(NULL, 0, RunAppsInList, (LPVOID)GetDlgItem(hWnd,IDC_LIST2),0, &g_dwThread );
            CloseHandle(hThread);
        break;

        case WM_FINISHED:
            EndDialog(hWnd,0);
            // DestroyWindow(hWnd);
        break;

        case WM_CTLCOLORLISTBOX:
            return _HandleCtlColorListbox((HWND)lParam, (HDC)uParam);

        case WM_COMMAND:  // message: command from application menu
            wmId    = LOWORD(uParam);
            wmEvent = HIWORD(uParam);
            if( wmEvent==LBN_SELCHANGE )
            {
                // LaunchApp( (HWND) lParam, LOWORD(uParam) );
                // De-select the item now.
                break;
            }
            else
            switch (wmId)
            {
                case IDOK:
                    EndDialog( hWnd, wmId);
                break;

                default:
                    // return (DefWindowProc(hWnd, message, uParam, lParam));
                break;
            }
        break;


        default:          // Passes it on if unproccessed
           // return (DefWindowProc(hWnd, message, uParam, lParam));
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\common.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1989 - 1999

!ENDIF

SEC_DIR = ..\..

C_DEFINES   = $(C_DEFINES) -DSTRICT -DUNICODE -D_UNICODE

USE_ATL=1

INCLUDES=\
    ..;\
    $(SEC_DIR)\inc;\

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

#
# Define PROFILE to enable IceCAP profiling.
#
!IF "$(PROFILE)" == "1"
USE_ICECAP=1
C_DEFINES=$(C_DEFINES) -DPROFILE
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\runonce\precomp.h ===
#define OEMRESOURCE
#include <windows.h>
#include <ccstock.h>
#include <debug.h>

BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, int);
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
BOOL   RunOnceFill(HWND hWnd);
LRESULT CALLBACK dlgProcRunOnce(
                HWND hWnd,         // window handle
                UINT message,      // type of message
                WPARAM uParam,     // additional information
                LPARAM lParam);     // additional information
void WashCreate(HWND hwndParent);

BOOL   CreateGlobals(HWND hwndCtl);
BOOL CenterWindow (HWND hwndChild, HWND hwndParent);
BOOL TopLeftWindow(HWND hwndChild, HWND hwndParent);

extern SIZE g_SizeTextExt;
extern int g_cxIcon;
extern int g_cyIcon;
extern int g_cxSmIcon;
extern int g_cySmIcon;
extern HFONT g_hfont;
extern HBRUSH g_hbrBkGnd;
extern HFONT g_hBoldFont;
extern HINSTANCE hInst;
extern HWND g_hWash;

#define MAX_TITLE 32
#define MAX_TEXT 128

typedef struct tagTASK
{
     TCHAR Text[MAX_TEXT+1];
     WORD wHeight;
     HICON hIcon;
     TCHAR Cmd[MAX_PATH+1];
} TASK,  * PTASK;

// Bit fields for command line switches.
#define CMD_DO_CHRIS 1
#define CMD_DO_REBOOT 2
#define CMD_DO_RESTART 4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\aceedit.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       aceedit.cpp
//
//  This file contains the implementation for the advanced ACE editor
//  page.
//
//--------------------------------------------------------------------------

#include "aclpriv.h"
#include "sddl.h"       // ConvertSidToStringSid

#define PWM_SELECT_PAGE             (WM_APP - 1)

//
//  Context Help IDs.
//
const static DWORD aAcePermHelpIDs[] =
{
    IDC_ACEE_INHERITWARNING,        IDH_NOHELP,
    IDC_ACEE_NAME_STATIC,           IDH_ACEE_PERM_NAME,
    IDC_ACEE_NAME,                  IDH_ACEE_PERM_NAME,
    IDC_ACEE_NAMEBUTTON,            IDH_ACEE_PERM_NAMEBUTTON,
    IDC_ACEE_APPLYONTO_STATIC,      IDH_ACEE_PERM_INHERITTYPE,
    IDC_ACEE_INHERITTYPE,           IDH_ACEE_PERM_INHERITTYPE,
    IDC_ACEE_ACCESS,                IDH_ACEE_PERM_LIST,
    IDC_ACEE_ALLOW,                 IDH_ACEE_PERM_LIST,
    IDC_ACEE_DENY,                  IDH_ACEE_PERM_LIST,
    IDC_ACEE_LIST,                  IDH_ACEE_PERM_LIST,
    IDC_ACEE_INHERITIMMEDIATE,      IDH_ACEE_PERM_INHERITIMMEDIATE,
    IDC_ACEE_CLEAR,                 IDH_ACEE_PERM_CLEAR,
    0, 0
};
const static DWORD aAceAuditHelpIDs[] =
{
    IDC_ACEE_INHERITWARNING,        IDH_NOHELP,
    IDC_ACEE_NAME_STATIC,           IDH_ACEE_AUDIT_NAME,
    IDC_ACEE_NAME,                  IDH_ACEE_AUDIT_NAME,
    IDC_ACEE_NAMEBUTTON,            IDH_ACEE_AUDIT_NAMEBUTTON,
    IDC_ACEE_APPLYONTO_STATIC,      IDH_ACEE_AUDIT_INHERITTYPE,
    IDC_ACEE_INHERITTYPE,           IDH_ACEE_AUDIT_INHERITTYPE,
    IDC_ACEE_ACCESS,                IDH_ACEE_AUDIT_LIST,
    IDC_ACEE_ALLOW,                 IDH_ACEE_AUDIT_LIST,
    IDC_ACEE_DENY,                  IDH_ACEE_AUDIT_LIST,
    IDC_ACEE_LIST,                  IDH_ACEE_AUDIT_LIST,
    IDC_ACEE_INHERITIMMEDIATE,      IDH_ACEE_AUDIT_INHERITIMMEDIATE,
    IDC_ACEE_CLEAR,                 IDH_ACEE_AUDIT_CLEAR,
    0, 0
};


class CACEPage : public CSecurityPage
{
private:
    PACE            m_pAce;
    HDPA           *m_phEntries;
    PSID            m_pSid;
    DWORD           m_siFlags;
    DWORD          *m_pdwResult;
    GUID            m_guidInheritType;
    BOOL            m_fInheritImmediateEnabled;
    BOOL            m_fPreviousImmediateSetting;
    BOOL            m_fReadOnly;
    BOOL            m_fPageDirty;
    SI_INHERIT_TYPE m_siInheritUnknown;
	CACEPage		*m_pOtherPage;
	HWND			m_hwnd;

public:
    CACEPage(LPSECURITYINFO psi,
             SI_PAGE_TYPE siType,
             PACE pAce,
             BOOL bReadOnly,
             DWORD dwFlags,
             DWORD *pdwResult,
             HDPA *phEntries);
    virtual ~CACEPage();

private:
    virtual BOOL DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Prevent propsheet callbacks from reaching the object that invoked us
    virtual UINT PSPageCallback(HWND, UINT, LPPROPSHEETPAGE) { return 1; }

    void EmptyCheckList(HWND hwndList);
    LONG CheckPermBoxes(HWND hwndList, PACE pAce, DWORD dwState);
    LONG InitCheckList(HWND hDlg, PACE pAce);
    LONG ReInitCheckList(HWND hDlg, HDPA hEntries);
	VOID DisplayNoControlMessage(HWND hDlg, BOOL bDisplay);
    void HideInheritedAceWarning(HWND hDlg);
    void InitDlg(HWND hDlg);
    BOOL OnChangeName(HWND hDlg);
    BOOL OnClearAll(HWND hDlg);
    void HandleSelChange(HWND hDlg, HWND hWnd);
    LONG OnApply(HWND hDlg, BOOL bClose);
	HWND m_hwndNoPerm;
	BOOL IsAclBloated(HWND hDlg);
	HDPA GetAceList(HWND hDlg);
};
typedef class CACEPage *LPACEPAGE;

CACEPage::CACEPage(LPSECURITYINFO psi,
                   SI_PAGE_TYPE siType,
                   PACE pAce,
                   BOOL bReadOnly,
                   DWORD dwFlags,
                   DWORD *pdwResult,
                   HDPA *phEntries)
: CSecurityPage(psi, siType), m_pAce(pAce), m_fReadOnly(bReadOnly),
    m_siFlags(dwFlags), m_pdwResult(pdwResult), m_phEntries(phEntries),
	m_hwndNoPerm(NULL),m_pOtherPage(NULL)
{
    if (m_pdwResult)
        *m_pdwResult = 0;
}

CACEPage::~CACEPage()
{
    if (m_pSid)
        LocalFree(m_pSid);
	if(m_hwndNoPerm)
		DestroyWindow(m_hwndNoPerm);
}


void
CACEPage::EmptyCheckList(HWND hwndList)
{
    SendMessage(hwndList, CLM_RESETCONTENT, 0, 0);
}


LONG
CACEPage::CheckPermBoxes(HWND hwndList, PACE pAce, DWORD dwState)
{
    LONG nLastChecked = -1;
    UINT cItems;
    BOOL bColumnAllow = FALSE;
    BOOL bColumnDeny = FALSE;

    //
    // Check all boxes that correspond to a particular ACE
    //

    if (hwndList == NULL || pAce == NULL)
        return -1;

    if (pAce->AceFlags & INHERITED_ACE)
        dwState |= CLST_DISABLED;

    if (m_siPageType == SI_PAGE_ADVPERM)
    {
        // Only check one column (either allow or deny)

        if (IsEqualACEType(pAce->AceType, ACCESS_ALLOWED_ACE_TYPE))
            bColumnAllow = TRUE;        // Access allowed
        else if (IsEqualACEType(pAce->AceType, ACCESS_DENIED_ACE_TYPE))
            bColumnDeny = TRUE;         // Access denied
        else
            return -1;  // Bogus ACE
    }
    else if (m_siPageType == SI_PAGE_AUDIT)
    {
        // Either or both columns can be checked for audits

        if (pAce->AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG)
            bColumnAllow = TRUE;        // Audit successful access

        if (pAce->AceFlags & FAILED_ACCESS_ACE_FLAG)
            bColumnDeny = TRUE;         // Audit failed access
    }
    else
        return -1;

    cItems = (UINT)SendMessage(hwndList, CLM_GETITEMCOUNT, 0, 0);

    while (cItems > 0)
    {
        PSI_ACCESS pAccess;

        --cItems;
        pAccess = (PSI_ACCESS)SendMessage(hwndList, CLM_GETITEMDATA, cItems, 0);

        //
        // The below expression tests to see if this access mask enables
        // this access "rights" line.  It could have more bits enabled, but
        // as long as it has all of the ones from the pAccess->mask then
        // it effectively has that option enabled.
        //

        if (pAccess &&
            AllFlagsOn(pAce->Mask, pAccess->mask) &&
            (!(pAce->Flags & ACE_OBJECT_TYPE_PRESENT) ||
             IsSameGUID(pAccess->pguid, &pAce->ObjectType)))
        {
            WPARAM wItem;

            nLastChecked = cItems;


            if (bColumnAllow)
            {
                wItem = MAKELONG((WORD)cItems, COLUMN_ALLOW);
                SendMessage(hwndList,
                            CLM_SETSTATE,
                            wItem,
                            (LPARAM)dwState);
            }

            if (bColumnDeny)
            {
                wItem = MAKELONG((WORD)cItems, COLUMN_DENY);
                SendMessage(hwndList,
                            CLM_SETSTATE,
                            wItem,
                            (LPARAM)dwState);
            }
        }
    }

    return nLastChecked;
}


LONG
CACEPage::InitCheckList(HWND hDlg, PACE pAce)
{
    LONG nTopItemChecked;
    HDPA hList = NULL;

    TraceEnter(TRACE_ACEEDIT, "CACEPage::InitCheckList");
    TraceAssert(hDlg != NULL);

    if (m_siPageType == SI_PAGE_AUDIT)
        SendDlgItemMessage(hDlg, IDC_ACEE_LIST, CLM_SETCOLUMNWIDTH, 0, 40);

    hList = DPA_Create(1);
    if (hList && pAce)
        DPA_AppendPtr(hList, pAce->Copy());

    nTopItemChecked = ReInitCheckList(hDlg, hList);

    if (hList)
        DestroyDPA(hList);

    TraceLeaveValue(nTopItemChecked);
}


LONG
CACEPage::ReInitCheckList(HWND hDlg, HDPA hEntries)
{
    LONG nTopItemChecked = -1;
    HWND hwndList;
    DWORD dwFlags;
    HRESULT hr;
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    TraceEnter(TRACE_ACEEDIT, "CACEPage::ReInitCheckList");
    TraceAssert(hDlg != NULL);

    hwndList = GetDlgItem(hDlg, IDC_ACEE_LIST);

    EmptyCheckList(hwndList);

    dwFlags = SI_ADVANCED;

    if (m_siPageType == SI_PAGE_AUDIT)
        dwFlags |= SI_EDIT_AUDITS;

    if (m_siFlags == SI_ACCESS_PROPERTY)
        dwFlags |= SI_EDIT_PROPERTIES;

    //
    // Enumerate the permissions and add to the checklist
    //
    hr = _InitCheckList(hwndList,
                        m_psi,
                        &m_guidInheritType,
                        dwFlags,
                        m_siObjectInfo.hInstance,
                        m_siFlags,
                        NULL);
    if (SUCCEEDED(hr))
    {
        UINT cItems = (UINT)SendMessage(hwndList, CLM_GETITEMCOUNT, 0, 0);
		
		//
		//On object page display the message if number
		//cItems is zero.
		//
		if(m_siFlags == SI_ACCESS_SPECIFIC)
			DisplayNoControlMessage(hDlg, !cItems);

        ULONG cAces = 0;
        
        if (hEntries)
            cAces = DPA_GetPtrCount(hEntries);

        //
        // Check the appropriate boxes
        //
        nTopItemChecked = MAXLONG;
        while (cAces > 0)
        {
            PACE_HEADER pAceHeader;

            --cAces;
            pAceHeader = (PACE_HEADER)DPA_FastGetPtr(hEntries, cAces);
            if (pAceHeader)
            {
                CAce Ace(pAceHeader);
                LONG nTop = CheckPermBoxes(hwndList, &Ace, CLST_CHECKED);
                if (-1 != nTop)
                    nTopItemChecked = min(nTopItemChecked, nTop);
            }
        }
        if (MAXLONG == nTopItemChecked)
            nTopItemChecked = -1;

        // Make sure the top item checked is scrolled into view.
        // (-1 scrolls to the top, same as 0.)
        SendMessage(hwndList, CLM_ENSUREVISIBLE, nTopItemChecked, 0);

        // Disable all of the boxes if we're in read-only mode
        if (m_fReadOnly)
            SendMessage(hwndList, WM_ENABLE, FALSE, 0);
    }

    SetCursor(hcur);
    TraceLeaveValue(nTopItemChecked);
}

VOID CACEPage::DisplayNoControlMessage(HWND hDlg, BOOL bDisplay)
{
	RECT rc;
	if(bDisplay)
	{
		ShowWindow(m_hwndNoPerm, SW_SHOW);
	}
	else
	{
		ShowWindow(m_hwndNoPerm, SW_HIDE);
	}
}

void CACEPage::HideInheritedAceWarning(HWND hDlg)
// Hides the message informing the user that the current ACE is inherited from
// the parent. Also moves and resizes controls as appropriate.
{
    // Array of control IDs to move up
    static UINT rgMoveControls[] =
    {
        IDC_ACEE_NAME_STATIC,
        IDC_ACEE_NAME,
        IDC_ACEE_NAMEBUTTON,
        IDC_ACEE_APPLYONTO_STATIC,
        IDC_ACEE_INHERITTYPE,
        IDC_ACEE_ACCESS,
        IDC_ACEE_ALLOW,
        IDC_ACEE_DENY,
    };

    // Get the message window dimensions
    HWND hwndControl = GetDlgItem(hDlg, IDC_ACEE_INHERITWARNING);
    RECT rect;
    GetWindowRect(hwndControl, &rect);

    // We need to move controls up this amount:
    int nMoveUpAmount = rect.bottom - rect.top;

    // Rather than hide the message window, destroy it altogether so WinHelp
    // doesn't confuse it with the "Name:" static during WM_CONTEXTMENU.
    DestroyWindow(hwndControl);

    // Move each of the controls we need to move up
    for (int nControl = 0; nControl < ARRAYSIZE(rgMoveControls); nControl++)
    {
        hwndControl = GetDlgItem(hDlg, rgMoveControls[nControl]);
        GetWindowRect(hwndControl, &rect);
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rect, 2);
        SetWindowPos(hwndControl,
                     NULL,
                     rect.left,
                     rect.top - nMoveUpAmount,
                     0,
                     0,
                     SWP_NOSIZE | SWP_NOZORDER);
    }

    // Finally, we need to resize the list control, including adjusting its height
    hwndControl = GetDlgItem(hDlg, IDC_ACEE_LIST);
    GetWindowRect(hwndControl, &rect);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rect, 2);
    SetWindowPos(hwndControl,
                 NULL,
                 rect.left,
                 rect.top - nMoveUpAmount,
                 rect.right - rect.left,
                 rect.bottom - (rect.top - nMoveUpAmount),
                 SWP_NOZORDER);
}


//
// Default "Apply onto" strings for when GetInheritTypes
// fails or we don't find a matching inherit type.
//
// If desirable, different strings can be created for
// CONTAINER_INHERIT_ACE vs OBJECT_INHERIT_ACE.
//
static const UINT s_aInheritTypes[] =
{
    IDS_THIS_OBJECT_ONLY,           // 0 = <no inheritance>
    IDS_THIS_OBJECT_AND_SUBOBJECTS, // 1 = OBJECT_INHERIT_ACE
    IDS_THIS_OBJECT_AND_SUBOBJECTS, // 2 = CONTAINER_INHERIT_ACE
    IDS_THIS_OBJECT_AND_SUBOBJECTS, // 3 = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE
};

// These are used when INHERIT_ONLY_ACE is present
static const UINT s_aInheritOnlyTypes[] =
{
    IDS_INVALID_INHERIT,            // 0 = <invalid>
    IDS_SUBOBJECTS_ONLY,            // 1 = OBJECT_INHERIT_ACE
    IDS_SUBOBJECTS_ONLY,            // 2 = CONTAINER_INHERIT_ACE
    IDS_SUBOBJECTS_ONLY,            // 3 = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE
};


static int
_AddInheritType(HWND hInheritType,
                PSI_INHERIT_TYPE psiInheritType,
                HINSTANCE hInstance)
{
    UINT iIndex;
    TCHAR szName[MAX_PATH];
    LPCTSTR pszName = psiInheritType->pszName;

    if (IS_INTRESOURCE(pszName))
    {
        if (LoadString(hInstance,
                       (ULONG)((ULONG_PTR)pszName),
                       szName,
                       ARRAYSIZE(szName)) == 0)
        {
            LoadString(::hModule,
                       IDS_UNKNOWN,
                       szName,
                       ARRAYSIZE(szName));
        }
        pszName = szName;
    }

    iIndex = (UINT)SendMessage(hInheritType, CB_ADDSTRING, 0, (LPARAM)pszName);

    if (CB_ERR != iIndex)
        SendMessage(hInheritType, CB_SETITEMDATA, iIndex, (LPARAM)psiInheritType);

    return iIndex;
}

void
CACEPage::InitDlg(HWND hDlg)
{
#define X_COR 7
#define Y_COR 7
    UCHAR   AceFlags = 0;
    PSID    pSid = NULL;
    LPCTSTR pszName = NULL;
    LPTSTR  pszNameT = NULL;
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    HRESULT hr;

    TraceEnter(TRACE_ACEEDIT, "CACEPage::InitDlg");

	//
	//Store the hDlg
	//

	m_hwnd = hDlg;
	if(m_siFlags == SI_ACCESS_SPECIFIC)
	{
		//
		//Create a label to show message when no generic 
		//permissions exist for the object
		//

		WCHAR szName[1024];
		LoadString(::hModule, IDS_NO_OBJECT_PERM, szName, ARRAYSIZE(szName));

		RECT rc;
		GetWindowRect(GetDlgItem(hDlg,IDC_ACEE_LIST),&rc);
		// Create a new label control
		m_hwndNoPerm = CreateWindowEx(0,
									  TEXT("STATIC"),
									  szName,
									  WS_CHILD | WS_VISIBLE | SS_LEFTNOWORDWRAP | SS_NOPREFIX,
									  X_COR,
									  Y_COR,
									  rc.right - rc.left - 2*X_COR,
									  rc.bottom - rc.top - 2*Y_COR,
									  GetDlgItem(hDlg,IDC_ACEE_LIST),
									  (HMENU)IntToPtr(0xffff),
									  ::hModule,
									  NULL);
		// Set the font
		SendMessage(m_hwndNoPerm,
					WM_SETFONT,
					SendMessage(hDlg, WM_GETFONT, 0, 0),
					0);
	}


    if (m_pAce)
    {
        AceFlags = m_pAce->AceFlags;
        m_guidInheritType = m_pAce->InheritedObjectType;
        pSid = m_pAce->psid;
        pszName = m_pAce->LookupName(m_siObjectInfo.pszServerName, m_psi2);
    }
    else
    {
        if (m_siObjectInfo.dwFlags & SI_CONTAINER)
            AceFlags = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE;

        pSid = QuerySystemSid(UI_SID_World);
    }

    // Make sure the AceFlags are valid
    ACCESS_MASK Mask = 0;
    m_psi->MapGeneric(&m_guidInheritType, &AceFlags, &Mask);

    // Hide the inherit warning and adjust other control positions
    if (!(AceFlags & INHERITED_ACE))
        HideInheritedAceWarning(hDlg);

    // Make a copy of the sid and get the name
    if (pSid)
    {
        PUSER_LIST pUserList = NULL;

        m_pSid = LocalAllocSid(pSid);

        if (pszName == NULL)
        {
            // This should only happen when m_pAce is NULL and we're
            // using UI_SID_World
            if (LookupSid(pSid, m_siObjectInfo.pszServerName, m_psi2, &pUserList))
            {
                TraceAssert(NULL != pUserList);
                TraceAssert(1 == pUserList->cUsers);

                if (BuildUserDisplayName(&pszNameT,
                                         pUserList->rgUsers[0].pszName,
                                         pUserList->rgUsers[0].pszLogonName)
                    || ConvertSidToStringSid(pSid, &pszNameT))
                {
                    pszName = pszNameT;
                }
            }
        }

        SetDlgItemText(hDlg, IDC_ACEE_NAME, pszName);

        if (NULL != pUserList)
            LocalFree(pUserList);
    }

    // Get the list of permissions and initialize the check boxes
    LONG nTopChecked = InitCheckList(hDlg, m_pAce);

    if (-1 == nTopChecked &&
        m_pAce &&
        m_pAce->Mask &&
        (m_siObjectInfo.dwFlags & SI_EDIT_PROPERTIES) &&
        m_siFlags != SI_ACCESS_PROPERTY)
    {
        // Must be a property ACE, switch to the Properties page
        PostMessage(hDlg, PWM_SELECT_PAGE, 1, 0);
    }

    HWND hInheritType = GetDlgItem(hDlg, IDC_ACEE_INHERITTYPE);
    HWND hInheritImmed = GetDlgItem(hDlg, IDC_ACEE_INHERITIMMEDIATE);

    if (m_siObjectInfo.dwFlags & SI_NO_TREE_APPLY)
    {
        ShowWindow(hInheritImmed, SW_HIDE);
        EnableWindow(hInheritImmed, FALSE);
    }

    //
    // Get inherit types from callback
    //
    ULONG cItems = 0;
    PSI_INHERIT_TYPE psiInheritType = NULL;

    hr = m_psi->GetInheritTypes(&psiInheritType, &cItems);
    if (SUCCEEDED(hr))
    {
        // Check these inherit bits for a match
        DWORD dwInheritMask = INHERIT_ONLY_ACE | ACE_INHERIT_ALL;

        // Don't check INHERIT_ONLY_ACE if the ACE inherit type
        // matches the current object
        if ((m_siObjectInfo.dwFlags & SI_OBJECT_GUID) &&
            IsSameGUID(&m_siObjectInfo.guidObjectType, &m_guidInheritType))
        {
            dwInheritMask &= ~INHERIT_ONLY_ACE;
        }

        //
        // Add inherit types to combobox
        //
        for ( ; cItems > 0; cItems--, psiInheritType++)
        {
            UINT iIndex = _AddInheritType(hInheritType,
                                          psiInheritType,
                                          m_siObjectInfo.hInstance);

            // See if this entry matches the incoming ACE
            if ((psiInheritType->dwFlags & dwInheritMask) == (ULONG)(AceFlags & dwInheritMask)
                && IsSameGUID(&m_guidInheritType, psiInheritType->pguid))
            {
                // Got a match, select this entry
                SendMessage(hInheritType, CB_SETCURSEL, iIndex, 0);
            }
        }
    }

    //
    // If GetInheritTypes failed, or we failed to find a match,
    // pick a default string and build an appropriate inherit type.
    //
    if (FAILED(hr) || CB_ERR == SendMessage(hInheritType, CB_GETCURSEL, 0, 0))
    {
        // Pick a default string
        UINT ids = IDS_SPECIAL;
        if (IsNullGUID(&m_guidInheritType))
        {
            if (AceFlags & INHERIT_ONLY_ACE)
                ids = s_aInheritOnlyTypes[AceFlags & ACE_INHERIT_ALL];
            else
                ids = s_aInheritTypes[AceFlags & ACE_INHERIT_ALL];
        }

        // Fill in m_siInheritUnknown with the pertinent info
        m_siInheritUnknown.pguid   = &m_guidInheritType;
        m_siInheritUnknown.dwFlags = AceFlags & (INHERIT_ONLY_ACE | ACE_INHERIT_ALL);
        m_siInheritUnknown.pszName = MAKEINTRESOURCE(ids);

        // Insert and select it
        UINT iIndex = _AddInheritType(hInheritType,
                                      &m_siInheritUnknown,
                                      ::hModule);
        SendMessage(hInheritType, CB_SETCURSEL, iIndex, 0);

        if (FAILED(hr))
        {
            // GetInheritTypes failed, which means the only entry is the
            // default one we just added.  Disable the combo.
            EnableWindow(hInheritType, FALSE);
        }
    }


    //
    // Select the options which match the incoming ace
    //

    if (!(AceFlags & (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE)))
    {
        SendMessage(hInheritImmed, BM_SETCHECK, BST_UNCHECKED, 0);
        EnableWindow(hInheritImmed, FALSE);
        m_fInheritImmediateEnabled = FALSE;
        m_fPreviousImmediateSetting = BST_UNCHECKED;
    }
    else
    {
        SendMessage(hInheritImmed,
                    BM_SETCHECK,
                    (AceFlags & NO_PROPAGATE_INHERIT_ACE) ? BST_CHECKED : BST_UNCHECKED,
                    0);
        m_fInheritImmediateEnabled = TRUE;
    }

    if (!(m_siObjectInfo.dwFlags & SI_CONTAINER) || m_fReadOnly || (AceFlags & INHERITED_ACE))
    {
        // Disable all inheritance
        EnableWindow(hInheritType, FALSE);
        EnableWindow(hInheritImmed, FALSE);
    }

    if (m_fReadOnly || (AceFlags & INHERITED_ACE))
    {
        // Disable the "change name" and "clear all" buttons
        EnableWindow(GetDlgItem(hDlg, IDC_ACEE_NAMEBUTTON), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_ACEE_CLEAR), FALSE);
    }

	PropSheet_QuerySiblings(GetParent(hDlg),0,(LPARAM)this);

    LocalFreeString(&pszNameT);
    SetCursor(hcur);

    TraceLeaveVoid();
}

BOOL
CACEPage::OnChangeName(HWND hDlg)
{
    PUSER_LIST pUserList = NULL;
    BOOL bResult = FALSE;

    TraceEnter(TRACE_ACEEDIT, "CACEPage::OnChangeName");

    if (S_OK == GetUserGroup(hDlg, FALSE, &pUserList))
    {
        TraceAssert(NULL != pUserList);
        TraceAssert(1 == pUserList->cUsers);

        // Free up previous sid
        if (m_pSid)
            LocalFree(m_pSid);

        // Copy the new sid
        m_pSid = LocalAllocSid(pUserList->rgUsers[0].pSid);
        if (m_pSid)
        {
            SetDlgItemText(hDlg, IDC_ACEE_NAME, pUserList->rgUsers[0].pszName);
            bResult = TRUE;
        }
        LocalFree(pUserList);
    }

    TraceLeaveValue(bResult);
}

BOOL
CACEPage::OnClearAll(HWND hDlg)
{
    HWND hwndList;
    ULONG cPermissions;

    TraceEnter(TRACE_ACEEDIT, "CACEPage::OnClearAll");
    TraceAssert(!m_fReadOnly);

    hwndList = GetDlgItem(hDlg, IDC_ACEE_LIST);
    cPermissions = (ULONG)SendMessage(hwndList, CLM_GETITEMCOUNT, 0, 0);

    while (cPermissions != 0)
    {
        WORD wCol = COLUMN_ALLOW;

        cPermissions--;

        while (wCol == COLUMN_ALLOW || wCol == COLUMN_DENY)
        {
            WPARAM wItem = MAKELONG((WORD)cPermissions, wCol);

            if (!(CLST_DISABLED & SendMessage(hwndList, CLM_GETSTATE, wItem, 0)))
                SendMessage(hwndList, CLM_SETSTATE, wItem, CLST_UNCHECKED);

            wCol++;
        }
    }

    TraceLeaveValue(TRUE);
}

void
CACEPage::HandleSelChange(HWND hDlg, HWND hWnd) // inherit type change
{
    PSI_INHERIT_TYPE psiInheritType;
    BOOL fEnableInheritImmediate = FALSE;
    const GUID *pguidInheritType = &GUID_NULL;

    TraceEnter(TRACE_ACEEDIT, "CACEPage::HandleSelChange");

    psiInheritType = (PSI_INHERIT_TYPE)SendMessage(hWnd,
                                                   CB_GETITEMDATA,
                                                   SendMessage(hWnd, CB_GETCURSEL, 0, 0),
                                                   0);

    if (psiInheritType != (PSI_INHERIT_TYPE)CB_ERR && psiInheritType != NULL)
    {
        if (psiInheritType->dwFlags & (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE))
            fEnableInheritImmediate = TRUE;
        if( psiInheritType->pguid )
            pguidInheritType = psiInheritType->pguid;
    }

    if (fEnableInheritImmediate != m_fInheritImmediateEnabled)
    {
        HWND hInheritImmediate = GetDlgItem(hDlg, IDC_ACEE_INHERITIMMEDIATE);

        if (fEnableInheritImmediate)
        {
            SendMessage(hInheritImmediate, BM_SETCHECK, m_fPreviousImmediateSetting, 0);
        }
        else
        {
            m_fPreviousImmediateSetting = (BOOL)SendMessage(hInheritImmediate,
                                                            BM_GETCHECK,
                                                            0,
                                                            0);
            SendMessage(hInheritImmediate, BM_SETCHECK, BST_UNCHECKED, 0);
        }

        EnableWindow(hInheritImmediate, fEnableInheritImmediate);
        m_fInheritImmediateEnabled = fEnableInheritImmediate;
    }

    // If the inherit type GUID has changed, reinitialize the checklist.
    if (!IsSameGUID(pguidInheritType, &m_guidInheritType))
    {
        HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
        HDPA hNewEntries = DPA_Create(4);

        if (hNewEntries)
        {
            GetAcesFromCheckList(GetDlgItem(hDlg, IDC_ACEE_LIST),
                                 m_pSid,
                                 m_siPageType == SI_PAGE_ADVPERM,
                                 TRUE,
                                 0,         // don't care about flags
                                 NULL,      // or inherit type here
                                 hNewEntries);

            // Save new inherit type and reset the checklist
            m_guidInheritType = *pguidInheritType; 
            ReInitCheckList(hDlg, hNewEntries);
            DestroyDPA(hNewEntries);
        }

        SetCursor(hcur);
    }

    TraceLeaveVoid();
}

void
HandleListClick(PNM_CHECKLIST pnmc, 
                SI_PAGE_TYPE siType, 
                BOOL bInheritFlags, 
                HDSA *phAllowUncheckedAccess, 
                HDSA *phDenyUncheckedAccess, 
                BOOL bCustomPresent)
{
    HWND            hChkList;
    UINT            iRow;
    WORD            wCol;
    PSI_ACCESS      pAccess;
    DWORD           dwState;
    BOOL            bNullGuid;
    UINT            iRowCompare;
    PSI_ACCESS      pAccessCompare;

    TraceEnter(TRACE_MISC, "HandleListClick");
    TraceAssert(pnmc != NULL);

    hChkList = pnmc->hdr.hwndFrom;
    iRow    = pnmc->iItem;
    wCol    = (WORD)pnmc->iSubItem;       // 1 = Allow, 2 = Deny
    pAccess = (PSI_ACCESS)pnmc->dwItemData;
    dwState = pnmc->dwState;

    if (pAccess == NULL)
        TraceLeaveVoid();

    if( phAllowUncheckedAccess )
    {
        *phAllowUncheckedAccess = DSA_Create(SIZEOF(PSI_ACCESS), 4);
        if (*phAllowUncheckedAccess == NULL)
        {
            TraceMsg("DSA_Create failed");
            TraceLeaveVoid();
        }
    }
    if( phDenyUncheckedAccess )
    {
        *phDenyUncheckedAccess = DSA_Create(SIZEOF(PSI_ACCESS), 4);
        if (*phDenyUncheckedAccess == NULL)
        {
            TraceMsg("DSA_Create failed");
            TraceLeaveVoid();
        }
    }


    bNullGuid = IsNullGUID(pAccess->pguid);

    iRowCompare = (UINT)SendMessage(hChkList, CLM_GETITEMCOUNT, 0, 0);

    //Custom checkbox is handled Separately
    if( bCustomPresent )
        --iRowCompare;

    while (iRowCompare != 0)
    {
        WPARAM wItem;
        DWORD  dwStateCompareOriginal;
        DWORD  dwStateCompare;
        WORD   wColCompare;
        BOOL   bSameGuid;
        BOOL   bNullGuidCompare;

        --iRowCompare;
        pAccessCompare = (PSI_ACCESS)SendMessage(hChkList, CLM_GETITEMDATA, iRowCompare, 0);

        if (!pAccessCompare)
            continue;

        bSameGuid = IsSameGUID(pAccessCompare->pguid, pAccess->pguid);
        bNullGuidCompare = IsNullGUID(pAccessCompare->pguid);

        // If the GUIDs are incompatible, then we can't do anything
        if (!(bSameGuid || bNullGuid || bNullGuidCompare))
            continue;

        //
        // Yukky, complicated mechanism to determine whether to
        // turn on or off the allow or deny check marks.
        //
        // REVIEW: This algorithm of changing check marks based on other
        // checkmarks handles a lot of cases, but it doesn't handle a
        // two good ones.
        //
        // (1) If you have a right which implies other rights and you turn,
        // it off, then maybe we should turn off all of the implied ones
        // too. For example, you turn off change (which is the combination
        // of read and write) maybe we should turn off both read and write.
        //
        // (2) If you turn on all of the component rights of one which
        // implies them all, then we should turn on that one (because
        // it implies them all).
        //
#ifdef NO_RADIOBUTTON_BEHAVIOR
        wColCompare = wCol;
#else
        for (wColCompare = COLUMN_ALLOW; wColCompare <= COLUMN_DENY; wColCompare++)
#endif
        {
            wItem = MAKELONG((WORD)iRowCompare, wColCompare);
            dwStateCompareOriginal = (DWORD)SendMessage(hChkList, CLM_GETSTATE, wItem, 0);

            //
            // If the other box is disabled, then it represents an
            // inherited right so don't do anything with it.
            //
            // nb: Depending on NO_RADIOBUTTON_BEHAVIOR, this may continue to the
            // for(wColCompare) loop or the while(iRowCompare) loop as appropriate
            //
            if (dwStateCompareOriginal & CLST_DISABLED)
                continue;

            dwStateCompare = dwStateCompareOriginal;

            if (dwState & CLST_CHECKED)
            {
                if (wCol == wColCompare)
                {
                    //
                    // If this right implies some other right,
                    // then turn it on too.
                    //
                    if ((bSameGuid || bNullGuid) && AllFlagsOn(pAccess->mask, pAccessCompare->mask))
                    {
                        if (!bInheritFlags ||
                            AllFlagsOn(pAccess->dwFlags & ACE_INHERIT_ALL, pAccessCompare->dwFlags & ACE_INHERIT_ALL))
                        {
                            dwStateCompare |= CLST_CHECKED;
                        }
                    }
                }
                else
                {
#ifndef NO_RADIOBUTTON_BEHAVIOR
                    //
                    // If this right implies or is implied by some other
                    // right in the other column, then turn it off.
                    //
                    if ( (siType == SI_PAGE_PERM || siType == SI_PAGE_ADVPERM) &&
                         (((bSameGuid || bNullGuid) && AllFlagsOn(pAccess->mask, pAccessCompare->mask)) ||
                          ((bSameGuid || bNullGuidCompare) && AllFlagsOn(pAccessCompare->mask, pAccess->mask))) )
                    {
                        if (!bInheritFlags ||
                            (AllFlagsOn(pAccessCompare->dwFlags & ACE_INHERIT_ALL, pAccess->dwFlags & ACE_INHERIT_ALL) ||
                             AllFlagsOn(pAccess->dwFlags & ACE_INHERIT_ALL, pAccessCompare->dwFlags & ACE_INHERIT_ALL)) )
                        {
                            dwStateCompare &= ~(CLST_CHECKED);
                        }
                    }
#endif
                }
            }
            else
            {
                if (wCol == wColCompare)
                {
                    //
                    // If this right is implied by some other right, then
                    // turn it off too.
                    //
                    if ((bSameGuid || bNullGuidCompare) && AllFlagsOn(pAccessCompare->mask, pAccess->mask))
                    {
                        if (!bInheritFlags ||
                            AllFlagsOn(pAccessCompare->dwFlags & ACE_INHERIT_ALL, pAccess->dwFlags & ACE_INHERIT_ALL))
                        {
                            dwStateCompare &= ~(CLST_CHECKED);
                        }
                    }
                }
            }

            if (dwStateCompareOriginal != dwStateCompare)
            {
                SendMessage(hChkList, CLM_SETSTATE, wItem, (LPARAM)dwStateCompare);
                //If a checkbox was intially checked and and now unchecked, add to 
                //h[Allow|Deny]UncheckedAccess.
                if( dwStateCompareOriginal & CLST_CHECKED && !(dwStateCompare & CLST_CHECKED) )
                {
                    if( phDenyUncheckedAccess && ( wColCompare == COLUMN_DENY ) )
                        DSA_AppendItem(*phDenyUncheckedAccess, &pAccessCompare);
                    if( phAllowUncheckedAccess && ( wColCompare == COLUMN_ALLOW ) )
                        DSA_AppendItem(*phAllowUncheckedAccess, &pAccessCompare);
                }

            }
        }
    }

    TraceLeaveVoid();
}


UINT
GetAcesFromCheckList(HWND hChkList,
                     PSID pSid,                 // All aces get this SID
                     BOOL fPerm,                // Create ACCESS or AUDIT aces?
                     BOOL fAceFlagsProvided,    // Use uAceFlagsAll instead of pAccess->dwFlags
                     UCHAR uAceFlagsAll,        // All aces get these flags
                     const GUID *pInheritGUID,  // All aces get this inherit GUID
                     HDPA hEntries)             // Store new aces here
{
    UINT cCheckRows;
    UINT iCheckRow;
    UINT cbSidSize;
    UINT iCount;
    BOOL bInheritTypePresent = FALSE;

    TraceEnter(TRACE_MISC, "GetAcesFromCheckList");
    TraceAssert(hChkList != NULL);
    TraceAssert(pSid != NULL);
    TraceAssert(hEntries != NULL);

    cbSidSize = GetLengthSid(pSid);

    if (pInheritGUID == NULL)
        pInheritGUID = &GUID_NULL;
    else if (!IsNullGUID(pInheritGUID))
        bInheritTypePresent = TRUE;

    //
    // First clear out the old HDPA
    //
    iCount = DPA_GetPtrCount(hEntries);
    while (iCount != 0)
    {
        --iCount;
        LocalFree(DPA_FastGetPtr(hEntries, iCount));
        DPA_DeletePtr(hEntries, iCount);
    }

    cCheckRows = (UINT)SendMessage(hChkList, CLM_GETITEMCOUNT, 0, 0);
    for (iCheckRow = 0; iCheckRow < cCheckRows; iCheckRow++)
    {
        PSI_ACCESS pAccess;
        DWORD dwObjectFlagsNew;
        WORD wCol;
        UCHAR uAceFlagsNew;

        pAccess = (PSI_ACCESS)SendMessage(hChkList, CLM_GETITEMDATA, iCheckRow, 0);

        uAceFlagsNew = (UCHAR)(fAceFlagsProvided ? uAceFlagsAll : pAccess->dwFlags);

        dwObjectFlagsNew = 0;
        if (!IsNullGUID(pAccess->pguid))
            dwObjectFlagsNew |= ACE_OBJECT_TYPE_PRESENT;

        if (bInheritTypePresent)
            dwObjectFlagsNew |= ACE_INHERITED_OBJECT_TYPE_PRESENT;

        wCol = COLUMN_ALLOW;
        while (wCol == COLUMN_ALLOW || wCol == COLUMN_DENY)
        {
            WPARAM        wItem;
            DWORD         dwState;

            wItem = MAKELONG((WORD)iCheckRow, wCol);
            dwState = (DWORD)SendMessage(hChkList, CLM_GETSTATE, wItem, 0);

            if ((dwState & CLST_CHECKED) && !(dwState & CLST_DISABLED))
            {
                //
                // Ok, time to make an ACE for this check mark, see if we
                // can merge it into an already existing ACE, or whether we
                // we need to create a new entry
                //
                UCHAR uAceTypeNew;
                DWORD dwMaskNew = pAccess->mask;
                UINT cbSize = SIZEOF(KNOWN_ACE);

                if (fPerm)
                {
                    if (wCol == COLUMN_ALLOW)
                        uAceTypeNew = ACCESS_ALLOWED_ACE_TYPE;
                    else
                        uAceTypeNew = ACCESS_DENIED_ACE_TYPE;
                }
                else
                {
                    uAceTypeNew = SYSTEM_AUDIT_ACE_TYPE;
                    uAceFlagsNew &= ~(SUCCESSFUL_ACCESS_ACE_FLAG | FAILED_ACCESS_ACE_FLAG);

                    if (wCol == COLUMN_ALLOW)
                        uAceFlagsNew |= SUCCESSFUL_ACCESS_ACE_FLAG;
                    else
                        uAceFlagsNew |= FAILED_ACCESS_ACE_FLAG;
                }

                if (dwObjectFlagsNew != 0)
                {
                    uAceTypeNew += (ACCESS_ALLOWED_OBJECT_ACE_TYPE - ACCESS_ALLOWED_ACE_TYPE);
                    cbSize = SIZEOF(KNOWN_OBJECT_ACE);

                    if (dwObjectFlagsNew & ACE_OBJECT_TYPE_PRESENT)
                        cbSize += SIZEOF(GUID);

                    if (dwObjectFlagsNew & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                        cbSize += SIZEOF(GUID);
                }

                cbSize += cbSidSize - SIZEOF(ULONG);

                //
                // See if it exists
                //
                iCount = DPA_GetPtrCount(hEntries);
                while(iCount != 0)
                {
                    PACE_HEADER pAce;
                    BOOL bObjectTypePresent = FALSE;
                    const GUID *pObjectType = NULL;

                    --iCount;
                    pAce = (PACE_HEADER)DPA_FastGetPtr(hEntries, iCount);

                    if (IsObjectAceType(pAce))
                        pObjectType = RtlObjectAceObjectType(pAce);

                    if (!pObjectType)
                        pObjectType = &GUID_NULL;
                    else
                        bObjectTypePresent = TRUE;

                    //
                    // Test the new ACE against each existing ACE to see if
                    // we can combine them.
                    //
                    if (IsEqualACEType(pAce->AceType, uAceTypeNew))
                    {
                        DWORD dwMergeFlags = 0;
                        DWORD dwMergeStatus;
                        DWORD dwMergeResult;

                        if (dwObjectFlagsNew & ACE_OBJECT_TYPE_PRESENT)
                            dwMergeFlags |= MF_OBJECT_TYPE_1_PRESENT;

                        if (bObjectTypePresent)
                            dwMergeFlags |= MF_OBJECT_TYPE_2_PRESENT;

                        if (!(dwMergeFlags & (MF_OBJECT_TYPE_1_PRESENT | MF_OBJECT_TYPE_2_PRESENT)))
                        {
                            // Neither are present, so they are the same
                            dwMergeFlags |= MF_OBJECT_TYPE_EQUAL;
                        }
                        else if (IsSameGUID(pAccess->pguid, pObjectType))
                            dwMergeFlags |= MF_OBJECT_TYPE_EQUAL;

                        if (!fPerm)
                            dwMergeFlags |= MF_AUDIT_ACE_TYPE;

                        dwMergeStatus = MergeAceHelper(uAceFlagsNew,
                                                       dwMaskNew,
                                                       pAce->AceFlags,
                                                       ((PKNOWN_ACE)pAce)->Mask,
                                                       dwMergeFlags,
                                                       &dwMergeResult);

                        if (dwMergeStatus == MERGE_MODIFIED_FLAGS)
                        {
                            uAceFlagsNew = (UCHAR)dwMergeResult;
                            dwMergeStatus = MERGE_OK_1;
                        }
                        else if (dwMergeStatus == MERGE_MODIFIED_MASK)
                        {
                            dwMaskNew = dwMergeResult;
                            dwMergeStatus = MERGE_OK_1;
                        }

                        if (dwMergeStatus == MERGE_OK_1)
                        {
                            //
                            // The new ACE implies the existing ACE, so
                            // the existing one can be removed.
                            //
                            LocalFree(pAce);
                            DPA_DeletePtr(hEntries, iCount);
                            //
                            // Keep looking.  Maybe we can remove some more entries
                            // before adding the new one.
                            //
                        }
                        else if (dwMergeStatus == MERGE_OK_2)
                        {
                            iCount = 1;     // non-zero for match found
                            break;
                        }
                    }
                }

                //
                // Otherwise, add it
                //
                if (iCount == 0)
                {
                    PACE_HEADER pAce = (PACE_HEADER)LocalAlloc(LPTR, cbSize);

                    if (pAce)
                    {
                        PSID pSidT;

                        pAce->AceType  = uAceTypeNew;
                        pAce->AceFlags = uAceFlagsNew;
                        pAce->AceSize  = (USHORT)cbSize;
                        ((PKNOWN_ACE)pAce)->Mask = dwMaskNew;
                        pSidT = &((PKNOWN_ACE)pAce)->SidStart;

                        if (dwObjectFlagsNew != 0)
                        {
                            GUID *pGuid;

                            ((PKNOWN_OBJECT_ACE)pAce)->Flags = dwObjectFlagsNew;

                            pGuid = RtlObjectAceObjectType(pAce);
                            if (pGuid)
                            {
                                if (pAccess->pguid)
                                    *pGuid = *pAccess->pguid;
                                else
                                    *pGuid = GUID_NULL;
                            }

                            pGuid = RtlObjectAceInheritedObjectType(pAce);
                            if (pGuid)
                                *pGuid = *pInheritGUID;

                            pSidT = RtlObjectAceSid(pAce);
                        }

                        CopyMemory(pSidT, pSid, cbSidSize);
                        DPA_AppendPtr(hEntries, pAce);
                    }
                }
            }

            wCol++;
        }
    }

    iCount = DPA_GetPtrCount(hEntries);
    TraceLeaveValue(iCount);
}

LONG
CACEPage::OnApply(HWND hDlg, BOOL /*bClose*/)
{
    const GUID *pInheritGUID;
    UCHAR uAceFlagsNew = 0;
    HDPA hEntries;
	BOOL bAclBloated = FALSE;
	//
	//If this page is property page and user has not clicked on
	//the object page, aclbloat must be checked from this page
	//only.
	//
	if((m_siFlags == SI_ACCESS_PROPERTY) && !m_pOtherPage)
		bAclBloated = IsAclBloated(hDlg);

	if(m_siFlags != SI_ACCESS_PROPERTY)
		bAclBloated = IsAclBloated(hDlg);
	
	if(bAclBloated)
		return PSNRET_INVALID_NOCHANGEPAGE;
    
	if (!m_fPageDirty)
        return PSNRET_NOERROR;

    TraceEnter(TRACE_ACEEDIT, "CACEPage::Apply");


	
    //
    // Determine inheritance for containers
    //
    pInheritGUID = &GUID_NULL;
    if ((m_siObjectInfo.dwFlags & SI_CONTAINER) != 0)
    {
        PSI_INHERIT_TYPE psiInheritType = NULL;
        HWND hInheritType = GetDlgItem( hDlg, IDC_ACEE_INHERITTYPE);

        int iSel = (int)SendMessage(hInheritType, CB_GETCURSEL, 0,0);

        if (iSel != CB_ERR)
        {
            psiInheritType = (PSI_INHERIT_TYPE)SendMessage(hInheritType,
                                                           CB_GETITEMDATA,
                                                           iSel,
                                                           0);
        }

        if (psiInheritType != (PSI_INHERIT_TYPE)CB_ERR && psiInheritType != NULL)
        {
            pInheritGUID = psiInheritType->pguid;
            uAceFlagsNew = (UCHAR)(psiInheritType->dwFlags & VALID_INHERIT_FLAGS);
        }
        else if (m_pAce)
        {
            uAceFlagsNew = m_pAce->AceFlags;
        }

        if (m_fInheritImmediateEnabled)
        {
            if (IsDlgButtonChecked(hDlg, IDC_ACEE_INHERITIMMEDIATE) == BST_CHECKED)
                uAceFlagsNew |= NO_PROPAGATE_INHERIT_ACE;
            else
                uAceFlagsNew &= ~NO_PROPAGATE_INHERIT_ACE;
        }
    }

    if (m_phEntries != NULL)
    {
        if (*m_phEntries == NULL)
            *m_phEntries = DPA_Create(4);

        GetAcesFromCheckList(GetDlgItem(hDlg, IDC_ACEE_LIST),
                             m_pSid,
                             m_siPageType == SI_PAGE_ADVPERM,
                             TRUE,
                             uAceFlagsNew,
                             pInheritGUID,
                             *m_phEntries);
    }

    if (m_pdwResult)
        *m_pdwResult |= (m_siFlags == SI_ACCESS_PROPERTY ? EAE_NEW_PROPERTY_ACE : EAE_NEW_OBJECT_ACE);
    m_fPageDirty = FALSE;

    TraceLeaveValue(PSNRET_NOERROR);
}

BOOL
CACEPage::IsAclBloated(HWND hDlg)
{
    TraceEnter(TRACE_MISC, "CACEPage::ShowAclBloat");
    
	HDPA hEntries = NULL;
	HDPA hPropEntries = NULL;
	
	BOOL bReturn = FALSE;

	hEntries = GetAceList(hDlg);

	if(m_pOtherPage)
	{
		hPropEntries = m_pOtherPage->GetAceList(m_pOtherPage->m_hwnd);
	}

	CACLBloat bloat(m_psi,
					m_psi2,
					m_siPageType,
					&m_siObjectInfo,
					hEntries,
					hPropEntries);	
	if(bloat.IsAclBloated())
		bReturn = bloat.DoModalDialog(hDlg);

	if(hEntries)
		DestroyDPA(hEntries);

	if(hPropEntries)
		DestroyDPA(hPropEntries);

	return bReturn;
}


HDPA
CACEPage::GetAceList(HWND hDlg)
{
	TraceEnter(TRACE_ACEEDIT, "CACEPage::GetAceList");
    
	if (!m_fPageDirty)
		return NULL;
    //
    // Determine inheritance for containers
    //
    const GUID *pInheritGUID = &GUID_NULL;
	UCHAR uAceFlagsNew = 0;
	HDPA hEntries = NULL;

    if ((m_siObjectInfo.dwFlags & SI_CONTAINER) != 0)
    {
        PSI_INHERIT_TYPE psiInheritType = NULL;
        HWND hInheritType = GetDlgItem( hDlg, IDC_ACEE_INHERITTYPE);

        int iSel = (int)SendMessage(hInheritType, CB_GETCURSEL, 0,0);

        if (iSel != CB_ERR)
        {
            psiInheritType = (PSI_INHERIT_TYPE)SendMessage(hInheritType,
                                                           CB_GETITEMDATA,
                                                           iSel,
                                                           0);
        }

        if (psiInheritType != (PSI_INHERIT_TYPE)CB_ERR && psiInheritType != NULL)
        {
            pInheritGUID = psiInheritType->pguid;
            uAceFlagsNew = (UCHAR)(psiInheritType->dwFlags & VALID_INHERIT_FLAGS);
        }
        else if (m_pAce)
        {
            uAceFlagsNew = m_pAce->AceFlags;
        }

        if (m_fInheritImmediateEnabled)
        {
            if (IsDlgButtonChecked(hDlg, IDC_ACEE_INHERITIMMEDIATE) == BST_CHECKED)
                uAceFlagsNew |= NO_PROPAGATE_INHERIT_ACE;
            else
                uAceFlagsNew &= ~NO_PROPAGATE_INHERIT_ACE;
        }
    }

	hEntries = DPA_Create(4);

	if(hEntries)
	{
		GetAcesFromCheckList(GetDlgItem(hDlg, IDC_ACEE_LIST),
							 m_pSid,
							 m_siPageType == SI_PAGE_ADVPERM,
							 TRUE,
							 uAceFlagsNew,
							 pInheritGUID,
							 hEntries);
	}
	return hEntries;
}



BOOL
CACEPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        InitDlg(hDlg);
        break;

    case WM_DESTROY:
        EmptyCheckList(GetDlgItem(hDlg, IDC_ACEE_LIST));
        break;

    case PWM_SELECT_PAGE:
        PropSheet_SetCurSel(GetParent(hDlg), lParam, wParam);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_ACEE_NAMEBUTTON:
            if (OnChangeName(hDlg))
            {
                PropSheet_Changed(GetParent(hDlg), hDlg);
                m_fPageDirty = TRUE;
            }
            break;

        case IDC_ACEE_INHERITTYPE:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE)
            {
                HandleSelChange(hDlg, (HWND)lParam);
                PropSheet_Changed(GetParent(hDlg), hDlg);
                m_fPageDirty = TRUE;
            }
            break;

        case IDC_ACEE_INHERITIMMEDIATE:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
            {
                PropSheet_Changed(GetParent(hDlg), hDlg);
                m_fPageDirty = TRUE;
            }
            break;

        case IDC_ACEE_CLEAR:
            if (OnClearAll(hDlg))
            {
                PropSheet_Changed(GetParent(hDlg), hDlg);
                m_fPageDirty = TRUE;
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code)
        {
        case CLN_CLICK:
            if (lParam)
            {
                HandleListClick((PNM_CHECKLIST)lParam, m_siPageType, FALSE);
                PropSheet_Changed(GetParent(hDlg), hDlg);
                m_fPageDirty = TRUE;
            }
            break;

        case CLN_GETCOLUMNDESC:
            {
                PNM_CHECKLIST pnmc = (PNM_CHECKLIST)lParam;
                GetDlgItemText(hDlg,
                               IDC_ACEE_ALLOW - 1 + pnmc->iSubItem,
                               pnmc->pszText,
                               pnmc->cchTextMax);
            }
            break;

        case PSN_APPLY:
            SetWindowLongPtr(hDlg,
                             DWLP_MSGRESULT,
                             OnApply(hDlg, (BOOL)(((LPPSHNOTIFY)lParam)->lParam)));
            break;


        }
        break;

	case PSM_QUERYSIBLINGS: 
		{
			BOOL bSendQuery = !m_pOtherPage;
			if(this != (CACEPage*)lParam)
				m_pOtherPage = (CACEPage*)lParam;

			if(bSendQuery)
				PostMessage(GetParent(hDlg),PSM_QUERYSIBLINGS,0,(LPARAM)this);
		}

		break;


    case WM_HELP:
        if (IsWindowEnabled(hDlg))
        {
            const DWORD *pdwHelpIDs = aAcePermHelpIDs;

            if (m_siPageType == SI_PAGE_AUDIT)
                pdwHelpIDs = aAceAuditHelpIDs;

            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_szAcluiHelpFile,
                    HELP_WM_HELP,
                    (DWORD_PTR)pdwHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hDlg))
        {
            HWND hwnd = (HWND)wParam;
            const DWORD *pdwHelpIDs = aAcePermHelpIDs;

            if (m_siPageType == SI_PAGE_AUDIT)
                pdwHelpIDs = aAceAuditHelpIDs;

            //
            // Some of the checkboxes may be scrolled out of view, but
            // they are still detected by WinHelp, so we jump through
            // a few extra hoops here.
            //
            if (hwnd == hDlg)
            {
                POINT pt;
                pt.x = GET_X_LPARAM(lParam);
                pt.y = GET_Y_LPARAM(lParam);

                ScreenToClient(hDlg, &pt);
                hwnd = ChildWindowFromPoint(hDlg, pt);
                if (hDlg == hwnd)
                    break;
            }

            //
            // WinHelp looks for child windows, but we don't have help id's
            // for the permission checkboxes.  If the request is for the
            // checklist window, fake out WinHelp by referring to one of
            // the static labels just above the list.
            //
            if (GetDlgCtrlID(hwnd) == IDC_ACEE_LIST)
                hwnd = GetWindow((HWND)wParam, GW_HWNDPREV);    // Static label "Deny"

            WinHelp(hwnd,
                    c_szAcluiHelpFile,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)pdwHelpIDs);
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

HPROPSHEETPAGE
CreateACEPage(LPSECURITYINFO psi,
              SI_PAGE_TYPE siType,
              PACE pAce,
              BOOL bReadOnly,
              DWORD dwFlags,
              DWORD *pdwResult,
              HDPA *phEntries)
{
    HPROPSHEETPAGE hPage = NULL;
    LPCTSTR pszTitle = NULL;
    LPACEPAGE pPage;

    TraceEnter(TRACE_ACEEDIT, "CreateACEPage");
    TraceAssert(psi != NULL);
    TraceAssert(phEntries != NULL);

    pPage = new CACEPage(psi,
                         siType,
                         pAce,
                         bReadOnly,
                         dwFlags,
                         pdwResult,
                         phEntries);
    if (pPage)
    {
        int iDlgTemplate = IDD_ACEENTRY_PERM_PAGE;

        if (siType == SI_PAGE_AUDIT)
            iDlgTemplate = IDD_ACEENTRY_AUDIT_PAGE;

        if (dwFlags == SI_ACCESS_PROPERTY)
            pszTitle = MAKEINTRESOURCE(IDS_ACEE_PROPERTY_TITLE);

        hPage = pPage->CreatePropSheetPage(MAKEINTRESOURCE(iDlgTemplate), pszTitle);
    }

    TraceLeaveValue(hPage);
}

BOOL
EditACEEntry(HWND hwndOwner,
             LPSECURITYINFO psi,
             PACE pAce,
             SI_PAGE_TYPE siType,
             LPCTSTR pszObjectName,
             BOOL bReadOnly,
             DWORD *pdwResult,
             HDPA *phEntries,
             HDPA *phPropertyEntries,
             UINT nStartPage)
{
    HPROPSHEETPAGE hPage[2];
    UINT cPages = 0;
    BOOL bResult = FALSE;

    TraceEnter(TRACE_ACEEDIT, "EditACEEntry");
    TraceAssert(psi != NULL);

    if (phEntries)
    {
        hPage[cPages] = CreateACEPage(psi,
                                      siType,
                                      pAce,
                                      bReadOnly,
                                      SI_ACCESS_SPECIFIC,
                                      pdwResult,
                                      phEntries);
        if (hPage[cPages])
            cPages++;
    }

    if (phPropertyEntries)
    {
        hPage[cPages] = CreateACEPage(psi,
                                      siType,
                                      pAce,
                                      bReadOnly,
                                      SI_ACCESS_PROPERTY,
                                      pdwResult,
                                      phPropertyEntries);
        if (hPage[cPages])
            cPages++;
    }

    if (cPages)
    {
        // Build dialog title string
        LPTSTR pszCaption = NULL;
        FormatStringID(&pszCaption,
                       ::hModule,
                       siType == SI_PAGE_AUDIT ? IDS_ACEE_AUDIT_TITLE : IDS_ACEE_PERM_TITLE,
                       pszObjectName);

        PROPSHEETHEADER psh;
        psh.dwSize = SIZEOF(psh);
        psh.dwFlags = PSH_DEFAULT | PSH_NOAPPLYNOW;
        psh.hwndParent = hwndOwner;
        psh.hInstance = ::hModule;
        psh.pszCaption = pszCaption;
        psh.nPages = cPages;
        psh.nStartPage = 0;
        psh.phpage = &hPage[0];

        if (nStartPage < cPages)
            psh.nStartPage = nStartPage;

        bResult = (PropertySheet(&psh) == IDOK);

        LocalFreeString(&pszCaption);
    }

    TraceLeaveValue(bResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\ace.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ace.cpp
//
//  This file contains the implementation of the CAce class
//
//--------------------------------------------------------------------------

#include "aclpriv.h"
#include "sddl.h"       // ConvertSidToStringSid


CAce::CAce(PACE_HEADER pAce):pszInheritSourceName(NULL),
                             iInheritSourceLevel(0)
{
    ULONG nSidLength = 0;
    ULONG nAceLength = SIZEOF(KNOWN_ACE) - SIZEOF(ULONG);

    ZeroMemory(this, SIZEOF(CAce));
    sidType = SidTypeInvalid;

	InheritedObjectType = GUID_NULL;

    if (pAce != NULL)
    {
        PSID psidT;

        // Copy the header and mask
        *(PACE_HEADER)this = *pAce;
        Mask = ((PKNOWN_ACE)pAce)->Mask;

        // Is this an object ACE?
        if (IsObjectAceType(pAce))
        {
            GUID *pGuid;

            nAceLength = SIZEOF(KNOWN_OBJECT_ACE) - SIZEOF(ULONG);

            // Copy the object type guid if present
            pGuid = RtlObjectAceObjectType(pAce);
            if (pGuid)
            {
                Flags |= ACE_OBJECT_TYPE_PRESENT;
                ObjectType = *pGuid;
                nAceLength += SIZEOF(GUID);
            }

            //
            //ACE_INHERITED_OBJECT_TYPE_PRESENT is invalid without
            //either of container inherit or object inherit flags.
            //NTRAID#NTBUG9-287737-2001/01/23-hiteshr
            //
            if (pAce->AceFlags & ACE_INHERIT_ALL)
            {

                //Copy the inherit type guid if present
                pGuid = RtlObjectAceInheritedObjectType(pAce);
                if (pGuid)
                {
                    Flags |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
                    InheritedObjectType = *pGuid;
                    nAceLength += SIZEOF(GUID);
                }
            }
        }

        // Copy the SID
        psidT = GetAceSid(pAce);
        nSidLength = GetLengthSid(psidT);

        psid = (PSID)LocalAlloc(LPTR, nSidLength);
        if (psid)
            CopyMemory(psid, psidT, nSidLength);
    }

    AceSize = (USHORT)(nAceLength + nSidLength);
}


CAce::~CAce()
{
    if (psid != NULL)
        LocalFree(psid);
    LocalFreeString(&pszName);
    LocalFreeString(&pszType);
    LocalFreeString(&pszAccessType);
    LocalFreeString(&pszInheritType);
    LocalFreeString(&pszInheritSourceName);
}

void 
CAce::SetInheritSourceInfo(LPCTSTR psz, INT level)
{
#define MAX_BUFFER 1000 
    iInheritSourceLevel = level;
    if(psz != NULL)
    {
        SetString(&pszInheritSourceName,psz); 
    }
    else
    {
        WCHAR Buffer[MAX_BUFFER];
        if(IsInheritedAce())
        {
            LoadString(::hModule, IDS_FROM_PARENT, Buffer, ARRAYSIZE(Buffer));
            SetString(&pszInheritSourceName,Buffer); 
            iInheritSourceLevel = -1;
        }
        else
        {
            LoadString(::hModule, IDS_NOT_INHERITED, Buffer, ARRAYSIZE(Buffer));
            SetString(&pszInheritSourceName,Buffer); 
            iInheritSourceLevel = 0;
        }
    }
}

LPTSTR
CAce::LookupName(LPCTSTR pszServer, LPSECURITYINFO2 psi2)
{
    if (SidTypeInvalid == sidType)
    {
        PUSER_LIST pUserList = NULL;
        LPCTSTR pszN = NULL;
        LPCTSTR pszL = NULL;

        sidType = SidTypeUnknown;

        if (LookupSid(psid, pszServer, psi2, &pUserList))
        {
            sidType = pUserList->rgUsers[0].SidType;
            pszN = pUserList->rgUsers[0].pszName;
            pszL = pUserList->rgUsers[0].pszLogonName;
        }

        SetName(pszN, pszL);

        if (pUserList)
            LocalFree(pUserList);
    }

    return pszName;
}


void
CAce::SetName(LPCTSTR pszN, LPCTSTR pszL)
{
    LocalFreeString(&pszName);
    if (!BuildUserDisplayName(&pszName, pszN, pszL) && psid)
        ConvertSidToStringSid(psid, &pszName);
}


void
CAce::SetSid(PSID p, LPCTSTR pszName, LPCTSTR pszLogonName, SID_NAME_USE type)
{
    ULONG nSidLength = 0;
    ULONG nAceLength = SIZEOF(KNOWN_ACE) - SIZEOF(ULONG);

    if (psid != NULL)
    {
        LocalFree(psid);
        psid = NULL;
    }

    if (p != NULL)
    {
        nSidLength = GetLengthSid(p);

        psid = (PSID)LocalAlloc(LPTR, nSidLength);
        if (psid)
            CopyMemory(psid, p, nSidLength);
    }

    if (Flags != 0)
    {
        nAceLength = SIZEOF(KNOWN_OBJECT_ACE) - SIZEOF(ULONG);

        if (Flags & ACE_OBJECT_TYPE_PRESENT)
            nAceLength += SIZEOF(GUID);

        if (Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
            nAceLength += SIZEOF(GUID);
    }

    AceSize = (USHORT)(nAceLength + nSidLength);

    sidType = type;
    SetName(pszName, pszLogonName);
}


void
CAce::SetString(LPTSTR *ppszDest, LPCTSTR pszSrc)
{
    LocalFreeString(ppszDest);
    if (NULL != pszSrc)
        LocalAllocString(ppszDest, pszSrc);
}


PACE_HEADER
CAce::Copy() const
{
    PACE_HEADER pAceCopy = (PACE_HEADER)LocalAlloc(LPTR, AceSize);
    CopyTo(pAceCopy);
    return pAceCopy;
}


void
CAce::CopyTo(PACE_HEADER pAceDest) const
{
    if (pAceDest)
    {
        ULONG nAceLength = SIZEOF(KNOWN_ACE) - SIZEOF(ULONG);
        ULONG nSidLength;

        // Copy the header and mask
        *pAceDest = *(PACE_HEADER)this;
        ((PKNOWN_ACE)pAceDest)->Mask = Mask;

        // Is this an object ACE?
        if (IsObjectAceType(this))
        {
            GUID *pGuid;

            nAceLength = SIZEOF(KNOWN_OBJECT_ACE) - SIZEOF(ULONG);

            // Copy the object flags
            ((PKNOWN_OBJECT_ACE)pAceDest)->Flags = Flags;

            // Copy the object type guid if present
            pGuid = RtlObjectAceObjectType(pAceDest);
            if (pGuid)
            {
                *pGuid = ObjectType;
                nAceLength += SIZEOF(GUID);
            }

            // Copy the inherit type guid if present
            pGuid = RtlObjectAceInheritedObjectType(pAceDest);
            if (pGuid)
            {
                *pGuid = InheritedObjectType;
                nAceLength += SIZEOF(GUID);
            }
        }

        // Copy the SID
        nSidLength = GetLengthSid(psid);
        CopyMemory(GetAceSid(pAceDest), psid, nSidLength);

        // The size should already be correct, but set it here to be sure.
        pAceDest->AceSize = (USHORT)(nAceLength + nSidLength);
    }
}


int
CAce::CompareType(const CAce *pAceCompare) const
{
    //
    // Determine which ACE preceeds the other in canonical ordering.
    //
    // Return negative if this ACE preceeds pAceCompare, positive if
    // pAceCompare preceeds this ACE, and 0 if they are equivalent in
    // canonical ordering.
    //
    BOOL b1;
    BOOL b2;

    //
    // First check inheritance. Inherited ACEs follow non-inherited ACEs.
    //
    b1 = AceFlags & INHERITED_ACE;
    b2 = pAceCompare->AceFlags & INHERITED_ACE;

    if (b1 != b2)
    {
        // One (and only one) of the ACEs is inherited.
        return (b1 ? 1 : -1);
    }

    //
    // Next, Allow ACEs follow Deny ACEs.
    // Note that allow/deny has no effect on the ordering of Audit ACEs.
    //
    b1 = (AceType == ACCESS_ALLOWED_ACE_TYPE ||
          AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE);
    b2 = (pAceCompare->AceType == ACCESS_ALLOWED_ACE_TYPE ||
          pAceCompare->AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE);

    if (b1 != b2)
    {
        // One of the ACEs is an Allow ACE.
        return (b1 ? 1 : -1);
    }

    //
    // Next, Object ACEs follow non-object ACEs.
    //
    b1 = (AceType >= ACCESS_MIN_MS_OBJECT_ACE_TYPE &&
          AceType <= ACCESS_MAX_MS_OBJECT_ACE_TYPE);
    b2 = (pAceCompare->AceType >= ACCESS_MIN_MS_OBJECT_ACE_TYPE &&
          pAceCompare->AceType <= ACCESS_MAX_MS_OBJECT_ACE_TYPE);

    if (b1 != b2)
    {
        // One of the ACEs is an Object ACE.
        return (b1 ? 1 : -1);
    }

    return 0;
}


DWORD
CAce::Merge(const CAce *pAce2)
{
    DWORD dwStatus;
    DWORD dwMergeFlags = 0;
    DWORD dwResult;

    if (pAce2 == NULL)
        return MERGE_FAIL;

    //if either of the ace is inherited and they are not from the same parent
    if( GetInheritSourceLevel() != pAce2->GetInheritSourceLevel() )
        return MERGE_FAIL;

    //
    // The ACEs have to be the same basic type and have the same SID or
    // there's no hope.
    //
    if (!IsEqualACEType(AceType, pAce2->AceType) ||
        !EqualSid(psid, pAce2->psid))
        return MERGE_FAIL;

    if (!IsEqualGUID(InheritedObjectType, pAce2->InheritedObjectType))
        return MERGE_FAIL;  // incompatible inherit object types

    if (Flags & ACE_OBJECT_TYPE_PRESENT)
        dwMergeFlags |= MF_OBJECT_TYPE_1_PRESENT;

    if (pAce2->Flags & ACE_OBJECT_TYPE_PRESENT)
        dwMergeFlags |= MF_OBJECT_TYPE_2_PRESENT;

    if (IsEqualGUID(ObjectType, pAce2->ObjectType))
        dwMergeFlags |= MF_OBJECT_TYPE_EQUAL;

    if (IsAuditAlarmACE(AceType))
        dwMergeFlags |= MF_AUDIT_ACE_TYPE;

    dwStatus = MergeAceHelper(AceFlags,
                              Mask,
                              pAce2->AceFlags,
                              pAce2->Mask,
                              dwMergeFlags,
                              &dwResult);

    switch (dwStatus)
    {
    case MERGE_MODIFIED_FLAGS:
        AceFlags = (UCHAR)dwResult;
        break;

    case MERGE_MODIFIED_MASK:
        Mask = dwResult;
        break;
    }

    return dwStatus;
}


BOOL
IsEqualACEType(DWORD dwType1, DWORD dwType2)
{
    if (dwType1 >= ACCESS_MIN_MS_OBJECT_ACE_TYPE &&
        dwType1 <= ACCESS_MAX_MS_OBJECT_ACE_TYPE)
        dwType1 -= (ACCESS_ALLOWED_OBJECT_ACE_TYPE - ACCESS_ALLOWED_ACE_TYPE);

    if (dwType2 >= ACCESS_MIN_MS_OBJECT_ACE_TYPE &&
        dwType2 <= ACCESS_MAX_MS_OBJECT_ACE_TYPE)
        dwType2 -= (ACCESS_ALLOWED_OBJECT_ACE_TYPE - ACCESS_ALLOWED_ACE_TYPE);

    return (dwType1 == dwType2);
}


DWORD
MergeAceHelper(DWORD dwAceFlags1,
               DWORD dwMask1,
               DWORD dwAceFlags2,
               DWORD dwMask2,
               DWORD dwMergeFlags,
               LPDWORD pdwResult)
{
    // Assumptions:
    //   The ACEs are the same basic type.
    //   The SIDs are the same for both.
    //   The Inherit object type is the same for both.

    if (pdwResult == NULL)
        return MERGE_FAIL;

    *pdwResult = 0;

    if (dwMergeFlags & MF_OBJECT_TYPE_EQUAL)
    {
        if (dwAceFlags1 == dwAceFlags2)
        {
            //
            // Everything matches except maybe the mask, which
            // can be combined here.
            //
            if (AllFlagsOn(dwMask1, dwMask2))
                return MERGE_OK_1;
            else if (AllFlagsOn(dwMask2, dwMask1))
                return MERGE_OK_2;

            *pdwResult = dwMask1 | dwMask2;
            return MERGE_MODIFIED_MASK;
        }
        else if ((dwAceFlags1 & VALID_INHERIT_FLAGS) == (dwAceFlags2 & VALID_INHERIT_FLAGS) &&
                dwMask1 == dwMask2)
		{
			// If 2 audit aces are identical except for the audit
            // type (success/fail), the flags can be combined.
			if (dwMergeFlags & MF_AUDIT_ACE_TYPE)        
            {
                *pdwResult = dwAceFlags1 | dwAceFlags2;
                return MERGE_MODIFIED_FLAGS;
            }
        }
        else if ((dwAceFlags1 & (NO_PROPAGATE_INHERIT_ACE | INHERITED_ACE | FAILED_ACCESS_ACE_FLAG | SUCCESSFUL_ACCESS_ACE_FLAG))
                    == (dwAceFlags2 & (NO_PROPAGATE_INHERIT_ACE | INHERITED_ACE | FAILED_ACCESS_ACE_FLAG | SUCCESSFUL_ACCESS_ACE_FLAG)))
        {
            // The NO_PROPAGATE_INHERIT_ACE bit is the same for both
            if (dwMask1 == dwMask2)
            {
                // The masks are the same, so we can combine inherit flags
                *pdwResult = dwAceFlags1;

                // INHERIT_ONLY_ACE should be turned on only if it is
                // already on in both ACEs, otherwise leave it off.
                if (!(dwAceFlags2 & INHERIT_ONLY_ACE))
                    *pdwResult &= ~INHERIT_ONLY_ACE;

                // Combine the remaining inherit flags and return
                *pdwResult |= dwAceFlags2 & (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE);
                return MERGE_MODIFIED_FLAGS;
            }
            else if (AllFlagsOn(dwMask1, dwMask2))
            {
                // mask1 contains mask2. If Ace1 is inherited onto all of the
                // same things that Ace2 is, then Ace2 is redundant.
                if ((!(dwAceFlags1 & INHERIT_ONLY_ACE) || (dwAceFlags2 & INHERIT_ONLY_ACE))
                    && AllFlagsOn(dwAceFlags1 & ACE_INHERIT_ALL, dwAceFlags2 & ACE_INHERIT_ALL))
                    return MERGE_OK_1;
            }
            else if (AllFlagsOn(dwMask2, dwMask1))
            {
                // Same as above, reversed.
                if ((!(dwAceFlags2 & INHERIT_ONLY_ACE) || (dwAceFlags1 & INHERIT_ONLY_ACE))
                    && AllFlagsOn(dwAceFlags2 & ACE_INHERIT_ALL, dwAceFlags1 & ACE_INHERIT_ALL))
                    return MERGE_OK_2;
            }
        }
    }
    else if (dwAceFlags1 == dwAceFlags2)
    {
        if (!(dwMergeFlags & MF_OBJECT_TYPE_1_PRESENT) &&
                 AllFlagsOn(dwMask1, dwMask2))
        {
            //
            // The other ACE has a non-NULL object type but this ACE has no object
            // type and a mask that includes all of the bits in the other one.
            // I.e. This ACE implies the other ACE.
            //
            return MERGE_OK_1;
        }
        else if (!(dwMergeFlags & MF_OBJECT_TYPE_2_PRESENT) &&
                 AllFlagsOn(dwMask2, dwMask1))
        {
            //
            // This ACE has a non-NULL object type but the other ACE has no object
            // type and a mask that includes all of the bits in this one.
            // I.e. The other ACE implies this ACE.
            //
            return MERGE_OK_2;
        }
    }

    return MERGE_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\ace.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ace.h
//
//  This file contains definitions and prototypes for the ACE abstraction
//  class (CAce)
//
//--------------------------------------------------------------------------

#ifndef _ACE_H_
#define _ACE_H_

class CAce : public ACE_HEADER
{
public:
  //UCHAR           AceType;        // Inherited from ACE_HEADER
  //UCHAR           AceFlags;
  //USHORT          AceSize;
    ACCESS_MASK     Mask;
    ULONG           Flags;          // ACE_OBJECT_TYPE_PRESENT, etc.
    GUID            ObjectType;
    GUID            InheritedObjectType;
    PSID            psid;
    SID_NAME_USE    sidType;
private:
    LPTSTR          pszName;
    LPTSTR          pszType;
    LPTSTR          pszAccessType;
    LPTSTR          pszInheritType;
    BOOL            bPropertyAce;
    LPTSTR          pszInheritSourceName;
    INT            iInheritSourceLevel;
public:
    CAce(PACE_HEADER pAceHeader = NULL);
    ~CAce();

    LPTSTR GetName()        const { return pszName;         }
    LPTSTR GetType()        const { return pszType;         }
    LPTSTR GetAccessType()  const { return pszAccessType;   }
    LPTSTR GetInheritType() const { return pszInheritType;  }
    LPTSTR GetInheritSourceName() const { return pszInheritSourceName; }
    INT   GetInheritSourceLevel() const { return iInheritSourceLevel; }
    BOOL   IsPropertyAce()  const { return bPropertyAce;    }
    BOOL   IsInheritedAce() const { return AceFlags & INHERITED_ACE; }

    LPTSTR LookupName(LPCTSTR pszServer = NULL, LPSECURITYINFO2 psi2 = NULL);
    void SetInheritSourceInfo(LPCTSTR psz, INT level);
    void SetName(LPCTSTR pszN, LPCTSTR pszL = NULL);
    void SetType(LPCTSTR psz)        { SetString(&pszType, psz);        }
    void SetAccessType(LPCTSTR psz)  { SetString(&pszAccessType, psz);  }
    void SetInheritType(LPCTSTR psz) { SetString(&pszInheritType, psz); }
    void SetPropertyAce(BOOL b)      { bPropertyAce = b;                }
    void SetSid(PSID p, LPCTSTR pszName, LPCTSTR pszLogonName, SID_NAME_USE type);
    PACE_HEADER Copy() const;
    void CopyTo(PACE_HEADER pAceDest) const;
    int  CompareType(const CAce *pAceCompare) const;
    DWORD Merge(const CAce *pAce2);

private:
    void SetString(LPTSTR *ppszDest, LPCTSTR pszSrc);
};
typedef CAce *PACE;

#define AllFlagsOn(dw1, dw2)        (((dw1) & (dw2)) == (dw2))  // equivalent to ((dw1 | dw2) == dw1)
#define IsAuditAlarmACE(type) ( ((type) == SYSTEM_AUDIT_ACE_TYPE)        || \
                                ((type) == SYSTEM_AUDIT_OBJECT_ACE_TYPE) || \
                                ((type) == SYSTEM_ALARM_ACE_TYPE)        || \
                                ((type) == SYSTEM_ALARM_OBJECT_ACE_TYPE) )

BOOL
IsEqualACEType(DWORD dwType1, DWORD dwType2);

DWORD
MergeAceHelper(DWORD dwAceFlags1,
               DWORD dwMask1,
               DWORD dwAceFlags2,
               DWORD dwMask2,
               DWORD dwMergeFlags,
               LPDWORD pdwResult);

// CAce::Merge and MergeAceHelper return values
#define MERGE_FAIL              0   // Unable to merge ACEs
#define MERGE_OK_1              1   // ACE 1 (this) implies ACE 2
#define MERGE_OK_2              2   // ACE 2 implies ACE 1 (this)
#define MERGE_MODIFIED_FLAGS    3   // ACEs can be merged by modifying flags (new flags in *pdwResult)
#define MERGE_MODIFIED_MASK     4   // ACEs can be merged by modifying mask (new mask in *pdwResult)

// Values for MergeAceHelper dwMergeFlags parameter
#define MF_OBJECT_TYPE_1_PRESENT    1
#define MF_OBJECT_TYPE_2_PRESENT    2
#define MF_OBJECT_TYPE_EQUAL        4
#define MF_AUDIT_ACE_TYPE           8


#endif  // _ACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\runonce\romain.c ===
// **************************************************************************
//
// ROMain.C
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1992-1993
//  All rights reserved
//
//  The window/messages pump for RunOnce
//
//      5 June 1994     FelixA  Started
//
//     23 June 94       FelixA  Moved to Shell tree. Changed UI.
//
// *************************************************************************/

#include "precomp.h"
#include "regstr.h"
#include <shlwapi.h>
#include <shlwapip.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <shellapi.h>
#include <winuserp.h>
#include <shlobj.h>
#include <shlobjp.h>
#include "resource.h"

#include <runonce.c>    // shared runonce code

// needed to make this code compile (legacy runonce.c baggage from explorer\initcab.cpp)
BOOL g_fCleanBoot = FALSE;
BOOL g_fEndSession = FALSE;


HINSTANCE g_hInst;          // current instance
BOOL InitROInstance( HINSTANCE hInstance, int nCmdShow);


typedef void (WINAPI *RUNONCEEXPROCESS)(HWND, HINSTANCE, LPSTR, int);

int ParseCmdLine(LPCTSTR lpCmdLine)
{
    int Res=0;

    while(*lpCmdLine)
    {
        while( *lpCmdLine && *lpCmdLine!=TEXT('-') && *lpCmdLine!=TEXT('/'))
            lpCmdLine++;

        if (!(*lpCmdLine)) {
            return Res;
        }

        // skip over the '/'
        lpCmdLine++;

        if (lstrcmpi(lpCmdLine, TEXT("RunOnce6432")) == 0)
        {
            if (IsOS(OS_WOW6432))
            {
                // this means we have to process the 32-bit runonce keys for wow64
                Res =  Cabinet_EnumRegApps(HKEY_LOCAL_MACHINE,
                                           REGSTR_PATH_RUNONCE,
                                           RRA_DELETE | RRA_WAIT,
                                           ExecuteRegAppEnumProc,
                                           0);
            }   
            return Res;
        }
        else if (lstrcmpi(lpCmdLine, TEXT("RunOnceEx6432")) == 0)
        {
            if (IsOS(OS_WOW6432))
            {
                // this means that we have to process the 32-bit runonceex keys for wow64
                HINSTANCE hLib;

                hLib = LoadLibrary(TEXT("iernonce.dll"));
                if (hLib)
                {
                    // Note: if ew ant TS install mode for wow64 apps we need to enable/disable install mode here
                    RUNONCEEXPROCESS pfnRunOnceExProcess = (RUNONCEEXPROCESS)GetProcAddress(hLib, "RunOnceExProcess");
                    if (pfnRunOnceExProcess)
                    {
                        // the four param in the function is due to the function cab be called
                        // from RunDLL which will path in those params.  But RunOnceExProcess ignore all
                        // of them.  Therefore, I don't pass any meaningful thing here.
                        //
                        pfnRunOnceExProcess(NULL, NULL, NULL, 0);

                        Res = 1;
                    }
                    FreeLibrary(hLib);
                }
            }
            return Res;
        }
        else if (lstrcmpi(lpCmdLine, TEXT("Run6432")) == 0)
        {
            if (IsOS(OS_WOW6432))
            {
                // this means that we have to process the 32-bit Run keys for wow64
                Res =  Cabinet_EnumRegApps(HKEY_LOCAL_MACHINE,
                                           REGSTR_PATH_RUN,
                                           RRA_NOUI,
                                           ExecuteRegAppEnumProc,
                                           0);
            }
            return Res;
        }

        switch(*lpCmdLine)
        {
            case TEXT('r'):
                Res|=CMD_DO_CHRIS;
                break;
            case TEXT('b'):
                Res|=CMD_DO_REBOOT;
                break;
            case TEXT('s'):
                Res|=CMD_DO_RESTART;
                break;
        }
        lpCmdLine++;
    }
    return Res;
}

/****************************************************************************

        FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int)

        PURPOSE: calls initialization function, processes message loop

****************************************************************************/
int g_iState=0;
int __stdcall WinMainT(
        HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
        LPTSTR lpCmdLine,
        int nCmdShow)
{
    if (!hPrevInstance)
    {       // Other instances of app running?
        if (!InitApplication(hInstance))
        { // Initialize shared things
             return (FALSE);     // Exits if unable to initialize
        }
    }

    // see if we have a commnand line switch - in a VERY bad way.
    g_iState = ParseCmdLine(GetCommandLine());
    if(g_iState & CMD_DO_CHRIS )
    {
        // Go do chris's runonce stuff.
        if (!InitROInstance(hInstance, nCmdShow))
            return (FALSE);
        return TRUE;
    }
    else
    {
        /* Perform initializations that apply to a specific instance */
        if (!InitInstance(hInstance, nCmdShow))
            return (FALSE);
    }
    return (FALSE);
}


/****************************************************************************

        FUNCTION: InitApplication(HINSTANCE)


****************************************************************************/

BOOL InitApplication(HINSTANCE hInstance)
{
//    CreateGlobals();
    return TRUE;
}


/****************************************************************************

        FUNCTION:  InitInstance(HINSTANCE, int)

****************************************************************************/

BOOL InitInstance( HINSTANCE hInstance, int nCmdShow)
{
    HWND hShell=GetShellWindow();
    g_hInst = hInstance; // Store instance handle in our global variable

    DialogBox(hInstance, MAKEINTRESOURCE(IDD_RUNONCE),NULL,dlgProcRunOnce);
    return (TRUE);              // We succeeded...
}

BOOL InitROInstance( HINSTANCE hInstance, int nCmdShow)
{
    g_hInst = hInstance; // Store instance handle in our global variable

    // Ideally this should be sufficient.
    Cabinet_EnumRegApps(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUNONCE, RRA_DELETE| RRA_WAIT, ExecuteRegAppEnumProc, 0);
    return TRUE;
}

BOOL TopLeftWindow( HWND hwndChild, HWND hwndParent)
{
    return SetWindowPos(hwndChild, NULL, 32, 32, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}

/****************************************************************************

        FUNCTION: CenterWindow (HWND, HWND)

        PURPOSE:  Center one window over another

        COMMENTS:

        Dialog boxes take on the screen position that they were designed at,
        which is not always appropriate. Centering the dialog over a particular
        window usually results in a better position.

****************************************************************************/

BOOL CenterWindow (HWND hwndChild, HWND hwndParent)
{
    RECT    rChild, rParent;
    int     wChild, hChild, wParent, hParent;
    int     wScreen, hScreen, xNew, yNew;
    HDC     hdc;

    // Get the Height and Width of the child window
    GetWindowRect (hwndChild, &rChild);
    wChild = rChild.right - rChild.left;
    hChild = rChild.bottom - rChild.top;


    // Get the display limits
    hdc = GetDC (hwndChild);
    wScreen = GetDeviceCaps (hdc, HORZRES);
    hScreen = GetDeviceCaps (hdc, VERTRES);
    ReleaseDC (hwndChild, hdc);

    // Get the Height and Width of the parent window
    if( !GetWindowRect (hwndParent, &rParent) )
    {
        rParent.right = wScreen;
        rParent.left  = 0;
        rParent.top = 0;
        rParent.bottom = hScreen;
    }

        wParent = rParent.right - rParent.left;
        hParent = rParent.bottom - rParent.top;

    // Calculate new X position, then adjust for screen
    xNew = rParent.left + ((wParent - wChild) /2);
    if (xNew < 0)
    {
        xNew = 0;
    }
    else
    if ((xNew+wChild) > wScreen)
    {
        xNew = wScreen - wChild;
    }

    // Calculate new Y position, then adjust for screen
    yNew = rParent.top  + ((hParent - hChild) /2);
    if (yNew < 0)
    {
        yNew = 0;
    } else if ((yNew+hChild) > hScreen)
    {
        yNew = hScreen - hChild;
    }

    // Set it, and return
    return SetWindowPos (hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}


// stolen from the CRT, used to shirink our code
int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPTSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfo(&si);

    i = WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\aclbloat.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       aclbloat.h
//	
//	This file contains the definition for ACLBLOAT class which controls the 
//  dialog box for aclbloat
//
//	Author		hiteshr 4th April 2001
//
//--------------------------------------------------------------------------

#ifndef _ACLBLOAT_H
#define _ACLBLOAT_H


class CACLBloat
{
private:
	LPSECURITYINFO		m_psi;
	LPSECURITYINFO2		m_psi2;
	SI_PAGE_TYPE		m_siPageType;
	SI_OBJECT_INFO*		m_psiObjectInfo;
	HDPA				m_hEntries;
	HDPA				m_hPropEntries;
	HDPA				m_hMergedEntries;
	HFONT				m_hFont;
public:
    CACLBloat(LPSECURITYINFO	psi, 
			  LPSECURITYINFO2   psi2,
			  SI_PAGE_TYPE		m_siPageType,
			  SI_OBJECT_INFO*   psiObjectInfo,
			  HDPA				hEntries,
			  HDPA				hPropEntries);

	~CACLBloat();

	BOOL DoModalDialog(HWND hParent);
	BOOL IsAclBloated();

private:

	static INT_PTR _DlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

	HRESULT InitDlg( HWND hDlg );
	
	BOOL OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);

    BOOL OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam);
    
	HRESULT AddAce(HDPA hEntries, 
                  PACE_HEADER pAceHeader);

	HRESULT AddAce(HDPA hEntries, PACE pAceNew);


    LPCTSTR TranslateAceIntoRights(DWORD dwMask, const GUID *pObjectType,
                                   PSI_ACCESS  pAccess, ULONG       cAccess);
    
	LPCTSTR GetItemString(LPCTSTR pszItem, LPTSTR pszBuffer, UINT ccBuffer);

    HRESULT AddAcesFromDPA(HWND hListView, HDPA hEntries);

	HRESULT MergeAces(HDPA hEntries, HDPA hPropEntries, HDPA hMergedList);

};
typedef CACLBloat *PACLBLOAT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\chklist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       chklist.cpp
//
//  This file contains the implementation of the CheckList control.
//
//--------------------------------------------------------------------------

#include "aclpriv.h"

//
// Text and Background colors
//
#define TEXT_COLOR  COLOR_WINDOWTEXT
#define BK_COLOR    COLOR_WINDOW

//
// Default dimensions for child controls. All are in dialog units.
// Currently only the column width is user-adjustable (via the
// CLM_SETCOLUMNWIDTH message).
//
#define DEFAULT_COLUMN_WIDTH    40
#define DEFAULT_CHECK_WIDTH     9
#define DEFAULT_HORZ_SPACE      7
#define DEFAULT_VERTICAL_SPACE  3
#define DEFAULT_ITEM_HEIGHT     8


//
// 16 bits are used for the control ID's, divided into n bits for
// the subitem (least significant) and 16-n bits for the item index.
//
// ID_SUBITEM_BITS can be adjusted to control the maximum number of
// items and subitems. For example, to allow up to 7 subitems and 8k
// items, set ID_SUBITEM_BITS to 3.
//

// Use the low 2 bits for the subitem index, the rest for the item index.
// (4 subitems max, 16k items max)
#define ID_SUBITEM_BITS         2

#define ID_SUBITEM_MASK         ((1 << ID_SUBITEM_BITS) - 1)
#define GET_ITEM(id)            ((id) >> ID_SUBITEM_BITS)
#define GET_SUBITEM(id)         ((id) & ID_SUBITEM_MASK)

#define MAKE_CTRL_ID(i, s)      (0xffff & (((i) << ID_SUBITEM_BITS) | ((s) & ID_SUBITEM_MASK)))
#define MAKE_LABEL_ID(i)        MAKE_CTRL_ID(i, 0)
// Note that the subitem (column) index is one-based for the checkboxes
// (the zero column is the label).  The item (row) index is zero-based.

#define MAX_CHECK_COLUMNS       ID_SUBITEM_MASK


TCHAR const c_szStaticClass[]   = TEXT("STATIC");
TCHAR const c_szButtonClass[]   = TEXT("BUTTON");


class CCheckList
{
private:
    LONG m_cItems;
    LONG m_cSubItems;
    RECT m_rcItemLabel;
    LONG m_nCheckPos[MAX_CHECK_COLUMNS];
    LONG m_cxCheckBox;
    LONG m_cxCheckColumn;
    HWND m_hwndCheckFocus;
    LPTSTR m_pszColumnDesc[MAX_CHECK_COLUMNS];

    int m_cWheelDelta;
    static UINT g_ucScrollLines;

private:
    CCheckList(HWND hWnd, LPCREATESTRUCT lpcs);
    ~CCheckList(void);

    LRESULT MsgCommand(HWND hWnd, WORD idCmd, WORD wNotify, HWND hwndCtrl);
    void MsgPaint(HWND hWnd, HDC hdc);
    void MsgVScroll(HWND hWnd, int nCode, int nPos);
    void MsgMouseWheel(HWND hWnd, WORD fwFlags, int zDelta);
    void MsgButtonDown(HWND hWnd, WPARAM fwFlags, int xPos, int yPos);
    void MsgEnable(HWND hWnd, BOOL fEnabled);
    void MsgSize(HWND hWnd, DWORD dwSizeType, LONG nWidth, LONG nHeight);

    LONG AddItem(HWND hWnd, LPCTSTR pszLabel, LPARAM lParam);
    void SetState(HWND hWnd, WORD iItem, WORD iSubItem, LONG lState);
    LONG GetState(HWND hWnd, WORD iItem, WORD iSubItem);
    void SetColumnWidth(HWND hWnd, LONG cxDialog, LONG cxColumn);
    void ResetContent(HWND hWnd);
    LONG GetVisibleCount(HWND hWnd);
    LONG GetTopIndex(HWND hWnd);
    void SetTopIndex(HWND hWnd, LONG nIndex)
    { m_cWheelDelta = 0; MsgVScroll(hWnd, SB_THUMBPOSITION, nIndex * m_rcItemLabel.bottom); }
    void EnsureVisible(HWND hWnd, LONG nIndex);
    void DrawCheckFocusRect(HWND hWnd, HWND hwndCheck, BOOL fDraw);
    void GetColumnDescriptions(HWND hWnd);

public:
    static LRESULT CALLBACK WindowProc(HWND hWnd,
                                       UINT uMsg,
                                       WPARAM wParam,
                                       LPARAM lParam);
};


BOOL RegisterCheckListWndClass(void)
{
    WNDCLASS wc;

    wc.style            = 0;
    wc.lpfnWndProc      = CCheckList::WindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = hModule;
    wc.hIcon            = NULL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(BK_COLOR+1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = TEXT(WC_CHECKLIST);

    return (BOOL)RegisterClass(&wc);
}


UINT CCheckList::g_ucScrollLines = (UINT)-1;


CCheckList::CCheckList(HWND hWnd, LPCREATESTRUCT lpcs)
: m_cItems(0), m_hwndCheckFocus(NULL), m_cWheelDelta(0)
{
    TraceEnter(TRACE_CHECKLIST, "CCheckList::CCheckList");
    TraceAssert(hWnd != NULL);
    TraceAssert(lpcs != NULL);

    //
    // Get number of check columns
    //
    m_cSubItems = lpcs->style & CLS_CHECKMASK;

    //
    // Convert default coordinates from dialog units to pixels
    //
    RECT rc;
    rc.left = DEFAULT_CHECK_WIDTH;
    rc.right = DEFAULT_COLUMN_WIDTH;
    rc.top = rc.bottom = 0;
    MapDialogRect(lpcs->hwndParent, &rc);

    // Save the converted values
    m_cxCheckBox = rc.left;
    m_cxCheckColumn = rc.right;

    rc.left = DEFAULT_HORZ_SPACE;
    rc.top = DEFAULT_VERTICAL_SPACE;
    rc.right = 10;              // bogus (unused)
    rc.bottom = DEFAULT_VERTICAL_SPACE + DEFAULT_ITEM_HEIGHT;
    MapDialogRect(lpcs->hwndParent, &rc);

    // Save the converted values
    m_rcItemLabel = rc;

    //
    // Get info for mouse wheel scrolling
    //
    if ((UINT)-1 == g_ucScrollLines)
    {
        g_ucScrollLines = 3; // default
        SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &g_ucScrollLines, 0);
    }

    TraceLeaveVoid();
}

CCheckList::~CCheckList(void)
{
    for (LONG j = 0; j < m_cSubItems; j++)
    {
        LocalFreeString(&m_pszColumnDesc[j]);
    }
}

LRESULT
CCheckList::MsgCommand(HWND hWnd, WORD idCmd, WORD wNotify, HWND hwndCtrl)
{
    TraceEnter(TRACE_CHECKLIST, "CCheckList::MsgCommand");

    // Should only get notifications from visible, enabled, check boxes
    TraceAssert(GET_ITEM(idCmd) < m_cItems);
    TraceAssert(0 < GET_SUBITEM(idCmd) && GET_SUBITEM(idCmd) <= m_cSubItems);
    TraceAssert(hwndCtrl && IsWindowEnabled(hwndCtrl));

    switch (wNotify)
    {
    case BN_CLICKED:
        {
            NM_CHECKLIST nmc;
            nmc.hdr.hwndFrom = hWnd;
            nmc.hdr.idFrom = GetDlgCtrlID(hWnd);
            nmc.hdr.code = CLN_CLICK;
            nmc.iItem = GET_ITEM(idCmd);
            nmc.iSubItem = GET_SUBITEM(idCmd);
            nmc.dwState = (DWORD)SendMessage(hwndCtrl, BM_GETCHECK, 0, 0);
            if (!IsWindowEnabled(hwndCtrl))
                nmc.dwState |= CLST_DISABLED;
            nmc.dwItemData = GetWindowLongPtr(GetDlgItem(hWnd, MAKE_LABEL_ID(nmc.iItem)),
                                              GWLP_USERDATA);
            nmc.cchTextMax = 0;
            nmc.pszText = NULL;

            SendMessage(GetParent(hWnd),
                        WM_NOTIFY,
                        nmc.hdr.idFrom,
                        (LPARAM)&nmc);
        }
        break;

    case BN_SETFOCUS:
        if (m_hwndCheckFocus != hwndCtrl)   // Has the focus moved?
        {
            // Remember where the focus is
            m_hwndCheckFocus = hwndCtrl;

            // Make sure the row is scrolled into view
            EnsureVisible(hWnd, GET_ITEM(idCmd));
        }
        // Always draw the focus rect
        DrawCheckFocusRect(hWnd, hwndCtrl, TRUE);
        break;

    case BN_KILLFOCUS:
        // Remove the focus rect
        m_hwndCheckFocus = NULL;
        DrawCheckFocusRect(hWnd, hwndCtrl, FALSE);
        break;
    }

    TraceLeaveValue(0);
}


void
CCheckList::MsgPaint(HWND hWnd, HDC hdc)
{
    if (hdc == NULL && m_hwndCheckFocus != NULL)
    {
        // This will cause a focus rect to be drawn after the window and
        // all checkboxes have been painted.
        PostMessage(hWnd,
                    WM_COMMAND,
                    GET_WM_COMMAND_MPS(GetDlgCtrlID(m_hwndCheckFocus), m_hwndCheckFocus, BN_SETFOCUS));
    }

    // Default paint
    DefWindowProc(hWnd, WM_PAINT, (WPARAM)hdc, 0);
}


void
CCheckList::MsgVScroll(HWND hWnd, int nCode, int nPos)
{
    UINT cScrollUnitsPerLine;
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_ALL;

    if (!GetScrollInfo(hWnd, SB_VERT, &si))
        return;

    cScrollUnitsPerLine = m_rcItemLabel.bottom;

    // One page is always visible, so adjust the range to a more useful value
    si.nMax -= si.nPage - 1;

    switch (nCode)
    {
    case SB_LINEUP:
        // "line" is the height of one item (includes the space in between)
        nPos = si.nPos - cScrollUnitsPerLine;
        break;

    case SB_LINEDOWN:
        nPos = si.nPos + cScrollUnitsPerLine;
        break;

    case SB_PAGEUP:
        nPos = si.nPos - si.nPage;
        break;

    case SB_PAGEDOWN:
        nPos = si.nPos + si.nPage;
        break;

    case SB_TOP:
        nPos = si.nMin;
        break;

    case SB_BOTTOM:
        nPos = si.nMax;
        break;

    case SB_ENDSCROLL:
        nPos = si.nPos;     // don't go anywhere
        break;

    case SB_THUMBTRACK:
        // Do nothing here to allow tracking
        // nPos = si.nPos;    // Do this to prevent tracking
    case SB_THUMBPOSITION:
        // nothing to do here... nPos is passed in
        break;
    }

    // Make sure the new position is within the range
    if (nPos < si.nMin)
        nPos = si.nMin;
    else if (nPos > si.nMax)
        nPos = si.nMax;

    if (nPos != si.nPos)  // are we moving?
    {
        SetScrollPos(hWnd, SB_VERT, nPos, TRUE);
        ScrollWindow(hWnd, 0, si.nPos - nPos, NULL, NULL);
    }
}


void
CCheckList::MsgMouseWheel(HWND hWnd, WORD fwFlags, int iWheelDelta)
{
    int cDetants;

    if ((fwFlags & (MK_SHIFT | MK_CONTROL)) || 0 == g_ucScrollLines)
        return;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::MsgMouseWheel");

    // Update count of scroll amount
    m_cWheelDelta -= iWheelDelta;
    cDetants = m_cWheelDelta / WHEEL_DELTA;
    if (0 == cDetants)
        TraceLeaveVoid();
    m_cWheelDelta %= WHEEL_DELTA;

    if (WS_VSCROLL & GetWindowLong(hWnd, GWL_STYLE))
    {
        SCROLLINFO  si;
        UINT        cScrollUnitsPerLine;
        UINT        cLinesPerPage;
        UINT        cLinesPerDetant;

        // Get the scroll amount of one line
        cScrollUnitsPerLine = m_rcItemLabel.bottom;
        TraceAssert(cScrollUnitsPerLine > 0);

        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_PAGE | SIF_POS;
        if (!GetScrollInfo(hWnd, SB_VERT, &si))
            TraceLeaveVoid();

        // The size of a page is at least one line, and
        // leaves one line of overlap
        cLinesPerPage = (si.nPage - cScrollUnitsPerLine) / cScrollUnitsPerLine;
        cLinesPerPage = max(1, cLinesPerPage);

        // Don't scroll more than one page per detant
        cLinesPerDetant = min(cLinesPerPage, g_ucScrollLines);

        si.nPos += cDetants * cLinesPerDetant * cScrollUnitsPerLine;

        MsgVScroll(hWnd, SB_THUMBTRACK, si.nPos);
    }
    TraceLeaveVoid();
}


void
CCheckList::MsgButtonDown(HWND hWnd, WPARAM /*fwFlags*/, int /*xPos*/, int yPos)
{
    LONG nItemIndex;
    HWND hwndCheck;
    RECT rc;

    // Get position of the top visible item in client coords
    nItemIndex = GetTopIndex(hWnd);
    hwndCheck = GetDlgItem(hWnd, MAKE_CTRL_ID(nItemIndex, 0));
    GetWindowRect(hwndCheck, &rc);
    MapWindowPoints(NULL, hWnd, (LPPOINT)&rc, 2);

    // Find nearest item
    nItemIndex += (yPos - rc.top + m_rcItemLabel.top/2)/m_rcItemLabel.bottom;
    nItemIndex = max(0, min(nItemIndex, m_cItems - 1)); // 0 <= y < m_cItems

    // Set focus to first subitem that is enabled
    for (LONG j = 1; j <= m_cSubItems; j++)
    {
        hwndCheck = GetDlgItem(hWnd, MAKE_CTRL_ID(nItemIndex, j));
        if (IsWindowEnabled(hwndCheck))
        {
            SetFocus(hwndCheck);
            break;
        }
    }
}


void
CCheckList::MsgEnable(HWND hWnd, BOOL fEnabled)
{
    static BOOL bInMsgEnable = FALSE;

    if (!bInMsgEnable)
    {
        bInMsgEnable = TRUE;
        for (LONG i = 0; i < m_cItems; i++)
        {
            for (LONG j = 1; j <= m_cSubItems; j++)
            {
                EnableWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(i, j)), fEnabled);
            }
        }
        if (!fEnabled)
            EnableWindow(hWnd, TRUE);
        bInMsgEnable = FALSE;
    }
}


void
CCheckList::MsgSize(HWND hWnd, DWORD dwSizeType, LONG nWidth, LONG nHeight)
{
    TraceEnter(TRACE_CHECKLIST, "CCheckList::MsgSize");
    TraceAssert(hWnd != NULL);

    if (dwSizeType == SIZE_RESTORED)
    {
        RECT rc;
        SCROLLINFO si;

        si.cbSize = sizeof(si);
        si.fMask = SIF_RANGE | SIF_PAGE;
        si.nMin = 0;
        si.nMax = m_cItems * m_rcItemLabel.bottom + m_rcItemLabel.top - 1;
        si.nPage = nHeight;                         // ^^^^^^^^^ extra space

        SetScrollInfo(hWnd, SB_VERT, &si, FALSE);

        // Don't trust the width value passed in, since SetScrollInfo may
        // affect it if the scroll bar is turning on or off.
        GetClientRect(hWnd, &rc);
        nWidth = rc.right;

        // If the scrollbar is turned on, artificially bump up the width
        // by the width of the scrollbar, so the boxes don't jump to the left
        // when we have a scrollbar.
        if ((UINT)si.nMax >= si.nPage)
            nWidth += GetSystemMetrics(SM_CYHSCROLL);

        SetColumnWidth(hWnd, nWidth, m_cxCheckColumn);
    }

    TraceLeaveVoid();
}


LONG
CCheckList::AddItem(HWND hWnd, LPCTSTR pszLabel, LPARAM lParam)
{
    HWND hwndNew;
    HWND hwndPrev;
    RECT rc;
    LONG cyOffset;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::AddItem");
    TraceAssert(hWnd != NULL);
    TraceAssert(pszLabel != NULL && !IsBadStringPtr(pszLabel, MAX_PATH));

    // If this is the first item, get column descriptions
    if (0 == m_cItems)
        GetColumnDescriptions(hWnd);

    // Calculate the position of the new static label
    rc = m_rcItemLabel;
    cyOffset = m_cItems * m_rcItemLabel.bottom;
    OffsetRect(&rc, 0, cyOffset);

    // Create a new label control
    hwndNew = CreateWindowEx(WS_EX_NOPARENTNOTIFY,
                             c_szStaticClass,
                             pszLabel,
                             WS_CHILD | WS_VISIBLE | SS_LEFTNOWORDWRAP | SS_NOPREFIX,// | WS_GROUP,
                             rc.left,
                             rc.top,
                             rc.right - rc.left,
                             rc.bottom - rc.top,
                             hWnd,
                             (HMENU)IntToPtr(MAKE_LABEL_ID(m_cItems)),
                             hModule,
                             NULL);
    if (!hwndNew)
        TraceLeaveValue(-1);

    // Save item data
    SetWindowLongPtr(hwndNew, GWLP_USERDATA, lParam);

    // Set the font
    SendMessage(hwndNew,
                WM_SETFONT,
                SendMessage(GetParent(hWnd), WM_GETFONT, 0, 0),
                0);

    // Set Z-order position just after the last checkbox. This keeps
    // tab order correct.
    if (m_cItems > 0)
    {
        hwndPrev = GetDlgItem(hWnd, MAKE_CTRL_ID(m_cItems - 1, m_cSubItems));
        SetWindowPos(hwndNew,
                     hwndPrev,
                     0, 0, 0, 0,
                     SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    }

    // Create new checkboxes
    for (LONG j = 0; j < m_cSubItems; j++)
    {
        // Build window text for the control. The text is
        // hidden, but used for accessibility. (341042)
        LPCTSTR pszCheckText = pszLabel;
        LPTSTR pszT = NULL;
        if (m_pszColumnDesc[j] &&
            FormatStringID(&pszT, hModule, IDS_FMT_CHECKLABEL, pszLabel, m_pszColumnDesc[j]))
        {
            pszCheckText = pszT;
        }

        hwndPrev = hwndNew;
        hwndNew = CreateWindowEx(WS_EX_NOPARENTNOTIFY,
                                 c_szButtonClass,
                                 pszCheckText,
                                 WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_NOTIFY | BS_FLAT | BS_AUTOCHECKBOX,
                                 m_nCheckPos[j],
                                 rc.top,
                                 m_cxCheckBox,
                                 rc.bottom - rc.top,
                                 hWnd,
                                 (HMENU)IntToPtr(MAKE_CTRL_ID(m_cItems, j + 1)),
                                 hModule,
                                 NULL);

        LocalFreeString(&pszT);

        if (!hwndNew)
        {
            while (j >= 0)
            {
                DestroyWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(m_cItems, j)));
                j--;
            }

            TraceLeaveValue(-1);
        }

        SetWindowPos(hwndNew,
                     hwndPrev,
                     0, 0, 0, 0,
                     SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    }

    // We now officially have a new item
    m_cItems++;

    //
    // The last thing is to calculate the scroll range
    //
    LONG nBottom = rc.bottom;
    GetClientRect(hWnd, &rc);

    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_RANGE | SIF_PAGE;
    si.nMin = 0;
    si.nMax = nBottom + m_rcItemLabel.top - 1;
    si.nPage = rc.bottom; // ^^^^^^^^^ extra space

    SetScrollInfo(hWnd, SB_VERT, &si, FALSE);

    TraceLeaveValue(m_cItems - 1);  // return the index of the new item
}


void
CCheckList::SetState(HWND hWnd, WORD iItem, WORD iSubItem, LONG lState)
{
    TraceEnter(TRACE_CHECKLIST, "CCheckList::SetState");
    TraceAssert(hWnd != NULL);
    TraceAssert(iItem < m_cItems);
    TraceAssert(0 < iSubItem && iSubItem <= m_cSubItems);

    HWND hwndCtrl = GetDlgItem(hWnd, MAKE_CTRL_ID(iItem, iSubItem));
    if (hwndCtrl != NULL)
    {
        SendMessage(hwndCtrl, BM_SETCHECK, lState & CLST_CHECKED, 0);
        EnableWindow(hwndCtrl, !(lState & CLST_DISABLED));
    }

    TraceLeaveVoid();
}


LONG
CCheckList::GetState(HWND hWnd, WORD iItem, WORD iSubItem)
{
    LONG lState = 0;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::GetState");
    TraceAssert(hWnd != NULL);
    TraceAssert(iItem < m_cItems);
    TraceAssert(0 < iSubItem && iSubItem <= m_cSubItems);

    HWND hwndCtrl = GetDlgItem(hWnd, MAKE_CTRL_ID(iItem, iSubItem));

    if (hwndCtrl != NULL)
    {
        lState = (LONG)SendMessage(hwndCtrl, BM_GETCHECK, 0, 0);
        TraceAssert(!(lState & BST_INDETERMINATE));

        if (!IsWindowEnabled(hwndCtrl))
            lState |= CLST_DISABLED;
    }

    TraceLeaveValue(lState);
}


void
CCheckList::SetColumnWidth(HWND hWnd, LONG cxDialog, LONG cxColumn)
{
    LONG j;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::SetColumnWidth");
    TraceAssert(hWnd != NULL);
    TraceAssert(cxColumn > 10);

    m_cxCheckColumn = cxColumn;

    if (m_cSubItems > 0)
    {
        m_nCheckPos[m_cSubItems-1] = cxDialog                       // dlg width
                                    - m_rcItemLabel.left            // right margin
                                    - (cxColumn + m_cxCheckBox)/2;  // 1/2 col & 1/2 checkbox

        for (j = m_cSubItems - 1; j > 0; j--)
            m_nCheckPos[j-1] = m_nCheckPos[j] - cxColumn;

        //              (leftmost check pos) - (horz margin)
        m_rcItemLabel.right = m_nCheckPos[0] - m_rcItemLabel.left;
    }
    else
        m_rcItemLabel.right = cxDialog - m_rcItemLabel.left;

    LONG nTop = m_rcItemLabel.top;
    LONG nBottom = m_rcItemLabel.bottom;

    for (LONG i = 0; i < m_cItems; i++)
    {
        MoveWindow(GetDlgItem(hWnd, MAKE_LABEL_ID(i)),
                   m_rcItemLabel.left,
                   nTop,
                   m_rcItemLabel.right - m_rcItemLabel.left,
                   nBottom - nTop,
                   FALSE);

        for (j = 0; j < m_cSubItems; j++)
        {
            MoveWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(i, j + 1)),
                       m_nCheckPos[j],
                       nTop,
                       m_cxCheckBox,
                       nBottom - nTop,
                       FALSE);
        }

        nTop += m_rcItemLabel.bottom;
        nBottom += m_rcItemLabel.bottom;
    }

    TraceLeaveVoid();
}


void
CCheckList::ResetContent(HWND hWnd)
{
    for (LONG i = 0; i < m_cItems; i++)
        for (LONG j = 0; j <= m_cSubItems; j++)
            DestroyWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(i, j)));

  // Hide the scroll bar
  ShowScrollBar(hWnd, SB_VERT, FALSE);
  m_cItems = 0;
}


LONG
CCheckList::GetVisibleCount(HWND hWnd)
{
    LONG nCount = 1;
    RECT rc;

    if (GetClientRect(hWnd, &rc) && m_rcItemLabel.bottom > 0)
        nCount = max(1, rc.bottom / m_rcItemLabel.bottom);

    return nCount;
}


LONG
CCheckList::GetTopIndex(HWND hWnd)
{
    LONG nIndex = 0;
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_POS;

    if (GetScrollInfo(hWnd, SB_VERT, &si) && m_rcItemLabel.bottom > 0)
        nIndex = max(0, si.nPos / m_rcItemLabel.bottom);

    return nIndex;
}


void
CCheckList::EnsureVisible(HWND hWnd, LONG nItemIndex)
{
    LONG nTopIndex = GetTopIndex(hWnd);

    // Note that the top item may only be partially visible,
    // so we need to test for equality here.  Raid #208449
    if (nItemIndex <= nTopIndex)
    {
        SetTopIndex(hWnd, nItemIndex);
    }
    else
    {
        LONG nVisible = GetVisibleCount(hWnd);

        if (nItemIndex >= nTopIndex + nVisible)
            SetTopIndex(hWnd, nItemIndex - nVisible + 1);
    }
}


void
CCheckList::DrawCheckFocusRect(HWND hWnd, HWND hwndCheck, BOOL fDraw)
{
    RECT rcCheck;
    HDC hdc;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::DrawCheckFocusRect");
    TraceAssert(hWnd != NULL);
    TraceAssert(hwndCheck != NULL);

    GetWindowRect(hwndCheck, &rcCheck);
    MapWindowPoints(NULL, hWnd, (LPPOINT)&rcCheck, 2);
    InflateRect(&rcCheck, 2, 2);    // draw *outside* the checkbox

    hdc = GetDC(hWnd);
    if (hdc)
    {
        // Always erase before drawing, since we may already be
        // partially visible and drawing is an XOR operation.
        // (Don't want to leave any turds on the screen.)

        FrameRect(hdc, &rcCheck, GetSysColorBrush(BK_COLOR));

        if (fDraw)
        {
            SetTextColor(hdc, GetSysColor(TEXT_COLOR));
            SetBkColor(hdc, GetSysColor(BK_COLOR));
            DrawFocusRect(hdc, &rcCheck);
        }

        ReleaseDC(hWnd, hdc);
    }

    TraceLeaveVoid();
}


void
CCheckList::GetColumnDescriptions(HWND hWnd)
{
    //
    // Get column descriptions for accessibility
    //
    TCHAR szDescription[MAX_PATH];
    NM_CHECKLIST nmc;
    nmc.hdr.hwndFrom = hWnd;
    nmc.hdr.idFrom = GetDlgCtrlID(hWnd);
    nmc.hdr.code = CLN_GETCOLUMNDESC;
    nmc.iItem = 0;
    nmc.dwState = 0;
    nmc.dwItemData = 0;
    nmc.cchTextMax = ARRAYSIZE(szDescription);
    nmc.pszText = szDescription;

    for (LONG j = 0; j < m_cSubItems; j++)
    {
        szDescription[0] = TEXT('\0');
        nmc.iSubItem = j+1;

        SendMessage(GetParent(hWnd),
                    WM_NOTIFY,
                    nmc.hdr.idFrom,
                    (LPARAM)&nmc);

        LocalFreeString(&m_pszColumnDesc[j]);
        if (szDescription[0])
            LocalAllocString(&m_pszColumnDesc[j], szDescription);
    }
}


LRESULT
CALLBACK
CCheckList::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    CCheckList *pThis = (CCheckList*)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    TraceEnter(TRACE_CHECKLIST, "CCheckList::WindowProc");
    TraceAssert(hWnd != NULL);

    switch (uMsg)
    {
    case WM_NCCREATE:
        pThis = new CCheckList(hWnd, (LPCREATESTRUCT)lParam);
        if (pThis != NULL)
        {
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pThis);
            lResult = TRUE;
        }
        break;

    case WM_NCDESTROY:
        delete pThis;
        break;

    case WM_COMMAND:
        TraceAssert(pThis != NULL);
        lResult = pThis->MsgCommand(hWnd,
                                    GET_WM_COMMAND_ID(wParam, lParam),
                                    GET_WM_COMMAND_CMD(wParam, lParam),
                                    GET_WM_COMMAND_HWND(wParam, lParam));
        break;

    case WM_CTLCOLORSTATIC:
        TraceAssert(pThis != NULL);
        SetBkMode((HDC)wParam, TRANSPARENT);
        SetTextColor((HDC)wParam, GetSysColor(TEXT_COLOR));
        SetBkColor((HDC)wParam, GetSysColor(BK_COLOR));
        lResult = (LRESULT)GetSysColorBrush(BK_COLOR);
        break;

    case WM_PAINT:
        TraceAssert(pThis != NULL);
        pThis->MsgPaint(hWnd, (HDC)wParam);
        break;

    case WM_VSCROLL:
        TraceAssert(pThis != NULL);
        pThis->MsgVScroll(hWnd,
                          (int)(short)GET_WM_VSCROLL_CODE(wParam, lParam),
                          (int)(short)GET_WM_VSCROLL_POS(wParam, lParam));
        break;

    case WM_MOUSEWHEEL:
        TraceAssert(pThis != NULL);
        pThis->MsgMouseWheel(hWnd,
                             LOWORD(wParam),
                             (int)(short)HIWORD(wParam));
        break;

    case WM_LBUTTONDOWN:
        TraceAssert(pThis != NULL);
        pThis->MsgButtonDown(hWnd,
                             wParam,
                             (int)(short)LOWORD(lParam),
                             (int)(short)HIWORD(lParam));
        break;

    case WM_ENABLE:
        TraceAssert(pThis != NULL);
        pThis->MsgEnable(hWnd, (BOOL)wParam);
        break;

    case WM_SETFONT:
        TraceAssert(pThis != NULL);
        {
            for (LONG i = 0; i < pThis->m_cItems; i++)
                SendDlgItemMessage(hWnd,
                                   MAKE_LABEL_ID(i),
                                   WM_SETFONT,
                                   wParam,
                                   lParam);
        }
        break;

    case WM_SIZE:
        TraceAssert(pThis != NULL);
        pThis->MsgSize(hWnd, (DWORD)wParam, LOWORD(lParam), HIWORD(lParam));
        break;

    case CLM_ADDITEM:
        TraceAssert(pThis != NULL);
        lResult = pThis->AddItem(hWnd, (LPCTSTR)wParam, lParam);
        break;

    case CLM_GETITEMCOUNT:
        TraceAssert(pThis != NULL);
        lResult = pThis->m_cItems;
        break;

    case CLM_SETSTATE:
        TraceAssert(pThis != NULL);
        pThis->SetState(hWnd, LOWORD(wParam), HIWORD(wParam), (LONG)lParam);
        break;

    case CLM_GETSTATE:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetState(hWnd, LOWORD(wParam), HIWORD(wParam));
        break;

    case CLM_SETCOLUMNWIDTH:
        TraceAssert(pThis != NULL);
        {
            RECT rc;
            LONG cxDialog;

            GetClientRect(hWnd, &rc);
            cxDialog = rc.right;

            rc.right = (LONG)lParam;
            MapDialogRect(GetParent(hWnd), &rc);

            pThis->SetColumnWidth(hWnd, cxDialog, rc.right);
        }
        break;

    case CLM_SETITEMDATA:
        TraceAssert(GET_ITEM(wParam) < (ULONG)pThis->m_cItems);
        SetWindowLongPtr(GetDlgItem(hWnd, MAKE_LABEL_ID((int)wParam)),
                         GWLP_USERDATA,
                         lParam);
        break;

    case CLM_GETITEMDATA:
        TraceAssert(GET_ITEM(wParam) < (ULONG)pThis->m_cItems);
        lResult = GetWindowLongPtr(GetDlgItem(hWnd, MAKE_LABEL_ID((int)wParam)),
                                   GWLP_USERDATA);
        break;

    case CLM_RESETCONTENT:
        TraceAssert(pThis != NULL);
        pThis->ResetContent(hWnd);
        break;

    case CLM_GETVISIBLECOUNT:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetVisibleCount(hWnd);
        break;

    case CLM_GETTOPINDEX:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetTopIndex(hWnd);
        break;

    case CLM_SETTOPINDEX:
        TraceAssert(pThis != NULL);
        pThis->SetTopIndex(hWnd, (LONG)wParam);
        break;

    case CLM_ENSUREVISIBLE:
        TraceAssert(pThis != NULL);
        pThis->EnsureVisible(hWnd, (LONG)wParam);
        break;

    //
    // Always refer to the chklist window for help. Don't pass
    // one of the child window handles here.
    //
    case WM_HELP:
        ((LPHELPINFO)lParam)->hItemHandle = hWnd;
        lResult = SendMessage(GetParent(hWnd), uMsg, wParam, lParam);
        break;
    case WM_CONTEXTMENU:
        lResult = SendMessage(GetParent(hWnd), uMsg, (WPARAM)hWnd, lParam);
        break;

    default:
        lResult = DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    TraceLeaveValue(lResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\chklist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       chklist.h
//
//  Definitions and protytypes for the checklist pseudo-control.
//
//--------------------------------------------------------------------------

#ifndef _CHKLIST_H_
#define _CHKLIST_H_

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

//
// CheckList window class name
//
#define WC_CHECKLIST        "CHECKLIST_ACLUI"

BOOL RegisterCheckListWndClass(void);


//
// CheckList check states
//
#define CLST_UNCHECKED      0   // == BST_UNCHECKED
#define CLST_CHECKED        1   // == BST_CHECKED
#define CLST_DISABLED       2   // == BST_INDETERMINATE
#define CLST_CHECKDISABLED  (CLST_CHECKED | CLST_DISABLED)

//
// CheckList window styles
//
#define CLS_1CHECK          0x0001
#define CLS_2CHECK          0x0002
//#define CLS_3CHECK          0x0003
//#define CLS_4CHECK          0x0004
#define CLS_CHECKMASK       0x000f

//
// CheckList messages
//
// row is 0-based
// column is 1-based
//
#define CLM_SETCOLUMNWIDTH  (WM_USER + 1)   // lParam = width (dlg units) of a check column (default=32)
#define CLM_ADDITEM         (WM_USER + 2)   // wParam = pszName, lParam = item data, return = row
#define CLM_GETITEMCOUNT    (WM_USER + 3)   // no parameters
#define CLM_SETSTATE        (WM_USER + 4)   // wParam = row/column, lParam = state
#define CLM_GETSTATE        (WM_USER + 5)   // wParam = row/column, return = state
#define CLM_SETITEMDATA     (WM_USER + 6)   // wParam = row, lParam = item data
#define CLM_GETITEMDATA     (WM_USER + 7)   // wParam = row, return = item data
#define CLM_RESETCONTENT    (WM_USER + 8)   // no parameters
#define CLM_GETVISIBLECOUNT (WM_USER + 9)   // no parameters, return = # of visible rows
#define CLM_GETTOPINDEX     (WM_USER + 10)  // no parameters, return = index of top row
#define CLM_SETTOPINDEX     (WM_USER + 11)  // wParam = index of new top row
#define CLM_ENSUREVISIBLE   (WM_USER + 12)  // wParam = index of item to make fully visible

//
// CheckList notification messages
//
#define CLN_FIRST           (1000U)         // commctrl use negative values
#define CLN_LAST            (1049U)
#define CLN_CLICK           (CLN_FIRST+0)   // lparam = PNM_CHECKLIST
#define CLN_GETCOLUMNDESC   (CLN_FIRST+1)

typedef struct _NM_CHECKLIST
{
    NMHDR hdr;
    int iItem;                              // row (0-based)
    int iSubItem;                           // column (1-based)
    DWORD dwState;
    DWORD_PTR dwItemData;
    ULONG cchTextMax;
    LPTSTR pszText;
} NM_CHECKLIST, *PNM_CHECKLIST;


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _CHKLIST_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\aclbloat.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       aclbloat.h
//	
//	This file contains the implementation of ACLBLOAT class which controls the 
//  dialog box for aclbloat
//
//	Author		hiteshr 4th April 2001
//
//--------------------------------------------------------------------------

#include "aclpriv.h"


//+--------------------------------------------------------------------------
//
//  Member:     CACLBloat::CACLBloat
//
//  Synopsis:   Constructor
//
//
//  History:    04-April 2001 hiteshr Created
//
//---------------------------------------------------------------------------

CACLBloat::CACLBloat(LPSECURITYINFO	psi, 
					 LPSECURITYINFO2 psi2,
					 SI_PAGE_TYPE    siPageType,
					 SI_OBJECT_INFO* psiObjectInfo,
					 HDPA hEntries,
					 HDPA hPropEntries):m_psi(psi),
										m_psi2(psi2),
										m_siPageType(siPageType),
										m_psiObjectInfo(psiObjectInfo),
										m_hEntries(hEntries),
										m_hPropEntries(hPropEntries),
										m_hMergedEntries(NULL),
										m_hFont(NULL)
{
	TraceEnter(TRACE_ACLBLOAT, "CACLBloat::CACLBloat");
	if(m_psi)
		m_psi->AddRef();
	if(m_psi2)
		m_psi2->AddRef();
}

CACLBloat::~CACLBloat()
{
	if(m_psi)
		m_psi->Release();
	if(m_psi2)
		m_psi2->Release();

	if(m_hMergedEntries)
	{
		UINT cItems = DPA_GetPtrCount(m_hMergedEntries);
		for(UINT iItems = 0; iItems < cItems; ++iItems)
		{
			delete (PACE)DPA_FastGetPtr(m_hMergedEntries, iItems);
		}
		DPA_Destroy(m_hMergedEntries);
	}

	if(m_hFont)
		DeleteObject(m_hFont);
}
//+--------------------------------------------------------------------------
//
//  Member:     CACLBloat::IsAclBloated
//
//  Synopsis:   ACL is bloated if number of entries which inherits to child objects
//				is more than 8
//
//
//  History:    04-April 2001 hiteshr Created
//
//---------------------------------------------------------------------------
BOOL
CACLBloat::IsAclBloated()
{
	TraceEnter(TRACE_ACLBLOAT, "CACLBloat::IsAclBloated");
	
	if(!m_hMergedEntries)
	{
		m_hMergedEntries = DPA_Create(4);
		if(!m_hMergedEntries)
			return FALSE;
	}

	if(SUCCEEDED(MergeAces(m_hEntries, m_hPropEntries, m_hMergedEntries)))
	{
		int cItems = DPA_GetPtrCount(m_hMergedEntries);
		if(cItems > ACL_BLOAT_LIMIT)
			return TRUE;
	}
	return FALSE;
}


//+--------------------------------------------------------------------------
//
//  Member:     CACLBloat::DoModalDialog
//
//  Synopsis:   Creates modal dialogbox
//
//  Arguments:  [hwndParent] - handle to owner window of dialog to create
//
//  Returns:    Dialog's return code
//
//  History:    04-April-2001 hiteshr Created
//
//---------------------------------------------------------------------------

BOOL
CACLBloat::DoModalDialog(HWND hwndParent)
{
	TraceEnter(TRACE_ACLBLOAT, "CACLBloat::CACLBloat");
    
	INT_PTR iResult = DialogBoxParam(::hModule,
                                     MAKEINTRESOURCE(IDD_ACLBLOAT),
                                     hwndParent,
                                     CACLBloat::_DlgProc,
			                         (LPARAM) this);
    return static_cast<BOOL>(iResult);
}


//+--------------------------------------------------------------------------
//
//  Member:     CACLBloat::_DlgProc
//
//  Synopsis:   Dialog box callback
//
//  Returns:    Dialog's return code
//
//  History:    04-April-2001 hiteshr Created
//
//---------------------------------------------------------------------------
INT_PTR CALLBACK
CACLBloat::_DlgProc(HWND hDlg,
					UINT uMsg,
					WPARAM wParam,
					LPARAM lParam)
{
    BOOL bReturn = TRUE;    
	CACLBloat *pThis = (CACLBloat *)GetWindowLongPtr(hDlg, DWLP_USER);
    if (!pThis && uMsg != WM_INITDIALOG)
    {
        return FALSE;
    }

    switch (uMsg)
    {
		case WM_INITDIALOG:
			pThis = (CACLBloat*) lParam;
			ASSERT(pThis);
			SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pThis);
			pThis->InitDlg(hDlg);
			break;

		case WM_COMMAND:
			bReturn = pThis->OnCommand(hDlg, wParam, lParam);
			break;

		case WM_NOTIFY:
			bReturn = pThis->OnNotify(hDlg, wParam, lParam);
			break;


		default:
			bReturn = FALSE;
			break;
    }
    
	return bReturn;
}

//+--------------------------------------------------------------------------
//
//  Member:     CACLBloat::InitDlg
//
//  Synopsis:   Initialize the ACL bloat dialog box
//
//
//  History:    04-April-2001 hiteshr Created
//
//---------------------------------------------------------------------------
HRESULT 
CACLBloat::InitDlg( HWND hDlg )
{    
	TraceEnter(TRACE_ACLBLOAT, "CACLBloat::CACLBloat");

	HRESULT hr = S_OK;
    
	HCURSOR     hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));


	//
    // Set up the listview control
    //		
	
	HWND        hListView = GetDlgItem( hDlg, IDC_ACEL_BLOAT );
	//
    // Set extended LV style for whole line selection with InfoTips
	//
    ListView_SetExtendedListViewStyleEx(hListView,
                                        LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP,
                                        LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP);
	//
    // Add appropriate columns
    //
	RECT        rc;
    GetClientRect(hListView, &rc);	

    LV_COLUMN col;    
    col.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.iSubItem = 0;
    col.cx = rc.right;
    ListView_InsertColumn(hListView, 0, &col);

	//
	//Add the aces to listview
	//
	hr = AddAcesFromDPA(hListView, m_hMergedEntries);
	if(FAILED(hr))
		return hr;

	//
	//Add a warning icon
	//
	// add the warning icon			
	HICON hWarn = LoadIcon(NULL, IDI_WARNING);
	SendDlgItemMessage(hDlg,  // dialog box window handle 
					   IDC_BLOAT_WARN_ICON,              // icon identifier 
					   STM_SETIMAGE,          // message to send 
					   (WPARAM) IMAGE_ICON,   // image type 
					   (LPARAM) hWarn); // icon handle 


	//
	//Set the title of dialog box
	//
    LPTSTR pszCaption = NULL;
    if(FormatStringID(&pszCaption,
					 ::hModule,
					  m_siPageType == SI_PAGE_AUDIT ? IDS_ACEE_AUDIT_TITLE : IDS_ACEE_PERM_TITLE,
					  m_psiObjectInfo->pszObjectName))
	{
		SetWindowText(hDlg, pszCaption);
		LocalFreeString(&pszCaption);
	}

	//
	//Set the warning message
	//
	UINT cItem = DPA_GetPtrCount(m_hMergedEntries);
	WCHAR buffer[34];
	_itow(cItem,buffer,10);
	if(FormatStringID(&pszCaption,
					  ::hModule,
					   m_siPageType == SI_PAGE_AUDIT ? IDS_BLOAT_AUDIT_WARN : IDS_BLOAT_PERM_WARN,
					   buffer))
	{
		SetDlgItemText(hDlg, IDC_BLOAT_LV_STATIC, pszCaption);
		LocalFreeString(&pszCaption);
	}

	//
	//Set the line 1
	//
	WCHAR szBuffer[1024];
	if(LoadString(::hModule, 
			   m_siPageType == SI_PAGE_AUDIT ? IDS_BLOAT_AUDIT_LINE1: IDS_BLOAT_PERM_LINE1,
			   szBuffer, 
			   1024))
		SetDlgItemText(hDlg,IDC_BLOAT_LINE1_STATIC, szBuffer);

	//
	//Set the line 2
	//
	if(LoadString(::hModule, 
			   m_siPageType == SI_PAGE_AUDIT ? IDS_BLOAT_AUDIT_LINE2: IDS_BLOAT_PERM_LINE2,
			   szBuffer, 
			   1024))
		SetDlgItemText(hDlg,IDC_BLOAT_LINE2_STATIC, szBuffer);

	//
	//make warning bold
	//
	MakeBold(GetDlgItem(hDlg,IDC_ACLB_WARNING), &m_hFont);

	SetCursor(hcur);
	
	return hr;
}

BOOL 
CACLBloat::OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
	LPNMHDR pnmh = (LPNMHDR)lParam;
    LPNM_LISTVIEW pnmlv = (LPNM_LISTVIEW)lParam;
    // Set default return value
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

    switch (pnmh->code)
    {

#define lvi (((NMLVDISPINFO*)lParam)->item)
		case LVN_GETDISPINFO:
		{
			PACE pAce = (PACE)lvi.lParam;
            if ((lvi.mask & LVIF_TEXT) && pAce)
            {
				if (0 == lvi.iSubItem)
                {
					lvi.pszText = pAce->GetAccessType();
				}
			}
		}
        break;
#undef lvi

	}

	return TRUE;
}


//+--------------------------------------------------------------------------
//
//  Member:     CACLBloat::MergeAces
//
//  Synopsis:   Merges the aces from Object and Property Pages in to single
//				List
//
//
//  History:    04-April-2001 hiteshr Created
//
//---------------------------------------------------------------------------

HRESULT 
CACLBloat::MergeAces(HDPA hEntries, HDPA hPropEntries, HDPA hMergedList)
{
	
	if(!hMergedList || (!hEntries && !hPropEntries))
		return E_POINTER;

	
	HRESULT hr = S_OK;
	if(hEntries)
	{
		UINT cItems = DPA_GetPtrCount(hEntries);
		for(UINT iItems = 0; iItems < cItems; ++iItems)
		{
			hr = AddAce(hMergedList,
					   (PACE_HEADER)DPA_FastGetPtr(hEntries, iItems));
			if(FAILED(hr))
				return hr;
		}
	}

	if(hPropEntries)
	{
		UINT cItems = DPA_GetPtrCount(hPropEntries);
		for(UINT iItems = 0; iItems < cItems; ++iItems)
		{
			hr = AddAce(hMergedList,
					   (PACE_HEADER)DPA_FastGetPtr(hPropEntries, iItems));
			if(FAILED(hr))
				return hr;
		}
	}
	return S_OK;
}						   

//+--------------------------------------------------------------------------
//
//  Member:     CACLBloat::AddAce
//
//  Synopsis:   Converts AceHeader to ACLUI Ace structure 
//
//
//  History:    04-April-2001 hiteshr Created
//
//---------------------------------------------------------------------------
HRESULT
CACLBloat::AddAce(HDPA hEntries, 
                  PACE_HEADER pAceHeader)
{
	//
	//This Ace doesn't propogate to child objects,
	//so we don't show this.
	//
	if(!(pAceHeader->AceFlags  & CONTAINER_INHERIT_ACE))
		return S_OK;

    PACE pAce = new CAce(pAceHeader);
    if (pAce)
    {
        return AddAce(hEntries, pAce);
    }
    else
		return E_OUTOFMEMORY;
}

//+--------------------------------------------------------------------------
//
//  Member:     CACLBloat::AddAce
//
//  Synopsis:   Add an Ace to list. First it tries to merge it with existing 
//				aces in the list.
//
//
//  History:    04-April-2001 hiteshr Created
//
//---------------------------------------------------------------------------
HRESULT 
CACLBloat::AddAce(HDPA hEntries, 
				  PACE pAceNew)
{
	TraceEnter(TRACE_ACLBLOAT, "CACLBloat::AddAce");
    TraceAssert(hEntries != NULL);
	TraceAssert(pAceNew != NULL);
    
    if (pAceNew == NULL)
        return E_POINTER;

    m_psi->MapGeneric(&pAceNew->ObjectType, &pAceNew->AceFlags, &pAceNew->Mask);

    //
    // Try to merge the new ACE with an existing entry in the list.
    //
    int cItems = DPA_GetPtrCount(hEntries);
    for( int iItems = 0; iItems < cItems; ++iItems)
    {
        PACE pAceCompare = (PACE)DPA_FastGetPtr(hEntries, iItems);

        if (pAceCompare != NULL)
        {
            switch (pAceNew->Merge(pAceCompare))
            {
            case MERGE_MODIFIED_FLAGS:
            case MERGE_MODIFIED_MASK:
                // The ACEs were merged into pAceNew.
            case MERGE_OK_1:
                //
                // The new ACE implies the existing ACE, so the existing
                // ACE can be removed.
                //
                // First copy the name so we don't have to look
                // it up again.  (Don't copy the other strings
                // since they may be different.)
                //
                // Then keep looking.  Maybe we can remove some more entries
                // before adding the new one.
                //
                DPA_DeletePtr(hEntries, iItems);
				delete pAceCompare;
                --cItems;
				--iItems;
                break;

            case MERGE_OK_2:
                //
                // The existing ACE implies the new ACE, so we don't
                // need to do anything here.
                //
                delete pAceNew;
                return S_OK;
                break;
            }
        }
    }

	DPA_AppendPtr(hEntries, pAceNew);
	return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Member:     CACLBloat::GetItemString
//
//  Synopsis:  Gets a display name for the item.
//
//
//  History:    04-April-2001 hiteshr Created
//
//---------------------------------------------------------------------------
LPCTSTR
CACLBloat::GetItemString(LPCTSTR pszItem,
						 LPTSTR pszBuffer,
                         UINT ccBuffer)
{
    TraceEnter(TRACE_ACELIST, "CACLBloat::GetItemString");

    if (pszItem == NULL)
    {
        LoadString(::hModule, IDS_SPECIAL, pszBuffer, ccBuffer);
        pszItem = pszBuffer;
    }
    else if (IS_INTRESOURCE(pszItem))
    {
        if (LoadString(m_psiObjectInfo->hInstance,
                       (UINT)((ULONG_PTR)pszItem),
                       pszBuffer,
                       ccBuffer) == 0)
        {
            LoadString(::hModule, IDS_SPECIAL, pszBuffer, ccBuffer);
        }
        pszItem = pszBuffer;
    }

    TraceLeaveValue(pszItem);
}

//+--------------------------------------------------------------------------
//
//  Member:     CACLBloat::TranslateAceIntoRights
//
//  Synopsis:  Converts Aces Mask in to a string taking into account
//			   the Object Guid.
//
//
//  History:    04-April-2001 hiteshr Created
//
//---------------------------------------------------------------------------
LPCTSTR
CACLBloat::TranslateAceIntoRights(DWORD dwMask,
                                  const GUID *pObjectType,
							      PSI_ACCESS  pAccess,
								  ULONG       cAccess)
{
    TraceEnter(TRACE_ACELIST, "CACLBloat::TranslateAceIntoRights");
    TraceAssert(pObjectType != NULL);
	if(!pAccess || !cAccess)
		return NULL;
	

	LPCTSTR     pszName = NULL;
    if (pAccess && cAccess)
    {
		//
        // Look for a name for the mask
		//
        for (UINT iItem = 0; iItem < cAccess; iItem++)
        {
            if ( dwMask == pAccess[iItem].mask &&
                 IsSameGUID(pObjectType, pAccess[iItem].pguid) )
            {
                pszName = pAccess[iItem].pszName;
                break;
            }
        }
    }

    TraceLeaveValue(pszName);
}

//+--------------------------------------------------------------------------
//
//  Member:     CACLBloat::AddAcesFromDPA
//
//  Synopsis:  Add ace from list to ListView control.
//
//
//  History:    04-April-2001 hiteshr Created
//
//---------------------------------------------------------------------------
HRESULT
CACLBloat::AddAcesFromDPA(HWND hListView, HDPA hEntries)
{
	ULONG iDefaultAccess = 0;
	PSI_ACCESS  pAccess = NULL;
    ULONG       cAccess = 0;
	HRESULT hr = S_OK;

	if(!hEntries)
		return E_POINTER;

	//
	//Get the count of items
	// 
	int cItems = DPA_GetPtrCount(hEntries);
	GUID* pGUID = NULL;

	PACE pAce = (PACE)DPA_FastGetPtr(hEntries, 0);
	if(pAce)
	{
		//
		//Get the AccessRight array for the guid
		//
		hr = m_psi->GetAccessRights(&pAce->InheritedObjectType, 
									SI_ADVANCED|SI_EDIT_EFFECTIVE, 
									&pAccess,
									&cAccess, 
									&iDefaultAccess);

		if(FAILED(hr))
			return hr;
		pGUID = &pAce->InheritedObjectType;
	}

    for( int iItem = 0; iItem < cItems; ++iItem)
    {
		pAce = (PACE)DPA_FastGetPtr(hEntries, iItem);
		if(pAce)
		{
			if(!IsSameGUID(pGUID, &pAce->InheritedObjectType))
			{
				//
				//if Guid is not same as one for which we have access right info,
				//fetch access right info for new guid
				//
				hr = m_psi->GetAccessRights(&pAce->InheritedObjectType, 
											SI_ADVANCED | SI_EDIT_EFFECTIVE, 
											&pAccess,
											&cAccess, 
											&iDefaultAccess);

				if(FAILED(hr))
					return hr;
				pGUID = &pAce->InheritedObjectType;
			}
	
			TCHAR   szBuffer[MAX_COLUMN_CHARS];
		    LPCTSTR pszRights = NULL;
		    pszRights = TranslateAceIntoRights(pAce->Mask,
											   &pAce->ObjectType,
											   pAccess,
											   cAccess);

			//
			// If this is a property ACE, give it a name like "Read property" or
			// "Write property".  Also, remember that it's a property ACE so we
			// can show the Property page first when editing this ACE.
			//
			// This is a bit slimy, since it assumes DS property access bits are
			// the only ones that will ever be used on the properties page.
			//
			if ((m_psiObjectInfo->dwFlags & SI_EDIT_PROPERTIES) &&
				(pAce->Flags & ACE_OBJECT_TYPE_PRESENT) &&
				(pAce->Mask & (ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP)) &&
				!(pAce->Mask & ~(ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP)))
			{
				pAce->SetPropertyAce(TRUE);

				if (pszRights == NULL)
				{
					UINT idString = 0;

					switch (pAce->Mask & (ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP))
					{
					case ACTRL_DS_READ_PROP:
						idString = IDS_READ_PROP;
						break;

					case ACTRL_DS_WRITE_PROP:
						idString = IDS_WRITE_PROP;
						break;

					case (ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP):
						idString = IDS_READ_WRITE_PROP;
						break;
					}

					if (idString)
					{
						LoadString(::hModule, idString, szBuffer, ARRAYSIZE(szBuffer));
						pszRights = szBuffer;
					}
				}
			}

			pszRights = GetItemString(pszRights, szBuffer, ARRAYSIZE(szBuffer));
			pAce->SetAccessType(pszRights);
		    
			LV_ITEM lvi;
			lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
			lvi.state = 0;
			lvi.stateMask = LVIS_CUT;
			lvi.iItem = iItem;
			lvi.iSubItem = 0;
			lvi.pszText = LPSTR_TEXTCALLBACK;
			lvi.lParam = (LPARAM)pAce;

			//
			// insert the item into the list
			//
			iItem = ListView_InsertItem(hListView, &lvi);

			if (iItem == -1)
				delete pAce;


		}
	}
	return hr;
}


BOOL
CACLBloat::OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = TRUE;

    switch (LOWORD(wParam))
    {
    case IDOK:
        EndDialog(hDlg, FALSE);
        break;

    case IDCANCEL:
        EndDialog(hDlg, TRUE);
        break;

	case IDHELP:
		HtmlHelp(NULL,					
				 L"aclui.chm::/ACLUI_acl_BP.htm",
				 HH_DISPLAY_TOPIC,
				 0);
		break;
		
    default:
        fHandled = FALSE;
        break;
    }
    return fHandled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\cstrings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cstrings.cpp
//
//  Constant strings used by this module
//
//--------------------------------------------------------------------------

#include "aclpriv.h"

TCHAR const c_szDllName[]           = TEXT("aclui.dll");
TCHAR const c_szAcluiHelpFile[]     = TEXT("aclui.hlp");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\aclpriv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       aclpriv.h
//
//--------------------------------------------------------------------------

#ifndef _ACLUI_
#define _ACLUI_

#ifndef UNICODE
#error "No ANSI support yet"
#endif

// For test building NT4
//#undef _WIN32_WINNT
//#define _WIN32_WINNT 0x0400
//BOOL WINAPI ConvertSidToStringSid(PSID pSid, LPTSTR *ppszStringSid);

extern "C"
{
    #include <nt.h>         // SE_TAKE_OWNERSHIP_PRIVILEGE, etc
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <seopaque.h>   // RtlObjectAceSid, etc.
}

#define INC_OLE2
#include <windows.h>
#include <commctrl.h>
#include "resource.h"   // resource ID's
#include "idh.h"        // help ID's

#ifndef RC_INVOKED

#include <windowsx.h>
#include <atlconv.h>    // ANSI/Unicode conversion support
#include <shlobj.h>
#include <shfusion.h>
#include <accctrl.h>
#include <aclui.h>
#include <comctrlp.h>   // DPA/DSA
#if(_WIN32_WINNT >= 0x0500)
#include <objsel.h>     // DS Object Picker
#else
typedef IUnknown IDsObjectPicker;  // dummy placeholder
#endif
#include <htmlhelp.h>
#include <common.h>
#include "misc.h"
#include "pagebase.h"
#include "chklist.h"
#include "ace.h"
#include "perm.h"
#include "cstrings.h"
#include "sidcache.h"
#include "aclbloat.h"
// These are here for NT4 SP4 builds (comctrlp.h added these for NT5)
#ifndef DA_LAST
#define DA_LAST     (0x7FFFFFFF)
#endif
#ifndef DPA_AppendPtr
#define DPA_AppendPtr(hdpa, pitem)  DPA_InsertPtr(hdpa, DA_LAST, pitem)
#endif
#ifndef DSA_AppendItem
#define DSA_AppendItem(hdsa, pitem) DSA_InsertItem(hdsa, DA_LAST, pitem)
#endif

extern HINSTANCE hModule;
extern HINSTANCE g_hGetUserLib;
extern UINT UM_SIDLOOKUPCOMPLETE;
extern UINT g_cfDsSelectionList;
extern UINT g_cfSidInfoList;

// Magic debug flags
#define TRACE_PERMPAGE      0x00000001
#define TRACE_PRINCIPAL     0x00000002
#define TRACE_SI            0x00000004
#define TRACE_PERMSET       0x00000008
#define TRACE_ACELIST       0x00000010
#define TRACE_ACEEDIT       0x00000020
#define TRACE_OWNER         0x00000040
#define TRACE_MISC          0x00000080
#define TRACE_CHECKLIST     0x00000100
#define TRACE_SIDCACHE      0x00000200
#define TRACE_EFFPERM       0x00000400
#define TRACE_ACLBLOAT		0x00000800
#define TRACE_ALWAYS        0xffffffff          // use with caution

#define MAX_COLUMN_CHARS    100

#define COLUMN_ALLOW    1
#define COLUMN_DENY     2

#define ACE_INHERIT_ALL     (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE)

#define SI_ACCESS_CUSTOM   0x10000000  //This flag is used is SI_ACCESS to indicate
                                       //Custom checkbox which comes in first screen for 
                                       //custom permission

#define ACL_BLOAT_LIMIT 8


BOOL
ACLUIAPI
EditSecurityEx(HWND hwndOwner,
               LPSECURITYINFO psi,
               PPERMPAGE pPermPage,
               UINT nStartPage);

BOOL
EditACEEntry(HWND hwndOwner,
             LPSECURITYINFO psi,
             PACE pAce,
             SI_PAGE_TYPE siType,
             LPCTSTR pszObjectName,
             BOOL bReadOnly,
             DWORD *pdwResult,
             HDPA *phEntries,
             HDPA *phPropertyEntries,
             UINT nStartPage = 0);

// EditACEEntry result values. Set if something was edited on the
// corresponding page, otherwise clear.
#define EAE_NEW_OBJECT_ACE      0x0001
#define EAE_NEW_PROPERTY_ACE    0x0002

LPARAM
GetSelectedItemData(HWND hList, int *pIndex);

int
ConfirmAclProtect(HWND hwndParent, BOOL bDacl);

HPROPSHEETPAGE
CreateOwnerPage(LPSECURITYINFO psi, SI_OBJECT_INFO *psiObjectInfo);

HPROPSHEETPAGE
CreateEffectivePermPage(LPSECURITYINFO psi,SI_OBJECT_INFO *psiObjectInfo);


STDMETHODIMP
_InitCheckList(HWND           hwndList,
               LPSECURITYINFO psi,
               const GUID *   pguidObjectType,
               DWORD          dwFlags,
               HINSTANCE      hInstance,
               DWORD          dwType,
               PSI_ACCESS *   ppDefaultAccess);

void
HandleListClick(PNM_CHECKLIST pnmc, 
                SI_PAGE_TYPE siType, 
                BOOL bContainerFlags, 
                HDSA * phAllowUncheckedAccess= NULL,
                HDSA * phDenyUncheckedAccess= NULL,
                BOOL bCustomPresent = FALSE);

UINT
GetAcesFromCheckList(HWND hChkList,
                     PSID pSid,
                     BOOL fPerm,
                     BOOL fAceFlagsProvided,
                     UCHAR uAceFlagsNew,
                     const GUID *pInheritGUID,
                     HDPA hEntries);

typedef struct _col_for_listview
{
    UINT    idText;     // Resource Id for column name
    UINT    iPercent;   // Percent of width
} COL_FOR_LV;


#endif // RC_INVOKED
#endif // _ACLUI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\acelist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       acelist.cpp
//
//  This file contains the implementation for the advanced ACE list editor
//  permission and auditing pages.
//
//--------------------------------------------------------------------------

#include "aclpriv.h"
#include <accctrl.h>
//Functions selects an Item in ListView. It first 
//Clears all exisiting selections
VOID 
SelectSingleItemInLV( HWND hListView, INT iSelected )
{
    INT cCount = ListView_GetItemCount( hListView );
    for( INT i = 0; i < cCount; ++i )
        ListView_SetItemState( hListView, 
                              i, 
                              0, 
                              LVIS_SELECTED | LVIS_FOCUSED );

    //Now select the iSelected
    ListView_SetItemState( hListView, 
                          iSelected, 
                          LVIS_SELECTED | LVIS_FOCUSED, 
                          LVIS_SELECTED | LVIS_FOCUSED );
    return;



}

//This function checks if any of the aces selected in the listbox
//is of type 
//type = fAppliedDirect ? Applied Directly on this object :
//                        Inhereted from parent  
BOOL AnySelectedAceofType( HWND hListView, BOOL fAppliedDirect )
{
    LVITEM lvi = {0};
    UINT cSelectedCount = 0;  //Number of item selected in listbox
    lvi.iItem    = -1;
    lvi.mask     = LVIF_PARAM;
    lvi.iSubItem = 0;

    cSelectedCount = ListView_GetSelectedCount(hListView);                     
    
    while( cSelectedCount-- )
    {
        lvi.iItem = ListView_GetNextItem(hListView, lvi.iItem, LVNI_SELECTED);

        if (lvi.iItem != -1)
        {
            lvi.lParam   = NULL;

            ListView_GetItem(hListView, &lvi);
            if( fAppliedDirect && ( (((PACE)lvi.lParam)->AceFlags & INHERITED_ACE) == 0 ) )
                return TRUE;
            if( !fAppliedDirect && ((PACE)lvi.lParam)->AceFlags & INHERITED_ACE )
                return TRUE;

        }
    }
    return FALSE;
}


LPARAM
GetSelectedItemData(HWND hListView, int *pIndex)
{
    int iSelected = ListView_GetNextItem(hListView, -1, LVNI_SELECTED);

    if (iSelected == -1)
        return NULL;

    if (pIndex)
        *pIndex = iSelected;

    LV_ITEM lvi;

    lvi.mask     = LVIF_PARAM;
    lvi.iItem    = iSelected;
    lvi.iSubItem = 0;
    lvi.lParam   = NULL;

    ListView_GetItem(hListView, &lvi);

    return lvi.lParam;
}


void
SelectListViewItem(HWND hListView, int iSelected)
{
    ListView_SetItemState(hListView,
                          iSelected,
                          LVIS_SELECTED | LVIS_FOCUSED,
                          LVIS_SELECTED | LVIS_FOCUSED);
    ListView_EnsureVisible(hListView, iSelected, FALSE);
}

void
EnsureListViewSelectionIsVisible(HWND hListView)
{
    int iSelected = ListView_GetNextItem(hListView, -1, LVNI_SELECTED);
    if (-1 != iSelected)
        ListView_EnsureVisible(hListView, iSelected, FALSE);
}


INT_PTR
_ConfirmAclProtectProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        Static_SetIcon(GetDlgItem(hDlg, IDC_CONFIRM_ICON), LoadIcon(NULL, IDI_QUESTION));
        return TRUE;

    case WM_COMMAND:
        if (BN_CLICKED == GET_WM_COMMAND_CMD(wParam, lParam))
        {
            EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
            return TRUE;
        }
        break;
    }
    return FALSE;
}

int
ConfirmAclProtect(HWND hwndParent, BOOL bDacl)
{
    return (int)DialogBox(::hModule,
                          MAKEINTRESOURCE(bDacl ? IDD_CONFIRM_DACL_PROTECT : IDD_CONFIRM_SACL_PROTECT),
                          hwndParent,
                          _ConfirmAclProtectProc);
}


//
//  Context Help IDs.
//
const static DWORD aAceListPermHelpIDs[] =
{
    IDC_ACEL_DETAILS,           IDH_ACEL_PERM_DETAILS,
    IDC_ACEL_ADD,               IDH_ACEL_PERM_ADD,
    IDC_ACEL_REMOVE,            IDH_ACEL_PERM_REMOVE,
    IDC_ACEL_EDIT,              IDH_ACEL_PERM_EDIT,
    IDC_ACEL_RESET,             IDH_ACEL_PERM_RESET,
    IDC_ACEL_DEFAULT_STATIC,         IDH_ACEL_PERM_RESET,
    IDC_ACEL_PROTECT,           IDH_ACEL_PERM_PROTECT,
    IDC_ACEL_DESCRIPTION,       IDH_NOHELP,
    IDC_ACEL_RESET_ACL_TREE,    IDH_ACEL_PERM_RESET_ACL_TREE,
    IDC_ACEL_STATIC,            -1,    
    0, 0
};

const static DWORD aAceListAuditHelpIDs[] =
{
    IDC_ACEL_DETAILS,           IDH_ACEL_AUDIT_DETAILS,
    IDC_ACEL_ADD,               IDH_ACEL_AUDIT_ADD,
    IDC_ACEL_REMOVE,            IDH_ACEL_AUDIT_REMOVE,
    IDC_ACEL_EDIT,              IDH_ACEL_AUDIT_EDIT,
    IDC_ACEL_RESET,             IDH_ACEL_AUDIT_RESET,
    IDC_ACEL_DEFAULT_STATIC,    IDH_ACEL_AUDIT_RESET,
    IDC_ACEL_PROTECT,           IDH_ACEL_AUDIT_PROTECT,
    IDC_ACEL_DESCRIPTION,       IDH_NOHELP,
    IDC_ACEL_RESET_ACL_TREE,    IDH_ACEL_AUDIT_RESET_ACL_TREE,
    IDC_ACEL_STATIC,            -1,
    0, 0
};


class CAdvancedListPage : public CSecurityPage
{
private:
    PSI_ACCESS          m_pAccess;
    ULONG               m_cAccesses;
    PSI_INHERIT_TYPE    m_pInheritType;
    ULONG               m_cInheritTypes;
    int                 m_iLastColumnClick;
    int                 m_iSortDirection;
    BOOL                m_fPageDirty:1;
    BOOL                m_bReadOnly:1;
    BOOL                m_bAuditPolicyOK:1;
    BOOL                m_bWasDenyAcl:1;
	DWORD				m_cInheritableAces;

public:
    CAdvancedListPage( LPSECURITYINFO psi, SI_PAGE_TYPE siType )
        : CSecurityPage(psi, siType), 
		  m_iLastColumnClick(-1), 
		  m_iSortDirection(1),
	      m_cInheritableAces(0){}

private:
    virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    PACL GetACL(PSECURITY_DESCRIPTOR *ppSD, LPBOOL pbProtected, BOOL bDefault);
    void FillAceList(HWND hListView, PACL pAcl, BOOL bSortList = TRUE);
    void InitDlg( HWND hDlg );
    int AddAce(HWND hListView, PACE_HEADER pAceHeader, int iRow, LPCTSTR pszInheritSource, int level);
    int AddAce(HWND hListView, PACE pAce, int iRow, LPCTSTR pszInheritSource, int level);
    LPCTSTR TranslateAceIntoRights(DWORD dwAceFlags,
                                   DWORD dwMask,
                                   const GUID *pObjectType,
                                   const GUID *pInheritedObjectType,
                                   LPCTSTR *ppszInheritType);
    LPCTSTR GetItemString(LPCTSTR pszItem, LPTSTR pszBuffer, UINT ccBuffer);
    void UpdateButtons(HWND hDlg);
    void BuildAcl(HWND hListView,
                  PACL *ppAcl);
    HRESULT ApplyAudits(HWND hDlg, HWND hListView, BOOL fProtected);
    HRESULT ApplyPermissions(HWND hDlg, HWND hListView, BOOL fProtected);
    void OnApply(HWND hDlg, BOOL bClose);
    void OnAdd(HWND hDlg);
    void OnRemove(HWND hDlg);
    void OnReset(HWND hDlg);
    void OnProtect(HWND hDlg);
    void OnEdit(HWND hDlg);
    int AddAcesFromDPA(HWND hListView, HDPA hEntries, int iSelected);
    void EditAce(HWND hDlg, PACE pAce, BOOL bDeleteSelection, LONG iSelected = MAXLONG);
    void CheckAuditPolicy(HWND hwndOwner);
};
typedef CAdvancedListPage *PADVANCEDLISTPAGE;


int CALLBACK
AceListCompareProc(LPARAM lParam1,
                   LPARAM lParam2,
                   LPARAM lParamSort)
{
    int iResult = 0;
    PACE pAce1 = (PACE)lParam1;
    PACE pAce2 = (PACE)lParam2;
    short iColumn = LOWORD(lParamSort);
    short iSortDirection = HIWORD(lParamSort);
    LPTSTR psz1 = NULL;
    LPTSTR psz2 = NULL;

    TraceEnter(TRACE_ACELIST, "AceListCompareProc");

    if (iSortDirection == 0)
        iSortDirection = 1;

    if (pAce1 && pAce2)
    {
        switch (iColumn)
        {
        case 0:
            psz1 = pAce1->GetType();
            psz2 = pAce2->GetType();
            break;                
        case 1:
            psz1 = pAce1->GetName();
            psz2 = pAce2->GetName();
            break;

        case 2:
            psz1 = pAce1->GetAccessType();
            psz2 = pAce2->GetAccessType();
            break;

        case 3:
            psz1 = pAce1->GetInheritSourceName();
            psz2 = pAce2->GetInheritSourceName();
            break;
        case 4:
            psz1 = pAce1->GetInheritType();
            psz2 = pAce2->GetInheritType();
            break;
        }

        if (iResult == 0 && psz1 && psz2)
        {
            iResult = CompareString(LOCALE_USER_DEFAULT, 0, psz1, -1, psz2, -1) - 2;
        }

        iResult *= iSortDirection;
    }

    TraceLeaveValue(iResult);
}

//
//This function is used for cannonical sorting of the list
//
int CALLBACK
AceListCompareProcCanno(LPARAM lParam1,
                   LPARAM lParam2,
                   LPARAM lParamSort)
{
    int iResult = 0;
    PACE pAce1 = (PACE)lParam1;
    PACE pAce2 = (PACE)lParam2;
    short iColumn = LOWORD(lParamSort);
    short iSortDirection = HIWORD(lParamSort);
    LPTSTR psz1 = NULL;
    LPTSTR psz2 = NULL;

    TraceEnter(TRACE_ACELIST, "AceListCompareProc");

    if (iSortDirection == 0)
        iSortDirection = 1;

    if (pAce1 && pAce2)
    {
        switch (iColumn)
        {
        case 0:
            iResult = pAce1->CompareType(pAce2);
        // Fall through and use the name to differentiate ACEs of the same type
        case 1:
            psz1 = pAce1->GetName();
            psz2 = pAce2->GetName();
            break;

        }

        if (iResult == 0 && psz1 && psz2)
        {
            iResult = CompareString(LOCALE_USER_DEFAULT, 0, psz1, -1, psz2, -1) - 2;
        }

        iResult *= iSortDirection;
    }

    TraceLeaveValue(iResult);
}


//
// CAdvancedListPage implementation
//
LPCTSTR
CAdvancedListPage::TranslateAceIntoRights(DWORD dwAceFlags,
                                          DWORD dwMask,
                                          const GUID *pObjectType,
                                          const GUID *pInheritedObjectType,
                                          LPCTSTR *ppszInheritType)
{
    LPCTSTR     pszName = NULL;
    PSI_ACCESS  pAccess = m_pAccess;
    ULONG       cAccess = m_cAccesses;
    UINT        iItem;

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::TranslateAceIntoRights");
    TraceAssert(pObjectType != NULL);
    TraceAssert(pInheritedObjectType != NULL);
    TraceAssert(!m_bAbortPage);

    // If this ACE applies to a different object type, ask the client
    // for the appropriate SI_ACCESS list.
    if ((m_siObjectInfo.dwFlags & SI_OBJECT_GUID)
        && !IsNullGUID(pInheritedObjectType)
        && !IsSameGUID(pInheritedObjectType, &m_siObjectInfo.guidObjectType))
    {
        ULONG iDefaultAccess;
        DWORD dwFlags = SI_ADVANCED;
        if (m_siPageType == SI_PAGE_AUDIT)
            dwFlags |= SI_EDIT_AUDITS;
        if (FAILED(m_psi->GetAccessRights(pInheritedObjectType,
                                          dwFlags,
                                          &pAccess,
                                          &cAccess,
                                          &iDefaultAccess)))
        {
            pAccess = m_pAccess;
            cAccess = m_cAccesses;
        }
    }

    if (pAccess && cAccess)
    {
        // Look for a name for the mask
        for (iItem = 0; iItem < cAccess; iItem++)
        {
            if ( dwMask == pAccess[iItem].mask &&
                 IsSameGUID(pObjectType, pAccess[iItem].pguid) )
            {
                pszName = pAccess[iItem].pszName;
                break;
            }
        }
    }

    // Look for a name for the inheritance type
    if ((m_siObjectInfo.dwFlags & SI_CONTAINER) && ppszInheritType)
    {
        // Check these inherit bits for a match
        DWORD dwInheritMask = INHERIT_ONLY_ACE | ACE_INHERIT_ALL;

        // Don't check INHERIT_ONLY_ACE if the ACE inherit type
        // matches the current object
        if ((m_siObjectInfo.dwFlags & SI_OBJECT_GUID) &&
            IsSameGUID(&m_siObjectInfo.guidObjectType, pInheritedObjectType))
        {
            dwInheritMask &= ~INHERIT_ONLY_ACE;
        }

        *ppszInheritType = NULL;

        for (iItem = 0; iItem < m_cInheritTypes; iItem++)
        {
            if ((m_pInheritType[iItem].dwFlags & dwInheritMask) == (ULONG)(dwAceFlags & dwInheritMask)
                && IsSameGUID(pInheritedObjectType, m_pInheritType[iItem].pguid))
            {
                *ppszInheritType = m_pInheritType[iItem].pszName;
                break;
            }
        }
    }

    TraceLeaveValue(pszName);
}


LPCTSTR
CAdvancedListPage::GetItemString(LPCTSTR pszItem,
                                 LPTSTR pszBuffer,
                                 UINT ccBuffer)
{
    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::GetItemString");

    if (pszItem == NULL)
    {
        LoadString(::hModule, IDS_SPECIAL, pszBuffer, ccBuffer);
        pszItem = pszBuffer;
    }
    else if (IS_INTRESOURCE(pszItem))
    {
        if (LoadString(m_siObjectInfo.hInstance,
                       (UINT)((ULONG_PTR)pszItem),
                       pszBuffer,
                       ccBuffer) == 0)
        {
            LoadString(::hModule, IDS_SPECIAL, pszBuffer, ccBuffer);
        }
        pszItem = pszBuffer;
    }

    TraceLeaveValue(pszItem);
}


int
CAdvancedListPage::AddAce(HWND hListView, 
                          PACE_HEADER pAceHeader, 
                          int iRow, 
                          LPCTSTR pszInheritSource,
                          int level)
{
    PACE pAce = new CAce(pAceHeader);
    if (pAce)
    {
        iRow = AddAce(hListView, pAce, iRow,pszInheritSource, level);
    }
    return iRow;
}

int
CAdvancedListPage::AddAce(HWND hListView, PACE pAceNew, int iRow,LPCTSTR pszInheritSource, int level)
{
    PACE    pAceCompare;
    TCHAR   szBuffer[MAX_COLUMN_CHARS];
    LPCTSTR pszInheritType;
    LPCTSTR pszRights;
    LV_ITEM lvi;
    UINT    id = IDS_UNKNOWN;
    int     iItem;
    int     cItems;

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::AddAce");
    TraceAssert(hListView != NULL);
    TraceAssert(!m_bAbortPage);

    if (pAceNew == NULL)
        TraceLeaveValue(-1);

    pAceNew->SetInheritSourceInfo(pszInheritSource, level);
    m_psi->MapGeneric(&pAceNew->ObjectType, &pAceNew->AceFlags, &pAceNew->Mask);

    //
    // Try to merge the new ACE with an existing entry in the list.
    //
    cItems = ListView_GetItemCount(hListView);
    lvi.iSubItem = 0;
    lvi.mask = LVIF_PARAM;

    while (cItems > 0)
    {
        --cItems;
        lvi.iItem = cItems;

        ListView_GetItem(hListView, &lvi);
        pAceCompare = (PACE)lvi.lParam;

        if (pAceCompare != NULL)
        {
            switch (pAceNew->Merge(pAceCompare))
            {
            case MERGE_MODIFIED_FLAGS:
            case MERGE_MODIFIED_MASK:
                // The ACEs were merged into pAceNew.
            case MERGE_OK_1:
                //
                // The new ACE implies the existing ACE, so the existing
                // ACE can be removed.
                //
                // First copy the name so we don't have to look
                // it up again.  (Don't copy the other strings
                // since they may be different.)
                //
                // Then keep looking.  Maybe we can remove some more entries
                // before adding the new one.
                //
                if (pAceNew->GetName() == NULL)
                    pAceNew->SetName(pAceCompare->GetName());
                ListView_DeleteItem(hListView, cItems);
                iRow = cItems;  // try to insert here
                break;

            case MERGE_OK_2:
                //
                // The existing ACE implies the new ACE, so we don't
                // need to do anything here.
                //
                delete pAceNew;
                TraceLeaveValue(cItems);
                break;
            }
        }
    }


    //
    // Make sure we have a name for the SID.
    //
    pAceNew->LookupName(m_siObjectInfo.pszServerName, m_psi2);

    //
    // Get the Access Type and Inherit Type strings
    //
    pszRights = TranslateAceIntoRights(pAceNew->AceFlags,
                                       pAceNew->Mask,
                                       &pAceNew->ObjectType,
                                       &pAceNew->InheritedObjectType,
                                       &pszInheritType);

    //
    // If this is a property ACE, give it a name like "Read property" or
    // "Write property".  Also, remember that it's a property ACE so we
    // can show the Property page first when editing this ACE.
    //
    // This is a bit slimy, since it assumes DS property access bits are
    // the only ones that will ever be used on the properties page.
    //
    if ((m_siObjectInfo.dwFlags & SI_EDIT_PROPERTIES) &&
        (pAceNew->Flags & ACE_OBJECT_TYPE_PRESENT) &&
        (pAceNew->Mask & (ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP)) &&
        !(pAceNew->Mask & ~(ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP)))
    {
        pAceNew->SetPropertyAce(TRUE);

        if (pszRights == NULL)
        {
            UINT idString = 0;

            switch (pAceNew->Mask & (ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP))
            {
            case ACTRL_DS_READ_PROP:
                idString = IDS_READ_PROP;
                break;

            case ACTRL_DS_WRITE_PROP:
                idString = IDS_WRITE_PROP;
                break;

            case (ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP):
                idString = IDS_READ_WRITE_PROP;
                break;
            }

            if (idString)
            {
                LoadString(::hModule, idString, szBuffer, ARRAYSIZE(szBuffer));
                pszRights = szBuffer;
            }
        }
    }

    pszRights = GetItemString(pszRights, szBuffer, ARRAYSIZE(szBuffer));
    pAceNew->SetAccessType(pszRights);

    if (m_siObjectInfo.dwFlags & SI_CONTAINER)
    {
        pszInheritType = GetItemString(pszInheritType,
                                       szBuffer,
                                       ARRAYSIZE(szBuffer));
        pAceNew->SetInheritType(pszInheritType);
    }

    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
    lvi.state = 0;
    lvi.stateMask = LVIS_CUT;
    lvi.iItem = iRow;
    lvi.iSubItem = 0;
    lvi.pszText = LPSTR_TEXTCALLBACK;
    lvi.lParam = (LPARAM)pAceNew;

    if (pAceNew->AceFlags & INHERITED_ACE)
    {
#ifdef USE_OVERLAY_IMAGE
        lvi.state = LVIS_CUT | INDEXTOOVERLAYMASK(1);
#else
        lvi.state = LVIS_CUT;
#endif
    }


    //
    // Get the string ID for the Type column
    //
    if (m_siPageType == SI_PAGE_ADVPERM)
    {
        switch(pAceNew->AceType)
        {
            case ACCESS_ALLOWED_ACE_TYPE:
            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                id = IDS_ALLOW;
                break;

            case ACCESS_DENIED_ACE_TYPE:
            case ACCESS_DENIED_OBJECT_ACE_TYPE:
                id = IDS_DENY;
                break;

            case SYSTEM_AUDIT_ACE_TYPE:
            case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                id = IDS_AUDIT;
                break;

            case SYSTEM_ALARM_ACE_TYPE:
            case SYSTEM_ALARM_OBJECT_ACE_TYPE:
                id = IDS_ALARM;
                break;
        }
    }
    else
    {

        switch(pAceNew->AceFlags & (SUCCESSFUL_ACCESS_ACE_FLAG|FAILED_ACCESS_ACE_FLAG))
        {
            case SUCCESSFUL_ACCESS_ACE_FLAG:
                id = IDS_AUDITPASS;
                break;

            case FAILED_ACCESS_ACE_FLAG:
                id = IDS_AUDITFAIL;
                break;

            case SUCCESSFUL_ACCESS_ACE_FLAG | FAILED_ACCESS_ACE_FLAG:
                id = IDS_AUDITBOTH;
                break;
        }
    }

    // Load the Type string
    LoadString(::hModule, id, szBuffer, ARRAYSIZE(szBuffer));
    pAceNew->SetType(szBuffer);

    //
    // Finally, insert the item into the list
    //
    iItem = ListView_InsertItem(hListView, &lvi);

    if (iItem == -1)
        delete pAceNew;

    TraceLeaveValue(iItem);
}


void
CAdvancedListPage::UpdateButtons( HWND hDlg )
{
    HWND hListView;
    BOOL fEnableButtons = FALSE;
    LVITEM lvi = {0};
    UINT cSelectedCount = 0;  //Number of item selected in listbox

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::UpdateButtons");

    hListView = GetDlgItem(hDlg, IDC_ACEL_DETAILS);
    cSelectedCount = ListView_GetSelectedCount(hListView);

    if (!m_bAbortPage)
    {
        //If SelectedCount > 1, disable View\Edit button
        if( cSelectedCount <= 1 )
        {                       
            lvi.iItem = ListView_GetNextItem(hListView, -1, LVNI_SELECTED);

            // Decide whether or not to enable edit button and decide what description
            // to display for the ACE
            if (lvi.iItem != -1)
                fEnableButtons = TRUE;
        }

        HWND hwndEdit = GetDlgItem(hDlg, IDC_ACEL_EDIT);

        // If we're disabling the edit button, make sure it doesn't have
        // focus or keyboard access gets hosed.
        if (!fEnableButtons && GetFocus() == hwndEdit)
            SetFocus(hListView);

        EnableWindow(hwndEdit, fEnableButtons);
    }

    if (m_bReadOnly)
    {
        const int idDisable[] =
        {
            IDC_ACEL_ADD,
            IDC_ACEL_REMOVE,
            IDC_ACEL_RESET,
            IDC_ACEL_PROTECT,
            IDC_ACEL_RESET_ACL_TREE,
        };
        for (int i = 0; i < ARRAYSIZE(idDisable); i++)
            EnableWindow(GetDlgItem(hDlg, idDisable[i]), FALSE);
    }
    else
    {
        // The Remove button is enabled if any selected ace is direct
        if ( AnySelectedAceofType( hListView, TRUE ) )
            fEnableButtons = TRUE;
        else
            fEnableButtons = FALSE;

        HWND hwndRemove = GetDlgItem(hDlg, IDC_ACEL_REMOVE);

        // If we're disabling the remove button, make sure it doesn't have
        // focus or keyboard access gets hosed.
        if (!fEnableButtons && GetFocus() == hwndRemove)
            SetFocus(hListView);

        EnableWindow(hwndRemove, fEnableButtons);
    }

    TraceLeaveVoid();
}


PACL
CAdvancedListPage::GetACL(PSECURITY_DESCRIPTOR *ppSD, LPBOOL pbProtected, BOOL bDefault)
{
    PACL pAcl = NULL;
    SECURITY_DESCRIPTOR_CONTROL sdControl = 0;
    DWORD dwRevision;
    BOOL bPresent;
    HRESULT hr;

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::GetACL");
    TraceAssert(ppSD != NULL);
    TraceAssert(pbProtected != NULL);
    TraceAssert(m_psi != NULL);
    TraceAssert(!m_bAbortPage);


    *pbProtected = FALSE;

    if (m_siPageType == SI_PAGE_ADVPERM)
    {
        hr = m_psi->GetSecurity(DACL_SECURITY_INFORMATION, ppSD, bDefault);

        if (SUCCEEDED(hr) && *ppSD != NULL)
        {
            GetSecurityDescriptorControl(*ppSD, &sdControl, &dwRevision);
            *pbProtected = ((sdControl & SE_DACL_PROTECTED) != 0);
            GetSecurityDescriptorDacl(*ppSD, &bPresent, &pAcl, &bDefault);
        }
    }
    else
    {
        DWORD dwPriv = SE_SECURITY_PRIVILEGE;
        HANDLE hToken = EnablePrivileges(&dwPriv, 1);

        hr = m_psi->GetSecurity(SACL_SECURITY_INFORMATION, ppSD, bDefault);

        ReleasePrivileges(hToken);

        if (SUCCEEDED(hr))
        {
            if (*ppSD != NULL)
            {
                GetSecurityDescriptorControl(*ppSD, &sdControl, &dwRevision);
                *pbProtected = ((sdControl & SE_SACL_PROTECTED) != 0);
                GetSecurityDescriptorSacl(*ppSD, &bPresent, &pAcl, &bDefault);
            }
        }
        else
        {
            // If we can't read the SACL, we can't write it either
            m_bReadOnly = TRUE;
        }
    }

	//Get the count of inheritable aces
	m_cInheritableAces = GetCountOfInheritableAces(pAcl);


    TraceLeaveValue(pAcl);
}


void
CAdvancedListPage::FillAceList(HWND hListView, PACL pAcl, BOOL bSortList)
{
    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::FillAceList");
    TraceAssert(!m_bAbortPage);
    
    //
    // Enumerate the ACL into the ListView
    //
    // Turn off redraw and empty out the list
    SendMessage(hListView, WM_SETREDRAW, FALSE, 0);
    ListView_DeleteAllItems(hListView);


    if (pAcl)
    {
        PACE_HEADER pAceHeader;
        UINT AceCount;
        int iRow = 0;
        HRESULT hr = S_OK;
        
        SECURITY_INFORMATION si = (m_siPageType == SI_PAGE_ADVPERM) ? DACL_SECURITY_INFORMATION :SACL_SECURITY_INFORMATION;
        
        PINHERITED_FROM pInheritArray = NULL;
        if(m_psoti)
        {
                hr = m_psoti->GetInheritSource(si, pAcl, &pInheritArray);
        }            
        //
        // Enumerate all of the ACEs, putting the data into the list view
        //
        ULONG i = 0;
        for (AceCount = pAcl->AceCount, pAceHeader = (PACE_HEADER)FirstAce(pAcl);
             AceCount > 0;
             AceCount--, pAceHeader = (PACE_HEADER)NextAce(pAceHeader), ++i)
        {
            iRow = AddAce(hListView, 
                          pAceHeader, 
                          iRow,
                          pInheritArray? pInheritArray[i].AncestorName : NULL,
                          pInheritArray? pInheritArray[i].GenerationGap :0
                          ) + 1;
        }
        
        LocalFree(pInheritArray);
    }

    if (bSortList)
    {
        //
        // Sort the list,if no column is clicked so far,
        // sort in the cannonical order else in the last column clicked order
        //
        if(m_iLastColumnClick == -1)
        {            
            ListView_SortItems(hListView,
                               AceListCompareProcCanno,
                               MAKELPARAM(0, 1));
        }
        else
        {
            ListView_SortItems(hListView,
                               AceListCompareProc,
                               MAKELPARAM(m_iLastColumnClick, m_iSortDirection));
        }
    }

    //
    // Now select the first item
    //
    SelectListViewItem(hListView, 0);

    // Redraw the list
    SendMessage(hListView, WM_SETREDRAW, TRUE, 0);
    ListView_RedrawItems(hListView, 0, -1);

    TraceLeaveVoid();
}



COL_FOR_LV perm_col_for_container[] =
{
    IDS_ACE_PERM_COLUMN_TYPE,       10,
    IDS_ACE_PERM_COLUMN_NAME,       25,
    IDS_ACE_PERM_COLUMN_ACCESS,     20,
    IDS_ACE_PERM_COLUMN_PARENT,     20,
    IDS_ACE_PERM_COLUMN_INHERIT,    25,
};

COL_FOR_LV perm_col_for_noncontainer[] =
{
    IDS_ACE_PERM_COLUMN_TYPE,       10,
    IDS_ACE_PERM_COLUMN_NAME,       35,
    IDS_ACE_PERM_COLUMN_ACCESS,     20,
    IDS_ACE_PERM_COLUMN_PARENT,     35,
};

COL_FOR_LV audit_col_for_container[] =
{
    IDS_ACE_AUDIT_COLUMN_TYPE,      13,
    IDS_ACE_AUDIT_COLUMN_NAME,      25,
    IDS_ACE_AUDIT_COLUMN_ACCESS,    20,
    IDS_ACE_PERM_COLUMN_PARENT,     20,
    IDS_ACE_AUDIT_COLUMN_INHERIT,   25,
};

COL_FOR_LV audit_col_for_noncontainer[] =
{
    IDS_ACE_AUDIT_COLUMN_TYPE,      10,
    IDS_ACE_AUDIT_COLUMN_NAME,      35,
    IDS_ACE_AUDIT_COLUMN_ACCESS,    20,
    IDS_ACE_PERM_COLUMN_PARENT,     35,
};


void
CAdvancedListPage::InitDlg( HWND hDlg )
{
    HWND        hListView;
    RECT        rc;
    TCHAR       szBuffer[MAX_COLUMN_CHARS];
    LV_COLUMN   col;
    UINT        iTotal = 0;
    HCURSOR     hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::InitDlg");

    // Hide the Reset button if it isn't supported.
    if (!(m_siObjectInfo.dwFlags & SI_RESET) &&
        !((m_siPageType == SI_PAGE_ADVPERM) && (m_siObjectInfo.dwFlags & SI_RESET_DACL)) &&
        !((m_siPageType == SI_PAGE_AUDIT) && (m_siObjectInfo.dwFlags & SI_RESET_SACL)) )
    {
        HWND hwnd = GetDlgItem(hDlg, IDC_ACEL_RESET);
        ShowWindow(hwnd, SW_HIDE);
        EnableWindow(hwnd, FALSE);
        hwnd = GetDlgItem(hDlg, IDC_ACEL_DEFAULT_STATIC);
        ShowWindow(hwnd, SW_HIDE);
        EnableWindow(hwnd, FALSE);
    }

    if (m_siObjectInfo.dwFlags & SI_NO_ACL_PROTECT)
    {
        // Hide the "Inherit permissions" box
        HWND hwnd = GetDlgItem(hDlg, IDC_ACEL_PROTECT);
        ShowWindow(hwnd, SW_HIDE);
        EnableWindow(hwnd, FALSE);
    }

    if (!(m_siObjectInfo.dwFlags & SI_CONTAINER) ||
        !(m_siObjectInfo.dwFlags & (m_siPageType == SI_PAGE_ADVPERM ? SI_RESET_DACL_TREE : SI_RESET_SACL_TREE)))
    {
        // Hide the "Reset ACL" box
        HWND hwnd = GetDlgItem(hDlg, IDC_ACEL_RESET_ACL_TREE);
        ShowWindow(hwnd, SW_HIDE);
        EnableWindow(hwnd, FALSE);
    }

    if (m_siPageType == SI_PAGE_ADVPERM)
    {
        m_bReadOnly = !!(m_siObjectInfo.dwFlags & SI_READONLY);
    }

    hListView = GetDlgItem( hDlg, IDC_ACEL_DETAILS );

    if (m_bAbortPage)
    {
        //
        // Disable everything
        //
        m_bReadOnly = TRUE;
        EnableWindow(hListView, FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_ACEL_EDIT), FALSE);
    }
    else
    {
        //
        // Get the ACL
        //
        PSECURITY_DESCRIPTOR pSD = NULL;
        BOOL        fProtected = FALSE;
        PACL        pAcl = GetACL(&pSD, &fProtected, FALSE);

        if (m_siPageType == SI_PAGE_AUDIT)
        {
            if (pAcl && pAcl->AceCount)
            {
                // Audits are already in place, don't bother checking
                // whether auditing is enabled later.
                m_bAuditPolicyOK = TRUE;
            }
        }
        else
        {
            DWORD dwFullControl = GENERIC_ALL;
            UCHAR aceFlags = 0;

            m_psi->MapGeneric(NULL, &aceFlags, &dwFullControl);
            if (IsDenyACL(pAcl,
                          fProtected,
                          dwFullControl,
                          NULL))
            {
                // Already have Deny ACEs, don't bother warning again later.
                m_bWasDenyAcl = TRUE;
            }
        }

        //
        // Set up the listview control
        //

        // Set extended LV style for whole line selection with InfoTips
        ListView_SetExtendedListViewStyleEx(hListView,
                                            LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP,
                                            LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP);

        //
        // Add appropriate columns
        //
        GetClientRect(hListView, &rc);
        if (pAcl && pAcl->AceCount > 10)
            rc.right -= GetSystemMetrics(SM_CYHSCROLL); // Make room for scrollbar

        COL_FOR_LV *cfl;
        UINT iColCount;

        if (m_siObjectInfo.dwFlags & SI_CONTAINER)
        {
            // Get the inherit types for filling in the inherit column
            m_cInheritTypes = 0;
            m_pInheritType = NULL;
            m_psi->GetInheritTypes(&m_pInheritType, &m_cInheritTypes);

            cfl = perm_col_for_container;
            iColCount = ARRAYSIZE(perm_col_for_container);

            if (m_siPageType == SI_PAGE_AUDIT)
            {
                cfl = audit_col_for_container;
                iColCount = ARRAYSIZE(audit_col_for_container);
            }
        }
        else
        {
            // There is no inherit column for non-containers

            cfl = perm_col_for_noncontainer;
            iColCount = ARRAYSIZE(perm_col_for_noncontainer);

            if (m_siPageType == SI_PAGE_AUDIT)
            {
                cfl = audit_col_for_noncontainer;
                iColCount = ARRAYSIZE(audit_col_for_noncontainer);
            }
        }

        UINT iCol;

        iCol = 0;
        while (iCol < iColCount)
        {
            LoadString(::hModule, cfl[iCol].idText,
                       szBuffer, ARRAYSIZE(szBuffer));
            col.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
            col.fmt = LVCFMT_LEFT;
            col.pszText = szBuffer;
            col.iSubItem = iCol;

            if (iCol == iColCount - 1)
                col.cx = rc.right - iTotal;
            else
                col.cx = (rc.right * cfl[iCol].iPercent) / 100;

            ListView_InsertColumn(hListView, iCol, &col);
            iTotal += col.cx;
            iCol++;
        }

        //
        // Get the access list for filling in the Rights column
        //
        ULONG iDefaultAccess;
        DWORD dwFlags = SI_ADVANCED;
        if (m_siPageType == SI_PAGE_AUDIT)
            dwFlags |= SI_EDIT_AUDITS;
        m_psi->GetAccessRights(NULL,
                               dwFlags,
                               &m_pAccess,
                               &m_cAccesses,
                               &iDefaultAccess);

        //
        // Enumerate the ACL into the ListView
        //
        FillAceList(hListView, pAcl, FALSE);

        // Set the protection checkbox
        CheckDlgButton(hDlg, IDC_ACEL_PROTECT, !fProtected);

        if (pSD)
            LocalFree(pSD);     // We're done with it, now free it
    } // !m_bAbortPage

    // Update the other controls
    UpdateButtons(hDlg);

    SetCursor(hcur);

    TraceLeaveVoid();
}


void
CAdvancedListPage::BuildAcl(HWND hListView,
                            PACL *ppAcl)
{
    long cAces;
    long iEntry;
    long iLength = SIZEOF(ACL);
    PACE pAce;
    PACL pACL = NULL;
    LV_ITEM lvi;
    lvi.mask     = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.lParam   = NULL;

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::BuildAcl");
    TraceAssert(hListView != NULL);
    TraceAssert(ppAcl != NULL);

    *ppAcl = NULL;

    cAces = ListView_GetItemCount(hListView);

    //
    // Iterate through all of the ace's counting up size.
    // If there are no ACEs, create an empty ACL.
    //
    for (iEntry = 0; iEntry < cAces; iEntry++)
    {
        lvi.iItem = iEntry;
        ListView_GetItem(hListView, &lvi);

        pAce = (PACE)lvi.lParam;
        if (pAce)
        {
            if (!(pAce->AceFlags & INHERITED_ACE))
                iLength += pAce->AceSize;
        }
    }

    pACL = (PACL)LocalAlloc(LPTR, iLength);
    if (pACL)
    {
        PACE_HEADER pAceDest;

        InitializeAcl(pACL, iLength, ACL_REVISION);

        for (iEntry = 0, pAceDest = (PACE_HEADER)FirstAce(pACL);
             iEntry < cAces;
             iEntry++)
        {
            lvi.iItem = iEntry;
            ListView_GetItem(hListView, &lvi);

            pAce = (PACE)lvi.lParam;
            if (pAce)
            {
                if (!(pAce->AceFlags & INHERITED_ACE))
                {
                    //
                    // Special case for CreatorOwner/CreatorGroup,
                    // which are only useful if inherit bits are set.
                    //
                    if (IsCreatorSid(pAce->psid) && !(pAce->AceFlags & INHERIT_ONLY_ACE))
                    {
                        pAce->AceFlags |= INHERIT_ONLY_ACE;
                        if (!(pAce->AceFlags & ACE_INHERIT_ALL))
                        {
                            pAce->AceFlags |= ACE_INHERIT_ALL;
                            m_psi->MapGeneric(&pAce->ObjectType, &pAce->AceFlags, &pAce->Mask);
                        }
                    }

                    pAce->CopyTo(pAceDest);
                    pACL->AceCount++;
                    pAceDest = (PACE_HEADER)NextAce(pAceDest);

                    // Is this an object ACE?  If so, reset the ACL revision.
                    if (pAce->Flags != 0 && pACL->AclRevision < ACL_REVISION_DS)
                        pACL->AclRevision = ACL_REVISION_DS;
                }
            }
        }

        iLength = (ULONG)((PBYTE)pAceDest - (PBYTE)pACL);
        TraceAssert(pACL->AclSize >= iLength);

        if (pACL->AclSize > iLength)
            pACL->AclSize = (WORD)iLength;

        TraceAssert(IsValidAcl(pACL));
    }

    *ppAcl = pACL;

    TraceLeaveVoid();
}


HRESULT
CAdvancedListPage::ApplyPermissions(HWND hDlg,
                                    HWND hListView,
                                    BOOL fProtected)
{
    HRESULT hr = S_OK;
    PACL pACL = NULL;
    SECURITY_DESCRIPTOR sd;
    SECURITY_INFORMATION si = DACL_SECURITY_INFORMATION;
    BOOL bIsDenyAcl = FALSE;

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::ApplyPermissions");
    TraceAssert(hDlg != NULL);
    TraceAssert(hListView != NULL);
    TraceAssert(!m_bReadOnly);
    TraceAssert(!m_bAbortPage);

    if (IsDlgButtonChecked(hDlg, IDC_ACEL_RESET_ACL_TREE))
    {
        // Confirm this operation
        if (IDNO == MsgPopup(hDlg,
                             MAKEINTRESOURCE(IDS_RESET_DACL_WARNING),
                             MAKEINTRESOURCE(IDS_SECURITY),
                             MB_YESNO | MB_ICONWARNING,
                             ::hModule,
                             m_siObjectInfo.pszObjectName))
        {
            // Return PSNRET_INVALID to abort the Apply and tell the sheet to
            // select this page as the active page.
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
            ExitGracefully(hr, S_OK, "ApplyPermissions aborting");
        }

        si |= SI_RESET_DACL_TREE;
    }

    // Make sure the DACL is in canonical order.  Note that OnApply
    // will re-read the DACL and reinitialize the list with the
    // current sort order.
    ListView_SortItems(hListView,
                       AceListCompareProcCanno,
                       MAKELPARAM(0, 1));

    // Build the new DACL
    BuildAcl(hListView, &pACL);

    // Check for Deny ACEs in the ACL
    if (!m_bWasDenyAcl)
    {
        DWORD dwWarning = 0;
        DWORD dwFullControl = GENERIC_ALL;
        UCHAR aceFlags = 0;

        m_psi->MapGeneric(NULL, &aceFlags, &dwFullControl);
        bIsDenyAcl = IsDenyACL(pACL,
                               fProtected,
                               dwFullControl,
                               &dwWarning);
        if (bIsDenyAcl)
        {
            TraceAssert(dwWarning != 0);

            // Warn the user about Deny ACEs
            if (IDNO == MsgPopup(hDlg,
                                 MAKEINTRESOURCE(dwWarning),
                                 MAKEINTRESOURCE(IDS_SECURITY),
                                 MB_YESNO | MB_ICONWARNING,
                                 ::hModule,
                                 m_siObjectInfo.pszObjectName))
            {
                // Return PSNRET_INVALID to abort the Apply and tell the sheet to
                // select this page as the active page.
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                ExitGracefully(hr, S_OK, "ApplyPermissions aborting");
            }
        }
    }

    // Build the security descriptor
    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorDacl(&sd, !!(pACL), pACL, FALSE);
    sd.Control |= SE_DACL_AUTO_INHERIT_REQ;

    if (fProtected)
        sd.Control |= SE_DACL_PROTECTED;

	if(IsAclBloated(hDlg, si, &sd, m_cInheritableAces,m_siObjectInfo.dwFlags & SI_EDIT_PROPERTIES))
	{
		SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
        ExitGracefully(hr, S_FALSE, "ApplyPermissions aborting");
	}
	
	// Write out the new DACL
	hr = m_psi->SetSecurity(si, &sd);
	

    if (bIsDenyAcl && S_OK == hr)
        m_bWasDenyAcl = TRUE;

exit_gracefully:

    if (pACL)
        LocalFree(pACL);

    TraceLeaveResult(hr);
}


HRESULT
CAdvancedListPage::ApplyAudits(HWND hDlg,
                               HWND hListView,
                               BOOL fProtected)
{
    HRESULT hr = S_OK;
    PACL pACL = NULL;
    SECURITY_DESCRIPTOR sd;
    SECURITY_INFORMATION si = SACL_SECURITY_INFORMATION;
    DWORD dwPriv = SE_SECURITY_PRIVILEGE;
    HANDLE hToken = INVALID_HANDLE_VALUE;

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::ApplyAudits");
    TraceAssert(!m_bReadOnly);
    TraceAssert(!m_bAbortPage);

    if (IsDlgButtonChecked(hDlg, IDC_ACEL_RESET_ACL_TREE))
        si |= SI_RESET_SACL_TREE;

    // Build the SACL
    BuildAcl(hListView, &pACL);

#if 0
    // Added this to fix 174167, removed it to fix 359975
    if (pACL && 0 == pACL->AceCount)
    {
        LocalFree(pACL);
        pACL = NULL;
    }
#endif

    // Build the security descriptor
    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorSacl(&sd, !!(pACL), pACL, FALSE);
    sd.Control |= SE_SACL_AUTO_INHERIT_REQ;

    if (fProtected)
        sd.Control |= SE_SACL_PROTECTED;

    // Enable the security privilege and write out the new SACL
    hToken = EnablePrivileges(&dwPriv, 1);

	if(IsAclBloated(hDlg, si, &sd, m_cInheritableAces,m_siObjectInfo.dwFlags & SI_EDIT_PROPERTIES))
	{
		SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
        hr = S_FALSE;
	}
	else
		hr = m_psi->SetSecurity(si, &sd);

    ReleasePrivileges(hToken);

    if (pACL)
        LocalFree(pACL);

    if (S_OK == hr)
        CheckAuditPolicy(hDlg);

    TraceLeaveResult(hr);
}


void
CAdvancedListPage::OnApply(HWND hDlg, BOOL bClose)
{
    HRESULT hr = S_OK;
    HWND hListView;
    BOOL fProtected;

    if (!m_fPageDirty)
        return;

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::OnApply");
    TraceAssert(hDlg != NULL);
    TraceAssert(!m_bReadOnly);
    TraceAssert(!m_bAbortPage);

    hListView = GetDlgItem(hDlg, IDC_ACEL_DETAILS);
    fProtected = !IsDlgButtonChecked(hDlg, IDC_ACEL_PROTECT);

    if (m_siPageType == SI_PAGE_ADVPERM)
    {
        hr = ApplyPermissions(hDlg, hListView, fProtected);
    }
    else
    {
        hr = ApplyAudits(hDlg, hListView, fProtected);
    }

    if (FAILED(hr))
    {
        // Tell the user there was a problem.  If they choose to cancel
        // and the dialog is closing, do nothing (let the dialog close).
        // Otherwise, tell the property sheet that we had a problem.
        UINT nMsgID = IDS_PERM_WRITE_FAILED;
        if (m_siPageType == SI_PAGE_AUDIT)
            nMsgID = IDS_AUDIT_WRITE_FAILED;

        if (IDCANCEL != SysMsgPopup(hDlg,
                                    MAKEINTRESOURCE(nMsgID),
                                    MAKEINTRESOURCE(IDS_SECURITY),
                                    (bClose ? MB_RETRYCANCEL : MB_OK) | MB_ICONERROR,
                                    ::hModule,
                                    hr,
                                    m_siObjectInfo.pszObjectName))
        {
            // Return PSNRET_INVALID to abort the Apply and cause the sheet to
            // select this page as the active page.
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
        }
    }
    else if (S_FALSE == hr)
    {
        // S_FALSE is silent failure (the client should put up UI
        // during SetSecurity before returning S_FALSE).
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
    }
    else
    {
        m_fPageDirty = FALSE;

        // If ApplyPermissions bailed due to user action ("No"),
        // then the dialog won't be closing
        if (PSNRET_INVALID == GetWindowLongPtr(hDlg, DWLP_MSGRESULT))
            bClose = FALSE;

        if (!bClose)
        {
            //
            // Re-read the security descriptor and reinitialize the dialog
            //
            //Inform the Effective Permission tab that
            //Permissions are changed
            if(m_siPageType == SI_PAGE_ADVPERM)
                PropSheet_QuerySiblings(GetParent(hDlg),0,0);

            PSECURITY_DESCRIPTOR pSD = NULL;
            BOOL        fACLProtected = FALSE;
            PACL pAcl = GetACL(&pSD, &fACLProtected, FALSE);
            FillAceList(hListView, pAcl);


            // Set the button states
             CheckDlgButton(hDlg, IDC_ACEL_PROTECT, !fACLProtected);
            CheckDlgButton(hDlg, IDC_ACEL_RESET_ACL_TREE, BST_UNCHECKED);
            UpdateButtons(hDlg);

            if (pSD)
                LocalFree(pSD);     // We're done with it, now free it
        }
    }

    TraceLeaveVoid();
}

void
CAdvancedListPage::OnAdd(HWND hDlg)
{
    PUSER_LIST pUserList = NULL;

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::OnAdd");
    TraceAssert(!m_bReadOnly);

    if (S_OK == GetUserGroup(hDlg, FALSE, &pUserList))
    {
        // Build an empty ACE (mask = 0) using the SID we just
        // got in pUserList.
        CAce ace;

        TraceAssert(NULL != pUserList);
        TraceAssert(1 == pUserList->cUsers);

        if (m_siPageType == SI_PAGE_AUDIT)
            ace.AceType = SYSTEM_AUDIT_ACE_TYPE;

        if (m_siObjectInfo.dwFlags & SI_CONTAINER)
            ace.AceFlags = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE;

        ace.SetSid(pUserList->rgUsers[0].pSid,
                   pUserList->rgUsers[0].pszName,
                   pUserList->rgUsers[0].pszLogonName,
                   pUserList->rgUsers[0].SidType);

        // Done with this now
        LocalFree(pUserList);

        // Edit the ACE
        EditAce(hDlg, &ace, FALSE);
    }

    TraceLeaveVoid();
}


BOOL CanDeleteDirectAces( HWND hDlg )
{
    TCHAR szBuffer[1024];
    TCHAR szCaption[1024];
    if( !LoadString( ::hModule, IDS_CONFIRM_MULTIPLE_DELETION, szBuffer, 1024 ) )
        return FALSE;
    if( !LoadString( ::hModule, IDS_SECURITY, szCaption, 1024 ) )
        return FALSE;

    return (IDYES == MessageBox( hDlg, szBuffer, szCaption, MB_YESNO | MB_ICONQUESTION | MB_APPLMODAL ));
}
void
CAdvancedListPage::OnRemove(HWND hDlg)
{

    HWND hListView = GetDlgItem(hDlg, IDC_ACEL_DETAILS);

    //if Any selected Ace is inherited from parent
    //Ask user if to proceed with deletion of direct aces
    if( AnySelectedAceofType(hListView, FALSE) && !CanDeleteDirectAces( hDlg ) )
        return;

    //Remember the positon of first selected permissons
    //In end select the item at this position
    int iFirstSelected = ListView_GetNextItem(hListView, -1, LVNI_SELECTED);
    LVITEM lvi = {0};
    lvi.iItem = iFirstSelected;
    lvi.mask     = LVIF_PARAM;
    lvi.iSubItem = 0;
    while( lvi.iItem != -1 )
    {

        lvi.lParam   = NULL;
        ListView_GetItem(hListView, &lvi);
        if( (((PACE)lvi.lParam)->AceFlags & INHERITED_ACE) == 0 )
        {
            ListView_DeleteItem(hListView, lvi.iItem);
            //Start from one item back as current item is deleted
            --lvi.iItem;
        }
        lvi.iItem = ListView_GetNextItem(hListView, lvi.iItem, LVNI_SELECTED);
    }


    if (ListView_GetItemCount(hListView) <= iFirstSelected )
            --iFirstSelected;

        SelectListViewItem(hListView, iFirstSelected);

        PropSheet_Changed(GetParent(hDlg),hDlg);
        m_fPageDirty = TRUE;
    
}


void
CAdvancedListPage::OnReset(HWND hDlg)
{
    //
    // Get a default ACL and enumerate it into the ListView
    //
    PSECURITY_DESCRIPTOR pSD = NULL;
    BOOL fProtected = FALSE;

    FillAceList(GetDlgItem(hDlg, IDC_ACEL_DETAILS),
                GetACL(&pSD, &fProtected, TRUE /*default*/));

    // Set the button states
    CheckDlgButton(hDlg, IDC_ACEL_PROTECT, !fProtected);
    UpdateButtons(hDlg);

    if (pSD)
        LocalFree(pSD);     // We're done with it, now free it

    // Notify the property sheet that we've changed
    PropSheet_Changed(GetParent(hDlg),hDlg);
    m_fPageDirty = TRUE;
}


void
CAdvancedListPage::OnProtect(HWND hDlg)
{
    // The "Inherit permissions" checkbox was clicked

    if (!IsDlgButtonChecked(hDlg, IDC_ACEL_PROTECT))
    {
        BOOL bHaveInheritedAces = FALSE;
        HWND hListView = GetDlgItem(hDlg, IDC_ACEL_DETAILS);
        int cItems = ListView_GetItemCount(hListView);
        int i;
        PACE pAce;
        LV_ITEM lvItem;
        lvItem.iSubItem = 0;
        lvItem.mask = LVIF_PARAM;

        // Are there any inherited aces?
        for (i = 0; i < cItems && !bHaveInheritedAces; i++)
        {
            lvItem.iItem = i;
            ListView_GetItem(hListView, &lvItem);
            pAce = (PACE)lvItem.lParam;
            if (pAce)
                bHaveInheritedAces = (pAce->AceFlags & INHERITED_ACE);
        }

        if (bHaveInheritedAces)
        {
            int nResult;
            int iSelected;

            // Turning protection on.  Ask the user whether to convert
            // inherited aces to non-inherited aces, or delete them.
            nResult = ConfirmAclProtect(hDlg, m_siPageType == SI_PAGE_ADVPERM);

            if (nResult == IDCANCEL)
            {
                // Reset the checkbox and bail
                CheckDlgButton(hDlg, IDC_ACEL_PROTECT, BST_CHECKED);
                return;
            }

            //
            // Remember the current selection, if any.
            //
            iSelected = ListView_GetNextItem(hListView, -1, LVNI_SELECTED);

            //
            // Convert or delete inherited aces
            //
            while (cItems > 0)
            {
                --cItems;
                lvItem.iItem = cItems;

                //
                // The AddAce call below merges entries, which
                // can potentially remove entries from the list,
                // so check the return value here.  This also
                // means we could see the same item more than
                // once here, but after the first time it won't
                // have the INHERITED_ACE flag set.
                //
                if (!ListView_GetItem(hListView, &lvItem))
                    continue;

                pAce = (PACE)lvItem.lParam;

                if (pAce && (pAce->AceFlags & INHERITED_ACE))
                {
                    if (nResult == IDC_CONFIRM_REMOVE)
                    {
                        // Delete it
                        ListView_DeleteItem(hListView, cItems);
                    }
                    else
                    {
                        //
                        // Convert it to non-inherited.  Do this
                        // by deleting and re-adding without
                        // INHERITED_ACE set.  AddAce will try
                        // to merge into existing entries.
                        //
                        // Before deleting, be sure to set
                        // lParam to zero so pAce doesn't
                        // get freed.
                        //
                        pAce->AceFlags &= ~INHERITED_ACE;
                        lvItem.lParam = 0;
                        ListView_SetItem(hListView, &lvItem);
                        ListView_DeleteItem(hListView, cItems);
                        AddAce(hListView, pAce, cItems, NULL,0);
                    }
                }
            }

            //
            // Reset the selection
            //
            iSelected = min(ListView_GetItemCount(hListView)-1, iSelected);
            SelectListViewItem(hListView, iSelected);
        }
    }

    PropSheet_Changed(GetParent(hDlg), hDlg);
    m_fPageDirty = TRUE;
}


void
CAdvancedListPage::OnEdit(HWND hDlg)
{
    HWND hListView;
    PACE pAce;
    int  iSelected;

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::OnEdit");
    TraceAssert(hDlg != NULL);
    TraceAssert(!m_bAbortPage);

    hListView = GetDlgItem(hDlg, IDC_ACEL_DETAILS);
    pAce = (PACE)GetSelectedItemData(hListView, &iSelected);
    EditAce(hDlg, pAce, TRUE, iSelected);

    TraceLeaveVoid();
}


int
CAdvancedListPage::AddAcesFromDPA(HWND hListView, HDPA hEntries, int iSelected)
{
    UINT iItems = 0;

    if (hEntries)
        iItems = DPA_GetPtrCount(hEntries);

    while (iItems)
    {
        --iItems;
        iSelected = AddAce(hListView,
                           (PACE_HEADER)DPA_FastGetPtr(hEntries, iItems),
                           iSelected,
                           NULL,0) + 1;
    }

    return iSelected;
}

void
CAdvancedListPage::EditAce(HWND hDlg, PACE pAce, BOOL bDeleteSelection, LONG iSelected)
{
    HWND hListView;
    HDPA hEntries = NULL;
    HDPA hPropertyEntries = NULL;
    UINT iItems = 0;
    UINT iPropertyItems = 0;
    BOOL bUpdateList;
    UINT nStartPage = 0;
    DWORD dwResult = 0;

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::EditAce");
    TraceAssert(hDlg != NULL);
    TraceAssert(!m_bAbortPage);

    hListView = GetDlgItem(hDlg, IDC_ACEL_DETAILS);

    if (pAce)
    {
        // If the ACE is inherited, don't delete it.
        if (pAce->AceFlags & INHERITED_ACE)
            bDeleteSelection = FALSE;

        // If this is a property ACE, we want to show the property page first.
        if (pAce->IsPropertyAce())
        {
            TraceAssert(m_siObjectInfo.dwFlags & SI_EDIT_PROPERTIES);
            nStartPage = 1;
        }
    }

    bUpdateList = EditACEEntry(hDlg,
                               m_psi,
                               pAce,
                               m_siPageType,
                               m_siObjectInfo.pszObjectName,
                               m_bReadOnly,
                               &dwResult,
                               &hEntries,
                               (m_siObjectInfo.dwFlags & SI_EDIT_PROPERTIES) ? &hPropertyEntries : NULL,
                               nStartPage)
                  && !m_bReadOnly;

    if (bUpdateList)
    {
        if (hEntries)
            iItems = DPA_GetPtrCount(hEntries);

        if (hPropertyEntries)
            iPropertyItems = DPA_GetPtrCount(hPropertyEntries);

        if (iItems + iPropertyItems)
        {
            if (bDeleteSelection)
            {
                if ((nStartPage == 0 && iItems != 0) || (nStartPage == 1 && iPropertyItems != 0))
                {
                    // The previous ace was modified, so delete it here.
                    ListView_DeleteItem(hListView, iSelected);
                }
                else if (iPropertyItems != 0 &&
                         !(pAce->Flags & ACE_OBJECT_TYPE_PRESENT) &&
                         (pAce->Mask & (ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP)))
                {
                    //
                    // iPropertyItems != 0 implies nStartPage = 0 or else the
                    // "if" condition above would be true.  nStartPage = 0
                    // implies iItems = 0 for the same reason.  That means the
                    // ace has more in it that just property stuff (or it's a
                    // control access right), but the only changes occurred on the
                    // Property page.  Make sure we get rid of any property bits
                    // in the original ace so that we don't incorrectly merge
                    // property changes into the original ace.
                    //
                    // An example of this:
                    // Suppose pAce->Mask == READ_CONTROL | ACTRL_DS_READ_PROP and
                    // no property GUID is present.  Suppose the user edits the ace
                    // and clicks on the Property tab, then unchecks a bunch of
                    // things, including "Read all properties".  The result
                    // "should be" a bunch of "Read <specific property>" aces.
                    // If we don't remove ACTRL_DS_READ_PROP from the original ace,
                    // then all of the "Read <specific property>" aces get merged
                    // back into the original ace for no net effect.
                    //
                    // The reverse situation (nStartPage = 1, iPropertyItems = 0,
                    // iItems != 0) is not a problem.  In that case merging will
                    // occur correctly,
                    //

                    // Make a copy with everything except the property bits
                    if (pAce->Mask & ~(ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP))
                    {
EditAce_MakeCopyWithoutProperties:
                        PACE_HEADER pAceHeader = pAce->Copy();
                        if (pAceHeader != NULL)
                        {
                            // Turn off property bits
                            ((PKNOWN_ACE)pAceHeader)->Mask &= ~(ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP);
                            TraceAssert(((PKNOWN_ACE)pAceHeader)->Mask != 0);
                            // 370573
                            // Add it to hPropertyEntries instead of hEntries,
                            // since hEntries can be NULL here but we know
                            // hPropertyEntries is non-NULL (iPropertyItems!=0)
                            DPA_AppendPtr(hPropertyEntries, pAceHeader);
                        }
                    }
                    // Delete the old ace
                    ListView_DeleteItem(hListView, iSelected);
                }
            }

            //
            // Now merge the new aces into the existing list
            //
            iSelected = AddAcesFromDPA(hListView, hEntries, iSelected);
            iSelected = AddAcesFromDPA(hListView, hPropertyEntries, iSelected);

            //
            // Now select the last item inserted
            //
            SelectSingleItemInLV( hListView, iSelected -1 );
            // Re-sort the list so the new and/or modified entries
            // appear in the right place.
            if(m_iLastColumnClick == -1)
            {            
                ListView_SortItems(hListView,
                                   AceListCompareProcCanno,
                                   MAKELPARAM(0, 1));
            }
            else
            {
                ListView_SortItems(hListView,
                                   AceListCompareProc,
                                   MAKELPARAM(m_iLastColumnClick, m_iSortDirection));
            }

            // After sorting, make sure the selection is visible.
            EnsureListViewSelectionIsVisible(hListView);
        }
        else if (bDeleteSelection && dwResult)
        {
            // Everything succeeded, something was edited, but nothing was created
            // (probably all boxes were unchecked).  Delete the previous selection.

            // 370573
            // If the only change occurred on the Properties page, then we
            // only want to turn off the property bits. We don't want to
            // delete the whole thing.
            if (EAE_NEW_PROPERTY_ACE == dwResult &&
                (pAce->Mask & ~(ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP)))
            {
                if (!hPropertyEntries)
                    hPropertyEntries = DPA_Create(1);
                if (hPropertyEntries)
                    goto EditAce_MakeCopyWithoutProperties;
            }

            // Delete the previous selection.
            ListView_DeleteItem(hListView, iSelected);
        }

        // Was anything edited?
        if (dwResult)
        {
            PropSheet_Changed(GetParent(hDlg),hDlg);
            m_fPageDirty = TRUE;
        }
    }

    if (hEntries)
        DestroyDPA(hEntries);

    if (hPropertyEntries)
        DestroyDPA(hPropertyEntries);

    TraceLeaveVoid();
}


void
CAdvancedListPage::CheckAuditPolicy(HWND hwndOwner)
{
    //
    // Check whether auditing is turned on and warn the user if not.
    //
    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::CheckAuditPolicy");

    if (!m_bAuditPolicyOK)
    {
        LSA_HANDLE hPolicy = GetLSAConnection(m_siObjectInfo.pszServerName,
                                              POLICY_VIEW_AUDIT_INFORMATION);

        if (hPolicy != NULL)
        {
            PPOLICY_AUDIT_EVENTS_INFO pAuditInfo = NULL;

            LsaQueryInformationPolicy(hPolicy,
                                      PolicyAuditEventsInformation,
                                      (PVOID*)&pAuditInfo);

            if (pAuditInfo != NULL)
            {
                // We don't need to do this work again
                m_bAuditPolicyOK = TRUE;

                if (!pAuditInfo->AuditingMode)
                {
                    // Auditing is not on... warn the user
                    MsgPopup(hwndOwner,
                             MAKEINTRESOURCE(IDS_AUDIT_OFF_WARNING),
                             MAKEINTRESOURCE(IDS_SECURITY),
                             MB_OK | MB_ICONWARNING,
                             ::hModule);
                }

                LsaFreeMemory(pAuditInfo);
            }
            else
            {
                TraceMsg("LsaQueryInformationPolicy failed");
            }

            LsaClose(hPolicy);
        }
        else
        {
            TraceMsg("Unable to open LSA policy handle");
        }
    }

    TraceLeaveVoid();
}


BOOL
CAdvancedListPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PACE pAce;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        InitDlg(hDlg);
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            LPNM_LISTVIEW pnmlv = (LPNM_LISTVIEW)lParam;

            // Set default return value
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

            switch (pnmh->code)
            {
            case NM_DBLCLK:
                if (pnmh->idFrom == IDC_ACEL_DETAILS)
                    OnEdit(hDlg);
                break;

            case LVN_ITEMCHANGED:
                if (pnmlv->uChanged & LVIF_STATE)
                    UpdateButtons(hDlg);
                break;

            case LVN_DELETEITEM:
                pAce = (PACE)pnmlv->lParam;
                delete pAce;
                break;

            case LVN_KEYDOWN:
                if (((LPNMLVKEYDOWN)pnmh)->wVKey == VK_DELETE)
                    if( IsWindowEnabled( GetDlgItem( hDlg, IDC_ACEL_REMOVE ) ) )
                        SendMessage(hDlg,
                                    WM_COMMAND,
                                    GET_WM_COMMAND_MPS(IDC_ACEL_REMOVE, NULL, 0));
                break;

#define lvi (((NMLVDISPINFO*)lParam)->item)

            case LVN_GETDISPINFO:
                pAce = (PACE)lvi.lParam;
                if ((lvi.mask & LVIF_TEXT) && pAce)
                {
                    switch (lvi.iSubItem)
                    {
                    case 0:
                        lvi.pszText = pAce->GetType();
                        break;

                    case 1:
                        lvi.pszText = pAce->GetName();
                        break;

                    case 2:
                        lvi.pszText = pAce->GetAccessType();
                        break;
                    case 3:
                        lvi.pszText = pAce->GetInheritSourceName();
                        break;
                    case 4:
                        lvi.pszText = pAce->GetInheritType();
                        break;
                    }
                }
                break;
#undef lvi

            case LVN_COLUMNCLICK:
                if (m_iLastColumnClick == pnmlv->iSubItem)
                    m_iSortDirection = -m_iSortDirection;
                else
                    m_iSortDirection = 1;
                m_iLastColumnClick = pnmlv->iSubItem;
                ListView_SortItems(pnmh->hwndFrom,
                                   AceListCompareProc,
                                   MAKELPARAM(m_iLastColumnClick, m_iSortDirection));
                EnsureListViewSelectionIsVisible(pnmh->hwndFrom);
                break;

            case PSN_APPLY:
                OnApply(hDlg, (BOOL)(((LPPSHNOTIFY)lParam)->lParam));
                break;
            }
        }
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_ACEL_ADD:
            OnAdd(hDlg);
            break;

        case IDC_ACEL_REMOVE:
            OnRemove(hDlg);
            break;

        case IDC_ACEL_EDIT:
            OnEdit(hDlg);
            break;

        case IDC_ACEL_RESET:
            OnReset(hDlg);
            break;

        case IDC_ACEL_RESET_ACL_TREE:
            if (!m_fPageDirty)
            {
                PropSheet_Changed(GetParent(hDlg),hDlg);
                m_fPageDirty = TRUE;
            }
            break;

        case IDC_ACEL_PROTECT:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED
                && !m_bReadOnly)
            {
                OnProtect(hDlg);
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_HELP:
        if (IsWindowEnabled(hDlg))
        {
            const DWORD *pdwHelpIDs = aAceListPermHelpIDs;

            if (m_siPageType == SI_PAGE_AUDIT)
                pdwHelpIDs = aAceListAuditHelpIDs;

            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_szAcluiHelpFile,
                    HELP_WM_HELP,
                    (DWORD_PTR)pdwHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hDlg))
        {
            const DWORD *pdwHelpIDs = aAceListPermHelpIDs;

            if (m_siPageType == SI_PAGE_AUDIT)
                pdwHelpIDs = aAceListAuditHelpIDs;

            WinHelp(hDlg,
                    c_szAcluiHelpFile,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)pdwHelpIDs);
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

HPROPSHEETPAGE
CreateAdvPermissionPage( LPSECURITYINFO psi )
{
    HPROPSHEETPAGE hPage = NULL;
    PADVANCEDLISTPAGE pPage;

    TraceEnter(TRACE_ACELIST, "CreateAdvPermissionPage");

    pPage = new CAdvancedListPage( psi, SI_PAGE_ADVPERM );

    if (pPage)
    {
        hPage = pPage->CreatePropSheetPage(MAKEINTRESOURCE(IDD_ACELIST_PERM_PAGE));

        if (!hPage)
            delete pPage;
    }

    TraceLeaveValue(hPage);
}

HPROPSHEETPAGE
CreateAdvAuditPage( LPSECURITYINFO psi )
{
    HPROPSHEETPAGE hPage = NULL;
    PADVANCEDLISTPAGE pPage;

    TraceEnter(TRACE_ACELIST, "CreateAdvAuditPage");

    pPage = new CAdvancedListPage( psi, SI_PAGE_AUDIT );

    if (pPage)
    {
        hPage = pPage->CreatePropSheetPage(MAKEINTRESOURCE(IDD_ACELIST_AUDIT_PAGE));

        if (!hPage)
            delete pPage;
    }

    TraceLeaveValue(hPage);
}


//
// Expose an api to get at the ace list editor
//
BOOL
ACLUIAPI
EditSecurityEx( HWND hwndOwner, LPSECURITYINFO psi, PPERMPAGE pPermPage, UINT nStartPage )
{
    HPROPSHEETPAGE hPage[4];
    UINT cPages = 0;
    BOOL bResult = FALSE;
    SI_OBJECT_INFO siObjectInfo = {0};
    HRESULT hr;

    TraceEnter(TRACE_ACELIST, "EditSecurityEx");

    // Get flags and object name information
    hr = psi->GetObjectInformation(&siObjectInfo);

    if (FAILED(hr))
    {
        SysMsgPopup(hwndOwner,
                    MAKEINTRESOURCE(IDS_OPERATION_FAILED),
                    MAKEINTRESOURCE(IDS_SECURITY),
                    MB_OK | MB_ICONERROR,
                    ::hModule,
                    hr);
        TraceLeaveValue(FALSE);
    }

    hPage[cPages] = CreateAdvPermissionPage( psi );
    if (hPage[cPages])
        cPages++;

    if (siObjectInfo.dwFlags & SI_EDIT_AUDITS)
    {
        hPage[cPages] = CreateAdvAuditPage( psi );
        if (hPage[cPages])
            cPages++;
    }

    if (siObjectInfo.dwFlags & SI_EDIT_OWNER)
    {
        hPage[cPages] = CreateOwnerPage( psi, &siObjectInfo );
        if (hPage[cPages])
            cPages++;
    }

    if((siObjectInfo.dwFlags & SI_EDIT_EFFECTIVE) &&  pPermPage->IsEffective())
    {
        hPage[cPages] = CreateEffectivePermPage( psi, &siObjectInfo );
        if (hPage[cPages])
        {
//            pPermPage->SetEffectivePerm(hPage[cPages]);
            cPages++;
        }
    }

    if (cPages)
    {
        // Build dialog title string
        LPTSTR pszCaption = NULL;
        FormatStringID(&pszCaption, ::hModule, IDS_ACEL_TITLE, siObjectInfo.pszObjectName);

        PROPSHEETHEADER psh = {0};
        psh.dwSize = SIZEOF(psh);
        psh.dwFlags = PSH_DEFAULT;
        psh.hwndParent = hwndOwner;
        psh.hInstance = ::hModule;
        psh.pszCaption = pszCaption;
        psh.nPages = cPages;
        psh.nStartPage = 0;
        psh.phpage = &hPage[0];

        if (nStartPage < cPages)
            psh.nStartPage = nStartPage;

        bResult = (BOOL)(PropertySheet(&psh) + 1);

        LocalFreeString(&pszCaption);
    }

    TraceLeaveValue(bResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\cstrings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cstrings.h
//
//--------------------------------------------------------------------------

#ifndef __cstrings_h
#define __cstrings_h

extern TCHAR const c_szDllName[];
extern TCHAR const c_szAcluiHelpFile[];

#endif  // __cstrings_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\idh.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       idh.h
//
//--------------------------------------------------------------------------

#define IDH_NOHELP                      ((DWORD)-1)

#define IDH_SPP_PRINCIPALS              1000
#define IDH_SPP_ADD                     1001
#define IDH_SPP_REMOVE                  1002
#define IDH_SPP_RESET                   1003
#define IDH_SPP_PERMS                   1004
#define IDH_SPP_ADVANCED                1005
#define IDH_SPP_PROTECT                 1007

#define IDH_ACEL_PERM_DETAILS           2001
#define IDH_ACEL_PERM_ADD               2002
#define IDH_ACEL_PERM_REMOVE            2003
#define IDH_ACEL_PERM_EDIT              2004
#define IDH_ACEL_PERM_RESET             2005
#define IDH_ACEL_PERM_PROTECT           2006
#define IDH_ACEL_PERM_RESET_ACL_TREE    2008

#define IDH_ACEL_AUDIT_DETAILS          3001
#define IDH_ACEL_AUDIT_ADD              3002
#define IDH_ACEL_AUDIT_REMOVE           3003
#define IDH_ACEL_AUDIT_EDIT             3004
#define IDH_ACEL_AUDIT_RESET            3005
#define IDH_ACEL_AUDIT_PROTECT          3006
#define IDH_ACEL_AUDIT_RESET_ACL_TREE   3008

#define IDH_ACEE_PERM_NAMEBUTTON        4000
#define IDH_ACEE_PERM_NAME              4001
#define IDH_ACEE_PERM_INHERITTYPE       4002
#define IDH_ACEE_PERM_INHERITIMMEDIATE  4003
#define IDH_ACEE_PERM_LIST              4004
#define IDH_ACEE_PERM_CLEAR             4009

#define IDH_ACEE_AUDIT_NAMEBUTTON       4100
#define IDH_ACEE_AUDIT_NAME             4101
#define IDH_ACEE_AUDIT_INHERITTYPE      4102
#define IDH_ACEE_AUDIT_INHERITIMMEDIATE 4103
#define IDH_ACEE_AUDIT_LIST             4104
#define IDH_ACEE_AUDIT_CLEAR            4109

#define IDH_OWN_CURRENTOWNER            5001
#define IDH_OWN_OWNERLIST               5002
#define IDH_OWN_RESET                   5003
#define IDH_OWN_RECURSE                 5004


#define IDH_EFF_NAME                    6001
#define IDH_EFF_SELECT                  6002
#define IDH_EFF_PERM_LIST               6003
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\misc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       misc.h
//
//  Definitions and prototypes for miscellaneous stuff
//
//--------------------------------------------------------------------------

#ifndef _MISC_H_
#define _MISC_H_

typedef struct _USER_INFO
{
    PSID pSid;
    LPCTSTR pszName;
    LPCTSTR pszLogonName;
    SID_NAME_USE SidType;
} USER_INFO, *PUSER_INFO;

typedef struct _USER_LIST
{
    ULONG cUsers;
    USER_INFO rgUsers[ANYSIZE_ARRAY];
} USER_LIST, *PUSER_LIST;

PSID GetAceSid(PACE_HEADER pAce);
PSID LocalAllocSid(PSID pOriginal);
void DestroyDPA(HDPA hList);

extern "C" {
#include <ntlsa.h>
}
LSA_HANDLE GetLSAConnection(LPCTSTR pszServer, DWORD dwAccessDesired);

BOOL LookupSid(PSID pSid,
               LPCTSTR pszServer,
               LPSECURITYINFO2 psi2,
               PUSER_LIST *ppUserList);
BOOL LookupSids(HDPA hSids,
                LPCTSTR pszServer,
                LPSECURITYINFO2 psi2,
                PUSER_LIST *ppUserList);
BOOL LookupSidsAsync(HDPA hSids,
                     LPCTSTR pszServer,
                     LPSECURITYINFO2 psi2,
                     HWND hWndNotify,
                     UINT uMsgNotify,
                     PHANDLE phThread = NULL);
BOOL BuildUserDisplayName(LPTSTR *ppszDisplayName,
                          LPCTSTR pszName,
                          LPCTSTR pszLogonName = NULL);

// Indexes into the SID image list
typedef enum
{
    SID_IMAGE_UNKNOWN = 0,
    SID_IMAGE_COMPUTER,
    SID_IMAGE_GROUP,
    SID_IMAGE_LOCALGROUP,
    SID_IMAGE_USER
} SID_IMAGE_INDEX;

HIMAGELIST LoadImageList(HINSTANCE hInstance, LPCTSTR pszBitmapID);
SID_IMAGE_INDEX GetSidImageIndex(PSID psid, SID_NAME_USE sidType);

BOOL IsStandalone(LPCTSTR pszMachine, PBOOL pbIsDC = NULL);

#if(_WIN32_WINNT < 0x0500)

HRESULT GetUserGroup(HWND       hwndOwner,
                     DWORD      dwFlags,
                     LPCTSTR    pszServer,
                     BOOL       bStandalone,
                     PUSER_LIST *ppUserList);   // Caller must LocalFree this

// Flags for GetUserGroup
#define GU_CONTAINER        0x00000001
#define GU_MULTI_SELECT     0x00000002
#define GU_AUDIT_HLP        0x00000004
#define GU_DC_SERVER        0x00000008

#endif  // _WIN32_WINNT < 0x0500

BOOL IsDACLCanonical(PACL pDacl);
BOOL IsDenyACL(PACL pDacl,
               BOOL fProtected,
               DWORD dwFullControlMask,
               LPDWORD pdwWarning);


//
// Possible SIDs that can be retrieved using QuerySystemSid.
//
enum UI_SystemSid
{
    // Well-known / universal
    UI_SID_World = 0,
    UI_SID_CreatorOwner,
    UI_SID_CreatorGroup,
    UI_SID_Dialup,
    UI_SID_Network,
    UI_SID_Batch,
    UI_SID_Interactive,
    UI_SID_Service,
    UI_SID_AnonymousLogon,
    UI_SID_Proxy,
    UI_SID_EnterpriseDC,
    UI_SID_Self,
    UI_SID_AuthenticatedUser,
    UI_SID_RestrictedCode,
    UI_SID_TerminalServer,
    UI_SID_LocalSystem,
    // Aliases ("BUILTIN")
    UI_SID_Admins,
    UI_SID_Users,
    UI_SID_Guests,
    UI_SID_PowerUsers,
    UI_SID_AccountOps,
    UI_SID_SystemOps,
    UI_SID_PrintOps,
    UI_SID_BackupOps,
    UI_SID_Replicator,
    UI_SID_RasServers,

    // Special value that gives the number of valid UI_SID_* types.
    // Don't add any new types after this value (add them before).
    UI_SID_Count,

    // This special value can be used for initializing enum UI_SystemSid
    // variables with a known unused quantity.  This value should never
    // be passed to QuerySystemSid.
    UI_SID_Invalid = -1
};
#define COUNT_SYSTEM_SID_TYPES          ((int)UI_SID_Count)
#define COUNT_WELL_KNOWN_SYSTEM_SIDS    ((int)UI_SID_Admins)

PSID QuerySystemSid(UI_SystemSid SystemSidType);

#define IsNTAuthority(pSid)             EqualPrefixSid(pSid, QuerySystemSid(UI_SID_LocalSystem))
#define IsAliasSid(pSid)                EqualPrefixSid(pSid, QuerySystemSid(UI_SID_Admins))
#define IsCreatorSid(pSid)              EqualPrefixSid(pSid, QuerySystemSid(UI_SID_CreatorOwner))
#define EqualSystemSid(pSid, uiSid)     EqualSid(pSid, QuerySystemSid(uiSid))

//
// Possible SIDs that can be retrieved using QueryTokenSid.
//
enum UI_TokenSid
{
    UI_TSID_CurrentProcessUser = 0, // Always the logged on user SID
    UI_TSID_CurrentProcessOwner,    // Generally logged on user SID, but sometimes not (e.g. Administrators)
    UI_TSID_CurrentProcessPrimaryGroup,
    UI_TSID_Count,
    UI_TSID_Invalid = -1
};
#define COUNT_TOKEN_SID_TYPES           ((int)UI_TSID_Count)

PSID QueryTokenSid(UI_TokenSid TokenSidType);

#define EqualTokenSid(pSid, uiSid)      EqualSid(pSid, QueryTokenSid(uiSid))

PSID GetAuthenticationID(LPCWSTR pszServer);

int CopyUnicodeString(LPTSTR pszDest, ULONG cchDest, PLSA_UNICODE_STRING pSrc);
int CopyUnicodeString(LPTSTR *ppszResult, PLSA_UNICODE_STRING pSrc);

BOOL IsSameGUID(const GUID *p1, const GUID *p2);
#define IsNullGUID(p)   (!(p) || IsSameGUID((p), &GUID_NULL))

//
//Get the count of inheritable aces in the acl
//
DWORD GetCountOfInheritableAces(PACL pAcl);

DWORD GetCountOfInheritableAces(PSECURITY_DESCRIPTOR pSD);

BOOL IsAclBloated(HWND hDlg, SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD, DWORD dwOrgInheritAceCount, BOOL bShowHelp);
HRESULT MakeBold (HWND hwnd, HFONT * phNewFont);


#endif  // _MISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\dll.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dll.cpp
//
//  Core entry points for the DLL
//
//--------------------------------------------------------------------------

#include "aclpriv.h"


/*----------------------------------------------------------------------------
/ Globals
/----------------------------------------------------------------------------*/

HINSTANCE hModule = NULL;
HINSTANCE g_hGetUserLib = NULL;

UINT UM_SIDLOOKUPCOMPLETE = 0;
UINT g_cfDsSelectionList = 0;
UINT g_cfSidInfoList = 0;


/*-----------------------------------------------------------------------------
/ DllMain
/ -------
/   Main entry point.  We are passed reason codes and assored other
/   information when loaded or closed down.
/
/ In:
/   hInstance = our instance handle
/   dwReason = reason code
/   pReserved = depends on the reason code.
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
STDAPI_(BOOL)
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*pReserved*/)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        hModule = hInstance;
        DebugProcessAttach();
        TraceSetMaskFromRegKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\AclUI"));
#ifndef DEBUG
        DisableThreadLibraryCalls(hInstance);
#endif
        SHFusionInitializeFromModuleID(hInstance, SHFUSION_DEFAULT_RESOURCE_ID);
        RegisterCheckListWndClass();

        UM_SIDLOOKUPCOMPLETE = RegisterWindowMessage(TEXT("ACLUI SID Lookup Complete"));
#if(_WIN32_WINNT >= 0x0500)
        g_cfDsSelectionList = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);
#endif
        g_cfSidInfoList = RegisterClipboardFormat(CFSTR_ACLUI_SID_INFO_LIST);
    	break;

    case DLL_PROCESS_DETACH:
        FreeSidCache();
        if (g_hGetUserLib)
            FreeLibrary(g_hGetUserLib);
        SHFusionUninitialize();
        DebugProcessDetach();
        break;

    case DLL_THREAD_DETACH:
        DebugThreadDetach();
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\misc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       misc.cpp
//
//  This file contains miscellaneous helper functions.
//
//--------------------------------------------------------------------------

#include "aclpriv.h"

/*******************************************************************

    NAME:       GetAceSid

    SYNOPSIS:   Gets pointer to SID from an ACE

    ENTRY:      pAce - pointer to ACE

    EXIT:

    RETURNS:    Pointer to SID if successful, NULL otherwise

    NOTES:

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/

PSID
GetAceSid(PACE_HEADER pAce)
{
    switch (pAce->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
        return (PSID)&((PKNOWN_ACE)pAce)->SidStart;

    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        return (PSID)&((PKNOWN_COMPOUND_ACE)pAce)->SidStart;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        return RtlObjectAceSid(pAce);
    }

    return NULL;
}


/*******************************************************************

    NAME:       LocalAllocSid

    SYNOPSIS:   Copies a SID

    ENTRY:      pOriginal - pointer to SID to copy

    EXIT:

    RETURNS:    Pointer to SID if successful, NULL otherwise

    NOTES:      Caller must free the returned SID with LocalFree

    HISTORY:
        JeffreyS    12-Apr-1999     Created

********************************************************************/

PSID
LocalAllocSid(PSID pOriginal)
{
    PSID pCopy = NULL;
    if (pOriginal && IsValidSid(pOriginal))
    {
        DWORD dwLength = GetLengthSid(pOriginal);
        pCopy = (PSID)LocalAlloc(LMEM_FIXED, dwLength);
        if (NULL != pCopy)
            CopyMemory(pCopy, pOriginal, dwLength);
    }
    return pCopy;
}


/*******************************************************************

    NAME:       DestroyDPA

    SYNOPSIS:   LocalFree's all pointers in a Dynamic Pointer
                Array and then frees the DPA.

    ENTRY:      hList - handle of list to destroy

    EXIT:

    RETURNS:    nothing

    NOTES:

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/

int CALLBACK
_LocalFreeCB(LPVOID pVoid, LPVOID /*pData*/)
{
    if (pVoid)
        LocalFree(pVoid);
    return 1;
}

void
DestroyDPA(HDPA hList)
{
    if (hList != NULL)
        DPA_DestroyCallback(hList, _LocalFreeCB, 0);
}



/*******************************************************************

    NAME:       GetLSAConnection

    SYNOPSIS:   Wrapper for LsaOpenPolicy

    ENTRY:      pszServer - the server on which to make the connection

    EXIT:

    RETURNS:    LSA_HANDLE if successful, NULL otherwise

    NOTES:

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/

LSA_HANDLE
GetLSAConnection(LPCTSTR pszServer, DWORD dwAccessDesired)
{
    LSA_HANDLE hPolicy = NULL;
    LSA_UNICODE_STRING uszServer = {0};
    LSA_UNICODE_STRING *puszServer = NULL;
    LSA_OBJECT_ATTRIBUTES oa;
    SECURITY_QUALITY_OF_SERVICE sqos;

    sqos.Length = SIZEOF(sqos);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = FALSE;

    InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
    oa.SecurityQualityOfService = &sqos;

    if (pszServer &&
        *pszServer &&
        RtlCreateUnicodeString(&uszServer, pszServer))
    {
        puszServer = &uszServer;
    }

    LsaOpenPolicy(puszServer, &oa, dwAccessDesired, &hPolicy);

    if (puszServer)
        RtlFreeUnicodeString(puszServer);

    return hPolicy;
}


/*******************************************************************

    NAME:       LookupSid

    SYNOPSIS:   Gets the qualified account name for a given SID

    ENTRY:      pszServer - the server on which to do the lookup
                pSid - the SID to lookup

    EXIT:       *ppszName contains the account name. This buffer
                must be freed by the caller with LocalFree.

                *pSidType contains the SID type. pSidType is optional.

    RETURNS:    TRUE if successful, FALSE otherwise

    NOTES:

    HISTORY:
        JeffreyS    08-Oct-1996     Created
        JeffreyS    16-Jan-1998     Converted to HDPA (multiple lookup)

********************************************************************/

BOOL
LookupSids(HDPA hSids, LPCTSTR pszServer, LPSECURITYINFO2 psi2, PUSER_LIST *ppUserList)
{
    PSIDCACHE pSidCache;

    if (NULL == hSids)
        return FALSE;

    if (ppUserList != NULL)
        *ppUserList = NULL;

    pSidCache = GetSidCache();

    if (NULL != pSidCache)
    {
        BOOL bRet = pSidCache->LookupSids(hSids, pszServer, psi2, ppUserList);
        pSidCache->Release();
        return bRet;
    }

    return FALSE;
}

BOOL
LookupSid(PSID pSid, LPCTSTR pszServer, LPSECURITYINFO2 psi2, PUSER_LIST *ppUserList)
{
    BOOL fResult;
    HDPA hSids = NULL;

    if (NULL == pSid)
        return FALSE;

    hSids = DPA_Create(1);

    if (NULL == hSids)
        return FALSE;

    DPA_AppendPtr(hSids, pSid);

    fResult = LookupSids(hSids, pszServer, psi2, ppUserList);

    if (NULL != hSids)
        DPA_Destroy(hSids);

    return fResult;
}

// Private data structure used by LookupSidsAsync to pass
// data needed by the thread
typedef struct _LOOKUPSIDSDATA
{
    HDPA hSids;
    LPTSTR pszServer;
    HWND hWndNotify;
    UINT uMsgNotify;
} LOOKUPSIDSDATA, *PLOOKUPSIDSDATA;


DWORD WINAPI
_LookupSidsAsyncProc(LPVOID pv)
{
    PLOOKUPSIDSDATA pdata = (PLOOKUPSIDSDATA)pv;

    if (pdata)
    {
        PSIDCACHE pSidCache = GetSidCache();

        if (NULL != pSidCache)
        {
            pSidCache->LookupSidsAsync(pdata->hSids,
                                       pdata->pszServer,
                                       NULL,
                                       pdata->hWndNotify,
                                       pdata->uMsgNotify);
            pSidCache->Release();
        }

        PostMessage(pdata->hWndNotify, pdata->uMsgNotify, 0, 0);

        DestroyDPA(pdata->hSids);
        LocalFreeString(&pdata->pszServer);
        LocalFree(pdata);
    }

    FreeLibraryAndExitThread(GetModuleHandle(c_szDllName), 0);
    return 0;
}

BOOL
LookupSidsAsync(HDPA hSids,
                LPCTSTR pszServer,
                LPSECURITYINFO2 psi2,
                HWND hWndNotify,
                UINT uMsgNotify,
                PHANDLE phThread)
{
    PLOOKUPSIDSDATA pdata;

    if (phThread)
        *phThread = NULL;

    if (NULL == hSids)
        return FALSE;

    if (psi2)
    {
        // Should marshal psi2 into a stream and do this on the
        // other thread.  Well No one has implemented psi2 so its fine.
        BOOL bResult = LookupSids(hSids, pszServer, psi2, NULL);
        PostMessage(hWndNotify, uMsgNotify, 0, 0);
        return bResult;
    }

    //
    // Copy all of the data so the thread can be abandoned if necessary
    //
    pdata = (PLOOKUPSIDSDATA)LocalAlloc(LPTR, SIZEOF(LOOKUPSIDSDATA));
    if (pdata)
    {
        int cSids;
        int i;
        HINSTANCE hInstThisDll;
        DWORD dwThreadId;
        HANDLE hThread;

        cSids = DPA_GetPtrCount(hSids);
        pdata->hSids = DPA_Create(cSids);

        if (!pdata->hSids)
        {
            LocalFree(pdata);
            return FALSE;
        }

        for (i = 0; i < cSids; i++)
        {
            PSID p2 = LocalAllocSid((PSID)DPA_FastGetPtr(hSids, i));
            if (p2)
            {
                DPA_AppendPtr(pdata->hSids, p2);
            }
        }

        if (pszServer)
            LocalAllocString(&pdata->pszServer, pszServer);

        pdata->hWndNotify = hWndNotify;
        pdata->uMsgNotify = uMsgNotify;

        // Give the thread we are about to create a ref to the dll,
        // so that the dll will remain for the lifetime of the thread
        hInstThisDll = LoadLibrary(c_szDllName);

        hThread = CreateThread(NULL,
                               0,
                               _LookupSidsAsyncProc,
                               pdata,
                               NULL,
                               &dwThreadId);
        if (hThread != NULL)
        {
            if (phThread)
                *phThread = hThread;
            else
                CloseHandle(hThread);
            return TRUE;
        }
        else
        {
            // Thread creation has failed; clean up
            DestroyDPA(pdata->hSids);
            LocalFreeString(&pdata->pszServer);
            LocalFree(pdata);
            FreeLibrary(hInstThisDll);
        }
    }
    return FALSE;
}

BOOL
BuildUserDisplayName(LPTSTR *ppszDisplayName,
                     LPCTSTR pszName,
                     LPCTSTR pszLogonName)
{
    TCHAR szDisplayName[MAX_PATH];

    if (NULL == ppszDisplayName || NULL == pszName)
        return FALSE;

    *ppszDisplayName = NULL;

    if (NULL != pszLogonName && *pszLogonName)
    {
        return (BOOL)FormatStringID(ppszDisplayName,
                                    ::hModule,
                                    IDS_FMT_USER_DISPLAY,
                                    pszName,
                                    pszLogonName);
    }

    return SUCCEEDED(LocalAllocString(ppszDisplayName, pszName));
}


/*******************************************************************

    NAME:       LoadImageList

    SYNOPSIS:   Creates an image list from a bitmap resource

    ENTRY:      hInstance - the bitmap lives here
                pszBitmapID - resource ID of the bitmap

    EXIT:

    RETURNS:    HIMAGELIST if successful, NULL otherwise

    NOTES:
        In order to calculate the number of images, it is assumed
        that the width and height of a single image are the same.

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/

HIMAGELIST
LoadImageList(HINSTANCE hInstance, LPCTSTR pszBitmapID)
{
    HIMAGELIST himl = NULL;
    HBITMAP hbm = LoadBitmap(hInstance, pszBitmapID);

    if (hbm != NULL)
    {
        BITMAP bm;
        GetObject(hbm, SIZEOF(bm), &bm);

        himl = ImageList_Create(bm.bmHeight,    // height == width
                                bm.bmHeight,
                                ILC_COLOR | ILC_MASK,
                                bm.bmWidth / bm.bmHeight,
                                0);  // don't need to grow
        if (himl != NULL)
            ImageList_AddMasked(himl, hbm, CLR_DEFAULT);

        DeleteObject(hbm);
    }

    return himl;
}


/*******************************************************************

    NAME:       GetSidImageIndex

    SYNOPSIS:   Gets the image index for the given SID type

    ENTRY:      sidType - type of SID
                sidSys - well-known group type
                fRemoteUser - TRUE if SID is a user on a remote system

    EXIT:

    RETURNS:    index into image list

    NOTES:

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/

SID_IMAGE_INDEX
GetSidImageIndex(PSID psid,
                 SID_NAME_USE sidType)
{
    SID_IMAGE_INDEX idBitmap;

    switch (sidType)
    {
    case SidTypeUser:
        idBitmap = SID_IMAGE_USER;
        break;

    case SidTypeAlias:
    case SidTypeGroup:
    case SidTypeWellKnownGroup:
        idBitmap = SID_IMAGE_GROUP;
        break;

#if(_WIN32_WINNT >= 0x0500)
    case SidTypeComputer:
        idBitmap = SID_IMAGE_COMPUTER;
        break;
#endif

    default:
        idBitmap = SID_IMAGE_UNKNOWN;
        break;
    }

    return idBitmap;
}

#if(_WIN32_WINNT >= 0x0500)

#include <dsrole.h>
BOOL IsStandalone(LPCTSTR pszMachine, PBOOL pbIsDC)
{
    BOOL bStandalone = TRUE;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pDsRole = NULL;

    //
    // Find out if target machine is a standalone machine or joined to
    // an NT domain.
    //

    __try
    {
        if (pbIsDC)
            *pbIsDC = FALSE;

        DsRoleGetPrimaryDomainInformation(pszMachine,
                                          DsRolePrimaryDomainInfoBasic,
                                          (PBYTE*)&pDsRole);
    }
    __finally
    {
    }

    if (NULL != pDsRole)
    {
        if (pDsRole->MachineRole == DsRole_RoleStandaloneWorkstation ||
            pDsRole->MachineRole == DsRole_RoleStandaloneServer)
        {
            bStandalone = TRUE;
        }
        else
            bStandalone = FALSE;

        if (pbIsDC)
        {
            if (pDsRole->MachineRole == DsRole_RolePrimaryDomainController ||
                pDsRole->MachineRole == DsRole_RoleBackupDomainController)
            {
                *pbIsDC = TRUE;
            }
        }

        DsRoleFreeMemory(pDsRole);
    }

    return bStandalone;
}

#else   // _WIN32_WINNT < 0x0500

BOOL IsStandalone(LPCTSTR pszMachine, PBOOL pbIsDC)
{
    BOOL bStandalone = FALSE;

    //implement an NT4 version of this? There is no request for this
    //so no need.
    if (pbIsDC)
        *pbIsDC = FALSE;

    return bStandalone;
}


//
// Stuff used by GetUserGroup below
//
#include <getuser.h>

const TCHAR c_szGetUserLib[]        = TEXT("netui2.dll");
const char c_szOpenUB[]             = "OpenUserBrowser";
const char c_szEnumUBSelection[]    = "EnumUserBrowserSelection";
const char c_szCloseUB[]            = "CloseUserBrowser";

typedef HUSERBROW (WINAPI *PFN_UB_OPEN)(LPUSERBROWSER);
typedef BOOL (WINAPI *PFN_UB_ENUM)(HUSERBROW, LPUSERDETAILS, LPDWORD);
typedef BOOL (WINAPI *PFN_UB_CLOSE)(HUSERBROW);

PFN_UB_OPEN pfnUBOpen;
PFN_UB_ENUM pfnUBEnum;
PFN_UB_CLOSE pfnUBClose;

#ifndef HC_SED_USER_BROWSER_DIALOG
#define HC_SED_USER_BROWSER_DIALOG          4300
#define HC_SED_USER_BROWSER_AUDIT_DLG       4325
#endif


/*******************************************************************

    NAME:       GetUserGroup

    SYNOPSIS:   Invokes the old NT4 user/group picker dialog

    ENTRY:      hwndOwner - owner window
                dwFlags - indicate multi-select, etc.
                pszServer - initial focus of dialog
                ppUserList - out parameter

    EXIT:       *ppUserList contains a list of USER_INFO structures

    RETURNS:    HRESULT

    NOTES:      *ppUserList must be LocalFree'd by the caller.

    HISTORY:
        JeffreyS    16-Jan-1998     Created

********************************************************************/

HRESULT
GetUserGroup(HWND       hwndOwner,
             DWORD      dwFlags,
             LPCTSTR    pszServer,
             BOOL       /*bStandalone*/,
             PUSER_LIST *ppUserList)
{
    HRESULT hr = S_OK;
    HUSERBROW hUserBrowser = NULL;
    USERBROWSER ub;
    DWORD dwUDLength = 1024;
    PUSERDETAILS pUserDetails = NULL;
    PSID_CACHE_ENTRY pEntry;
    HDPA hEntryList = NULL;
    PSIDCACHE pSidCache = NULL;

    TraceEnter(TRACE_MISC, "GetUserGroup");
    TraceAssert(ppUserList != NULL);

    if (!ppUserList)
        TraceLeaveResult(E_INVALIDARG);

    *ppUserList = NULL;

    if (!g_hGetUserLib)
    {
        g_hGetUserLib = LoadLibrary(c_szGetUserLib);
        if (g_hGetUserLib == NULL)
            ExitGracefully(hr, E_FAIL, "Unable to load netui2.dll");

        pfnUBOpen = (PFN_UB_OPEN)GetProcAddress(g_hGetUserLib, c_szOpenUB);
        pfnUBEnum = (PFN_UB_ENUM)GetProcAddress(g_hGetUserLib, c_szEnumUBSelection);
        pfnUBClose = (PFN_UB_CLOSE)GetProcAddress(g_hGetUserLib, c_szCloseUB);

        if (!pfnUBOpen || !pfnUBEnum || !pfnUBClose)
        {
            FreeLibrary(g_hGetUserLib);
            g_hGetUserLib = NULL;
            ExitGracefully(hr, E_FAIL, "Unable to link to netui2.dll");
        }
    }

    //
    // Create the global sid cache object, if necessary
    //
    pSidCache = GetSidCache();

    if (pSidCache == NULL)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to create SID cache");

    ub.ulStructSize = sizeof(ub);
    ub.fUserCancelled = FALSE;
    ub.fExpandNames = TRUE;
    ub.hwndOwner = hwndOwner;
    ub.pszTitle = NULL;
    ub.pszInitialDomain = (LPTSTR)pszServer;
    ub.Flags = USRBROWS_SHOW_ALL | USRBROWS_INCL_ALL;
    ub.ulHelpContext = HC_SED_USER_BROWSER_DIALOG;
    ub.pszHelpFileName = (LPWSTR)c_szAcluiHelpFile;

#ifdef USRBROWS_INCL_RESTRICTED
    ub.Flags &= ~USRBROWS_INCL_RESTRICTED;  // NT5 only
#endif

    if (!(dwFlags & GU_CONTAINER))
        ub.Flags &= ~USRBROWS_INCL_CREATOR;

    if (!(dwFlags & GU_MULTI_SELECT))
        ub.Flags |= USRBROWS_SINGLE_SELECT;

    if (dwFlags & GU_AUDIT_HLP)
        ub.ulHelpContext = HC_SED_USER_BROWSER_AUDIT_DLG;

    //
    // Open the dialog
    //
    hUserBrowser = (*pfnUBOpen)(&ub);
    if (hUserBrowser == NULL)
        ExitGracefully(hr, E_FAIL, "OpenUserBrowser returned false");

    pUserDetails = (PUSERDETAILS)LocalAlloc(LPTR, dwUDLength);
    if (!pUserDetails)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to allocate UserDetails buffer");

    hEntryList = DPA_Create(4);
    if (!hEntryList)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to create SID cache entry list");

    //
    // Enumerate the results
    //
    for (;;)
    {
        if (!(*pfnUBEnum)(hUserBrowser, pUserDetails, &dwUDLength))
        {
            if (ERROR_INSUFFICIENT_BUFFER == GetLastError())
            {
                // The details buffer wasn't big enough, reallocate it
                LocalFree(pUserDetails);
                pUserDetails = (PUSERDETAILS)LocalAlloc(LPTR, dwUDLength);
                if (pUserDetails == NULL)
                    break;

                if (!(*pfnUBEnum)(hUserBrowser, pUserDetails, &dwUDLength))
                    break;
            }
            else // probably ERROR_NO_MORE_ITEMS
                break;
        }

        //
        // See if it's already in the cache
        //
        pEntry = pSidCache->FindSid(pUserDetails->psidUser);

        if (NULL == pEntry)
        {
            //
            // Not in the cache, add it
            //
            TCHAR szAccountName[MAX_PATH];
            TCHAR szDomainName[MAX_PATH];
            ULONG nAccountLength;

            lstrcpy(szAccountName, pUserDetails->pszAccountName);
            lstrcpy(szDomainName, pUserDetails->pszDomainName);

            switch (pUserDetails->UserType)
            {
            case SidTypeUnknown:
            case SidTypeInvalid:
                // Load unknown account string
                LoadString(::hModule, IDS_SID_UNKNOWN, szAccountName, ARRAYSIZE(szAccountName));
                break;

            case SidTypeAlias:
                //if (IsAliasSid(pSid))
                //    szDomainName[0] = TEXT('\0');   // The domain is "BUILTIN"
                break;

            case SidTypeDeletedAccount:
                // Load deleted account string
                LoadString(::hModule, IDS_SID_DELETED, szAccountName, ARRAYSIZE(szAccountName));
                break;

            case SidTypeWellKnownGroup:
                // Don't include the domain for a well-known group
                szDomainName[0] = TEXT('\0');
                break;
            }

            //
            // Build NT4 "domain\user" style name (logon name)
            //
            if (szDomainName[0] != TEXT('\0'))
            {
                lstrcat(szDomainName, TEXT("\\"));
                lstrcat(szDomainName, szAccountName);
            }

            LPCTSTR pszCommonName = pUserDetails->pszFullName;
            if (!pszCommonName || !*pszCommonName)
                pszCommonName = pUserDetails->pszAccountName;

            pEntry = pSidCache->MakeEntry(pUserDetails->psidUser,
                                          pUserDetails->UserType,
                                          pszCommonName,
                                          szDomainName);
            if (NULL != pEntry)
                pSidCache->AddEntry(pEntry);
        }

        if (NULL != pEntry)
            DPA_AppendPtr(hEntryList, pEntry);
    }

    //
    // Build return list
    //
    if (DPA_GetPtrCount(hEntryList))
        pSidCache->BuildUserList(hEntryList, pszServer, ppUserList);

    if (NULL == *ppUserList)
        hr = E_FAIL;

exit_gracefully:

    if (pSidCache)
        pSidCache->Release();

    if (NULL != hUserBrowser)
        (*pfnUBClose)(hUserBrowser);

    if (pUserDetails != NULL)
        LocalFree(pUserDetails);

    DPA_Destroy(hEntryList);

    TraceLeaveResult(hr);
}

#endif  // _WIN32_WINNT < 0x0500


/*******************************************************************

    NAME:       IsDACLCanonical

    SYNOPSIS:   Checks a DACL for canonical ordering

    ENTRY:      pDacl - points to DACL to check

    EXIT:

    RETURNS:    Nonzero if DACL is in canonical order, zero otherwise

    NOTES:

    HISTORY:
        JeffreyS    08-Oct-1996     Created
        JeffreyS    03-Oct-1997     Make object aces same as non-object aces

********************************************************************/

enum ACELEVEL
{
    alNonInheritAccessDenied,
    alNonInheritAccessAllowed,
    alInheritedAces,
};

BOOL
IsDACLCanonical(PACL pDacl)
{
    PACE_HEADER pAce;
    ACELEVEL currentAceLevel;
    DWORD dwAceCount;

    if (pDacl == NULL)
        return TRUE;

    currentAceLevel = alNonInheritAccessDenied;
    dwAceCount = pDacl->AceCount;

    if (dwAceCount == 0)
        return TRUE;

    for (pAce = (PACE_HEADER)FirstAce(pDacl);
         dwAceCount > 0;
         --dwAceCount, pAce = (PACE_HEADER)NextAce(pAce))
    {
        ACELEVEL aceLevel;

        //
        // NOTE: We do not skip INHERIT_ONLY aces because we want them in
        // canonical order too.
        //

        if (pAce->AceFlags & INHERITED_ACE)
        {
            aceLevel = alInheritedAces;      // don't check order here
        }
        else
        {
            switch(pAce->AceType)
            {
            case ACCESS_DENIED_ACE_TYPE:
            case ACCESS_DENIED_OBJECT_ACE_TYPE:
                aceLevel = alNonInheritAccessDenied;
                break;

            case ACCESS_ALLOWED_ACE_TYPE:
            case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                aceLevel = alNonInheritAccessAllowed;
                break;

            default:
                return FALSE;
            }
        }

        //
        // If the ace type is less than the level we are currently at,
        // then it is not canonical.
        //
        if (aceLevel < currentAceLevel)
            return FALSE;

        //
        // Update the current ace level.
        //
        currentAceLevel = aceLevel;
    }

    //
    // If we get here, then the DACL is in canonical order.
    //
    return TRUE;
}


/*******************************************************************

    NAME:       IsDenyACL

    SYNOPSIS:   Checks a DACL for Deny ACEs.  Also looks for "Deny
                All" ACEs.

    ENTRY:      pDacl - points to DACL to check

    EXIT:       *pdwWarning is 0, IDS_PERM_DENY, or IDS_PERM_DENY_ALL 

    RETURNS:    Nonzero if DACL contains any Deny ACEs, zero otherwise

    NOTES:

    HISTORY:
        JeffreyS    05-Sep-1997     Created

********************************************************************/

BOOL
IsDenyACL(PACL pDacl,
          BOOL fProtected,
          DWORD dwFullControlMask,
          LPDWORD pdwWarning)
{
    DWORD dwWarning = 0;

    TraceEnter(TRACE_MISC, "IsDenyACL");

    // NULL DACL implies "Allow Everyone Full Control"
    if (pDacl == NULL)
        goto exit_gracefully;

    // Check for empty DACL (no access to anyone)
    if (pDacl->AceCount == 0)
    {
        if (fProtected)
            dwWarning = IDS_PERM_DENY_ALL;
        // else the object will inherit permissions from the parent.
    }
    else
    {
        PACE_HEADER pAce;
        int iEntry;

        // Iterate through the ACL looking for "Deny All"
        for (iEntry = 0, pAce = (PACE_HEADER)FirstAce(pDacl);
             iEntry < pDacl->AceCount;
             iEntry++, pAce = (PACE_HEADER)NextAce(pAce))
        {
            if (pAce->AceType != ACCESS_DENIED_ACE_TYPE &&
                pAce->AceType != ACCESS_DENIED_OBJECT_ACE_TYPE)
            {
                // Assuming the ACL is in canonical order, we can
                // stop as soon as we find something that isn't
                // a Deny ACE.  (Deny ACEs come first)
                break;
            }

            // Found a Deny ACE
            dwWarning = IDS_PERM_DENY;

            // Check for "Deny Everyone Full Control". Don't look
            // for ACCESS_DENIED_OBJECT_ACE_TYPE here since Object
            // aces don't have as wide an effect as normal aces.
            if (pAce->AceType == ACCESS_DENIED_ACE_TYPE &&
                ((PKNOWN_ACE)pAce)->Mask == dwFullControlMask &&
                EqualSid(GetAceSid(pAce), QuerySystemSid(UI_SID_World)))
            {
                // Found "Deny All"
                dwWarning = IDS_PERM_DENY_ALL;
                break;
            }
        }
    }

exit_gracefully:

    if (pdwWarning != NULL)
        *pdwWarning = dwWarning;

    TraceLeaveValue(dwWarning != 0);
}


/*******************************************************************

    NAME:       QuerySystemSid

    SYNOPSIS:   Retrieves the requested SID

    ENTRY:      SystemSidType - Which SID to retrieve

    EXIT:

    RETURNS:    PSID if successful, NULL otherwise

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/

//
// Global array of static system SIDs, corresponding to UI_SystemSid
//
const struct
{
    SID sid;            // contains 1 subauthority
    DWORD dwSubAuth[1]; // we currently need at most 2 subauthorities
} g_StaticSids[COUNT_SYSTEM_SID_TYPES] =
{
    {{SID_REVISION,1,SECURITY_WORLD_SID_AUTHORITY,  {SECURITY_WORLD_RID}},              {0}                             },
    {{SID_REVISION,1,SECURITY_CREATOR_SID_AUTHORITY,{SECURITY_CREATOR_OWNER_RID}},      {0}                             },
    {{SID_REVISION,1,SECURITY_CREATOR_SID_AUTHORITY,{SECURITY_CREATOR_GROUP_RID}},      {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_DIALUP_RID}},             {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_NETWORK_RID}},            {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_BATCH_RID}},              {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_INTERACTIVE_RID}},        {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_SERVICE_RID}},            {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_ANONYMOUS_LOGON_RID}},    {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_PROXY_RID}},              {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_ENTERPRISE_CONTROLLERS_RID}},{0}                          },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_PRINCIPAL_SELF_RID}},     {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_AUTHENTICATED_USER_RID}}, {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_RESTRICTED_CODE_RID}},    {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_TERMINAL_SERVER_RID}},    {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_LOCAL_SYSTEM_RID}},       {0}                             },
    {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_ADMINS}       },
    {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_USERS}        },
    {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_GUESTS}       },
    {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_POWER_USERS}  },
    {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_ACCOUNT_OPS}  },
    {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_SYSTEM_OPS}   },
    {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_PRINT_OPS}    },
    {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_BACKUP_OPS}   },
    {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_REPLICATOR}   },
    {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_RAS_SERVERS}  },
};

PSID
QuerySystemSid(UI_SystemSid SystemSidType)
{
    if (SystemSidType == UI_SID_Invalid || SystemSidType >= UI_SID_Count)
        return NULL;

    return (PSID)&g_StaticSids[SystemSidType];
}


//
// Global array of cached token SIDs
//
struct
{
    SID sid;            // SID contains 1 subauthority
    DWORD dwSubAuth[SID_MAX_SUB_AUTHORITIES - 1];
} g_TokenSids[COUNT_TOKEN_SID_TYPES] = {0};

PSID
QueryTokenSid(UI_TokenSid TokenSidType)
{
    if (TokenSidType == UI_TSID_Invalid || TokenSidType >= UI_TSID_Count)
        return NULL;

    if (0 == *GetSidSubAuthorityCount((PSID)&g_TokenSids[TokenSidType]))
    {
        HANDLE hProcessToken;

        // Get the current process's user's SID
        if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcessToken))
        {
            BYTE buffer[sizeof(TOKEN_USER) + sizeof(g_TokenSids[0])];
            ULONG cbBuffer = sizeof(buffer);

            switch (TokenSidType)
            {
            case UI_TSID_CurrentProcessUser:
                if (GetTokenInformation(hProcessToken,
                                        TokenUser,
                                        buffer,
                                        cbBuffer,
                                        &cbBuffer))
                {
                    PTOKEN_USER ptu = (PTOKEN_USER)buffer;
                    CopyMemory(&g_TokenSids[UI_TSID_CurrentProcessUser],
                               ptu->User.Sid,
                               GetLengthSid(ptu->User.Sid));
                }
                break;

            case UI_TSID_CurrentProcessOwner:
                if (GetTokenInformation(hProcessToken,
                                        TokenOwner,
                                        buffer,
                                        cbBuffer,
                                        &cbBuffer))
                {
                    PTOKEN_OWNER pto = (PTOKEN_OWNER)buffer;
                    CopyMemory(&g_TokenSids[UI_TSID_CurrentProcessOwner],
                               pto->Owner,
                               GetLengthSid(pto->Owner));
                }
                break;

            case UI_TSID_CurrentProcessPrimaryGroup:
                if (GetTokenInformation(hProcessToken,
                                        TokenPrimaryGroup,
                                        buffer,
                                        cbBuffer,
                                        &cbBuffer))
                {
                    PTOKEN_PRIMARY_GROUP ptg = (PTOKEN_PRIMARY_GROUP)buffer;
                    CopyMemory(&g_TokenSids[UI_TSID_CurrentProcessPrimaryGroup],
                               ptg->PrimaryGroup,
                               GetLengthSid(ptg->PrimaryGroup));
                }
                break;
            }
            CloseHandle(hProcessToken);
        }

        if (0 == *GetSidSubAuthorityCount((PSID)&g_TokenSids[TokenSidType]))
            return NULL;
    }

    return (PSID)&g_TokenSids[TokenSidType];
}


/*******************************************************************

    NAME:       GetAuthenticationID

    SYNOPSIS:   Retrieves the SID associated with the credentials
                currently being used for network access.
                (runas /netonly credentials)

    ENTRY:      pszServer = server on which to lookup the account.
                            NULL indicates local system.

    EXIT:

    RETURNS:    PSID if successful, NULL otherwise.  Caller must
                free with LocalFree.

    HISTORY:
        JeffreyS    05-Aug-1999     Created

********************************************************************/
PSID
GetAuthenticationID(LPCWSTR pszServer)
{
    PSID pSid = NULL;
    HANDLE hLsa;
    NTSTATUS Status;

    //
    // These LSA calls are delay-loaded from secur32.dll using the linker's
    // delay-load mechanism.  Therefore, wrap with an exception handler.
    //
    __try
    {
        Status = LsaConnectUntrusted(&hLsa);

        if (Status == 0)
        {
            NEGOTIATE_CALLER_NAME_REQUEST Req = {0};
            PNEGOTIATE_CALLER_NAME_RESPONSE pResp;
            ULONG cbSize;
            NTSTATUS SubStatus;

            Req.MessageType = NegGetCallerName;

            Status = LsaCallAuthenticationPackage(
                            hLsa,
                            0,
                            &Req,
                            sizeof(Req),
                            (void**)&pResp,
                            &cbSize,
                            &SubStatus);

            if ((Status == 0) && (SubStatus == 0))
            {
                BYTE sid[sizeof(SID) + (SID_MAX_SUB_AUTHORITIES - 1)*sizeof(DWORD)];
                PSID psid = (PSID)sid;
                DWORD cbSid = sizeof(sid);
                WCHAR szDomain[MAX_PATH];
                DWORD cchDomain = ARRAYSIZE(szDomain);
                SID_NAME_USE sidType;

                if (LookupAccountNameW(pszServer,
                                       pResp->CallerName,
                                       psid,
                                       &cbSid,
                                       szDomain,
                                       &cchDomain,
                                       &sidType))
                {
                    pSid = LocalAllocSid(psid);
                }

                LsaFreeReturnBuffer(pResp);
            }

            LsaDeregisterLogonProcess(hLsa);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return pSid;
}


/*******************************************************************

    NAME:       CopyUnicodeString

    SYNOPSIS:   Allocates a buffer and copies a string from
                a UNICODE_STRING sources.

    ENTRY:      pszDest - pointer to destination buffer
                cchDest - # of chars in pszDest (bytes for MBCS)
                pSrc - pointer to UNICODE_STRING to copy

    EXIT:       pszDest - containing copy of string

    RETURNS:    # of chars copied, or 0 if not successful.

    NOTES:

    HISTORY:
        JeffreyS    22-Jan-1998     Created

********************************************************************/

int
CopyUnicodeString(LPTSTR pszDest, ULONG cchDest, PLSA_UNICODE_STRING pSrc)
{
    int nResult;
    ULONG cchSrc;

    // If UNICODE, cchDest is size of destination buffer in chars
    // Else (MBCS) cchDest is size of destination buffer in bytes

    if (pszDest == NULL || 0 == cchDest)
        return 0;

    *pszDest = TEXT('\0');

    if (pSrc == NULL || pSrc->Buffer == NULL)
        return 0;

    // Get # of chars in source (not including NULL)
    cchSrc = pSrc->Length/sizeof(WCHAR);

#ifdef UNICODE
    //
    // Note that pSrc->Buffer may not be NULL terminated so we can't just
    // call lstrcpynW with cchDest.  Also, if we call lstrcpynW with cchSrc,
    // it copies the correct # of chars, but then overwrites the last char
    // with NULL giving an incorrect result.  If we call lstrcpynW with
    // (cchSrc+1) it reads past the end of the buffer, which may fault (360251)
    // causing lstrcpynW's exception handler to return 0 without NULL-
    // terminating the resulting string.
    //
    // So let's just copy the bits.
    //
    nResult = min(cchSrc, cchDest);
    CopyMemory(pszDest, pSrc->Buffer, sizeof(WCHAR)*nResult);
    if (nResult == (int)cchDest)
        --nResult;
    pszDest[nResult] = L'\0';
#else
    nResult = WideCharToMultiByte(CP_ACP,
                                  0,
                                  pSrc->Buffer,
                                  cchSrc,
                                  pszDest,
                                  cchDest,
                                  NULL,
                                  NULL);
#endif

    return nResult;
}


/*******************************************************************

    NAME:       CopyUnicodeString

    SYNOPSIS:   Allocates a buffer and copies a string from
                a UNICODE_STRING sources.

    ENTRY:      pSrc - pointer to UNICODE_STRING to copy

    EXIT:       *ppszResult - points to LocalAlloc'd buffer containing copy.

    RETURNS:    # of chars copied, or 0 if not successful.

    NOTES:

    HISTORY:
        JeffreyS    22-Jan-1998     Created

********************************************************************/

int
CopyUnicodeString(LPTSTR *ppszResult, PLSA_UNICODE_STRING pSrc)
{
    int nResult = 0;

    if (NULL == ppszResult)
        return 0;

    *ppszResult = NULL;

    if (NULL != pSrc)
    {
        ULONG cchResult;

        *ppszResult = NULL;

        // Get # of chars in source (including NULL)
        cchResult = pSrc->Length/SIZEOF(WCHAR) + 1;

        // Allocate buffer big enough for either UNICODE or MBCS result
        *ppszResult = (LPTSTR)LocalAlloc(LPTR, cchResult * 2);

        if (*ppszResult)
        {
            nResult = CopyUnicodeString(*ppszResult, cchResult, pSrc);

            if (0 == nResult)
            {
                LocalFree(*ppszResult);
                *ppszResult = NULL;
            }
        }
    }

    return nResult;
}


//
// Test GUIDs safely
//
BOOL IsSameGUID(const GUID *p1, const GUID *p2)
{
    BOOL bResult = FALSE;

    if (!p1) p1 = &GUID_NULL;
    if (!p2) p2 = &GUID_NULL;

    __try
    {
        bResult = InlineIsEqualGUID(*p1, *p2);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return bResult;
}

/*******************************************************************

    NAME:       GetCountOfInheritableAces

    SYNOPSIS:   Get the count of aces in ACL which can be 
				inherited to child objects

    RETURNS:    Count of Aces

********************************************************************/
DWORD GetCountOfInheritableAces(PACL pAcl)
{
	if(!pAcl)
		return 0;

	DWORD dwCount = 0;
	PACE_HEADER pAce = NULL;
	int iEntry = 0;
	for (iEntry = 0, pAce = (PACE_HEADER)FirstAce(pAcl);
         iEntry < pAcl->AceCount;
         iEntry++, pAce = (PACE_HEADER)NextAce(pAce))
	{
			 //
			 //Consider only explicit aces
			 //
			 if((!(pAce->AceFlags & INHERITED_ACE))&&(pAce->AceFlags & (OBJECT_INHERIT_ACE|CONTAINER_INHERIT_ACE)))
				 dwCount++;
	}
	
	return dwCount;
}
/*******************************************************************

    NAME:       GetCountOfInheritableAces

    SYNOPSIS:   Get the count of aces in SACL or DACL which can be 
				inherited to child objects

    RETURNS:    Count of Aces

********************************************************************/
DWORD GetCountOfInheritableAces(SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD)
{
	if(!pSD)
		return 0;
	
	PACL pAcl = NULL;
	BOOL bPresent;
	BOOL bDefault;
	
	if(si & DACL_SECURITY_INFORMATION)
	{
		if(GetSecurityDescriptorDacl(pSD, &bPresent, &pAcl, &bDefault))
		{
			return GetCountOfInheritableAces(pAcl);
		}
	}
	else if(si & SACL_SECURITY_INFORMATION)
	{
		if(GetSecurityDescriptorSacl(pSD, &bPresent, &pAcl, &bDefault))
		{
			return GetCountOfInheritableAces(pAcl);
		}
	}

	return 0;
}

typedef struct AclBloatInfo{
	DWORD dwInheriteAceCount;
	SECURITY_INFORMATION si;
	HFONT hFont;
	BOOL bShowHelp;
}ACL_BLOAT_INFO;

INT_PTR CALLBACK
AclBloatDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            ACL_BLOAT_INFO * pInfo= (ACL_BLOAT_INFO*)lParam;
			ASSERT(pInfo);
			SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pInfo);
			
			//
			//Add a warning icon
			//
			// add the warning icon			
			HICON hWarn = LoadIcon(NULL, IDI_WARNING);
			SendDlgItemMessage(hDlg,  // dialog box window handle 
							   IDC_BLOAT_WARN_ICON,              // icon identifier 
							   STM_SETIMAGE,          // message to send 
							   (WPARAM) IMAGE_ICON,   // image type 
							   (LPARAM) hWarn); // icon handle 


			//
			//Set the title of dialog box
			//
			LPTSTR pszCaption = NULL;
			if(FormatStringID(&pszCaption,
							  ::hModule,
							  pInfo->si & DACL_SECURITY_INFORMATION ? IDS_PERMISSIONS : IDS_AUDITING))
			{
				SetWindowText(hDlg, pszCaption);
				LocalFreeString(&pszCaption);
			}

			//
			//Set the warning message
			//
			UINT cItem = pInfo->dwInheriteAceCount;
			WCHAR buffer[34];
			_itow(cItem,buffer,10);
			if(FormatStringID(&pszCaption,
							  ::hModule,
							  pInfo->si & DACL_SECURITY_INFORMATION ? IDS_ACLBLOAT_NO_LIST_LINE1:IDS_ACLBLOAT_NO_LIST_SACL_LINE1,
							  buffer))
			{
				SetDlgItemText(hDlg, IDC_ACLBLOAT_LINE1, pszCaption);
				LocalFreeString(&pszCaption);
			}

			//
			//make warning bold
			//
			MakeBold(GetDlgItem(hDlg,IDC_ACLB_WARNING), &(pInfo->hFont));

			//
			//Set the line2, hide the Help button and move other buttons.
			//
			if(!pInfo->bShowHelp)
			{
				if(FormatStringID(&pszCaption,
								  ::hModule,
								  pInfo->si & DACL_SECURITY_INFORMATION ? IDS_BLOAT_PERM_LINE2_NOHELP : IDS_BLOAT_AUDIT_LINE2_NOHELP))
				{
					SetDlgItemText(hDlg, IDC_ACLB_LINE3, pszCaption);
					LocalFreeString(&pszCaption);
				}
			
				RECT rcHelp, rcCancel;
				GetWindowRect(GetDlgItem(hDlg, IDHELP), &rcHelp);
				MapWindowPoints(NULL, hDlg, (LPPOINT)&rcHelp, 2);
				GetWindowRect(GetDlgItem(hDlg, IDCANCEL), &rcCancel);
				MapWindowPoints(NULL, hDlg, (LPPOINT)&rcCancel, 2);
				
				//
				//Hide the Help button, Move Cancel to help position 
				//and Ok to Cancel positon.
				//
				ShowWindow(GetDlgItem(hDlg, IDHELP),FALSE);				
				SetWindowPos(GetDlgItem(hDlg, IDCANCEL),
					         NULL,
						     rcHelp.left,
							 rcHelp.top,
							 0,
                             0,
                             SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
				
				SetWindowPos(GetDlgItem(hDlg, IDOK),
					         NULL,
						     rcCancel.left,
							 rcCancel.top,
							 0,
                             0,
                             SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);

			}

            break;
        }

        case WM_COMMAND:
        {
            WORD wControlID = GET_WM_COMMAND_ID(wParam, lParam);
            switch (wControlID)
            {
				case IDOK:
				{	
					ACL_BLOAT_INFO * pInfo = (ACL_BLOAT_INFO *)GetWindowLongPtr(hDlg, DWLP_USER);
					if(pInfo->hFont)
						DeleteObject(pInfo->hFont);
					pInfo->hFont = NULL;
					EndDialog(hDlg, FALSE);
					break;
				}
				case IDCANCEL:
				{
					ACL_BLOAT_INFO * pInfo = (ACL_BLOAT_INFO *)GetWindowLongPtr(hDlg, DWLP_USER);
					if(pInfo->hFont)
						DeleteObject(pInfo->hFont);
					pInfo->hFont = NULL;

					EndDialog(hDlg, TRUE);
					break;
				}

				case IDHELP:
					HtmlHelp(NULL,					
							 L"aclui.chm::/ACLUI_acl_BP.htm",
							 HH_DISPLAY_TOPIC,
							 0);
					return TRUE;				
		
            }
            break;
        }
    }
    return FALSE;
}

//
// This function displays the "An error has occured [Continue] [Cancel]" message
//
// Returns IDOK or IDCANCEL
//
BOOL
IsAclBloated(HWND hWndParent, SECURITY_INFORMATION si, DWORD dwInheritAceCount, int idd, BOOL bShowHelp)
{
	AclBloatInfo info;
	info.dwInheriteAceCount = dwInheritAceCount;
	info.si = si;
	info.hFont = NULL;
	info.bShowHelp = bShowHelp;
    return (BOOL)DialogBoxParam(::hModule,
                               MAKEINTRESOURCE(idd),
                               hWndParent,
                               AclBloatDialogProc,
                               (LPARAM)(&info));
}

BOOL IsAclBloated(HWND hDlg, SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD, DWORD dwOrgInheritAceCount, BOOL bShowHelp)
{
	ASSERT(pSD);
	BOOL fReturn = FALSE;

	DWORD dwNewInheritAceCount = GetCountOfInheritableAces(si, pSD);
	if( ((int)dwNewInheritAceCount - (int)dwOrgInheritAceCount) > ACL_BLOAT_LIMIT )
		fReturn = IsAclBloated(hDlg, 
					           si,
							   dwNewInheritAceCount - dwOrgInheritAceCount,							   
							   si & DACL_SECURITY_INFORMATION ? IDD_BLOAT_NO_LIST : IDD_BLOAT_NO_LIST_SACL,
							   bShowHelp);

	return fReturn;
}

//
//Sets the font style to bold for the hwnd.
//phNewFont gets handle to newFont which
//is to freed after hwnd is destroyed.
//
HRESULT MakeBold (HWND hwnd, HFONT *phNewFont)
{
	HRESULT hr = S_OK;
	HFONT hFont = NULL;
	*phNewFont = NULL;
	LOGFONT LogFont;

	if(!hwnd || !phNewFont)
		return E_POINTER;


	hFont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
	if (!hFont)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		return hr;
	}
    

	if (!GetObject(hFont,sizeof(LOGFONT),(LPVOID)(&LogFont)))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		return hr;
	}

	LogFont.lfWeight = FW_BOLD;

	if (!(*phNewFont = CreateFontIndirect(&LogFont)))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		return hr;
	}

	SendMessage(hwnd,WM_SETFONT,(WPARAM)(*phNewFont),MAKELPARAM(FALSE,0));

	return S_OK;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\owner.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       owner.cpp
//
//  This file contains the implementation of the Owner page.
//
//--------------------------------------------------------------------------

#include "aclpriv.h"
#include "sddl.h"       // ConvertSidToStringSid


//
//  Context Help IDs.
//
const static DWORD aOwnerHelpIDs[] =
{
    IDC_OWN_CURRENTOWNER_STATIC,    IDH_OWN_CURRENTOWNER,
    IDC_OWN_CURRENTOWNER,           IDH_OWN_CURRENTOWNER,
    IDC_OWN_OWNERLIST_STATIC,       IDH_OWN_OWNERLIST,
    IDC_OWN_OWNERLIST,              IDH_OWN_OWNERLIST,
    IDC_OWN_RECURSE,                IDH_OWN_RECURSE,
    IDC_OWN_RESET,                  IDH_OWN_RESET,
    IDC_ACEL_STATIC,                -1,
    0, 0
};

//
// These SIDs are always added to the list of possible owners
//
const static UI_TokenSid g_uiTokenSids[] =
{
    UI_TSID_CurrentProcessUser,
    UI_TSID_CurrentProcessOwner,
    //UI_TSID_CurrentProcessPrimaryGroup,
};


class COwnerPage : public CSecurityPage
{
private:
    PSID    m_psidOriginal;
    PSID    m_psidNetID;
    HANDLE  m_hSidThread;

public:
    COwnerPage(LPSECURITYINFO psi, SI_OBJECT_INFO *psiObjectInfo);
    virtual ~COwnerPage(void);

private:
    virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void InitDlg(HWND hDlg);
    int  AddSid(HWND hOwner, PSID psid, LPCTSTR pszServerName = NULL);
    void OnApply(HWND hDlg, BOOL bClose);
    void OnReset(HWND hDlg);
};


HPROPSHEETPAGE
CreateOwnerPage(LPSECURITYINFO psi, SI_OBJECT_INFO *psiObjectInfo)
{
    HPROPSHEETPAGE hPage = NULL;
    COwnerPage *pPage;

    TraceEnter(TRACE_OWNER, "CreateOwnerPage");

    pPage = new COwnerPage(psi, psiObjectInfo);

    if (pPage)
    {
        hPage = pPage->CreatePropSheetPage(MAKEINTRESOURCE(IDD_OWNER_PAGE));

        if (!hPage)
            delete pPage;
    }

    TraceLeaveValue(hPage);
}


COwnerPage::COwnerPage(LPSECURITYINFO psi, SI_OBJECT_INFO *psiObjectInfo)
: CSecurityPage(psi, SI_PAGE_OWNER), m_psidOriginal(NULL), m_psidNetID(NULL),
  m_hSidThread(NULL)
{
    // Lookup known SIDs asynchronously so the dialog
    // will initialize faster
    HDPA hSids = DPA_Create(ARRAYSIZE(g_uiTokenSids));
    if (hSids)
    {
        USES_CONVERSION;

        LPCWSTR pszServer = NULL;
        if (psiObjectInfo)
            pszServer = psiObjectInfo->pszServerName;

        for (int i = 0; i < ARRAYSIZE(g_uiTokenSids); i++)
            DPA_AppendPtr(hSids, QueryTokenSid(g_uiTokenSids[i]));

        m_psidNetID = GetAuthenticationID(pszServer);
        if (m_psidNetID)
            DPA_AppendPtr(hSids, m_psidNetID);

        LookupSidsAsync(hSids, W2CT(pszServer), m_psi2, NULL, 0, &m_hSidThread);
        DPA_Destroy(hSids);
    }
}


COwnerPage::~COwnerPage(void)
{
    if (m_hSidThread)
        CloseHandle(m_hSidThread);

    if (m_psidOriginal)
        LocalFree(m_psidOriginal);

    if (m_psidNetID)
        LocalFree(m_psidNetID);
}

int
COwnerPage::AddSid(HWND hOwner, PSID psid, LPCTSTR pszServerName)
{
    PUSER_LIST pUserList = NULL;
    SID_NAME_USE sidType = SidTypeUnknown;
    LPCTSTR pszName = NULL;
    LPCTSTR pszLogonName = NULL;
    int iItem = -1;
    int cItems;
    LV_ITEM lvItem;

    TraceEnter(TRACE_OWNER, "COwnerPage::AddSid");
    TraceAssert(!m_bAbortPage);

    if (!psid || !IsValidSid(psid))
        ExitGracefully(iItem, -1, "Bad SID parameter");

    // Get the name for this SID
    if (LookupSid(psid, pszServerName, m_psi2, &pUserList))
    {
        TraceAssert(NULL != pUserList);
        TraceAssert(1 == pUserList->cUsers);

        sidType = pUserList->rgUsers[0].SidType;
        pszName = pUserList->rgUsers[0].pszName;
        pszLogonName = pUserList->rgUsers[0].pszLogonName;
    }

    switch (sidType)
    {
    case SidTypeDomain:
    case SidTypeDeletedAccount:
    case SidTypeInvalid:
    case SidTypeUnknown:
    case SidTypeComputer:
        ExitGracefully(iItem, -1, "SID invalid on target");
        break;
    }

    cItems = ListView_GetItemCount(hOwner);
    lvItem.mask     = LVIF_PARAM;
    lvItem.iSubItem = 0;

    // See if this SID is already in the list
    for (iItem = 0; iItem < cItems; iItem++)
    {
        lvItem.iItem    = iItem;
        lvItem.lParam   = NULL;
        ListView_GetItem(hOwner, &lvItem);

        if (lvItem.lParam && EqualSid(psid, (PSID)lvItem.lParam))
        {
            // This is a hack.  We often see alias sids more than once when
            // filling the list, e.g. BUILTIN\Administrators.  We want to use
            // the version of the name that includes the target domain, if
            // provided.  That is, if pszServerName is non-NULL here, switch
            // to the version of the name that goes with pszServerName.
            if (pszServerName)
            {
                lvItem.mask = LVIF_TEXT;
                lvItem.pszText = NULL;
                if (BuildUserDisplayName(&lvItem.pszText, pszName, pszLogonName)
                    || ConvertSidToStringSid(psid, &lvItem.pszText))
                {
                    ListView_SetItem(hOwner, &lvItem);
                    LocalFreeString(&lvItem.pszText);
                }
            }
            break;
        }
    }

    if (iItem == cItems)
    {
        // The SID doesn't exist in the list.  Add a new entry.

        PSID psidCopy = LocalAllocSid(psid);
        if (psidCopy)
        {
            lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
            lvItem.iItem = 0;
            lvItem.iSubItem = 0;
            lvItem.pszText = NULL;
            if (!BuildUserDisplayName(&lvItem.pszText, pszName, pszLogonName))
                ConvertSidToStringSid(psid, &lvItem.pszText);
            lvItem.iImage = GetSidImageIndex(psid, sidType);
            lvItem.lParam = (LPARAM)psidCopy;

            // Insert principal into list
            iItem = ListView_InsertItem(hOwner, &lvItem);
            LocalFreeString(&lvItem.pszText);
        }
    }

exit_gracefully:

    if (NULL != pUserList)
        LocalFree(pUserList);

    TraceLeaveValue(iItem);
}

void
COwnerPage::InitDlg(HWND hDlg)
{
    TCHAR       szBuffer[MAX_PATH];
    BOOL        bReadOnly;
    HWND        hOwner = GetDlgItem(hDlg, IDC_OWN_OWNERLIST);
    HCURSOR     hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    TraceEnter(TRACE_OWNER, "COwnerPage::InitDlg");

    // Hide the Reset button if it isn't supported.
    if (!(m_siObjectInfo.dwFlags & SI_RESET) &&
        !(m_siObjectInfo.dwFlags & SI_RESET_OWNER))
    {
        ShowWindow(GetDlgItem(hDlg, IDC_OWN_RESET), SW_HIDE);
    }

    // Hide the Recurse checkbox if it isn't supported.
    if ((m_siObjectInfo.dwFlags & (SI_OWNER_RECURSE | SI_CONTAINER)) != (SI_OWNER_RECURSE | SI_CONTAINER))
    {
        m_siObjectInfo.dwFlags &= ~SI_OWNER_RECURSE;
        HWND hwndRecurse = GetDlgItem(hDlg, IDC_OWN_RECURSE);
        ShowWindow(hwndRecurse, SW_HIDE);
        EnableWindow(hwndRecurse, FALSE);
    }

    if (m_bAbortPage)
    {
        //
        // Disable everything
        //
        bReadOnly = TRUE;
    }
    else
    {
        // Create & set the image list for the listview
        ListView_SetImageList(hOwner,
                              LoadImageList(::hModule, MAKEINTRESOURCE(IDB_SID_ICONS)),
                              LVSIL_SMALL);

        //
        // Add the "Name" column (the only column on this page)
        //
        RECT rc;
        GetClientRect(hOwner, &rc);

        LoadString(::hModule, IDS_NAME, szBuffer, ARRAYSIZE(szBuffer));

        LV_COLUMN col;
        col.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
        col.fmt = LVCFMT_LEFT;
        col.pszText = szBuffer;
        col.iSubItem = 0;
        col.cx = rc.right;
        ListView_InsertColumn(hOwner, 0, &col);


        //
        // Make a copy of the current owner sid
        //
        PSECURITY_DESCRIPTOR pSD = NULL;

        HRESULT hr = m_psi->GetSecurity(OWNER_SECURITY_INFORMATION, &pSD, FALSE);
        if (pSD)
        {
            PSID psidOwner = NULL;
            BOOL bDefaulted;

            GetSecurityDescriptorOwner(pSD, &psidOwner, &bDefaulted);

            if (psidOwner)
            {
                UINT iLength = GetLengthSid(psidOwner);
                m_psidOriginal = LocalAlloc(LPTR, iLength);
                if (m_psidOriginal)
                    CopyMemory(m_psidOriginal, psidOwner, iLength);
            }
            LocalFree(pSD);
        }

        // Test for writeability
        bReadOnly = !!(m_siObjectInfo.dwFlags & SI_OWNER_READONLY);
    } // !m_bAbortPage

    //
    // Iterate through the groups on this process's token looking for
    // the SE_GROUP_OWNER attribute.
    //
    if (!bReadOnly)
    {
        HANDLE hProcessToken = NULL;

        //
        // Wait for the known SIDs to be resolved so we don't try
        // to look them up twice.
        //
        if (m_hSidThread)
        {
            WaitForSingleObject(m_hSidThread, INFINITE);
            CloseHandle(m_hSidThread);
            m_hSidThread = NULL;
        }

        if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcessToken))
        {
            // Allocate a buffer for the TOKEN_GROUPS information
            ULONG  cbBuffer = 1024; // start with 1k
            LPVOID pBuffer = LocalAlloc(LPTR, cbBuffer);

            if (pBuffer)
            {
                if (!GetTokenInformation(hProcessToken,
                                         TokenGroups,
                                         pBuffer,
                                         cbBuffer,
                                         &cbBuffer))
                {
                    LocalFree(pBuffer);
                    pBuffer = NULL;

                    if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                    {
                        pBuffer = LocalAlloc(LPTR, cbBuffer);// size returned above
                        if (pBuffer && !GetTokenInformation(hProcessToken,
                                                            TokenGroups,
                                                            pBuffer,
                                                            cbBuffer,
                                                            &cbBuffer))
                        {
                            LocalFree(pBuffer);
                            pBuffer = NULL;
                        }
                    }
                }

                if (pBuffer)
                {
                    PTOKEN_GROUPS ptg = (PTOKEN_GROUPS)pBuffer;
                    for (ULONG i = 0; i < ptg->GroupCount; i++)
                    {
                        DWORD dwAttr = ptg->Groups[i].Attributes;
                        if ((dwAttr & SE_GROUP_OWNER) && !(dwAttr & SE_GROUP_LOGON_ID))
                        {
                            AddSid(hOwner, ptg->Groups[i].Sid, m_siObjectInfo.pszServerName);
                        }
                    }
                }
                if (pBuffer != NULL)
                    LocalFree(pBuffer);
            }
            CloseHandle(hProcessToken);
        }

        //
        // Now add in the additional possible sids
        //
        for (int i = 0; i < ARRAYSIZE(g_uiTokenSids); i++)
            AddSid(hOwner, QueryTokenSid(g_uiTokenSids[i]));

        AddSid(hOwner, m_psidNetID, m_siObjectInfo.pszServerName);
    }

    if (!m_bAbortPage)
    {
        PUSER_LIST pUserList = NULL;

        LoadString(::hModule, IDS_OWNER_CANT_DISPLAY, szBuffer, ARRAYSIZE(szBuffer));

        // Finally, look up a name for the original SID.
        if (m_psidOriginal)
        {
            LPTSTR pszName = NULL;

            // Get the "S-1-5-blah" form of the SID in case the lookup fails
            if (ConvertSidToStringSid(m_psidOriginal, &pszName))
            {
                lstrcpyn(szBuffer, pszName, ARRAYSIZE(szBuffer));
                LocalFreeString(&pszName);
            }

            if (LookupSid(m_psidOriginal, m_siObjectInfo.pszServerName, m_psi2, &pUserList))
            {
                TraceAssert(NULL != pUserList);
                TraceAssert(1 == pUserList->cUsers);

                if (BuildUserDisplayName(&pszName, pUserList->rgUsers[0].pszName, pUserList->rgUsers[0].pszLogonName))
                {
                    lstrcpyn(szBuffer, pszName, ARRAYSIZE(szBuffer));
                    LocalFreeString(&pszName);
                }
                LocalFree(pUserList);
            }
        }
        SetDlgItemText(hDlg, IDC_OWN_CURRENTOWNER, szBuffer);
    }

    //
    // If the current user cannot change owners, gray out the list box.
    //
    if (bReadOnly)
    {
        // Disable the list and notify the user that it's read-only.
        EnableWindow(hOwner, FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_OWN_RESET), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_OWN_RECURSE), FALSE);

        //
        // If we're aborting, then the user should have been notified
        // during the propsheetpage callback.  Don't put up another
        // message here.
        //
        if (S_OK == m_hrLastPSPCallbackResult)
        {
            MsgPopup(hDlg,
                     MAKEINTRESOURCE(IDS_OWNER_READONLY),
                     MAKEINTRESOURCE(IDS_SECURITY),
                     MB_OK | MB_ICONINFORMATION,
                     ::hModule,
                     m_siObjectInfo.pszObjectName);
        }
    }

    SetCursor(hcur);

    TraceLeaveVoid();
}

void
COwnerPage::OnApply(HWND hDlg, BOOL bClose)
{
    int  iSelected = -1;
    HWND hwndOwnerList;
    PSID psid;
    BOOL bRecurse = FALSE;
    SECURITY_INFORMATION si = OWNER_SECURITY_INFORMATION;
    BOOL bEqualSid = FALSE;

    TraceEnter(TRACE_OWNER, "COwnerPage::OnApply");

    hwndOwnerList = GetDlgItem(hDlg, IDC_OWN_OWNERLIST);
    psid = (PSID)GetSelectedItemData(hwndOwnerList, &iSelected);

    // If there is no selection, use the original
    if (!psid)
        psid = m_psidOriginal;

    // If no selection and no original, then we can't do anything
    if (!psid)
        TraceLeaveVoid();


    if ((m_siObjectInfo.dwFlags & SI_OWNER_RECURSE)
        && IsDlgButtonChecked(hDlg, IDC_OWN_RECURSE) == BST_CHECKED)
    {
        bRecurse = TRUE;
    }

    // Has anything changed?
    if (m_psidOriginal
        && ( (m_psidOriginal == psid) || EqualSid(m_psidOriginal, psid) )
        && !bRecurse)
    {
        // Nothing has changed
        TraceLeaveVoid();
    }

    SECURITY_DESCRIPTOR sd = {0};
    DWORD dwPriv = SE_TAKE_OWNERSHIP_PRIVILEGE;
    HANDLE hToken = INVALID_HANDLE_VALUE;
    HRESULT hr;

    TraceAssert(!m_bAbortPage);

    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorOwner(&sd, psid, FALSE);

    // 
    // ISecurityInformation::SetSecurity doesn't have a parameter to indicate
    // that the owner should be recursively applied.  We could add a parameter,
    // but for now, just use one of the unused SECURITY_INFORMATION bits.
    // The security descriptor structure is unlikely to change so this should
    // be ok for now.
    if (bRecurse)
        si |= SI_OWNER_RECURSE;

    hToken = EnablePrivileges(&dwPriv, 1);

    hr = m_psi->SetSecurity(si, &sd);

    ReleasePrivileges(hToken);

    if (S_FALSE == hr)
    {
        // S_FALSE is silent failure (the client should put up UI
        // during SetSecurity before returning S_FALSE).
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
    }
    else if (S_OK == hr && !bClose)
    {

        //Inform the Effective Permission tab that
        //Permissions are changed
        PropSheet_QuerySiblings(GetParent(hDlg),0,0);

        UINT iLength = GetLengthSid(psid);
        
        if (-1 != iSelected)
        {
            TCHAR szName[MAX_PATH];
            szName[0] = TEXT('\0');
            ListView_GetItemText(hwndOwnerList, iSelected, 0, szName, ARRAYSIZE(szName));
            SetDlgItemText(hDlg, IDC_OWN_CURRENTOWNER, szName);
        }
        
        if (!(m_psidOriginal && 
           ((m_psidOriginal == psid) || EqualSid(m_psidOriginal, psid))))
        {
            if (m_psidOriginal)
            {
                UINT iLengthOriginal = (UINT)LocalSize(m_psidOriginal);
                if (iLengthOriginal < iLength)
                {
                    LocalFree(m_psidOriginal);
                    m_psidOriginal = NULL;
                }
                else
                {
                    ZeroMemory(m_psidOriginal, iLengthOriginal);
                }
            }

            if (!m_psidOriginal)
                m_psidOriginal = LocalAlloc(LPTR, iLength);

            if (m_psidOriginal)
            {
                CopyMemory(m_psidOriginal, psid, iLength);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        if (m_siObjectInfo.dwFlags & SI_OWNER_RECURSE)
            CheckDlgButton(hDlg, IDC_OWN_RECURSE, BST_UNCHECKED);
    }

    if (FAILED(hr))
    {
        SysMsgPopup(hDlg,
                    MAKEINTRESOURCE(IDS_OWNER_WRITE_FAILED),
                    MAKEINTRESOURCE(IDS_SECURITY),
                    MB_OK | MB_ICONERROR,
                    ::hModule,
                    hr,
                    m_siObjectInfo.pszObjectName);
    }

    TraceLeaveVoid();
}

void
COwnerPage::OnReset(HWND hDlg)
{
    PSECURITY_DESCRIPTOR pSD = NULL;
    HWND hOwner;
    PSID psid;
    HRESULT hr;

    TraceEnter(TRACE_OWNER, "COwnerPage::OnReset");
    TraceAssert(!m_bAbortPage);

    hOwner = GetDlgItem(hDlg, IDC_OWN_OWNERLIST);
    psid = (PSID)GetSelectedItemData(hOwner, NULL);

    hr = m_psi->GetSecurity(OWNER_SECURITY_INFORMATION, &pSD, TRUE);
    if (SUCCEEDED(hr))
    {
        PSID psidDefault = NULL;
        BOOL bDefaulted;

        if (pSD)
            GetSecurityDescriptorOwner(pSD, &psidDefault, &bDefaulted);

        if (psidDefault && !EqualSid(psidDefault, psid))
        {
            int iSel = AddSid(hOwner, psidDefault, m_siObjectInfo.pszServerName);

            if (iSel != -1)
            {
                ListView_SetItemState(hOwner, iSel, LVIS_SELECTED, LVIS_SELECTED);
                PropSheet_Changed(GetParent(hDlg), hDlg);
            }
        }
        LocalFree(pSD);
    }
    else
    {
        SysMsgPopup(hDlg,
                    MAKEINTRESOURCE(IDS_OPERATION_FAILED),
                    MAKEINTRESOURCE(IDS_SECURITY),
                    MB_OK | MB_ICONERROR,
                    ::hModule,
                    hr);
    }

    TraceLeaveVoid();
}

BOOL
COwnerPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL bResult = TRUE;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        InitDlg(hDlg);
        break;

    case WM_NOTIFY:
        {
            LPNM_LISTVIEW pnmlv = (LPNM_LISTVIEW)lParam;

            switch (((LPNMHDR)lParam)->code)
            {
            case LVN_ITEMCHANGED:
                if (pnmlv->uChanged & LVIF_STATE)
                {
                    // item *gaining* selection
                    if ((pnmlv->uNewState & LVIS_SELECTED) &&
                        !(pnmlv->uOldState & LVIS_SELECTED))
                    {
                        PropSheet_Changed(GetParent(hDlg), hDlg);
                    }
                }
                break;

            case LVN_DELETEITEM:
                if (pnmlv->lParam)
                    LocalFree((PSID)pnmlv->lParam);
                break;

            case NM_SETFOCUS:
                if (((LPNMHDR)lParam)->idFrom == IDC_OWN_OWNERLIST)
                {
                    // Make sure the listview is always focused on something,
                    // otherwise you can't tab into the control.
                    HWND hwndLV = GetDlgItem(hDlg, IDC_OWN_OWNERLIST);
                    if (-1 == ListView_GetNextItem(hwndLV, -1, LVNI_FOCUSED))
                        ListView_SetItemState(hwndLV, 0, LVIS_FOCUSED, LVIS_FOCUSED);
                }
                break;

            case PSN_QUERYINITIALFOCUS:
                {
                    // Set initial focus to the list of potential owners
                    HWND hwndLV = GetDlgItem(hDlg, IDC_OWN_OWNERLIST);
                    if (IsWindowEnabled(hwndLV))
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LONG_PTR)hwndLV);
                    else
                        bResult = FALSE;
                }
                break;

            case PSN_APPLY:
                OnApply(hDlg, (BOOL)(((LPPSHNOTIFY)lParam)->lParam));
                break;

            default:
                bResult = FALSE;
            }
        }
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_OWN_RECURSE:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
                PropSheet_Changed(GetParent(hDlg), hDlg);
            break;

        case IDC_OWN_RESET:
            OnReset(hDlg);
            break;

        default:
            bResult = FALSE;
        }
        break;

    case WM_HELP:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_szAcluiHelpFile,
                    HELP_WM_HELP,
                    (DWORD_PTR)aOwnerHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp(hDlg,
                    c_szAcluiHelpFile,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)aOwnerHelpIDs);
        }
        break;

    default:
        bResult = FALSE;
    }

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\pagebase.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pagebase.cpp
//
//  This file contains the implementation of the CSecurityPage base class.
//
//--------------------------------------------------------------------------

#include "aclpriv.h"

CSecurityPage::CSecurityPage( LPSECURITYINFO psi, SI_PAGE_TYPE siType )
: m_siPageType(siType), m_psi(psi), m_psi2(NULL),m_pei(NULL), m_pObjectPicker(NULL),
  m_psoti(NULL),
  m_flLastOPOptions(DWORD(-1))
{
    ZeroMemory(&m_siObjectInfo, sizeof(m_siObjectInfo));

    // Initialize COM incase our client hasn't
    m_hrComInit = CoInitialize(NULL);

    if (m_psi != NULL)
    {
        m_psi->AddRef();

        // It's normal for this to fail
        m_psi->QueryInterface(IID_ISecurityInformation2, (LPVOID*)&m_psi2);
        m_psi->QueryInterface(IID_IEffectivePermission, (LPVOID*)&m_pei);
        m_psi->QueryInterface(IID_ISecurityObjectTypeInfo, (LPVOID*)&m_psoti);
    }
}

CSecurityPage::~CSecurityPage( void )
{
    DoRelease(m_psi);
    DoRelease(m_psi2);
    DoRelease(m_pObjectPicker);
    DoRelease(m_pei);
    DoRelease(m_psoti);

    if (SUCCEEDED(m_hrComInit))
        CoUninitialize();
}

HPROPSHEETPAGE
CSecurityPage::CreatePropSheetPage(LPCTSTR pszDlgTemplate, LPCTSTR pszDlgTitle)
{
    PROPSHEETPAGE psp;

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_USECALLBACK ;
    psp.hInstance   = ::hModule;
    psp.pszTemplate = pszDlgTemplate;
    psp.pszTitle    = pszDlgTitle;
    psp.pfnDlgProc  = CSecurityPage::_DlgProc;
    psp.lParam      = (LPARAM)this;
    psp.pfnCallback = CSecurityPage::_PSPageCallback;

    if (pszDlgTitle != NULL)
        psp.dwFlags |= PSP_USETITLE;

    return CreatePropertySheetPage(&psp);
}

HRESULT
CSecurityPage::GetObjectPicker(IDsObjectPicker **ppObjectPicker)
{
#if(_WIN32_WINNT >= 0x0500)
    HRESULT hr = S_OK;

    if (!m_pObjectPicker)
    {
        if (!m_psi)
            return E_UNEXPECTED;

        // See if the object supports IDsObjectPicker
        hr = m_psi->QueryInterface(IID_IDsObjectPicker, (LPVOID*)&m_pObjectPicker);

        // If the object doesn't support IDsObjectPicker, create one.
        if (FAILED(hr))
        {
            hr = CoCreateInstance(CLSID_DsObjectPicker,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IDsObjectPicker,
                                  (LPVOID*)&m_pObjectPicker);
        }
    }

    if (ppObjectPicker)
    {
        *ppObjectPicker = m_pObjectPicker;
        // Return a reference (caller must Release)
        if (m_pObjectPicker)
            m_pObjectPicker->AddRef();
    }

    return hr;
#else
    *ppObjectPicker = NULL;
    return E_NOTIMPL;
#endif
}


#if(_WIN32_WINNT >= 0x0500)
//
// Stuff used for initializing the Object Picker below
//
#define DSOP_FILTER_COMMON1 ( DSOP_FILTER_INCLUDE_ADVANCED_VIEW \
                            | DSOP_FILTER_USERS                 \
                            | DSOP_FILTER_UNIVERSAL_GROUPS_SE   \
                            | DSOP_FILTER_GLOBAL_GROUPS_SE      \
                            | DSOP_FILTER_COMPUTERS             \
                            )
#define DSOP_FILTER_COMMON2 ( DSOP_FILTER_COMMON1               \
                            | DSOP_FILTER_WELL_KNOWN_PRINCIPALS \
                            | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE\
                            )
#define DSOP_FILTER_COMMON3 ( DSOP_FILTER_COMMON2               \
                            | DSOP_FILTER_BUILTIN_GROUPS        \
                            )
#define DSOP_FILTER_DL_COMMON1      ( DSOP_DOWNLEVEL_FILTER_USERS           \
                                    | DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS   \
                                    )
#define DSOP_FILTER_DL_COMMON2      ( DSOP_FILTER_DL_COMMON1                    \
                                    | DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS  \
                                    )
#define DSOP_FILTER_DL_COMMON3      ( DSOP_FILTER_DL_COMMON2                \
                                    | DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS    \
                                    )
// Same as DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS, except no CREATOR flags.
// Note that we need to keep this in sync with any object picker changes.
#define DSOP_FILTER_DL_WELLKNOWN    ( DSOP_DOWNLEVEL_FILTER_WORLD               \
                                    | DSOP_DOWNLEVEL_FILTER_AUTHENTICATED_USER  \
                                    | DSOP_DOWNLEVEL_FILTER_ANONYMOUS           \
                                    | DSOP_DOWNLEVEL_FILTER_BATCH               \
                                    | DSOP_DOWNLEVEL_FILTER_DIALUP              \
                                    | DSOP_DOWNLEVEL_FILTER_INTERACTIVE         \
                                    | DSOP_DOWNLEVEL_FILTER_NETWORK             \
                                    | DSOP_DOWNLEVEL_FILTER_SERVICE             \
                                    | DSOP_DOWNLEVEL_FILTER_SYSTEM              \
                                    | DSOP_DOWNLEVEL_FILTER_TERMINAL_SERVER     \
                                    )

#if 0
{   // DSOP_SCOPE_INIT_INFO
    cbSize,
    flType,
    flScope,
    {   // DSOP_FILTER_FLAGS
        {   // DSOP_UPLEVEL_FILTER_FLAGS
            flBothModes,
            flMixedModeOnly,
            flNativeModeOnly
        },
        flDownlevel
    },
    pwzDcName,
    pwzADsPath,
    hr // OUT
}
#endif

#define DECLARE_SCOPE(t,f,b,m,n,d)  \
{ sizeof(DSOP_SCOPE_INIT_INFO), (t), (f|DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS|DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS), { { (b), (m), (n) }, (d) }, NULL, NULL, S_OK }

// The domain to which the target computer is joined.
// Make 2 scopes, one for uplevel domains, the other for downlevel.
#define JOINED_DOMAIN_SCOPE(f)  \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN,(f),0,(DSOP_FILTER_COMMON2 & ~(DSOP_FILTER_UNIVERSAL_GROUPS_SE|DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE)),DSOP_FILTER_COMMON2,0), \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN,(f),0,0,0,DSOP_FILTER_DL_COMMON2)

// The domain for which the target computer is a Domain Controller.
// Make 2 scopes, one for uplevel domains, the other for downlevel.
#define JOINED_DOMAIN_SCOPE_DC(f)  \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN,(f),0,(DSOP_FILTER_COMMON3 & ~DSOP_FILTER_UNIVERSAL_GROUPS_SE),DSOP_FILTER_COMMON3,0), \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN,(f),0,0,0,DSOP_FILTER_DL_COMMON3)

// Target computer scope.  Computer scopes are always treated as
// downlevel (i.e., they use the WinNT provider).
#define TARGET_COMPUTER_SCOPE(f)\
DECLARE_SCOPE(DSOP_SCOPE_TYPE_TARGET_COMPUTER,(f),0,0,0,DSOP_FILTER_DL_COMMON3)

// The Global Catalog
#define GLOBAL_CATALOG_SCOPE(f) \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_GLOBAL_CATALOG,(f),DSOP_FILTER_COMMON1|DSOP_FILTER_WELL_KNOWN_PRINCIPALS,0,0,0)

// The domains in the same forest (enterprise) as the domain to which
// the target machine is joined.  Note these can only be DS-aware
#define ENTERPRISE_SCOPE(f)     \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN,(f),DSOP_FILTER_COMMON1,0,0,0)

// Domains external to the enterprise but trusted directly by the
// domain to which the target machine is joined.
#define EXTERNAL_SCOPE(f)       \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN|DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN,\
    (f),DSOP_FILTER_COMMON1,0,0,DSOP_DOWNLEVEL_FILTER_USERS|DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS)

// Workgroup scope.  Only valid if the target computer is not joined
// to a domain.
#define WORKGROUP_SCOPE(f)      \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_WORKGROUP,(f),0,0,0, DSOP_FILTER_DL_COMMON1|DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS )

//
// Array of Default Scopes
//
static const DSOP_SCOPE_INIT_INFO g_aDefaultScopes[] =
{
    JOINED_DOMAIN_SCOPE(DSOP_SCOPE_FLAG_STARTING_SCOPE),
    TARGET_COMPUTER_SCOPE(0),
    GLOBAL_CATALOG_SCOPE(0),
    ENTERPRISE_SCOPE(0),
    EXTERNAL_SCOPE(0),
};

//
// Same as above, but without the Target Computer
// Used when the target is a Domain Controller
//
static const DSOP_SCOPE_INIT_INFO g_aDCScopes[] =
{
    JOINED_DOMAIN_SCOPE_DC(DSOP_SCOPE_FLAG_STARTING_SCOPE),
    GLOBAL_CATALOG_SCOPE(0),
    ENTERPRISE_SCOPE(0),
    EXTERNAL_SCOPE(0),
};

//
// Array of scopes for standalone machines
//
static const DSOP_SCOPE_INIT_INFO g_aStandAloneScopes[] =
{
//
//On Standalone machine Both User And Groups are selected by default
//
    TARGET_COMPUTER_SCOPE(DSOP_SCOPE_FLAG_STARTING_SCOPE|DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS),
};

//
// Attributes that we want the Object Picker to retrieve
//
static const LPCTSTR g_aszOPAttributes[] =
{
    TEXT("ObjectSid"),
};


HRESULT
CSecurityPage::InitObjectPicker(BOOL bMultiSelect)
{
    HRESULT hr = S_OK;
    DSOP_INIT_INFO InitInfo;
    PCDSOP_SCOPE_INIT_INFO pScopes;
    ULONG cScopes;

    USES_CONVERSION;

    TraceEnter(TRACE_MISC, "InitObjectPicker");

    hr = GetObjectPicker();
    if (FAILED(hr))
        TraceLeaveResult(hr);

    TraceAssert(m_pObjectPicker != NULL);

    InitInfo.cbSize = sizeof(InitInfo);
    // We do the DC check at WM_INITDIALOG
    InitInfo.flOptions = DSOP_FLAG_SKIP_TARGET_COMPUTER_DC_CHECK;
    if (bMultiSelect)
        InitInfo.flOptions |= DSOP_FLAG_MULTISELECT;

    // flOptions is the only thing that changes from call to call,
    // so optimize this by only reinitializing if flOptions changes.
    if (m_flLastOPOptions == InitInfo.flOptions)
        TraceLeaveResult(S_OK); // Already initialized

    m_flLastOPOptions = (DWORD)-1;

    pScopes = g_aDefaultScopes;
    cScopes = ARRAYSIZE(g_aDefaultScopes);

    if (m_bStandalone)
    {
        cScopes = ARRAYSIZE(g_aStandAloneScopes);
        pScopes = g_aStandAloneScopes;
    }
    else if (m_siObjectInfo.dwFlags & SI_SERVER_IS_DC)
    {
        cScopes = ARRAYSIZE(g_aDCScopes);
        pScopes = g_aDCScopes;
    }

    //
    // The pwzTargetComputer member allows the object picker to be
    // retargetted to a different computer.  It will behave as if it
    // were being run ON THAT COMPUTER.
    //
    InitInfo.pwzTargetComputer = T2CW(m_siObjectInfo.pszServerName);
    InitInfo.cDsScopeInfos = cScopes;
    InitInfo.aDsScopeInfos = (PDSOP_SCOPE_INIT_INFO)LocalAlloc(LPTR, sizeof(*pScopes)*cScopes);
    if (!InitInfo.aDsScopeInfos)
        TraceLeaveResult(E_OUTOFMEMORY);
    CopyMemory(InitInfo.aDsScopeInfos, pScopes, sizeof(*pScopes)*cScopes);
    InitInfo.cAttributesToFetch = ARRAYSIZE(g_aszOPAttributes);
    InitInfo.apwzAttributeNames = (LPCTSTR*)g_aszOPAttributes;

    if ((m_siObjectInfo.dwFlags & SI_SERVER_IS_DC) || !(m_siObjectInfo.dwFlags & SI_CONTAINER))
    {
        for (ULONG i = 0; i < cScopes; i++)
        {
            // Set the DC name if appropriate
            if ((m_siObjectInfo.dwFlags & SI_SERVER_IS_DC) &&
                (InitInfo.aDsScopeInfos[i].flType & DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN))
            {
                InitInfo.aDsScopeInfos[i].pwzDcName = InitInfo.pwzTargetComputer;
            }

            // Turn off CREATOR_OWNER & CREATOR_GROUP for non-containers
            if (!(m_siObjectInfo.dwFlags & SI_CONTAINER) &&
                (InitInfo.aDsScopeInfos[i].FilterFlags.flDownlevel & DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS))
            {
                InitInfo.aDsScopeInfos[i].FilterFlags.flDownlevel &= ~DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS;
                InitInfo.aDsScopeInfos[i].FilterFlags.flDownlevel |= DSOP_FILTER_DL_WELLKNOWN;
            }
        }
    }

    hr = m_pObjectPicker->Initialize(&InitInfo);

    if (SUCCEEDED(hr))
    {
        // Remember the Options for next time
        m_flLastOPOptions = InitInfo.flOptions;
    }

    LocalFree(InitInfo.aDsScopeInfos);

    TraceLeaveResult(hr);
}
#endif  // (_WIN32_WINNT >= 0x0500)


HRESULT
CSecurityPage::GetUserGroup(HWND hDlg, BOOL bMultiSelect, PUSER_LIST *ppUserList)
{
#if(_WIN32_WINNT < 0x0500)
    DWORD dwFlags = 0;

    if (bMultiSelect)
        dwFlags |= GU_MULTI_SELECT;
    if (m_siObjectInfo.dwFlags & SI_CONTAINER)
        dwFlags |= GU_CONTAINER;
    if (m_siObjectInfo.dwFlags & SI_SERVER_IS_DC)
        dwFlags |= GU_DC_SERVER;
    if (m_siPageType == SI_PAGE_AUDIT)
        dwFlags |= GU_AUDIT_HLP;

    return ::GetUserGroup(hDlg,
                          dwFlags,
                          m_siObjectInfo.pszServerName,
                          m_bStandalone,
                          ppUserList);
#else   // (_WIN32_WINNT >= 0x0500)
    HRESULT hr;
    LPDATAOBJECT pdoSelection = NULL;
    STGMEDIUM medium = {0};
    FORMATETC fe = { (CLIPFORMAT)g_cfDsSelectionList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    PDS_SELECTION_LIST pDsSelList = NULL;
    HCURSOR hcur = NULL;
    PSIDCACHE pSidCache = NULL;
    UINT idErrorMsg = IDS_GET_USER_FAILED;

    TraceEnter(TRACE_MISC, "GetUserGroup");
    TraceAssert(ppUserList != NULL);

    *ppUserList = NULL;

    //
    // Create and initialize the Object Picker object
    //
    hr = InitObjectPicker(bMultiSelect);
    FailGracefully(hr, "Unable to initialize Object Picker object");

    //
    // Create the global sid cache object, if necessary
    //
    pSidCache = GetSidCache();
    if (pSidCache == NULL)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to create SID cache");

    //
    // Bring up the object picker dialog
    //
    hr = m_pObjectPicker->InvokeDialog(hDlg, &pdoSelection);
    FailGracefully(hr, "IDsObjectPicker->Invoke failed");
    if (S_FALSE == hr)
        ExitGracefully(hr, S_FALSE, "IDsObjectPicker->Invoke cancelled by user");

    hr = pdoSelection->GetData(&fe, &medium);
    FailGracefully(hr, "Unable to get CFSTR_DSOP_DS_SELECTION_LIST from DataObject");

    pDsSelList = (PDS_SELECTION_LIST)GlobalLock(medium.hGlobal);
    if (!pDsSelList)
        ExitGracefully(hr, E_FAIL, "Unable to lock stgmedium.hGlobal");

    TraceAssert(pDsSelList->cItems > 0);
    Trace((TEXT("%d items selected"), pDsSelList->cItems));

    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    // Lookup the names/sids and cache them
    //
    if (!pSidCache->LookupNames(pDsSelList,
                                m_siObjectInfo.pszServerName,
                                ppUserList,
                                m_bStandalone))
    {
        hr = E_FAIL;
        idErrorMsg = IDS_SID_LOOKUP_FAILED;
    }

    SetCursor(hcur);

exit_gracefully:
    
    if (pSidCache)
        pSidCache->Release();

    if (FAILED(hr))
    {
        SysMsgPopup(hDlg,
                    MAKEINTRESOURCE(idErrorMsg),
                    MAKEINTRESOURCE(IDS_SECURITY),
                    MB_OK | MB_ICONERROR,
                    ::hModule,
                    hr);
    }

    if (pDsSelList)
        GlobalUnlock(medium.hGlobal);
    ReleaseStgMedium(&medium);
    DoRelease(pdoSelection);

    TraceLeaveResult(hr);
#endif  // (_WIN32_WINNT >= 0x0500)
}

UINT
CSecurityPage::PSPageCallback(HWND hwnd,
                              UINT uMsg,
                              LPPROPSHEETPAGE /*ppsp*/)
{
    m_hrLastPSPCallbackResult = E_FAIL;

    if (m_psi != NULL)
    {
        m_hrLastPSPCallbackResult = m_psi->PropertySheetPageCallback(hwnd, uMsg, m_siPageType);
        if (m_hrLastPSPCallbackResult == E_NOTIMPL)
            m_hrLastPSPCallbackResult = S_OK;
    }

    return SUCCEEDED(m_hrLastPSPCallbackResult);
}

INT_PTR
CALLBACK
CSecurityPage::_DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPSECURITYPAGE pThis = (LPSECURITYPAGE)GetWindowLongPtr(hDlg, DWLP_USER);

    // The following messages arrive before WM_INITDIALOG
    // which means pThis is NULL for them.  We don't need these
    // messages so let DefDlgProc handle them.
    //
    // WM_SETFONT
    // WM_NOTIFYFORMAT
    // WM_NOTIFY (LVN_HEADERCREATED)

    if (uMsg == WM_INITDIALOG)
    {
        pThis = (LPSECURITYPAGE)(((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pThis);

        if (pThis)
        {
            if (!pThis->PSPageCallback(hDlg, PSPCB_SI_INITDIALOG, NULL))
                pThis->m_bAbortPage = TRUE;

            if (pThis->m_psi)
            {
                BOOL bIsDC = FALSE;
                pThis->m_psi->GetObjectInformation(&pThis->m_siObjectInfo);
                pThis->m_bStandalone = IsStandalone(pThis->m_siObjectInfo.pszServerName, &bIsDC);
                if (bIsDC)
                    pThis->m_siObjectInfo.dwFlags |= SI_SERVER_IS_DC;
            }
        }
    }

    if (pThis != NULL)
        return pThis->DlgProc(hDlg, uMsg, wParam, lParam);

    return FALSE;
}

UINT
CALLBACK
CSecurityPage::_PSPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    LPSECURITYPAGE pThis = (LPSECURITYPAGE)ppsp->lParam;

    if (pThis)
    {
        UINT nResult = pThis->PSPageCallback(hWnd, uMsg, ppsp);

        switch (uMsg)
        {
        case PSPCB_CREATE:
            if (!nResult)
                pThis->m_bAbortPage = TRUE;
            break;

        case PSPCB_RELEASE:
            delete pThis;
            break;
        }
    }

    //
    // Always return non-zero or else our tab will disappear and whichever
    // property page becomes active won't repaint properly.  Instead, use
    // the m_bAbortPage flag during WM_INITDIALOG to disable the page if
    // the callback failed.
    //
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\pagebase.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pagebase.h
//
//  This file contains the definition of the CSecurityPage base class
//
//--------------------------------------------------------------------------

#ifndef _PAGEBASE_H_
#define _PAGEBASE_H_

class CSecurityPage
{
protected:
    SI_PAGE_TYPE            m_siPageType;
    LPSECURITYINFO          m_psi;
    LPSECURITYINFO2         m_psi2;
    LPEFFECTIVEPERMISSION   m_pei;
    LPSecurityObjectTypeInfo m_psoti;
    HRESULT                 m_hrComInit;
    IDsObjectPicker         *m_pObjectPicker;
    SI_OBJECT_INFO          m_siObjectInfo;
    DWORD                   m_flLastOPOptions;
    BOOL                    m_bStandalone;
    BOOL                    m_bAbortPage;
    HRESULT                 m_hrLastPSPCallbackResult;

public:
    CSecurityPage( LPSECURITYINFO psi, SI_PAGE_TYPE siType );
    virtual ~CSecurityPage( void );

    HPROPSHEETPAGE CreatePropSheetPage(LPCTSTR pszDlgTemplate, LPCTSTR pszDlgTitle = NULL);
    HRESULT GetObjectPicker(IDsObjectPicker **ppObjectPicker = NULL);
    HRESULT GetUserGroup(HWND hDlg, BOOL bMultiSelect, PUSER_LIST *ppUserList);
    BOOL IsEffective(){ return (m_pei != NULL) ;}

protected:
#if(_WIN32_WINNT >= 0x0500)
    HRESULT InitObjectPicker(BOOL bMultiSelect);
#endif

    virtual BOOL DlgProc(HWND, UINT, WPARAM, LPARAM) = 0;
    virtual UINT PSPageCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);

    static INT_PTR CALLBACK _DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static UINT CALLBACK _PSPageCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
};

typedef class CSecurityPage *LPSECURITYPAGE;

#endif  /* _PAGEBASE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\effperm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       owner.cpp
//
//  This file contains the implementation of the Owner page.
//
//--------------------------------------------------------------------------
#include "aclpriv.h"
#include <initguid.h> // needed to get the GUIDs defined in oleacc.h
#include <oleacc.h> // contains IAccProp* definitions



//Context Help IDs
const static DWORD aEffHelpIDs[] =
{
    IDC_EFF_NAME_STATIC,        IDH_EFF_NAME,
    IDC_EFF_NAME,               IDH_EFF_NAME,
    IDC_EFF_SELECT,             IDH_EFF_SELECT,
    IDC_EFF_PERMISSION_STATIC,  IDH_EFF_PERM_LIST,
    IDC_EFF_PERM_LIST,          IDH_EFF_PERM_LIST,
    IDC_EFF_STATIC,             -1,
    0, 0
};


LPCWSTR g_ListStateMap = 
    L"A:0"
    L":0:0x50" // checked, disabled - STATE_SYSTEM_READONLY | STATE_SYSTEM_CHECKED
    L":1:0x40" // disabled - STATE_SYSTEM_READONLY
    L":";


LPCWSTR g_ListRoleMap = 
    L"A:0"
    L":0:0x2C" // checkbox - ROLE_SYSTEM_CHECKBUTTON (ie. checkbox)
    L":1:0x2C"
    L":";


int LV_ADDITEM(HWND hwndList, 
               LPCTSTR pszName, 
               int index, 
               PSI_ACCESS pAccess, 
               BOOL bChecked)
{
    LVITEM lvItem;    
    TraceAssert(pAccess != NULL);
    TraceAssert(pszName != NULL);

    lvItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    lvItem.iItem = index;
    lvItem.iSubItem = 0;
    lvItem.pszText = (LPTSTR)pszName;
    lvItem.lParam = (LPARAM)pAccess;
    lvItem.iImage = bChecked ? 0 : 1;

    // Insert item into list
    index = ListView_InsertItem(hwndList, &lvItem);
    ListView_SetCheckState(hwndList,index,bChecked);
    
    return index;
}

typedef struct _EffCacheItem
{    
    POBJECT_TYPE_LIST pObjectTypeList;
    ULONG cObjectTypeListLength;
    PACCESS_MASK pGrantedAccessList;
    PSID pSid;
}EFFCACHEITEM,*PEFFCACHEITEM;


//This Function checks is pAccess is granted.
BOOL IsChecked( PSI_ACCESS pAccess,
                PEFFCACHEITEM pCacheItem)
{
    TraceEnter(TRACE_EFFPERM, "IsChecked");
    TraceAssert(pCacheItem != NULL);
    TraceAssert(pAccess != NULL);

    POBJECT_TYPE_LIST pObjectTypeList = pCacheItem->pObjectTypeList;
    ULONG cObjectTypeListLength = pCacheItem->cObjectTypeListLength;
    PACCESS_MASK pGrantedAccessList = pCacheItem->pGrantedAccessList;

    //0th Grant is for full object. 
    if( (pAccess->mask & pGrantedAccessList[0]) == pAccess->mask )
        return TRUE;

    BOOL bGuidNULL = pAccess->pguid ?IsEqualGUID(*(pAccess->pguid), GUID_NULL): TRUE;
    LPGUID pguid;        

    for( UINT i = 1; i < cObjectTypeListLength; ++i )
    {
        pguid = pObjectTypeList[i].ObjectType;
        if( pguid == NULL ||
            IsEqualGUID(*pguid, GUID_NULL) ||
            (!bGuidNULL && IsEqualGUID(*pguid,*(pAccess->pguid))) )
        {
            if( (pAccess->mask & pGrantedAccessList[i]) == pAccess->mask )
                return TRUE;
        }
    }
    return FALSE;
}



class CEffPage: public CSecurityPage
{
public:
    CEffPage(LPSECURITYINFO psi, SI_OBJECT_INFO *psiObjectInfo);
    virtual ~CEffPage();

private:
    virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL InitDlg(HWND hDlg);
    void OnSelect(HWND hDlg);
    void InitListBox(HWND hDlg);
    HRESULT GetEffectivePerm(PSID pSid, PEFFCACHEITEM *ppCacheItem);
    PSID GetSelectedSID(){ return m_pSid; }

private:
    PSID m_pSid;    //Sid of the security principal for which permissions are displayed
   
    PSI_ACCESS m_pAccess;
    ULONG m_cAccesses;
};


HPROPSHEETPAGE
CreateEffectivePermPage(LPSECURITYINFO psi, SI_OBJECT_INFO *psiObjectInfo)
{
    HPROPSHEETPAGE hPage = NULL;
    CEffPage *pPage;
    
    TraceEnter(TRACE_EFFPERM, "CreateEffectivePermPage");
    TraceAssert(psi!=NULL);
    TraceAssert(psiObjectInfo);

    pPage = new CEffPage(psi, psiObjectInfo);

    if (pPage)
    {
        hPage = pPage->CreatePropSheetPage(MAKEINTRESOURCE(IDD_EFFECTIVE_PERM_PAGE));

        if (!hPage)
            delete pPage;
    }

    TraceLeaveValue(hPage);
}


CEffPage::CEffPage(LPSECURITYINFO psi, SI_OBJECT_INFO *psiObjectInfo)
: CSecurityPage(psi, SI_PAGE_OWNER) , m_pSid(NULL),
  m_pAccess(NULL), m_cAccesses(0)
{
    // Lookup known SIDs asynchronously so the dialog
    // will initialize faster
}

CEffPage::~CEffPage()
{
    if (m_pSid)
        LocalFree(m_pSid);
}
BOOL 
CEffPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL bResult = TRUE;
    LPPSHNOTIFY lpsn;
    switch(uMsg)
    {
    case WM_INITDIALOG:
        InitDlg(hDlg);
        break;


    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_EFF_SELECT:
            OnSelect(hDlg);
            break;
        default:
            bResult = FALSE;
        }
        break;

    case WM_HELP:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                            c_szAcluiHelpFile,
                            HELP_WM_HELP,
                            (DWORD_PTR)aEffHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp(hDlg,
                    c_szAcluiHelpFile,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)aEffHelpIDs);
        }
        break;
    case PSM_QUERYSIBLINGS:
        if(GetSelectedSID())
            InitListBox(hDlg);                
        break;

    default:
        bResult = FALSE;
    }

    return bResult;
}


BOOL
CEffPage::InitDlg( HWND hDlg )
{

    HWND hwndList;
    RECT rc;
    LV_COLUMN col;
    TCHAR szBuffer[MAX_COLUMN_CHARS];
    HRESULT hr = S_OK;
    ULONG iDefaultAccess;
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    TraceEnter(TRACE_EFFPERM, "CEffPage::InitDlg");
    TraceAssert(hDlg != NULL);
    TraceAssert(m_psi != NULL);
    TraceAssert(m_pei != NULL);

    hwndList = GetDlgItem(hDlg, IDC_EFF_PERM_LIST);

    //
    // Create & set the image list for the listview.  If there is a
    // problem CreateSidImageList will return NULL which won't hurt
    // anything. In that case we'll just continue without an image list.
    //
    ListView_SetImageList(hwndList,
                          LoadImageList(::hModule, MAKEINTRESOURCE(IDB_CHECKBOX)),
                          LVSIL_SMALL);


    // Set extended LV style for whole line selection with InfoTips
    ListView_SetExtendedListViewStyleEx(hwndList,
                                        LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP, 
                                        LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP);


	IAccPropServices * pAccPropSvc = NULL;
	hr = CoCreateInstance( CLSID_AccPropServices, NULL, CLSCTX_SERVER, IID_IAccPropServices, (void **) & pAccPropSvc );
	if( hr == S_OK && pAccPropSvc )
	{
		// Don't have to check HRESULT here, since if they fail we just ignore anyway,
		// but may want to log it while debugging.
		pAccPropSvc->SetHwndPropStr(hwndList, OBJID_CLIENT, 0, PROPID_ACC_ROLEMAP, g_ListRoleMap );
		pAccPropSvc->SetHwndPropStr(hwndList, OBJID_CLIENT, 0, PROPID_ACC_STATEMAP, g_ListStateMap );
		pAccPropSvc->Release();
	}



    //
    // Add appropriate listview columns
    //
    GetClientRect(hwndList, &rc);

    LoadString(::hModule, IDS_PERMISSIONS, szBuffer, ARRAYSIZE(szBuffer));
    col.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.pszText = szBuffer;
    col.iSubItem = 0;
    col.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);
    ListView_InsertColumn(hwndList, 0, &col);


    //Get the access Rights
    hr = m_psi->GetAccessRights(&GUID_NULL,
                                SI_ADVANCED|SI_EDIT_EFFECTIVE,
                                &m_pAccess,
                                &m_cAccesses,
                                &iDefaultAccess);
    FailGracefully(hr, "GetAccessRights Failed");    
    //Initialize the List box
    InitListBox(hDlg);

exit_gracefully:


    SetCursor(hcur);

    if (FAILED(hr))
    {
        HWND hwnd;
        // Hide and disable everything
        for (hwnd = GetWindow(hDlg, GW_CHILD);
             hwnd != NULL;
             hwnd = GetWindow(hwnd, GW_HWNDNEXT))
        {
            ShowWindow(hwnd, SW_HIDE);
            EnableWindow(hwnd, FALSE);
        }

        // Enable and show the "No Security" message
        hwnd = GetDlgItem(hDlg, IDC_NO_EFFECTIVE);
        EnableWindow(hwnd, TRUE);
        ShowWindow(hwnd, SW_SHOW);
    }

    TraceLeaveValue(TRUE);
}

VOID
CEffPage::OnSelect(HWND hDlg)
{
    PUSER_LIST pUserList = NULL;
    LPEFFECTIVEPERMISSION pei;
    HRESULT hr = S_OK;

    TraceEnter(TRACE_EFFPERM, "CEffPage::OnSelect");

    if (S_OK == GetUserGroup(hDlg, FALSE, &pUserList))
    {
        TraceAssert(NULL != pUserList);
        TraceAssert(1 == pUserList->cUsers);

        // Free up previous sid
        if (m_pSid)
            LocalFree(m_pSid);

        // Copy the new sid
        m_pSid = LocalAllocSid(pUserList->rgUsers[0].pSid);
        if (m_pSid)
        {
            SetDlgItemText(hDlg, IDC_EFF_NAME, pUserList->rgUsers[0].pszName);
        }
        LocalFree(pUserList);
        InitListBox(hDlg); 
    }    
}


VOID
CEffPage::InitListBox(HWND hDlg)
{
    HWND hwndList;
    BOOL bProperties;

    PSI_ACCESS pAccess;
    ULONG cAccesses;
    DWORD dwType;
    TCHAR szName[MAX_PATH];
    PSID pSid = NULL;
    PEFFCACHEITEM pCacheItem = NULL; 
    int index;
    TraceEnter(TRACE_EFFPERM, "CEffPage::InitListBox");
    TraceAssert( m_pAccess != NULL );
    TraceAssert(m_cAccesses != 0 );

    HRESULT hr = S_OK;
    hwndList = GetDlgItem(hDlg, IDC_EFF_PERM_LIST);

    if(!IsWindowEnabled(hwndList))
    {        
        //Hide Error Message
        HWND hwnd = GetDlgItem(hDlg, IDC_EFF_ERROR);
        EnableWindow(hwnd, FALSE);
        ShowWindow(hwnd, SW_HIDE);
        //Show List box
        EnableWindow(hwndList, TRUE);
        ShowWindow(hwndList, SW_SHOW);
    }

    //Clear all items
    ListView_DeleteAllItems(hwndList);

    pAccess = m_pAccess;
    cAccesses = m_cAccesses;
    dwType = SI_ACCESS_SPECIFIC | SI_ACCESS_PROPERTY;
    
    //Get the current sid
    pSid = GetSelectedSID();
    if( pSid )
    {
        hr = GetEffectivePerm(pSid, &pCacheItem);
        FailGracefully(hr,"GetEffectivePermission Failed");
    }

    index = 0;        
    // Enumerate the permissions and add to the checklist
    ULONG i;
    for (i = 0; i < cAccesses; i++, pAccess++)
    {
        LPCTSTR pszName;

        // Only add permissions that have any of the flags specified in dwType
        if (!(pAccess->dwFlags & dwType))
            continue;

        //Don't Add Permission which have inherit only on
        if( pAccess->dwFlags & INHERIT_ONLY_ACE )
            continue;

        pszName = pAccess->pszName;
        if (IS_INTRESOURCE(pszName))
        {
            TraceAssert(m_siObjectInfo.hInstance != NULL);

            if (LoadString(m_siObjectInfo.hInstance,
                           (UINT)((ULONG_PTR)pszName),
                           szName,
                           ARRAYSIZE(szName)) == 0)
            {
                LoadString(::hModule,
                           IDS_UNKNOWN,
                           szName,
                           ARRAYSIZE(szName));
            }
            pszName = szName;
        }
        
        BOOL bChecked = FALSE;
        if(pSid)
        {
            bChecked = IsChecked( pAccess, pCacheItem );
        }
        index = LV_ADDITEM( hwndList, pszName, index, pAccess, bChecked);
        index++;
    }    
    if(index)
    {
        SelectListViewItem(hwndList, 0);
        // Redraw the list
        SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);
        ListView_RedrawItems(hwndList, 0, -1);
    }



exit_gracefully:
    if(pCacheItem)
    {
        if(pCacheItem->pGrantedAccessList)
            LocalFree(pCacheItem->pGrantedAccessList);
        LocalFree(pCacheItem);
    }
    if(FAILED(hr))
    {
        //Hide List box
        HWND hwnd = GetDlgItem(hDlg, IDC_EFF_PERM_LIST);
        EnableWindow(hwnd, FALSE);
        ShowWindow(hwnd, SW_HIDE);
        
        //Format Error Message To Display
        WCHAR buffer[MAX_PATH];
        LPWSTR pszCaption = NULL;
        GetWindowText(GetDlgItem(hDlg, IDC_EFF_NAME),
                      buffer, 
                      MAX_PATH-1);
        FormatStringID(&pszCaption, ::hModule, IDS_EFF_ERROR, buffer);
        
        //Show Error Message
        hwnd = GetDlgItem(hDlg, IDC_EFF_ERROR);
        EnableWindow(hwnd, TRUE);
        SetWindowText(hwnd,pszCaption);
        ShowWindow(hwnd, SW_SHOW);
        LocalFreeString(&pszCaption);
    }
    TraceLeaveVoid();
}

//Calling function frees *ppCacheItem->pGrantedAccessList
//and *ppCacheItem

HRESULT
CEffPage::GetEffectivePerm(PSID pSid,
                           PEFFCACHEITEM *ppCacheItem )
{
    PSECURITY_DESCRIPTOR pSD;
    
    HRESULT hr = S_OK;
    ULONG cItems = 0;
    PEFFCACHEITEM pCacheTemp = NULL;

    TraceEnter(TRACE_EFFPERM, "CEffPage::GetEffectivePerm");
    TraceAssert(pSid != NULL);
    TraceAssert(ppCacheItem != NULL);

    pCacheTemp = (PEFFCACHEITEM)LocalAlloc( LPTR, sizeof(EFFCACHEITEM) + GetLengthSid(pSid));
    
    if(!pCacheTemp)
        ExitGracefully(hr, E_OUTOFMEMORY, "Lcoal Alloc Failed");
    pCacheTemp->pSid = (PSID)(pCacheTemp + 1);
    CopySid(GetLengthSid(pSid), pCacheTemp->pSid, pSid);

    
    if(m_psi)
    {
        hr = m_psi->GetSecurity(OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
                                &pSD,
                                FALSE);
        FailGracefully(hr, "GetSecurity Failed");
    }
    
    if( m_pei)
    {
        DWORD dwTemp;
        hr = m_pei->GetEffectivePermission(&(m_siObjectInfo.guidObjectType),
                                           pCacheTemp->pSid,
                                           m_siObjectInfo.pszServerName,
                                           //NULL,
                                           pSD,
                                           &(pCacheTemp->pObjectTypeList),
                                           &(pCacheTemp->cObjectTypeListLength),
                                           &(pCacheTemp->pGrantedAccessList),
                                           &dwTemp);
        if(SUCCEEDED(hr))
        {
            if(!pCacheTemp->pObjectTypeList || !pCacheTemp->pGrantedAccessList)
                hr = E_FAIL;
        }

        FailGracefully(hr, "GetEffectivePermission Failed");
        
    }
exit_gracefully:
    
    if( !SUCCEEDED(hr) )
    {
        LocalFree(pCacheTemp);
        pCacheTemp = NULL;
    }
    *ppCacheItem = pCacheTemp;

    TraceLeaveResult(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ACLUI.rc
//
#define IDS_SECURITY                    1
#define IDS_NAME                        2
#define IDS_VIEW                        3
#define IDS_INITDLG_FAILED              4
#define IDS_OUT_OF_MEMORY               5
#define IDS_OPERATION_FAILED            6
#define IDS_SID_UNKNOWN                 7
#define IDS_SID_DELETED                 8
#define IDS_GET_USER_FAILED             9
#define IDS_SID_LOOKUP_FAILED           10
#define IDS_RESET_DACL_WARNING          11
#define IDS_FMT_USER_DISPLAY            12
#define IDS_FMT_CHECKLABEL              13
#define IDS_PERM_READONLY               16
#define IDS_PERM_WRITE_FAILED           17
#define IDS_PERM_NOT_CANONICAL          18
#define IDS_PERM_DENY_ALL               19
#define IDS_PERM_CANT_REMOVE            20
#define IDS_PERM_CANT_READ_CAN_WRITE_DACL 21
#define IDS_PERM_CANT_READ_CAN_WRITE_OWNER 22
#define IDS_PERM_CANT_READ_CAN_AUDIT    23
#define IDS_PERM_CANT_READ_CAN_AUDIT_WRITE_OWNER 24
#define IDS_PERM_NO_ACCESS              25
#define IDS_AUDIT_WRITE_FAILED          26
#define IDS_AUDIT_OFF_WARNING           27
#define IDS_OWNER_READONLY              28
#define IDS_OWNER_WRITE_FAILED          29
#define IDS_OWNER_CANT_DISPLAY          30
#define IDS_PERM_DENY                   31
#define IDS_SPP_TITLE                   32
#define IDS_ACEL_TITLE                  33
#define IDS_ACEE_PERM_TITLE             34
#define IDS_ACEE_AUDIT_TITLE            35
#define IDS_ACEE_PROPERTY_TITLE         36
#define IDS_ACE_PERM_COLUMN_TYPE        37
#define IDS_ACE_PERM_COLUMN_NAME        38
#define IDS_ACE_PERM_COLUMN_ACCESS      39
#define IDS_ACE_PERM_COLUMN_INHERIT     40
#define IDS_ACE_AUDIT_COLUMN_TYPE       41
#define IDS_ACE_AUDIT_COLUMN_NAME       42
#define IDS_ACE_AUDIT_COLUMN_ACCESS     43
#define IDS_ACE_AUDIT_COLUMN_INHERIT    44
#define IDS_ALLOW                       48
#define IDS_DENY                        49
#define IDS_AUDIT                       50
#define IDS_ALARM                       51
#define IDS_UNKNOWN                     52
#define IDS_SPECIAL                     53
#define IDS_AUDITPASS                   54
#define IDS_AUDITFAIL                   55
#define IDS_AUDITBOTH                   56
#define IDS_READ_PROP                   57
#define IDS_WRITE_PROP                  58
#define IDS_READ_WRITE_PROP             59
#define IDS_THIS_OBJECT_ONLY            60
#define IDS_THIS_OBJECT_AND_SUBOBJECTS  61
#define IDS_SUBOBJECTS_ONLY             62
#define IDS_INVALID_INHERIT             63
#define IDS_SELCHANGE_WARNING           64
#define IDS_FMT_ACE_DESC                65
#define IDS_PERMISSION_LOCALACE_DESC    66
#define IDS_AUDITENTRY_LOCALACE_DESC    67
#define IDS_PERMISSION_INHERITEDACE_DESC 68
#define IDS_AUDITENTRY_INHERITEDACE_DESC 69
#define IDS_PERMISSION_INHERITEDONLYACE_DESC 70
#define IDS_AUDITENTRY_INHERITEDONLYACE_DESC 71
#define IDS_PERMISSION_NOINHERIT_DESC   72
#define IDS_AUDITENTRY_NOINHERIT_DESC   73
#define IDS_PERMISSION_DOESINHERIT_DESC 74
#define IDS_AUDITENTRY_DOESINHERIT_DESC 75
#define IDS_CUSTOM                      76
#define IDS_CUSTOM_CHECKBOX_WARNING     77
#define IDS_PERM_CANT_READ_MAY_WRITE_DACL 78
#define IDS_CONFIRM_MULTIPLE_DELETION   79
#define IDS_PERMISSIONS                 80
#define IDS_PERMISSION_INHERITEDONLYACE_DESC_PARENT 81
#define IDS_AUDITENTRY_INHERITEDONLYACE_DESC_PARENT 82
#define IDS_PERMISSION_INHERITEDACE_DESC_PARENT 83
#define IDS_AUDITENTRY_INHERITEDACE_DESC_PARENT 84
#define IDS_DYNAMIC_PERMISSION          85
#define IDS_ACE_PERM_COLUMN_PARENT      86
#define IDS_FROM_PARENT                 87
#define IDS_NOT_INHERITED               88
#define IDS_EFF_ERROR                   89
#define IDS_SID_DELETED_1               90
#define IDS_SID_UNKNOWN_1               91
#define IDS_NO_OBJECT_PERM              92
#define IDS_ACL_SIZE_ERROR              93
#define IDS_ACL_SIZE_ERROR_ADV          94
#define IDS_BLOAT_AUDIT_WARN            95
#define IDS_BLOAT_PERM_WARN             96
#define IDS_BLOAT_AUDIT_LINE1           97
#define IDS_BLOAT_PERM_LINE1            98
#define IDS_BLOAT_AUDIT_LINE2           99
#define IDS_BLOAT_PERM_LINE2            100
#define IDB_SID_ICONS                   101
#define IDS_AUDITING                    101
#define IDB_LOCKS                       102
#define IDS_ACLBLOAT_NO_LIST_LINE1      102
#define IDD_SIMPLE_PERM_PAGE            103
#define IDS_ACLBLOAT_NO_LIST_SACL_LINE1 103
#define IDD_ACELIST_PERM_PAGE           104
#define IDS_BLOAT_AUDIT_LINE2_NOHELP    104
#define IDD_ACELIST_AUDIT_PAGE          105
#define IDS_BLOAT_PERM_LINE2_NOHELP     105
#define IDD_ACEENTRY_PERM_PAGE          106
#define IDD_ACEENTRY_AUDIT_PAGE         107
#define IDD_OWNER_PAGE                  108
#define IDD_CONFIRM_DACL_PROTECT        109
#define IDD_CONFIRM_SACL_PROTECT        110
#define IDD_EFFECTIVE_PERM_PAGE         111
#define IDB_CHECKBOX                    112
#define IDD_ACLBLOAT                    113
#define IDD_BLOAT_NO_LIST               126
#define IDD_BLOAT_NO_LIST_SACL          127
#define IDC_SPP_PRINCIPALS              1000
#define IDC_SPP_ADD                     1001
#define IDC_SPP_REMOVE                  1002
#define IDC_SPP_PERMS                   1004
#define IDC_SPP_ADVANCED                1005
#define IDC_SPP_MORE_MSG                1006
#define IDC_SPP_PROTECT                 1007
#define IDC_SPP_ACCESS                  1008
#define IDC_ACLBLOAT_LINE1              1008
#define IDC_SPP_ALLOW                   1009
#define IDC_SPP_DENY                    1010
#define IDC_SPP_DONTCARE                1011
#define IDC_SPP_NO_SECURITY             1012
#define IDC_SPP_GROUP_USER_NAME         1013
#define IDC_ACEL_DETAILS                2001
#define IDC_ACEL_ADD                    2002
#define IDC_ACEL_REMOVE                 2003
#define IDC_ACEL_EDIT                   2004
#define IDC_ACEL_RESET                  2005
#define IDC_ACEL_PROTECT                2006
#define IDC_ACEL_DESCRIPTION            2007
#define IDC_ACEL_RESET_ACL_TREE         2008
#define IDC_ACEE_NAMEBUTTON             4000
#define IDC_ACEE_NAME                   4001
#define IDC_ACEE_INHERITTYPE            4002
#define IDC_ACEE_INHERITIMMEDIATE       4003
#define IDC_ACEE_LIST                   4004
#define IDC_ACEE_ACCESS                 4005
#define IDC_ACEE_ALLOW                  4006
#define IDC_ACEE_DENY                   4007
#define IDC_ACEE_DONTCARE               4008
#define IDC_ACEE_CLEAR                  4009
#define IDC_ACEE_NAME_STATIC            4010
#define IDC_ACEE_APPLYONTO_STATIC       4011
#define IDC_ACEE_INHERITWARNING         4012
#define IDC_OWN_CURRENTOWNER            5001
#define IDC_OWN_OWNERLIST               5002
#define IDC_OWN_RESET                   5003
#define IDC_OWN_RECURSE                 5004
#define IDC_OWN_CURRENTOWNER_STATIC     5005
#define IDC_OWN_OWNERLIST_STATIC        5006
#define IDC_CONFIRM_ICON                6001
#define IDC_CONFIRM_MESSAGE             6002
#define IDC_CONFIRM_COPY                6003
#define IDC_CONFIRM_REMOVE              6004
#define IDC_EFF_SELECT                  7007
#define IDC_EFF_PERM_LIST               7009
#define IDC_EFF_NAME                    7013
#define IDC_EFF_NAME_STATIC             7014
#define IDC_EFF_PERMISSION_STATIC       7015
#define IDC_NO_EFFECTIVE                7016
#define IDC_ACEL_DEFAULT_STATIC         7019
#define IDC_ACEL_STATIC                 7020
#define IDC_EFF_STATIC                  7021
#define IDC_EFF_ERROR                   7023
#define IDC_SPP_ACCESS_BIG              7024
#define IDC_EDIT1                       7025
#define IDC_SPP_STATIC_ADV              7026
#define IDC_STATIC_NO_PERM              7027
#define IDC_ACEL_BLOAT                  7028
#define IDC_ACLB_WARNING                7029
#define IDC_BLOAT_LV_STATIC             7030
#define IDC_BLOAT_WARN_ICON             7031
#define IDC_BLOAT_LINE1_STATIC          7032
#define IDC_BLOAT_LINE2_STATIC          7033
#define IDC_WARNING                     7034
#define IDC_ACLB_LINE3                  7037
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         7038
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\perm.cpp ===
#include "aclpriv.h"

//Function for checking the Custom checkbox
VOID 
CheckCustom(HWND hwndList,
            WORD wColumn,      //Allow or Deny column
            DWORD dwState )
{
    //Custom is always the last checkbox
    UINT cRights = (UINT)SendMessage(hwndList, CLM_GETITEMCOUNT, 0, 0);

    //Don't check if the column is already checked. This fucntion is first
    //called for explicit and then for inherited aces. Effect is if explict aces are there
    //checkbox is enabled.

    DWORD dwStateCurrent = (DWORD)SendMessage(hwndList,
                                       CLM_GETSTATE,
                                       MAKELONG((WORD)(cRights -1), wColumn),
                                       0);

    if (dwStateCurrent & CLST_CHECKED) 
        return;
    //
    //Custom Checkbox is always disabled
    //

    SendMessage(hwndList,
                CLM_SETSTATE,
                MAKELONG((WORD)(cRights -1), wColumn),
                dwState|CLST_DISABLED);
}
VOID 
ClearCustom(HWND hwndList,
            WORD wColumn)      //Allow or Deny column
{
    //Custom is always the last checkbox
    UINT cRights = (UINT)SendMessage(hwndList, CLM_GETITEMCOUNT, 0, 0);
    //
    //Custom Checkbox is always disabled
    //
    SendMessage(hwndList,
                CLM_SETSTATE,
                MAKELONG((WORD)(cRights -1), wColumn),
                CLST_DISABLED);
}


//
// CPrincipal implementation
//

CPrincipal::~CPrincipal()
{
    if (NULL != m_pSID)
        LocalFree(m_pSID);

    LocalFreeString(&m_pszName);
    LocalFreeString(&m_pszDisplayName);
    if( m_hAdditionalAllow != NULL )
        DSA_Destroy( m_hAdditionalAllow );
    if( m_hAdditionalDeny != NULL )
        DSA_Destroy( m_hAdditionalDeny );
}


BOOL
CPrincipal::SetPrincipal(PSID pSID,
                         SID_NAME_USE sidType,
                         LPCTSTR pszName,
                         LPCTSTR pszLogonName)
{
    DWORD dwLength;

    TraceEnter(TRACE_PRINCIPAL, "CPrincipal::SetPrincipal");
    TraceAssert(pSID != NULL);
    TraceAssert(IsValidSid(pSID));

    if (NULL != m_pSID)
        LocalFree(m_pSID);

    m_pSID = LocalAllocSid(pSID);

    SetSidType(sidType);
    SetName(pszName, pszLogonName);

    TraceLeaveValue(NULL != m_pSID);
}


BOOL
CPrincipal::SetName(LPCTSTR pszName, LPCTSTR pszLogonName)
{
    LocalFreeString(&m_pszName);
    m_bHaveRealName = FALSE;

    if (BuildUserDisplayName(&m_pszName, pszName, pszLogonName))
        m_bHaveRealName = TRUE;
    else
        ConvertSidToStringSid(m_pSID, &m_pszName);
    
    if(pszName)
    {
        LocalFreeString(&m_pszDisplayName);
        LocalAllocString(&m_pszDisplayName, pszName);
    }           

    return (NULL != m_pszName);
}


CPermissionSet*
CPrincipal::GetPermSet(DWORD dwType, BOOL bInherited)
{
    CPermissionSet *pPermSet = NULL;

    TraceEnter(TRACE_PRINCIPAL, "CPrincipal::GetPermSet");

    switch (dwType)
    {
    case ACCESS_DENIED_ACE_TYPE:
        if (bInherited)
            pPermSet = &m_permInheritedDeny;
        else
            pPermSet = &m_permDeny;
        break;

    case ACCESS_ALLOWED_ACE_TYPE:
        if (bInherited)
            pPermSet = &m_permInheritedAllow;
        else
            pPermSet = &m_permAllow;
        break;

    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        // We don't handle compound ACEs
        TraceMsg("Ignoring ACCESS_ALLOWED_COMPOUND_ACE");
        break;

#ifdef DEBUG
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
    default:
        // We only process the various ACCESS_ALLOWED_* and ACCESS_DENIED_*
        // ACE types, except for ACCESS_ALLOWED_COMPOUND_ACE_TYPE, and these
        // are all accounted for above.  Something is very wrong if we get
        // an audit/alarm ACE or some unknown/future ACE type.
        TraceAssert(FALSE);
        break;
#endif
    }

    TraceLeaveValue(pPermSet);
}

BOOL
CPrincipal::AddNormalAce(DWORD dwType, DWORD dwFlags, ACCESS_MASK mask, const GUID *pObjectType)
{
    BOOL fResult = FALSE;

    TraceEnter(TRACE_PRINCIPAL, "CPrincipal::AddNormalAce");

    CPermissionSet *pPermSet = GetPermSet(dwType, (BOOL)(dwFlags & INHERITED_ACE));
    if (pPermSet)
        fResult = pPermSet->AddAce(pObjectType, mask, dwFlags);

    TraceLeaveValue(fResult);
}


BOOL
CPrincipal::AddAdvancedAce(DWORD dwType, PACE_HEADER pAce)
{
    BOOL fResult = FALSE;

    TraceEnter(TRACE_PRINCIPAL, "CPrincipal::AddAdvancedAce");

    CPermissionSet *pPermSet = GetPermSet(dwType, AceInherited(pAce));
    if (pPermSet)
        fResult = pPermSet->AddAdvancedAce(pAce);

    TraceLeaveValue(fResult);
}


BOOL
CPrincipal::AddAce(PACE_HEADER pAce)
{
    TraceEnter(TRACE_PRINCIPAL, "CPrincipal::AddAce");
    TraceAssert(pAce != NULL);

    BOOL fResult = FALSE;
    const GUID *pObjectType = NULL;
    UCHAR AceType = pAce->AceType;
    UCHAR AceFlags = pAce->AceFlags;
    ACCESS_MASK AccessMask = ((PKNOWN_ACE)pAce)->Mask;
    ULONG ulObjectFlags = 0;

    // Get the object type GUID from object ACEs
    if (IsObjectAceType(pAce))
    {
        AceType -= (ACCESS_ALLOWED_OBJECT_ACE_TYPE - ACCESS_ALLOWED_ACE_TYPE);
        ulObjectFlags = ((PKNOWN_OBJECT_ACE)pAce)->Flags;

        if (m_pPage->m_wDaclRevision < ACL_REVISION_DS)
            m_pPage->m_wDaclRevision = ACL_REVISION_DS;

        pObjectType = RtlObjectAceObjectType(pAce);
    }

    if (!pObjectType)
        pObjectType = &GUID_NULL;

    // Map any generic bits to standard & specific bits.
    m_pPage->m_psi->MapGeneric(pObjectType, &AceFlags, &AccessMask);

    // Can't have INHERIT_ONLY_ACE without either CONTAINER_INHERIT_ACE or
    // OBJECT_INHERIT_ACE, so if we find one of these, skip it.
    if ((AceFlags & (INHERIT_ONLY_ACE | ACE_INHERIT_ALL)) != INHERIT_ONLY_ACE)
    {
        //
        //ACE_INHERITED_OBJECT_TYPE_PRESENT is invalid without
        //either of container inherit or object inherit flags.
        //NTRAID#NTBUG9-287737-2001/01/23-hiteshr
        //
        if (ulObjectFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT && 
            AceFlags & ACE_INHERIT_ALL)
        {
            // If we have an inherit object type without INHERIT_ONLY_ACE,
            // and the inherit object type matches the current object,
            // then it applies to this object.  Simulate this (per the
            // ACL inheritance spec) with 2 ACEs: one with no inheritance
            // at all, and one with the inherit type + INHERIT_ONLY_ACE.

            // Does it apply to this object?
            if ((m_pPage->m_siObjectInfo.dwFlags & SI_OBJECT_GUID) &&
                !(AceFlags & INHERIT_ONLY_ACE) &&
                IsSameGUID(&m_pPage->m_siObjectInfo.guidObjectType, RtlObjectAceInheritedObjectType(pAce)))
            {
                // Mask out all flags except INHERITED_ACE and add it
                AddNormalAce(AceType, (AceFlags & INHERITED_ACE), AccessMask, pObjectType);

                // Turn on INHERIT_ONLY_ACE before adding the "advanced" ACE.
                pAce->AceFlags |= INHERIT_ONLY_ACE;
            }

            // The ACE does not apply directly to this object
            fResult = AddAdvancedAce(AceType, pAce);
        }
        else
        {
            fResult = AddNormalAce(AceType, AceFlags, AccessMask, pObjectType);
        }
    }

    TraceLeaveValue(fResult);
}


ULONG
CPrincipal::GetAclLength(DWORD dwFlags)
{
    // Return an estimate of the buffer size needed to hold the
    // requested ACEs. The size of the ACL header is NOT INCLUDED.

    // The following flags are always assumed:
    // ACL_DENY | ACL_ALLOW | ACL_NONOBJECT | ACL_OBJECT

    ULONG nAclLength = 0;
    ULONG nSidLength;

    TraceEnter(TRACE_PRINCIPAL, "CPrincipal::GetAclLength");
    TraceAssert(NULL != m_pSID);

    if (NULL == m_pSID)
        TraceLeaveValue(0);

    nSidLength = GetLengthSid(m_pSID);

    if (dwFlags & ACL_NONINHERITED)
    {
        nAclLength += m_permDeny.GetAclLength(nSidLength);
        nAclLength += m_permAllow.GetAclLength(nSidLength);
    }

    if (dwFlags & ACL_INHERITED)
    {
        nAclLength += m_permInheritedDeny.GetAclLength(nSidLength);
        nAclLength += m_permInheritedAllow.GetAclLength(nSidLength);
    }

    TraceLeaveValue(nAclLength);
}

BOOL
CPrincipal::AppendToAcl(PACL pAcl,
                        DWORD dwFlags,
                        PACE_HEADER *ppAcePos)  // position to copy first ACE
{
    PACE_HEADER pAceT;

    TraceEnter(TRACE_PRINCIPAL, "CPrincipal::AppendToAcl");
    TraceAssert(pAcl != NULL && IsValidAcl(pAcl));
    TraceAssert(ppAcePos != NULL);
    TraceAssert(NULL != m_pSID);

    if (NULL == m_pSID)
        TraceLeaveValue(FALSE);

    pAceT = *ppAcePos;

    // Build the ACL in the following order:
    //      Deny
    //      Allow
    //      Inherited Deny
    //      Inherited Allow

    if (dwFlags & ACL_NONINHERITED)
    {
        if (dwFlags & ACL_DENY)
            m_permDeny.AppendToAcl(pAcl, ppAcePos, m_pSID, FALSE, dwFlags);

        if (dwFlags & ACL_ALLOW)
            m_permAllow.AppendToAcl(pAcl, ppAcePos, m_pSID, TRUE, dwFlags);
    }

    if (dwFlags & ACL_INHERITED)
    {
        if (dwFlags & ACL_DENY)
            m_permInheritedDeny.AppendToAcl(pAcl, ppAcePos, m_pSID, FALSE, dwFlags);

        if (dwFlags & ACL_ALLOW)
            m_permInheritedAllow.AppendToAcl(pAcl, ppAcePos, m_pSID, TRUE, dwFlags);
    }

    if ((dwFlags & ACL_CHECK_CREATOR) && IsCreatorSid(m_pSID))
    {
        //
        // Special case for CreatorOwner/CreatorGroup,
        // which are only useful if inherit bits are set.
        //
        for (; pAceT < *ppAcePos; pAceT = (PACE_HEADER)NextAce(pAceT))
        {
            pAceT->AceFlags |= INHERIT_ONLY_ACE;
            if (!(pAceT->AceFlags & ACE_INHERIT_ALL))
            {
                pAceT->AceFlags |= ACE_INHERIT_ALL;

                //
                // Give the client a chance to adjust the flags.
                // E.g. DS always turns off OBJECT_INHERIT_ACE
                //
                UCHAR AceFlags = pAceT->AceFlags;
                ACCESS_MASK Mask = GENERIC_ALL;
                m_pPage->m_psi->MapGeneric(NULL, &AceFlags, &Mask);
                pAceT->AceFlags = AceFlags;
            }
        }
    }

    TraceAssert(IsValidAcl(pAcl));
    TraceLeaveValue(TRUE);
}


BOOL
CPrincipal::HaveInheritedAces(void)
{
    return (m_permInheritedAllow.GetPermCount(TRUE) || m_permInheritedDeny.GetPermCount(TRUE));
}


void
CPrincipal::ConvertInheritedAces(BOOL bDelete)
{
    if (bDelete)
    {
        m_permInheritedDeny.Reset();
        m_permInheritedAllow.Reset();
    }
    else
    {
        m_permDeny.ConvertInheritedAces(m_permInheritedDeny);
        m_permAllow.ConvertInheritedAces(m_permInheritedAllow);
    }
}


void
CPrincipal::AddPermission(BOOL bAllow, PPERMISSION pperm)
{
    if (bAllow)
        m_permAllow.AddPermission(pperm);
    else
        m_permDeny.AddPermission(pperm);
}


void
CPrincipal::RemovePermission(BOOL bAllow, PPERMISSION pperm)
{
    if (bAllow)
        m_permAllow.RemovePermission(pperm);
    else
        m_permDeny.RemovePermission(pperm);
}


//
// CPermPage implementation
//

void
CPermPage::InitPrincipalList(HWND hDlg, PACL pDacl)
{
    TraceEnter(TRACE_PERMPAGE, "CPermPage::InitPrincipalList");
    TraceAssert(hDlg != NULL);

    HWND hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
    TraceAssert(hwndList != NULL);

    // Save the DACL revision
    if (pDacl != NULL)
    {
        m_wDaclRevision = pDacl->AclRevision;
    }

    // If we have a selection, remember the SID for later
    PSID psidTemp = NULL;
    LPPRINCIPAL pPrincipal = (LPPRINCIPAL)GetSelectedItemData(hwndList, NULL);
    if (pPrincipal != NULL)
        psidTemp = LocalAllocSid(pPrincipal->GetSID());

    // Empty out the list
    ListView_DeleteAllItems(hwndList);

    // Enumerate the new DACL and fill the list
    EnumerateAcl(hwndList, pDacl);

    // Try to re-select the previously selection
    if (psidTemp != NULL)
    {
        int cItems = ListView_GetItemCount(hwndList);

        LV_ITEM lvItem;
        lvItem.iSubItem = 0;
        lvItem.mask = LVIF_PARAM;

        // Look for the previously selected principal in the list
        while (cItems > 0)
        {
            --cItems;
            lvItem.iItem = cItems;

            ListView_GetItem(hwndList, &lvItem);
            pPrincipal = (LPPRINCIPAL)lvItem.lParam;

            if (EqualSid(psidTemp, pPrincipal->GetSID()))
            {
                SelectListViewItem(hwndList, cItems);
                break;
            }
        }

        LocalFree(psidTemp);
    }

    TraceLeaveVoid();
}



STDMETHODIMP
_InitCheckList(HWND hwndList,
               LPSECURITYINFO psi,
               const GUID* pguidObjectType,
               DWORD dwFlags,
               HINSTANCE hInstance,
               DWORD dwType,
               PSI_ACCESS *ppDefaultAccess)
{
    HRESULT hr;
    PSI_ACCESS pAccess;
    ULONG cAccesses;
    ULONG iDefaultAccess;
    TCHAR szName[MAX_PATH];

    TraceEnter(TRACE_MISC, "_InitCheckList");
    TraceAssert(psi != NULL);

    //
    // Retrieve the permission list
    //
    hr = psi->GetAccessRights(pguidObjectType,
                              dwFlags,
                              &pAccess,
                              &cAccesses,
                              &iDefaultAccess);
    if (SUCCEEDED(hr) && cAccesses > 0)
    {
        if (ppDefaultAccess != NULL)
            *ppDefaultAccess = &pAccess[iDefaultAccess];

        // Enumerate the permissions and add to the checklist
        for (ULONG i = 0; i < cAccesses; i++, pAccess++)
        {
            LPCTSTR pszName;

            // Only add permissions that have any of the flags specified in dwType
            if (!(pAccess->dwFlags & dwType))
                continue;

            pszName = pAccess->pszName;
            if (IS_INTRESOURCE(pszName))
            {
                TraceAssert(hInstance != NULL);

                if (LoadString(hInstance,
                               (UINT)((ULONG_PTR)pszName),
                               szName,
                               ARRAYSIZE(szName)) == 0)
                {
                    LoadString(::hModule,
                               IDS_UNKNOWN,
                               szName,
                               ARRAYSIZE(szName));
                }
                pszName = szName;
            }

            if (SendMessage(hwndList,
                            CLM_ADDITEM,
                            (WPARAM)pszName,
                            (LPARAM)pAccess) == -1)
            {
                DWORD dwErr = GetLastError();
                ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr), "Failed to add item to checklist");
            }
        }
    }

exit_gracefully:

    TraceLeaveResult(hr);
}



HRESULT
CPermPage::InitCheckList(HWND hDlg)
{
    HRESULT hr;
    TCHAR szName[MAX_PATH];
    PSI_ACCESS pAccess;

    TraceEnter(TRACE_PERMPAGE, "CPermPage::InitCheckList");
    TraceAssert(hDlg != NULL);


    HWND hwndList = GetDlgItem(hDlg, IDC_SPP_PERMS);    // checklist window
    TraceAssert(hwndList != NULL);

    DWORD dwType = SI_ACCESS_GENERAL;
    if (m_siObjectInfo.dwFlags & SI_CONTAINER)
        dwType |= SI_ACCESS_CONTAINER;

    // Enumerate the permissions and add to the checklist
    hr = _InitCheckList(hwndList,
                        m_psi,
                        NULL,
                        0,
                        m_siObjectInfo.hInstance,
                        dwType,
                        &m_pDefaultAccess);
    if (SUCCEEDED(hr))
    {
        //Add Custom Checkbox at the   bottom of checklist. Custom checkbox is added only if
        //Advanced Page is there
        if(m_bCustomPermission)
        {
            if( ( pAccess = (PSI_ACCESS)LocalAlloc( LPTR, sizeof( SI_ACCESS ) ) ) == NULL )
                ExitGracefully(hr, HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY), "Failed to allocate Memeory");

            pAccess->dwFlags = SI_ACCESS_CUSTOM; 

            LoadString(::hModule, IDS_CUSTOM, szName, ARRAYSIZE(szName));

            if (SendMessage(hwndList, CLM_ADDITEM, (WPARAM)szName, (LPARAM)pAccess) == -1)
            {
                DWORD dwErr = GetLastError();
                ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr), "Failed to add item to checklist");
            }
            //
            //Disable the custom checkbox
            //                
            ClearCustom(hwndList,1);
            ClearCustom(hwndList,2);
        }
    }
exit_gracefully:        
    TraceLeaveResult(hr);
}


//
// CAUTION  - This function modifies the ACEs in the ACL by setting
//            the AceType to 0xff (an invalid ACE type).
//
//This function goes through the ACL and groups the aces
//according to SID in PRINCIPAL objects.

void
CPermPage::EnumerateAcl(HWND hwndList, PACL pAcl)
{
    LPPRINCIPAL pPrincipal;
    PACE_HEADER pAce;
    int         iEntry;
    int         iTemp;
    PACE_HEADER paceTemp;
    HDPA        hSids = NULL;

    if (pAcl == NULL)
        return;

    TraceEnter(TRACE_PERMPAGE, "CPermPage::EnumerateAcl");

    TraceAssert(IsValidAcl(pAcl));
    TraceAssert(hwndList != NULL);

    hSids = DPA_Create(4);

    if (NULL == hSids)
        TraceLeaveVoid();

    for (iEntry = 0, pAce = (PACE_HEADER)FirstAce(pAcl);
         iEntry < pAcl->AceCount;
         iEntry++, pAce = (PACE_HEADER)NextAce(pAce))
    {
        // Skip ACEs that we've already seen
        if (pAce->AceType == 0xff)
            continue;

        // Found an ACE we haven't seen yet, must be a new principal
        pPrincipal = new CPrincipal(this);
        if (pPrincipal == NULL)
            continue;  // memory error (try to continue)

        // Initialize new principal
        if (!pPrincipal->SetPrincipal(GetAceSid(pAce)))
        {
            delete pPrincipal;
            continue;  // probably memory error (try to continue)
        }

        // Remember the SIDs so that later we can look up all the names
        // at once and then add them to the listview.
        DPA_AppendPtr(hSids, pPrincipal->GetSID());

         // The current ACE belongs to this principal, so add it
        pPrincipal->AddAce(pAce);

        // Mark the ACE so we don't look at it again
        pAce->AceType = 0xff;

        // Loop through the rest of the ACEs in the ACL looking
        // for the same SID
        paceTemp = pAce;
        for (iTemp = iEntry + 1; iTemp < pAcl->AceCount; iTemp++)
        {
            // Move pointer to the current ACE
            paceTemp = (PACE_HEADER)NextAce(paceTemp);

            // If this ACE belongs to the current principal, add it
            if (paceTemp->AceType != 0xff &&
                EqualSid(GetAceSid(paceTemp), pPrincipal->GetSID()))
            {
                // Same principal, add the ACE
                pPrincipal->AddAce(paceTemp);

                // Mark the ACE so we don't look at it again
                paceTemp->AceType = 0xff;
            }
        }

        if (-1 == AddPrincipalToList(hwndList, pPrincipal))
        {
            delete pPrincipal;
        }
    }

    // Launch thread to look up sids
    m_fBusy = TRUE;
    LookupSidsAsync(hSids,
                    m_siObjectInfo.pszServerName,
                    m_psi2,
                    GetParent(hwndList),
                    UM_SIDLOOKUPCOMPLETE);
    DPA_Destroy(hSids);

    TraceLeaveVoid();
}


HRESULT
CPermPage::SetPrincipalNamesInList(HWND hwndList, PSID pSid)
{
    TraceEnter(TRACE_PERMPAGE, "CPermPage::SetPrincipalNamesInList");

    HRESULT hr = S_OK;
    PUSER_LIST  pUserList = NULL;
    LPPRINCIPAL pPrincipal = NULL;
    LVITEM lvItem = {0};
    int cListItems;
    int iListItem;
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Enumerate through each entry in the list view
    cListItems = ListView_GetItemCount(hwndList);
    for (iListItem = 0; iListItem < cListItems; iListItem++)
    {
        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = iListItem;
        lvItem.iSubItem = 0;

        if (ListView_GetItem(hwndList, &lvItem))
        {
            pPrincipal = (LPPRINCIPAL) lvItem.lParam;

            if (pPrincipal != NULL)
            {
                // Are we looking for a particular principal?
                if (pSid && !EqualSid(pSid, pPrincipal->GetSID()))
                    continue;

                // Do we already have a good name?
                if (pPrincipal->HaveRealName())
                {
                    if (pSid)
                        break;  // only care about this principal, stop here
                    else
                        continue;   // skip this one and check the rest
                }

                // Lookup the SID for this principal in the cache
                LookupSid(pPrincipal->GetSID(),
                          m_siObjectInfo.pszServerName,
                          m_psi2,
                          &pUserList);

                if ((pUserList != NULL) && (pUserList->cUsers == 1))
                {
                    // The list should contain a single item
                    PUSER_INFO pUserInfo = &pUserList->rgUsers[0];

                    // Update the principal with this new name information
                    pPrincipal->SetSidType(pUserInfo->SidType);
                    pPrincipal->SetName(pUserInfo->pszName, pUserInfo->pszLogonName);

                    // Set the text of this item to the name we've found
                    lvItem.mask = LVIF_TEXT | LVIF_IMAGE;
                    lvItem.pszText = (LPTSTR)pPrincipal->GetName();
                    lvItem.iImage = pPrincipal->GetImageIndex();
                    ListView_SetItem(hwndList, &lvItem);

                    LocalFree(pUserList);
                }
            }
        }
    }

    SetCursor(hcur);

    TraceLeaveResult(hr);
}


int
CPermPage::AddPrincipalToList(HWND hwndList, LPPRINCIPAL pPrincipal)
{
    LVITEM lvItem;
    int iIndex = -1;

    TraceEnter(TRACE_PERMPAGE, "CPermPage::AddPrincipalToList");
    TraceAssert(hwndList != NULL);
    TraceAssert(pPrincipal != NULL);

    // Insert new principal into listview
    lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    lvItem.iItem = 0;
    lvItem.iSubItem = 0;
    lvItem.lParam = (LPARAM)pPrincipal;
    lvItem.pszText = (LPTSTR)pPrincipal->GetName();
    lvItem.iImage = pPrincipal->GetImageIndex();

    iIndex = ListView_InsertItem(hwndList, &lvItem);

    TraceLeaveValue(iIndex);
}

VOID 
CPermPage::SetPermLabelText(HWND hDlg)
{
    RECT rc;
    WCHAR szBuffer[MAX_COLUMN_CHARS];
    HWND hwndLabel;
    HWND hwndList;
    LPTSTR pszCaption = NULL;
    SIZE size;
    LPCWSTR pszUserName = NULL;
    CPrincipal * pPrincipal = NULL;
    int iIndex = 0;
    //Get Label Dimension
    hwndLabel = GetDlgItem(hDlg, IDC_SPP_ACCESS);
    GetClientRect(hwndLabel, &rc);
    MapDialogRect(hDlg,&rc);
    //Get Text Dimension
    HDC hdc = GetDC(hDlg);

    hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
    pPrincipal = (LPPRINCIPAL)GetSelectedItemData(hwndList, &iIndex);
    if(pPrincipal)
        pszUserName = pPrincipal->GetDisplayName();

    if(pszUserName)
        FormatStringID(&pszCaption, ::hModule, IDS_DYNAMIC_PERMISSION,pszUserName);
    else
        FormatStringID(&pszCaption, ::hModule, IDS_PERMISSIONS, NULL);

    GetTextExtentPoint32(hdc,pszCaption,wcslen(pszCaption),&size);   


   if(size.cx > rc.right)
   {
       hwndLabel = GetDlgItem(hDlg, IDC_SPP_ACCESS);
       EnableWindow(hwndLabel, FALSE);
       ShowWindow(hwndLabel,SW_HIDE);
       hwndLabel = GetDlgItem(hDlg, IDC_SPP_ACCESS_BIG);
       EnableWindow(hwndLabel, TRUE);
       ShowWindow(hwndLabel,SW_SHOW);
       SetWindowText(hwndLabel,pszCaption);
   }
   else
   {
       hwndLabel = GetDlgItem(hDlg, IDC_SPP_ACCESS_BIG);
       EnableWindow(hwndLabel, FALSE);
       ShowWindow(hwndLabel,SW_HIDE);
       hwndLabel = GetDlgItem(hDlg, IDC_SPP_ACCESS);
       EnableWindow(hwndLabel, TRUE);
       ShowWindow(hwndLabel,SW_SHOW);
       SetWindowText(hwndLabel,pszCaption);
   }
       hwndLabel = GetDlgItem(hDlg, IDC_EDIT1);
       SetWindowText(hwndLabel,pszCaption);

   LocalFreeString(&pszCaption);
   ReleaseDC(hDlg, hdc);
}


BOOL
CPermPage::InitDlg(HWND hDlg)
{
    HRESULT hr = S_OK;
    HWND hwnd;
    HWND hwndList;
    RECT rc;
    LV_COLUMN col;
    TCHAR szBuffer[MAX_COLUMN_CHARS];
    PSECURITY_DESCRIPTOR pSD = NULL;
    BOOL bUserNotified = FALSE;
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    TraceEnter(TRACE_PERMPAGE, "CPermPage::InitDlg");
    TraceAssert(hDlg != NULL);
    TraceAssert(m_psi != NULL);

    hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
    
    //
    // Create & set the image list for the listview.  If there is a
    // problem CreateSidImageList will return NULL which won't hurt
    // anything. In that case we'll just continue without an image list.
    //
    ListView_SetImageList(hwndList,
                          LoadImageList(::hModule, MAKEINTRESOURCE(IDB_SID_ICONS)),
                          LVSIL_SMALL);

    // Set extended LV style for whole line selection with InfoTips
    ListView_SetExtendedListViewStyleEx(hwndList,
                                        LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP,
                                        LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP);

    //
    // Add appropriate listview columns
    //
    GetClientRect(hwndList, &rc);

    col.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.iSubItem = 0;
    col.cx = rc.right;
    ListView_InsertColumn(hwndList, 0, &col);


    if (!(m_siObjectInfo.dwFlags & SI_ADVANCED))
    {
        // Hide the Advanced button
        hwnd = GetDlgItem(hDlg, IDC_SPP_ADVANCED);
        ShowWindow(hwnd, SW_HIDE);
        EnableWindow(hwnd, FALSE);
        hwnd = GetDlgItem(hDlg, IDC_SPP_STATIC_ADV);
        ShowWindow(hwnd, SW_HIDE);
        EnableWindow(hwnd, FALSE);
    }


    if (S_FALSE == m_hrLastPSPCallbackResult)
    {
        // The propsheetpage callback told us to not show any messages here.
        bUserNotified = TRUE;
    }

    //Additional Permissions?
    m_bCustomPermission =  (m_siObjectInfo.dwFlags & SI_ADVANCED) 
                            && !(m_siObjectInfo.dwFlags & SI_NO_ADDITIONAL_PERMISSION);
    
    if (m_bAbortPage)
    {
        // Disable everything except the Advanced button
        m_siObjectInfo.dwFlags |= SI_READONLY;
        EnableWindow(hwndList, FALSE);

        // The user should have been notified during the propsheetpage
        // callback, so don't put up another message now.
        bUserNotified = TRUE;
    }
    else
    {
        //
        // Initialize the checklist window
        //
        hr = InitCheckList(hDlg);
        FailGracefully(hr, "Failed to initialize checklist");

        //
        // Retrieve the DACL from the object and set it into the dialog
        //
        hr = m_psi->GetSecurity(DACL_SECURITY_INFORMATION, &pSD, FALSE);

        if (SUCCEEDED(hr))
        {
            // We always disable the advanced button until the SID name cache
            // is filled on our other thread. See the DlgProc handler for
            // UM_SIDLOOKUPCOMPLETE
            EnableWindow(GetDlgItem(hDlg, IDC_SPP_ADVANCED), FALSE);

            hr = SetDacl(hDlg, pSD);
            FailGracefully(hr, "SetDacl failed");
        }
        else if (hr == E_ACCESSDENIED)
        {
            if (!bUserNotified)
            {
                //
                // Can't read the DACL or Owner, figure out what we CAN do.
                //
                UINT idMsg = IDS_PERM_NO_ACCESS;
                UINT mbType = MB_OK | MB_ICONWARNING;

                if (!(m_siObjectInfo.dwFlags & SI_READONLY))
                {
                    if(!( m_siObjectInfo.dwFlags & SI_MAY_WRITE))
                        idMsg = IDS_PERM_CANT_READ_CAN_WRITE_DACL;
                    else
                        idMsg = IDS_PERM_CANT_READ_MAY_WRITE_DACL;
                }
                else
                {
                    //
                    // Can't write the DACL, can we write the owner or edit the SACL?
                    //
                    DWORD dwFlags = m_siObjectInfo.dwFlags & (SI_EDIT_AUDITS | SI_OWNER_READONLY);

                    // If we're not editing the owner, then we can't write it.
                    if (!(m_siObjectInfo.dwFlags & SI_EDIT_OWNER))
                        dwFlags |= SI_OWNER_READONLY;

                    switch(dwFlags)
                    {
                    case 0:
                        // Can write the Owner but can't edit the SACL
                        idMsg = IDS_PERM_CANT_READ_CAN_WRITE_OWNER;
                        break;

                    case SI_EDIT_AUDITS:
                        // Can edit the SACL and write the Owner
                        idMsg = IDS_PERM_CANT_READ_CAN_AUDIT_WRITE_OWNER;
                        break;

                    case SI_OWNER_READONLY:
                        // No Access
                        break;

                    case SI_OWNER_READONLY | SI_EDIT_AUDITS:
                        // Can edit the SACL but can't write the Owner
                        idMsg = IDS_PERM_CANT_READ_CAN_AUDIT;
                        break;
                    }
                }

                if (idMsg == IDS_PERM_NO_ACCESS)
                    mbType = MB_OK | MB_ICONERROR;

                MsgPopup(hDlg,
                         MAKEINTRESOURCE(idMsg),
                         MAKEINTRESOURCE(IDS_SECURITY),
                         mbType,
                         ::hModule,
                         m_siObjectInfo.pszObjectName);
                bUserNotified = TRUE;
            }

            EnablePrincipalControls(hDlg, FALSE);
            hr = S_OK;
        }
        else
        {
            FailGracefully(hr, "GetSecurity failed");
        }
    } // !m_bAbortPage

    if (m_siObjectInfo.dwFlags & SI_READONLY)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_SPP_ADD), FALSE);
        EnablePrincipalControls(hDlg, FALSE);

        // Tell the user that we're in read-only mode
        //Do not show this dialog box
        //Windows Bug 181665
        /*if (!bUserNotified)
        {
            MsgPopup(hDlg,
                     MAKEINTRESOURCE(IDS_PERM_READONLY),
                     MAKEINTRESOURCE(IDS_SECURITY),
                     MB_OK | MB_ICONINFORMATION,
                     ::hModule,
                     m_siObjectInfo.pszObjectName);

            bUserNotified = TRUE;
        }
        */
    }

exit_gracefully:

    if (pSD != NULL)
        LocalFree(pSD);

    SetCursor(hcur);

    if (FAILED(hr))
    {
        // Hide and disable everything
        for (hwnd = GetWindow(hDlg, GW_CHILD);
             hwnd != NULL;
             hwnd = GetWindow(hwnd, GW_HWNDNEXT))
        {
            ShowWindow(hwnd, SW_HIDE);
            EnableWindow(hwnd, FALSE);
        }

        // Enable and show the "No Security" message
        hwnd = GetDlgItem(hDlg, IDC_SPP_NO_SECURITY);
        EnableWindow(hwnd, TRUE);
        ShowWindow(hwnd, SW_SHOW);
    }

    TraceLeaveValue(TRUE);
}


BOOL
CPermPage::OnNotify(HWND hDlg, int /*idCtrl*/, LPNMHDR pnmh)
{
    LPNM_LISTVIEW pnmlv = (LPNM_LISTVIEW)pnmh;

    TraceEnter(TRACE_PERMPAGE, "CPermPage::OnNotify");
    TraceAssert(hDlg != NULL);
    TraceAssert(pnmh != NULL);

    // Set default return value
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

    switch (pnmh->code)
    {
    case LVN_ITEMCHANGED:
        if (pnmlv->uChanged & LVIF_STATE)
        {
            OnSelChange(hDlg);
            // item *gaining* selection
            if ((pnmlv->uNewState & LVIS_SELECTED) &&
                !(pnmlv->uOldState & LVIS_SELECTED))
            {
               //here bClearCustom should be False. We don't need to clear 
               //Custom when we select another principal. 
               //Build Additional List for it.
            }
            // item *losing* selection
            else if (!(pnmlv->uNewState & LVIS_SELECTED) &&
                     (pnmlv->uOldState & LVIS_SELECTED))
            {
                // Post ourselves a message to check for a new selection later.
                // If we haven't gotten a new selection by the time we process
                // this message, then assume the user clicked inside the listview
                // but not on an item, thus causing the listview to remove the
                // selection.  In that case, disable the combobox & Remove button.
                //
                // Do this via WM_COMMAND rather than WM_NOTIFY so we don't
                // have to allocate/free a NMHDR structure.
                PostMessage(hDlg,
                            WM_COMMAND,
                            GET_WM_COMMAND_MPS(pnmh->idFrom, pnmh->hwndFrom, IDN_CHECKSELECTION));
            }
        }
        break;

    case LVN_DELETEITEM:
        delete (LPPRINCIPAL)pnmlv->lParam;
        break;

    case LVN_KEYDOWN:
        if (((LPNMLVKEYDOWN)pnmh)->wVKey == VK_DELETE)
        {
            //Get the status of Remove button. Only if remove is 
            //enabled do something bug 390243
            if( IsWindowEnabled( GetDlgItem( hDlg,IDC_SPP_REMOVE )) )
                OnRemovePrincipal(hDlg);
        }
        break;

#ifdef UNUSED
    case NM_DBLCLK:
        if (pnmh->idFrom == IDC_SPP_PRINCIPALS)
        {
            // Must have a selection to get here
            TraceAssert(ListView_GetSelectedCount(pnmh->hwndFrom) == 1);

            // do something here
        }
        break;
#endif

    case CLN_CLICK:
        if (pnmh->idFrom == IDC_SPP_PERMS)
        {
            LPPRINCIPAL pPrincipal;
            int iIndex = -1;
            
            pPrincipal = (LPPRINCIPAL)GetSelectedItemData(GetDlgItem(hDlg, IDC_SPP_PRINCIPALS), &iIndex);
            if (pPrincipal)
            {
                PNM_CHECKLIST   pnmc    = (PNM_CHECKLIST)pnmh;
                PSI_ACCESS      pAccess = (PSI_ACCESS)pnmc->dwItemData;
                
                //Custom checkbox is clicked, reqiures special handling
                if( pAccess->dwFlags & SI_ACCESS_CUSTOM )
                {
                    if (pnmc->dwState & CLST_CHECKED)
                    {                                            
                        //Uncheck the Checkbox. Can checkbox be prevented from checked?
                        SendMessage(pnmc->hdr.hwndFrom,
                                    CLM_SETSTATE,
                                    MAKELONG((WORD)pnmc->iItem, (WORD)pnmc->iSubItem),
                                    0
                                    );       
                        
                        //Show the message box
                        MsgPopup(hDlg,
                                 MAKEINTRESOURCE(IDS_CUSTOM_CHECKBOX_WARNING),
                                 MAKEINTRESOURCE(IDS_SECURITY),
                                 MB_OK | MB_ICONINFORMATION,
                                 ::hModule);
                                          
                    }
                    else
                    {
                        SetDirty(hDlg);
                        //Clear the Special Checkbox and Permissions
                        BOOL bClearAllow = (1 == pnmc->iSubItem);    // 1 = Allow, 2 = Deny
                        OnSelChange(hDlg, TRUE, bClearAllow, !bClearAllow);
                    }
                    //Break out of Switch
                    break;
                }
            }


            //
            // HandleListClick decides which boxes should be checked and
            // unchecked, however, we can't rely only on that to generate
            // ACLs (we used to).  Suppose the principal has Full Control and
            // the user unchecks "Delete" which is a single bit.  If there is
            // no checkbox corresponding to "Full Control minus Delete" then
            // the principal would also lose other bits, such as WRITE_DAC.
            //
            // So let HandleListClick do its thing. Then remove permission
            // bits according to what was checked or unchecked.
            //
            // But wait, there's more. Removing permission bits turns off
            // too much. For example, if the principal has Full Control and
            // the user turns off Full Control, then the principal ends up
            // with nothing, even though HandleListClick leaves Modify
            // checked.
            //
            // So after removing what was just (un)checked, build new
            // permissions from what is still checked and add them.
            //
            // This yields the correct results, and also keeps the principal
            // up-to-date so we don't need to call CommitCurrent anywhere else.
            //
            // Raid 260952
            //

            //HandleListClick decides which boxes should be checked and unchecked.
            //If FullControl was intially Checked, we uncheck Read, Full Control is
            //also unchecked. If a checkbox was intially checked and unchecked in 
            //HandleListClick, its added to h[Allow/Deny]UncheckedAccess list.
            //Permission corresponding to these checkboxes is removed.
            

            // Check/uncheck appropriate boxes in both columns
            HDSA hAllowUncheckedAccess = NULL;
            HDSA hDenyUncheckedAccess = NULL;

            //Does appropriate check-uncheck.

            HandleListClick((PNM_CHECKLIST)pnmh,
                            SI_PAGE_PERM,
                            m_siObjectInfo.dwFlags & SI_CONTAINER,
                            &hAllowUncheckedAccess,
                            &hDenyUncheckedAccess,
                            m_bCustomPermission);

            pPrincipal = (LPPRINCIPAL)GetSelectedItemData(GetDlgItem(hDlg, IDC_SPP_PRINCIPALS), &iIndex);
            if (pPrincipal)
            {
                PNM_CHECKLIST   pnmc    = (PNM_CHECKLIST)pnmh;
                PSI_ACCESS      pAccess = (PSI_ACCESS)pnmc->dwItemData;
                PERMISSION      perm    = { pAccess->mask, 0, 0 };

                //If we uncheck Allow Read, Allow Read Checkbox goes into HandleListClick as
                //unchecked and is not in hAllowUncheckedAccess. Perm Corresponding to it 
                //especially removed.
                if(!(pnmc->dwState & CLST_CHECKED))
                {
                    // Which column was clicked?
                    BOOL bRemoveFromAllow = (1 == pnmc->iSubItem);    // 1 = Allow, 2 = Deny

                    if (pAccess->pguid)
                        perm.guid = *pAccess->pguid;

                    if (m_siObjectInfo.dwFlags & SI_CONTAINER)
                        perm.dwFlags = pAccess->dwFlags & VALID_INHERIT_FLAGS;

                    pPrincipal->RemovePermission(bRemoveFromAllow, &perm);
                }

                if( hAllowUncheckedAccess )
                {
                    UINT cItems = DSA_GetItemCount(hAllowUncheckedAccess);
                    PERMISSION permTemp;
                    while (cItems)
                    {
                        --cItems;
                        DSA_GetItem(hAllowUncheckedAccess, cItems, &pAccess);
                        permTemp.mask = pAccess->mask;
                        if (m_siObjectInfo.dwFlags & SI_CONTAINER)
                            permTemp.dwFlags = pAccess->dwFlags & VALID_INHERIT_FLAGS;
                        if( pAccess->pguid )
                            permTemp.guid = *pAccess->pguid;
                    
                        pPrincipal->RemovePermission(TRUE, &permTemp);
                    }
                    DSA_Destroy(hAllowUncheckedAccess);
                }

                if( hDenyUncheckedAccess )
                {
                    UINT cItems = DSA_GetItemCount(hDenyUncheckedAccess);
                    PERMISSION permTemp;
                    PSI_ACCESS pAccess2 = NULL;
                    while (cItems)
                    {
                        --cItems;
                        DSA_GetItem(hDenyUncheckedAccess, cItems, &pAccess2);
                        permTemp.mask = pAccess2->mask;
                        if (m_siObjectInfo.dwFlags & SI_CONTAINER)
                            permTemp.dwFlags = pAccess2->dwFlags & VALID_INHERIT_FLAGS;
                        if( pAccess2->pguid )
                            permTemp.guid = *pAccess2->pguid;
                    
                        pPrincipal->RemovePermission(FALSE, &permTemp);
                    }
                    DSA_Destroy(hDenyUncheckedAccess);
                }
            }

            SetDirty(hDlg);

            // Add perms according to what is still checked. This is required, since 
            // when i uncheck Read, full control is also unchecked and permission corresponding to 
            // it is removed. This will remove Write also, though its still checked.
            //CommitCurrent will add permission for checkboxes which are still checked.
            CommitCurrent(hDlg, iIndex);

            //Here i should add additional list to main list, but no need to rebuild addtional list

            // Reset the "There is more stuff" message
            OnSelChange(hDlg, FALSE);
        }
        break;

    case CLN_GETCOLUMNDESC:
        {
            PNM_CHECKLIST pnmc = (PNM_CHECKLIST)pnmh;
            GetDlgItemText(hDlg,
                           IDC_SPP_ALLOW - 1 + pnmc->iSubItem,
                           pnmc->pszText,
                           pnmc->cchTextMax);
        }
        break;

    case PSN_APPLY:
        OnApply(hDlg, (BOOL)(((LPPSHNOTIFY)pnmh)->lParam));
        break;
    default:
        TraceLeaveValue(FALSE); // message not handled
    }

    TraceLeaveValue(TRUE);  // message handled
}


    

BOOL
CheckPermissions(HWND hwndList,
                 CPermissionSet &PermSet,
                 WORD wColumn,
                 BOOL bDisabled,
                 BOOL bInheritFlags,
                 BOOL bCustom,      //Does Custom Checkbox exist?
                 BOOL bClearCustom,
                 HDSA hAdditional )//Clear Custom Permissions?
{
    UINT cRights = (UINT)SendMessage(hwndList, CLM_GETITEMCOUNT, 0, 0);

    //Custom Checkbox is handled separately the end.
    if( bCustom )
        --cRights;
    
    UINT cAces = PermSet.GetPermCount();
    BOOL bMorePresent = FALSE;
    WORD wOtherColumn;
    DWORD dwState = CLST_CHECKED;

    TraceEnter(TRACE_MISC, "CheckPermissions");

    HDSA hPermList;     //Temp List of PPERMISSION pointers
    if( bClearCustom )
    {
       hPermList = DSA_Create(SIZEOF(PPERMISSION), 4);
       if (hPermList == NULL)
       {
           TraceMsg("DSA_Create failed");
           TraceLeaveValue(FALSE);
       }
    }

    if (wColumn == 1)
        wOtherColumn = 2;
    else
        wOtherColumn = 1;

    if (bDisabled)
        dwState |= CLST_DISABLED;

    for (UINT j = 0; j < cAces; j++)
    {
        ACCESS_MASK maskChecked = 0;
        PPERMISSION pPerm = PermSet[j];
        BOOL bIsNullGuid = IsNullGUID(&pPerm->guid);
        //Igonre custom here
        for (UINT i = 0; i < cRights ; i++)
        {
            PSI_ACCESS pAccess = (PSI_ACCESS)SendMessage(hwndList,
                                                         CLM_GETITEMDATA,
                                                         i,
                                                         0);
            //
            // The below expression tests to see if this access mask enables
            // this access "rights" line.  It could have more bits enabled, but
            // as long as it has all of the ones from the pAccess[i].mask then
            // it effectively has that option enabled.
            //
            if ( (pPerm->mask & pAccess->mask) == pAccess->mask &&
                 (bIsNullGuid || IsSameGUID(&pPerm->guid, pAccess->pguid)) )
            {
                DWORD dwStateCompare;

                //
                // Next, check the inherit flags.
                //
                if (bInheritFlags)
                {
                    DWORD dwCommonFlags = pPerm->dwFlags & pAccess->dwFlags;

                    //
                    // This expression tests to see whether the ACE applies
                    // to all objects that this access rights line applies to.
                    // The ACE must have at least as many of (CONTAINER_INHERIT_ACE,
                    // OBJECT_INHERIT_ACE) turned on as the rights line, and
                    // if the ACE has INHERIT_ONLY_ACE, then so must the rights line.
                    //
                    if (!((dwCommonFlags & ACE_INHERIT_ALL) == (pAccess->dwFlags & ACE_INHERIT_ALL)
                          && (dwCommonFlags & INHERIT_ONLY_ACE) == (pPerm->dwFlags & INHERIT_ONLY_ACE)))
                    continue;
                }

                // The bits say it's checked. We may not actually check the box
                // below, but for other reasons. In any case, we don't want the
                // "Additional stuff is here but I can't show it" message to
                // display because of this perm.
                maskChecked |= pAccess->mask;

                //
                // Ok, the bits say that this box should be checked, but
                // if the other column is already checked and has the same
                // enabled/disabled state, then we don't check this one.
                // This keeps us from having both Allow and Deny checked &
                // enabled on the same line (nonsense) or checked & disabled
                // on the same line (both inherited; we must show both as 
                // Allow Inherited can preceede Deny Inherited and we 
                // don't know the order at this point.
                //
                
                if( !(pPerm->dwFlags & INHERITED_ACE) )
                {
                    dwStateCompare = (DWORD)SendMessage(hwndList,
                                                        CLM_GETSTATE,
                                                        MAKELONG((WORD)i, wOtherColumn),
                                                        0);
                    if ((dwStateCompare & CLST_CHECKED) &&
                        ((dwStateCompare & CLST_DISABLED) == (dwState & CLST_DISABLED)))
                        continue;
                }
                //
                // Next, see if the box is already checked. If so, leave it
                // alone. Note that we don't compare the enabled/disabled
                // state.  The effect here is that the first check wins.
                // Raid 326000
                //
                dwStateCompare = (DWORD)SendMessage(hwndList,
                                                    CLM_GETSTATE,
                                                    MAKELONG((WORD)i, wColumn),
                                                    0);
                if (dwStateCompare & CLST_CHECKED)
                    continue;

                //
                // Finally, check the box.
                //
                SendMessage(hwndList,
                            CLM_SETSTATE,
                            MAKELONG((WORD)i, wColumn),
                            dwState);
            }
        }

        if( bClearCustom )
        {
            //If an ace don't check anyof the checkboxes,( i.e. maskchecked = 0 ),
            //it should be removed when custom is unchecked.
            if( !maskChecked )
            {
                DSA_AppendItem(hPermList, &pPerm);
                maskChecked = pPerm->mask;      //this is done to make sure maskchecked is false          
            }
            //Ace checks some checkbox ( maskChecked), so it mask should be maskChecked
            else
                pPerm->mask = maskChecked;
        }

        // Does this ACE have bits that aren't shown on this dialog?
        if (maskChecked != pPerm->mask)
        {   
            ACCESS_MASK maskTemp = 0;
            //Add this ace to the list of additional aces,
            //but only the bits which are additional
            if( hAdditional )    
            {
                maskTemp = pPerm->mask;
                pPerm->mask &= ~maskChecked;
                DSA_AppendItem(hAdditional, pPerm);
                pPerm->mask = maskTemp;
            }
            bMorePresent = TRUE;
        }
    }

    if( bClearCustom )
    {
        UINT cItems = DSA_GetItemCount(hPermList);
        PPERMISSION pTemp = NULL;
        while (cItems)
        {
            --cItems;
            DSA_GetItem(hPermList, cItems, &pTemp);
            //Removes only the permission which match its inheritance flag, not others.
            //For example it this permission is read applied to subobjects and hence appear as
            //custom permission. On clearing the custom checkbox, only read permission applied to
            //subobjects should go, not the read permission applied to this object ( and/or subobjects)
            // which can be shown in other checkboxes.
            PermSet.RemovePermission(pTemp, TRUE);
            --cAces;
        }
      
        PermSet.ResetAdvanced();
        DSA_Destroy(hPermList);
    }

    // Does this permission set have "advanced" ACEs that aren't shown
    // on this dialog?
    if (!bMorePresent && cAces != PermSet.GetPermCount(TRUE))
        bMorePresent = TRUE;

    if( bMorePresent && bCustom )
        CheckCustom( hwndList, wColumn, dwState );

    TraceLeaveValue(bMorePresent);
}


void
CPermPage::OnSelChange(HWND hDlg, BOOL bClearFirst, BOOL bClearCustomAllow, BOOL bClearCustomDeny)
{
    BOOL bDisabled = m_siObjectInfo.dwFlags & SI_READONLY;

    TraceEnter(TRACE_PERMPAGE, "CPermPage::OnSelChange");
    TraceAssert(hDlg != NULL);

    //
    // If the principal list is empty or there is no selection, then we need
    // to disable all of the controls that operate on items in the listbox.
    //
    HWND hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
    TraceAssert(hwndList != NULL);

    // Get the selected principal
    LPPRINCIPAL pPrincipal = (LPPRINCIPAL)GetSelectedItemData(hwndList, NULL);

    // Enable/disable the other controls
    if (!bDisabled)
        EnablePrincipalControls(hDlg, pPrincipal != NULL);

    //Change the permission label to reflect the new User/Group
    SetPermLabelText(hDlg);

    if (pPrincipal == NULL)
        TraceLeaveVoid();   // no selection or empty list

    //
    // Check/uncheck the permission boxes
    //

    hwndList = GetDlgItem(hDlg, IDC_SPP_PERMS);
    TraceAssert(hwndList != NULL);

    if (bClearFirst)
    {
        // First need to uncheck everything
        ClearPermissions(hwndList, bDisabled);
    }

    BOOL bIsContainer = m_siObjectInfo.dwFlags & SI_CONTAINER;
    BOOL bMorePresent = FALSE;

    //Clear the Custom Checkboxes. This is the only place where Custom Checkbox is cleared
    if(m_bCustomPermission)
    {
        ClearCustom(hwndList,1);
        ClearCustom(hwndList,2);
    }

    if( !pPrincipal->m_hAdditionalAllow )
    {
       pPrincipal->m_hAdditionalAllow = DSA_Create(SIZEOF(PERMISSION), 4);
       if (pPrincipal->m_hAdditionalAllow == NULL)
       {
           TraceMsg("DSA_Create failed");
           TraceLeaveVoid();
       }

    }
    if( !pPrincipal->m_hAdditionalDeny )
    {
       pPrincipal->m_hAdditionalDeny = DSA_Create(SIZEOF(PERMISSION), 4);
       if (pPrincipal->m_hAdditionalDeny == NULL)
       {
           TraceMsg("DSA_Create failed");
           TraceLeaveVoid();
       }

    }
    
    UINT cItems = DSA_GetItemCount(pPrincipal->m_hAdditionalAllow);
    PPERMISSION pPermTemp;
    while (cItems)
    {
        --cItems;
        pPermTemp = (PPERMISSION)DSA_GetItemPtr(pPrincipal->m_hAdditionalAllow, cItems );
        if(pPermTemp)
            pPrincipal->AddPermission(TRUE, pPermTemp);
    }
    DSA_DeleteAllItems(pPrincipal->m_hAdditionalAllow);

    cItems = DSA_GetItemCount(pPrincipal->m_hAdditionalDeny);
    while (cItems)
    {
        --cItems;
        pPermTemp = (PPERMISSION)DSA_GetItemPtr(pPrincipal->m_hAdditionalDeny, cItems );
        if(pPermTemp)
            pPrincipal->AddPermission(FALSE, pPermTemp);
    }
    DSA_DeleteAllItems(pPrincipal->m_hAdditionalDeny);

    bMorePresent |= CheckPermissions(hwndList, 
                                     pPrincipal->m_permDeny, 
                                     2, 
                                     bDisabled, 
                                     bIsContainer, 
                                     m_bCustomPermission, 
                                     bClearCustomDeny,
                                     pPrincipal->m_hAdditionalDeny);
    bMorePresent |= CheckPermissions(hwndList, 
                                     pPrincipal->m_permAllow, 
                                     1, 
                                     bDisabled, 
                                     bIsContainer, 
                                     m_bCustomPermission, 
                                     bClearCustomAllow,
                                     pPrincipal->m_hAdditionalAllow);
    bMorePresent |= CheckPermissions(hwndList, 
                                     pPrincipal->m_permInheritedDeny, 
                                     2, 
                                     TRUE, 
                                     bIsContainer, 
                                     m_bCustomPermission, 
                                     FALSE, 
                                     NULL);
    bMorePresent |= CheckPermissions(hwndList, 
                                     pPrincipal->m_permInheritedAllow, 
                                     1, 
                                     TRUE, 
                                     bIsContainer, 
                                     m_bCustomPermission, 
                                     FALSE,NULL);

    if (m_siObjectInfo.dwFlags & SI_ADVANCED)
    {
        ShowWindow(GetDlgItem(hDlg, IDC_SPP_MORE_MSG),
                   (bMorePresent ? SW_SHOW : SW_HIDE));

        
    }
    else if (bMorePresent)
    {
        TraceMsg("Ignoring unknown permissions");
    }

    TraceLeaveVoid();
}

void
CPermPage::OnApply(HWND hDlg, BOOL bClose)
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pSD;

    TraceEnter(TRACE_PERMPAGE, "CPermPage::OnApply");

    // Build a new DACL without the inherited ACEs.
    if (m_fPageDirty && SUCCEEDED(hr = BuildDacl(hDlg, &pSD, FALSE)) && (hr != S_FALSE))
    {
        PISECURITY_DESCRIPTOR psd = (PISECURITY_DESCRIPTOR)pSD;
        DWORD dwWarning = 0;
        SECURITY_INFORMATION si = DACL_SECURITY_INFORMATION;

        TraceAssert(pSD != NULL);
        TraceAssert(m_psi != NULL);

        // Check for Deny ACEs in the ACL
        if (!m_bWasDenyAcl)
        {
            DWORD dwFullControl = GENERIC_ALL;
            UCHAR aceFlags = 0;

            m_psi->MapGeneric(NULL, &aceFlags, &dwFullControl);
            if (IsDenyACL(psd->Dacl,
                          (psd->Control & SE_DACL_PROTECTED),
                          dwFullControl,
                          &dwWarning))
            {
                TraceAssert(dwWarning != 0);

                // Warn the user about Deny ACEs
                if (IDNO == MsgPopup(hDlg,
                                     MAKEINTRESOURCE(dwWarning),
                                     MAKEINTRESOURCE(IDS_SECURITY),
                                     MB_YESNO | MB_ICONWARNING,
                                     ::hModule,
                                     m_siObjectInfo.pszObjectName))
                {
                    hr = S_FALSE;
                }
            }
        }

        if (S_FALSE != hr)
        {
			if(!IsAclBloated(hDlg, si, pSD, m_cInheritableAces, m_siObjectInfo.dwFlags & SI_EDIT_PROPERTIES))
			{
				// Apply the new security descriptor on the object
				hr = m_psi->SetSecurity(si, pSD);
			}
			else
				hr = S_FALSE;
        }

        if (S_OK == hr)
        {
            LocalFree(pSD);
            pSD = NULL;
            m_fPageDirty = FALSE;

            if (!bClose)
            {
                //
                // Read the new DACL back from the object.  This ensures that we
                // have the "real" current DACL in case it was modified by the
                // object.  For example, inherited aces may have been added.
                //
                // This also resets the dialog to the initial state if the
                // user chose No in the confirmation dialog above.
                //
                if (SUCCEEDED(m_psi->GetSecurity(DACL_SECURITY_INFORMATION, &pSD, FALSE)))
                    SetDacl(hDlg, pSD);
            }
        }
        else if (S_FALSE == hr)
        {
            // S_FALSE is silent failure (the client should put up UI
            // during SetSecurity before returning S_FALSE).
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
        }

        if (pSD != NULL)
            LocalFree(pSD);
    }

    if (FAILED(hr))
    {
        // Tell the user there was a problem.  If they choose to cancel
        // and the dialog is closing, do nothing (let the dialog close).
        // Otherwise, tell the property sheet that we had a problem.
        if (IDCANCEL != SysMsgPopup(hDlg,
                                    MAKEINTRESOURCE(IDS_PERM_WRITE_FAILED),
                                    MAKEINTRESOURCE(IDS_SECURITY),
                                    (bClose ? MB_RETRYCANCEL : MB_OK) | MB_ICONERROR,
                                    ::hModule,
                                    hr,
                                    m_siObjectInfo.pszObjectName))
        {
            // Return PSNRET_INVALID to abort the Apply and cause the sheet to
            // select this page as the active page.
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
        }
    }

    TraceLeaveVoid();
}

/*-----------------------------------------------------------------------------
/ BuildDacl
/ -------
/  Convert the listbox entries into SD. If the size of security descriptor
/  is more than Max allowed shows a dialog box.
/  ppSD can be NULL for the cases where we want to verify if the SD size is
/  not execeeding the max size.
/
/----------------------------------------------------------------------------*/

HRESULT
CPermPage::BuildDacl(HWND hDlg,
                     PSECURITY_DESCRIPTOR *ppSD,
                     BOOL fIncludeInherited)
{
    PISECURITY_DESCRIPTOR pSD;
    ULONG nAclSize;
    LPPRINCIPAL pPrincipal;
    int cPrincipals = 0;
    DWORD dwFlags;
    int i, j;
    HCURSOR hcur = NULL;
    HWND hwndList = NULL;
    LV_ITEM lvItem;
    lvItem.mask = LVIF_PARAM;
    lvItem.iSubItem = 0;

    static DWORD dwCanonicalFlags[] =
    {
        ACL_DENY | ACL_NONOBJECT,
        ACL_DENY | ACL_OBJECT,
        ACL_ALLOW | ACL_NONOBJECT,
        ACL_ALLOW | ACL_OBJECT
    };

    TraceEnter(TRACE_PERMPAGE, "CPermPage::BuildDacl");
    TraceAssert(hDlg != NULL);

    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    // Estimate the size of the buffer necessary to build the
    // Security Descriptor.
    //

    hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
    cPrincipals = ListView_GetItemCount(hwndList);

    dwFlags = ACL_NONINHERITED;
    if (fIncludeInherited)
        dwFlags |= ACL_INHERITED;

	WORD nMaxAclSize = 0xffff;
    nAclSize = SIZEOF(ACL);

    for (i = 0; i < cPrincipals; i++)
    {
        lvItem.iItem = i;
        if (ListView_GetItem(hwndList, &lvItem))
        {
            pPrincipal = (LPPRINCIPAL)lvItem.lParam;
            nAclSize += pPrincipal->GetAclLength(dwFlags);
        }
		if(nAclSize > nMaxAclSize)
		{
			//
			//itow converts upto 33 bytes so 34bytes is fine
			//
			WCHAR buffer[34];
			_itow((cPrincipals - i),buffer,10);
			ULONG nMsgId = IDS_ACL_SIZE_ERROR;
			if(!ppSD)
				nMsgId = IDS_ACL_SIZE_ERROR_ADV;

			MsgPopup(hDlg,
                     MAKEINTRESOURCE(nMsgId),
                     MAKEINTRESOURCE(IDS_SECURITY),
                     MB_OK | MB_ICONERROR,
                     ::hModule,
                     buffer);
			SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
			//
			//Do a silent failure since we have already shown the error message
			//
			return S_FALSE;
		}
    }

	if(!ppSD)
		return S_OK;

	*ppSD = NULL;

    //
    // Now that we have the size estimate, allocate the buffer.  Note that
    // we allocate enough memory for a self-relative security descriptor, but
    // don't set the SE_SELF_RELATIVE flag in pSD->Control.  This lets us
    // use pSD->Dacl, etc. as pointers rather than offsets.
    //

    *ppSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH + nAclSize);
    if (*ppSD == NULL)
        TraceLeaveResult(E_OUTOFMEMORY);

    InitializeSecurityDescriptor(*ppSD, SECURITY_DESCRIPTOR_REVISION);

    pSD = (PISECURITY_DESCRIPTOR)*ppSD;

    //
    // Finally, build the security descriptor
    //
    pSD->Control |= SE_DACL_PRESENT | SE_DACL_AUTO_INHERIT_REQ
                    | (m_wSDControl & (SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED));

    if (nAclSize > 0)
    {
        pSD->Dacl = (PACL)(pSD + 1);
        pSD->Dacl->AclRevision = ACL_REVISION;
        pSD->Dacl->AclSize = (WORD)nAclSize;
        pSD->Dacl->AceCount = 0;

        PACE_HEADER pAcePos = (PACE_HEADER)FirstAce(pSD->Dacl);

        DWORD dwExtraFlags = fIncludeInherited ? 0 : ACL_CHECK_CREATOR;

        // Build the DACL in the following order:
        //      Deny
        //      Allow
        //      Inherited Deny
        //      Inherited Allow

        for (j = 0; j < ARRAYSIZE(dwCanonicalFlags); j++)
        {
            for (i = 0; i < cPrincipals; i++)
            {
                lvItem.iItem = i;
                if (ListView_GetItem(hwndList, &lvItem))
                {
                    pPrincipal = (LPPRINCIPAL)lvItem.lParam;
                    pPrincipal->AppendToAcl(pSD->Dacl,
                                            ACL_NONINHERITED | dwCanonicalFlags[j] | dwExtraFlags,
                                            &pAcePos);
                }
            }
        }

        if (fIncludeInherited)
        {
            for (j = 0; j < ARRAYSIZE(dwCanonicalFlags); j++)
            {
                for (i = 0; i < cPrincipals; i++)
                {
                    lvItem.iItem = i;
                    if (ListView_GetItem(hwndList, &lvItem))
                    {
                        pPrincipal = (LPPRINCIPAL)lvItem.lParam;
                        pPrincipal->AppendToAcl(pSD->Dacl,
                                                ACL_INHERITED | dwCanonicalFlags[j] | dwExtraFlags,
                                                &pAcePos);
                    }
                }
            }
        }

        // Set accurate size information for the ACL
        nAclSize = (ULONG)((PBYTE)pAcePos - (PBYTE)pSD->Dacl);
        TraceAssert(nAclSize >= SIZEOF(ACL));
        TraceAssert(pSD->Dacl->AclSize >= nAclSize);

        if (pSD->Dacl->AclSize > nAclSize)
            pSD->Dacl->AclSize = (WORD)nAclSize;

        TraceAssert(m_psi2 || IsDACLCanonical(pSD->Dacl));
    }

    TraceAssert(pSD && IsValidSecurityDescriptor(pSD));

    SetCursor(hcur);

    TraceLeaveResult(S_OK);
}


HRESULT
CPermPage::SetDacl(HWND hDlg,
                   PSECURITY_DESCRIPTOR pSD,
                   BOOL bDirty)
{
    HRESULT hr = S_OK;
    PACL pAcl = NULL;
    PACL paclAllowAll = NULL;
    BOOL bDefaulted;
    BOOL bPresent;
    SECURITY_DESCRIPTOR_CONTROL wSDControl = 0;
    PSECURITY_DESCRIPTOR pSDDefault = NULL;
    DWORD dwRevision;

    TraceEnter(TRACE_PERMPAGE, "CPermPage::SetDacl");
    TraceAssert(hDlg != NULL);

    if (pSD != NULL && !IsValidSecurityDescriptor(pSD))
        TraceLeaveResult(E_INVALIDARG);

    if (pSD != NULL)
        GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision);

    // Save the DACL protection and auto-inherited bits
    m_wSDControl &= ~(SE_DACL_DEFAULTED | SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED);
    m_wSDControl |= (wSDControl & (SE_DACL_DEFAULTED | SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED));

    // Get a pointer to the new DACL
    if (pSD != NULL)
        GetSecurityDescriptorDacl(pSD, &bPresent, &pAcl, &bDefaulted);

    if (!(m_siObjectInfo.dwFlags & SI_READONLY))
    {
        // Check for canonical ordering (Deny, Allow, Inherited Deny, Inherited Allow)
        if ((m_psi2 && !m_psi2->IsDaclCanonical(pAcl))
            || (!m_psi2 && !IsDACLCanonical(pAcl)))
        {
            TraceMsg("DACL not in canonical order!");

            // Ask the user whether to canonicalize the DACL or
            // blow it away completely.
            if (IDCANCEL == MsgPopup(hDlg,
                                     MAKEINTRESOURCE(IDS_PERM_NOT_CANONICAL),
                                     MAKEINTRESOURCE(IDS_SECURITY),
                                     MB_OKCANCEL | MB_ICONWARNING,
                                     ::hModule,
                                     m_siObjectInfo.pszObjectName))
            {
                // Blow it away and start over.
                pAcl = NULL;

                // Does the caller support a default ACL?  If so, get it now.
                if (m_siObjectInfo.dwFlags & SI_RESET)
                {
                    hr = m_psi->GetSecurity(DACL_SECURITY_INFORMATION,
                                            &pSDDefault,
                                            TRUE);

                    if (SUCCEEDED(hr) && pSDDefault != NULL)
                    {
                        // Save the DACL control bits
                        GetSecurityDescriptorControl(pSDDefault, &wSDControl, &dwRevision);
                        m_wSDControl &= ~(SE_DACL_DEFAULTED | SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED);
                        m_wSDControl |= SE_DACL_DEFAULTED | (wSDControl & (SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED));

                        // Get a pointer to the new DACL
                        GetSecurityDescriptorDacl(pSDDefault, &bPresent, &pAcl, &bDefaulted);
                    }
                    // else go with a NULL DACL
                }
            }
            // else simply continuing and re-saving will
            // cause the DACL to get sorted correctly

            // This causes a PropSheet_Changed notification to be sent below
            bDirty = TRUE;
        }
    }

    m_bWasDenyAcl = FALSE;

    // A NULL ACL implies "Everyone Full control", so
    // create such an ACL here
    if (pAcl == NULL)
    {
        PSID psidWorld = QuerySystemSid(UI_SID_World);
        DWORD dwSidLength = GetLengthSid(psidWorld);
        DWORD dwAclLength = SIZEOF(ACL) + SIZEOF(ACCESS_ALLOWED_ACE)
                            - SIZEOF(DWORD) + dwSidLength;

        m_wDaclRevision = ACL_REVISION;

        paclAllowAll = (PACL)LocalAlloc(LPTR, dwAclLength);
        if (paclAllowAll != NULL)
        {
            paclAllowAll->AclRevision = ACL_REVISION;
            paclAllowAll->AclSize = (WORD)dwAclLength;
#if 0 //(_WIN32_WINNT >= 0x0500)
            paclAllowAll->AceCount = 0;

            AddAccessAllowedAceEx(paclAllowAll,
                                  ACL_REVISION,
                                  ACE_INHERIT_ALL,
                                  GENERIC_ALL,
                                  psidWorld);
#else
            paclAllowAll->AceCount = 1;

            PACE_HEADER pAce = (PACE_HEADER)FirstAce(paclAllowAll);
            pAce->AceType = ACCESS_ALLOWED_ACE_TYPE;
            pAce->AceFlags = ACE_INHERIT_ALL;
            pAce->AceSize = (WORD)dwAclLength - SIZEOF(ACL);
            ((PACCESS_ALLOWED_ACE)pAce)->Mask = GENERIC_ALL;
            CopyMemory(&((PACCESS_ALLOWED_ACE)pAce)->SidStart, psidWorld, dwSidLength);
#endif
            pAcl = paclAllowAll;
        }
    }
    else
    {
        DWORD dwFullControl = GENERIC_ALL;
        UCHAR aceFlags = 0;

        m_psi->MapGeneric(NULL, &aceFlags, &dwFullControl);
        if (IsDenyACL(pAcl,
                      (m_wSDControl & SE_DACL_PROTECTED),
                      dwFullControl,
                      NULL))
        {
            // Already have Deny ACEs, don't bother warning again later.
            m_bWasDenyAcl = TRUE;
        }
    }

    // Reset the list of principals
    InitPrincipalList(hDlg, pAcl);

	//Get the count of inheritable aces
	m_cInheritableAces = GetCountOfInheritableAces(pAcl);


    // If there aren't any entries, fake a sel change to update
    // (i.e. disable) the other controls.
    if (pAcl == NULL || pAcl->AceCount == 0)
        OnSelChange(hDlg);

    if (bDirty)
        SetDirty(hDlg, TRUE);

    if (paclAllowAll != NULL)
        LocalFree(paclAllowAll);

    if (pSDDefault != NULL)
        LocalFree(pSDDefault);

    TraceLeaveResult(hr);
}


void
CPermPage::OnAddPrincipal(HWND hDlg)
{
    PUSER_LIST pUserList = NULL;

    TraceEnter(TRACE_PERMPAGE, "CPermPage::OnAddPrincipal");
    TraceAssert(hDlg != NULL);
    
    if (S_OK == GetUserGroup(hDlg, TRUE, &pUserList))
    {
        PUSER_INFO pUserInfo;
        DWORD i;
        BOOL fPageModified = FALSE;
        int iItem = -1;

        TraceAssert(NULL != pUserList);

        HWND hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
        TraceAssert(hwndList != NULL);

        for (i = 0; i < pUserList->cUsers; i++)
        {
            int cItems;
            LV_ITEM lvItem;
            LPPRINCIPAL pPrincipal;
            BYTE buffer[SIZEOF(KNOWN_OBJECT_ACE) + SIZEOF(GUID)];
            PACE_HEADER pAce = (PACE_HEADER)buffer;

            pUserInfo = &pUserList->rgUsers[i];
            iItem = -1;

            // Check whether the new principal is already in our list.
            // If so, don't add it again.
            cItems = ListView_GetItemCount(hwndList);
            lvItem.iSubItem = 0;
            lvItem.mask = LVIF_PARAM;
            while (cItems > 0)
            {
                LPPRINCIPAL pPrincipal2 = NULL;

                --cItems;
                lvItem.iItem = cItems;

                ListView_GetItem(hwndList, &lvItem);
                pPrincipal2 = (LPPRINCIPAL)lvItem.lParam;

                if (EqualSid(pPrincipal2->GetSID(), pUserInfo->pSid))
                {
                    iItem = lvItem.iItem;
                    break;
                }
            }

            // Did we find it?
            if (iItem != -1)
                continue;

            // ListView_FindItem failed to find a match.  Add a
            // new principal.

            pPrincipal = new CPrincipal(this);
            if (!pPrincipal)
                continue;

            // Initialize principal
            if (!pPrincipal->SetPrincipal(pUserInfo->pSid,
                                          pUserInfo->SidType,
                                          pUserInfo->pszName,
                                          pUserInfo->pszLogonName))
            {
                delete pPrincipal;
                continue;
            }

            lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
            lvItem.iItem = 0;
            lvItem.iSubItem = 0;
            lvItem.pszText = (LPTSTR)pPrincipal->GetName();
            lvItem.iImage = pPrincipal->GetImageIndex();
            lvItem.lParam = (LPARAM)pPrincipal;

            // Insert principal into list
            iItem = ListView_InsertItem(hwndList, &lvItem);
            if (-1 == iItem)
            {
                delete pPrincipal;
                continue;
            }

            // Add ace with default access
            pAce->AceType = ACCESS_ALLOWED_ACE_TYPE;
            pAce->AceFlags = 0;
            pAce->AceSize = SIZEOF(ACCESS_ALLOWED_ACE);
            ((PACCESS_ALLOWED_ACE)pAce)->Mask = m_pDefaultAccess->mask;

            if (m_siObjectInfo.dwFlags & SI_CONTAINER)
            {
                // Pick up inherit bits from the default access
                pAce->AceFlags = (UCHAR)(m_pDefaultAccess->dwFlags & (VALID_INHERIT_FLAGS & ~INHERITED_ACE));

                //
                // Special case for CreatorOwner/CreatorGroup,
                // which are only useful if inherit bits are set.
                //
                if (IsCreatorSid(pUserInfo->pSid))
                {
                    // Make sure it inherits onto something
                    if (!(pAce->AceFlags & ACE_INHERIT_ALL))
                        pAce->AceFlags = ACE_INHERIT_ALL;

                    // It never applies to the current object
                    pAce->AceFlags |= INHERIT_ONLY_ACE;

                    // Set it up so whoever creates an object
                    // gets full control by default
                    ((PACCESS_ALLOWED_ACE)pAce)->Mask = GENERIC_ALL;
                }
            }

            if (!IsNullGUID(m_pDefaultAccess->pguid))
            {
                pAce->AceType = ACCESS_ALLOWED_OBJECT_ACE_TYPE;
                pAce->AceSize = SIZEOF(KNOWN_OBJECT_ACE) + SIZEOF(GUID);
                ((PKNOWN_OBJECT_ACE)pAce)->Flags = ACE_OBJECT_TYPE_PRESENT;
                *RtlObjectAceObjectType(pAce) = *m_pDefaultAccess->pguid;
            }

            pPrincipal->AddAce(pAce);
            fPageModified = TRUE;
        }

        // Done with this now
        LocalFree(pUserList);

        if (fPageModified)
        {
            // If we've added items, resize the Name column
            //ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE);

            SetDirty(hDlg);
        }

        if (iItem != -1)
        {
            // Select the last one inserted.
            SelectListViewItem(hwndList, iItem);
        }
    }

    TraceLeaveVoid();
}


void
CPermPage::OnRemovePrincipal(HWND hDlg)
{
    HWND hwndList;
    int iIndex;
    LPPRINCIPAL pPrincipal;

    TraceEnter(TRACE_PERMPAGE, "CPermPage::OnRemovePrincipal");

    hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
    pPrincipal = (LPPRINCIPAL)GetSelectedItemData(hwndList, &iIndex);

    if (pPrincipal)
    {
        BOOL bDirty = FALSE;

        if (pPrincipal->GetAclLength(ACL_INHERITED) > 0)
        {
            // This principal has inherited ACEs so we can't remove the principal
            // from the list. Instead, simply remove the non-inherited ACEs from
            // the principal.
            if (pPrincipal->GetAclLength(ACL_NONINHERITED) > 0)
            {
                pPrincipal->m_permDeny.Reset();
                pPrincipal->m_permAllow.Reset();
                DSA_DeleteAllItems(pPrincipal->m_hAdditionalAllow);
                DSA_DeleteAllItems(pPrincipal->m_hAdditionalDeny);


                bDirty = TRUE;

                // Update the other controls (this happens automatically in the
                // ListView_DeleteItem case below).
                OnSelChange(hDlg);
            }
            else
            {
                // Notify the user that we can't remove inherited ACEs.
                MsgPopup(hDlg,
                         MAKEINTRESOURCE(IDS_PERM_CANT_REMOVE),
                         MAKEINTRESOURCE(IDS_SECURITY),
                         MB_OK | MB_ICONWARNING,
                         ::hModule,
                         pPrincipal->GetName());
            }
        }
        else
        {
             ListView_DeleteItem(hwndList, iIndex);
            //
            // If we just removed the only item, move the focus to the Add button
            // (the Remove button will be disabled in OnSelChange).
            //
            int cItems = ListView_GetItemCount(hwndList);
            if (cItems == 0)
                SetFocus(GetDlgItem(hDlg, IDC_SPP_ADD));
            else
            {
                // If we deleted the last one, select the previous one
                if (cItems <= iIndex)
                    --iIndex;

                SelectListViewItem(hwndList, iIndex);
				//
				//Key board focus is getting lost at this point
				//set it to REMOVE button.
				//
				SetFocus(GetDlgItem(hDlg, IDC_SPP_REMOVE));
            }
            bDirty = TRUE;
        }

        // Notify the property sheet that we've changed
        if (bDirty)
            SetDirty(hDlg);
    }

    TraceLeaveVoid();
}


void
CPermPage::OnAdvanced(HWND hDlg)
{
    LPSECURITYINFO psi;

    TraceEnter(TRACE_PERMPAGE, "CPermPage::OnAdvanced");

	//
	//Don't go to Advanced page, if DACL size is more than
	//maximum allowed. 
	//
    if (m_fPageDirty && (S_FALSE == BuildDacl(hDlg, NULL, FALSE)))
		TraceLeaveVoid();

    //
    // Create an ISecurityInformation wrapper to give to the advanced
    // dialog.  The wrapper intercepts GetSecurity & SetSecurity.
    //
    psi = new CSecurityInfo(this, hDlg);

    if (psi != NULL)
    {
        // Invoke the advanced ACL editor
        EditSecurityEx(hDlg, psi,this, 0);
        psi->Release();   // release initial reference
    }
    else
    {
        MsgPopup(hDlg,
                 MAKEINTRESOURCE(IDS_OUT_OF_MEMORY),
                 MAKEINTRESOURCE(IDS_SECURITY),
                 MB_OK | MB_ICONERROR,
                 ::hModule);
    }

    TraceLeaveVoid();
}

void
CPermPage::EnablePrincipalControls(HWND hDlg, BOOL fEnable)
{
    TraceEnter(TRACE_PERMPAGE, "CPermPage::EnablePrincipalControls");

    EnableWindow(GetDlgItem(hDlg, IDC_SPP_PERMS), fEnable);

    if (!fEnable)
    {
        ShowWindow(GetDlgItem(hDlg, IDC_SPP_MORE_MSG), SW_HIDE);
    }
    else
    {
#if 0
        LPPRINCIPAL pPrincipal
            = (LPPRINCIPAL)GetSelectedItemData(GetDlgItem(hDlg, IDC_SPP_PRINCIPALS),
                                               NULL);

        // If the selected principal has only inherited ACEs, then disable
        // the Remove button.
        if (pPrincipal &&
            pPrincipal->GetAclLength(ACL_INHERITED) > 0 &&
            pPrincipal->GetAclLength(ACL_NONINHERITED) == 0)
        {
            fEnable = FALSE;
        }
#endif
    }
    EnableWindow(GetDlgItem(hDlg, IDC_SPP_REMOVE), fEnable);

    TraceLeaveVoid();
}

void
CPermPage::CommitCurrent(HWND hDlg, int iPrincipal)
{
    // Commit any outstanding bit changes

    HWND hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);

    TraceEnter(TRACE_PERMPAGE, "CPermPage::CommitCurrent");

    // If an index isn't provided, get the index of the currently
    // selected principal.
    if (iPrincipal == -1)
        iPrincipal = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);

    if (iPrincipal != -1)
    {
        // Get the Principal from the selection.
        LV_ITEM lvItem;
        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = iPrincipal;
        lvItem.iSubItem = 0;
        lvItem.lParam = 0;

        ListView_GetItem(hwndList, &lvItem);
        LPPRINCIPAL pPrincipal = (LPPRINCIPAL)lvItem.lParam;

        if (pPrincipal != NULL)
        {
            // Get new ACEs from the checklist window

            HDPA hAceEntries = DPA_Create(4);

            if (hAceEntries != NULL)
            {
                hwndList = GetDlgItem(hDlg, IDC_SPP_PERMS);
                UINT iCount = GetAcesFromCheckList(hwndList,
                                                   pPrincipal->GetSID(),
                                                   TRUE,
                                                   FALSE,
                                                   0,
                                                   &GUID_NULL,
                                                   hAceEntries);

                // Merge new ACEs into the principal
                while (iCount != 0)
                {
                    --iCount;
                    PACE_HEADER pAce = (PACE_HEADER)DPA_FastGetPtr(hAceEntries, iCount);
                    // Shouldn't get any inherited ACEs here
                    TraceAssert(!(pAce->AceFlags & INHERITED_ACE));
                    pPrincipal->AddAce(pAce);
                    LocalFree(pAce);
                    DPA_DeletePtr(hAceEntries, iCount);
                }

                TraceAssert(DPA_GetPtrCount(hAceEntries) == 0);
                DPA_Destroy(hAceEntries);
            }
        }
    }

    TraceLeaveVoid();
}


void
CPermPage::OnSize(HWND hDlg, DWORD dwSizeType, ULONG /*nWidth*/, ULONG /*nHeight*/)
{
    RECT rc;
    RECT rcDlg;
    LONG dx;
    LONG dy;
    HWND hwndAdvButton;
    HWND hwndPermList;
    HWND hwndPrincipalList;
    HWND hwndBottom;
    HWND hwnd;
    LONG i;

    TraceEnter(TRACE_PERMPAGE, "CPermPage::OnSize");

    if (dwSizeType != SIZE_RESTORED)
        TraceLeaveVoid();

    hwndPrincipalList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
    hwndPermList = GetDlgItem(hDlg, IDC_SPP_PERMS);
    hwndAdvButton = GetDlgItem(hDlg, IDC_SPP_ADVANCED);
    GetClientRect(hDlg, &rcDlg);

    GetWindowRect(hwndPrincipalList, &rc);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);   // map from screen to dlg

    InflateRect(&rcDlg, -rc.left, -rc.top);         // account for margins

    if (GetWindowLong(hwndAdvButton, GWL_STYLE) & WS_VISIBLE)
    {
        hwndBottom = hwndAdvButton;
    }
    else
    {
        hwndBottom = hwndPermList;
    }

    GetWindowRect(hwndBottom, &rc);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);

    dy = rcDlg.bottom - rc.bottom;

    GetWindowRect(hwndPermList, &rc);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);

    dx = rcDlg.right - rc.right;

    //
    // Never make things smaller, and only make things
    // bigger if the change is worthwhile.
    //
    dx = max(dx, 0);
    if (dx < 5)
        dx = 0;
    dy = max(dy, 0);
    if (dy < 5)
        dy = 0;

    //
    // Reposition and/or resize all controls
    //
    if (dx > 0 || dy > 0)
    {
        // Add, Remove, Reset buttons
        for (i = IDC_SPP_ADD; i <= IDC_SPP_REMOVE; i++)
        {
            hwnd = GetDlgItem(hDlg, i);
            GetWindowRect(hwnd, &rc);
            MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);
            SetWindowPos(hwnd,
                         NULL,
                         rc.left + dx,
                         rc.top + dy/2,
                         0,
                         0,
                         SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
        }
    }

    if (dx > 0 || dy > 0)
    {
        // Listview containing User/Group names
        GetWindowRect(hwndPrincipalList, &rc);
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);
        SetWindowPos(hwndPrincipalList,
                     NULL,
                     0,
                     0,
                     rc.right - rc.left + dx,
                     rc.bottom - rc.top + dy/2,
                     SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);

        // Widen the name column if necessary
        GetClientRect(hwndPrincipalList, &rc);
        if (ListView_GetColumnWidth(hwndPrincipalList, 0) < rc.right)
            ListView_SetColumnWidth(hwndPrincipalList, 0, rc.right);
    }

    if (dy > 0 || dx > 0)
    {
        // Static control "Access"
        hwnd = GetDlgItem(hDlg, IDC_SPP_ACCESS);
        GetWindowRect(hwnd, &rc);
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);
        SetWindowPos(hwnd,
                     NULL,
                     rc.left,
                     rc.top + dy/2,
                     rc.right - rc.left + dx,
                     rc.bottom - rc.top,
                     SWP_NOACTIVATE |  SWP_NOZORDER);
        //Static control Big Permission Label
        hwnd = GetDlgItem(hDlg, IDC_SPP_ACCESS_BIG);
        GetWindowRect(hwnd, &rc);
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);
        SetWindowPos(hwnd,
                     NULL,
                     rc.left,
                     rc.top + dy/2,
                     rc.right - rc.left + dx,
                     rc.bottom - rc.top,
                     SWP_NOACTIVATE |  SWP_NOZORDER);

    }

    if (dx > 0 || dy > 0)
    {
        // Static controls "Allow" and "Deny"
        for (i = IDC_SPP_ALLOW; i <= IDC_SPP_DENY; i++)
        {
            hwnd = GetDlgItem(hDlg, i);
            GetWindowRect(hwnd, &rc);
            MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);
            SetWindowPos(hwnd,
                         NULL,
                         rc.left + dx,
                         rc.top + dy/2,
                         0,
                         0,
                         SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
        }

        // List of permission checkboxes
        GetWindowRect(hwndPermList, &rc);
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);
        SetWindowPos(hwndPermList,
                     NULL,
                     rc.left,
                     rc.top + dy/2,
                     rc.right - rc.left + dx,
                     rc.bottom - rc.top + dy/2,
                     SWP_NOACTIVATE | SWP_NOZORDER);
    }

    if (dy > 0 || dx > 0)
    {
        // Advanced button
        GetWindowRect(hwndAdvButton, &rc);
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);
        SetWindowPos(hwndAdvButton,
                     NULL,
                     rc.left + dx,
                     rc.top + dy,
                     0,
                     0,
                     SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);

        // "More stuff is present but not viewable" message
        hwnd = GetDlgItem(hDlg, IDC_SPP_STATIC_ADV);
        GetWindowRect(hwnd, &rc);
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);
        SetWindowPos(hwnd,
                     NULL,
                     rc.left,
                     rc.top + dy,
                     0,
                     0,
                     SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);

    }

    TraceLeaveVoid();
}


void
CPermPage::ClearPermissions(HWND hwndList, BOOL bDisabled)
{
    // Uncheck everything
    UINT cRights = 0;
    DWORD dwState = CLST_UNCHECKED;

    if (bDisabled)
        dwState |= CLST_DISABLED;

    if (hwndList)
        cRights = (UINT)SendMessage(hwndList, CLM_GETITEMCOUNT, 0, 0);

    while (cRights > 0)
    {
        cRights--;
        SendMessage(hwndList, CLM_SETSTATE, MAKELONG((WORD)cRights, 1), dwState);
        SendMessage(hwndList, CLM_SETSTATE, MAKELONG((WORD)cRights, 2), dwState);
    }

    if(m_bCustomPermission)
    {
        ClearCustom(hwndList,1);
        ClearCustom(hwndList,2);
    }
}


void
CPermPage::SetDirty(HWND hDlg, BOOL bDefault)
{
    if (!bDefault)
        m_wSDControl &= ~SE_DACL_DEFAULTED;
    m_fPageDirty = TRUE;
    PropSheet_Changed(GetParent(hDlg), hDlg);
}


BOOL
CPermPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // First check to see if its time to update listview names
    if (uMsg == UM_SIDLOOKUPCOMPLETE)
    {
        HWND hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
        SetPrincipalNamesInList(hwndList, (PSID)lParam);
        SetPermLabelText(hDlg);

        // lParam is zero when all remaining names are looked up
        if (0 == lParam)
        {
            // Sort using the real names
            ListView_SortItems(hwndList, NULL, 0);

            // Make sure the selected item is visible
            int iSelItem;
            if (NULL == GetSelectedItemData(hwndList, &iSelItem))
            {
                // No selection, select the first item
                SelectListViewItem(hwndList, 0);
            }
            else
            {
                ListView_EnsureVisible(hwndList, iSelItem, FALSE);
            }

            // Show normal cursor now
            m_fBusy = FALSE;
            SetCursor(LoadCursor(NULL, IDC_ARROW));

            // Enable the Advanced button if appropriate
            EnableWindow(GetDlgItem(hDlg, IDC_SPP_ADVANCED),
                (m_siObjectInfo.dwFlags & SI_ADVANCED));
        }
        return TRUE;
    }

    switch(uMsg)
    {
    case WM_SETCURSOR:
        if (m_fBusy)
        {
            SetCursor(m_hcurBusy);
            SetWindowLong(hDlg, DWLP_MSGRESULT, TRUE);
            return TRUE;
        }
        else
            return FALSE;
        break;

    case WM_INITDIALOG:
        return InitDlg(hDlg);

    case WM_NOTIFY:
        return OnNotify(hDlg, (int)wParam, (LPNMHDR)lParam);

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_SPP_ADD:
            OnAddPrincipal(hDlg);
            break;

        case IDC_SPP_REMOVE:
            OnRemovePrincipal(hDlg);
            break;

        case IDC_SPP_ADVANCED:
            OnAdvanced(hDlg);
            break;

        case IDC_SPP_PRINCIPALS:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == IDN_CHECKSELECTION)
            {
                // See if we have gotten a new selection.  If not, then the
                // user must have clicked inside the listview but not on an item,
                // thus causing the listview to remove the selection.  In that
                // case, disable the other controls

                if (ListView_GetSelectedCount(GET_WM_COMMAND_HWND(wParam, lParam)) == 0)
                {
                    // Uncheck everything first
                    ClearPermissions(GetDlgItem(hDlg, IDC_SPP_PERMS));
                    EnablePrincipalControls(hDlg, FALSE);
                }
            }
            break;

        default:
            // Command not handled
            return FALSE;
        }
        break;

    case WM_SIZE:
        OnSize(hDlg, (LONG)wParam, (ULONG)LOWORD(lParam), (ULONG)HIWORD(lParam));
        break;

    case WM_HELP:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_szAcluiHelpFile,
                    HELP_WM_HELP,
                    (DWORD_PTR)aPermPageHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hDlg))
        {
            HWND hwnd = (HWND)wParam;

            //
            // Some of the checkboxes may be scrolled out of view, but
            // they are still detected by WinHelp, so we jump through
            // a few extra hoops here.
            //
            if (hwnd == hDlg)
            {
                POINT pt;
                pt.x = GET_X_LPARAM(lParam);
                pt.y = GET_Y_LPARAM(lParam);

                ScreenToClient(hDlg, &pt);
                hwnd = ChildWindowFromPoint(hDlg, pt);
                if (hDlg == hwnd)
                    break;
            }

            //
            // WinHelp looks for child windows, but we don't have help id's
            // for the permission checkboxes.  If the request is for the
            // checklist window, fake out WinHelp by referring to one of
            // the static labels just above the list.
            //
            if (GetDlgCtrlID(hwnd) == IDC_SPP_PERMS)
                hwnd = GetDlgItem(hDlg, IDC_SPP_ACCESS);

            WinHelp(hwnd,
                    c_szAcluiHelpFile,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)aPermPageHelpIDs);
        }
        break;

    default:
        // Message not handled
        return FALSE;
    }

    return TRUE;
}


//
// CSecurityInfo implementation
//
STDMETHODIMP_(ULONG)
CSecurityInfo::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CSecurityInfo::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CSecurityInfo::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
        *ppv = static_cast<LPSECURITYINFO>(this);
    else if (IsEqualIID(riid, IID_ISecurityInformation2))
    {
        if (m_pPage->m_psi2)
            *ppv = static_cast<LPSECURITYINFO2>(this);
    }
    else if (IsEqualIID(riid, IID_IEffectivePermission))
    {
        if(m_pPage->m_pei)
           *ppv = static_cast<LPEFFECTIVEPERMISSION>(this);
    }
    else if (IsEqualIID(riid, IID_ISecurityObjectTypeInfo))
    {
        if(m_pPage->m_psoti)
            *ppv = static_cast<LPSecurityObjectTypeInfo>(this);

    }

#if(_WIN32_WINNT >= 0x0500)
    else if (IsEqualIID(riid, IID_IDsObjectPicker))
        *ppv = static_cast<IDsObjectPicker*>(this);
#endif

    if (*ppv)
    {
        m_cRef++;
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP
CSecurityInfo::GetObjectInformation(PSI_OBJECT_INFO pObjectInfo)
{
    TraceEnter(TRACE_SI, "CSecurityInfo::GetObjectInformation");
    TraceAssert(m_pPage != NULL);

    *pObjectInfo = m_pPage->m_siObjectInfo;

    TraceLeaveResult(S_OK);
}

STDMETHODIMP
CSecurityInfo::GetSecurity(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault)
{
    HRESULT hr;

    TraceEnter(TRACE_SI, "CSecurityInfo::GetSecurity");
    TraceAssert(si != 0);
    TraceAssert(ppSD != NULL);
    TraceAssert(m_pPage != NULL);
    TraceAssert(m_hDlg != NULL);

    *ppSD = NULL;


//Effective permission page calls with si = DACL + OWNER + GROUP and it should
//return Actual Security Descriptor. Other pages calls with only one thing at a time
//and we build dacl and return it if its dirty.
    if (!fDefault && (si == DACL_SECURITY_INFORMATION) && m_pPage->m_fPageDirty)
    {
        // We only get asked for one thing at a time
        TraceAssert(si == DACL_SECURITY_INFORMATION);

        // Return current DACL, including inherited ACEs
        hr = m_pPage->BuildDacl(m_hDlg, ppSD, TRUE);
    }
    else
    {
        TraceAssert(m_pPage->m_psi != NULL);

        // Get it from the object
        hr = m_pPage->m_psi->GetSecurity(si, ppSD, fDefault);
    }

    TraceLeaveResult(hr);
}

STDMETHODIMP
CSecurityInfo::SetSecurity(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = E_FAIL;

    TraceEnter(TRACE_SI, "CSecurityInfo::SetSecurity");
    TraceAssert(si != 0);
    TraceAssert(pSD != NULL);
    TraceAssert(m_pPage != NULL);
    TraceAssert(m_hDlg != NULL);

    // Write out the new security descriptor
    if (m_pPage->m_psi != NULL)
        hr = m_pPage->m_psi->SetSecurity(si, pSD);

    if (S_OK == hr && (si & DACL_SECURITY_INFORMATION))
    {
        PSECURITY_DESCRIPTOR psd = NULL;

        m_pPage->m_fPageDirty = FALSE;

        // Read the new DACL back from the object, that is, don't use the one
        // from the passed-in security descriptor.  This ensures that we have
        // the "real" current DACL in case it was modified somewhere en route.
        if (SUCCEEDED(m_pPage->m_psi->GetSecurity(DACL_SECURITY_INFORMATION, &psd, FALSE)))
            pSD = psd;

        // Reinitialize the dialog using the new DACL
        m_pPage->SetDacl(m_hDlg, pSD);

        if (psd != NULL)
            LocalFree(psd);
    }

    TraceLeaveResult(hr);
}

STDMETHODIMP
CSecurityInfo::GetAccessRights(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess)
{
    HRESULT hr = E_FAIL;

    TraceEnter(TRACE_SI, "CSecurityInfo::GetAccessRights");
    TraceAssert(m_pPage != NULL);

    if (m_pPage->m_psi != NULL)
        hr = m_pPage->m_psi->GetAccessRights(pguidObjectType,
                                             dwFlags,
                                             ppAccess,
                                             pcAccesses,
                                             piDefaultAccess);
    TraceLeaveResult(hr);
}

STDMETHODIMP
CSecurityInfo::MapGeneric(const GUID* pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask)
{
    HRESULT hr = E_FAIL;

    TraceEnter(TRACE_SI, "CSecurityInfo::MapGeneric");
    TraceAssert(m_pPage != NULL);

    if (m_pPage->m_psi != NULL)
        hr = m_pPage->m_psi->MapGeneric(pguidObjectType, pAceFlags, pmask);

    TraceLeaveResult(hr);
}

STDMETHODIMP
CSecurityInfo::GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes)
{
    HRESULT hr = E_FAIL;

    TraceEnter(TRACE_SI, "CSecurityInfo::GetInheritTypes");
    TraceAssert(m_pPage != NULL);
    TraceAssert(ppInheritTypes != NULL);
    TraceAssert(pcInheritTypes != NULL);

    *ppInheritTypes = NULL;
    *pcInheritTypes = 0;

    if (m_pPage->m_psi != NULL)
        hr = m_pPage->m_psi->GetInheritTypes(ppInheritTypes,
                                             pcInheritTypes);
    TraceLeaveResult(hr);
}

STDMETHODIMP
CSecurityInfo::PropertySheetPageCallback(HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage)
{
    HRESULT hr = S_OK;

    TraceEnter(TRACE_SI, "CSecurityInfo::PropertySheetPageCallback");
    TraceAssert(m_pPage != NULL);

    //
    // Pass the call on to the client
    //
    if (m_pPage->m_psi != NULL)
        hr = m_pPage->m_psi->PropertySheetPageCallback(hwnd, uMsg, uPage);

    //
    // If the simple perm page is disabled, make sure the advanced perm
    // page is as well.
    //
    if (SUCCEEDED(hr) && uPage == SI_PAGE_ADVPERM && m_pPage->m_bAbortPage)
        hr = E_FAIL;

    TraceLeaveResult(hr);
}


//
// ISecurityInformation2 methods
//
STDMETHODIMP_(BOOL)
CSecurityInfo::IsDaclCanonical(PACL pDacl)
{
    BOOL bResult = TRUE;

    TraceEnter(TRACE_SI, "CSecurityInfo::IsDaclCanonical");
    TraceAssert(m_pPage != NULL);

    if (m_pPage->m_psi2 != NULL)
        bResult = m_pPage->m_psi2->IsDaclCanonical(pDacl);

    TraceLeaveValue(bResult);
}

STDMETHODIMP
CSecurityInfo::LookupSids(ULONG cSids, PSID *rgpSids, LPDATAOBJECT *ppdo)
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter(TRACE_SI, "CSecurityInfo::LookupSids");
    TraceAssert(m_pPage != NULL);

    if (m_pPage->m_psi2 != NULL)
        hr = m_pPage->m_psi2->LookupSids(cSids, rgpSids, ppdo);

    TraceLeaveResult(hr);
}


//
// IDsObjectPicker methods
//
#if(_WIN32_WINNT >= 0x0500)
STDMETHODIMP CSecurityInfo::Initialize(PDSOP_INIT_INFO pInitInfo)
{
    HRESULT hr;
    IDsObjectPicker *pObjectPicker = NULL;

    hr = m_pPage->GetObjectPicker(&pObjectPicker);

    if (SUCCEEDED(hr))
    {
        if (m_pPage->m_flLastOPOptions != pInitInfo->flOptions)
        {
            m_pPage->m_flLastOPOptions = (DWORD)-1;

            hr = pObjectPicker->Initialize(pInitInfo);

            if (SUCCEEDED(hr))
            {
                m_pPage->m_flLastOPOptions = pInitInfo->flOptions;
            }
        }
        pObjectPicker->Release();
    }

    return hr;
}

STDMETHODIMP CSecurityInfo::InvokeDialog(HWND hwndParent,
                                         IDataObject **ppdoSelection)
{
    HRESULT hr;
    IDsObjectPicker *pObjectPicker = NULL;

    hr = m_pPage->GetObjectPicker(&pObjectPicker);

    if (SUCCEEDED(hr))
    {
        hr = pObjectPicker->InvokeDialog(hwndParent, ppdoSelection);
        pObjectPicker->Release();
    }

    return hr;
}
#endif  // _WIN32_WINNT >= 0x0500

STDMETHODIMP CSecurityInfo::GetInheritSource(SECURITY_INFORMATION si,
                                              PACL pACL, 
                                              PINHERITED_FROM *ppInheritArray)
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter(TRACE_SI, "CSecurityInfo::GetInheritSource");
    TraceAssert(m_pPage != NULL);

    if (m_pPage->m_psoti)
        hr = m_pPage->m_psoti->GetInheritSource(si, pACL, ppInheritArray);

    TraceLeaveResult(hr);
}

STDMETHODIMP CSecurityInfo::GetEffectivePermission( THIS_ const GUID* pguidObjectType,
                                                    PSID pUserSid,
                                                    LPCWSTR pszServerName,
                                                    PSECURITY_DESCRIPTOR pSD,
                                                    POBJECT_TYPE_LIST *ppObjectTypeList,
                                                    ULONG *pcObjectTypeListLength,
                                                    PACCESS_MASK *ppGrantedAccessList,
                                                    ULONG *pcGrantedAccessListLength)
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter(TRACE_SI, "CSecurityInfo::GetEffectivePermission");
    TraceAssert(m_pPage != NULL);

    if (m_pPage->m_pei)
        hr = m_pPage->m_pei->GetEffectivePermission(pguidObjectType,
                                                    pUserSid,
                                                    pszServerName,
                                                    pSD,
                                                    ppObjectTypeList,
                                                    pcObjectTypeListLength,
                                                    ppGrantedAccessList,
                                                    pcGrantedAccessListLength);

    TraceLeaveResult(hr);
}




//
// Expose an api to get at the simple permission editor
//

HPROPSHEETPAGE
ACLUIAPI
CreateSecurityPage(LPSECURITYINFO psi)
{
    HPROPSHEETPAGE hPage = NULL;
    PPERMPAGE pPage;
    PSIDCACHE pSidCache;

    TraceEnter(TRACE_PERMPAGE, "CreateSecurityPage");

    // Create the global SID Cache
    pSidCache = GetSidCache();

    if (NULL == psi)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        TraceLeaveValue(NULL);
    }

    pPage = new CPermPage(psi);

    if (pPage)
    {
        SI_OBJECT_INFO siObjectInfo = {0};
        LPCTSTR pszTitle = NULL;

        if (SUCCEEDED(psi->GetObjectInformation(&siObjectInfo)) &&
            (siObjectInfo.dwFlags & SI_PAGE_TITLE))
        {
            pszTitle = siObjectInfo.pszPageTitle;
        }

        hPage = pPage->CreatePropSheetPage(MAKEINTRESOURCE(IDD_SIMPLE_PERM_PAGE), pszTitle);

        if (!hPage)
            delete pPage;
    }

    if (pSidCache)
        pSidCache->Release();

    TraceLeaveValue(hPage);
}

BOOL
ACLUIAPI
EditSecurity( HWND hwndOwner, LPSECURITYINFO psi )
{
    HPROPSHEETPAGE hPage[1];
    UINT cPages = 0;
    BOOL bResult = FALSE;
    SI_OBJECT_INFO siObjectInfo = {0};
    HRESULT hr;

    TraceEnter(TRACE_PERMPAGE, "EditSecurity");

    // Get object name for dialog title
    hr = psi->GetObjectInformation(&siObjectInfo);

    if (FAILED(hr))
    {
        if (!GetLastError())
            SetLastError(hr);

        TraceLeaveValue(FALSE);
    }

    hPage[cPages] = CreateSecurityPage( psi );
    if (hPage[cPages])
        cPages++;

    if (cPages)
    {
        // Build dialog title string
        LPTSTR pszCaption = NULL;

        PROPSHEETHEADER psh;
        psh.dwSize = SIZEOF(psh);
        psh.dwFlags = PSH_DEFAULT;
        psh.hwndParent = hwndOwner;
        psh.hInstance = ::hModule;
        psh.nPages = cPages;
        psh.nStartPage = 0;
        psh.phpage = &hPage[0];

// There has been a request for customization of this dialog title,
// but this probably isn't the best way to do it, since the dlg title
// and page title will be the same.
#if 0
        if ((siObjectInfo.dwFlags & SI_PAGE_TITLE)
            && siObjectInfo.pszPageTitle
            && siObjectInfo.pszPageTitle[0])
        {
            psh.pszCaption = siObjectInfo.pszPageTitle;
        }
        else
#endif
        {
            FormatStringID(&pszCaption, ::hModule, IDS_SPP_TITLE, siObjectInfo.pszObjectName);
            psh.pszCaption = pszCaption;
        }

        bResult = (BOOL)(PropertySheet(&psh) + 1);

        LocalFreeString(&pszCaption);
    }

    TraceLeaveValue(bResult);
}
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\sidcache.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       sidcache.h
//
//  This file contains definitions and prototypes for SID/Name cache.
//
//--------------------------------------------------------------------------

#ifndef _SIDCACHE_H_
#define _SIDCACHE_H_

#include <comctrlp.h>   // DPA

DWORD WaitOnThread(HANDLE *phThread);

#define BUCKET_COUNT    31

typedef struct _sid_cache_entry
{
    DWORD   dwLastAccessTime;
    SID_NAME_USE SidType;
    PSID    pSid;
    LPCTSTR pszName;
    LPCTSTR pszLogonName;
} SID_CACHE_ENTRY, *PSID_CACHE_ENTRY;


class CSidCache
{
private:
    HDPA m_dpaSidHashTable[BUCKET_COUNT];
    CRITICAL_SECTION m_csHashTableLock;
    CRITICAL_SECTION m_csDomainNameLock;
    CRITICAL_SECTION m_csDcNameLock;
    LPTSTR m_pszCachedServer;
    LPTSTR m_pszCachedDomain;
    HANDLE m_hInitThread;
    LPTSTR m_pszLastDc;
    LPTSTR m_pszLastDomain;
    LONG   m_cRef;

public:
    CSidCache();
    ~CSidCache();

    // used to control lifetime of the object
    ULONG AddRef();
    ULONG Release();

    BOOL LookupSids(HDPA hSids, LPCTSTR pszServer, LPSECURITYINFO2 psi2, PUSER_LIST *ppUserList);
    BOOL LookupSidsAsync(HDPA hSids, LPCTSTR pszServer, LPSECURITYINFO2 psi2, HWND hWndNotify, UINT uMsgNotify);
#if(_WIN32_WINNT >= 0x0500)
    BOOL LookupNames(PDS_SELECTION_LIST pDsSelList, LPCTSTR pszServer, PUSER_LIST *ppUserList, BOOL bStandalone);
#endif
    void GetDomainName(LPCTSTR pszServer, LPTSTR pszDomain, ULONG cchDomain);
    void GetDcName(LPCTSTR pszDomain, LPTSTR pszDC, ULONG cchDC);

    PSID_CACHE_ENTRY FindSid(PSID pSid);
    PSID_CACHE_ENTRY MakeEntry(PSID pSid,
                               SID_NAME_USE SidType,
                               LPCTSTR pszName,
                               LPCTSTR pszLogonName = NULL);
    BOOL AddEntry(PSID_CACHE_ENTRY pEntry);

    BOOL BuildUserList(HDPA hEntryList,
                       LPCTSTR pszServer,
                       PUSER_LIST *ppUserList);

private:
    int HashSid(PSID pSid);
    static int CALLBACK CompareSid(LPVOID p1, LPVOID p2, LPARAM lParam);

    void GetUserFriendlyName(LPCTSTR pszSamLogonName,
                             LPCTSTR pszSamAccountName,
                             LPCTSTR pszServer,
                             BOOL    bUseSamCompatibleInfo,
                             BOOL    bIsStandalone,
                             BSTR   *pstrLogonName,
                             BSTR   *pstrDisplayName);
    BSTR GetNT4DisplayName(LPCTSTR pszAccount,
                           LPCTSTR pszName,
                           LPCTSTR pszServer,
                           BOOL bStandalone);

    BOOL InternalLookupSids(HDPA hSids,
                            LPCTSTR pszServer,
                            LPSECURITYINFO2 psi2,
                            HDPA hEntryList,
                            HWND hWndNotify = NULL,
                            UINT uMsgNotify = 0);
    BOOL LookupSidsHelper(HDPA hSids,
                          LPCTSTR pszServer,
                          HDPA hEntryList,
                          HWND hWndNotify = NULL,
                          UINT uMsgNotify = 0,
                          BOOL bSecondTry = FALSE);
    HRESULT LookupSidsFromObject(HDPA hSids, LPSECURITYINFO2 psi2, HDPA hEntryList);

#if(_WIN32_WINNT >= 0x0500)
    BOOL InternalLookupNames(PDS_SELECTION_LIST pDsSelList,
                             LPCTSTR pszServer,
                             HDPA hEntryList,
                             BOOL bStandalone);
#endif

    static DWORD WINAPI InitThread(LPVOID pvThreadData);

    void Lock()     { EnterCriticalSection(&m_csHashTableLock); }
    void Unlock()   { LeaveCriticalSection(&m_csHashTableLock); }

    void LockDomain()   { EnterCriticalSection(&m_csDomainNameLock); }
    void UnlockDomain() { LeaveCriticalSection(&m_csDomainNameLock); }

    void LockDc()   { EnterCriticalSection(&m_csDcNameLock); }
    void UnlockDc() { LeaveCriticalSection(&m_csDcNameLock); }
};
typedef CSidCache *PSIDCACHE;

//
// Helper functions for creating/deleting the global SID Cache
//
PSIDCACHE GetSidCache();
void FreeSidCache();

#endif  // _SIDCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\permset.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       permset.h
//
//  This file contains the definition of the CPermissionSet class
//
//--------------------------------------------------------------------------

#ifndef _PERMSET_H_
#define _PERMSET_H_

typedef struct _PERMISSION
{
    ACCESS_MASK mask;       // permission bits
    DWORD       dwFlags;    // AceFlags (e.g. inheritance bits)
    GUID        guid;       // often GUID_NULL
} PERMISSION, *PPERMISSION;

class CPermissionSet
{
private:
    HDSA m_hPermList;       // Dynamic array of PERMISSION structures
    HDPA m_hAdvPermList;    // Dynamic array of ACE pointers
    BOOL m_fObjectAcesPresent;

public:
    CPermissionSet() : m_hPermList(NULL), m_hAdvPermList(NULL), m_fObjectAcesPresent(FALSE) {}
    ~CPermissionSet() { Reset(); }

    void Reset();
    void ResetAdvanced();
    BOOL AddAce(const GUID *pguid, ACCESS_MASK mask, DWORD dwFlags);
    BOOL AddPermission(PPERMISSION pPerm);
    BOOL AddAdvancedAce(PACE_HEADER pAce);
    UINT GetPermCount(BOOL fIncludeAdvAces = FALSE) const;
    PPERMISSION GetPermission(UINT i) const { if (m_hPermList) return (PPERMISSION)DSA_GetItemPtr(m_hPermList, i); return NULL; }
    PPERMISSION operator[](UINT i) const { return GetPermission(i); }
    ULONG GetAclLength(ULONG cbSid) const;
    BOOL AppendToAcl(PACL pAcl, PACE_HEADER *ppAcePos, PSID pSid, BOOL fAllowAce, DWORD dwFlags) const;
    void ConvertInheritedAces(CPermissionSet &permInherited);
    void RemovePermission(PPERMISSION pPerm, BOOL bInheritFlag = FALSE);
};

// Flags for AppendToAcl
#define PS_NONOBJECT        0x00000001L
#define PS_OBJECT           0x00000002L


#endif  // _PERMSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\sources.inc ===
TARGETNAME=aclui
TARGETPATH=obj
TARGETTYPE=DYNLINK

PASS1_PUBLISH={$(O)\$(TARGETNAME).lib=$(SDK_LIB_PATH)\$(TARGETNAME).lib}

DLLDEF=$(O)\$(TARGETNAME).def
DLLENTRY=DllMain
USE_NTDLL=1

INCLUDES=..;..\..\inc;$(BASE_INC_PATH)

DELAYLOAD=netapi32.dll;secur32.dll

# 
# Fusionized
# 
SXS_ASSEMBLY_NAME=Microsoft.Windows.ServerGroup.sec
SXS_ASSEMBLY_VERSION=1.0 
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=sec.Manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_MANIFEST_RESOURCE_ID=123
SXS_NO_BINPLACE=1


LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

LINKLIBS=\
    ..\..\common\winnt\$(O)\common.lib     \

TARGETLIBS=\
    $(SDK_LIB_PATH)\kernel32.lib    \
    $(SDK_LIB_PATH)\user32.lib      \
    $(SDK_LIB_PATH)\gdi32.lib       \
    $(SDK_LIB_PATH)\shlwapi.lib     \
    $(SDK_LIB_PATH)\advapi32.lib    \
    $(SDK_LIB_PATH)\ole32.lib       \
    $(SDK_LIB_PATH)\oleaut32.lib    \
    $(SDK_LIB_PATH)\uuid.lib        \
    $(SDK_LIB_PATH)\netapi32.lib    \
    $(SDK_LIB_PATH)\adsiid.lib      \
    $(SDK_LIB_PATH)\secur32.lib     \
    $(SDK_LIB_PATH)\htmlhelp.lib       \
    $(SHELL_LIB_PATH)\shfusion.lib    \

SOURCES=\
    ..\aclui.rc     \
    ..\uuid.c       \
    ..\dll.cpp      \
    ..\ace.cpp      \
    ..\acelist.cpp  \
    ..\owner.cpp    \
    ..\aceedit.cpp  \
    ..\chklist.cpp  \
    ..\misc.cpp     \
    ..\pagebase.cpp \
    ..\perm.cpp     \
    ..\permset.cpp  \
    ..\cstrings.cpp \
    ..\sidcache.cpp \
    ..\effperm.cpp  \
    ..\aclbloat.cpp \


PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\aclpriv.h
PRECOMPILED_PCH=aclpriv.pch
PRECOMPILED_OBJ=aclpriv.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\sidcache.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       sidcache.cpp
//
//  This file contains the implementation of a SID/Name cache.
//
//--------------------------------------------------------------------------

#include "aclpriv.h"

#if(_WIN32_WINNT >= 0x0500)
#include <dsgetdc.h>    // DsGetDcName
#include <iads.h>
#endif

#define SECURITY_WIN32
#include <security.h>   // TranslateName
#include <lm.h>         // NetApiBufferFree
#include <shlwapi.h>    // StrChr, StrRChr

// 10 minutes
#define SID_CACHE_AGE_LIMIT     (10*60*1000)

TCHAR const c_szNTProvider[]    = TEXT("WinNT://");
#define NTPROV_LEN              (ARRAYSIZE(c_szNTProvider)-1)

#define ACLUI_ALIGNED_SID_LENGTH(p) ((PtrAlignSize(RtlLengthSid((p)))))

PSIDCACHE g_pSidCache = NULL;

PSIDCACHE GetSidCache()
{
    if (NULL == g_pSidCache)
    {
        // The cache starts with an extra ref here that will be released
        // during our DLL_PROCESS_DETACH
        g_pSidCache = new CSidCache;

        if (g_pSidCache)
        {
            g_pSidCache->AddRef();
        }
    }
    else
    {
        g_pSidCache->AddRef();
    }

    return g_pSidCache;
}

void FreeSidCache()
{
    if (g_pSidCache)
    {
        g_pSidCache->Release();
        g_pSidCache = NULL;
    }
}

//
// CSidCache implementation
//

CSidCache::CSidCache()
: m_pszCachedServer(NULL), m_pszCachedDomain(NULL),
  m_hInitThread(NULL), m_pszLastDc(NULL), m_pszLastDomain(NULL),
  m_cRef(1)
{
    HINSTANCE hInstThisDll;
    DWORD dwThreadID;

    ZeroMemory(m_dpaSidHashTable, SIZEOF(m_dpaSidHashTable));
    ExceptionPropagatingInitializeCriticalSection(&m_csHashTableLock);
    ExceptionPropagatingInitializeCriticalSection(&m_csDomainNameLock);
    ExceptionPropagatingInitializeCriticalSection(&m_csDcNameLock);

    // Give the thread we are about to create a ref to the dll,
    // so that the dll will remain for the lifetime of the thread
    hInstThisDll = LoadLibrary(c_szDllName);
    if (hInstThisDll != NULL)
    {
        // also do an AddRef() for the worker thread to release later
        AddRef();

        // Start a thread to cache the well-known and built-in SIDs
        m_hInitThread = CreateThread(NULL, 0, InitThread, this, 0, &dwThreadID);

        if (!m_hInitThread)
        {
            // Failed to create the thread, do cleanup
            FreeLibrary(hInstThisDll);
            Release();
        }
    }
}

ULONG
CSidCache::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG
CSidCache::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

CSidCache::~CSidCache()
{
    int i;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::~CSidCache");

    Lock();
    for (i = 0; i < BUCKET_COUNT; i++)
    {
        DestroyDPA(m_dpaSidHashTable[i]);
        m_dpaSidHashTable[i] = NULL;
    }
    Unlock();

    LockDomain();
    LocalFreeString(&m_pszCachedServer);
    LocalFreeString(&m_pszCachedDomain);
    UnlockDomain();

    LockDc();
    LocalFreeString(&m_pszLastDc);
    LocalFreeString(&m_pszLastDomain);
    UnlockDc();

    DeleteCriticalSection(&m_csHashTableLock);
    DeleteCriticalSection(&m_csDomainNameLock);
    DeleteCriticalSection(&m_csDcNameLock);


    if (m_hInitThread != NULL)
    {
        CloseHandle(m_hInitThread);
    }

    TraceLeaveVoid();
}


BOOL
CSidCache::LookupSids(HDPA hSids,
                      LPCTSTR pszServer,
                      LPSECURITYINFO2 psi2,
                      PUSER_LIST *ppUserList)
{
    BOOL fResult = FALSE;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::LookupSids");
    TraceAssert(hSids != NULL);

    if (NULL == hSids)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        TraceLeaveValue(FALSE);
    }

    if (NULL != ppUserList)
        *ppUserList = NULL;

    if (0 != DPA_GetPtrCount(hSids))
    {
        HDPA hEntryList = DPA_Create(4);

        if (NULL == hEntryList)
            TraceLeaveValue(FALSE);

        InternalLookupSids(hSids, pszServer, psi2, hEntryList);

        if (0 != DPA_GetPtrCount(hEntryList) && NULL != ppUserList)
            fResult = BuildUserList(hEntryList, pszServer, ppUserList);

        DPA_Destroy(hEntryList);
    }

    TraceLeaveValue(fResult);
}


BOOL
CSidCache::LookupSidsAsync(HDPA hSids,
                           LPCTSTR pszServer,
                           LPSECURITYINFO2 psi2,
                           HWND hWndNotify,
                           UINT uMsgNotify)
{
    BOOL fResult = FALSE;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::LookupSids");
    TraceAssert(hSids != NULL);

    if (NULL == hSids)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        TraceLeaveValue(FALSE);
    }

    if (0 != DPA_GetPtrCount(hSids))
    {
        fResult = InternalLookupSids(hSids,
                                     pszServer,
                                     psi2,
                                     NULL,
                                     hWndNotify,
                                     uMsgNotify);
    }

    TraceLeaveValue(fResult);
}


#if(_WIN32_WINNT >= 0x0500)
BOOL
CSidCache::LookupNames(PDS_SELECTION_LIST pDsSelList,
                       LPCTSTR pszServer,
                       PUSER_LIST *ppUserList,
                       BOOL bStandalone)
{
    BOOL fResult = FALSE;
    HDPA hEntryList;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::LookupNames");
    TraceAssert(pDsSelList != NULL);
    TraceAssert(ppUserList != NULL);

    if (NULL == pDsSelList)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        TraceLeaveValue(FALSE);
    }

    if (NULL != ppUserList)
        *ppUserList = NULL;

    hEntryList = DPA_Create(4);

    if (NULL == hEntryList)
        TraceLeaveValue(FALSE);

    InternalLookupNames(pDsSelList, pszServer, hEntryList, bStandalone);

    if (0 != DPA_GetPtrCount(hEntryList))
    {
        fResult = TRUE; // so far, so good

        if (NULL != ppUserList)
            fResult = BuildUserList(hEntryList, pszServer, ppUserList);
    }

    DPA_Destroy(hEntryList);

    TraceLeaveValue(fResult);
}
#endif // #if(_WIN32_WINNT >= 0x0500)


void
CSidCache::GetDomainName(LPCTSTR pszServer, LPTSTR pszDomain, ULONG cchDomain)
{
    TraceEnter(TRACE_SIDCACHE, "CSidCache::GetDomainName");
    TraceAssert(NULL != pszDomain);
    TraceAssert(0 != cchDomain);

    pszDomain[0] = TEXT('\0');

    LockDomain();

    if (m_pszCachedDomain == NULL ||
        (pszServer == NULL && m_pszCachedServer != NULL) ||
        (pszServer != NULL && (m_pszCachedServer == NULL ||
         CompareString(LOCALE_USER_DEFAULT,
                       0,
                       pszServer,
                       -1,
                       m_pszCachedServer,
                       -1) != CSTR_EQUAL)))
    {
        //
        // It's a different server than last time, so ask LSA
        // for the domain name.
        //
        LocalFreeString(&m_pszCachedDomain);
        LocalFreeString(&m_pszCachedServer);

        if (pszServer != NULL)
            LocalAllocString(&m_pszCachedServer, pszServer);

        LSA_HANDLE hLSA = GetLSAConnection(pszServer, POLICY_VIEW_LOCAL_INFORMATION);
        if (hLSA != NULL)
        {
            PPOLICY_ACCOUNT_DOMAIN_INFO pDomainInfo = NULL;

            LsaQueryInformationPolicy(hLSA,
                                      PolicyAccountDomainInformation,
                                      (PVOID*)&pDomainInfo);
            if (pDomainInfo != NULL)
            {
                CopyUnicodeString(&m_pszCachedDomain, &pDomainInfo->DomainName);
                LsaFreeMemory(pDomainInfo);

                Trace((TEXT("Domain for %s is %s"), pszServer, m_pszCachedDomain));
            }
            LsaClose(hLSA);
        }
        else if (NULL != pszServer) // use the server name
        {
            // Skip leading backslashes
            while (TEXT('\\') == *pszServer)
                pszServer++;

            LocalAllocString(&m_pszCachedDomain, pszServer);

            if (m_pszCachedDomain)
            {
                // If there is a period, truncate the name at that point so
                // that something like "nttest.microsoft.com" becomes "nttest"
                LPTSTR pszDot = StrChr(m_pszCachedDomain, TEXT('.'));
                if (pszDot)
                    *pszDot = TEXT('\0');
            }
        }
    }

    if (m_pszCachedDomain)
        lstrcpyn(pszDomain, m_pszCachedDomain, cchDomain);

    UnlockDomain();

    TraceLeaveVoid();
}


DWORD
_GetDcName(LPCTSTR pszServer, LPCTSTR pszDomain, LPTSTR *ppszDC)
{
    DWORD dwErr;

    if (!ppszDC)
        return ERROR_INVALID_PARAMETER;

    *ppszDC = NULL;

#if(_WIN32_WINNT >= 0x0500)
    PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;
    TraceMsg("Calling DsGetDcName");
    dwErr = DsGetDcName(pszServer,
                        pszDomain,
                        NULL,
                        NULL,
                        DS_IS_FLAT_NAME,
                        &pDCInfo);
    if (ERROR_SUCCESS == dwErr)
    {
        TraceAssert(NULL != pDCInfo);
        LocalAllocString(ppszDC, pDCInfo->DomainControllerName);
        NetApiBufferFree(pDCInfo);
    }
#else
    LPTSTR pszDcName = NULL;
    // NetGetAnyDCName only works for trusted domains, but is faster
    // and returns either PDC or BDC.  NetGetDCName returns only PDC.
    TraceMsg("Calling NetGetAnyDCName / NetGetDCName");
    dwErr = NetGetAnyDCName(pszServer, pszDomain, (LPBYTE*)&pszDcName);
    if (ERROR_NO_SUCH_DOMAIN == dwErr)
        dwErr = NetGetDCName(pszServer, pszDomain, (LPBYTE*)&pszDcName);
    if (pszDcName)
    {
        LocalAllocString(ppszDC, pszDcName);
        NetApiBufferFree(pszDcName);
    }
#endif

    if (ERROR_SUCCESS == dwErr && !*ppszDC)
        dwErr = ERROR_OUTOFMEMORY;

    return dwErr;
}

void
CSidCache::GetDcName(LPCTSTR pszDomain, LPTSTR pszDC, ULONG cchDC)
{
    TraceEnter(TRACE_SIDCACHE, "CSidCache::GetDcName");
    TraceAssert(NULL != pszDC);
    TraceAssert(0 != cchDC);

    pszDC[0] = TEXT('\0');

    LockDc();

    if (m_pszLastDc == NULL ||
        (pszDomain == NULL && m_pszLastDomain != NULL) ||
        (pszDomain != NULL && (m_pszLastDomain == NULL ||
         CompareString(LOCALE_USER_DEFAULT,
                       0,
                       pszDomain,
                       -1,
                       m_pszLastDomain,
                       -1) != CSTR_EQUAL)))
    {
        //
        // It's a different domain than last time, so look for a DC
        //
        LocalFreeString(&m_pszLastDc);
        LocalFreeString(&m_pszLastDomain);

        if (pszDomain != NULL)
            LocalAllocString(&m_pszLastDomain, pszDomain);

        _GetDcName(NULL, pszDomain, &m_pszLastDc);

        Trace((TEXT("DC for %s is %s"), pszDomain, m_pszLastDc));
    }

    if (m_pszLastDc)
        lstrcpyn(pszDC, m_pszLastDc, cchDC);

    UnlockDc();

    TraceLeaveVoid();
}


BSTR
CSidCache::GetNT4DisplayName(LPCTSTR pszAccount,
                             LPCTSTR pszName,
                             LPCTSTR pszServer,
                             BOOL bStandalone)
{
    BSTR strResult = NULL;
    TCHAR szComputer[UNCLEN];
    LPTSTR pszT = NULL;
    PUSER_INFO_2 pui = NULL;

    if (!pszAccount || !*pszAccount || !pszName || !*pszName)
        return NULL;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::GetNT4DisplayName");

    if (!bStandalone
        && (pszT = StrChr(pszAccount, TEXT('\\'))))
    {
        // Copy the domain name
        TCHAR szDomain[DNLEN];
        lstrcpyn(szDomain,
                 pszAccount,
                 min((size_t)(pszT - pszAccount + 1), ARRAYSIZE(szDomain)));

        // See if we can use pszServer for NetUserGetInfo
        TCHAR szAccountDomain[DNLEN];
        szAccountDomain[0] = TEXT('\0');
        GetDomainName(pszServer, szAccountDomain, ARRAYSIZE(szAccountDomain));

        if (lstrcmpi(szDomain, szAccountDomain))
        {
            // Different domain, find a DC
            szComputer[0] = TEXT('\0');
            GetDcName(szDomain, szComputer, ARRAYSIZE(szComputer));
            if (TEXT('\0') != szComputer[0])
                pszServer = szComputer;
        }
    }

    TraceMsg("Calling NetUserGetInfo");
    if (NERR_Success == NetUserGetInfo(pszServer, pszName, 2, (LPBYTE *)&pui)
        && NULL != pui->usri2_full_name
        && *pui->usri2_full_name)
    {
        strResult = SysAllocString(pui->usri2_full_name);
    }

    NetApiBufferFree(pui);

    Trace((TEXT("Returning Full Name '%s' for '%s'"), strResult, pszAccount));
    TraceLeaveValue(strResult);
}


int
CSidCache::HashSid(PSID pSid)
{
    DWORD dwHash = 0;

    if (NULL != pSid)
    {
        PBYTE pbSid    = (PBYTE)pSid;
        PBYTE pbEndSid = pbSid + GetLengthSid(pSid);

        while (pbSid < pbEndSid)
            dwHash += *pbSid++;
    }

    return dwHash % BUCKET_COUNT;
}


int CALLBACK
CSidCache::CompareSid(LPVOID p1, LPVOID p2, LPARAM lParam)
{
    int nResult = 0;
    PSID_CACHE_ENTRY pEntry1 = (PSID_CACHE_ENTRY)p1;
    PSID_CACHE_ENTRY pEntry2 = (PSID_CACHE_ENTRY)p2;
    PSID pSid1 = NULL;
    PSID pSid2 = NULL;

    if (pEntry1)
        pSid1 = pEntry1->pSid;
    else if (lParam)
        pSid1 = (PSID)lParam;

    if (pEntry2)
        pSid2 = pEntry2->pSid;

    if (pSid1 == NULL)
        nResult = -1;
    else if (pSid2 == NULL)
        nResult = 1;
    else
    {
        DWORD dwLength = GetLengthSid(pSid1);

        // Compare SID lengths
        nResult = dwLength - GetLengthSid(pSid2);

        if (nResult == 0)
        {
            // Lengths are equal, compare the bits
            PBYTE pbSid1 = (PBYTE)pSid1;
            PBYTE pbSid2 = (PBYTE)pSid2;

            // Could compare Identifier Authorities and SubAuthorities instead
            while (nResult == 0 && dwLength != 0)
            {
                dwLength--;
                nResult = *pbSid1++ - *pbSid2++;
            }
        }
    }

    return nResult;
}


PSID_CACHE_ENTRY
CSidCache::FindSid(PSID pSid)
{
    PSID_CACHE_ENTRY pEntry = NULL;
    int iBucket;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::FindSid");
    TraceAssert(pSid != NULL);
    TraceAssert(IsValidSid(pSid));

    iBucket = HashSid(pSid);

    Lock();

    if (m_dpaSidHashTable[iBucket] != NULL)
    {
        int iEntry = DPA_Search(m_dpaSidHashTable[iBucket],
                                NULL,
                                0,
                                CompareSid,
                                (LPARAM)pSid,
                                DPAS_SORTED);
        if (iEntry != -1)
        {
            pEntry = (PSID_CACHE_ENTRY)DPA_FastGetPtr(m_dpaSidHashTable[iBucket],
                                                      iEntry);
            TraceAssert(pEntry != NULL);
            TraceAssert(EqualSid(pSid, pEntry->pSid));

            if (0 != pEntry->dwLastAccessTime)
            {
                DWORD dwCurrentTime = GetTickCount();

                if ((dwCurrentTime - pEntry->dwLastAccessTime) > SID_CACHE_AGE_LIMIT)
                {
                    // The entry has aged out, remove it.
                    Trace((TEXT("Removing stale entry: %s"), pEntry->pszName));
                    DPA_DeletePtr(m_dpaSidHashTable[iBucket], iEntry);
                    LocalFree(pEntry);
                    pEntry = NULL;
                }
                else
                    pEntry->dwLastAccessTime = dwCurrentTime;
            }
        }
    }

    Unlock();

    TraceLeaveValue(pEntry);
}


PSID_CACHE_ENTRY
CSidCache::MakeEntry(PSID pSid,
                     SID_NAME_USE SidType,
                     LPCTSTR pszName,
                     LPCTSTR pszLogonName)
{
    PSID_CACHE_ENTRY pEntry = NULL;
    ULONG cbSid;
    ULONG cbName = 0;
    ULONG cbLogonName = 0;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::MakeEntry");
    TraceAssert(pSid != NULL);

    cbSid = GetLengthSid(pSid);
    if (NULL != pszName && *pszName)
        cbName = StringByteSize(pszName);
    if (NULL != pszLogonName && *pszLogonName)
        cbLogonName = StringByteSize(pszLogonName);

    pEntry = (PSID_CACHE_ENTRY)LocalAlloc(LPTR,
                                          SIZEOF(SID_CACHE_ENTRY)
                                           + cbSid
                                           + cbName
                                           + cbLogonName);
    if (pEntry != NULL)
    {
        PBYTE pData = (PBYTE)(pEntry+1);

        pEntry->SidType = SidType;

        pEntry->pSid = (PSID)pData;
        CopyMemory(pData, pSid, cbSid);
        pData += cbSid;

        if (0 != cbName)
        {
            pEntry->pszName = (LPCTSTR)pData;
            CopyMemory(pData, pszName, cbName);
            pData += cbName;
        }

        if (0 != cbLogonName)
        {
            pEntry->pszLogonName = (LPCTSTR)pData;
            CopyMemory(pData, pszLogonName, cbLogonName);
            //pData += cbLogonName;
        }

        // Well-known entries never age out
        if (SidTypeWellKnownGroup == SidType || IsAliasSid(pSid))
            pEntry->dwLastAccessTime = 0;
        else
            pEntry->dwLastAccessTime = GetTickCount();
    }

    TraceLeaveValue(pEntry);
}


BOOL
CSidCache::AddEntry(PSID_CACHE_ENTRY pEntry)
{
    BOOL fResult = FALSE;
    int iSidBucket;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::AddEntry");
    TraceAssert(pEntry != NULL);

    if (NULL == pEntry)
        TraceLeaveValue(FALSE);

    iSidBucket = HashSid(pEntry->pSid);

    Lock();

    if (m_dpaSidHashTable[iSidBucket] == NULL)
        m_dpaSidHashTable[iSidBucket] = DPA_Create(4);

    if (NULL != m_dpaSidHashTable[iSidBucket])
    {
        DPA_AppendPtr(m_dpaSidHashTable[iSidBucket], pEntry);
        DPA_Sort(m_dpaSidHashTable[iSidBucket], CompareSid, 0);
        fResult = TRUE;
    }

    Unlock();

    TraceLeaveValue(fResult);
}


BOOL
CSidCache::BuildUserList(HDPA hEntryList,
                         LPCTSTR pszServer,
                         PUSER_LIST *ppUserList)
{
    ULONG cEntries;
    TCHAR szAliasDomain[MAX_PATH];
    PSID_CACHE_ENTRY pEntry;
    ULONG cb = 0;
	ULONG cSidsLen = 0;
    ULONG cbAliasDomain = 0;
    ULONG i;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::BuildUserList");
    TraceAssert(hEntryList != NULL);
    TraceAssert(ppUserList != NULL);

    cEntries = DPA_GetPtrCount(hEntryList);
    TraceAssert(0 != cEntries);

    //
    // This name replaces "BUILTIN" for Alias SIDs
    //
    GetDomainName(pszServer, szAliasDomain, ARRAYSIZE(szAliasDomain));
    cbAliasDomain = StringByteSize(szAliasDomain);

    //
    // Add the sizes
    //
    cb = SIZEOF(USER_LIST) + ((cEntries - 1) * SIZEOF(USER_INFO));
    for (i = 0; i < cEntries; i++)
    {
        pEntry = (PSID_CACHE_ENTRY)DPA_FastGetPtr(hEntryList, i);
        TraceAssert(NULL != pEntry);
		
		cSidsLen += ACLUI_ALIGNED_SID_LENGTH(pEntry->pSid);
        
        if (SidTypeAlias == pEntry->SidType)
            cb += cbAliasDomain;
        else if (pEntry->pszLogonName)
            cb += StringByteSize(pEntry->pszLogonName);

        if (pEntry->pszName)
            cb += StringByteSize(pEntry->pszName);
    }

	cb += cSidsLen;
    //
    // Allocate and build the return buffer
    //
    *ppUserList = (PUSER_LIST)LocalAlloc(LPTR, cb);

    if (NULL == *ppUserList)
        TraceLeaveValue(FALSE);

    (*ppUserList)->cUsers = cEntries;

	PBYTE pData = NULL;
	PBYTE pCharData = NULL;

	//
	//NTRAID#NTBUG9-364410-2001/20/23-hiteshr
	//Sids were non aligned if cEntries > 1
	//
    pData = (PBYTE)&(*ppUserList)->rgUsers[cEntries];
	pCharData = pData + cSidsLen;

    for (i = 0; i < cEntries; i++)
    {
        pEntry = (PSID_CACHE_ENTRY)DPA_FastGetPtr(hEntryList, i);
        TraceAssert(NULL != pEntry);

        (*ppUserList)->rgUsers[i].SidType = pEntry->SidType;

        TraceAssert(NULL != pEntry->pSid);
        (*ppUserList)->rgUsers[i].pSid = (PSID)pData;
        cb = GetLengthSid(pEntry->pSid);
        CopyMemory(pData, pEntry->pSid, cb);
        pData += cb;

        if (SidTypeAlias == pEntry->SidType)
        {
            (*ppUserList)->rgUsers[i].pszLogonName = (LPCTSTR)pCharData;

            // Copy the "BUILTIN" domain name
            if (cbAliasDomain)
            {
                CopyMemory(pCharData, szAliasDomain, cbAliasDomain);
                pCharData += cbAliasDomain - SIZEOF(TCHAR);

                if (NULL != pEntry->pszName)
                    *(LPTSTR)pCharData = TEXT('\\');
                else
                    *(LPTSTR)pCharData = TEXT('\0');

                pCharData += SIZEOF(TCHAR);
            }
            // The rest of the name is copied below
        }
        else  if (NULL != pEntry->pszLogonName)
        {
            (*ppUserList)->rgUsers[i].pszLogonName = (LPCTSTR)pCharData;
            cb = StringByteSize(pEntry->pszLogonName);
            CopyMemory(pCharData, pEntry->pszLogonName, cb);
            pCharData += cb;
        }

        if (NULL != pEntry->pszName)
        {
            (*ppUserList)->rgUsers[i].pszName = (LPCTSTR)pCharData;
            cb = StringByteSize(pEntry->pszName);
            CopyMemory(pCharData, pEntry->pszName, cb);
            pCharData += cb;
        }
    }

    TraceLeaveValue(TRUE);
}


//
// Wrapper around sspi's TranslateName that automatically handles
// the buffer sizing
//
HRESULT
TranslateNameInternal(LPCTSTR pszAccountName,
                      EXTENDED_NAME_FORMAT AccountNameFormat,
                      EXTENDED_NAME_FORMAT DesiredNameFormat,
                      BSTR *pstrTranslatedName)
{
#if(_WIN32_WINNT >= 0x0500)
#if DBG
    //
    // These match up with the EXTENDED_NAME_FORMAT enumeration.
    // They're for debugger output only.
    //
    static const LPCTSTR rgpszFmt[] = { 
                                TEXT("NameUnknown"),
                                TEXT("FullyQualifiedDN"),
                                TEXT("NameSamCompatible"),
                                TEXT("NameDisplay"),
                                TEXT("NameDomainSimple"),
                                TEXT("NameEnterpriseSimple"),
                                TEXT("NameUniqueId"),
                                TEXT("NameCanonical"),
                                TEXT("NameUserPrincipal"),
                                TEXT("NameCanonicalEx"),
                                TEXT("NameServicePrincipal") };
#endif // DBG

    TraceEnter(TRACE_SIDCACHE, "TranslateNameInternal");
    Trace((TEXT("Calling TranslateName for \"%s\""), pszAccountName));
    Trace((TEXT("Translating %s -> %s"), 
              rgpszFmt[AccountNameFormat], rgpszFmt[DesiredNameFormat]));

    if (!pszAccountName || !*pszAccountName || !pstrTranslatedName)
        TraceLeaveResult(E_INVALIDARG);

    HRESULT hr = NOERROR;
    //
    // cchTrans is static so that if a particular installation's
    // account names are really long, we'll not be resizing the
    // buffer for each account.
    //
    static ULONG cchTrans = MAX_PATH;
    ULONG cch = cchTrans;

    *pstrTranslatedName = SysAllocStringLen(NULL, cch);
    if (NULL == *pstrTranslatedName)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to allocate name buffer");

    **pstrTranslatedName = L'\0';

    //
    // TranslateName is delay-loaded from secur32.dll using the linker's
    // delay-load mechanism.  Therefore, wrap with an exception handler.
    //
    __try
    {
        while(!::TranslateName(pszAccountName,
                               AccountNameFormat,
                               DesiredNameFormat,
                               *pstrTranslatedName,
                               &cch))
        {
            if (ERROR_INSUFFICIENT_BUFFER == GetLastError())
            {
                Trace((TEXT("Resizing buffer to %d chars"), cch));
                if (!SysReAllocStringLen(pstrTranslatedName, NULL, cch))
                    ExitGracefully(hr, E_OUTOFMEMORY, "Unable to reallocate name buffer");

                **pstrTranslatedName = L'\0';
            }
            else
            {
                hr = E_FAIL;
                break;
            }
        }

        cchTrans = max(cch, cchTrans);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_FAIL;
    }

exit_gracefully:

    if (FAILED(hr))
    {
        SysFreeString(*pstrTranslatedName);
        *pstrTranslatedName = NULL;
    }

    TraceLeaveResult(hr);
#else
    return E_NOTIMPL;
#endif  // _WIN32_WINNT >= 0x0500
}


void
CSidCache::GetUserFriendlyName(LPCTSTR pszSamLogonName,
                               LPCTSTR pszSamAccountName,
                               LPCTSTR pszServer,
                               BOOL    bUseSamCompatibleInfo,
                               BOOL    bIsStandalone,
                               BSTR   *pstrLogonName,
                               BSTR   *pstrDisplayName)
{
    BSTR strFQDN = NULL;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::GetUserFriendlyName");
    TraceAssert(NULL != pszSamLogonName);

    //
    // Start by getting the FQDN.  Cracking is most efficient when the
    // FQDN is the starting point.
    //
    // TranslateName takes a while to complete, so bUseSamCompatibleInfo
    // should be TRUE whenever possible, e.g. for local accounts on a non-DC
    // or anything where we know a FQDN doesn't exist.
    //
    if (!bUseSamCompatibleInfo &&
        FAILED(TranslateNameInternal(pszSamLogonName,
                                     NameSamCompatible,
                                     NameFullyQualifiedDN,
                                     &strFQDN)))
    {
        //
        // No FQDN available for this account.  Must be an NT4
        // account.  Return SAM-compatible info to the caller.
        //
        bUseSamCompatibleInfo = TRUE;
    }

    if (NULL != pstrLogonName)
    {
        *pstrLogonName = NULL;

        if (!bUseSamCompatibleInfo)
        {
            TranslateNameInternal(strFQDN,
                                  NameFullyQualifiedDN,
                                  NameUserPrincipal,
                                  pstrLogonName);
        }
    }

    if (NULL != pstrDisplayName)
    {
        *pstrDisplayName = NULL;

        if (bUseSamCompatibleInfo ||
            FAILED(TranslateNameInternal(strFQDN,
                                         NameFullyQualifiedDN,
                                         NameDisplay,
                                         pstrDisplayName)))
        {
            *pstrDisplayName = GetNT4DisplayName(pszSamLogonName,
                                                 pszSamAccountName,
                                                 pszServer,
                                                 bIsStandalone);
        }
    }

    SysFreeString(strFQDN);

    TraceLeaveVoid();
}


BOOL
CSidCache::InternalLookupSids(HDPA hSids,
                              LPCTSTR pszServer,
                              LPSECURITYINFO2 psi2,
                              HDPA hEntryList,
                              HWND hWndNotify,
                              UINT uMsgNotify)
{
    ULONG cSids;
    HDPA hUnknownSids;
    PSID_CACHE_ENTRY pEntry;
    ULONG i;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::InternalLookupSids");
    TraceAssert(hSids != NULL);

    if (hSids == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        TraceLeaveValue(FALSE);
    }

    cSids = DPA_GetPtrCount(hSids);
    TraceAssert(0 != cSids);

    hUnknownSids = DPA_Create(4);

    if (NULL == hUnknownSids)
        TraceLeaveValue(FALSE);

    //
    // See if any exist in the cache already
    //
    for (i = 0; i < cSids; i++)
    {
        pEntry = FindSid((PSID)DPA_FastGetPtr(hSids, i));

        if (pEntry)
        {
            if (hWndNotify)
                PostMessage(hWndNotify, uMsgNotify, 0, (LPARAM)pEntry->pSid);
            else if (hEntryList)
                DPA_AppendPtr(hEntryList, pEntry);
        }
        else
            DPA_AppendPtr(hUnknownSids, DPA_FastGetPtr(hSids, i));
    }

    //
    // Call LSA to lookup any that we don't have cached
    //
    if (0 != DPA_GetPtrCount(hUnknownSids))
    {
        if (!psi2 ||
            FAILED(LookupSidsFromObject(hUnknownSids, psi2, hEntryList)))
        {
            LookupSidsHelper(hUnknownSids,
                             pszServer,
                             hEntryList,
                             hWndNotify,
                             uMsgNotify);
        }
    }

    DPA_Destroy(hUnknownSids);

    TraceLeaveValue(TRUE);
}

#if(_WIN32_WINNT >= 0x0500)
#include <adsnms.h>     // USER_CLASS_NAME, etc.
#else
#define COMPUTER_CLASS_NAME     TEXT("Computer")
#define USER_CLASS_NAME         TEXT("User")
#define GROUP_CLASS_NAME        TEXT("Group")
#define GLOBALGROUP_CLASS_NAME  TEXT("GlobalGroup")
#define LOCALGROUP_CLASS_NAME   TEXT("LocalGroup")
#endif

TCHAR const c_szForeignSecurityPrincipal[]  = TEXT("foreignSecurityPrincipal");

static const struct
{
    LPCTSTR pszClass;
    SID_NAME_USE sidType;
} c_aSidClasses[] =
{
    USER_CLASS_NAME,                    SidTypeUser,
    GROUP_CLASS_NAME,                   SidTypeGroup,
    GLOBALGROUP_CLASS_NAME,             SidTypeGroup,
    LOCALGROUP_CLASS_NAME,              SidTypeGroup,
    COMPUTER_CLASS_NAME,                SidTypeComputer,
    c_szForeignSecurityPrincipal,       SidTypeGroup,
};

SID_NAME_USE
GetSidType(PSID pSid, LPCTSTR pszClass)
{
    SID_NAME_USE sidType = SidTypeUnknown;

    TraceEnter(TRACE_SIDCACHE, "GetSidType");

    if (pSid)
    {
        TraceAssert(IsValidSid(pSid));

        if (EqualSystemSid(pSid, UI_SID_World) || IsCreatorSid(pSid))
            TraceLeaveValue(SidTypeWellKnownGroup);

        if (IsAliasSid(pSid))
            TraceLeaveValue(SidTypeAlias);

        if (*GetSidSubAuthorityCount(pSid) == 1 && IsNTAuthority(pSid))
        {
            DWORD sa = *GetSidSubAuthority(pSid, 0);
            if (sa && sa <= SECURITY_RESTRICTED_CODE_RID && sa != SECURITY_LOGON_IDS_RID)
                TraceLeaveValue(SidTypeWellKnownGroup);
            if (SECURITY_LOCAL_SYSTEM_RID == sa)
                TraceLeaveValue(SidTypeWellKnownGroup);
        }
    }

    if (pszClass)
    {
        // Didn't recognize the SID, try the class name
        for (int i = 0; i < ARRAYSIZE(c_aSidClasses); i++)
        {
            if (!lstrcmpi(pszClass, c_aSidClasses[i].pszClass))
                TraceLeaveValue(c_aSidClasses[i].sidType);
        }
        Trace((TEXT("Unexpected class type: %s"), pszClass));
    }

    // Don't know what type it is, so take a guess.  This is just
    // for picking an icon, so it doesn't matter too much.
    TraceLeaveValue(SidTypeUser); // SidTypeGroup would be just as valid
}

HRESULT
CSidCache::LookupSidsFromObject(HDPA hSids,
                                LPSECURITYINFO2 psi2,
                                HDPA hEntryList)
{
    HRESULT hr;
    ULONG cSids;
    LPDATAOBJECT pdoNames = NULL;
    STGMEDIUM medium = {0};
    FORMATETC fe = { (CLIPFORMAT)g_cfSidInfoList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    PSID_INFO_LIST pSidList = NULL;
    UINT i;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::LookupSidsFromObject");
    TraceAssert(hSids != NULL);
    TraceAssert(psi2 != NULL);

    cSids = DPA_GetPtrCount(hSids);
    TraceAssert(cSids != 0);

    hr = psi2->LookupSids(cSids, DPA_GetPtrPtr(hSids), &pdoNames);
    FailGracefully(hr, "ISecurityInformation2::LookupSids failed");

    hr = pdoNames->GetData(&fe, &medium);
    FailGracefully(hr, "Unable to get CFSTR_ACLUI_SID_INFO_LIST from DataObject");

    pSidList = (PSID_INFO_LIST)GlobalLock(medium.hGlobal);
    if (!pSidList)
        ExitGracefully(hr, E_FAIL, "Unable to lock stgmedium.hGlobal");

    TraceAssert(pSidList->cItems > 0);

    for (i = 0; i < pSidList->cItems; i++)
    {
        PSID_CACHE_ENTRY pEntry = MakeEntry(pSidList->aSidInfo[i].pSid,
                                            GetSidType(pSidList->aSidInfo[i].pSid,
                                                       pSidList->aSidInfo[i].pwzClass),
                                            pSidList->aSidInfo[i].pwzCommonName,
                                            pSidList->aSidInfo[i].pwzUPN);
        if (pEntry)
        {
            if (AddEntry(pEntry))
            {
                if (hEntryList)
                    DPA_AppendPtr(hEntryList, pEntry);
            }
            else
                LocalFree(pEntry);
        }
    }

exit_gracefully:

    if (pSidList)
        GlobalUnlock(medium.hGlobal);
    ReleaseStgMedium(&medium);
    DoRelease(pdoNames);

    TraceLeaveResult(hr);
}

BOOL
CSidCache::LookupSidsHelper(HDPA hSids,
                            LPCTSTR pszServer,
                            HDPA hEntryList,
                            HWND hWndNotify,
                            UINT uMsgNotify,
                            BOOL bSecondTry)
{
    BOOL fResult = FALSE;
    ULONG cSids;
    LSA_HANDLE hlsa = NULL;
    PLSA_REFERENCED_DOMAIN_LIST pRefDomains = NULL;
    PLSA_TRANSLATED_NAME pTranslatedNames = NULL;
    DWORD dwStatus;
    BOOL bIsDC = FALSE;
    BOOL bIsStandalone = FALSE;
    HDPA hUnknownSids = NULL;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::LookupSidsHelper");
    TraceAssert(hSids != NULL);

    cSids = DPA_GetPtrCount(hSids);
    if (!cSids)
        TraceLeaveValue(FALSE);

    //
    // Call LSA to lookup SIDs for the names
    //
    hlsa = GetLSAConnection(pszServer, POLICY_LOOKUP_NAMES);
    if (NULL == hlsa && NULL != pszServer && !bSecondTry)
    {
        // Try the local machine
        pszServer = NULL;
        hlsa = GetLSAConnection(NULL, POLICY_LOOKUP_NAMES);
    }
    if (NULL == hlsa)
        TraceLeaveValue(FALSE);

    dwStatus = LsaLookupSids(hlsa,
                             cSids,
                             DPA_GetPtrPtr(hSids),
                             &pRefDomains,
                             &pTranslatedNames);

    bIsStandalone = IsStandalone(pszServer, &bIsDC);

    if (STATUS_SUCCESS == dwStatus || STATUS_SOME_NOT_MAPPED == dwStatus)
    {
        TraceAssert(pTranslatedNames);
        TraceAssert(pRefDomains);

        //
        // Build cache entries with NT4 style names
        //
        for (ULONG i = 0; i < cSids; i++)
        {
            BOOL bTryUPN = TRUE;
            BSTR strLogonName = NULL;
            BSTR strDisplayName = NULL;
            LPTSTR pszDeletedAccount = NULL;
            LPTSTR pszSID = NULL;

            PLSA_TRANSLATED_NAME pLsaName = &pTranslatedNames[i];
            PLSA_TRUST_INFORMATION pLsaDomain = NULL;
            PSID pSid = DPA_FastGetPtr(hSids, i);

            TCHAR szAccountName[MAX_PATH];
            TCHAR szDomainName[MAX_PATH];

            BOOL bNoCache = FALSE;

            szAccountName[0] = TEXT('\0');
            szDomainName[0] = TEXT('\0');

            // Get the referenced domain, if any
            if (pLsaName->DomainIndex >= 0 && pRefDomains)
            {
                TraceAssert((ULONG)pLsaName->DomainIndex < pRefDomains->Entries);
                pLsaDomain = &pRefDomains->Domains[pLsaName->DomainIndex];
            }

            // Make NULL-terminated copies of the domain and account name strings
            CopyUnicodeString(szAccountName, ARRAYSIZE(szAccountName), &pLsaName->Name);
            if (pLsaDomain)
                CopyUnicodeString(szDomainName, ARRAYSIZE(szDomainName), &pLsaDomain->Name);

            // Some optimization to avoid TranslateName when possible
            if (!bIsDC)
            {
                if (bIsStandalone)
                {
                    // Non-DC, standalone, therefore no UPN
                    bTryUPN = FALSE;
                }
                else if (SidTypeUser == pLsaName->Use)
                {
                    TCHAR szTargetDomain[DNLEN];
                    szTargetDomain[0] = TEXT('\0');
                    GetDomainName(pszServer, szTargetDomain, ARRAYSIZE(szTargetDomain));
                    if (CSTR_EQUAL == CompareString(LOCALE_USER_DEFAULT,
                                                    NORM_IGNORECASE,
                                                    szTargetDomain,
                                                    -1,
                                                    szDomainName,
                                                    -1))
                    {
                        // Local account on non-DC, therefore no UPN
                        bTryUPN = FALSE;
                    }
                }
            }

            //
            // Build NT4 "domain\user" style name
            //
            if (szDomainName[0] != TEXT('\0'))
            {
                lstrcat(szDomainName, TEXT("\\"));
                lstrcat(szDomainName, szAccountName);
            }

            // What we've got so far is our baseline.
            // Adjust these based on SID type.
            LPTSTR pszName = szAccountName;
            LPTSTR pszLogonName = szDomainName;

            switch (pLsaName->Use)
            {
            case SidTypeUser:               // 1
                // Get "User Principal Name" etc.
                GetUserFriendlyName(pszLogonName,
                                    pszName,
                                    pszServer,
                                    !bTryUPN,
                                    bIsStandalone,
                                    &strLogonName,
                                    &strDisplayName);
                if (strLogonName)
                    pszLogonName = strLogonName;
                if (strDisplayName)
                    pszName = strDisplayName;
                break;

            case SidTypeGroup:              // 2
            case SidTypeDomain:             // 3
                // nothing
                break;

            case SidTypeAlias:              // 4
                if (!IsAliasSid(pSid))
                {
                    // Sometimes get SidTypeAlias for non-BUILTIN sids,
                    // e.g. Domain Local Groups. Treat these as groups
                    // so we don't replace the Domain name.
                    // Raid #383755
                    pLsaName->Use = SidTypeGroup;
                    break;
                }
                // else Fall Through
            case SidTypeWellKnownGroup:     // 5
                // No logon name for these
                pszLogonName = NULL;
                break;

            case SidTypeDeletedAccount:     // 6
                // Display "Account Deleted(Sid)"
                ConvertSidToStringSid(pSid, &pszSID);
                if(FormatStringID(&pszDeletedAccount,
                                 ::hModule,
                                 IDS_SID_DELETED_1,
                                 pszSID))
				{
					if (pszSID)
						LocalFreeString(&pszSID);
					if (pszDeletedAccount)
						pszName = pszDeletedAccount;
					pszLogonName = NULL;
				}
				else
				{
					bNoCache = TRUE;
				}
                break;

            case SidTypeInvalid:            // 7
                bNoCache = TRUE;
                break;

            case SidTypeUnknown:            // 8
                // Some SIDs can only be looked up on a DC, so
                // if pszServer is not a DC, remember them and
                // look them up on a DC after this loop is done.
                if (!bSecondTry && !bIsStandalone && !bIsDC)
                {
                    if (!hUnknownSids)
                        hUnknownSids = DPA_Create(4);
                    if (hUnknownSids)
                        DPA_AppendPtr(hUnknownSids, pSid);

					bNoCache = TRUE;
                }
				else
				{
					// Display "Account Unknown(Sid)"
					ConvertSidToStringSid(pSid, &pszSID);
					if(FormatStringID(&pszDeletedAccount,
									::hModule,
									IDS_SID_UNKNOWN_1,
									pszSID))
					{
						if (pszSID)
							LocalFreeString(&pszSID);
						if (pszDeletedAccount)
							pszName = pszDeletedAccount;
						pszLogonName = NULL;
					}
					else
					{
						bNoCache = TRUE;
					}
                }
                break;

    #if(_WIN32_WINNT >= 0x0500)
            case SidTypeComputer:           // 9
                if (*pszName)
                {
                    // Strip the trailing '$'
                    int nLen = lstrlen(pszName);
                    if (nLen && pszName[nLen-1] == TEXT('$'))
                    {
                        pszName[nLen-1] = TEXT('\0');
                    }
                }
                break;
    #endif
            }

            if (!bNoCache)
            {
                //
                // Make a cache entry and save it
                //
                PSID_CACHE_ENTRY pEntry = MakeEntry(pSid,
                                                    pLsaName->Use,
                                                    pszName,
                                                    pszLogonName);
                if (pEntry)
                {
                    if (AddEntry(pEntry))
                    {
                        fResult = TRUE; // we added something to the cache

                        if (hWndNotify)
                            PostMessage(hWndNotify, uMsgNotify, 0, (LPARAM)pEntry->pSid);
                        else if (hEntryList)
                            DPA_AppendPtr(hEntryList, pEntry);
                    }
                    else
                        LocalFree(pEntry);
                }
            }

            if (strLogonName)
                SysFreeString(strLogonName);
            if (strDisplayName)
                SysFreeString(strDisplayName);
            LocalFreeString(&pszDeletedAccount);
        }
    }
    else if (STATUS_NONE_MAPPED == dwStatus && !bSecondTry && !bIsStandalone && !bIsDC)
    {
        hUnknownSids = DPA_Clone(hSids, NULL);
    }

    // Cleanup
    if (pTranslatedNames)
        LsaFreeMemory(pTranslatedNames);
    if (pRefDomains)
        LsaFreeMemory(pRefDomains);
    LsaClose(hlsa);


    if (hUnknownSids)
    {
        //
        // Some (or all) SIDs were unknown on the target machine,
        // try a DC for the target machine's primary domain.
        //
        // This typically happens for certain Alias SIDs, such
        // as Print Operators and System Operators, for which LSA
        // only returns names if the lookup is done on a DC.
        //
        LPTSTR pszDC = NULL;

        TraceAssert(!bSecondTry);

        // We don't bother trying if standalone, and don't
        // do this if the target machine is already a DC.
        TraceAssert(!bIsStandalone && !bIsDC);

        _GetDcName(pszServer, NULL, &pszDC);

        if (pszDC)
        {
            // Recurse
            if (LookupSidsHelper(hUnknownSids,
                                 pszDC,
                                 hEntryList,
                                 hWndNotify,
                                 uMsgNotify,
                                 TRUE))
            {
                fResult = TRUE;
            }
            LocalFree(pszDC);
        }

        DPA_Destroy(hUnknownSids);
    }

    TraceLeaveValue(fResult);
}


#if(_WIN32_WINNT >= 0x0500)

BSTR GetNT4AccountName(LPTSTR pszWinNTPath)
{
    // pszWinNTPath is expected to look like
    //   "WinNT://domain/user"
    // or
    //   "WinNT://domain/machine/user"
    //
    // The "WinNT://" part is optional.
    //
    // In either case, we want the last 2 elements,
    // e.g. "domain/user" and "machine/user".
    //
    // The approach is to find the next to last '/' and add 1.
    // If there are less than 2 slashes, return the original string.

    BSTR strResult = NULL;
    LPTSTR pszResult = pszWinNTPath;
    if (pszWinNTPath)
    {
        LPTSTR pszSlash = StrRChr(pszWinNTPath, pszWinNTPath + lstrlen(pszWinNTPath) - 1, TEXT('/'));
        if (pszSlash)
        {
            pszSlash = StrRChr(pszWinNTPath, pszSlash-1, TEXT('/'));
            if (pszSlash)
                pszResult = pszSlash + 1;
        }
    }

    if (pszResult)
    {
        strResult = SysAllocString(pszResult);
        if (strResult)
        {
            // At this point, there is at most one forward slash
            // in the string.  Convert it to a backslash.
            LPTSTR pszSlash = StrChr(strResult, TEXT('/'));
            if (pszSlash)
                *pszSlash = TEXT('\\');
        }
    }

    return strResult;
}

BOOL
_LookupName(LPCTSTR pszServer,
            LPCTSTR pszAccount,
            PSID *ppSid,
            SID_NAME_USE *pSidType)
{
    BOOL fResult = FALSE;
    BYTE buffer[sizeof(SID) + SID_MAX_SUB_AUTHORITIES*sizeof(ULONG)];
    PSID pSid = (PSID)buffer;
    DWORD cbSid = sizeof(buffer);
    TCHAR szDomain[MAX_PATH];
    DWORD cchDomain = ARRAYSIZE(szDomain);
    SID_NAME_USE sidType;

    fResult = LookupAccountName(pszServer,
                                pszAccount,
                                pSid,
                                &cbSid,
                                szDomain,
                                &cchDomain,
                                &sidType);
    if (fResult)
    {
        *ppSid = LocalAllocSid(pSid);
        if (*ppSid)
        {
            if (pSidType)
                *pSidType = sidType;
        }
        else
            fResult = FALSE;
    }

    return fResult;
}

BOOL
CSidCache::InternalLookupNames(PDS_SELECTION_LIST pDsSelList,
                               LPCTSTR pszServer,
                               HDPA hEntryList,
                               BOOL bStandalone)
{
    BOOL fResult = FALSE;
    ULONG cNames;
    HDPA hSids = NULL;
    PSID_CACHE_ENTRY pEntry;
    ULONG i;
    ULONG cNoSID = 0;
    HRESULT hrCom = E_FAIL;
    IADsPathname *pPath = NULL;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::InternalLookupNames");
    TraceAssert(pDsSelList != NULL);
    TraceAssert(hEntryList != NULL);

    if (pDsSelList == NULL || hEntryList == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        TraceLeaveValue(FALSE);
    }

    cNames = pDsSelList->cItems;
    TraceAssert(cNames != 0);

    if (0 == cNames)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        TraceLeaveValue(FALSE);
    }

    hSids = DPA_Create(4);

    for (i = 0; i < cNames; i++)
    {
        PSID pSid = NULL;
        PSID pSidFree = NULL;
        LPVARIANT pvarSid = pDsSelList->aDsSelection[i].pvarFetchedAttributes;
        SID_NAME_USE sidType = SidTypeUnknown;
        BSTR strNT4Name = NULL;

        if (NULL == pvarSid || (VT_ARRAY | VT_UI1) != V_VT(pvarSid)
            || FAILED(SafeArrayAccessData(V_ARRAY(pvarSid), &pSid)))
        {
            // If there's no SID, then we can't use it in an ACL
            Trace((TEXT("No SID returned for %s"), pDsSelList->aDsSelection[i].pwzADsPath));

            // If it's the NT provider, try to lookup the SID by name
            if (CSTR_EQUAL == CompareString(LOCALE_USER_DEFAULT,
                                            0,
                                            c_szNTProvider,
                                            NTPROV_LEN,
                                            pDsSelList->aDsSelection[i].pwzADsPath,
                                            NTPROV_LEN))
            {
                strNT4Name = GetNT4AccountName(pDsSelList->aDsSelection[i].pwzADsPath + NTPROV_LEN);
                if (strNT4Name)
                {
                    Trace((TEXT("Using LSA to lookup SID for %s"), strNT4Name));
                    if (_LookupName(pszServer, strNT4Name, &pSidFree, &sidType))
                    {
                        pSid = pSidFree;
                    }
                }
            }

            if (NULL == pSid)
            {
                cNoSID++;
                continue;
            }
        }
        TraceAssert(NULL != pSid);

        // Is it already in the cache?
        pEntry = FindSid(pSid);
        if (pEntry)
        {
            DPA_AppendPtr(hEntryList, pEntry);
        }
        else
        {
            // Not cached, try to make an entry using the info returned
            // by the object picker.
            if (SidTypeUnknown == sidType)
                sidType = GetSidType(pSid, pDsSelList->aDsSelection[i].pwzClass);

            if (!lstrcmpi(c_szForeignSecurityPrincipal, pDsSelList->aDsSelection[i].pwzClass))
            {
                // Object picker returns non-localized names for these (the
                // DS Configuration Container is not localized). Look up the
                // localized name from LSA.  175278

                // This happens automatically below (pEntry is NULL).
            }
            else if (SidTypeAlias == sidType || SidTypeWellKnownGroup == sidType)
            {
                // Only need the name
                pEntry = MakeEntry(pSid,
                                   sidType,
                                   pDsSelList->aDsSelection[i].pwzName,
                                   NULL);
            }
            else if (pDsSelList->aDsSelection[i].pwzUPN && *pDsSelList->aDsSelection[i].pwzUPN)
            {
                // We have both name and UPN
                pEntry = MakeEntry(pSid,
                                   sidType,
                                   pDsSelList->aDsSelection[i].pwzName,
                                   pDsSelList->aDsSelection[i].pwzUPN);
            }
            else if (CSTR_EQUAL == CompareString(LOCALE_USER_DEFAULT,
                                                 0,
                                                 c_szNTProvider,
                                                 NTPROV_LEN,
                                                 pDsSelList->aDsSelection[i].pwzADsPath,
                                                 NTPROV_LEN))
            {
                // It's downlevel ("WinNT://blah")
                if (NULL == strNT4Name)
                    strNT4Name = GetNT4AccountName(pDsSelList->aDsSelection[i].pwzADsPath + NTPROV_LEN);
                if (strNT4Name)
                {
                    // We have the NT4 name, now look for a Friendly Name
                    BSTR strDisplay = GetNT4DisplayName(strNT4Name,
                                                        pDsSelList->aDsSelection[i].pwzName,
                                                        pszServer,
                                                        bStandalone);
                    pEntry = MakeEntry(pSid,
                                       sidType,
                                       strDisplay ? strDisplay : pDsSelList->aDsSelection[i].pwzName,
                                       strNT4Name);
                    SysFreeString(strDisplay);
                }
            }
            else
            {
                // It's not a downlevel, so it must be
                //   1. WellKnown/Universal (no ADsPath)
                // or
                //   2. Uplevel ("GC:" or "LDAP:") but
                //      has no UPN
                //
                // If it has an ADs path, try to get an
                // NT4 name such as "NTDEV\Domain Users".
                //
                // Note that wellknown things such "Authenticated User"
                // can fall under either 1 or 2 above, depending on what
                // scope it was selected from.  That's why we try to pick
                // them off higher up.
                TraceAssert(NULL == strNT4Name);
                if (pDsSelList->aDsSelection[i].pwzADsPath &&
                    *pDsSelList->aDsSelection[i].pwzADsPath)
                {
                    // DsCrackNames doesn't accept full ADs paths, so use
                    // IADsPathname to retrieve the DN (no provider/server).
                    if (FAILED(hrCom))
                        hrCom = CoInitialize(NULL);
                    if (!pPath)
                    {
                        CoCreateInstance(CLSID_Pathname,
                                         NULL,
                                         CLSCTX_INPROC_SERVER,
                                         IID_IADsPathname,
                                         (LPVOID*)&pPath);
                    }
                    if (pPath)
                    {
                        BSTR strT;
                        if (SUCCEEDED(pPath->Set(pDsSelList->aDsSelection[i].pwzADsPath,
                                                 ADS_SETTYPE_FULL)))
                        {
                            if (SUCCEEDED(pPath->Retrieve(ADS_FORMAT_X500_DN,
                                                          &strT)))
                            {
                                // Try to get an NT4 account name
                                TranslateNameInternal(strT,
                                                      NameFullyQualifiedDN,
                                                      NameSamCompatible,
                                                      &strNT4Name);
                                SysFreeString(strT);
                            }
                            if (!strNT4Name)
                            {
                                // Retrieve or CrackName failed. Try to build
                                // an NT4-style name from the server name.
                                if (SUCCEEDED(pPath->Retrieve(ADS_FORMAT_SERVER,
                                                              &strT)))
                                {
                                    TCHAR szNT4Name[MAX_PATH];
                                    GetDomainName(strT, szNT4Name, ARRAYSIZE(szNT4Name));
                                    PathAppend(szNT4Name, pDsSelList->aDsSelection[i].pwzName);
                                    strNT4Name = SysAllocString(szNT4Name);
                                    SysFreeString(strT);
                                }
                            }
                        }
                    }
                }
                pEntry = MakeEntry(pSid,
                                   sidType,
                                   pDsSelList->aDsSelection[i].pwzName,
                                   strNT4Name);
            }

            //
            // Do we have a cache entry yet?
            //
            if (pEntry)
            {
                if (AddEntry(pEntry))
                {
                    DPA_AppendPtr(hEntryList, pEntry);
                }
                else
                {
                    LocalFree(pEntry);
                    pEntry = NULL;
                }
            }

            if (!pEntry && hSids)
            {
                // Look up the SID the hard way
                Trace((TEXT("Using LSA to lookup %s"), pDsSelList->aDsSelection[i].pwzADsPath));
                PSID pSidCopy = LocalAllocSid(pSid);
                if (pSidCopy)
                {
                    DPA_AppendPtr(hSids, pSidCopy);
                }
            }
        }

        SysFreeString(strNT4Name);

        if (pSidFree)
            LocalFree(pSidFree);
        else
            SafeArrayUnaccessData(V_ARRAY(pvarSid));
    }

    TraceAssert(0 == cNoSID);

    //
    // Call LSA to lookup names for the SIDs that aren't cached yet
    //
    if (hSids && 0 != DPA_GetPtrCount(hSids))
        LookupSidsHelper(hSids, pszServer, hEntryList);

    if (NULL != hSids)
        DestroyDPA(hSids);

    DoRelease(pPath);

    if (SUCCEEDED(hrCom))
        CoUninitialize();

    TraceLeaveValue(TRUE);
}

#endif  // #if(_WIN32_WINNT >= 0x0500)


DWORD WINAPI
CSidCache::InitThread(LPVOID pvThreadData)
{
    PSIDCACHE pThis = (PSIDCACHE)pvThreadData;

    // Our caller already gave us a ref on the dll to prevent the race window where 
    // we are created but we the dll is freed before we can call LoadLibrary()
    // HINSTANCE hInstThisDll = LoadLibrary(c_szDllName);

    TraceEnter(TRACE_SIDCACHE, "CSidCache::InitThread");

    if (pThis)
    {
        // Lookup some well-known SIDs to pre-load the cache
        HDPA hSids;
        hSids = DPA_Create(COUNT_SYSTEM_SID_TYPES);
        if (hSids)
        {
            for (int i = 0; i < COUNT_SYSTEM_SID_TYPES; i++)
            {
                DPA_AppendPtr(hSids, QuerySystemSid((UI_SystemSid)i));
            }

            pThis->LookupSidsHelper(hSids, NULL, NULL, NULL, 0);

            DPA_Destroy(hSids);
        }

        pThis->Release();
    }

    TraceLeave();
    FreeLibraryAndExitThread(GetModuleHandle(c_szDllName), 0);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\perm.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       perm.cpp
//
//  This file contains the implementation for the simple permission
//  editor page.
//
//--------------------------------------------------------------------------

#include "permset.h"
#include "sddl.h"       // ConvertSidToStringSid

#define IDN_CHECKSELECTION  1

void SelectListViewItem(HWND hwndList, int iItem);


//
//  Context Help IDs.
//
const static DWORD aPermPageHelpIDs[] =
{
    IDC_SPP_GROUP_USER_NAME,    IDH_SPP_PRINCIPALS,
    IDC_SPP_PRINCIPALS,         IDH_SPP_PRINCIPALS,
    IDC_SPP_ADD,                IDH_SPP_ADD,
    IDC_SPP_REMOVE,             IDH_SPP_REMOVE,
    IDC_SPP_ACCESS,             IDH_SPP_PERMS,
    IDC_SPP_ACCESS_BIG,         IDH_SPP_PERMS,
    IDC_SPP_ALLOW,              IDH_SPP_PERMS,
    IDC_SPP_DENY,               IDH_SPP_PERMS,
    IDC_SPP_PERMS,              IDH_SPP_PERMS,
    IDC_SPP_STATIC_ADV,         IDH_SPP_ADVANCED,
    IDC_SPP_ADVANCED,           IDH_SPP_ADVANCED,
    IDC_SPP_MORE_MSG,           IDH_NOHELP,
    0, 0,
};


class CPrincipal;
typedef class CPrincipal *LPPRINCIPAL;
class CSecurityInfo;


class CPermPage : public CSecurityPage
{
private:
    SECURITY_DESCRIPTOR_CONTROL m_wSDControl;
    WORD            m_wDaclRevision;
    PSI_ACCESS      m_pDefaultAccess;
    BOOL            m_fPageDirty;
    BOOL            m_fBusy;
    BOOL            m_bWasDenyAcl;
    BOOL            m_bCustomPermission;
    HCURSOR         m_hcurBusy;
    HWND            m_hEffectivePerm;
	DWORD			m_cInheritableAces;

public:
    CPermPage(LPSECURITYINFO psi)
        : CSecurityPage(psi, SI_PAGE_PERM), 
          m_wDaclRevision(ACL_REVISION),
          m_hEffectivePerm(NULL),
		  m_cInheritableAces(0)
          { m_hcurBusy = LoadCursor(NULL, IDC_APPSTARTING); }

private:
    virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL InitDlg(HWND hDlg);
    void InitPrincipalList(HWND hDlg, PACL pDacl);
    HRESULT InitCheckList(HWND hDlg);
    void EnumerateAcl(HWND hwndList, PACL pAcl);
    HRESULT SetPrincipalNamesInList(HWND hwndList, PSID pSid = NULL);

    int AddPrincipalToList(HWND hwndList, LPPRINCIPAL pPrincipal);
    BOOL OnNotify(HWND hDlg, int idCtrl, LPNMHDR pnmh);
    void OnSelChange(HWND hDlg, BOOL bClearFirst = TRUE, BOOL bClearCustomAllow = FALSE, BOOL bClearCustomDeny = FALSE);
    void OnApply(HWND hDlg, BOOL bClose);
    HRESULT BuildDacl(HWND hDlg,
                      PSECURITY_DESCRIPTOR *ppSD,
                      BOOL fIncludeInherited);
    HRESULT SetDacl(HWND hDlg,
                    PSECURITY_DESCRIPTOR psd,
                    BOOL bDirty = FALSE);
    void OnAddPrincipal(HWND hDlg);
    void OnRemovePrincipal(HWND hDlg);
    void OnAdvanced(HWND hDlg);
    void EnablePrincipalControls(HWND hDlg, BOOL fEnable);
    void CommitCurrent(HWND hDlg, int iPrincipal = -1);
    void OnSize(HWND hDlg, DWORD dwSizeType, ULONG nWidth, ULONG nHeight);
    void ClearPermissions(HWND hwndList, BOOL bDisabled = TRUE);
    void SetDirty(HWND hDlg, BOOL bDefault = FALSE);
    void SetEffectivePerm(HWND hwnd){m_hEffectivePerm = hwnd;}
    VOID SetPermLabelText(HWND hDlg);

    friend class CPrincipal;
    friend class CSecurityInfo;
};
typedef class CPermPage *PPERMPAGE;

class CPrincipal
{
private:
    PPERMPAGE       m_pPage;
    LPTSTR          m_pszName;
    LPTSTR          m_pszDisplayName;  //This is only name. Doesn't include Logon Name
    PSID            m_pSID;
    SID_IMAGE_INDEX m_nImageIndex;
    BOOL            m_bHaveRealName;

public:
    CPermissionSet  m_permDeny;
    CPermissionSet  m_permAllow;
    CPermissionSet  m_permInheritedDeny;
    CPermissionSet  m_permInheritedAllow;

    HDSA            m_hAdditionalAllow;
    HDSA            m_hAdditionalDeny;

public:
    CPrincipal(CPermPage *pPage) : m_pPage(pPage), m_nImageIndex(SID_IMAGE_UNKNOWN), 
                                   m_pszDisplayName(NULL)  {}
    ~CPrincipal();

    BOOL    SetPrincipal(PSID pSID,
                         SID_NAME_USE sidType = SidTypeUnknown,
                         LPCTSTR pszName = NULL,
                         LPCTSTR pszLogonName = NULL);
    BOOL    SetName(LPCTSTR pszName, LPCTSTR pszLogonName = NULL);
    void    SetSidType(SID_NAME_USE sidType) { m_nImageIndex = GetSidImageIndex(m_pSID, sidType); }
    PSID    GetSID()  const { return m_pSID; }
    LPCTSTR GetName() const { return m_pszName; }
    LPCTSTR GetDisplayName() const{ return m_pszDisplayName ? m_pszDisplayName : m_pszName; }
    int     GetImageIndex() const { return m_nImageIndex; }

    BOOL    HaveRealName() { return m_bHaveRealName; }

    BOOL    AddAce(PACE_HEADER pAce);
    ULONG   GetAclLength(DWORD dwFlags);
    BOOL    AppendToAcl(PACL pAcl, DWORD dwFlags, PACE_HEADER *ppAcePos);

    BOOL    HaveInheritedAces(void);
    void    ConvertInheritedAces(BOOL bDelete);

    void    AddPermission(BOOL bAllow, PPERMISSION pperm);
    void    RemovePermission(BOOL bAllow, PPERMISSION pperm);

private:
    CPermissionSet* GetPermSet(DWORD dwType, BOOL bInherited);
    BOOL AddNormalAce(DWORD dwType, DWORD dwFlags, ACCESS_MASK mask, const GUID *pObjectType);
    BOOL AddAdvancedAce(DWORD dwType, PACE_HEADER pAce);
};

// flag bits for GetAclLength & AppendToAcl
#define ACL_NONINHERITED    0x00010000L
#define ACL_INHERITED       0x00020000L
#define ACL_DENY            0x00040000L
#define ACL_ALLOW           0x00080000L
#define ACL_CHECK_CREATOR   0x00100000L
#define ACL_NONOBJECT       PS_NONOBJECT
#define ACL_OBJECT          PS_OBJECT


//
// Wrapper for ISecurityInformation.  Used when invoking
// the advanced ACL editor
//
class CSecurityInfo : public ISecurityInformation, ISecurityInformation2, 
                      IEffectivePermission, ISecurityObjectTypeInfo
#if(_WIN32_WINNT >= 0x0500)
    , IDsObjectPicker
#endif
{
private:
    ULONG       m_cRef;
    PPERMPAGE   m_pPage;
    HWND        m_hDlg;

public:
    CSecurityInfo(PPERMPAGE pPage, HWND hDlg)
        : m_cRef(1), m_pPage(pPage), m_hDlg(hDlg) {}

    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // ISecurityInformation methods
    STDMETHODIMP GetObjectInformation(PSI_OBJECT_INFO pObjectInfo);
    STDMETHODIMP GetSecurity(SECURITY_INFORMATION si,
                             PSECURITY_DESCRIPTOR *ppSD,
                             BOOL fDefault);
    STDMETHODIMP SetSecurity(SECURITY_INFORMATION si,
                             PSECURITY_DESCRIPTOR pSD);
    STDMETHODIMP GetAccessRights(const GUID* pguidObjectType,
                                 DWORD dwFlags,
                                 PSI_ACCESS *ppAccess,
                                 ULONG *pcAccesses,
                                 ULONG *piDefaultAccess);
    STDMETHODIMP MapGeneric(const GUID* pguidObjectType,
                            UCHAR *pAceFlags,
                            ACCESS_MASK *pmask);
    STDMETHODIMP GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
                                 ULONG *pcInheritTypes);
    STDMETHODIMP PropertySheetPageCallback(HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage);

    // ISecurityInformation2 methods
    STDMETHODIMP_(BOOL) IsDaclCanonical(PACL pDacl);
    STDMETHODIMP        LookupSids(ULONG cSids, PSID *rgpSids, LPDATAOBJECT *ppdo);

    // IDsObjectPicker methods
#if(_WIN32_WINNT >= 0x0500)
    STDMETHODIMP Initialize(PDSOP_INIT_INFO pInitInfo);
    STDMETHODIMP InvokeDialog(HWND hwndParent, IDataObject **ppdoSelection);
#endif

    STDMETHOD(GetInheritSource)(SECURITY_INFORMATION si,
                                PACL pACL, 
                                PINHERITED_FROM *ppInheritArray);

    STDMETHOD(GetEffectivePermission) (  THIS_ const GUID* pguidObjectType,
                                         PSID pUserSid,
                                         LPCWSTR pszServerName,
                                         PSECURITY_DESCRIPTOR pSD,
                                         POBJECT_TYPE_LIST *ppObjectTypeList,
                                         ULONG *pcObjectTypeListLength,
                                         PACCESS_MASK *ppGrantedAccessList,
                                         ULONG *pcGrantedAccessListLength);


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\permset.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       permset.cpp
//
//  This file contains the implementation for the CPermissionSet class
//
//--------------------------------------------------------------------------

#include "aclpriv.h"
#include "permset.h"


void
CPermissionSet::Reset()
{
    TraceEnter(TRACE_PERMSET, "CPermissionSet::Reset");

    // Clear the lists

    if (m_hPermList != NULL)
    {
        DSA_Destroy(m_hPermList);
        m_hPermList = NULL;
    }

    DestroyDPA(m_hAdvPermList);
    m_hAdvPermList = NULL;

    m_fObjectAcesPresent = FALSE;

    TraceLeaveVoid();
}

void
CPermissionSet::ResetAdvanced()
{
    TraceEnter(TRACE_PERMSET, "CPermissionSet::ResetAdvanced");

    DestroyDPA(m_hAdvPermList);
    m_hAdvPermList = NULL;

    TraceLeaveVoid();
}


BOOL
CPermissionSet::AddAce(LPCGUID pguid, ACCESS_MASK mask, DWORD dwFlags)
{
    PERMISSION perm = { mask, dwFlags, 0 };

    if (pguid != NULL)
        perm.guid = *pguid;

    return AddPermission(&perm);
}


BOOL
CPermissionSet::AddPermission(PPERMISSION pPerm)
{
    BOOL bObjectTypePresent = FALSE;

    TraceEnter(TRACE_PERMSET, "CPermissionSet::AddAce");
    TraceAssert(pPerm != NULL);

    if (!IsEqualGUID(pPerm->guid, GUID_NULL))
        bObjectTypePresent = TRUE;

    if (m_hPermList == NULL)
    {
        m_hPermList = DSA_Create(SIZEOF(PERMISSION), 4);
        if (m_hPermList == NULL)
            TraceLeaveValue(FALSE);
    }
    else
    {
        //
        // Try to merge with an existing entry in the list.
        //
        UINT cItems = DSA_GetItemCount(m_hPermList);
        while (cItems > 0)
        {
            PPERMISSION pPermCompare;
            DWORD dwMergeFlags;
            DWORD dwMergeResult;
            DWORD dwMergeStatus;

            --cItems;
            pPermCompare = (PPERMISSION)DSA_GetItemPtr(m_hPermList, cItems);

            dwMergeFlags = 0;

            if (bObjectTypePresent)
                dwMergeFlags |= MF_OBJECT_TYPE_1_PRESENT;

            if (!IsEqualGUID(pPermCompare->guid, GUID_NULL))
                dwMergeFlags |= MF_OBJECT_TYPE_2_PRESENT;

            if (!(dwMergeFlags & (MF_OBJECT_TYPE_1_PRESENT | MF_OBJECT_TYPE_2_PRESENT)))
            {
                // Neither are present, so they are the same
                dwMergeFlags |= MF_OBJECT_TYPE_EQUAL;
            }
            else if (IsEqualGUID(pPermCompare->guid, pPerm->guid))
                dwMergeFlags |= MF_OBJECT_TYPE_EQUAL;

            dwMergeStatus = MergeAceHelper(pPerm->dwFlags,         // #1
                                           pPerm->mask,
                                           pPermCompare->dwFlags,  // #2
                                           pPermCompare->mask,
                                           dwMergeFlags,
                                           &dwMergeResult);

            if (dwMergeStatus == MERGE_MODIFIED_FLAGS)
            {
                pPerm->dwFlags = dwMergeResult;
                dwMergeStatus = MERGE_OK_1;
            }
            else if (dwMergeStatus == MERGE_MODIFIED_MASK)
            {
                pPerm->mask = dwMergeResult;
                dwMergeStatus = MERGE_OK_1;
            }

            if (dwMergeStatus == MERGE_OK_1)
            {
                //
                // The new permission implies the existing permission, so
                // the existing one can be removed.
                //
                DSA_DeleteItem(m_hPermList, cItems);
                //
                // Keep looking.  Maybe we can remove some more entries
                // before adding the new one.
                //
            }
            else if (dwMergeStatus == MERGE_OK_2)
            {
                //
                // The existing permission implies the new permission, so
                // there is nothing to do here.
                //
                TraceLeaveValue(TRUE);
            }
        }
    }

    // Ok, add the new permission to the list.
    DSA_AppendItem(m_hPermList, pPerm);

    if (bObjectTypePresent)
        m_fObjectAcesPresent = TRUE;

    TraceLeaveValue(TRUE);
}


BOOL
CPermissionSet::AddAdvancedAce(PACE_HEADER pAce)
{
    TraceEnter(TRACE_PERMSET, "CPermissionSet::AddAdvancedAce");
    TraceAssert(pAce != NULL);

    // Create list if necessary
    if (m_hAdvPermList == NULL)
    {
        m_hAdvPermList = DPA_Create(4);
        if (m_hAdvPermList == NULL)
        {
            TraceMsg("DPA_Create failed");
            TraceLeaveValue(FALSE);
        }
    }

    // This is as big as we need, but sometimes incoming ACEs are extra big.
    UINT nAceLen = SIZEOF(KNOWN_OBJECT_ACE) + 2*SIZEOF(GUID) - SIZEOF(DWORD)
        + GetLengthSid(GetAceSid(pAce));

    // Use the incoming AceSize only if it's smaller
    if (pAce->AceSize < nAceLen)
        nAceLen = pAce->AceSize;

    // Copy the ACE and add it to the list.
    PACE_HEADER pAceCopy = (PACE_HEADER)LocalAlloc(LMEM_FIXED, nAceLen);
    if (pAceCopy == NULL)
    {
        TraceMsg("LocalAlloc failed");
        TraceLeaveValue(FALSE);
    }

    CopyMemory(pAceCopy, pAce, nAceLen);
    pAceCopy->AceSize = (USHORT)nAceLen;
    DPA_AppendPtr(m_hAdvPermList, pAceCopy);

    TraceLeaveValue(TRUE);
}


UINT
CPermissionSet::GetPermCount(BOOL fIncludeAdvAces) const
{
    ULONG cAces = 0;

    TraceEnter(TRACE_PERMSET, "CPermissionSet::GetPermCount");

    if (m_hPermList != NULL)
        cAces = DSA_GetItemCount(m_hPermList);

    if (fIncludeAdvAces && m_hAdvPermList != NULL)
        cAces += DPA_GetPtrCount(m_hAdvPermList);

    TraceLeaveValue(cAces);
}


ULONG
CPermissionSet::GetAclLength(ULONG cbSid) const
{
    // Return an estimate of the buffer size needed to hold the
    // requested ACEs. The size of the ACL header is NOT INCLUDED.

    ULONG nAclLength = 0;
    ULONG cAces;
    ULONG nAceSize = SIZEOF(KNOWN_ACE) - SIZEOF(DWORD) + cbSid;
    ULONG nObjectAceSize = SIZEOF(KNOWN_OBJECT_ACE) + SIZEOF(GUID) - SIZEOF(DWORD) + cbSid;

    TraceEnter(TRACE_PERMSET, "CPermissionSet::GetAclLength");

    if (m_hPermList != NULL)
    {
        cAces = DSA_GetItemCount(m_hPermList);
        if (m_fObjectAcesPresent)
            nAclLength += cAces * nObjectAceSize;
        else
            nAclLength += cAces * nAceSize;
    }

    if (m_hAdvPermList != NULL)
    {
        cAces = DPA_GetPtrCount(m_hAdvPermList);
        nAclLength += cAces * (nObjectAceSize + SIZEOF(GUID));
    }

    TraceLeaveValue(nAclLength);
}


BOOL
CPermissionSet::AppendToAcl(PACL pAcl,
                            PACE_HEADER *ppAcePos,  // position to copy first ACE
                            PSID pSid,
                            BOOL fAllowAce,
                            DWORD dwFlags) const
{
    PACE_HEADER pAce;
    UINT cAces;
    DWORD dwSidSize;
    DWORD dwAceSize;
    PPERMISSION pPerm;
    UCHAR uAceType;
    PSID psidT;

    TraceEnter(TRACE_PERMSET, "CPermissionSet::AppendToAcl");
    TraceAssert(pAcl != NULL);
    TraceAssert(ppAcePos != NULL);
    TraceAssert(pSid != NULL);

    if (*ppAcePos == NULL || (ULONG_PTR)*ppAcePos < (ULONG_PTR)FirstAce(pAcl))
        *ppAcePos = (PACE_HEADER)FirstAce(pAcl);

    TraceAssert((ULONG_PTR)*ppAcePos >= (ULONG_PTR)FirstAce(pAcl) &&
                (ULONG_PTR)*ppAcePos <= (ULONG_PTR)ByteOffset(pAcl, pAcl->AclSize));

    dwSidSize = GetLengthSid(pSid);
    dwAceSize = SIZEOF(KNOWN_ACE) - SIZEOF(DWORD) + dwSidSize;
    uAceType = (UCHAR)(fAllowAce ? ACCESS_ALLOWED_ACE_TYPE : ACCESS_DENIED_ACE_TYPE);

    cAces = GetPermCount();
    while (cAces > 0)
    {
        BOOL bObjectAce;

        pPerm = (PPERMISSION)DSA_GetItemPtr(m_hPermList, --cAces);
        if (pPerm == NULL)
            continue;

        bObjectAce = !IsEqualGUID(pPerm->guid, GUID_NULL);

        if (bObjectAce && !(dwFlags & PS_OBJECT))
            continue;
        else if (!bObjectAce && !(dwFlags & PS_NONOBJECT))
            continue;

        pAce = *ppAcePos;

        // Make sure the buffer is large enough.
        if ((ULONG_PTR)ByteOffset(*ppAcePos, dwAceSize) > (ULONG_PTR)ByteOffset(pAcl, pAcl->AclSize))
        {
            TraceMsg("ACL buffer too small");
            TraceAssert(FALSE);
            TraceLeaveValue(FALSE);
        }
        TraceAssert(!IsBadWritePtr(*ppAcePos, dwAceSize));

        // Copy the header and mask
        pAce->AceType = uAceType;
        pAce->AceFlags = (UCHAR)pPerm->dwFlags;
        pAce->AceSize = (USHORT)dwAceSize;
        ((PKNOWN_ACE)pAce)->Mask = pPerm->mask;

        // Get the normal SID location
        psidT = &((PKNOWN_ACE)pAce)->SidStart;

        if (bObjectAce)
        {
            //
            // The Object ACEs that we deal with directly do not have an
            // Inherit GUID present. Those ACEs end up in m_hAdvPermList.
            //
            GUID *pGuid;

            // Adjust AceType and AceSize and set the object Flags
            pAce->AceType += ACCESS_ALLOWED_OBJECT_ACE_TYPE - ACCESS_ALLOWED_ACE_TYPE;
            pAce->AceSize += SIZEOF(KNOWN_OBJECT_ACE) - SIZEOF(KNOWN_ACE) + SIZEOF(GUID);
            ((PKNOWN_OBJECT_ACE)pAce)->Flags = ACE_OBJECT_TYPE_PRESENT;

            // Get the object type guid location
            pGuid = RtlObjectAceObjectType(pAce);

            // We just set the flag for this, so it can't be NULL
            TraceAssert(pGuid);

            // Make sure the buffer is large enough.
            if ((ULONG_PTR)ByteOffset(pAce, pAce->AceSize) > (ULONG_PTR)ByteOffset(pAcl, pAcl->AclSize))
            {
                TraceMsg("ACL buffer too small");
                TraceAssert(FALSE);
                TraceLeaveValue(FALSE);
            }
            TraceAssert(!IsBadWritePtr(pGuid, SIZEOF(GUID)));

            // Copy the object type guid
            *pGuid = pPerm->guid;

            // Get new SID location
            psidT = RtlObjectAceSid(pAce);

            // Adjust ACL revision
            if (pAcl->AclRevision < ACL_REVISION_DS)
                pAcl->AclRevision = ACL_REVISION_DS;
        }

        // Copy the SID
        TraceAssert(!IsBadWritePtr(psidT, dwSidSize));
        CopyMemory(psidT, pSid, dwSidSize);

        // Move to next ACE position
        pAcl->AceCount++;
        *ppAcePos = (PACE_HEADER)NextAce(pAce);
    }

    if ((dwFlags & PS_OBJECT) && m_hAdvPermList != NULL)
    {
        cAces = DPA_GetPtrCount(m_hAdvPermList);
        while (cAces > 0)
        {
            pAce = (PACE_HEADER)DPA_FastGetPtr(m_hAdvPermList, --cAces);
            if (pAce == NULL)
                continue;

            // Make sure the buffer is large enough.
            if ((ULONG_PTR)ByteOffset(*ppAcePos, pAce->AceSize) > (ULONG_PTR)ByteOffset(pAcl, pAcl->AclSize))
            {
                TraceMsg("ACL buffer too small");
                TraceAssert(FALSE);
                TraceLeaveValue(FALSE);
            }
            TraceAssert(!IsBadWritePtr(*ppAcePos, pAce->AceSize));

            // Copy the ACE
            CopyMemory(*ppAcePos, pAce, pAce->AceSize);

            // Adjust ACL revision
            if (IsObjectAceType(pAce) && pAcl->AclRevision < ACL_REVISION_DS)
                pAcl->AclRevision = ACL_REVISION_DS;

            // Move to next ACE position
            pAcl->AceCount++;
            *ppAcePos = (PACE_HEADER)NextAce(*ppAcePos);
        }
    }

    TraceLeaveValue(TRUE);
}


void
CPermissionSet::ConvertInheritedAces(CPermissionSet &permInherited)
{
    UINT cItems;

    TraceEnter(TRACE_PERMSET, "CPermissionSet::ConvertInheritedAces");

    if (permInherited.m_hPermList != NULL)
    {
        PPERMISSION pPerm;

        cItems = DSA_GetItemCount(permInherited.m_hPermList);
        while (cItems)
        {
            --cItems;
            pPerm = (PPERMISSION)DSA_GetItemPtr(permInherited.m_hPermList, cItems);
            if (pPerm != NULL)
            {
                pPerm->dwFlags &= ~INHERITED_ACE;
                AddPermission(pPerm);
            }
        }
    }

    if (permInherited.m_hAdvPermList != NULL)
    {
        PACE_HEADER pAceHeader;

        cItems = DPA_GetPtrCount(permInherited.m_hAdvPermList);
        while (cItems)
        {
            --cItems;
            pAceHeader = (PACE_HEADER)DPA_FastGetPtr(permInherited.m_hAdvPermList, cItems);
            if (pAceHeader != NULL)
            {
                pAceHeader->AceFlags &= ~INHERITED_ACE;
                AddAdvancedAce(pAceHeader);
            }
        }
    }

    permInherited.Reset();

    TraceLeaveVoid();
}

//Removes permission. If bInheritFlag, match inheritance flags before
//removing permission
void
CPermissionSet::RemovePermission(PPERMISSION pPerm, BOOL bInheritFlag )
{
    BOOL bObjectAcePresent = FALSE;

    TraceEnter(TRACE_PERMSET, "CPermissionSet::RemovePermission");
    TraceAssert(pPerm != NULL);

    if (m_hPermList)
    {
        BOOL bNullGuid = IsEqualGUID(pPerm->guid, GUID_NULL);
        UINT cItems = DSA_GetItemCount(m_hPermList);
        while (cItems > 0)
        {
            PPERMISSION pPermCompare;
            BOOL bNullGuidCompare;

            --cItems;
            pPermCompare = (PPERMISSION)DSA_GetItemPtr(m_hPermList, cItems);

            bNullGuidCompare = IsEqualGUID(pPermCompare->guid, GUID_NULL);

            if (bNullGuid || bNullGuidCompare || IsEqualGUID(pPermCompare->guid, pPerm->guid))
            {
                if( !bInheritFlag || ( (pPermCompare->dwFlags & VALID_INHERIT_FLAGS) == (pPerm->dwFlags & VALID_INHERIT_FLAGS) ) )
                {
                    pPermCompare->mask &= ~pPerm->mask;
                    if (0 == pPermCompare->mask)
                        DSA_DeleteItem(m_hPermList, cItems);
                    else if (!bNullGuidCompare)
                        bObjectAcePresent = TRUE;
                }
            }
            else if (!bNullGuidCompare)
                bObjectAcePresent = TRUE;
        }
    }

    m_fObjectAcesPresent = bObjectAcePresent;

    TraceLeaveVoid();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\uuid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       uuid.c
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <objbase.h>
#include <initguid.h>
#include <aclui.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\aclui\version.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       version.h
//
//--------------------------------------------------------------------------

// Resources for the common version chunk

#ifndef APSTUDIO_INVOKED

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Security Descriptor Editor"
#define VER_INTERNALNAME_STR            "aclui.dll"
#define VER_LEGALCOPYRIGHT_YEARS        "1998"
#define VER_ORIGINALFILENAME_STR        "aclui.dll"

#include <ntverp.h>
#include <common.ver>

#endif    // not APSTUDIO_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\common\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pch.h
//
//--------------------------------------------------------------------------

#ifndef _pch_h
#define _pch_h

#include <windows.h>
#include <shlobj.h>

#include <common.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\common\misc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       misc.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <advpub.h>     // REGINSTALL


/*-----------------------------------------------------------------------------
/ DPA_DestroyCallback
/ --------------
/   Same as in newer comctl32, but not present in NT4 SP4.
/
/ In:
/   -
/ Out:
/   
/----------------------------------------------------------------------------*/
#if(_WIN32_WINNT < 0x0500)
#include <comctrlp.h>
void
DPA_DestroyCallback(LPVOID hdpa, _PFNDPAENUMCALLBACK pfnCB, LPVOID pData)
{
    if (!hdpa)
        return;

    if (pfnCB)
    {
        for (int i = 0; i < DPA_GetPtrCount(hdpa); i++)
        {
            if (!pfnCB(DPA_FastGetPtr(hdpa, i), pData))
                break;
        }
    }
    DPA_Destroy((HDPA)hdpa);
}
#endif



/*-----------------------------------------------------------------------------
/ CallRegInstall
/ --------------
/   Called by DllRegisterServer and DllUnregisterServer to register/unregister
/   this module.  Uses the ADVPACK APIs and loads our INF data from resources.
/
/ In:
/   -
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT
CallRegInstall(HMODULE hModule, LPCSTR pszSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack;

    TraceEnter(TRACE_COMMON_MISC, "CallRegInstall");

    hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnRegInstall = (REGINSTALL)GetProcAddress(hinstAdvPack, achREGINSTALL);

        if ( pfnRegInstall )
        {
#ifdef UNICODE
            STRENTRY seReg[] =
            {
                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };

            hr = pfnRegInstall(hModule, pszSection, &stReg);
#else
            hr = pfnRegInstall(hModule, pszSection, NULL);
#endif
        }

        FreeLibrary(hinstAdvPack);
    }

    TraceLeaveResult(hr);
}

// This wrapper function required to make prefast shut up when we are 
// initializing a critical section in a constructor.

void
ExceptionPropagatingInitializeCriticalSection(LPCRITICAL_SECTION critsec)
{
   __try
   {
      ::InitializeCriticalSection(critsec);
   }

   // propagate the exception to our caller.  This will cause Log::Log
   // to abort prematurely, which will jump to the the handler in
   // Log::GetInstance
   
   __except (EXCEPTION_CONTINUE_SEARCH)
   {
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\common\priv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       priv.cpp
//
//  Provides support for enabling/disabling privileges
//
//--------------------------------------------------------------------------

#include "pch.h"


/*******************************************************************

    NAME:       EnablePrivileges

    SYNOPSIS:   Enables the given privileges in the current token

    ENTRY:      pdwPrivileges - list of privileges to enable

    RETURNS:    On success, the previous thread handle (if present) or NULL
                On failure, INVALID_HANDLE_VALUE

    NOTES:      The returned handle should be passed to ReleasePrivileges
                to ensure proper cleanup.  Otherwise, if not NULL or
                INVALID_HANDLE_VALUE it should be closed with CloseHandle.

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/
HANDLE EnablePrivileges(PDWORD pdwPrivileges, ULONG cPrivileges)
{
    BOOL                fResult;
    HANDLE              hToken;
    HANDLE              hOriginalThreadToken;
    PTOKEN_PRIVILEGES   ptp;
    ULONG               nBufferSize;

    if (!pdwPrivileges || !cPrivileges)
        return INVALID_HANDLE_VALUE;

    // Note that TOKEN_PRIVILEGES includes a single LUID_AND_ATTRIBUTES
    nBufferSize = sizeof(TOKEN_PRIVILEGES) + (cPrivileges - 1)*sizeof(LUID_AND_ATTRIBUTES);
    ptp = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, nBufferSize);
    if (!ptp)
        return INVALID_HANDLE_VALUE;

    //
    // Initialize the Privileges Structure
    //
    ptp->PrivilegeCount = cPrivileges;
    for (ULONG i = 0; i < cPrivileges; i++)
    {
        //ptp->Privileges[i].Luid = RtlConvertUlongToLuid(*pdwPrivileges++);
        ptp->Privileges[i].Luid.LowPart = *pdwPrivileges++;
        ptp->Privileges[i].Luid.HighPart = 0;
        ptp->Privileges[i].Attributes = SE_PRIVILEGE_ENABLED;
    }

    //
    // Open the Token
    //
    hToken = hOriginalThreadToken = INVALID_HANDLE_VALUE;
    fResult = OpenThreadToken(GetCurrentThread(), TOKEN_DUPLICATE, FALSE, &hToken);
    if (fResult)
        hOriginalThreadToken = hToken;  // Remember the thread token
    else
        fResult = OpenProcessToken(GetCurrentProcess(), TOKEN_DUPLICATE, &hToken);

    if (fResult)
    {
        HANDLE hNewToken;

        //
        // Duplicate that Token
        //
        fResult = DuplicateTokenEx(hToken,
                                   TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                   NULL,                   // PSECURITY_ATTRIBUTES
                                   SecurityImpersonation,  // SECURITY_IMPERSONATION_LEVEL
                                   TokenImpersonation,     // TokenType
                                   &hNewToken);            // Duplicate token
        if (fResult)
        {
            //
            // Add new privileges
            //
            fResult = AdjustTokenPrivileges(hNewToken,  // TokenHandle
                                            FALSE,      // DisableAllPrivileges
                                            ptp,        // NewState
                                            0,          // BufferLength
                                            NULL,       // PreviousState
                                            NULL);      // ReturnLength
            if (fResult)
            {
                //
                // Begin impersonating with the new token
                //
                fResult = SetThreadToken(NULL, hNewToken);
            }

            CloseHandle(hNewToken);
        }
    }

    // If something failed, don't return a token
    if (!fResult)
        hOriginalThreadToken = INVALID_HANDLE_VALUE;

    // Close the original token if we aren't returning it
    if (hOriginalThreadToken == INVALID_HANDLE_VALUE && hToken != INVALID_HANDLE_VALUE)
        CloseHandle(hToken);

    // If we succeeded, but there was no original thread token,
    // return NULL to indicate we need to do SetThreadToken(NULL, NULL)
    // to release privs.
    if (fResult && hOriginalThreadToken == INVALID_HANDLE_VALUE)
        hOriginalThreadToken = NULL;

    LocalFree(ptp);

    return hOriginalThreadToken;
}


/*******************************************************************

    NAME:       ReleasePrivileges

    SYNOPSIS:   Resets privileges to the state prior to the corresponding
                EnablePrivileges call.

    ENTRY:      hToken - result of call to EnablePrivileges

    RETURNS:    nothing

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/
void ReleasePrivileges(HANDLE hToken)
{
    if (INVALID_HANDLE_VALUE != hToken)
    {
        SetThreadToken(NULL, hToken);
        if (hToken)
            CloseHandle(hToken);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\common\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1989 - 1999

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Created 22-Nov-96 by Jeff Saathoff (jeffreys)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

TARGETNAME= common
TARGETTYPE= LIBRARY
TARGETPATH= obj

# Aclui.dll, rshx32.dll and dssec.dll depend on common.lib
SYNCHRONIZE_BLOCK=1

CONDITIONAL_INCLUDES=$(CONDITIONAL_INCLUDES) \
    shellp.h    \
    shlobjp.h

SOURCES=    ..\debug.cpp     \
            ..\unknown.cpp   \
            ..\strings.cpp   \
            ..\priv.cpp      \
            ..\msgpopup.cpp  \
            ..\misc.cpp      \

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pch.h
PRECOMPILED_PCH=pch.pch
PRECOMPILED_OBJ=pch.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\common\debug.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       debug.cpp
//
//  Provides printf style debug output
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <stdio.h>
#include <comctrlp.h>
#pragma hdrstop


#ifdef DEBUG

DWORD g_dwTraceMask = 0;
DWORD g_tlsDebug = 0xffffffffL;

#define MAX_CALL_DEPTH  64
#define BUFFER_SIZE     2048


class CDebugStack
{
private:
    DWORD m_dwThreadID;
    LONG m_cDepth;
    struct
    {
        BOOL    fTracedYet;
        LPCTSTR pszFunctionName;
        DWORD   dwMask;
    }
    m_CallStack[MAX_CALL_DEPTH];
    TCHAR m_szStringBuffer[BUFFER_SIZE];

public:
    CDebugStack() : m_dwThreadID(GetCurrentThreadId()), m_cDepth(-1)
    { ZeroMemory(&m_CallStack, SIZEOF(m_CallStack)); }

public:
    void _Indent(LONG iDepth, LPCTSTR pszFormat, ...);
    void _vIndent(LONG iDepth, LPCTSTR pszFormat, va_list va);
    BOOL _TraceProlog(LONG iDepth, BOOL fForce);
    void _TraceEnter(DWORD dwMask, LPCTSTR pName);
    void _TraceLeave(void);
    void _Trace(BOOL bForce, LPCTSTR pszFormat, ...);
    void _vTrace(BOOL bForce, LPCTSTR pszFormat, va_list va);
    void _TraceGUID(LPCTSTR pPrefix, REFGUID rGUID);
    void _TraceAssert(int iLine, LPTSTR pFilename);
};
typedef CDebugStack *PDEBUGSTACK;

class CDebugStackHolder
{
private:
    HDPA m_hDebugStackList;
    CRITICAL_SECTION m_csStackList;

public:
    CDebugStackHolder() : m_hDebugStackList(NULL) { ExceptionPropagatingInitializeCriticalSection(&m_csStackList); }
    ~CDebugStackHolder();

public:
    void Add(PDEBUGSTACK pDebugStack);
    void Remove(PDEBUGSTACK pDebugStack);
};
typedef CDebugStackHolder *PDEBUGSTACKHOLDER;

PDEBUGSTACKHOLDER g_pStackHolder = NULL;


/*-----------------------------------------------------------------------------
/ _Indent
/ -------
/   Output to the debug stream indented by n columns.
/
/ In:
/   i = column to indent to.
/   pszFormat -> string to be indented
/
/ Out:
/   -
/----------------------------------------------------------------------------*/

void CDebugStack::_Indent(LONG iDepth, LPCTSTR pszFormat, ...)
{
    va_list va;

    va_start(va, pszFormat);
    _vIndent(iDepth, pszFormat, va);
    va_end(va);
}


void CDebugStack::_vIndent(LONG iDepth, LPCTSTR pszFormat, va_list va)
{
    m_szStringBuffer[0] = TEXT('\0');

    wsprintf(m_szStringBuffer, TEXT("%08x "), m_dwThreadID);

    iDepth = min(iDepth, MAX_CALL_DEPTH - 1);
    for ( ; iDepth > 0 ; iDepth-- )
        lstrcat(m_szStringBuffer, TEXT("  "));

    wvsprintf(m_szStringBuffer + lstrlen(m_szStringBuffer), pszFormat, va);
    lstrcat(m_szStringBuffer, TEXT("\n"));

    OutputDebugString(m_szStringBuffer);
}


/*-----------------------------------------------------------------------------
/ _TraceProlog
/ -------------
/   Handle the prolog to a prefix string, including outputting the
/   function name if we haven't already.
/
/ In:
/   iDepth = depth in the call stack
/   fForce = ignore flags
/
/ Out:
/   BOOL if trace output should be made
/----------------------------------------------------------------------------*/
BOOL CDebugStack::_TraceProlog(LONG iDepth, BOOL fForce)
{
    if ( iDepth < 0 || iDepth >= MAX_CALL_DEPTH )
        return FALSE;

    if  ( (g_dwTraceMask & m_CallStack[iDepth].dwMask) || fForce )
    {
        if ( !m_CallStack[iDepth].fTracedYet )
        {
            if ( iDepth > 0 )
                _TraceProlog(iDepth-1, TRUE);

            _Indent(iDepth, m_CallStack[iDepth].pszFunctionName);
            m_CallStack[iDepth].fTracedYet = TRUE;
        }

        return TRUE;
    }

    return FALSE;
}


/*-----------------------------------------------------------------------------
/ _TraceEnter
/ ------------
/   Set the debugging call stack up to indicate which function we are in.
/
/ In:
/   pName -> function name to be displayed in subsequent trace output.
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void CDebugStack::_TraceEnter(DWORD dwMask, LPCTSTR pName)
{
    m_cDepth++;

    if ( m_cDepth < MAX_CALL_DEPTH )
    {
        if ( !pName )    
            pName = TEXT("<no name>");         // no function name given

        m_CallStack[m_cDepth].fTracedYet = FALSE;
        m_CallStack[m_cDepth].pszFunctionName = pName;
        m_CallStack[m_cDepth].dwMask = dwMask;

        //if ( m_cDepth > 0 )
        //    _TraceProlog(m_cDepth-1, FALSE);
    }
}


/*-----------------------------------------------------------------------------
/ _TraceLeave
/ ------------
/   On exit from a function this will adjust the function stack pointer to 
/   point to our previous function.  If no trace output has been made then 
/   we will output the function name on a single line (to indicate we went somewhere).
/
/ In:
/    -
/ Out:
/   -
/----------------------------------------------------------------------------*/
void CDebugStack::_TraceLeave(void)
{
    //_TraceProlog(m_cDepth, FALSE);

    //if ( !m_cDepth && m_CallStack[0].fTracedYet )
    //    OutputDebugString(TEXT("\n"));
    
    m_cDepth = max(m_cDepth-1, -1);         // account for underflow
}


/*-----------------------------------------------------------------------------
/ _Trace
/ -------
/   Perform printf formatting to the debugging stream.  We indent the output
/   and stream the function name as required to give some indication of 
/   call stack depth.
/
/ In:
/   pszFormat -> printf style formatting string
/   ... = arguments as required for the formatting
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void CDebugStack::_Trace(BOOL bForce, LPCTSTR pszFormat, ...)
{
    va_list va;

    va_start(va, pszFormat);
    _vTrace(bForce, pszFormat, va);
    va_end(va);
}


void CDebugStack::_vTrace(BOOL bForce, LPCTSTR pszFormat, va_list va)
{
    if ( _TraceProlog(m_cDepth, bForce) || bForce )
        _vIndent(m_cDepth+1, pszFormat, va);
}


/*-----------------------------------------------------------------------------
/ _TraceGUID
/ -----------
/   Given a GUID output it into the debug string, first we try and map it
/   to a name (ie. IShellFolder), if that didn't work then we convert it
/   to its human readable form.
/
/ In:
/   pszPrefix -> prefix string
/   lpGuid -> guid to be streamed   
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
#ifdef UNICODE
#define MAP_GUID(x)     &x, TEXT(""L#x)
#else
#define MAP_GUID(x)     &x, TEXT(""#x)
#endif

#define MAP_GUID2(x,y)  MAP_GUID(x), MAP_GUID(y)

const struct 
{
    const GUID* m_pGUID;
    LPCTSTR     m_pName;
}
_guid_map[] = 
{
    MAP_GUID(IID_IUnknown),
    MAP_GUID(IID_IClassFactory),
    MAP_GUID(IID_IDropTarget),
    MAP_GUID(IID_IDataObject),
    MAP_GUID(IID_IPersist),
    MAP_GUID(IID_IOleWindow),

    MAP_GUID2(IID_INewShortcutHookA, IID_INewShortcutHookW),
    MAP_GUID(IID_IShellBrowser),
    MAP_GUID(IID_IShellView),
    MAP_GUID(IID_IContextMenu),
    MAP_GUID(IID_IShellIcon),
    MAP_GUID(IID_IShellFolder),
    MAP_GUID(IID_IShellExtInit),
    MAP_GUID(IID_IShellPropSheetExt),
    MAP_GUID(IID_IPersistFolder),  
    MAP_GUID2(IID_IExtractIconA, IID_IExtractIconW),
    MAP_GUID2(IID_IShellLinkA, IID_IShellLinkW),
    MAP_GUID2(IID_IShellCopyHookA, IID_IShellCopyHookW),
    MAP_GUID2(IID_IFileViewerA, IID_IFileViewerW),
    MAP_GUID(IID_ICommDlgBrowser),
    MAP_GUID(IID_IEnumIDList),
    MAP_GUID(IID_IFileViewerSite),
    MAP_GUID(IID_IContextMenu2),
    MAP_GUID2(IID_IShellExecuteHookA, IID_IShellExecuteHookW),
    MAP_GUID(IID_IPropSheetPage),
    MAP_GUID(IID_IShellView2),
    MAP_GUID(IID_IUniformResourceLocator),
};

void CDebugStack::_TraceGUID(LPCTSTR pPrefix, REFGUID rGUID)
{
    TCHAR szGUID[40];
    LPCTSTR pName = NULL;
    int i;
    
    for ( i = 0 ; i < ARRAYSIZE(_guid_map); i++ )
    {
        if ( IsEqualGUID(rGUID, *_guid_map[i].m_pGUID) )
        {
            pName = _guid_map[i].m_pName;
            break;
        }
    }

    if ( !pName )
    {
// StringFromGUID2 only does UNICODE.  SHStringFromGUID goes both ways,
// but requires shlwapip.h and shlwapi.lib.
#ifndef UNICODE
  #error "_TraceGUID needs fixing"
#endif    
        StringFromGUID2(rGUID, szGUID, ARRAYSIZE(szGUID));
        //SHStringFromGUID(rGUID, szGUID, ARRAYSIZE(szGUID));
        pName = szGUID;
    }

    _Trace(FALSE, TEXT("%s %s"), pPrefix, pName);
}


/*-----------------------------------------------------------------------------
/ _TraceAssert
/ -------------
/   Our assert handler, out faults it the trace mask as enabled assert
/   faulting.
/
/ In:
/   iLine = line 
/   pFilename -> filename of the file we asserted in
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void CDebugStack::_TraceAssert(int iLine, LPTSTR pFilename)
{
    // nb: TRUE --> asserts always displayed
    _Trace(TRUE, TEXT("Assert failed in %s, line %d"), pFilename, iLine);

    if ( g_dwTraceMask & TRACE_COMMON_ASSERT )
        DebugBreak();
}


/*-----------------------------------------------------------------------------
/ ~CDebugStackHolder
/ ------------------
/   Free any DebugStack objects that exist
/
/ In:
/   -
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
int CALLBACK
_DeleteCB(LPVOID pVoid, LPVOID /*pData*/)
{
    PDEBUGSTACK pDebugStack = (PDEBUGSTACK)pVoid;
    if (pDebugStack)
    {
        //pDebugStack->_Trace(TRUE, TEXT("~CDebugStackHolder destroying DebugStack"));
        delete pDebugStack;
    }
    return 1;
}

CDebugStackHolder::~CDebugStackHolder()
{
    EnterCriticalSection(&m_csStackList);

    if (NULL != m_hDebugStackList)
    {
        DPA_DestroyCallback(m_hDebugStackList, _DeleteCB, NULL);
        m_hDebugStackList = NULL;
    }

    LeaveCriticalSection(&m_csStackList);
    DeleteCriticalSection(&m_csStackList);
}


/*-----------------------------------------------------------------------------
/ CDebugStackHolder::Add
/ ----------------------
/   Saves the DebugStack object in a list
/
/ In:
/   PDEBUGSTACK pointer to the thread's debug stack object
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void
CDebugStackHolder::Add(PDEBUGSTACK pDebugStack)
{
    EnterCriticalSection(&m_csStackList);

    if (NULL == m_hDebugStackList)
        m_hDebugStackList = DPA_Create(4);

    if (NULL != m_hDebugStackList)
        DPA_AppendPtr(m_hDebugStackList, pDebugStack);

    LeaveCriticalSection(&m_csStackList);
}


/*-----------------------------------------------------------------------------
/ CDebugStackHolder::Remove
/ -------------------------
/   Removes the DebugStack object from the list
/
/ In:
/   PDEBUGSTACK pointer to the thread's debug stack object
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void
CDebugStackHolder::Remove(PDEBUGSTACK pDebugStack)
{
    EnterCriticalSection(&m_csStackList);

    if (NULL != m_hDebugStackList)
    {
        int iStack = DPA_GetPtrIndex(m_hDebugStackList, pDebugStack);

        if (-1 != iStack)
            DPA_DeletePtr(m_hDebugStackList, iStack);
    }

    LeaveCriticalSection(&m_csStackList);
}


/*-----------------------------------------------------------------------------
/ GetThreadStack
/ --------------
/   Create (if necessary) and return the per-thread debug stack object.
/
/ In:
/   -
/
/ Out:
/   PDEBUGSTACK pointer to the thread's debug stack object
/----------------------------------------------------------------------------*/
PDEBUGSTACK GetThreadStack()
{
    PDEBUGSTACK pDebugStack;

    if (0xffffffffL == g_tlsDebug)
        return NULL;

    pDebugStack = (PDEBUGSTACK)TlsGetValue(g_tlsDebug);

    if (!pDebugStack)
    {
        pDebugStack = new CDebugStack;
        TlsSetValue(g_tlsDebug, pDebugStack);

        if (!g_pStackHolder)
            g_pStackHolder = new CDebugStackHolder;

        if (g_pStackHolder)
            g_pStackHolder->Add(pDebugStack);
    }

    return pDebugStack;
}
    

/*-----------------------------------------------------------------------------
/ DoTraceSetMask
/ --------------
/   Adjust the trace mask to reflect the state given.
/
/ In:
/   dwMask = mask for enabling / disable trace output
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceSetMask(DWORD dwMask)
{
    g_dwTraceMask = dwMask;
}


/*-----------------------------------------------------------------------------
/ DoTraceSetMaskFromRegKey
/ ------------------------
/   Pick up the TraceMask value from the given registry key and
/   set the trace mask using that.
/
/ In:
/   hkRoot = handle of open key
/   pszSubKey = name of subkey to open
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceSetMaskFromRegKey(HKEY hkRoot, LPCTSTR pszSubKey)
{
    HKEY hKey;

    if (ERROR_SUCCESS == RegOpenKey(hkRoot, pszSubKey, &hKey))
    {
        DWORD dwTraceMask = 0;
        DWORD cbTraceMask = SIZEOF(dwTraceMask);

        RegQueryValueEx(hKey,
                        TEXT("TraceMask"),
                        NULL,
                        NULL,
                        (LPBYTE)&dwTraceMask,
                        &cbTraceMask);
        DoTraceSetMask(dwTraceMask);
        RegCloseKey(hKey);
    }
}


/*-----------------------------------------------------------------------------
/ DoTraceSetMaskFromCLSID
/ -----------------------
/   Pick up the TraceMask value from the given CLSID value and
/   set the trace mask using that.
/
/ In:
/   rCLSID = CLSID to query the value from
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceSetMaskFromCLSID(REFCLSID rCLSID)
{
    TCHAR szClsidKey[48] = TEXT("CLSID\\");
    int nLength = lstrlen(szClsidKey);

// StringFromGUID2 only does UNICODE.  SHStringFromGUID goes both ways,
// but requires shlwapip.h and shlwapi.lib.
#ifdef UNICODE
    if (0 == StringFromGUID2(rCLSID, szClsidKey + nLength, ARRAYSIZE(szClsidKey) - nLength))
#else
#error "DoTraceSetMaskFromCLSID needs fixing"
    if (0 == SHStringFromGUID(rCLSID, szClsidKey + nLength, ARRAYSIZE(szClsidKey) - nLength))
#endif    
        return;

    DoTraceSetMaskFromRegKey(HKEY_CLASSES_ROOT, szClsidKey);
}


/*-----------------------------------------------------------------------------
/ DoTraceEnter
/ ------------
/   Set the debugging call stack up to indicate which function we are in.
/
/ In:
/   pName -> function name to be displayed in subsequent trace output.
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceEnter(DWORD dwMask, LPCTSTR pName)
{
    PDEBUGSTACK pDebugStack = GetThreadStack();

    if (pDebugStack)
        pDebugStack->_TraceEnter(dwMask, pName);
}


/*-----------------------------------------------------------------------------
/ DoTraceLeave
/ ------------
/   On exit from a function this will adjust the function stack pointer to 
/   point to our previous function.  If no trace output has been made then 
/   we will output the function name on a single line (to indicate we went somewhere).
/
/ In:
/    -
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceLeave(void)
{
    PDEBUGSTACK pDebugStack = GetThreadStack();

    if (pDebugStack)
        pDebugStack->_TraceLeave();
}


/*-----------------------------------------------------------------------------
/ DoTrace
/ -------
/   Perform printf formatting to the debugging stream.  We indent the output
/   and stream the function name as required to give some indication of 
/   call stack depth.
/
/ In:
/   pszFormat -> printf style formatting string
/   ... = arguments as required for the formatting
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTrace(LPCTSTR pszFormat, ...)
{
    PDEBUGSTACK pDebugStack = GetThreadStack();
    va_list va;

    if (pDebugStack)
    {
        va_start(va, pszFormat);
        pDebugStack->_vTrace(FALSE, pszFormat, va);
        va_end(va);
    }
}


/*-----------------------------------------------------------------------------
/ DoTraceGuid
/ -----------
/   Given a GUID output it into the debug string, first we try and map it
/   to a name (ie. IShellFolder), if that didn't work then we convert it
/   to its human readable form.
/
/ In:
/   pszPrefix -> prefix string
/   lpGuid -> guid to be streamed   
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceGUID(LPCTSTR pPrefix, REFGUID rGUID)
{
    PDEBUGSTACK pDebugStack = GetThreadStack();

    if (pDebugStack)
        pDebugStack->_TraceGUID(pPrefix, rGUID);
}


/*-----------------------------------------------------------------------------
/ DoTraceAssert
/ -------------
/   Our assert handler, out faults it the trace mask as enabled assert
/   faulting.
/
/ In:
/   iLine = line 
/   pFilename -> filename of the file we asserted in
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceAssert(int iLine, LPTSTR pFilename)
{
    PDEBUGSTACK pDebugStack = GetThreadStack();

    if (pDebugStack)
        pDebugStack->_TraceAssert(iLine, pFilename);
}


/*-----------------------------------------------------------------------------
/ DebugThreadDetach
/ DebugProcessAttach
/ DebugProcessDetach
/ -------------
/   These must be called from DllMain
/
/ In:
/   -
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DebugThreadDetach(void)
{
    PDEBUGSTACK pDebugStack;

    if (0xffffffffL == g_tlsDebug)
        return;

    pDebugStack = (PDEBUGSTACK)TlsGetValue(g_tlsDebug);

    if (pDebugStack)
    {
        if (g_pStackHolder)
            g_pStackHolder->Remove(pDebugStack);

        delete pDebugStack;
        TlsSetValue(g_tlsDebug, NULL);
    }
}

void DebugProcessAttach(void)
{
    g_tlsDebug = TlsAlloc();
}

void DebugProcessDetach(void)
{
    DebugThreadDetach();

    if (NULL != g_pStackHolder)
    {
        delete g_pStackHolder;
        g_pStackHolder = NULL;
    }

    if (0xffffffffL != g_tlsDebug)
    {
        TlsFree(g_tlsDebug);
        g_tlsDebug = 0xffffffffL;
    }
}


#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\common\msgpopup.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       msgpopup.cpp
//
//  This file contains MessageBox helper functions.
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop


/*******************************************************************

    NAME:       MsgPopup

    SYNOPSIS:   Displays a message to the user

    ENTRY:      hwnd        - Owner window handle
                pszMsgFmt   - Main message text
                pszTitle    - MessageBox title
                uType       - MessageBox flags
                hInstance   - Module to load strings from.  Only required if
                              pszMsgFmt or pszTitle is a string resource ID.
                Optional format insert parameters.

    EXIT:

    RETURNS:    MessageBox result

    NOTES:      Either of the string parameters may be string resource ID's.

    HISTORY:
        JeffreyS    11-Jun-1997     Created

********************************************************************/

int
WINAPIV
MsgPopup(HWND hwnd,
         LPCTSTR pszMsgFmt,
         LPCTSTR pszTitle,
         UINT uType,
         HINSTANCE hInstance,
         ...)
{
    int nResult;
    LPTSTR szMsg = NULL;
    LPTSTR szTitle = NULL;
    DWORD dwFormatResult;
    va_list args;

    if (pszMsgFmt == NULL)
        return -1;

    //
    // Insert arguments into the format string
    //
    va_start(args, hInstance);
    if (IS_INTRESOURCE(pszMsgFmt))
        dwFormatResult = vFormatStringID(&szMsg, hInstance, (UINT)((ULONG_PTR)pszMsgFmt), &args);
    else
        dwFormatResult = vFormatString(&szMsg, pszMsgFmt, &args);
    va_end(args);

    if (!dwFormatResult)
        return -1;

    //
    // Load the caption if necessary
    //
    if (pszTitle && IS_INTRESOURCE(pszTitle))
    {
        if (LoadStringAlloc(&szTitle, hInstance, (UINT)((ULONG_PTR)pszTitle)))
            pszTitle = szTitle;
        else
            pszTitle = NULL;
    }

    //
    // Display message box
    //
    nResult = MessageBox(hwnd, szMsg, pszTitle, uType);

    LocalFreeString(&szMsg);
    LocalFreeString(&szTitle);

    return nResult;
}


/*******************************************************************

    NAME:       SysMsgPopup

    SYNOPSIS:   Displays a message to the user using a system error
                message as an insert.

    ENTRY:      hwnd        - Owner window handle
                pszMsg      - Main message text
                pszTitle    - MessageBox title
                uType       - MessageBox flags
                hInstance   - Module to load strings from.  Only required if
                              pszMsg or pszTitle is a string resource ID.
                dwErrorID   - System defined error code (Insert 1)
                pszInsert2  - Optional string to be inserted into pszMsg

    EXIT:

    RETURNS:    MessageBox result

    NOTES:      Any of the string parameters may be string resource ID's.

    HISTORY:
        JeffreyS    11-Jun-1997     Created

********************************************************************/

int
WINAPI
SysMsgPopup(HWND hwnd,
            LPCTSTR pszMsg,
            LPCTSTR pszTitle,
            UINT uType,
            HINSTANCE hInstance,
            DWORD dwErrorID,
            LPCTSTR pszInsert2)
{
    int nResult;
    LPTSTR szInsert2 = NULL;
    LPTSTR szErrorText = NULL;

    //
    // Load the 2nd insert string if necessary
    //
    if (pszInsert2 && IS_INTRESOURCE(pszInsert2))
    {
        if (LoadStringAlloc(&szInsert2, hInstance, (UINT)((ULONG_PTR)pszInsert2)))
            pszInsert2 = szInsert2;
        else
            pszInsert2 = NULL;
    }

    //
    // Get the error message string
    //
    if (dwErrorID)
    {
        GetSystemErrorText(&szErrorText, dwErrorID);
    }

    nResult = MsgPopup(hwnd, pszMsg, pszTitle, uType, hInstance, szErrorText, pszInsert2);

    LocalFreeString(&szInsert2);
    LocalFreeString(&szErrorText);

    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\dssec\dll.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dll.cpp
//
//  Core entry points for the DLL
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#define INITGUID
#include <initguid.h>
#include "iids.h"

/*----------------------------------------------------------------------------
/ Globals
/----------------------------------------------------------------------------*/

HINSTANCE g_hInstance = NULL;
HINSTANCE g_hAclEditDll = NULL;
DWORD     g_tls = 0xffffffffL;


/*-----------------------------------------------------------------------------
/ DllMain
/ -------
/   Main entry point.  We are passed reason codes and assored other
/   information when loaded or closed down.
/
/ In:
/   hInstance = our instance handle
/   dwReason = reason code
/   pReserved = depends on the reason code.
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
STDAPI_(BOOL)
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*pReserved*/)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hInstance = hInstance;
        g_tls = TlsAlloc();
        DebugProcessAttach();
        TraceSetMaskFromCLSID(CLSID_DsSecurity);
#ifndef DEBUG
        DisableThreadLibraryCalls(hInstance);
#endif
        break;

    case DLL_PROCESS_DETACH:
        SchemaCache_Destroy();
        if (g_hAclEditDll)
            FreeLibrary(g_hAclEditDll);
        TlsFree(g_tls);
        DebugProcessDetach();
        break;

    case DLL_THREAD_DETACH:
        DebugThreadDetach();
        break;
    }

    return TRUE;
}


/*-----------------------------------------------------------------------------
/ DllCanUnloadNow
/ ---------------
/   Called by the outside world to determine if our DLL can be unloaded. If we
/   have any objects in existance then we must not unload.
/
/ In:
/   -
/ Out:
/   BOOL inidicate unload state.
/----------------------------------------------------------------------------*/
STDAPI
DllCanUnloadNow(void)
{
    return GLOBAL_REFCOUNT ? S_FALSE : S_OK;
}


/*-----------------------------------------------------------------------------
/ DllGetClassObject
/ -----------------
/   Given a class ID and an interface ID, return the relevant object.  This used
/   by the outside world to access the objects contained here in.
/
/ In:
/   rCLISD = class ID required
/   riid = interface within that class required
/   ppv -> receives the newly created object.
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
STDAPI
DllGetClassObject(REFCLSID rCLSID, REFIID riid, LPVOID *ppv)
{
    HRESULT hr;
    CDsSecurityClassFactory *pClassFactory;

    TraceEnter(TRACE_CORE, "DllGetClassObject");
    TraceGUID("Object requested", rCLSID);
    TraceGUID("Interface requested", riid);

    *ppv = NULL;

    if (!IsEqualIID(rCLSID, CLSID_DsSecurity))
        ExitGracefully(hr, CLASS_E_CLASSNOTAVAILABLE, "CLSID not supported");

    pClassFactory = new CDsSecurityClassFactory;

    if (!pClassFactory)
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to create class factory");

    hr = pClassFactory->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pClassFactory;           

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ WaitOnThread
/ -----------------
/   If a thread is running (if the handle is non-NULL) wait for it to complete.
/   Then set the handle to NULL.
/
/ In:
/   phThread = address of thread handle
/
/ Out:
/   Result of WaitForSingleObject, or zero.
/----------------------------------------------------------------------------*/
DWORD
WaitOnThread(HANDLE *phThread)
{
    DWORD dwResult = 0;

    if (phThread != NULL && *phThread != NULL)
    {
        HCURSOR hcurPrevious = SetCursor(LoadCursor(NULL, IDC_WAIT));

        SetThreadPriority(*phThread, THREAD_PRIORITY_HIGHEST);

        dwResult = WaitForSingleObject(*phThread, INFINITE);

        CloseHandle(*phThread);
        *phThread = NULL;

        SetCursor(hcurPrevious);
    }

    return dwResult;
}


/*-----------------------------------------------------------------------------
/ Thread Local Storage helpers
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ ThreadCoInitialize
/ ------------------
/   There is some thread local storage that indicates if we have called
/   CoInitialize.  If CoInitialize has not yet been called, call it now.
/   Otherwise, do nothing.
/
/ In:
/   -
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

HRESULT
ThreadCoInitialize(void)
{
    HRESULT hr = S_OK;

    TraceEnter(TRACE_CORE, "ThreadCoInitialize");

    if (!TlsGetValue(g_tls))
    {
        TraceMsg("Calling CoInitialize");
        hr = CoInitialize(NULL);
        TlsSetValue(g_tls, (LPVOID)SUCCEEDED(hr));
    }

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ ThreadCoUninitialize
/ ------------------
/   There is some thread local storage that indicates if we have called
/   CoInitialize.  If CoInitialize has been called, call CoUninitialize now.
/   Otherwise, do nothing.
/
/ In:
/   -
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

void
ThreadCoUninitialize(void)
{
    TraceEnter(TRACE_CORE, "ThreadCoUninitialize");

    if (TlsGetValue(g_tls))
    {
        TraceMsg("Calling CoUninitialize");
        CoUninitialize();
        TlsSetValue(g_tls, NULL);
    }

    TraceLeaveVoid();
}


//
// Wrappers for delay-loading aclui.dll
//
char const c_szCreateSecurityPage[] = "CreateSecurityPage";
char const c_szEditSecurity[] = "EditSecurity";
typedef HPROPSHEETPAGE (WINAPI *PFN_CREATESECPAGE)(LPSECURITYINFO);
typedef BOOL (WINAPI *PFN_EDITSECURITY)(HWND, LPSECURITYINFO);

HRESULT
_CreateSecurityPage(LPSECURITYINFO pSI, HPROPSHEETPAGE *phPage)
{
    HRESULT hr = E_FAIL;

    if (NULL == g_hAclEditDll)
        g_hAclEditDll = LoadLibrary(c_szAclUI);

    if (g_hAclEditDll)
    {
        static PFN_CREATESECPAGE s_pfnCreateSecPage = NULL;

        if (NULL == s_pfnCreateSecPage)
            s_pfnCreateSecPage = (PFN_CREATESECPAGE)GetProcAddress(g_hAclEditDll, c_szCreateSecurityPage);

        if (s_pfnCreateSecPage)
        {
            hr = S_OK;

            *phPage = (*s_pfnCreateSecPage)(pSI);

            if (NULL == *phPage)
                hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

HRESULT
_EditSecurity(HWND hwndOwner, LPSECURITYINFO pSI)
{
    HRESULT hr = E_FAIL;

    if (NULL == g_hAclEditDll)
        g_hAclEditDll = LoadLibrary(c_szAclUI);

    if (g_hAclEditDll)
    {
        static PFN_EDITSECURITY s_pfnEditSecurity = NULL;

        if (NULL == s_pfnEditSecurity)
            s_pfnEditSecurity = (PFN_EDITSECURITY)GetProcAddress(g_hAclEditDll, c_szEditSecurity);

        if (s_pfnEditSecurity)
        {
            hr = S_OK;
            (*s_pfnEditSecurity)(hwndOwner, pSI);
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\dssec\cstrings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cstrings.cpp
//
//  Constant strings used by this app
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

TCHAR const c_szDllName[]           = TEXT("dssec.dll");
TCHAR const c_szNetApi32[]          = TEXT("NetApi32.dll");
TCHAR const c_szAclUI[]             = TEXT("aclui.dll");
WCHAR const c_szFilterFile[]        = L"dssec.dat";
WCHAR const c_szClassKey[]          = L"@";
WCHAR const c_szGUIDFormat[]        = L"{%s}";
WCHAR const c_szClassFilter[]       = L"(objectClass=classSchema)";
WCHAR const c_szPropertyFilter[]    = L"(objectClass=attributeSchema)";
WCHAR const c_szERFilterFormat[]    = L"(&(objectClass=controlAccessRight)(appliesTo=%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x))";
WCHAR const c_szLDAPDisplayName[]   = L"lDAPDisplayName";
WCHAR const c_szDisplayName[]       = L"displayName";
WCHAR const c_szDisplayID[]         = L"localizationDisplayId";
WCHAR const c_szValidAccesses[]     = L"validAccesses";
WCHAR const c_szSchemaIDGUID[]      = L"schemaIDGUID";
WCHAR const c_szRightsGuid[]        = L"rightsGuid";
WCHAR const c_szSDProperty[]        = L"nTSecurityDescriptor";
WCHAR const c_szSDRightsProp[]      = L"sDRightsEffective";
WCHAR const c_szSchemaContext[]     = L"schemaNamingContext";
WCHAR const c_szConfigContext[]     = L"configurationNamingContext";
WCHAR const c_szERContainer[]       = L"CN=Extended-Rights";
WCHAR const c_szRootDsePath[]       = L"LDAP://rootdse";
WCHAR const c_szPathFormat[]        = L"LDAP://%s";
WCHAR const c_szCNFormat[]          = L"CN=%s";
WCHAR const c_szDefaultSchemaSD[]   = L"defaultSecurityDescriptor";
WCHAR const c_szAttributeSecurityGuid[] = L"attributeSecurityGUID";
WCHAR const c_szObjectClass[] = L"objectclass";
WCHAR const c_szStructuralObjectClass[] = L"structuralobjectclass";
WCHAR const c_szObjectClassCategory[]    = L"objectClassCategory";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\common\unknown.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       unknown.cpp
//
//  Helper functions for handling IUnknown
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ CUnknown
/   Helper functions to aid the implementation of IUnknown within objects,
/   handles not only AddRef and Release, but also QueryInterface.
/----------------------------------------------------------------------------*/

LONG g_cRefCount = 0;          // global reference count

CUnknown::CUnknown()
{
    m_cRefCount = 0;
    InterlockedIncrement(&g_cRefCount);
}

CUnknown::~CUnknown()
{
    TraceAssert( m_cRefCount == 0 );
    InterlockedDecrement(&g_cRefCount);
}


/*-----------------------------------------------------------------------------
/ CUnknown::HandleQueryInterface
/ ------------------------------
/   A table driven implementation of QueryInterface that scans through trying
/   to find a suitable match for the object.
/
/ In:
/   riid = interface being requested
/   ppvObject -> receives a pointer to the object
/   aIntefaces = array of interface descriptions
/   cif = number of interfaces in array
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
STDMETHODIMP CUnknown::HandleQueryInterface(REFIID riid, LPVOID* ppvObject, LPINTERFACES aInterfaces, int cif)
{
    HRESULT hr = S_OK;
    int i;

    TraceAssert(ppvObject);
    TraceAssert(aInterfaces);
    TraceAssert(cif);

    *ppvObject = NULL;          // no interface yet

    for ( i = 0; i != cif; i++ )
    {
        if ( IsEqualIID(riid, *aInterfaces[i].piid) || IsEqualIID(riid, IID_IUnknown) )
        {
            *ppvObject = aInterfaces[i].pvObject;
            goto exit_gracefully;
        }
    }

    hr = E_NOINTERFACE;         // failed.

exit_gracefully:

    if ( SUCCEEDED(hr) )
        ((LPUNKNOWN)*ppvObject)->AddRef();

    return hr;
}


/*-----------------------------------------------------------------------------
/ CUnknown::HandleAddRef
/ ----------------------
/   Increase the objects reference count.  Global reference count increase
/   by the constructor.
/
/ In:
/   -
/ Out:
/   current reference count
/----------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) CUnknown::HandleAddRef()
{
    return InterlockedIncrement(&m_cRefCount);

}


/*-----------------------------------------------------------------------------
/ CUnknown::HandleRelease
/ -----------------------
/   Decrease the reference counts, when the objects reaches zero then 
/   destroy it (which inturn will decrease the global reference count).
/
/ In:
/   -
/ Out:
/   current reference count == 0 if destroyed
/----------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) CUnknown::HandleRelease()
{
    ULONG cRefCount; 

    cRefCount = InterlockedDecrement(&m_cRefCount);
        
    if ( cRefCount )
        return cRefCount;

    delete this;    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\dssec\dssi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dssi.h
//
//--------------------------------------------------------------------------

// Everything here has moved to private\inc\dssec.h
#include <dssec.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\dssec\dll.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dll.h
//
//--------------------------------------------------------------------------

#ifndef __dll_h
#define __dll_h

extern HINSTANCE g_hInstance;
#define GLOBAL_HINSTANCE (g_hInstance)

HRESULT ThreadCoInitialize(void);
void ThreadCoUninitialize(void);
DWORD WaitOnThread(HANDLE *phThread);

HRESULT _CreateSecurityPage(LPSECURITYINFO pSI, HPROPSHEETPAGE *phPage);
HRESULT _EditSecurity(HWND hwndOwner, LPSECURITYINFO pSI);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\dssec\dssi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dssi.cpp
//
//  This file contains the implementation of the CDSSecurityInfo object,
//  which provides the ISecurityInformation interface for invoking
//  the ACL Editor.
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <dssec.h>
#include "exnc.h"
#include "ntsecapi.h"
TCHAR const c_szDomainClass[]       = DOMAIN_CLASS_NAME;    // adsnms.h
#define CLASS_COMPUTER L"computer"

GENERIC_MAPPING g_DSMap =
{
    DS_GENERIC_READ,
    DS_GENERIC_WRITE,
    DS_GENERIC_EXECUTE,
    DS_GENERIC_ALL
};

#define DSSI_LOCAL_NO_CREATE_DELETE     0x00000001

//
//Function Declarations
//
HRESULT
GetDomainSid(LPCWSTR pszServer, PSID *ppSid);

HRESULT
GetRootDomainSid(LPCWSTR pszServer, PSID *ppSid);



//
// CDSSecurityInfo (ISecurityInformation) class definition
//
class CDSSecurityInfo : public ISecurityInformation, 
                               IEffectivePermission,
                               ISecurityObjectTypeInfo, 
                               CUnknown
{
protected:
    GUID        m_guidObjectType;
    BSTR        m_strServerName;
    BSTR        m_strObjectPath;
    BSTR        m_strObjectClass;
    BSTR        m_strDisplayName;
    BSTR        m_strSchemaRootPath;
    AUTHZ_RESOURCE_MANAGER_HANDLE m_ResourceManager;
    //
    //List of Aux Clasess Attached to the object
    //
    HDPA        m_hAuxClasses;  
    IDirectoryObject *m_pDsObject;
    PSECURITY_DESCRIPTOR m_pSD;
    PSID        m_pDomainSid;
	PSID		m_pRootDomainSid;
    PSECURITY_DESCRIPTOR  m_pDefaultSD;
    DWORD       m_dwSIFlags;
    DWORD       m_dwInitFlags;  // DSSI_*
    DWORD       m_dwLocalFlags; //DSSI_LOCAL_*
    HANDLE      m_hInitThread;
    HANDLE      m_hLoadLibWaitEvent;
    volatile BOOL m_bThreadAbort;
    PFNREADOBJECTSECURITY  m_pfnReadSD;
    PFNWRITEOBJECTSECURITY m_pfnWriteSD;
    LPARAM      m_lpReadContext;
    LPARAM      m_lpWriteContext;

    //
    //Access Information
    //
    PACCESS_INFO m_pAIGeneral;        //For First Page and Object Page on Advanced
    PACCESS_INFO m_pAIProperty;       //For Property Page on Advanced
    PACCESS_INFO m_pAIEffective;      //For Effective Page on Advanced
    //
    //Object Type List Info
    //
    POBJECT_TYPE_LIST m_pOTL;
    ULONG m_cCountOTL;

public:
    virtual ~CDSSecurityInfo();

    STDMETHODIMP Init(LPCWSTR pszObjectPath,
                      LPCWSTR pszObjectClass,
                      LPCWSTR pszServer,
                      LPCWSTR pszUserName,
                      LPCWSTR pszPassword,
                      DWORD   dwFlags,
                      PFNREADOBJECTSECURITY  pfnReadSD,
                      PFNWRITEOBJECTSECURITY pfnWriteSD,
                      LPARAM lpContext);

    // IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    // ISecurityInformation
    STDMETHODIMP GetObjectInformation(PSI_OBJECT_INFO pObjectInfo);
    STDMETHODIMP GetSecurity(SECURITY_INFORMATION si,
                             PSECURITY_DESCRIPTOR *ppSD,
                             BOOL fDefault);
    STDMETHODIMP SetSecurity(SECURITY_INFORMATION si,
                             PSECURITY_DESCRIPTOR pSD);
    STDMETHODIMP GetAccessRights(const GUID* pguidObjectType,
                                 DWORD dwFlags,
                                 PSI_ACCESS *ppAccess,
                                 ULONG *pcAccesses,
                                 ULONG *piDefaultAccess);
    STDMETHODIMP MapGeneric(const GUID *pguidObjectType,
                            UCHAR *pAceFlags,
                            ACCESS_MASK *pmask);
    STDMETHODIMP GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
                                 ULONG *pcInheritTypes);
    STDMETHODIMP PropertySheetPageCallback(HWND hwnd,
                                           UINT uMsg,
                                           SI_PAGE_TYPE uPage);

    //IEffectivePermission
    STDMETHODIMP GetEffectivePermission(const GUID* pguidObjectType,
                                        PSID pUserSid,
                                        LPCWSTR pszServerName,
                                        PSECURITY_DESCRIPTOR pSD,
                                        POBJECT_TYPE_LIST *ppObjectTypeList,
                                        ULONG *pcObjectTypeListLength,
                                        PACCESS_MASK *ppGrantedAccessList,
                                        ULONG *pcGrantedAccessListLength);

    //ISecurityObjectTypeInfo
    STDMETHOD(GetInheritSource)(SECURITY_INFORMATION si,
                                PACL pACL, 
                                PINHERITED_FROM *ppInheritArray);



private:
    HRESULT Init2(LPCWSTR pszUserName, LPCWSTR pszPassword);
    HRESULT Init3();
    HRESULT GetAuxClassList();

    DWORD CheckObjectAccess();

    void WaitOnInitThread(void)
        { WaitOnThread(&m_hInitThread); }

    static DWORD WINAPI InitThread(LPVOID pvThreadData);

    static HRESULT WINAPI DSReadObjectSecurity(LPCWSTR pszObjectPath,
                                               SECURITY_INFORMATION si,
                                               PSECURITY_DESCRIPTOR *ppSD,
                                               LPARAM lpContext);

    static HRESULT WINAPI DSWriteObjectSecurity(LPCWSTR pszObjectPath,
                                                SECURITY_INFORMATION si,
                                                PSECURITY_DESCRIPTOR pSD,
                                                LPARAM lpContext);
};


//
// CDSSecurityInfo (ISecurityInformation) implementation
//
CDSSecurityInfo::~CDSSecurityInfo()
{
    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::~CDSSecurityInfo");

    m_bThreadAbort = TRUE;

    if (m_hInitThread != NULL)
    {
        WaitForSingleObject(m_hInitThread, INFINITE);
        CloseHandle(m_hInitThread);
    }

    DoRelease(m_pDsObject);

    SysFreeString(m_strServerName);
    SysFreeString(m_strObjectPath);
    SysFreeString(m_strObjectClass);
    SysFreeString(m_strDisplayName);
    SysFreeString(m_strSchemaRootPath);

    if (m_pSD != NULL)
        LocalFree(m_pSD);

    if( m_pDefaultSD != NULL )
        LocalFree(m_pDefaultSD);

    if(m_pDomainSid)
        LocalFree(m_pDomainSid);

	if(m_pRootDomainSid)
		LocalFree(m_pRootDomainSid);
    
    DestroyDPA(m_hAuxClasses);
    if(m_pAIGeneral && m_pAIGeneral->bLocalFree)
    {
        LocalFree(m_pAIGeneral->pAccess);
        LocalFree(m_pAIGeneral);
    }
    if(m_pAIProperty && m_pAIProperty->bLocalFree)
    {
        LocalFree(m_pAIProperty->pAccess);
        LocalFree(m_pAIProperty);
    }
    if(m_pAIEffective && m_pAIEffective->bLocalFree)
    {
        LocalFree(m_pAIEffective->pAccess);
        LocalFree(m_pAIEffective);
    }        
    if(m_pOTL)
        LocalFree(m_pOTL);

    if(m_ResourceManager)
        AuthzFreeResourceManager(m_ResourceManager);	

    TraceLeaveVoid();
}


//+--------------------------------------------------------------------------
//
//  Function:   DeleteParents
//
//  Synopsis:   Delete the parent of pszClassName from the list.
//              And recursively calls the function to delete the
//              parent of parent of pszClassName from the list.
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------
HRESULT DeleteParents(HDPA hListAux, 
                      LPWSTR pszClassName, 
                      LPWSTR pszSchemaRootPath)
{
    TraceEnter(TRACE_DSSI, "DeleteParents");

    if(!hListAux || !pszSchemaRootPath)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    IADsClass *pDsClass = NULL;
    VARIANT varDerivedFrom;
    int cCount = DPA_GetPtrCount(hListAux);
    
    if(cCount > 1)
    {
        hr = Schema_BindToObject(pszSchemaRootPath,
                                 pszClassName,
                                 IID_IADsClass,
                                 (LPVOID*)&pDsClass);
    
        FailGracefully(hr, "Schema_BindToObject failed");
        //
        //Find out the parent 
        //                           
        hr = pDsClass->get_DerivedFrom(&varDerivedFrom);
        if(hr == E_ADS_PROPERTY_NOT_FOUND)
        {
            //
            //This error will come for TOP which doesn't
            //have any parent
            //
            hr = S_OK;
            goto exit_gracefully;
        }
        FailGracefully(hr, "IADsClass get_DerivedFrom failed");

        LPWSTR pszParent= NULL;
        LPWSTR pszTemp = NULL;
        if( V_VT(&varDerivedFrom) == VT_BSTR)
        {
            pszParent = V_BSTR(&varDerivedFrom);
            int i;
            //
            //Remove all the pszParent entry from the 
            //hListAux
            //
            for(i = 0; i < cCount; ++i)
            {   
                pszTemp = (LPWSTR)DPA_FastGetPtr(hListAux,i);
                if(wcscmp(pszTemp, pszParent) == 0)
                {
                    DPA_DeletePtr(hListAux,i);
                    --cCount;
                    --i;
                }
            }
        }

        VariantClear(&varDerivedFrom);
    }                

exit_gracefully:

    if(pDsClass)
        DoRelease(pDsClass);
    return hr;
}


HRESULT 
CDSSecurityInfo::GetAuxClassList()
{
    TraceEnter(TRACE_DSSI, "GetAuxClassList");

    if(!m_pDsObject || !m_strSchemaRootPath)
    {
        return S_FALSE;
    }

    HRESULT hr = S_OK;
    PADS_ATTR_INFO pAtrrInfoObject = NULL;
    DWORD dwAttrCountObject = 0;
    PADS_ATTR_INFO pAttrInfoStruct = NULL;
    DWORD dwAttrCountStruct= 0;

    HDPA hListAux = NULL;
    HDPA hListCopy = NULL;

    //ObjectClass is list of "class hierarchy of StructuralClass" and "class hierarchy of AuxClass" 
    //for the object.
    //So ObjectClass MINUS StructurcalClass is the list of AuxClass. 
    //This list after subtraction may conatin the inheritance hierarchy. 
    //We only want the mostsignificant classes for the purpose of aclui.

    //
    //Get the ObjectClass Attribute
    //
    LPWSTR pszTemp = (LPWSTR)c_szObjectClass;
    hr = m_pDsObject->GetObjectAttributes(&pszTemp,
                                          1,
                                          &pAtrrInfoObject,
                                          &dwAttrCountObject);
    FailGracefully(hr, "Failed to get ObjectClass Attribute");

    if(!pAtrrInfoObject || !dwAttrCountObject)
        ExitGracefully(hr, S_OK, "Couldn't get ObjectClass, Assume no AuxClass");

    //
    //Get the StructuralObjectClass Attribute
    //
    pszTemp = (LPWSTR)c_szStructuralObjectClass;
    hr = m_pDsObject->GetObjectAttributes(&pszTemp,
                                          1,
                                          &pAttrInfoStruct,
                                          &dwAttrCountStruct);
    FailGracefully(hr, "Failed to get StructuralObjectClass Attribute");

    if(!pAttrInfoStruct || !dwAttrCountStruct)
        ExitGracefully(hr, S_OK, "Couldn't get Structural Object Class Attribute, Assume no Aux Class");

    if(pAtrrInfoObject->dwNumValues == pAttrInfoStruct->dwNumValues)
    {
        Trace((L"No Auxillary Class Attached to this object\n"));
        goto exit_gracefully;
    }

    hListAux = DPA_Create(4);

    UINT i,j;
    BOOL bAuxClass;
    for(i = 0; i < pAtrrInfoObject->dwNumValues; ++i)
    {
        bAuxClass = TRUE;            
        for(j = 0; j < pAttrInfoStruct->dwNumValues; ++j)
        {
            if( wcscmp(pAtrrInfoObject->pADsValues[i].CaseIgnoreString,
                       pAttrInfoStruct->pADsValues[j].CaseExactString) == 0 )
            {
                bAuxClass = FALSE;
                break;
            }
        }
        if(bAuxClass)
        {
            DPA_AppendPtr(hListAux,pAtrrInfoObject->pADsValues[i].CaseExactString);
        }
    }

    UINT cCount;
    cCount = DPA_GetPtrCount(hListAux);

    if(cCount)
    {
        if(cCount > 1)        
        {
            //
            //Make a copy of hListAux
            //
            HDPA hListCopy2 = DPA_Create(cCount);
            for(i = 0; i < cCount; ++i)
                DPA_AppendPtr(hListCopy2,DPA_FastGetPtr(hListAux, i));

            //
            //For each item in hListCopy2 remove its parent from
            //hListAux
            //
            for(i = 0; i < cCount; ++i)
            {
                hr = DeleteParents(hListAux,
                                  (LPWSTR)DPA_FastGetPtr(hListCopy2, i), 
                                  m_strSchemaRootPath);
                FailGracefully(hr, "DeleteParents Failed");
                //
                //if only one item is left we are done.
                //
                if( 1 == DPA_GetPtrCount(hListAux))
                    break;
            }
        }
        
      
        //    
        // What we have left is list of mostsignificant AuxClass[es]
        //
        LPWSTR pszItem;
        cCount = DPA_GetPtrCount(hListAux);
        TraceAssert(cCount);
        if(!m_hAuxClasses)
        {
            m_hAuxClasses = DPA_Create(cCount);
        }
        //
        //Copy AuxClasses into class member
        //
        while(cCount)
        {
            pszItem = (LPWSTR)DPA_FastGetPtr(hListAux,--cCount);
            PAUX_INFO pAI = (PAUX_INFO)LocalAlloc(LPTR,sizeof(AUX_INFO) + StringByteSize(pszItem));
            if(!pAI)
                ExitGracefully(hr, E_OUTOFMEMORY, "Out of memory");
            wcscpy(pAI->pszClassName,pszItem);
            pAI->guid = GUID_NULL;                    

            DPA_AppendPtr(m_hAuxClasses, pAI);
        }
    }            

exit_gracefully:

    if(hListAux)
        DPA_Destroy(hListAux);
    if(hListCopy)
        DPA_Destroy(hListCopy);
    if(pAttrInfoStruct)
        FreeADsMem(pAttrInfoStruct);
    if(pAtrrInfoObject)
        FreeADsMem(pAtrrInfoObject);
    return S_OK;
}       









STDMETHODIMP
CDSSecurityInfo::Init(LPCWSTR pszObjectPath,
                      LPCWSTR pszObjectClass,
                      LPCWSTR pszServer,
                      LPCWSTR pszUserName,
                      LPCWSTR pszPassword,
                      DWORD   dwFlags,
                      PFNREADOBJECTSECURITY  pfnReadSD,
                      PFNWRITEOBJECTSECURITY pfnWriteSD,
                      LPARAM lpContext)
{
    HRESULT hr = S_OK;
    DWORD   dwThreadID;

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::Init");
    TraceAssert(pszObjectPath != NULL);
    TraceAssert(m_strObjectPath == NULL);    // only initialize once

    m_dwInitFlags = dwFlags;

    m_ResourceManager = NULL;	
    m_pfnReadSD = DSReadObjectSecurity;
    m_pfnWriteSD = DSWriteObjectSecurity;
    m_lpReadContext = (LPARAM)this;
    m_lpWriteContext = (LPARAM)this;
    m_hLoadLibWaitEvent = NULL;

    m_hAuxClasses = NULL;  
    m_pAIGeneral = NULL;        //For First Page and Object Page on Advanced
    m_pAIProperty = NULL;       //For Property Page on Advanced
    m_pAIEffective = NULL;      //For Effective Page on Advanced
    m_pOTL = NULL;
    m_cCountOTL = 0;
    m_pDomainSid = NULL;
	m_pRootDomainSid = NULL;

    if (pfnReadSD)
    {
        m_pfnReadSD = pfnReadSD;
        m_lpReadContext = lpContext;
    }

    if (pfnWriteSD)
    {
        m_pfnWriteSD = pfnWriteSD;
        m_lpWriteContext = lpContext;
    }

    m_pDefaultSD = NULL;
    m_pSD = NULL;
    m_strObjectPath = SysAllocString(pszObjectPath);
    if (m_strObjectPath == NULL)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to copy the object path");

    if (pszObjectClass && *pszObjectClass)
        m_strObjectClass = SysAllocString(pszObjectClass);

    if (pszServer)
    {
        // Skip any preceding backslashes
        while (L'\\' == *pszServer)
            pszServer++;

        if (*pszServer)
            m_strServerName = SysAllocString(pszServer);
    }

    // Init2 cracks the path, binds to the object, checks access to
    // the object and gets the schema path.  This used to be done on
    // the other thread below, but is faster now than it used to be.
    //
    // It's preferable to do it here where we can fail and prevent the
    // page from being created if, for example, the user has no access
    // to the object's security descriptor.  This is better than always
    // creating the Security page and having it show a message
    // when initialization fails.
    hr = Init2(pszUserName, pszPassword);
    if (SUCCEEDED(hr))
    {

        //
        //Get the domain sid
        //
        GetDomainSid(m_strServerName, &m_pDomainSid);
		GetRootDomainSid(m_strServerName,&m_pRootDomainSid);

        if( !m_strObjectClass || !m_strSchemaRootPath )
        {
            // We evidently don't have read_property access to the object,
            // so just assume it's not a container, so we don't have to deal
            // with inherit types.
            //
            // We need to struggle on as best as we can. If someone removes
            // all access to an object, this is the only way an admin can
            // restore it.
            //
            m_guidObjectType = GUID_NULL;

            //don't show effective permission tab
            m_dwSIFlags &= (~SI_EDIT_EFFECTIVE);
        }
        else
        {
            //
            //Get the list of Dynamic Auxillary Classes attached to this Object.
            //
            hr = GetAuxClassList();


        }




        //Create event to make sure load library is called by InitThread before
        //function returns
        m_hLoadLibWaitEvent = CreateEvent( NULL,
                                           TRUE,
                                           FALSE,
                                           NULL );
        if( m_hLoadLibWaitEvent != NULL )
        {
            m_hInitThread = CreateThread(NULL,
                                         0,
                                         InitThread,
                                         this,
                                         0,
                                         &dwThreadID);
            
            WaitForSingleObject( m_hLoadLibWaitEvent, INFINITE );
        }
    }




exit_gracefully:
    
    if( m_hLoadLibWaitEvent )
        CloseHandle( m_hLoadLibWaitEvent );
    TraceLeaveResult(hr);
}


char const c_szDsGetDcNameProc[]       = "DsGetDcNameW";
char const c_szNetApiBufferFreeProc[]  = "NetApiBufferFree";
typedef DWORD (WINAPI *PFN_DSGETDCNAME)(LPCWSTR, LPCWSTR, GUID*, LPCWSTR, ULONG, PDOMAIN_CONTROLLER_INFOW*);
typedef DWORD (WINAPI *PFN_NETAPIFREE)(LPVOID);

HRESULT
GetDsDcAddress(BSTR *pbstrDcAddress)
{
    HRESULT hr = E_FAIL;
    HMODULE hNetApi32 = LoadLibrary(c_szNetApi32);
    if (hNetApi32)
    {
        PFN_DSGETDCNAME pfnDsGetDcName = (PFN_DSGETDCNAME)GetProcAddress(hNetApi32, c_szDsGetDcNameProc);
        PFN_NETAPIFREE pfnNetApiFree = (PFN_NETAPIFREE)GetProcAddress(hNetApi32, c_szNetApiBufferFreeProc);

        if (pfnDsGetDcName && pfnNetApiFree)
        {
            PDOMAIN_CONTROLLER_INFOW pDCI;
            DWORD dwErr = (*pfnDsGetDcName)(NULL, NULL, NULL, NULL,
                                            DS_DIRECTORY_SERVICE_REQUIRED | DS_IP_REQUIRED,
                                            &pDCI);
            hr = HRESULT_FROM_WIN32(dwErr);
            if (SUCCEEDED(hr))
            {
                LPCWSTR pszAddress = pDCI->DomainControllerAddress;
                // Skip any preceding backslashes
                while (L'\\' == *pszAddress)
                    pszAddress++;
                *pbstrDcAddress = SysAllocString(pszAddress);
                if (NULL == *pbstrDcAddress)
                    hr = E_OUTOFMEMORY;
                (*pfnNetApiFree)(pDCI);
            }
        }
        FreeLibrary(hNetApi32);
    }
    return hr;
}

HRESULT
CDSSecurityInfo::Init2(LPCWSTR pszUserName, LPCWSTR pszPassword)
{
    HRESULT hr = S_OK;
    DWORD dwAccessGranted;
    PADS_OBJECT_INFO pObjectInfo = NULL;
    IADsPathname *pPath = NULL;
    LPWSTR pszTemp;
    DWORD dwPrivs[] = { SE_SECURITY_PRIVILEGE, SE_TAKE_OWNERSHIP_PRIVILEGE };
    HANDLE hToken = INVALID_HANDLE_VALUE;
    PADS_ATTR_INFO pAttributeInfo = NULL;
    DWORD dwAttributesReturned;

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::Init2");
    TraceAssert(m_strObjectPath != NULL);
    TraceAssert(m_pDsObject == NULL);  // only do this one time

    //
    // Create an ADsPathname object to parse the path and get the
    // leaf name (for display) and server name (if necessary)
    //
    hr = CoCreateInstance(CLSID_Pathname,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IADsPathname,
                          (LPVOID*)&pPath);
    if (pPath)
    {
        if (FAILED(pPath->Set(m_strObjectPath, ADS_SETTYPE_FULL)))
            DoRelease(pPath); // sets pPath to NULL
    }

    if (NULL == m_strServerName)
    {
        // The path may or may not specify a server.  If not, call DsGetDcName
        if (pPath)
            hr = pPath->Retrieve(ADS_FORMAT_SERVER, &m_strServerName);
        if (!pPath || FAILED(hr))
            hr = GetDsDcAddress(&m_strServerName);
        FailGracefully(hr, "Unable to get server name");
    }
    Trace((TEXT("Server \"%s\""), m_strServerName));

    // Enable privileges before binding so CheckObjectAccess
    // and DSRead/WriteObjectSecurity work correctly.
    hToken = EnablePrivileges(dwPrivs, ARRAYSIZE(dwPrivs));

    // Bind to the object and get the schema path, etc.
    Trace((TEXT("Calling OpenDSObject(%s)"), m_strObjectPath));
    hr = OpenDSObject(m_strObjectPath,
                       (LPWSTR)pszUserName,
                       (LPWSTR)pszPassword,
                       ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND,
                       IID_IDirectoryObject,
                       (LPVOID*)&m_pDsObject);
    FailGracefully(hr, "Failed to get the DS object");

    // Assume certain access by default
    if (m_dwInitFlags & DSSI_READ_ONLY)
        dwAccessGranted = READ_CONTROL;
    else
        dwAccessGranted = READ_CONTROL | WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY;

    if (!(m_dwInitFlags & DSSI_NO_ACCESS_CHECK))
    {
        // Check whether the user has permission to do anything to
        // the security descriptor on this object.
        dwAccessGranted = CheckObjectAccess();
        Trace((TEXT("AccessGranted = 0x%08x"), dwAccessGranted));

        if (!(dwAccessGranted & (READ_CONTROL | WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY | SI_MAY_WRITE)))
            ExitGracefully(hr, E_ACCESSDENIED, "No access");
    }

    // Translate the access into SI_* flags, starting with this:
    m_dwSIFlags = SI_EDIT_ALL | SI_ADVANCED | SI_EDIT_PROPERTIES | SI_SERVER_IS_DC |SI_EDIT_EFFECTIVE;

    if (!(dwAccessGranted & WRITE_DAC))
    {
        if( !(dwAccessGranted & SI_MAY_WRITE) )
            m_dwSIFlags |= SI_READONLY;
        else
            m_dwSIFlags |= SI_MAY_WRITE;
    }

    if (!(dwAccessGranted & WRITE_OWNER))
    {
        if (!(dwAccessGranted & READ_CONTROL))
            m_dwSIFlags &= ~SI_EDIT_OWNER;
        else
            m_dwSIFlags |= SI_OWNER_READONLY;
    }

    if (!(dwAccessGranted & ACCESS_SYSTEM_SECURITY) || (m_dwInitFlags & DSSI_NO_EDIT_SACL))
        m_dwSIFlags &= ~SI_EDIT_AUDITS;

    if (m_dwInitFlags & DSSI_NO_EDIT_OWNER)
        m_dwSIFlags &= ~SI_EDIT_OWNER;


    // Get the class name and schema path
    m_pDsObject->GetObjectInformation(&pObjectInfo);
    if (pObjectInfo)
    {
        //
        // Note that m_strObjectClass, if provided, can be different
        // than pObjectInfo->pszClassName.  This is true when editing default
        // ACLs on schema class objects, for example, in which case
        // pObjectInfo->pszClassName will be "attributeSchema" but m_strObjectClass
        // will be something else such as "computer" or "user". Be
        // careful to only use pObjectInfo->pszClassName for getting the path of
        // the schema root, and use m_strObjectClass for everything else.
        //
        // If m_strObjectClass is not provided, use pObjectInfo->pszClassName.
        //
        if (m_strObjectClass == NULL)
            m_strObjectClass = SysAllocString(pObjectInfo->pszClassName);

        // If this is a root object (i.e. domain), hide the ACL protect checkbox
        // Note that there is more than one form of "domain", e.g. "domainDNS"
        // so look for anything that starts with "domain".
        // If this is a root object (i.e. domain), hide the ACL protect checkbox
        if ((m_dwInitFlags & DSSI_IS_ROOT)
            || (m_strObjectClass &&
                CSTR_EQUAL == CompareString(LOCALE_SYSTEM_DEFAULT,
                                            NORM_IGNORECASE,
                                            m_strObjectClass,
                                            ARRAYSIZE(c_szDomainClass) - 1,
                                            c_szDomainClass,
                                            ARRAYSIZE(c_szDomainClass) - 1)))
        {
            m_dwSIFlags |= SI_NO_ACL_PROTECT;
        }

        // Get the the path of the schema root
        int nClassLen;
        nClassLen = lstrlenW(pObjectInfo->pszClassName);
        pszTemp = pObjectInfo->pszSchemaDN + lstrlenW(pObjectInfo->pszSchemaDN) - nClassLen;
        if (CSTR_EQUAL == CompareString(LOCALE_SYSTEM_DEFAULT,
                                        NORM_IGNORECASE,
                                        pszTemp,
                                        nClassLen,
                                        pObjectInfo->pszClassName,
                                        nClassLen))
        {
            *pszTemp = L'\0';
        }

        // Save the schema root path
        m_strSchemaRootPath = SysAllocString(pObjectInfo->pszSchemaDN);

    }

    //For computer objects only use CN as display name doesn't get updated
    //when name of computer is changed which results in displaying old name.
    //see bug 104186	
    if(!m_strObjectClass || lstrcmpi(m_strObjectClass,CLASS_COMPUTER))
    {
        //
        // Get the displayName property
        //
        pszTemp = (LPWSTR)c_szDisplayName;
        m_pDsObject->GetObjectAttributes(&pszTemp,
                                         1,
                                         &pAttributeInfo,
                                         &dwAttributesReturned);
        if (pAttributeInfo)
        {
            m_strDisplayName = SysAllocString(pAttributeInfo->pADsValues->CaseExactString);
            FreeADsMem(pAttributeInfo);
            pAttributeInfo = NULL;
        }
    }

    // If that failed, try the leaf name.
    if (!m_strDisplayName && pPath)
    {
        // Retrieve the display name
        pPath->SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
        pPath->Retrieve(ADS_FORMAT_LEAF, &m_strDisplayName);
        pPath->SetDisplayType(ADS_DISPLAY_FULL);
    }
    
    // If we still don't have a display name, just copy the RDN.
    // Ugly, but better than nothing.    
    if (!m_strDisplayName && pObjectInfo)
        m_strDisplayName = SysAllocString(pObjectInfo->pszRDN);


exit_gracefully:

    if (pObjectInfo)
        FreeADsMem(pObjectInfo);

    DoRelease(pPath);
    ReleasePrivileges(hToken);

    TraceLeaveResult(hr);
}


HRESULT
CDSSecurityInfo::Init3()
{
    HRESULT hr = S_OK;
    IADsClass *pDsClass = NULL;
    VARIANT var = {0};

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::Init3");
    TraceAssert(m_strSchemaRootPath != NULL);
    TraceAssert(m_strObjectClass != NULL);

    if (m_bThreadAbort)
        goto exit_gracefully;

    // Create the schema cache
    // Sandwich this SchemaCache_Create call with refcounting. In the event that
    // the threads created therein take a long time to return, this allows the
    // release on the CDSSecurityInfo object in the invoking application to simply
    // return instead of waiting potentially a very long time for the schema cache
    // creation threads to complete.  This is because the last release on the 
    // CDSSecurityInfo calls its destructor (duh!) and the destructor waits on the
    // threads.
    AddRef ();  
    hr = SchemaCache_Create(m_strServerName);
    Release();
    FailGracefully(hr, "Unable to create schema cache");

    if( m_strSchemaRootPath && m_strObjectClass )
    {

        // Bind to the schema class object
        hr = Schema_BindToObject(m_strSchemaRootPath,
                                 m_strObjectClass,
                                 IID_IADsClass,
                                 (LPVOID*)&pDsClass);
        FailGracefully(hr, "Failed to get the Schema class object");

        // Get the class GUID
        Schema_GetObjectID(pDsClass, &m_guidObjectType);

        if (m_bThreadAbort)
            goto exit_gracefully;

        // See if this object is a container, by getting the list of possible
        // child classes.  If this fails, treat it as a non-container.
        pDsClass->get_Containment(&var);
     
        //set m_dwLocalFlags to DSSI_LOCAL_NO_CREATE_DELETE if object is not 
        // a container. If this flag is set, CREATE_DELETE permission which are
        // inherited from parents but meaning less for leaf object will not be shown.
        // In most cases presence of this flag is same as absence of SI_CONTAINER in m_dwSIFlags,
        // however in some cases its not possible to determine if the object is container or not.
        // there object is treated as non-container but we still must show all the aces.
     
        if (V_VT(&var) == (VT_ARRAY | VT_VARIANT))
        {
            LPSAFEARRAY psa = V_ARRAY(&var);

            TraceAssert(psa && psa->cDims == 1);

            if (psa->rgsabound[0].cElements > 0)
            {
                m_dwSIFlags |= SI_CONTAINER;
            }
            else
                m_dwLocalFlags |= DSSI_LOCAL_NO_CREATE_DELETE;
        }
        else if (V_VT(&var) == VT_BSTR) // single entry
        {
            TraceAssert(V_BSTR(&var));
            m_dwSIFlags |= SI_CONTAINER;
        }
        else
            m_dwLocalFlags |= DSSI_LOCAL_NO_CREATE_DELETE;

        if( !IsEqualGUID( m_guidObjectType, GUID_NULL ) )
        {
            hr = Schema_GetDefaultSD( &m_guidObjectType, m_pDomainSid, m_pRootDomainSid, &m_pDefaultSD );
            FailGracefully(hr, "Failed to get the Schema class object");
            
            m_dwSIFlags |= SI_RESET_DACL;
        }

    }
exit_gracefully:

    VariantClear(&var);
    DoRelease(pDsClass);

    TraceLeaveResult(hr);
}


///////////////////////////////////////////////////////////
//
// IUnknown methods
//
///////////////////////////////////////////////////////////

#undef CLASS_NAME
#define CLASS_NAME CDSSecurityInfo
#include "unknown.inc"

STDMETHODIMP
CDSSecurityInfo::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    INTERFACES iface[] =
    {
        &IID_ISecurityInformation, static_cast<LPSECURITYINFO>(this),
        &IID_IEffectivePermission, static_cast<LPEFFECTIVEPERMISSION>(this),
        &IID_ISecurityObjectTypeInfo, static_cast<LPSecurityObjectTypeInfo>(this),
    };

    return HandleQueryInterface(riid, ppv, iface, ARRAYSIZE(iface));
}


///////////////////////////////////////////////////////////
//
// ISecurityInformation methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP
CDSSecurityInfo::GetObjectInformation(PSI_OBJECT_INFO pObjectInfo)
{
    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::GetObjectInformation");
    TraceAssert(pObjectInfo != NULL &&
                !IsBadWritePtr(pObjectInfo, SIZEOF(*pObjectInfo)));

    pObjectInfo->hInstance = GLOBAL_HINSTANCE;
    pObjectInfo->dwFlags = m_dwSIFlags ;
    pObjectInfo->pszServerName = m_strServerName;
    pObjectInfo->pszObjectName = m_strDisplayName ? m_strDisplayName : m_strObjectPath;

    if (!IsEqualGUID(m_guidObjectType, GUID_NULL))
    {
        pObjectInfo->dwFlags |= SI_OBJECT_GUID;
        pObjectInfo->guidObjectType = m_guidObjectType;
    }

    TraceLeaveResult(S_OK);
}

//IF object is leaf object which cannot have create/detele object
//permissions, this function removes those aces from SD, so that 
//they are not displayed. It only removes inherited aces, if ace is 
//explicit, it better get displayed so that user can remove it.
//This is done to fix bug 14793

DWORD
RemoveRedundantPermissions( PSECURITY_DESCRIPTOR *ppSD, GUID *pGuidObjectType )

{

    PACL pAcl = NULL;
    PACE_HEADER pAce= NULL;
    UINT cAces = 0;
    BOOL *pBoolArray = NULL;
    TraceEnter(TRACE_DSSI, "RemoveRedundantPermissions");

    if ( NULL == ppSD || NULL == *ppSD )
        TraceLeaveResult(ERROR_SUCCESS);   // Nothing to do

    BOOL bDefaulted;
    BOOL bPresent;
    GetSecurityDescriptorDacl(*ppSD, &bPresent, &pAcl, &bDefaulted);

    if (NULL != pAcl)
    {
        if(pAcl->AceCount)
        {
            //pBoolArray is initialzied to FALSE
            pBoolArray = (PBOOL)LocalAlloc(LPTR,sizeof(BOOL)*pAcl->AceCount);
            if(!pBoolArray)
                return ERROR_NOT_ENOUGH_MEMORY;
        }            

        for (cAces = 0, pAce = (PACE_HEADER)FirstAce(pAcl);
             cAces < pAcl->AceCount;
             ++cAces, pAce = (PACE_HEADER)NextAce(pAce))
        {
            if( pAce->AceFlags & INHERITED_ACE )
            {
            //If Only Create Child/Delete Child don't show it
                if((((ACCESS_ALLOWED_ACE*)pAce)->Mask & (~(ACTRL_DS_CREATE_CHILD |ACTRL_DS_DELETE_CHILD))) == 0 )
                {
                    pBoolArray[cAces] = TRUE;
                    continue;
                }
                //If the ace is inherited and inherit only and inherited object type
                //is not same as this object type bug 22559
                if( (((ACCESS_ALLOWED_ACE*)pAce)->Header.AceFlags & INHERIT_ONLY_ACE )
                    && IsObjectAceType(pAce) )
                {
                    GUID *pGuid = RtlObjectAceInheritedObjectType(pAce);
                    if(pGuid && pGuidObjectType && !IsEqualGUID(*pGuid,*pGuidObjectType))
                    {
                        pBoolArray[cAces] = TRUE;
                        continue;
                    }
                }
            }
        }
        //Now Delete the Aces
        UINT cAceCount = pAcl->AceCount;
        UINT cAdjust = 0;
        for( cAces = 0; cAces < cAceCount; ++cAces)
        {
            if(pBoolArray[cAces])
            {
                DeleteAce(pAcl, cAces - cAdjust);
                cAdjust++;
            }
        }
        LocalFree(pBoolArray);
    }
    TraceLeaveResult(ERROR_SUCCESS);
}


STDMETHODIMP
CDSSecurityInfo::GetSecurity(SECURITY_INFORMATION si,
                             PSECURITY_DESCRIPTOR *ppSD,
                             BOOL fDefault)
{
    HRESULT hr = S_OK;

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::GetSecurity");
    TraceAssert(si != 0);
    TraceAssert(ppSD != NULL);

    *ppSD = NULL;

    
    if (fDefault)
    {
        if( m_pDefaultSD )
        {
            ULONG nLength = GetSecurityDescriptorLength(m_pDefaultSD);
            *ppSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, nLength);
            if (*ppSD != NULL)
                CopyMemory(*ppSD, m_pDefaultSD, nLength);
            else
                hr = E_OUTOFMEMORY;   
        }
        else
            hr = E_NOTIMPL;
    }
    else if (!(si & SACL_SECURITY_INFORMATION) && m_pSD != NULL)
    {
        ULONG nLength = GetSecurityDescriptorLength(m_pSD);

        *ppSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, nLength);
        if (*ppSD != NULL)
            CopyMemory(*ppSD, m_pSD, nLength);
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        TraceAssert(m_strObjectPath != NULL);
        TraceAssert(m_pfnReadSD != NULL)
        hr = (*m_pfnReadSD)(m_strObjectPath, si, ppSD, m_lpReadContext);
    }

    if( si & DACL_SECURITY_INFORMATION && (m_dwLocalFlags & DSSI_LOCAL_NO_CREATE_DELETE ) )
        RemoveRedundantPermissions(ppSD, &m_guidObjectType);        

    TraceLeaveResult(hr);
}


STDMETHODIMP
CDSSecurityInfo::SetSecurity(SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = S_OK;

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::SetSecurity");
    TraceAssert(si != 0);
    TraceAssert(pSD != NULL);

    TraceAssert(m_strObjectPath != NULL);
    TraceAssert(m_pfnWriteSD != NULL)
    hr = (*m_pfnWriteSD)(m_strObjectPath, si, pSD, m_lpWriteContext);

    if (SUCCEEDED(hr) && m_pSD != NULL && (si != SACL_SECURITY_INFORMATION))
    {
        // The initial security descriptor is no longer valid.
        LocalFree(m_pSD);
        m_pSD = NULL;
    }

    TraceLeaveResult(hr);
}


STDMETHODIMP
CDSSecurityInfo::GetAccessRights(const GUID* pguidObjectType,
                                 DWORD dwFlags,
                                 PSI_ACCESS *ppAccesses,
                                 ULONG *pcAccesses,
                                 ULONG *piDefaultAccess)
{
    HRESULT hr = S_OK;
    LPCTSTR pszClassName = NULL;

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::GetAccessRights");
    TraceAssert(ppAccesses != NULL);
    TraceAssert(pcAccesses != NULL);
    TraceAssert(piDefaultAccess != NULL);

    *ppAccesses = NULL;
    *pcAccesses = 0;
    *piDefaultAccess = 0;

    WaitOnInitThread();

    //
    //If we are getting the access rights for GUID which is selected in the
    //Apply onto combobox of permission page, we don't need to worry about
    //aux class. Only get the permission for the object type
    //
    BOOL bInheritGuid = TRUE;

    if (pguidObjectType == NULL || IsEqualGUID(*pguidObjectType, GUID_NULL))
    {
        bInheritGuid = FALSE;
        pguidObjectType = &m_guidObjectType;
        pszClassName = m_strObjectClass;
    }

    if (m_dwInitFlags & DSSI_NO_FILTER)
        dwFlags |= SCHEMA_NO_FILTER;

    // No schema path means we don't have read_property access to the object.
    // This limits what we can do.
    if (NULL == m_strSchemaRootPath)
        dwFlags |= SCHEMA_COMMON_PERM;

    PACCESS_INFO *ppAI = NULL;
    PACCESS_INFO pAI = NULL;
    if(!bInheritGuid)
    {
        if(dwFlags & SI_EDIT_PROPERTIES)
            ppAI = &m_pAIProperty;
        else if(dwFlags & SI_EDIT_EFFECTIVE)
            ppAI = &m_pAIEffective;    
        else
            ppAI = &m_pAIGeneral;
    }
    else
    {
        ppAI = &pAI;
    }

    if(!*ppAI)
    {
        hr = SchemaCache_GetAccessRights(pguidObjectType,
                                         pszClassName,
                                         !bInheritGuid ? m_hAuxClasses : NULL,
                                         m_strSchemaRootPath,
                                         dwFlags,
                                         ppAI);
        if(FAILED(hr))
        {
            return hr;
        }
    }

    if(*ppAI)
    {
        *ppAccesses = (*ppAI)->pAccess;
        *pcAccesses = (*ppAI)->cAccesses;
        *piDefaultAccess = (*ppAI)->iDefaultAccess;
    }
    
    TraceLeaveResult(hr);
}


STDMETHODIMP
CDSSecurityInfo::MapGeneric(const GUID* /*pguidObjectType*/,
                            UCHAR *pAceFlags,
                            ACCESS_MASK *pmask)
{
    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::MapGeneric");
    TraceAssert(pAceFlags != NULL);
    TraceAssert(pmask != NULL);

    // Only CONTAINER_INHERIT_ACE has meaning for DS
    *pAceFlags &= ~OBJECT_INHERIT_ACE;

    MapGenericMask(pmask, &g_DSMap);

    // We don't expose SYNCHRONIZE, so don't pass it through
    // to the UI.  192389
    *pmask &= ~SYNCHRONIZE;

    TraceLeaveResult(S_OK);
}


STDMETHODIMP
CDSSecurityInfo::GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
                                 ULONG *pcInheritTypes)
{
    HRESULT hr;
    DWORD dwFlags = 0;

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::GetInheritTypes");

    if (m_dwInitFlags & DSSI_NO_FILTER)
        dwFlags |= SCHEMA_NO_FILTER;

    hr = SchemaCache_GetInheritTypes(&m_guidObjectType, dwFlags, ppInheritTypes, pcInheritTypes);

    TraceLeaveResult(hr);
}


STDMETHODIMP
CDSSecurityInfo::PropertySheetPageCallback(HWND hwnd,
                                           UINT uMsg,
                                           SI_PAGE_TYPE uPage)
{
    if (PSPCB_SI_INITDIALOG == uMsg && uPage == SI_PAGE_PERM)
    {
        WaitOnInitThread();
    

        //
        // HACK ALERT!!!
        //
        // Exchange Platinum is required to hide membership of some groups
        // (distribution lists) for legal reasons. The only way they found
        // to do this is with non-canonical ACLs which look roughly like
        //   Allow Admins access
        //   Deny Everyone access
        //   <normal ACL>
        //
        // Since ACLUI always generates ACLs in NT Canonical Order, we can't
        // allow these funky ACLs to be modified. If we did, the DL's would
        // either become visible or Admins would get locked out.
        //
        if (!(SI_READONLY & m_dwSIFlags))
        {
            DWORD dwAclType = IsSpecificNonCanonicalSD(m_pSD);
            if (ENC_RESULT_NOT_PRESENT != dwAclType)
            {
                // It's a funky ACL so don't allow changes
                m_dwSIFlags |= SI_READONLY;

                // Tell the user what's going on
                MsgPopup(hwnd,
                         MAKEINTRESOURCE(IDS_SPECIAL_ACL_WARNING),
                         MAKEINTRESOURCE(IDS_SPECIAL_SECURITY_TITLE),
                         MB_OK | MB_ICONWARNING | MB_SETFOREGROUND,
                         g_hInstance,
                         m_strDisplayName);

                // S_FALSE suppresses further popups from aclui ("The ACL
                // is not ordered correctly, etc.")
                return S_FALSE;
            }
        }

        if( (SI_READONLY & m_dwSIFlags) && (DSSI_NO_READONLY_MESSAGE & m_dwSIFlags) )
            return S_FALSE;
    }
    return S_OK;
}

DWORD WINAPI
CDSSecurityInfo::InitThread(LPVOID pvThreadData)
{
    CDSSecurityInfo *psi;

    HINSTANCE hInstThisDll = LoadLibrary(c_szDllName);
    psi = (CDSSecurityInfo*)pvThreadData;
    
    SetEvent(psi->m_hLoadLibWaitEvent);
    InterlockedIncrement(&GLOBAL_REFCOUNT);


    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::InitThread");
    TraceAssert(psi != NULL);

#if DBG
    DWORD dwTime = GetTickCount();
#endif

    ThreadCoInitialize();

    psi->Init3();

    ThreadCoUninitialize();

#if DBG
    Trace((TEXT("InitThread complete, elapsed time: %d ms"), GetTickCount() - dwTime));
#endif

    TraceLeave();

    InterlockedDecrement(&GLOBAL_REFCOUNT);
    FreeLibraryAndExitThread(hInstThisDll, 0);

}


HRESULT
SetSecurityInfoMask(LPUNKNOWN punk, SECURITY_INFORMATION si)
{
    HRESULT hr = E_INVALIDARG;
    if (punk)
    {
        IADsObjectOptions *pOptions;
        hr = punk->QueryInterface(IID_IADsObjectOptions, (void**)&pOptions);
        if (SUCCEEDED(hr))
        {
            VARIANT var;
            VariantInit(&var);
            V_VT(&var) = VT_I4;
            V_I4(&var) = si;
            hr = pOptions->SetOption(ADS_OPTION_SECURITY_MASK, var);
            pOptions->Release();
        }
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CDSSecurityInfo::DSReadObjectSecurity
//
//  Synopsis:   Reads the security descriptor from the specied DS object
//
//  Arguments:  [IN  pszObjectPath] --  ADS path of DS object
//              [IN  SeInfo]        --  Security descriptor parts requested
//              [OUT ppSD]          --  Security descriptor returned here
//              [IN  lpContext]     --  CDSSecurityInfo*
//
//  Notes:      The returned security descriptor must be freed with LocalFree
//
//----------------------------------------------------------------------------
HRESULT WINAPI
CDSSecurityInfo::DSReadObjectSecurity(LPCWSTR /*pszObjectPath*/,
                                      SECURITY_INFORMATION SeInfo,
                                      PSECURITY_DESCRIPTOR *ppSD,
                                      LPARAM lpContext)
{
    HRESULT hr = S_OK;
    LPWSTR pszSDProperty = (LPWSTR)c_szSDProperty;
    PADS_ATTR_INFO pSDAttributeInfo = NULL;
    DWORD dwAttributesReturned;

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::DSReadObjectSecurity");
    TraceAssert(SeInfo != 0);
    TraceAssert(ppSD != NULL);
    TraceAssert(lpContext != 0);

    *ppSD = NULL;

    CDSSecurityInfo *pThis = reinterpret_cast<CDSSecurityInfo*>(lpContext);
    TraceAssert(pThis != NULL);
    TraceAssert(pThis->m_pDsObject != NULL);

    // Set the SECURITY_INFORMATION mask
    hr = SetSecurityInfoMask(pThis->m_pDsObject, SeInfo);
    FailGracefully(hr, "Unable to set ADS_OPTION_SECURITY_MASK");

    // Read the security descriptor
    hr = pThis->m_pDsObject->GetObjectAttributes(&pszSDProperty,
                                                 1,
                                                 &pSDAttributeInfo,
                                                 &dwAttributesReturned);
    if (SUCCEEDED(hr) && !pSDAttributeInfo)
        hr = E_ACCESSDENIED;    // This happens for SACL if no SecurityPrivilege
    FailGracefully(hr, "Unable to read nTSecurityDescriptor attribute");

    TraceAssert(ADSTYPE_NT_SECURITY_DESCRIPTOR == pSDAttributeInfo->dwADsType);
    TraceAssert(ADSTYPE_NT_SECURITY_DESCRIPTOR == pSDAttributeInfo->pADsValues->dwType);

    *ppSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, pSDAttributeInfo->pADsValues->SecurityDescriptor.dwLength);
    if (!*ppSD)
        ExitGracefully(hr, E_OUTOFMEMORY, "LocalAlloc failed");

    CopyMemory(*ppSD,
               pSDAttributeInfo->pADsValues->SecurityDescriptor.lpValue,
               pSDAttributeInfo->pADsValues->SecurityDescriptor.dwLength);

exit_gracefully:

    if (pSDAttributeInfo)
        FreeADsMem(pSDAttributeInfo);

    TraceLeaveResult(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CDSSecurityInfo::DSWriteObjectSecurity
//
//  Synopsis:   Writes the security descriptor to the specied DS object
//
//  Arguments:  [IN  pszObjectPath] --  ADS path of DS object
//              [IN  SeInfo]        --  Security descriptor parts provided
//              [IN  pSD]           --  The new security descriptor
//              [IN  lpContext]     --  CDSSecurityInfo*
//
//----------------------------------------------------------------------------
HRESULT WINAPI
CDSSecurityInfo::DSWriteObjectSecurity(LPCWSTR /*pszObjectPath*/,
                                       SECURITY_INFORMATION SeInfo,
                                       PSECURITY_DESCRIPTOR pSD,
                                       LPARAM lpContext)
{
    HRESULT hr = S_OK;
    ADSVALUE attributeValue;
    ADS_ATTR_INFO attributeInfo;
    DWORD dwAttributesModified;
    DWORD dwSDLength;
    PSECURITY_DESCRIPTOR psd = NULL;
    SECURITY_DESCRIPTOR_CONTROL sdControl = 0;
    DWORD dwRevision;

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::DSWriteObjectSecurity");
    TraceAssert(pSD && IsValidSecurityDescriptor(pSD));
    TraceAssert(SeInfo != 0);
    TraceAssert(lpContext != 0);

    CDSSecurityInfo *pThis = reinterpret_cast<CDSSecurityInfo*>(lpContext);
    TraceAssert(pThis != NULL);
    TraceAssert(pThis->m_pDsObject != NULL);

    // Set the SECURITY_INFORMATION mask
    hr = SetSecurityInfoMask(pThis->m_pDsObject, SeInfo);
    FailGracefully(hr, "Unable to set ADS_OPTION_SECURITY_MASK");

    // Need the total size
    dwSDLength = GetSecurityDescriptorLength(pSD);

    //
    // If necessary, make a self-relative copy of the security descriptor
    //
    GetSecurityDescriptorControl(pSD, &sdControl, &dwRevision);
    if (!(sdControl & SE_SELF_RELATIVE))
    {
        psd = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwSDLength);

        if (psd == NULL ||
            !MakeSelfRelativeSD(pSD, psd, &dwSDLength))
        {
            DWORD dwErr = GetLastError();
            ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr), "Unable to make self-relative SD copy");
        }

        // Point to the self-relative copy
        pSD = psd;
    }

    attributeValue.dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
    attributeValue.SecurityDescriptor.dwLength = dwSDLength;
    attributeValue.SecurityDescriptor.lpValue = (LPBYTE)pSD;

    attributeInfo.pszAttrName = (LPWSTR)c_szSDProperty;
    attributeInfo.dwControlCode = ADS_ATTR_UPDATE;
    attributeInfo.dwADsType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
    attributeInfo.pADsValues = &attributeValue;
    attributeInfo.dwNumValues = 1;

    // Write the security descriptor
    hr = pThis->m_pDsObject->SetObjectAttributes(&attributeInfo,
                                                 1,
                                                 &dwAttributesModified);
    if (HRESULT_FROM_WIN32(ERROR_DS_CONSTRAINT_VIOLATION) == hr
        && OWNER_SECURITY_INFORMATION == SeInfo)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_OWNER);
    }

exit_gracefully:

    if (psd != NULL)
        LocalFree(psd);

    TraceLeaveResult(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CheckObjectAccess
//
//  Synopsis:   Checks access to the security descriptor of a DS object.
//              In particular, determines whether the user has READ_CONTROL,
//              WRITE_DAC, WRITE_OWNER, and/or ACCESS_SYSTEM_SECURITY access.
//              If it cannot determine for sure about WRITE_DAC permission,
//              it returns SI_MAY_WRITE which helps aclui to put a better warning
//  Arguments:  none
//
//  Return:     DWORD (Access Mask)
//
//  Notes:      The check for READ_CONTROL involves reading the Owner,
//              Group, and DACL.  This security descriptor is saved
//              in m_pSD.
//
//              The checks for WRITE_DAC, WRITE_OWNER, and
//              ACCESS_SYSTEM_SECURITY involve getting sDRightsEffective
//              from the object.
//
//----------------------------------------------------------------------------
DWORD
CDSSecurityInfo::CheckObjectAccess()
{
    DWORD dwAccessGranted = 0;
    HRESULT hr;
    SECURITY_INFORMATION si = 0;
    LPWSTR pProp = (LPWSTR)c_szSDRightsProp;
    PADS_ATTR_INFO pSDRightsInfo = NULL;
    DWORD dwAttributesReturned;

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::CheckObjectAccess");

#ifdef DSSEC_PRIVATE_DEBUG
    // FOR DEBUGGING ONLY
    // Turn this on to prevent the dialogs from being read-only. This is
    // useful for testing the object picker against NTDEV (for example).
    TraceMsg("Returning all access for debugging");
    dwAccessGranted = (READ_CONTROL | WRITE_OWNER | WRITE_DAC | ACCESS_SYSTEM_SECURITY);
#endif

    // Test for READ_CONTROL by trying to read the Owner, Group, and DACL
    TraceAssert(NULL == m_pSD); // shouldn't get here twice
    TraceAssert(m_strObjectPath != NULL);
    TraceAssert(m_pfnReadSD != NULL);
    hr = (*m_pfnReadSD)(m_strObjectPath,
                        OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
                        &m_pSD,
                        m_lpReadContext);
    if (SUCCEEDED(hr))
    {
        TraceAssert(NULL != m_pSD);
        dwAccessGranted |= READ_CONTROL;
    }

    // If we're in read-only mode, there's no need to check anything else.
    if (m_dwInitFlags & DSSI_READ_ONLY)
        TraceLeaveValue(dwAccessGranted);

    // Read the sDRightsEffective property to determine writability
    m_pDsObject->GetObjectAttributes(&pProp,
                                     1,
                                     &pSDRightsInfo,
                                     &dwAttributesReturned);
    if (pSDRightsInfo)
    {
        TraceAssert(ADSTYPE_INTEGER == pSDRightsInfo->dwADsType);
        si = pSDRightsInfo->pADsValues->Integer;
        FreeADsMem(pSDRightsInfo);
    }
    else
    {
        //
        // Note that GetObjectAttributes commonly returns S_OK even when
        // it fails, so the HRESULT is basically useless here.
        //
        // This can fail if we don't have read_property access, which can
        // happen when an admin is trying to restore access to an object
        // that has had all access removed or denied
        //
        // Assume we can write the Owner and DACL. If not, the worst that
        // happens is the user gets an "Access Denied" message when trying
        // to save changes.
        //
        //Instead of add SI_MAY_WRITE to dwAccessGranted . This helps 
        //ACLUI to putup a better error message. bug 411843

        TraceMsg("GetObjectAttributes failed to read sDRightsEffective");
        dwAccessGranted |= SI_MAY_WRITE;
        si = OWNER_SECURITY_INFORMATION ;
    }

    // The resulting SECURITY_INFORMATION mask indicates the
    // security descriptor parts that may be modified by the user.
    Trace((TEXT("sDRightsEffective = 0x%08x"), si));

    if (OWNER_SECURITY_INFORMATION & si)
        dwAccessGranted |= WRITE_OWNER;

    if (DACL_SECURITY_INFORMATION & si)
        dwAccessGranted |= WRITE_DAC;

    if (SACL_SECURITY_INFORMATION & si)
        dwAccessGranted |= ACCESS_SYSTEM_SECURITY;

    TraceLeaveValue(dwAccessGranted);
}

BOOL SkipLocalGroup(LPCWSTR pszServerName, PSID psid)
{

	SID_NAME_USE use;
	WCHAR szAccountName[MAX_PATH];
	WCHAR szDomainName[MAX_PATH];
	DWORD dwAccountLen = MAX_PATH;
	DWORD dwDomainLen = MAX_PATH;

	if(LookupAccountSid(pszServerName,
						 psid,
						 szAccountName,
						 &dwAccountLen,
						 szDomainName,
						 &dwDomainLen,
						 &use))
	{
		if(use == SidTypeWellKnownGroup)
			return TRUE;
	}

	//
	//Built In sids have first subauthority of 32 ( s-1-5-32 )
	//
	if((*(GetSidSubAuthorityCount(psid)) >= 1 ) && (*(GetSidSubAuthority(psid,0)) == 32))
		return TRUE;
	
	return FALSE;
}

					 



STDMETHODIMP 
CDSSecurityInfo::GetEffectivePermission(const GUID* pguidObjectType,
                                        PSID pUserSid,
                                        LPCWSTR pszServerName,
                                        PSECURITY_DESCRIPTOR pSD,
                                        POBJECT_TYPE_LIST *ppObjectTypeList,
                                        ULONG *pcObjectTypeListLength,
                                        PACCESS_MASK *ppGrantedAccessList,
                                        ULONG *pcGrantedAccessListLength)
{
    AUTHZ_CLIENT_CONTEXT_HANDLE CC = NULL;
    LUID luid = {0xdead,0xbeef};    
    AUTHZ_ACCESS_REQUEST AReq;
    AUTHZ_ACCESS_REPLY AReply;
    HRESULT hr = S_OK;    
    DWORD dwFlags = 0;

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::GetEffectivePermission");
    TraceAssert(pUserSid && IsValidSecurityDescriptor(pSD));
    TraceAssert(ppObjectTypeList != NULL);
    TraceAssert(pcObjectTypeListLength != NULL);
    TraceAssert(ppGrantedAccessList != NULL);
    TraceAssert(pcGrantedAccessListLength != NULL);

    AReply.GrantedAccessMask = NULL;
    AReply.Error = NULL;
    AReq.ObjectTypeList = NULL;
    AReq.ObjectTypeListLength = 0;
 
    if( m_ResourceManager == NULL )
    {	
        //Initilize RM for Access check
    	AuthzInitializeResourceManager(0,
        	                       NULL,
                	               NULL,
                        	       NULL,
                                       L"Dummy",
                                       &m_ResourceManager );
	
	if( m_ResourceManager == NULL )
            ExitGracefully(hr, E_UNEXPECTED, "Could Not Get Resource Manager");    
    }

    //Initialize the client context

    BOOL bSkipLocalGroup = SkipLocalGroup(pszServerName, pUserSid);
    
    if( !AuthzInitializeContextFromSid(bSkipLocalGroup?AUTHZ_SKIP_TOKEN_GROUPS:0 ,
                                       pUserSid,
                                       m_ResourceManager,
                                       NULL,
                                       luid,
                                       NULL,
                                       &CC) )
    {
        DWORD dwErr = GetLastError();
        ExitGracefully(hr, 
                       HRESULT_FROM_WIN32(dwErr),
                       "AuthzInitializeContextFromSid Failed");
    }

    if (NULL == m_strSchemaRootPath)
        dwFlags = SCHEMA_COMMON_PERM;

    if(!m_pOTL)
    {
        //Get ObjectTypeList
        hr = Schema_GetObjectTypeList((LPGUID)pguidObjectType,
                                      m_hAuxClasses,
                                      m_strSchemaRootPath,
                                      dwFlags,
                                      &(AReq.ObjectTypeList), 
                                      &(AReq.ObjectTypeListLength));
        FailGracefully( hr, "Schema_GetObjectTypeList Failed");
        m_pOTL = AReq.ObjectTypeList;
        m_cCountOTL = AReq.ObjectTypeListLength;
    }
    else
    {
        AReq.ObjectTypeList = m_pOTL;
        AReq.ObjectTypeListLength = m_cCountOTL;
    }

    //Do the Access Check

    AReq.DesiredAccess = MAXIMUM_ALLOWED;
    AReq.PrincipalSelfSid = NULL;
    AReq.OptionalArguments = NULL;

    AReply.ResultListLength = AReq.ObjectTypeListLength;
    AReply.SaclEvaluationResults = NULL;
    if( (AReply.GrantedAccessMask = (PACCESS_MASK)LocalAlloc(LPTR, sizeof(ACCESS_MASK)*AReply.ResultListLength) ) == NULL )
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to LocalAlloc");
    if( (AReply.Error = (PDWORD)LocalAlloc(LPTR, sizeof(DWORD)*AReply.ResultListLength)) == NULL )
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to LocalAlloc");

    if( !AuthzAccessCheck(0,
                          CC,
                          &AReq,
                          NULL,
                          pSD,
                          NULL,
                          0,
                          &AReply,
                          NULL) )
    {
        DWORD dwErr = GetLastError();
        ExitGracefully(hr,                        
                       HRESULT_FROM_WIN32(dwErr),
                       "AuthzAccessCheck Failed");
    }

exit_gracefully:

    if(CC)
        AuthzFreeContext(CC);
    
    if(!SUCCEEDED(hr))
    {
        if(AReply.GrantedAccessMask)
            LocalFree(AReply.GrantedAccessMask);
        if(AReply.Error)
            LocalFree(AReply.Error);
        AReply.Error = NULL;
        AReply.GrantedAccessMask = NULL;
    }
    else
    {
        *ppObjectTypeList = AReq.ObjectTypeList;                                  
        *pcObjectTypeListLength = AReq.ObjectTypeListLength;
        *ppGrantedAccessList = AReply.GrantedAccessMask;
        *pcGrantedAccessListLength = AReq.ObjectTypeListLength;
    }

    TraceLeaveResult(hr);
}

STDMETHODIMP 
CDSSecurityInfo::GetInheritSource(SECURITY_INFORMATION si,
                                PACL pACL, 
                                PINHERITED_FROM *ppInheritArray)
{
    HRESULT hr = S_OK;
    DWORD dwErr = ERROR_SUCCESS;
    PINHERITED_FROM pTempInherit = NULL;
    PINHERITED_FROM pTempInherit2 = NULL;
    LPWSTR pStrTemp = NULL;
    IADsPathname *pPath = NULL;
    BSTR strObjectPath = NULL;
    BSTR strServerName = NULL;
    BSTR strParentPath = NULL;
    LPGUID *ppGuid = NULL;

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::GetInheritSource");
    TraceAssert(pACL != 0);
    TraceAssert(ppInheritArray != NULL);

    //
    // Create an ADsPathname object to parse the path and get the
    // the objectname in ADS_FORMAT_X500_DN 
    //
    hr = CoCreateInstance(CLSID_Pathname,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IADsPathname,
                          (LPVOID*)&pPath);

    if (pPath)
    {
        if (SUCCEEDED(pPath->Set(m_strObjectPath, ADS_SETTYPE_FULL)))
        {
            hr = pPath->Retrieve(ADS_FORMAT_SERVER, &strServerName);
            if(!strServerName)
            {
                pPath->Set(m_strServerName,ADS_SETTYPE_SERVER );
                hr = pPath->Retrieve(ADS_FORMAT_X500 ,&strObjectPath);
            }
            else
                strObjectPath = m_strObjectPath;
        }
    }

    if(strObjectPath == NULL)
        strObjectPath = m_strObjectPath;


    if( pACL == NULL || ppInheritArray == NULL )
        ExitGracefully(hr, E_POINTER, "CDSSecurityInfo::GetInheritSource Invalid Parameters");

    pTempInherit = (PINHERITED_FROM)LocalAlloc( LPTR, sizeof(INHERITED_FROM)*pACL->AceCount);
    if(pTempInherit == NULL)
            ExitGracefully(hr, E_OUTOFMEMORY,"OUT of Memory");

    UINT cGuidCount;
    cGuidCount = 1;
    if(m_hAuxClasses)
        cGuidCount += DPA_GetPtrCount(m_hAuxClasses);

    ppGuid = (LPGUID*)LocalAlloc(LPTR,sizeof(LPGUID)*cGuidCount);
    if(!ppGuid)
        ExitGracefully(hr, E_OUTOFMEMORY,"OUT of Memory");

    ppGuid[0] = &m_guidObjectType;

    for(UINT i = 1; i < cGuidCount ; ++i)
    {
        PAUX_INFO pAI = (PAUX_INFO)DPA_FastGetPtr(m_hAuxClasses, i-1);     
        if(IsEqualGUID(pAI->guid, GUID_NULL))
        {
            hr = Schema_GetObjectTypeGuid(pAI->pszClassName,&pAI->guid);
			FailGracefully( hr, "Schema_GetObjectTypeGuid Failed");
        }
        ppGuid[i] = &pAI->guid;
    }

    dwErr = GetInheritanceSource(strObjectPath,
                                 SE_DS_OBJECT_ALL,
                                 si,
                                 //m_dwSIFlags & SI_CONTAINER,
                                 TRUE,
                                 ppGuid,
                                 cGuidCount,
                                 pACL,
                                 NULL,
                                 &g_DSMap,
                                 pTempInherit);
    
    hr = HRESULT_FROM_WIN32(dwErr);
    FailGracefully( hr, "GetInheritanceSource Failed");

    DWORD nSize;
    

    nSize = sizeof(INHERITED_FROM)*pACL->AceCount;
    for(UINT i = 0; i < pACL->AceCount; ++i)
    {
        if(pTempInherit[i].AncestorName)
            nSize += StringByteSize(pTempInherit[i].AncestorName);
    }

    pTempInherit2 = (PINHERITED_FROM)LocalAlloc( LPTR, nSize );
    if(pTempInherit2 == NULL)
        ExitGracefully(hr, E_OUTOFMEMORY,"OUT of Memory");
    
    pStrTemp = (LPWSTR)(pTempInherit2 + pACL->AceCount); 

    for(i = 0; i < pACL->AceCount; ++i)
    {
        pTempInherit2[i].GenerationGap = pTempInherit[i].GenerationGap;
        if(pTempInherit[i].AncestorName)
        {
            if (SUCCEEDED(pPath->Set(pTempInherit[i].AncestorName, ADS_SETTYPE_FULL)))
            {
                hr = pPath->Retrieve(ADS_FORMAT_X500_DN, &strParentPath);
            }
            
            pTempInherit2[i].AncestorName = pStrTemp;
            
            if(strParentPath)
            {
                wcscpy(pStrTemp,strParentPath);
                pStrTemp += (wcslen(pStrTemp)+1);
                SysFreeString(strParentPath);
                strParentPath = NULL;
            }
            else
            {
                wcscpy(pStrTemp,pTempInherit[i].AncestorName);
                pStrTemp += (wcslen(pTempInherit[i].AncestorName)+1);
            }
        }
    }
            

exit_gracefully:

    if(SUCCEEDED(hr))
    {
        //FreeInheritedFromArray(pTempInherit, pACL->AceCount,NULL);
        *ppInheritArray = pTempInherit2;
            
    }                        
    if(pTempInherit)
        LocalFree(pTempInherit);

    if(ppGuid)
        LocalFree(ppGuid);
    
    DoRelease(pPath);
    if(strObjectPath != m_strObjectPath)
        SysFreeString(strObjectPath);
    if(strServerName)
	SysFreeString(strServerName);	

    TraceLeaveResult(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   DSCreateISecurityInfoObjectEx
//
//  Synopsis:   Instantiates an ISecurityInfo interface for a DS object
//
//  Arguments:  [IN  pwszObjectPath]    --  Full ADS path of DS object
//              [IN  pwszObjectClass]   --  Class of the object (optional)
//              [IN  pwszServer]        --  Name/address of DS DC (optional)
//              [IN  pwszUserName]      --  User name for validation (optional)
//              [IN  pwszPassword]      --  Password for validation (optional)
//              [IN  dwFlags]           --  Combination of DSSI_* flags
//              [OUT ppSI]              --  Interface pointer returned here
//              [IN  pfnReadSD]         --  Optional function for reading SD
//              [IN  pfnWriteSD]        --  Optional function for writing SD
//              [IN  lpContext]         --  Passed to pfnReadSD/pfnWriteSD
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
STDAPI
DSCreateISecurityInfoObjectEx(LPCWSTR pwszObjectPath,
                              LPCWSTR pwszObjectClass,
                              LPCWSTR pwszServer,
                              LPCWSTR pwszUserName,
                              LPCWSTR pwszPassword,
                              DWORD   dwFlags,
                              LPSECURITYINFO *ppSI,
                              PFNREADOBJECTSECURITY  pfnReadSD,
                              PFNWRITEOBJECTSECURITY pfnWriteSD,
                              LPARAM lpContext)
{
    HRESULT hr;
    CDSSecurityInfo* pSI = NULL;

    TraceEnter(TRACE_SECURITY, "DSCreateISecurityInfoObjectEx");

    if (pwszObjectPath == NULL || ppSI == NULL)
        TraceLeaveResult(E_INVALIDARG);

    *ppSI = NULL;

    //
    // Create and initialize the ISecurityInformation object.
    //
    pSI = new CDSSecurityInfo();      // ref == 0
    if (!pSI)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to create CDSSecurityInfo object");

    pSI->AddRef();                    // ref == 1

    hr = pSI->Init(pwszObjectPath,
                   pwszObjectClass,
                   pwszServer,
                   pwszUserName,
                   pwszPassword,
                   dwFlags,
                   pfnReadSD,
                   pfnWriteSD,
                   lpContext);
    if (FAILED(hr))
    {
        DoRelease(pSI);
    }

    *ppSI = (LPSECURITYINFO)pSI;

exit_gracefully:

    TraceLeaveResult(hr);
}


STDAPI
DSCreateISecurityInfoObject(LPCWSTR pwszObjectPath,
                            LPCWSTR pwszObjectClass,
                            DWORD   dwFlags,
                            LPSECURITYINFO *ppSI,
                            PFNREADOBJECTSECURITY  pfnReadSD,
                            PFNWRITEOBJECTSECURITY pfnWriteSD,
                            LPARAM lpContext)
{
    return DSCreateISecurityInfoObjectEx(pwszObjectPath,
                                         pwszObjectClass,
                                         NULL, //pwszServer,
                                         NULL, //pwszUserName,
                                         NULL, //pwszPassword,
                                         dwFlags,
                                         ppSI,
                                         pfnReadSD,
                                         pfnWriteSD,
                                         lpContext);
}


//+---------------------------------------------------------------------------
//
//  Function:   DSCreateSecurityPage
//
//  Synopsis:   Creates a Security property page for a DS object
//
//  Arguments:  [IN  pwszObjectPath]    --  Full ADS path of DS object
//              [IN  pwszObjectClass]   --  Class of the object (optional)
//              [IN  dwFlags]           --  Combination of DSSI_* flags
//              [OUT phPage]            --  HPROPSHEETPAGE returned here
//              [IN  pfnReadSD]         --  Optional function for reading SD
//              [IN  pfnWriteSD]        --  Optional function for writing SD
//              [IN  lpContext]         --  Passed to pfnReadSD/pfnWriteSD
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
STDAPI
DSCreateSecurityPage(LPCWSTR pwszObjectPath,
                     LPCWSTR pwszObjectClass,
                     DWORD   dwFlags,
                     HPROPSHEETPAGE *phPage,
                     PFNREADOBJECTSECURITY  pfnReadSD,
                     PFNWRITEOBJECTSECURITY pfnWriteSD,
                     LPARAM lpContext)
{
    HRESULT hr;
    LPSECURITYINFO pSI = NULL;

    TraceEnter(TRACE_SECURITY, "DSCreateSecurityPage");

    if (NULL == phPage || NULL == pwszObjectPath || !*pwszObjectPath)
        TraceLeaveResult(E_INVALIDARG);

    *phPage = NULL;

    hr = DSCreateISecurityInfoObject(pwszObjectPath,
                                     pwszObjectClass,
                                     dwFlags,
                                     &pSI,
                                     pfnReadSD,
                                     pfnWriteSD,
                                     lpContext);
    if (SUCCEEDED(hr))
    {
        hr = _CreateSecurityPage(pSI, phPage);
        DoRelease(pSI);
    }

    TraceLeaveResult(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   DSEditSecurity
//
//  Synopsis:   Displays a modal dialog for editing security on a DS object
//
//  Arguments:  [IN  hwndOwner]         --  Dialog owner window
//              [IN  pwszObjectPath]    --  Full ADS path of DS object
//              [IN  pwszObjectClass]   --  Class of the object (optional)
//              [IN  dwFlags]           --  Combination of DSSI_* flags
//              [IN  pwszCaption        --  Optional dialog caption
//              [IN  pfnReadSD]         --  Optional function for reading SD
//              [IN  pfnWriteSD]        --  Optional function for writing SD
//              [IN  lpContext]         --  Passed to pfnReadSD/pfnWriteSD
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
STDAPI
DSEditSecurity(HWND hwndOwner,
               LPCWSTR pwszObjectPath,
               LPCWSTR pwszObjectClass,
               DWORD dwFlags,
               LPCWSTR pwszCaption,
               PFNREADOBJECTSECURITY pfnReadSD,
               PFNWRITEOBJECTSECURITY pfnWriteSD,
               LPARAM lpContext)
{
    HRESULT hr;
    LPSECURITYINFO pSI = NULL;

    TraceEnter(TRACE_SECURITY, "DSCreateSecurityPage");

    if (NULL == pwszObjectPath || !*pwszObjectPath)
        TraceLeaveResult(E_INVALIDARG);

    if (pwszCaption && *pwszCaption)
    {
        // Use the provided caption
        HPROPSHEETPAGE hPage = NULL;

        hr = DSCreateSecurityPage(pwszObjectPath,
                                  pwszObjectClass,
                                  dwFlags,
                                  &hPage,
                                  pfnReadSD,
                                  pfnWriteSD,
                                  lpContext);
        if (SUCCEEDED(hr))
        {
            PROPSHEETHEADERW psh;
            psh.dwSize = SIZEOF(psh);
            psh.dwFlags = PSH_DEFAULT;
            psh.hwndParent = hwndOwner;
            psh.hInstance = GLOBAL_HINSTANCE;
            psh.pszCaption = pwszCaption;
            psh.nPages = 1;
            psh.nStartPage = 0;
            psh.phpage = &hPage;

            PropertySheetW(&psh);
        }
    }
    else
    {
        // This method creates a caption like "Permissions for Foo"
        hr = DSCreateISecurityInfoObject(pwszObjectPath,
                                         pwszObjectClass,
                                         dwFlags,
                                         &pSI,
                                         pfnReadSD,
                                         pfnWriteSD,
                                         lpContext);
        if (SUCCEEDED(hr))
        {
            hr = _EditSecurity(hwndOwner, pSI);
            DoRelease(pSI);
        }
    }

    TraceLeaveResult(hr);
}



/*******************************************************************

    NAME:       GetLSAConnection

    SYNOPSIS:   Wrapper for LsaOpenPolicy

    ENTRY:      pszServer - the server on which to make the connection

    EXIT:

    RETURNS:    LSA_HANDLE if successful, NULL otherwise

    NOTES:

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/

LSA_HANDLE
GetLSAConnection(LPCTSTR pszServer, DWORD dwAccessDesired)
{
    LSA_HANDLE hPolicy = NULL;
    LSA_UNICODE_STRING uszServer = {0};
    LSA_UNICODE_STRING *puszServer = NULL;
    LSA_OBJECT_ATTRIBUTES oa;
    SECURITY_QUALITY_OF_SERVICE sqos;

    sqos.Length = SIZEOF(sqos);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = FALSE;

    InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
    oa.SecurityQualityOfService = &sqos;

    if (pszServer &&
        *pszServer &&
        RtlCreateUnicodeString(&uszServer, pszServer))
    {
        puszServer = &uszServer;
    }

    LsaOpenPolicy(puszServer, &oa, dwAccessDesired, &hPolicy);

    if (puszServer)
        RtlFreeUnicodeString(puszServer);

    return hPolicy;
}

HRESULT
GetDomainSid(LPCWSTR pszServer, PSID *ppSid)
{
    HRESULT hr = S_OK;
    NTSTATUS nts = STATUS_SUCCESS;
    PPOLICY_ACCOUNT_DOMAIN_INFO pDomainInfo = NULL;
    if(!pszServer || !ppSid)
        return E_INVALIDARG;

    *ppSid = NULL;

    LSA_HANDLE hLSA = GetLSAConnection(pszServer, POLICY_VIEW_LOCAL_INFORMATION);

    if (!hLSA)
    {
        hr = E_FAIL;
        goto exit_gracefully;
    }

    
    nts = LsaQueryInformationPolicy(hLSA,
                                    PolicyAccountDomainInformation,
                                    (PVOID*)&pDomainInfo);
    if(nts != STATUS_SUCCESS)
    {
        hr = E_FAIL;
        goto exit_gracefully;
    }

    if (pDomainInfo && pDomainInfo->DomainSid)
    {
        ULONG cbSid = GetLengthSid(pDomainInfo->DomainSid);

        *ppSid = (PSID) LocalAlloc(LPTR, cbSid);

        if (!*ppSid)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }

        CopyMemory(*ppSid, pDomainInfo->DomainSid, cbSid);
    }

exit_gracefully:
    if(pDomainInfo)
        LsaFreeMemory(pDomainInfo);          
    if(hLSA)
        LsaClose(hLSA);

    return hr;
}

//
// include and defines for ldap calls
//
#include <winldap.h>
#include <ntldap.h>

typedef LDAP * (LDAPAPI *PFN_LDAP_OPEN)( PWCHAR, ULONG );
typedef ULONG (LDAPAPI *PFN_LDAP_UNBIND)( LDAP * );
typedef ULONG (LDAPAPI *PFN_LDAP_SEARCH)(LDAP *, PWCHAR, ULONG, PWCHAR, PWCHAR *, ULONG,PLDAPControlA *, PLDAPControlA *, struct l_timeval *, ULONG, LDAPMessage **);
typedef LDAPMessage * (LDAPAPI *PFN_LDAP_FIRST_ENTRY)( LDAP *, LDAPMessage * );
typedef PWCHAR * (LDAPAPI *PFN_LDAP_GET_VALUE)(LDAP *, LDAPMessage *, PWCHAR );
typedef ULONG (LDAPAPI *PFN_LDAP_MSGFREE)( LDAPMessage * );
typedef ULONG (LDAPAPI *PFN_LDAP_VALUE_FREE)( PWCHAR * );
typedef ULONG (LDAPAPI *PFN_LDAP_MAP_ERROR)( ULONG );

HRESULT
GetRootDomainSid(LPCWSTR pszServer, PSID *ppSid)
{
    //
    // get root domain sid, save it in RootDomSidBuf (global)
    // this function is called within the critical section
    //
    // 1) ldap_open to the DC of interest.
    // 2) you do not need to ldap_connect - the following step works anonymously
    // 3) read the operational attribute rootDomainNamingContext and provide the
    //    operational control LDAP_SERVER_EXTENDED_DN_OID as defined in sdk\inc\ntldap.h.


    DWORD               Win32rc=NO_ERROR;

    HINSTANCE                   hLdapDll=NULL;
    PFN_LDAP_OPEN               pfnLdapOpen=NULL;
    PFN_LDAP_UNBIND             pfnLdapUnbind=NULL;
    PFN_LDAP_SEARCH             pfnLdapSearch=NULL;
    PFN_LDAP_FIRST_ENTRY        pfnLdapFirstEntry=NULL;
    PFN_LDAP_GET_VALUE          pfnLdapGetValue=NULL;
    PFN_LDAP_MSGFREE            pfnLdapMsgFree=NULL;
    PFN_LDAP_VALUE_FREE         pfnLdapValueFree=NULL;
    PFN_LDAP_MAP_ERROR          pfnLdapMapError=NULL;

    PLDAP                       phLdap=NULL;

    LDAPControlW    serverControls = { LDAP_SERVER_EXTENDED_DN_OID_W,
                                       { 0, NULL },
                                       TRUE
                                     };
    LPWSTR           Attribs[] = { LDAP_OPATT_ROOT_DOMAIN_NAMING_CONTEXT_W, NULL };

    PLDAPControlW   rServerControls[] = { &serverControls, NULL };
    PLDAPMessage    pMessage = NULL;
    LDAPMessage     *pEntry = NULL;
    PWCHAR           *ppszValues=NULL;

    LPWSTR           pSidStart, pSidEnd, pParse;
    BYTE            *pDest = NULL;
    BYTE            OneByte;

	DWORD RootDomSidBuf[sizeof(SID)/sizeof(DWORD)+5];

    hLdapDll = LoadLibraryA("wldap32.dll");

    if ( hLdapDll) 
	{
        pfnLdapOpen = (PFN_LDAP_OPEN)GetProcAddress(hLdapDll,
                                                    "ldap_openW");
        pfnLdapUnbind = (PFN_LDAP_UNBIND)GetProcAddress(hLdapDll,
                                                      "ldap_unbind");
        pfnLdapSearch = (PFN_LDAP_SEARCH)GetProcAddress(hLdapDll,
                                                    "ldap_search_ext_sW");
        pfnLdapFirstEntry = (PFN_LDAP_FIRST_ENTRY)GetProcAddress(hLdapDll,
                                                      "ldap_first_entry");
        pfnLdapGetValue = (PFN_LDAP_GET_VALUE)GetProcAddress(hLdapDll,
                                                    "ldap_get_valuesW");
        pfnLdapMsgFree = (PFN_LDAP_MSGFREE)GetProcAddress(hLdapDll,
                                                      "ldap_msgfree");
        pfnLdapValueFree = (PFN_LDAP_VALUE_FREE)GetProcAddress(hLdapDll,
                                                    "ldap_value_freeW");
        pfnLdapMapError = (PFN_LDAP_MAP_ERROR)GetProcAddress(hLdapDll,
                                                      "LdapMapErrorToWin32");
    }

    if ( pfnLdapOpen == NULL ||
         pfnLdapUnbind == NULL ||
         pfnLdapSearch == NULL ||
         pfnLdapFirstEntry == NULL ||
         pfnLdapGetValue == NULL ||
         pfnLdapMsgFree == NULL ||
         pfnLdapValueFree == NULL ||
         pfnLdapMapError == NULL ) 
	{

        Win32rc = ERROR_PROC_NOT_FOUND;

    } else 
	{

        //
        // bind to ldap
        //
        phLdap = (*pfnLdapOpen)((PWCHAR)pszServer, LDAP_PORT);

        if ( phLdap == NULL ) 
            Win32rc = ERROR_FILE_NOT_FOUND;
    }

    if ( NO_ERROR == Win32rc ) 
	{
        //
        // now get the ldap handle,
        //

        Win32rc = (*pfnLdapSearch)(
                        phLdap,
                        L"",
                        LDAP_SCOPE_BASE,
                        L"(objectClass=*)",
                        Attribs,
                        0,
                        (PLDAPControlA *)&rServerControls,
                        NULL,
                        NULL,
                        10000,
                        &pMessage);

        if( Win32rc == NO_ERROR && pMessage ) 
		{

            Win32rc = ERROR_SUCCESS;

            pEntry = (*pfnLdapFirstEntry)(phLdap, pMessage);

            if(pEntry == NULL) 
			{

                Win32rc = (*pfnLdapMapError)( phLdap->ld_errno );

            } else 
			{
                //
                // Now, we'll have to get the values
                //
                ppszValues = (*pfnLdapGetValue)(phLdap,
                                              pEntry,
                                              Attribs[0]);

                if( ppszValues == NULL) 
				{

                    Win32rc = (*pfnLdapMapError)( phLdap->ld_errno );

                } else if ( ppszValues[0] && ppszValues[0][0] != '\0' ) 
				{

                    //
                    // ppszValues[0] is the value to parse.
                    // The data will be returned as something like:

                    // <GUID=278676f8d753d211a61ad7e2dfa25f11>;<SID=010400000000000515000000828ba6289b0bc11e67c2ef7f>;DC=colinbrdom1,DC=nttest,DC=microsoft,DC=com

                    // Parse through this to find the <SID=xxxxxx> part.  Note that it may be missing, but the GUID= and trailer should not be.
                    // The xxxxx represents the hex nibbles of the SID.  Translate to the binary form and case to a SID.


                    pSidStart = wcsstr(ppszValues[0], L"<SID=");

                    if ( pSidStart ) 
					{
                        //
                        // find the end of this SID
                        //
                        pSidEnd = wcsstr(pSidStart, L">");

                        if ( pSidEnd ) 
						{

                            pParse = pSidStart + 5;
                            pDest = (BYTE *)RootDomSidBuf;

                            while ( pParse < pSidEnd-1 ) 
							{

                                if ( *pParse >= '0' && *pParse <= '9' ) 
								{
                                    OneByte = (BYTE) ((*pParse - '0') * 16);
                                } 
								else 
								{
                                    OneByte = (BYTE) ( (tolower(*pParse) - 'a' + 10) * 16 );
                                }

                                if ( *(pParse+1) >= '0' && *(pParse+1) <= '9' ) 
								{
                                    OneByte = OneByte + (BYTE) ( (*(pParse+1)) - '0' ) ;
                                } 
								else 
								{
                                    OneByte = OneByte + (BYTE) ( tolower(*(pParse+1)) - 'a' + 10 ) ;
                                }

                                *pDest = OneByte;
                                pDest++;
                                pParse += 2;
                            }

							ULONG cbSid = GetLengthSid((PSID)RootDomSidBuf);
							*ppSid = (PSID) LocalAlloc(LPTR, cbSid);

							if (!*ppSid)
							{
								Win32rc = ERROR_NOT_ENOUGH_MEMORY;
							}

							CopyMemory(*ppSid, (PSID)RootDomSidBuf, cbSid);
							ASSERT(IsValidSid(*ppSid));


                        } else 
						{
                            Win32rc = ERROR_OBJECT_NOT_FOUND;
                        }
                    } else 
					{
                        Win32rc = ERROR_OBJECT_NOT_FOUND;
                    }

                    (*pfnLdapValueFree)(ppszValues);

                } else 
				{
                    Win32rc = ERROR_OBJECT_NOT_FOUND;
                }
            }

            (*pfnLdapMsgFree)(pMessage);
        }

    }

    //
    // even though it's not binded, use unbind to close
    //
    if ( phLdap != NULL && pfnLdapUnbind )
        (*pfnLdapUnbind)(phLdap);

    if ( hLdapDll ) 
	{
        FreeLibrary(hLdapDll);
    }

    return HRESULT_FROM_WIN32(Win32rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\common\strings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       strings.cpp
//
//  Useful string manipulation functions.
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ LocalAllocString
/ ------------------
/   Allocate a string, and initialize it with the specified contents.
/
/ In:
/   ppResult -> recieves pointer to the new string
/   pString -> string to initialize with
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT LocalAllocString(LPTSTR* ppResult, LPCTSTR pString)
{
    HRESULT hr;

    TraceEnter(TRACE_COMMON_STR, "LocalAllocString");

    TraceAssert(ppResult);
    TraceAssert(pString);

    if ( !ppResult || !pString )
        ExitGracefully(hr, E_INVALIDARG, "Bad arguments");

    *ppResult = (LPTSTR)LocalAlloc(LPTR, StringByteSize(pString) );

    if ( !*ppResult )
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate buffer");

    lstrcpy(*ppResult, pString);
    hr = S_OK;                          //  success

exit_gracefully:

    TraceLeaveResult(hr);
}


/*----------------------------------------------------------------------------
/ LocalAllocStringLen
/ ---------------------
/   Given a length return a buffer of that size.
/
/ In:
/   ppResult -> receives the pointer to the string
/   cLen = length in characters to allocate
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT LocalAllocStringLen(LPTSTR* ppResult, UINT cLen)
{
    HRESULT hr;

    TraceEnter(TRACE_COMMON_STR, "LocalAllocStringLen");

    TraceAssert(ppResult);

    if ( !ppResult || cLen == 0 )
        ExitGracefully(hr, E_INVALIDARG, "Bad arguments (length or buffer)");

    *ppResult = (LPTSTR)LocalAlloc(LPTR, (cLen+1) * SIZEOF(TCHAR));

    hr = *ppResult ? S_OK:E_OUTOFMEMORY; 

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ LocalFreeString
/ -----------------
/   Release the string pointed to be *ppString (which can be null) and
/   then reset the pointer back to NULL.   
/
/ In:
/   ppString -> pointer to string pointer to be free'd
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void LocalFreeString(LPTSTR* ppString)
{
    if ( ppString )
    {
        if ( *ppString )
            LocalFree((HLOCAL)*ppString);

        *ppString = NULL;
    }
}


//*************************************************************
//
//  SizeofStringResource
//
//  Purpose:    Find the length (in chars) of a string resource
//
//  Parameters: HINSTANCE hInstance - module containing the string
//              UINT idStr - ID of string
//
//
//  Return:     UINT - # of chars in string, not including NULL
//
//  Notes:      Based on code from user32.
//
//*************************************************************
UINT
SizeofStringResource(HINSTANCE hInstance,
                     UINT idStr)
{
    UINT cch = 0;
    HRSRC hRes = FindResource(hInstance, (LPTSTR)((LONG_PTR)(((USHORT)idStr >> 4) + 1)), RT_STRING);
    if (NULL != hRes)
    {
        HGLOBAL hStringSeg = LoadResource(hInstance, hRes);
        if (NULL != hStringSeg)
        {
            LPWSTR psz = (LPWSTR)LockResource(hStringSeg);
            if (NULL != psz)
            {
                idStr &= 0x0F;
                while(true)
                {
                    cch = *psz++;
                    if (idStr-- == 0)
                        break;
                    psz += cch;
                }
            }
        }
    }
    return cch;
}


//*************************************************************
//
//  LoadStringAlloc
//
//  Purpose:    Loads a string resource into an alloc'd buffer
//
//  Parameters: ppszResult - string resource returned here
//              hInstance - module to load string from
//              idStr - string resource ID
//
//  Return:     same as LoadString
//
//  Notes:      On successful return, the caller must
//              LocalFree *ppszResult
//
//*************************************************************
int
LoadStringAlloc(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr)
{
    int nResult = 0;
    UINT cch = SizeofStringResource(hInstance, idStr);
    if (cch)
    {
        cch++; // for NULL
        *ppszResult = (LPTSTR)LocalAlloc(LPTR, cch * sizeof(TCHAR));
        if (*ppszResult)
            nResult = LoadString(hInstance, idStr, *ppszResult, cch);
    }
    return nResult;
}


//*************************************************************
//
//  String formatting functions
//
//*************************************************************

DWORD
FormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, ...)
{
    DWORD dwResult;
    va_list args;
    va_start(args, idStr);
    dwResult = vFormatStringID(ppszResult, hInstance, idStr, &args);
    va_end(args);
    return dwResult;
}

DWORD
FormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, ...)
{
    DWORD dwResult;
    va_list args;
    va_start(args, pszFormat);
    dwResult = vFormatString(ppszResult, pszFormat, &args);
    va_end(args);
    return dwResult;
}

DWORD
vFormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, va_list *pargs)
{
    DWORD dwResult = 0;
    LPTSTR pszFormat = NULL;
    if (LoadStringAlloc(&pszFormat, hInstance, idStr))
    {
        dwResult = vFormatString(ppszResult, pszFormat, pargs);
        LocalFree(pszFormat);
    }
    return dwResult;
}

DWORD
vFormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, va_list *pargs)
{
    return FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                         pszFormat,
                         0,
                         0,
                         (LPTSTR)ppszResult,
                         1,
                         pargs);
}


//*************************************************************
//
//  GetSystemErrorText
//
//  Purpose:    Retrieve error text for a win32 error value
//
//  Parameters: ppszResult - string resource returned here
//              dwErr - error ID
//
//  Return:     same as FormatMessage
//
//  Notes:      On successful return, the caller must
//              LocalFree *ppszResult
//
//*************************************************************
DWORD
GetSystemErrorText(LPTSTR *ppszResult, DWORD dwErr)
{
    return FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                         NULL,
                         dwErr,
                         0,
                         (LPTSTR)ppszResult,
                         0,
                         NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\dssec\cstrings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cstrings.h
//
//--------------------------------------------------------------------------

#ifndef __cstrings_h
#define __cstrings_h

extern TCHAR const c_szDllName[];
extern TCHAR const c_szNetApi32[];
extern TCHAR const c_szAclUI[];
extern WCHAR const c_szFilterFile[];
extern WCHAR const c_szClassKey[];
extern WCHAR const c_szGUIDFormat[];
extern WCHAR const c_szClassFilter[];
extern WCHAR const c_szPropertyFilter[];
extern WCHAR const c_szERFilterFormat[];
extern WCHAR const c_szLDAPDisplayName[];
extern WCHAR const c_szDisplayName[];
extern WCHAR const c_szDisplayID[];
extern WCHAR const c_szValidAccesses[];
extern WCHAR const c_szSchemaIDGUID[];
extern WCHAR const c_szRightsGuid[];
extern WCHAR const c_szSDProperty[];
extern WCHAR const c_szSDRightsProp[];
extern WCHAR const c_szSchemaContext[];
extern WCHAR const c_szConfigContext[];
extern WCHAR const c_szERContainer[];
extern WCHAR const c_szRootDsePath[];
extern WCHAR const c_szPathFormat[];
extern WCHAR const c_szCNFormat[];
extern WCHAR const c_szDefaultSchemaSD[];
extern WCHAR const c_szAttributeSecurityGuid[];
extern WCHAR const c_szObjectClass[];
extern WCHAR const c_szStructuralObjectClass[];
extern WCHAR const c_szObjectClassCategory[];

#endif  // __cstrings_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\dssec\exnc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       exnc.h
//
// Specific Non-Canonical Test
//
// Test if a Security Descriptor contains an ACL with non-Canonical ACEs
//
// Created by: Marcelo Calbucci (MCalbu)
//             June 23rd, 1999.
//
//--------------------------------------------------------------------------

#ifndef __EXNC_H__
#define __EXNC_H__

#include <windows.h>
#include <ntdsapi.h>

//
// IsSpecificNonCanonical Results:
//
// ENC_RESULT_NOT_PRESENT: This is not an Specific Non-Canonical SD.
//                         (It still can be a Canonical SD)
// ENC_RESULT_HIDEMEMBER : We have the Non-Canonical part referent to HideMembership
// ENC_RESULT_HIDEOBJECT : We have the Non-Canonical part referent to HideFromAB
// ENC_RESULT_ALL        : We have both Non-Canonical parts, HideMembership and HideFromAB
#define ENC_RESULT_NOT_PRESENT	0x0
#define ENC_RESULT_HIDEMEMBER	0x1
#define ENC_RESULT_HIDEOBJECT	0x2
#define ENC_RESULT_ALL		(ENC_RESULT_HIDEMEMBER | ENC_RESULT_HIDEOBJECT)

#define ENC_MINIMUM_ALLOWED	0x1
//
// IsSpecificNonCanonicalSD
DWORD IsSpecificNonCanonicalSD(PSECURITY_DESCRIPTOR pSD);

#define NT_RIGHT_MEMBER		{0xbf9679c0, 0x0de6, 0x11d0, {0xa2, 0x85, 0x00, 0xaa, 0x00, 0x30, 0x49, 0xe2}}

PSID GetAccountSid(LPCTSTR szServer, LPCTSTR szUsername);
BOOL ENCCompareSids(PSID pSid, LPVOID lpAce);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\dssec\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pch.h
//
//--------------------------------------------------------------------------

#ifndef _pch_h
#define _pch_h

// Headers etc

#ifndef UNICODE
#error "No ANSI support yet"
#endif

extern "C"
{
    #include <nt.h>         // SE_TAKE_OWNERSHIP_PRIVILEGE, etc
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <seopaque.h>

}

#define INC_OLE2
#include <windows.h>
#include <windowsx.h>
#include <atlconv.h>        // ANSI/Unicode conversion support
#include <shlobj.h>
#include <shlwapi.h>        // StrStr
#include <comctrlp.h>       // DPA/DSA
#include <lmcons.h>
#include <lmapibuf.h>
#include <dsgetdc.h>
#include <activeds.h>
#include <winldap.h>
#include <aclapi.h>
#include <aclui.h>

#include <common.h>
#include <dsclient.h>

#include "resource.h"
#include "iids.h"
#include "cstrings.h"

#include "dll.h"

extern "C"
{
    #include "authz.h"
}

#include "schema.h"
#include "security.h"

#define MAX_TYPENAME_LENGTH     64

// Magic debug flags
#define TRACE_CORE          0x00000001
#define TRACE_SECURITY      0x00000002
#define TRACE_DSSI          0x00000004
#define TRACE_SCHEMA        0x00000008
#define TRACE_SCHEMACLASS   0x00000010
#define TRACE_SCHEMAPROP    0x00000020
#define TRACE_ALWAYS        0xffffffff          // use with caution

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\dssec\exnc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       exnc.cpp
//
// Specific Non-Canonical Test
//
// Test if a Security Descriptor contains an ACL with non-Canonical ACEs
//
// Created by: Marcelo Calbucci (MCalbu)
//             June 23rd, 1999.
//
//--------------------------------------------------------------------------

#include "pch.h"
extern "C" {
#include <seopaque.h>   // RtlObjectAceSid, etc.
}
#include "exnc.h"

static const GUID guidMember = NT_RIGHT_MEMBER;


//
// ENCCompareSids
// Compare if pSid is the same SID inside pAce.
//
BOOL ENCCompareSids(PSID pSid, PACE_HEADER pAce)
{
    if (!pAce)
        return FALSE;

    PSID pSid2 = NULL;

    switch (pAce->AceType)
    {
    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
        pSid2 = RtlObjectAceSid(pAce);
        break;

    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
        pSid2 = (PSID)&((PKNOWN_ACE)pAce)->SidStart;
        break;

    default:
        return FALSE;
    }

    return (pSid && pSid2 && EqualSid(pSid, pSid2));
}


//
// IsSpecificNonCanonicalSD
// This function verifies if the Security Descriptor (*pSD) it is or not in the
// specific non-canonical format.
// Parameters:
//    pSD: The Security Descriptor to be analyzed
// Result:
//    ENC_RESULT_NOT_PRESENT: This is not a Specific Non-Canonical SD.
//                            (It still can be a Canonical SD)
//    ENC_RESULT_HIDEMEMBER : We have the Non-Canonical part referent to HideMembership
//    ENC_RESULT_HIDEOBJECT : We have the Non-Canonical part referent to HideFromAB
//    ENC_RESULT_ALL        : We have both Non-Canonical parts, HideMembership and HideFromAB
//
DWORD IsSpecificNonCanonicalSD(PSECURITY_DESCRIPTOR pSD)
{
    // Check the Security Descriptor
    if(pSD==NULL)
        return FALSE;
    if(!IsValidSecurityDescriptor(pSD))
        return FALSE;

    // Get and Check the DACL
    PACL pDacl = NULL;
    BOOL fDaclPresent, fDaclDefaulted;
    if(!GetSecurityDescriptorDacl(pSD, &fDaclPresent, &pDacl, &fDaclDefaulted))
        return FALSE;
    if(!fDaclPresent)
        return FALSE;
    if(!pDacl)
        return FALSE;

    // Do a lazy evaluation:
    //    If we have less than 4 ACEs, this is not a Specific Non-Canonical ACL
    if (pDacl->AceCount < 4)
        return FALSE;

    //
    // Check if the "member" or "list object" are in the Non-Canonical format
    //

    // Info (flags): Count how many alloweds we have
    DWORD dwInfoMember = 0;
    DWORD dwInfoListObject = 0;
    
    // Get the Sids...
    SID sidEveryone;    // SID contains 1 subauthority, which is enough

    // -1 = Unknown
    // 0 = Not Present
    // 1 = Present
    int iMemberResult = -1;
    int iListObjectResult = -1;

    //  # Everyone
    SID_IDENTIFIER_AUTHORITY siaNtAuthority1 = SECURITY_WORLD_SID_AUTHORITY;
    InitializeSid(&sidEveryone, &siaNtAuthority1, 1);
    *(GetSidSubAuthority(&sidEveryone, 0)) = SECURITY_WORLD_RID;

    DWORD dwCurAce;
    PACE_HEADER pAce;

    for (dwCurAce = 0, pAce = (PACE_HEADER)FirstAce(pDacl);
         dwCurAce < pDacl->AceCount;
         dwCurAce++, pAce = (PACE_HEADER)NextAce(pAce))
    {
        // Test the "member"
        if (-1 == iMemberResult && IsObjectAceType(pAce))
        {
            const GUID *pObjectType = RtlObjectAceObjectType(pAce);
            if (pObjectType && (guidMember == *pObjectType))
            {
                switch(pAce->AceType)
                {
                case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                    dwInfoMember++;
                    break;

                case ACCESS_DENIED_OBJECT_ACE_TYPE:
                    if (ENCCompareSids(&sidEveryone, pAce))
                    {
                        if (dwInfoMember >= ENC_MINIMUM_ALLOWED)
                            iMemberResult = 1;
                        else
                            iMemberResult = 0;

                        if (-1 != iListObjectResult)
                            dwCurAce = pDacl->AceCount; // Quit the loop
                    }
                    break;
                }
            }
        }

        // Test the "list object"
        if (-1 == iListObjectResult &&
            ACTRL_DS_LIST_OBJECT == ((PKNOWN_ACE)pAce)->Mask)
        {
            switch(pAce->AceType)
            {
            case ACCESS_ALLOWED_ACE_TYPE:
                dwInfoListObject++;
                break;

            case ACCESS_DENIED_ACE_TYPE:
                if (ENCCompareSids(&sidEveryone, pAce))
                {
                    if (dwInfoListObject >= ENC_MINIMUM_ALLOWED)
                        iListObjectResult = 1;
                    else
                        iListObjectResult = 0;

                    if (-1 != iMemberResult)
                        dwCurAce = pDacl->AceCount; // Quit the loop
                }
                break;
            }
        }
    }

    DWORD dwResult = 0;

    if (iMemberResult == 1)
        dwResult |= ENC_RESULT_HIDEMEMBER;

    if (iListObjectResult == 1)
        dwResult |= ENC_RESULT_HIDEOBJECT;

    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\dssec\schema.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       schema.h
//
//--------------------------------------------------------------------------

#ifndef _SCHEMA_CACHE_H_
#define _SCHEMA_CACHE_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Generic Mapping for DS, adapted from \nt\private\ds\src\inc\permit.h
//
#define DS_GENERIC_READ         ((STANDARD_RIGHTS_READ)     | \
                                 (ACTRL_DS_LIST)            | \
                                 (ACTRL_DS_READ_PROP)       | \
                                 (ACTRL_DS_LIST_OBJECT))

#define DS_GENERIC_EXECUTE      ((STANDARD_RIGHTS_EXECUTE)  | \
                                 (ACTRL_DS_LIST))

// Note, STANDARD_RIGHTS_WRITE is specifically NOT included here
#define DS_GENERIC_WRITE        ((ACTRL_DS_SELF)            | \
                                 (ACTRL_DS_WRITE_PROP))

#define DS_GENERIC_ALL          ((STANDARD_RIGHTS_REQUIRED) | \
                                 (ACTRL_DS_CREATE_CHILD)    | \
                                 (ACTRL_DS_DELETE_CHILD)    | \
                                 (ACTRL_DS_DELETE_TREE)     | \
                                 (ACTRL_DS_READ_PROP)       | \
                                 (ACTRL_DS_WRITE_PROP)      | \
                                 (ACTRL_DS_LIST)            | \
                                 (ACTRL_DS_LIST_OBJECT)     | \
                                 (ACTRL_DS_CONTROL_ACCESS)  | \
                                 (ACTRL_DS_SELF))

//
// Flags for SchemaCache_Get****ID
//
#define IDC_CLASS_NO_CREATE     0x00000001
#define IDC_CLASS_NO_DELETE     0x00000002
#define IDC_CLASS_NO_INHERIT    0x00000004
#define IDC_PROP_NO_READ        IDC_CLASS_NO_CREATE
#define IDC_PROP_NO_WRITE       IDC_CLASS_NO_DELETE
#define OTL_ADDED_TO_LIST       0x00000008

#define IDC_CLASS_NONE          (IDC_CLASS_NO_CREATE | IDC_CLASS_NO_DELETE | IDC_CLASS_NO_INHERIT)
#define IDC_PROP_NONE           (IDC_PROP_NO_READ | IDC_PROP_NO_WRITE)

#define SCHEMA_COMMON_PERM      0x80000000
#define SCHEMA_NO_FILTER        0x40000000
#define SCHEMA_CLASS            0x20000000


//
//Purpose: Used to store information about aux class
//
typedef struct _AUX_INFO{
    GUID    guid;                       //Object Type Guid of class
    WCHAR pszClassName[ANYSIZE_ARRAY];  //class Name
}AUX_INFO, *PAUX_INFO;

//
//Purpose: Used to cache Access information passed to get access right
//
typedef struct _ACCESS_INFO{
    GUID ObjectTypeGuid;
    DWORD dwFlags;
    BOOL bLocalFree;
    PSI_ACCESS pAccess;
    ULONG cAccesses;
    ULONG iDefaultAccess;
}ACCESS_INFO, *PACCESS_INFO;

HRESULT SchemaCache_Create(LPCTSTR pszServer);
void SchemaCache_Destroy(void);

HRESULT SchemaCache_GetInheritTypes(LPCGUID pguidObjectType,
                                    DWORD dwFlags,
                                    PSI_INHERIT_TYPE *ppInheritTypes,
                                    ULONG *pcInheritTypes);
HRESULT SchemaCache_GetAccessRights(LPCGUID pguidObjectType,
                                    LPCTSTR pszClassName,   // optional (faster if provided)
                                    HDPA    hAuxList,
                                    LPCTSTR pszSchemaPath,
                                    DWORD dwFlags,  // 0, SI_ADVANCED, or SI_ADVANCED | SI_EDIT_PROPERTIES
                                    PACCESS_INFO* ppAccesInfo);

HRESULT Schema_BindToObject(LPCTSTR pszSchemaPath,
                            LPCTSTR pszName,
                            REFIID riid,
                            LPVOID *ppv);
HRESULT Schema_GetObjectID(IADs *pObj, LPGUID pGUID);

HRESULT Schema_GetDefaultSD( GUID *pSchemaGuid,
                             PSID pDomainSid,
							 PSID pRootDomainSid,
                             PSECURITY_DESCRIPTOR *ppSD = NULL );

HRESULT Schema_GetObjectTypeList(GUID *pSchamaGuid,
                                 HDPA hAuxList,
                                 LPCWSTR pszSchemaPath,
                                 DWORD dwFlags,
                                 POBJECT_TYPE_LIST *ppObjectTypeList, 
                                 DWORD * pObjectTypeListCount);

HRESULT Schema_GetObjectTypeGuid(LPCWSTR pszClassName, LPGUID pGuid);

AUTHZ_RESOURCE_MANAGER_HANDLE Schema_GetAUTHZ_RM();

bool DoesPathContainServer(LPCWSTR pszPath);
HRESULT OpenDSObject (LPTSTR lpPath, LPTSTR lpUserName, LPTSTR lpPassword, DWORD dwFlags, REFIID riid, void FAR * FAR * ppObject);


void
DestroyDPA(HDPA hList);

#ifdef __cplusplus
}
#endif

#endif  // _SCHEMA_CACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\dssec\iids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       iids.h
//
//--------------------------------------------------------------------------

// CLSID_DsSecurity {4E40F770-369C-11d0-8922-00A024AB2DBB}
DEFINE_GUID(CLSID_DsSecurity, 0x4e40f770, 0x369c, 0x11d0, 0x89, 0x22, 0x0, 0xa0, 0x24, 0xab, 0x2d, 0xbb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\dssec\schemap.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       schemap.h
//
//--------------------------------------------------------------------------

#ifndef _SCHEMAP_H_
#define _SCHEMAP_H_


//
//Purpose contains all the attributes of an objecttype
//
typedef struct _OBJECT_TYPE_CACHE
{
    GUID guidObject;
    DWORD flags;
    HDPA hListProperty;     //List of Property of the objecttype
    HDPA hListExtRights;    //List of Extended Rights of the objecttype   
    HDPA hListPropertySet;  //List of PropertySet of the objecttype
    HDPA hListChildObject;  //List of Child Classes of the objecttype
}OBJECT_TYPE_CACHE,*POBJECT_TYPE_CACHE;

#define OTC_PROP    0x00000001  //hListProperty is present.
#define OTC_EXTR    0x00000002  //hListExtRights,hListPropertySet is present
#define OTC_COBJ    0x00000004  //hListChildObject is present

typedef struct _ER_ENTRY
{
    GUID  guid;
    DWORD mask;
    DWORD dwFlags;
    WCHAR szName[ANYSIZE_ARRAY];
} ER_ENTRY, *PER_ENTRY;

typedef struct _PROP_ENTRY
{
    GUID *pguid;
    GUID *pasguid;
    DWORD dwFlags;
    WCHAR szName[ANYSIZE_ARRAY];
}PROP_ENTRY,*PPROP_ENTRY;
    

//
// Structures used by the cache
//
typedef struct _IdCacheEntry
{
    GUID    guid;
    GUID    asGuid;     //attributeSecurityGuid, Present only for properties.
    BOOL    bAuxClass;
    WCHAR   szLdapName[ANYSIZE_ARRAY];
} ID_CACHE_ENTRY, *PID_CACHE_ENTRY;


typedef struct _InheritTypeArray
{
    GUID            guidObjectType;
    DWORD           dwFlags;
    ULONG           cInheritTypes;
    SI_INHERIT_TYPE aInheritType[ANYSIZE_ARRAY];
} INHERIT_TYPE_ARRAY, *PINHERIT_TYPE_ARRAY;

typedef struct _AccessArray
{
    GUID        guidObjectType;
    DWORD       dwFlags;
    ULONG       cAccesses;
    ULONG       iDefaultAccess;
    SI_ACCESS   aAccess[ANYSIZE_ARRAY];
} ACCESS_ARRAY, *PACCESS_ARRAY;



//
// CSchemaCache object definition
//
class CSchemaCache
{
protected:
    BSTR        m_strSchemaSearchPath;
    BSTR        m_strERSearchPath;
    BSTR        m_strFilterFile;
    
    //
    //Cache of all classes in schema
    //
    HDPA        m_hClassCache;
    //
    //Cache of all attributes in schema
    //
    HDPA        m_hPropertyCache;
    HANDLE      m_hClassThread;
    HANDLE      m_hPropertyThread;
    HRESULT     m_hrClassResult;
    HRESULT     m_hrPropertyResult;
    
    PINHERIT_TYPE_ARRAY m_pInheritTypeArray;
    //
    //Cache for each objecttype. Contains lists of 
    //childclasses, propsets, extRigts, & properties
    //
    //
    HDPA        m_hObjectTypeCache;
    //
    //Cache of ACCESS_RIGHT for each object type
    //
    HDPA        m_hAccessInfoCache;
    //
    //This ACCESS_RIGHT is used if SCHEMA_COMMON_PERM flag is present
    //
    ACCESS_INFO m_AICommon;

    CRITICAL_SECTION m_ObjectTypeCacheCritSec;
    int         m_nDsListObjectEnforced;    
    HANDLE      m_hLoadLibPropWaitEvent;
    HANDLE      m_hLoadLibClassWaitEvent;
    AUTHZ_RESOURCE_MANAGER_HANDLE m_ResourceManager;    //Used for access check

public:
    CSchemaCache(LPCWSTR pszServer);
    ~CSchemaCache();

    LPCWSTR GetClassName(LPCGUID pguidObjectType);
    HRESULT GetInheritTypes(LPCGUID pguidObjectType,
                            DWORD dwFlags,
                            PSI_INHERIT_TYPE *ppInheritTypes,
                            ULONG *pcInheritTypes);
    HRESULT GetAccessRights(LPCGUID pguidObjectType,
                            LPCWSTR pszClassName,
                            HDPA pAuxList,
                            LPCWSTR pszSchemaPath,
                            DWORD dwFlags,
                            PACCESS_INFO* ppAccesInfo);
    HRESULT GetDefaultSD( GUID *pSchemaIDGuid,
                          PSID pDomainSid,
						  PSID pRootDomainSid,
                          PSECURITY_DESCRIPTOR * ppSD = NULL );

    HRESULT GetObjectTypeList(GUID *pSchamaGuid,
                              HDPA hAuxList,  
                              LPCWSTR pszSchemaPath,
                              DWORD dwFlags,
                              POBJECT_TYPE_LIST *ppObjectTypeList ,
                              DWORD * pObjectTypeListCount );
    AUTHZ_RESOURCE_MANAGER_HANDLE GetAuthzRM(){ return m_ResourceManager; }

    HRESULT LookupClassID(LPCWSTR pszClass, LPGUID pGuid);
protected:
    HRESULT WaitOnClassThread()
        { WaitOnThread(&m_hClassThread); return m_hrClassResult; }
    HRESULT WaitOnPropertyThread()
        { WaitOnThread(&m_hPropertyThread); return m_hrPropertyResult; }

private:
    PID_CACHE_ENTRY LookupID(HDPA hCache, LPCWSTR pszLdapName);
    PID_CACHE_ENTRY LookupClass(LPCGUID pguidObjectType);    
    LPCGUID LookupPropertyID(LPCWSTR pszProperty);
    BOOL IsAuxClass(LPCGUID pguidObjectType);

    int GetListObjectEnforced(void);
    BOOL HideListObjectAccess(void);

    HRESULT BuildAccessArray(LPCGUID pguidObjectType,
                             LPCWSTR pszClassName,
                             LPCWSTR pszSchemaPath,
                             HDPA hAuxList,
                             DWORD dwFlags,
                             PSI_ACCESS *ppAccesses,
                             ULONG *pcAccesses,
                             ULONG *piDefaultAccess);
    HRESULT EnumVariantList(LPVARIANT pvarList,
                            HDPA hTempList,
                            DWORD dwFlags,
                            IDsDisplaySpecifier *pDisplaySpec,
                            LPCWSTR pszPropertyClass,
                            BOOL bObjectTypeList);
    
    UINT AddTempListToAccessList(HDPA hTempList,
                                      PSI_ACCESS *ppAccess,
                                      LPWSTR *ppszData,
                                      DWORD dwAccessFlags,
                                      DWORD dwFlags,
                                      BOOL bPropSet);


    static DWORD WINAPI SchemaClassThread(LPVOID pvThreadData);
    static DWORD WINAPI SchemaPropertyThread(LPVOID pvThreadData);

    HRESULT BuildInheritTypeArray(DWORD dwFlags);

    HRESULT
    GetExtendedRightsForNClasses(IN LPWSTR pszSchemaSearchPath,
                                 IN LPCGUID pguidClass,
                                 IN HDPA    hAuxList,
                                 OUT HDPA *phERList,
                                 OUT HDPA *phPropSetList);


    HRESULT
    GetChildClassesForNClasses(IN LPCGUID pguidObjectType,
                               IN LPCWSTR pszClassName,
                               IN HDPA hAuxList,
                               IN LPCWSTR pszSchemaPath,
                               OUT HDPA *phChildList);

    HRESULT
    GetPropertiesForNClasses(IN LPCGUID pguidObjectType,
                             IN LPCWSTR pszClassName,
                             IN HDPA hAuxList,
                             IN LPCWSTR pszSchemaPath,
                             OUT HDPA *phPropertyList);


    HRESULT
    GetExtendedRightsForOneClass(IN LPWSTR pszSchemaSearchPath,
                                 IN LPCGUID pguidClass,
                                 OUT HDPA *phERList,
                                 OUT HDPA *phPropSetList);


    HRESULT
    GetChildClassesForOneClass(IN LPCGUID pguidObjectType,
                               IN LPCWSTR pszClassName,
                               IN LPCWSTR pszSchemaPath,
                               OUT HDPA *phChildList);

    HRESULT
    GetPropertiesForOneClass(IN LPCGUID pguidObjectType,
                             IN LPCWSTR pszClassName,
                             IN LPCWSTR pszSchemaPath,
                             OUT HDPA *phPropertyList);


};
typedef CSchemaCache *PSCHEMACACHE;

extern PSCHEMACACHE g_pSchemaCache;

#endif  // _SCHEMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\dssec\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_SECURITY                    0
#define IDS_SECURITYHELP                1
#define IDS_NO_ACCESS                   2
#define IDS_DS_CONTAINER_ONLY           3
#define IDS_DS_CONTAINER_SUBITEMS       4
#define IDS_DS_SUBITEMS_ONLY            5
#define IDS_DS_INHERIT_TYPE             6
#define IDS_DS_CREATE_CHILD_TYPE        7
#define IDS_DS_DELETE_CHILD_TYPE        8
#define IDS_DS_READ_PROP_TYPE           9
#define IDS_DS_WRITE_PROP_TYPE          10
#define IDS_DS_READWRITE_TYPE           11
#define IDS_DS_CREATEDELETE_TYPE        12
#define IDS_SPECIAL_SECURITY_TITLE      14
#define IDS_SPECIAL_ACL_WARNING         15
#define IDS_ACTRL_DELETE                16
#define IDS_ACTRL_READ_CONTROL          17
#define IDS_ACTRL_CHANGE_ACCESS         18
#define IDS_ACTRL_CHANGE_OWNER          19
#define IDS_ACTRL_DS_CREATE_CHILD       20
#define IDS_ACTRL_DS_DELETE_CHILD       21
#define IDS_ACTRL_DS_LIST               22
#define IDS_ACTRL_DS_SELF               23
#define IDS_ACTRL_DS_READ_PROP          24
#define IDS_ACTRL_DS_WRITE_PROP         25
#define IDS_ACTRL_DS_DELETE_TREE        26
#define IDS_ACTRL_DS_LIST_OBJECT        27
#define IDS_ACTRL_DS_CONTROL_ACCESS     28
#define IDS_DS_GENERIC_READ             32
#define IDS_DS_GENERIC_WRITE            33
#define IDS_DS_GENERIC_EXECUTE          34
#define IDS_DS_GENERIC_ALL              35
#define IDS_ACTRL_DS_READ_WRITE_PROP    36
#define IDS_ACTRL_DS_CREATE_DELETE_CHILD 37

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        126
#define _APS_NEXT_COMMAND_VALUE         40008
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\dssec\schema.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       schema.cpp
//
//  This file contains the implementation of the Schema Cache
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "sddl.h"
#include "sddlp.h"

//
// CSchemaCache object definition
//
#include "schemap.h"

PSCHEMACACHE g_pSchemaCache = NULL;


//
// Page size used for paging query result sets (better performance)
//
#define PAGE_SIZE       16

//
// The following array defines the permission names for DS objects.
//
SI_ACCESS g_siDSAccesses[] =
{
    { &GUID_NULL, DS_GENERIC_ALL,           MAKEINTRESOURCE(IDS_DS_GENERIC_ALL),        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, DS_GENERIC_READ,          MAKEINTRESOURCE(IDS_DS_GENERIC_READ),       SI_ACCESS_GENERAL },
    { &GUID_NULL, DS_GENERIC_WRITE,         MAKEINTRESOURCE(IDS_DS_GENERIC_WRITE),      SI_ACCESS_GENERAL },
    { &GUID_NULL, ACTRL_DS_LIST,            MAKEINTRESOURCE(IDS_ACTRL_DS_LIST),         SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACTRL_DS_LIST_OBJECT,     MAKEINTRESOURCE(IDS_ACTRL_DS_LIST_OBJECT),  SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACTRL_DS_READ_PROP,       MAKEINTRESOURCE(IDS_ACTRL_DS_READ_PROP),    SI_ACCESS_SPECIFIC | SI_ACCESS_PROPERTY },
    { &GUID_NULL, ACTRL_DS_WRITE_PROP,      MAKEINTRESOURCE(IDS_ACTRL_DS_WRITE_PROP),   SI_ACCESS_SPECIFIC | SI_ACCESS_PROPERTY },
    { &GUID_NULL, ACTRL_DS_WRITE_PROP|ACTRL_DS_READ_PROP, MAKEINTRESOURCE(IDS_ACTRL_DS_READ_WRITE_PROP),   },
    { &GUID_NULL, DELETE,                   MAKEINTRESOURCE(IDS_ACTRL_DELETE),          SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACTRL_DS_DELETE_TREE,     MAKEINTRESOURCE(IDS_ACTRL_DS_DELETE_TREE),  SI_ACCESS_SPECIFIC },
    { &GUID_NULL, READ_CONTROL,             MAKEINTRESOURCE(IDS_ACTRL_READ_CONTROL),    SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_DAC,                MAKEINTRESOURCE(IDS_ACTRL_CHANGE_ACCESS),   SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_OWNER,              MAKEINTRESOURCE(IDS_ACTRL_CHANGE_OWNER),    SI_ACCESS_SPECIFIC },
    { &GUID_NULL, 0,                        MAKEINTRESOURCE(IDS_NO_ACCESS),             0 },
    { &GUID_NULL, ACTRL_DS_SELF,            MAKEINTRESOURCE(IDS_ACTRL_DS_SELF),         SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACTRL_DS_CONTROL_ACCESS,  MAKEINTRESOURCE(IDS_ACTRL_DS_CONTROL_ACCESS),SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACTRL_DS_CREATE_CHILD,    MAKEINTRESOURCE(IDS_ACTRL_DS_CREATE_CHILD), SI_ACCESS_CONTAINER | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACTRL_DS_DELETE_CHILD,    MAKEINTRESOURCE(IDS_ACTRL_DS_DELETE_CHILD), SI_ACCESS_CONTAINER | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACTRL_DS_DELETE_CHILD|ACTRL_DS_CREATE_CHILD,    MAKEINTRESOURCE(IDS_ACTRL_DS_CREATE_DELETE_CHILD), 0 },  //This won't show up as checkbox but used to display in advanced page.
};
#define g_iDSRead       1   // DS_GENERIC_READ
#define g_iDSListObject 4   // ACTRL_DS_LIST_OBJECT
#define g_iDSProperties 5   // Read/Write properties
#define g_iDSDefAccess  g_iDSRead
#define g_iDSAllExtRights 15
#define g_iDSAllValRights 14
#define g_iDSDeleteTree	  9


//
// The following array defines the inheritance types common to all DS containers.
//
SI_INHERIT_TYPE g_siDSInheritTypes[] =
{
    { &GUID_NULL, 0,                                        MAKEINTRESOURCE(IDS_DS_CONTAINER_ONLY)     },
    { &GUID_NULL, CONTAINER_INHERIT_ACE,                    MAKEINTRESOURCE(IDS_DS_CONTAINER_SUBITEMS) },
    { &GUID_NULL, CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE, MAKEINTRESOURCE(IDS_DS_SUBITEMS_ONLY)      },
};

//
//Used to store some temp info
//
typedef struct _temp_info
{
    LPCGUID pguid;
    DWORD   dwFilter;
    LPCWSTR pszLdapName;
    WCHAR   szDisplayName[ANYSIZE_ARRAY];
} TEMP_INFO, *PTEMP_INFO;


//
// Helper functions for cleaning up DPA lists
//
int CALLBACK
_LocalFreeCB(LPVOID pVoid, LPVOID /*pData*/)
{
    LocalFree(pVoid);
    return 1;
}

void
DestroyDPA(HDPA hList)
{
    if (hList != NULL)
        DPA_DestroyCallback(hList, _LocalFreeCB, 0);
}
//
// Callback function for merging. Passed to DPA_Merge
//
LPVOID CALLBACK _Merge(UINT , LPVOID pvDest, LPVOID , LPARAM )
{
    return pvDest;
}

BSTR
GetFilterFilePath(void)
{
    WCHAR szFilterFile[MAX_PATH];
    UINT cch = GetSystemDirectory(szFilterFile, ARRAYSIZE(szFilterFile));
    if (0 == cch || cch >= ARRAYSIZE(szFilterFile))
        return NULL;
    if (szFilterFile[cch-1] != L'\\')
        szFilterFile[cch++] = L'\\';
    lstrcpynW(szFilterFile + cch, c_szFilterFile, ARRAYSIZE(szFilterFile) - cch);
    return SysAllocString(szFilterFile);
}


//
// Local prototypes
//
HRESULT
Schema_Search(LPWSTR pszSchemaSearchPath,
              LPCWSTR pszFilter,
              HDPA *phCache,
              BOOL bProperty);

//
// C wrappers for the schema cache object
//
HRESULT
SchemaCache_Create(LPCWSTR pszServer)
{
    HRESULT hr = S_OK;

    if (g_pSchemaCache == NULL)
    {
        g_pSchemaCache = new CSchemaCache(pszServer);

        if (g_pSchemaCache  == NULL)
            hr = E_OUTOFMEMORY;
    }

    return hr;
}


void
SchemaCache_Destroy(void)
{
    delete g_pSchemaCache;
    g_pSchemaCache = NULL;
}


HRESULT
SchemaCache_GetInheritTypes(LPCGUID pguidObjectType,
                            DWORD dwFlags,
                            PSI_INHERIT_TYPE *ppInheritTypes,
                            ULONG *pcInheritTypes)
{
    HRESULT hr = E_UNEXPECTED;

    if (g_pSchemaCache)
        hr = g_pSchemaCache->GetInheritTypes(pguidObjectType, dwFlags, ppInheritTypes, pcInheritTypes);

    return hr;
}


HRESULT
SchemaCache_GetAccessRights(LPCGUID pguidObjectType,
                            LPCWSTR pszClassName,
                            HDPA     hAuxList,
                            LPCWSTR pszSchemaPath,
                            DWORD dwFlags,
                            PACCESS_INFO* ppAccesInfo)
{
    HRESULT hr = E_UNEXPECTED;

    if (g_pSchemaCache)
        hr = g_pSchemaCache->GetAccessRights(pguidObjectType,
                                             pszClassName,
                                             hAuxList,
                                             pszSchemaPath,
                                             dwFlags,
                                             ppAccesInfo);
    return hr;
}


HRESULT
Schema_GetDefaultSD( GUID *pSchemaIdGuid,
                     PSID pDomainSid,
					 PSID pRootDomainSid,
                     PSECURITY_DESCRIPTOR *ppSD )
{
    HRESULT hr = E_UNEXPECTED;
    if( g_pSchemaCache )
        hr = g_pSchemaCache->GetDefaultSD(pSchemaIdGuid, 
										  pDomainSid, 
										  pRootDomainSid, 
										  ppSD);

    return hr;

}


HRESULT Schema_GetObjectTypeList(GUID *pSchamaGuid,
                                 HDPA hAuxList,
                                 LPCWSTR pszSchemaPath,
                                 DWORD dwFlags,
                                 POBJECT_TYPE_LIST *ppObjectTypeList, 
                                 DWORD * pObjectTypeListCount)
{
    HRESULT hr = E_UNEXPECTED;
    if( g_pSchemaCache )
        hr = g_pSchemaCache->GetObjectTypeList( pSchamaGuid,
                                                hAuxList,
                                                pszSchemaPath,
                                                dwFlags,
                                                ppObjectTypeList, 
                                                pObjectTypeListCount);

    return hr;

}


HRESULT Schema_GetObjectTypeGuid(LPCWSTR pszClassName, LPGUID pGuid)
{
   
    if( g_pSchemaCache )
        return g_pSchemaCache->LookupClassID(pszClassName, pGuid);
    else
        return E_UNEXPECTED;
}

AUTHZ_RESOURCE_MANAGER_HANDLE Schema_GetAUTHZ_RM()
{
    if( g_pSchemaCache )
        return g_pSchemaCache->GetAuthzRM();

    return NULL;
}

//
// DPA comparison functions used for sorting and searching the cache lists
//
int CALLBACK
Schema_CompareLdapName(LPVOID p1, LPVOID p2, LPARAM lParam)
{
    int nResult = 0;
    PID_CACHE_ENTRY pEntry1 = (PID_CACHE_ENTRY)p1;
    PID_CACHE_ENTRY pEntry2 = (PID_CACHE_ENTRY)p2;
    LPCWSTR pszFind = (LPCWSTR)lParam;

    if (pEntry1)
        pszFind = pEntry1->szLdapName;

    if (pszFind && pEntry2)
    {
        nResult = CompareStringW(LOCALE_USER_DEFAULT,
                                 0,
                                 pszFind,
                                 -1,
                                 pEntry2->szLdapName,
                                 -1) - CSTR_EQUAL;
    }

    return nResult;
}


//
// Callback function used to sort based on display name
//
int CALLBACK
Schema_CompareTempDisplayName(LPVOID p1, LPVOID p2, LPARAM )
{
    int nResult = 0;
    PTEMP_INFO pti1 = (PTEMP_INFO)p1;
    PTEMP_INFO pti2 = (PTEMP_INFO)p2;

    if (pti1 && pti2)
    {
        LPCWSTR psz1 = pti1->szDisplayName;
        LPCWSTR psz2 = pti2->szDisplayName;

        if (!*psz1)
            psz1 = pti1->pszLdapName;
        if (!*psz2)
            psz2 = pti2->pszLdapName;

        // Note that we are sorting backwards
        nResult = CompareStringW(LOCALE_USER_DEFAULT,
                                 0,
                                 (LPCWSTR)psz2,
                                 -1,
                                 (LPCWSTR)psz1,
                                 -1) - CSTR_EQUAL;
    }

    return nResult;
}

//
// Callback function used to sort based on display name
//
int CALLBACK
Schema_ComparePropDisplayName(LPVOID p1, LPVOID p2, LPARAM )
{
    int nResult = 0;
    PPROP_ENTRY pti1 = (PPROP_ENTRY)p1;
    PPROP_ENTRY pti2 = (PPROP_ENTRY)p2;

    if (pti1 && pti2)
    {
        LPCWSTR psz1 = pti1->szName;
        LPCWSTR psz2 = pti2->szName;

        nResult = CompareStringW(LOCALE_USER_DEFAULT,
                                 0,
                                 (LPCWSTR)psz1,
                                 -1,
                                 (LPCWSTR)psz2,
                                 -1) - CSTR_EQUAL;
    }

    return nResult;
}

//
// DPA comparison function used for sorting the Extended Rights list
//
int CALLBACK
Schema_CompareER(LPVOID p1, LPVOID p2, LPARAM /*lParam*/)
{
    int nResult = 0;
    PER_ENTRY pEntry1 = (PER_ENTRY)p1;
    PER_ENTRY pEntry2 = (PER_ENTRY)p2;

    if (pEntry1 && pEntry2)
    {
        nResult = CompareStringW(LOCALE_USER_DEFAULT,
                                 0,
                                 pEntry1->szName,
                                 -1,
                                 pEntry2->szName,
                                 -1) - CSTR_EQUAL;

    }

    return nResult;
}



//
// CSchemaCache object implementation
//
CSchemaCache::CSchemaCache(LPCWSTR pszServer)
{
    HRESULT hr;
    IADsPathname *pPath = NULL;
    BSTR strRootDSEPath = NULL;
    IADs *pRootDSE = NULL;
    VARIANT var = {0};
    DWORD dwThreadID;
    HANDLE ahWait[2];
    TraceEnter(TRACE_SCHEMA, "CSchemaCache::CSchemaCache");

    // Initialize everything
    ZeroMemory(this, sizeof(CSchemaCache));
    m_hrClassResult = E_UNEXPECTED;
    m_hrPropertyResult = E_UNEXPECTED;
    m_nDsListObjectEnforced = -1;        
    m_hLoadLibPropWaitEvent = NULL;
    m_hLoadLibClassWaitEvent = NULL;

    m_AICommon.pAccess = g_siDSAccesses;    
    m_AICommon.cAccesses = ARRAYSIZE(g_siDSAccesses);
    m_AICommon.iDefaultAccess = g_iDSDefAccess; 
    m_AICommon.bLocalFree = FALSE;


    m_hClassCache = NULL;
    m_hPropertyCache = NULL;    
    m_pInheritTypeArray = NULL;
    m_hObjectTypeCache = NULL;
    m_hAccessInfoCache = NULL;

    ExceptionPropagatingInitializeCriticalSection(&m_ObjectTypeCacheCritSec);

    
    if (pszServer && !*pszServer)
        pszServer = NULL;

    // Create a path object for manipulating ADS paths
    hr = CoCreateInstance(CLSID_Pathname,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IADsPathname,
                          (LPVOID*)&pPath);
    FailGracefully(hr, "Unable to create ADsPathname object");

    // Build RootDSE path with server
    hr = pPath->Set((LPWSTR)c_szRootDsePath, ADS_SETTYPE_FULL);
    FailGracefully(hr, "Unable to initialize path object");
    if (pszServer)
    {
        hr = pPath->Set((LPWSTR)pszServer, ADS_SETTYPE_SERVER);
        FailGracefully(hr, "Unable to initialize path object");
    }
    hr = pPath->Retrieve(ADS_FORMAT_WINDOWS, &strRootDSEPath);
    FailGracefully(hr, "Unable to retrieve RootDSE path from path object");

    // Bind to the RootDSE object
    hr = OpenDSObject(strRootDSEPath,
                       NULL,
                       NULL,
                       ADS_SECURE_AUTHENTICATION,
                       IID_IADs,
                       (LPVOID*)&pRootDSE);
    if (FAILED(hr) && pszServer)
    {
        // Try again with no server
        SysFreeString(strRootDSEPath);

        hr = pPath->Retrieve(ADS_FORMAT_WINDOWS_NO_SERVER, &strRootDSEPath);
        FailGracefully(hr, "Unable to retrieve RootDSE path from path object");

        hr = OpenDSObject(strRootDSEPath,
                           NULL,
                           NULL,
                           ADS_SECURE_AUTHENTICATION,
                           IID_IADs,
                           (LPVOID*)&pRootDSE);
    }
    FailGracefully(hr, "Failed to bind to root DSE");

    // Build the schema root path
    hr = pRootDSE->Get((LPWSTR)c_szSchemaContext, &var);
    FailGracefully(hr, "Unable to get schema naming context");

    TraceAssert(V_VT(&var) == VT_BSTR);
    hr = pPath->Set(V_BSTR(&var), ADS_SETTYPE_DN);
    FailGracefully(hr, "Unable to initialize path object");

    hr = pPath->Retrieve(ADS_FORMAT_WINDOWS, &m_strSchemaSearchPath);
    FailGracefully(hr, "Unable to retrieve schema search path from path object");

    // Build the Extended Rights container path
    VariantClear(&var);
    hr = pRootDSE->Get((LPWSTR)c_szConfigContext, &var);
    FailGracefully(hr, "Unable to get configuration naming context");

    TraceAssert(V_VT(&var) == VT_BSTR);
    hr = pPath->Set(V_BSTR(&var), ADS_SETTYPE_DN);
    FailGracefully(hr, "Unable to initialize path object");

    hr = pPath->AddLeafElement((LPWSTR)c_szERContainer);
    FailGracefully(hr, "Unable to build Extended Rights path");

    hr = pPath->Retrieve(ADS_FORMAT_WINDOWS, &m_strERSearchPath);
    FailGracefully(hr, "Unable to retrieve Extended Rights search path from path object");
    
    //Create the Events
    m_hLoadLibPropWaitEvent = CreateEvent(NULL,
                                          TRUE,
                                          FALSE,
                                          NULL );
    m_hLoadLibClassWaitEvent = CreateEvent(NULL,
                                          TRUE,
                                          FALSE,
                                          NULL );


    if( m_hLoadLibPropWaitEvent && m_hLoadLibClassWaitEvent )
    {
        // Start a thread to enumerate the schema classes
        m_hClassThread = CreateThread(NULL,
                                      0,
                                      SchemaClassThread,
                                      this,
                                      0,
                                      &dwThreadID);

        // Start a thread to enumerate the schema properties
        m_hPropertyThread = CreateThread(NULL,
                                         0,
                                         SchemaPropertyThread,
                                         this,
                                         0,
                                         &dwThreadID);



        ahWait[0] = m_hClassThread;
        ahWait[1] = m_hPropertyThread;

        WaitForMultipleObjects(2,
                               ahWait,
                               TRUE,
                               INFINITE);
    }

exit_gracefully:

    VariantClear(&var);
    DoRelease(pRootDSE);
    DoRelease(pPath);
    SysFreeString(strRootDSEPath);
    if( m_hLoadLibPropWaitEvent )
        CloseHandle( m_hLoadLibPropWaitEvent );
    if( m_hLoadLibClassWaitEvent )
        CloseHandle( m_hLoadLibClassWaitEvent );


    TraceLeaveVoid();
}


CSchemaCache::~CSchemaCache()
{

    TraceEnter(TRACE_SCHEMA, "CSchemaCache::~CSchemaCache");

    SysFreeString(m_strSchemaSearchPath);
    SysFreeString(m_strERSearchPath);
    SysFreeString(m_strFilterFile);
    DeleteCriticalSection(&m_ObjectTypeCacheCritSec);

    DestroyDPA(m_hClassCache);
    DestroyDPA(m_hPropertyCache);
    if(m_hObjectTypeCache)
    {
        POBJECT_TYPE_CACHE pOTC = NULL;
        UINT cCount = DPA_GetPtrCount(m_hObjectTypeCache);
        for(UINT i = 0; i < cCount; ++i)
        {
            pOTC = (POBJECT_TYPE_CACHE)DPA_FastGetPtr(m_hObjectTypeCache, i);
            if(pOTC)
            {
                DestroyDPA(pOTC->hListChildObject);
                DestroyDPA(pOTC->hListExtRights);
                DestroyDPA(pOTC->hListProperty);
                DestroyDPA(pOTC->hListPropertySet);    
            }
        }
    }
    DestroyDPA(m_hObjectTypeCache);    

    if (m_hAccessInfoCache != NULL)
    {
        UINT cItems = DPA_GetPtrCount(m_hAccessInfoCache);
        PACCESS_INFO pAI = NULL;
        while (cItems > 0)
        {
            pAI = (PACCESS_INFO)DPA_FastGetPtr(m_hAccessInfoCache, --cItems);
            if(pAI && pAI->pAccess)
                LocalFree(pAI->pAccess);            
        }
    }
    DestroyDPA(m_hAccessInfoCache);        
        
    if (m_pInheritTypeArray != NULL)
        LocalFree(m_pInheritTypeArray);

    TraceMsg("CSchemaCache::~CSchemaCache exiting");
    TraceLeaveVoid();
}


LPCWSTR
CSchemaCache::GetClassName(LPCGUID pguidObjectType)
{
    LPCWSTR pszLdapName = NULL;
    PID_CACHE_ENTRY pCacheEntry;

    TraceEnter(TRACE_SCHEMACLASS, "CSchemaCache::GetClassName");

    pCacheEntry = LookupClass(pguidObjectType);

    if (pCacheEntry != NULL)
        pszLdapName = pCacheEntry->szLdapName;

    TraceLeaveValue(pszLdapName);
}


HRESULT
CSchemaCache::GetInheritTypes(LPCGUID ,
                              DWORD dwFlags,
                              PSI_INHERIT_TYPE *ppInheritTypes,
                              ULONG *pcInheritTypes)
{
    // We're going to find the inherit type array corresponding to the passed-in
    // object type - pInheritTypeArray will point to it!
    TraceEnter(TRACE_SCHEMACLASS, "CSchemaCache::GetInheritTypes");
    TraceAssert(ppInheritTypes != NULL);
    TraceAssert(pcInheritTypes != NULL);

    *pcInheritTypes = 0;
    *ppInheritTypes = NULL;

    // If the filter state is changing, free everything
    if (m_pInheritTypeArray &&
        (m_pInheritTypeArray->dwFlags & SCHEMA_NO_FILTER) != (dwFlags & SCHEMA_NO_FILTER))
    {
        LocalFree(m_pInheritTypeArray);
        m_pInheritTypeArray = NULL;
    }

    // Build m_pInheritTypeArray if necessary
    if (m_pInheritTypeArray == NULL)
    {
        BuildInheritTypeArray(dwFlags);
    }

    // Return m_pInheritTypeArray if we have it, otherwise
    // fall back on the static types
    if (m_pInheritTypeArray)
    {
        *pcInheritTypes = m_pInheritTypeArray->cInheritTypes;
        *ppInheritTypes = m_pInheritTypeArray->aInheritType;
    }
    else
    {
        TraceMsg("Returning default inherit information");
        *ppInheritTypes = g_siDSInheritTypes;
        *pcInheritTypes = ARRAYSIZE(g_siDSInheritTypes);
    }

    TraceLeaveResult(S_OK); // always succeed
}


HRESULT
CSchemaCache::GetAccessRights(LPCGUID pguidObjectType,
                              LPCWSTR pszClassName,
                              HDPA hAuxList,
                              LPCWSTR pszSchemaPath,
                              DWORD dwFlags,
                              PACCESS_INFO *ppAccessInfo)
{
    HRESULT hr = S_OK;
    HCURSOR hcur;

    TraceEnter(TRACE_SCHEMA, "CSchemaCache::GetAccessRights");
    TraceAssert(ppAccessInfo);


    BOOL bAddToCache = FALSE;
    PACCESS_INFO pAI = NULL;
    //
    // If the SCHEMA_COMMON_PERM flag is on, just return the permissions
    // that are common to all DS objects (including containers).
    //
    if (dwFlags & SCHEMA_COMMON_PERM)
    {        
        *ppAccessInfo = &m_AICommon;
        TraceLeaveResult(S_OK);
    }

    TraceAssert(pguidObjectType);
        
    EnterCriticalSection(&m_ObjectTypeCacheCritSec);


    //
    //If AuxList is null, we can return the item from cache
    //
    if(hAuxList == NULL)
    {
        //There is no Aux Class. Check the m_hAccessInfoCache if we have access right
        //for the pguidObjectType;
        if (m_hAccessInfoCache != NULL)
        {
            UINT cItems = DPA_GetPtrCount(m_hAccessInfoCache);

            while (cItems > 0)
            {
                pAI = (PACCESS_INFO)DPA_FastGetPtr(m_hAccessInfoCache, --cItems);
                //
                //Found A match.
                //
                if(pAI && 
                   IsEqualGUID(pAI->ObjectTypeGuid, *pguidObjectType) &&
                   ((pAI->dwFlags & (SI_EDIT_PROPERTIES | SI_EDIT_EFFECTIVE)) == 
                    (dwFlags & (SI_EDIT_PROPERTIES | SI_EDIT_EFFECTIVE))))    

                    break;

                pAI = NULL;
            }
            
            if(pAI)
            {
                goto exit_gracefully;    
            }
        }
        bAddToCache = TRUE;
    }
    
    pAI = (PACCESS_INFO)LocalAlloc(LPTR,sizeof(ACCESS_INFO));
    if(!pAI)
        ExitGracefully(hr, E_OUTOFMEMORY, "LocalAlloc failed");
    
    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    hr = BuildAccessArray(pguidObjectType,
                          pszClassName,
                          pszSchemaPath,
                          hAuxList,
                          dwFlags,
                          &pAI->pAccess,
                          &pAI->cAccesses,
                          &pAI->iDefaultAccess);
    FailGracefully(hr, "BuildAccessArray Failed");

    if(bAddToCache)
    {
        if(!m_hAccessInfoCache)
            m_hAccessInfoCache = DPA_Create(4);
    
        if(!m_hAccessInfoCache)
            ExitGracefully(hr, E_OUTOFMEMORY, "DPA_Create Failed");

        pAI->dwFlags = dwFlags;
        pAI->ObjectTypeGuid = *pguidObjectType;
        DPA_AppendPtr(m_hAccessInfoCache, pAI);
    }
    
    //
    //If item is added to cache, don't localfree it. It will be free when 
    //DLL is unloaded
    //
    pAI->bLocalFree = !bAddToCache;
    
    SetCursor(hcur);

exit_gracefully:

    if(FAILED(hr))
    {
        if(pAI)
        {
            LocalFree(pAI);
            pAI = NULL;
        }
    }

    *ppAccessInfo = pAI;

    LeaveCriticalSection(&m_ObjectTypeCacheCritSec);

    TraceLeaveResult(hr);
}

 

HRESULT 
CSchemaCache::GetDefaultSD(GUID *pSchemaIDGuid, 
						   PSID pDomainSid, 
						   PSID pRootDomainSid, 
						   PSECURITY_DESCRIPTOR *ppSD)
{
    TraceEnter(TRACE_SCHEMA, "CSchemaCache::GetDefaultSD");
    TraceAssert( pSchemaIDGuid != NULL);
    TraceAssert( ppSD != NULL );

    HRESULT hr = S_OK;

	if( (pDomainSid && !IsValidSid(pDomainSid)) ||
		 (pRootDomainSid && !IsValidSid(pRootDomainSid)) )
		 return E_INVALIDARG;

    LPWSTR pszDestData = NULL;
    IDirectorySearch * IDs = NULL;
    ADS_SEARCH_HANDLE hSearchHandle=NULL;  
    LPWSTR lpszSchemaGuidFilter = L"(schemaIdGuid=%s)";
    LPWSTR pszAttr[] = {L"defaultSecurityDescriptor"};
    ADS_SEARCH_COLUMN col;
    WCHAR szSearchBuffer[MAX_PATH];

    hr = ADsEncodeBinaryData( (PBYTE)pSchemaIDGuid,
                          sizeof(GUID),
                          &pszDestData  );
    FailGracefully(hr, "ADsEncodeBinaryData Failed");
    
    wsprintf(szSearchBuffer, lpszSchemaGuidFilter,pszDestData);
    
   
   //We have Filter Now

   //Search in Configuration Contianer
    hr = OpenDSObject(  m_strSchemaSearchPath,
                         NULL,
                         NULL,
                         ADS_SECURE_AUTHENTICATION,
                         IID_IDirectorySearch,
                         (void **)&IDs );
    FailGracefully(hr, "OpenDSObject Failed");

    hr = IDs->ExecuteSearch(szSearchBuffer,
                           pszAttr,
                           1,
                           &hSearchHandle );

    FailGracefully(hr, "Search in Schema  Failed");


    hr = IDs->GetFirstRow(hSearchHandle);
    if( hr == S_OK )
    {  
        //Get Guid
        hr = IDs->GetColumn( hSearchHandle, pszAttr[0], &col );
        FailGracefully(hr, "Failed to get column from search result");

        if(pDomainSid && pRootDomainSid)
        {
            if(!ConvertStringSDToSDDomain(pDomainSid,
                                          pRootDomainSid,
                                          (LPCWSTR)(LPWSTR)col.pADsValues->CaseIgnoreString,
                                          SDDL_REVISION_1,
                                          ppSD,
                                          NULL )) 
            {
                hr = GetLastError();
                IDs->FreeColumn( &col );
                ExitGracefully(hr, E_FAIL, "Unable to convert String SD to SD");
            }
        }
        else
        {
            if ( !ConvertStringSecurityDescriptorToSecurityDescriptor( (LPCWSTR)(LPWSTR)col.pADsValues->CaseIgnoreString,
                                                                        SDDL_REVISION_1,
                                                                        ppSD,
                                                                        NULL ) ) 
            {
                hr = GetLastError();
                IDs->FreeColumn( &col );
                ExitGracefully(hr, E_FAIL, "Unable to convert String SD to SD");
            }
        }
        IDs->FreeColumn( &col );         
    }
    else
        ExitGracefully(hr, E_FAIL, "Schema search resulted in zero rows");
    
    

exit_gracefully:

    if( IDs )
    {
      if( hSearchHandle )
         IDs->CloseSearchHandle( hSearchHandle );
      IDs->Release();
    }
    FreeADsMem(pszDestData);
    TraceLeaveResult(hr);
}



VOID AddOTLToList( POBJECT_TYPE_LIST pOTL, WORD Level, LPGUID pGuidObject )
{
    (pOTL)->Level = Level;
    (pOTL)->ObjectType = pGuidObject;
}

//Get the ObjectTypeList for pSchemaGuid class

OBJECT_TYPE_LIST g_DefaultOTL[] = {
                                    {0, 0, (LPGUID)&GUID_NULL},
                                  };
HRESULT
CSchemaCache::GetObjectTypeList( GUID *pguidObjectType,
                                 HDPA hAuxList,
                                 LPCWSTR pszSchemaPath,
                                 DWORD dwFlags,
                                 POBJECT_TYPE_LIST *ppObjectTypeList,                                  
                                 DWORD * pObjectTypeListCount)
{
    TraceEnter(TRACE_SCHEMA, "CSchemaCache::GetObjectTypeList");
    TraceAssert( pguidObjectType != NULL);
    TraceAssert( ppObjectTypeList != NULL );
    TraceAssert( pObjectTypeListCount != NULL );
    TraceAssert(pszSchemaPath != NULL);


    HRESULT hr = S_OK;
    //
    //Lists
    //
    HDPA hExtRightList = NULL;
    HDPA hPropSetList = NULL;
    HDPA hPropertyList = NULL;
    HDPA hClassList = NULL;
    //
    //List counts
    //
    ULONG cExtendedRights = 0;
    ULONG cPropertySets = 0;
    UINT cProperties = 0;
    UINT cChildClasses = 0;

    POBJECT_TYPE_LIST pOTL = NULL;
    POBJECT_TYPE_LIST pTempOTL = NULL;

    LPCWSTR pszClassName = NULL;
    UINT cGuidIndex = 0;


    if( dwFlags & SCHEMA_COMMON_PERM )
    {
        *ppObjectTypeList = 
            (POBJECT_TYPE_LIST)LocalAlloc(LPTR,sizeof(OBJECT_TYPE_LIST)*ARRAYSIZE(g_DefaultOTL));
        if(!*ppObjectTypeList)
            TraceLeaveResult(E_OUTOFMEMORY);
        //
        //Note that default OTL is entry with all zero,thatz what LPTR does.
        //so there is no need to copy
        //
        *pObjectTypeListCount = ARRAYSIZE(g_DefaultOTL);        
        TraceLeaveResult(S_OK);
    }

    EnterCriticalSection(&m_ObjectTypeCacheCritSec);

    //
    // Lookup the name of this class
    //
    if (pszClassName == NULL)
        pszClassName = GetClassName(pguidObjectType);

    if(!pszClassName)
         ExitGracefully(hr, E_UNEXPECTED, "Unknown child object GUID");
    
    //
    // Get the list of Extended Rights for this page
    //
    if (pguidObjectType &&
        SUCCEEDED(GetExtendedRightsForNClasses(m_strERSearchPath,
                                               pguidObjectType,
                                               hAuxList,
                                               &hExtRightList,
                                               &hPropSetList)))

    {
        if(hPropSetList)
            cPropertySets = DPA_GetPtrCount(hPropSetList);
        if(hExtRightList)
            cExtendedRights = DPA_GetPtrCount(hExtRightList);
    }

    //
    //Get the child classes
    //
    if( pguidObjectType &&
        SUCCEEDED(GetChildClassesForNClasses(pguidObjectType,
                                             pszClassName,
                                             hAuxList,
                                             pszSchemaPath,
                                             &hClassList)))
    {

        if(hClassList)
            cChildClasses = DPA_GetPtrCount(hClassList);        
    }
     
    //
    //Get the properties for the class
    //        
    if (pguidObjectType &&
        SUCCEEDED(GetPropertiesForNClasses(pguidObjectType,
                                           pszClassName,
                                           hAuxList,
                                           pszSchemaPath,
                                           &hPropertyList)))
    {
        if(hPropertyList)
            cProperties = DPA_GetPtrCount(hPropertyList);
        
    }
    
    pOTL = (POBJECT_TYPE_LIST)LocalAlloc(LPTR, 
                                         (cPropertySets + 
                                          cExtendedRights + 
                                          cChildClasses + 
                                          cProperties +
                                          1)* sizeof(OBJECT_TYPE_LIST)); 
                                                   
    if(!pOTL)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to create POBJECT_TYPE_LIST");

    pTempOTL = pOTL;

    //
    //First Add the entry corresponding to Object
    //
    AddOTLToList(pTempOTL, 
                 ACCESS_OBJECT_GUID, 
                 pguidObjectType);
    pTempOTL++;
    cGuidIndex++;    
    
    UINT i, j;
    for (i = 0; i < cExtendedRights; i++)
    {
        PER_ENTRY pER = (PER_ENTRY)DPA_FastGetPtr(hExtRightList, i);
        AddOTLToList(pTempOTL, 
                     ACCESS_PROPERTY_SET_GUID, 
                     &(pER->guid));
        pTempOTL++;    
        cGuidIndex++;
    }
    
    //
    //Add Property Set
    //

    for(i = 0; i < cPropertySets; ++i)
    {
        PER_ENTRY pER = (PER_ENTRY)DPA_FastGetPtr(hPropSetList, i);
        
        AddOTLToList(pTempOTL,
                     ACCESS_PROPERTY_SET_GUID, 
                     &pER->guid); 
        cGuidIndex++;
        pTempOTL++;    
        
        //
        //Add all the properties which are member of this property set
        //
        for(j = 0; j < cProperties; ++j)
        {
            PPROP_ENTRY pProp = (PPROP_ENTRY)DPA_FastGetPtr(hPropertyList, j);
            if(IsEqualGUID(pER->guid, *pProp->pasguid))
            {
                AddOTLToList(pTempOTL,
                             ACCESS_PROPERTY_GUID, 
                             pProp->pguid); 
                cGuidIndex++;
                pTempOTL++;    
                pProp->dwFlags|= OTL_ADDED_TO_LIST;
            }
        }                
    }               

    //Add all remaining properties
    for( j =0; j < cProperties; ++j )
    {
        PPROP_ENTRY pProp = (PPROP_ENTRY)DPA_FastGetPtr(hPropertyList, j);
        if( !(pProp->dwFlags & OTL_ADDED_TO_LIST) )
        {
            AddOTLToList(pTempOTL, 
                         ACCESS_PROPERTY_SET_GUID, 
                         pProp->pguid); 
            pTempOTL++;    
            cGuidIndex++;
        }
        pProp->dwFlags &= ~OTL_ADDED_TO_LIST;
    }
    
    //All all child clasess
    for( j = 0; j < cChildClasses; ++j )
    {
        PPROP_ENTRY pClass= (PPROP_ENTRY)DPA_FastGetPtr(hClassList, j);
        AddOTLToList(pTempOTL, 
                     ACCESS_PROPERTY_SET_GUID, 
                     pClass->pguid); 
        pTempOTL++;
        cGuidIndex++;
    }

exit_gracefully:

    DPA_Destroy(hExtRightList);
    DPA_Destroy(hClassList);
    DPA_Destroy(hPropertyList);
    DPA_Destroy(hPropSetList);

    LeaveCriticalSection(&m_ObjectTypeCacheCritSec);

    if (FAILED(hr))
    {
        *ppObjectTypeList = NULL;
        *pObjectTypeListCount = 0;
    }
    else
    {
        *ppObjectTypeList = pOTL;
        *pObjectTypeListCount = cGuidIndex;
    }

    TraceLeaveResult(hr);
}


PID_CACHE_ENTRY
CSchemaCache::LookupID(HDPA hCache, LPCWSTR pszLdapName)
{
    PID_CACHE_ENTRY pCacheEntry = NULL;
    int iEntry;

    TraceEnter(TRACE_SCHEMA, "CSchemaCache::LookupID");
    TraceAssert(hCache != NULL);
    TraceAssert(pszLdapName != NULL && *pszLdapName);

    iEntry = DPA_Search(hCache,
                        NULL,
                        0,
                        Schema_CompareLdapName,
                        (LPARAM)pszLdapName,
                        DPAS_SORTED);

    if (iEntry != -1)
        pCacheEntry = (PID_CACHE_ENTRY)DPA_FastGetPtr(hCache, iEntry);

    TraceLeaveValue(pCacheEntry);
}

BOOL
CSchemaCache::IsAuxClass(LPCGUID pguidObjectType)
{
    PID_CACHE_ENTRY pCacheEntry = NULL;
    HRESULT hr = S_OK;
    UINT cItems;

    TraceEnter(TRACE_SCHEMACLASS, "CSchemaCache::LookupClass");
    TraceAssert(pguidObjectType != NULL);
    
    if(IsEqualGUID(*pguidObjectType, GUID_NULL))
        return FALSE;

    hr = WaitOnClassThread();
    FailGracefully(hr, "Class cache unavailable");

    TraceAssert(m_hClassCache != NULL);

    cItems = DPA_GetPtrCount(m_hClassCache);

    while (cItems > 0)
    {
        PID_CACHE_ENTRY pTemp = (PID_CACHE_ENTRY)DPA_FastGetPtr(m_hClassCache, --cItems);

        if (IsEqualGUID(*pguidObjectType, pTemp->guid))
        {
            pCacheEntry = pTemp;
            break;
        }
    }

exit_gracefully:

    if(pCacheEntry)
        return pCacheEntry->bAuxClass;
    else
        return FALSE;       
}

PID_CACHE_ENTRY
CSchemaCache::LookupClass(LPCGUID pguidObjectType)
{
    PID_CACHE_ENTRY pCacheEntry = NULL;
    HRESULT hr = S_OK;
    UINT cItems;

    TraceEnter(TRACE_SCHEMACLASS, "CSchemaCache::LookupClass");
    TraceAssert(pguidObjectType != NULL);
    TraceAssert(!IsEqualGUID(*pguidObjectType, GUID_NULL));

    hr = WaitOnClassThread();
    FailGracefully(hr, "Class cache unavailable");

    TraceAssert(m_hClassCache != NULL);

    cItems = DPA_GetPtrCount(m_hClassCache);

    while (cItems > 0)
    {
        PID_CACHE_ENTRY pTemp = (PID_CACHE_ENTRY)DPA_FastGetPtr(m_hClassCache, --cItems);

        if (IsEqualGUID(*pguidObjectType, pTemp->guid))
        {
            pCacheEntry = pTemp;
            break;
        }
    }

exit_gracefully:

    TraceLeaveValue(pCacheEntry);
}


HRESULT
CSchemaCache::LookupClassID(LPCWSTR pszClass, LPGUID pGuid)
{
    TraceEnter(TRACE_SCHEMACLASS, "CSchemaCache::LookupClassID");
    TraceAssert(pszClass != NULL && pGuid != NULL);
	

    HRESULT hr = WaitOnClassThread();
	if(SUCCEEDED(hr))
    {
        TraceAssert(m_hClassCache != NULL);
        PID_CACHE_ENTRY pCacheEntry = LookupID(m_hClassCache, pszClass);
        if (pCacheEntry)
            *pGuid = pCacheEntry->guid;
    }

    return hr;
}


LPCGUID
CSchemaCache::LookupPropertyID(LPCWSTR pszProperty)
{
    LPCGUID pID = NULL;

    TraceEnter(TRACE_SCHEMAPROP, "CSchemaCache::LookupPropertyID");
    TraceAssert(pszProperty != NULL);

    if (SUCCEEDED(WaitOnPropertyThread()))
    {
        TraceAssert(m_hPropertyCache != NULL);
        PID_CACHE_ENTRY pCacheEntry = LookupID(m_hPropertyCache, pszProperty);
        if (pCacheEntry)
            pID = &pCacheEntry->guid;
    }

    TraceLeaveValue(pID);
}


WCHAR const c_szDsHeuristics[] = L"dSHeuristics";

int
CSchemaCache::GetListObjectEnforced(void)
{
    int nListObjectEnforced = 0;    // Assume "not enforced"
    HRESULT hr;
    IADsPathname *pPath = NULL;
    const LPWSTR aszServicePath[] =
    {
        L"CN=Services",
        L"CN=Windows NT",
        L"CN=Directory Service",
    };
    BSTR strServicePath = NULL;
    IDirectoryObject *pDirectoryService = NULL;
    LPWSTR pszDsHeuristics = (LPWSTR)c_szDsHeuristics;
    PADS_ATTR_INFO pAttributeInfo = NULL;
    DWORD dwAttributesReturned;
    LPWSTR pszHeuristicString;
    int i;

    TraceEnter(TRACE_SCHEMA, "CSchemaCache::GetListObjectEnforced");

    // Create a path object for manipulating ADS paths
    hr = CoCreateInstance(CLSID_Pathname,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IADsPathname,
                          (LPVOID*)&pPath);
    FailGracefully(hr, "Unable to create ADsPathname object");

    hr = pPath->Set(m_strERSearchPath, ADS_SETTYPE_FULL);
    FailGracefully(hr, "Unable to initialize ADsPathname object");

    hr = pPath->RemoveLeafElement();
    for (i = 0; i < ARRAYSIZE(aszServicePath); i++)
    {
        hr = pPath->AddLeafElement(aszServicePath[i]);
        FailGracefully(hr, "Unable to build path to 'Directory Service' object");
    }

    hr = pPath->Retrieve(ADS_FORMAT_WINDOWS, &strServicePath);
    FailGracefully(hr, "Unable to build path to 'Directory Service' object");

    hr = ADsGetObject(strServicePath,
                      IID_IDirectoryObject,
                      (LPVOID*)&pDirectoryService);
    FailGracefully(hr, "Unable to bind to 'Directory Service' object for heuristics");

    hr = pDirectoryService->GetObjectAttributes(&pszDsHeuristics,
                                                1,
                                                &pAttributeInfo,
                                                &dwAttributesReturned);
    if (!pAttributeInfo)
        ExitGracefully(hr, hr, "GetObjectAttributes failed to read dSHeuristics property");

    TraceAssert(ADSTYPE_DN_STRING <= pAttributeInfo->dwADsType);
    TraceAssert(ADSTYPE_NUMERIC_STRING >= pAttributeInfo->dwADsType);
    TraceAssert(1 == pAttributeInfo->dwNumValues);

    pszHeuristicString = pAttributeInfo->pADsValues->NumericString;
    if (pszHeuristicString &&
        lstrlenW(pszHeuristicString) > 2 &&
        L'0' != pszHeuristicString[2])
    {
        nListObjectEnforced = 1;
    }

exit_gracefully:

    if (pAttributeInfo)
        FreeADsMem(pAttributeInfo);

    DoRelease(pDirectoryService);
    DoRelease(pPath);

    SysFreeString(strServicePath);

    TraceLeaveValue(nListObjectEnforced);
}

BOOL
CSchemaCache::HideListObjectAccess(void)
{
    TraceEnter(TRACE_SCHEMA, "CSchemaCache::HideListObjectAccess");

    if (-1 == m_nDsListObjectEnforced)
    {
        m_nDsListObjectEnforced = GetListObjectEnforced();
    }

    TraceLeaveValue(0 == m_nDsListObjectEnforced);
}


#define ACCESS_LENGTH_0 (sizeof(SI_ACCESS) + MAX_TYPENAME_LENGTH * sizeof(WCHAR))
#define ACCESS_LENGTH_1 (sizeof(SI_ACCESS) + MAX_TYPENAME_LENGTH * sizeof(WCHAR))
#define ACCESS_LENGTH_2 (3 * sizeof(SI_ACCESS) + 3 * MAX_TYPENAME_LENGTH * sizeof(WCHAR))

HRESULT
CSchemaCache::BuildAccessArray(LPCGUID pguidObjectType,
                               LPCWSTR pszClassName,
                               LPCWSTR pszSchemaPath,    
                               HDPA hAuxList,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccesses,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess)
{
    HRESULT hr = S_OK;
    
    DWORD dwBufferLength = 0;
    UINT cMaxAccesses;
    LPWSTR pszData = NULL;
    //
    //Lists
    //
    HDPA hExtRightList = NULL;
    HDPA hPropSetList = NULL;
    HDPA hPropertyList = NULL;
    HDPA hClassList = NULL;
    //
    //List counts
    //
    ULONG cExtendedRights = 0;
    ULONG cPropertySets = 0;
    UINT cProperties = 0;
    UINT cChildClasses = 0;

    ULONG cBaseRights = 0;
    
    
    PSI_ACCESS pAccesses = NULL;
    PSI_ACCESS pTempAccesses = NULL;
    ULONG cAccesses = 0;

    TraceEnter(TRACE_SCHEMA, "CSchemaCache::BuildAccessArray");
    TraceAssert(pguidObjectType != NULL);
    TraceAssert(ppAccesses);
    TraceAssert(pcAccesses);
    TraceAssert(piDefaultAccess);

    *ppAccesses = NULL;
    *pcAccesses = 0;
    *piDefaultAccess = 0;
    //
    //Decide what all we need
    //
    BOOL bBasicRight = FALSE;
    BOOL bExtRight = FALSE;
    BOOL bChildClass = FALSE;
    BOOL bProp = FALSE;


    //
    // Lookup the name of this class
    //
    if (pszClassName == NULL)
        pszClassName = GetClassName(pguidObjectType);
    
    if(pszClassName == NULL)
        ExitGracefully(hr, E_UNEXPECTED, "Unknown child object GUID");

    
    if(dwFlags & SI_EDIT_PROPERTIES)
    {
        bProp = TRUE;
    }
    else if(dwFlags & SI_EDIT_EFFECTIVE)
    {
        bExtRight = TRUE;
        bChildClass = TRUE;
        bProp = TRUE;
    }
    else
    {
        bExtRight = TRUE;
        bChildClass = TRUE;
    }
    //
    //We don't show basicRights for Auxillary Classes.
    //This happens when user selects Aux Class in Applyonto combo
    //
    bBasicRight = !IsAuxClass(pguidObjectType);
    //
    // Get the list of Extended Rights for this page
    //
    if (pguidObjectType &&
        SUCCEEDED(GetExtendedRightsForNClasses(m_strERSearchPath,
                                               pguidObjectType,
                                               hAuxList,
                                               bExtRight ? &hExtRightList : NULL,
                                               &hPropSetList)))

    {
        if(hPropSetList)
            cPropertySets = DPA_GetPtrCount(hPropSetList);
        if(hExtRightList)
            cExtendedRights = DPA_GetPtrCount(hExtRightList);
    }


    if( bChildClass &&
        pguidObjectType &&
        SUCCEEDED(GetChildClassesForNClasses(pguidObjectType,
                                             pszClassName,
                                             hAuxList,
                                             pszSchemaPath,
                                             &hClassList)))
    {

        if(hClassList)
            cChildClasses = DPA_GetPtrCount(hClassList);        
    }
     

    //
    //Get the properties for the class
    //        
    if (bProp &&
        pguidObjectType &&
        SUCCEEDED(GetPropertiesForNClasses(pguidObjectType,
                                           pszClassName,
                                           hAuxList,
                                           pszSchemaPath,
                                           &hPropertyList)))
    {
        if(hPropertyList)
            cProperties = DPA_GetPtrCount(hPropertyList);
        
    }
    
    if(bBasicRight)
    {
        //
        //Only Read Property and write Property
        //
        if(dwFlags & SI_EDIT_PROPERTIES)
        {
            cBaseRights = 2;
        }
        else
        {
            cBaseRights = ARRAYSIZE(g_siDSAccesses);
                if (!cChildClasses)
                    cBaseRights -= 3; // skip DS_CREATE_CHILD and DS_DELETE_CHILD and both

        }
    }

    //
    //Three Entries per Child Class 1)Create 2)Delete 3) Create/Delete 
    //Three Entries per Prop Class 1) Read 2)Write 3)Read/Write
    //
    cMaxAccesses =  cBaseRights +
                    cExtendedRights +  
                    3 * cChildClasses +  
                    3 * cPropertySets +
                    3 * cProperties;
    //
    //This can happen for Aux Class Object Right page
    //As we don't show general rights for it.
    //
    if(cMaxAccesses == 0)
        goto exit_gracefully;
    
    //
    // Allocate a buffer for the access array
    //
    dwBufferLength =  cBaseRights * sizeof(SI_ACCESS)
                      + cExtendedRights * ACCESS_LENGTH_1
                      + cChildClasses * ACCESS_LENGTH_2
                      + cPropertySets * ACCESS_LENGTH_2
                      + cProperties * ACCESS_LENGTH_2;
    
    pAccesses = (PSI_ACCESS)LocalAlloc(LPTR, dwBufferLength);
    if (pAccesses == NULL)
        ExitGracefully(hr, E_OUTOFMEMORY, "LocalAlloc failed");

    pTempAccesses = pAccesses;
    pszData = (LPWSTR)(pTempAccesses + cMaxAccesses);

    //
    //Copy the basic right
    //
    if(bBasicRight)
    {
        if(dwFlags & SI_EDIT_PROPERTIES)
        {    
            //
            // Add "Read All Properties" and "Write All Properties"
            //
            CopyMemory(pTempAccesses, &g_siDSAccesses[g_iDSProperties], 2 * sizeof(SI_ACCESS));
            pTempAccesses += 2;
            cAccesses += 2;
        }
        else
        {
            //
            // Add normal entries 
            //
            CopyMemory(pTempAccesses, g_siDSAccesses, cBaseRights * sizeof(SI_ACCESS));
            pTempAccesses += cBaseRights;
            cAccesses += cBaseRights;

            if (HideListObjectAccess())
            {
                pAccesses[g_iDSRead].mask &= ~ACTRL_DS_LIST_OBJECT;
                pAccesses[g_iDSListObject].dwFlags = 0;
            }
			
			//
			//If there are no child objects, don't show create/delete child objects
			//
			if(cChildClasses == 0)
				pAccesses[g_iDSDeleteTree].dwFlags = 0;

        }
    }

    //
    // Add entries for creating & deleting child objects
    //
    if (bChildClass && cChildClasses)
    {
        TraceAssert(NULL != hClassList);

        cAccesses += AddTempListToAccessList(hClassList,
                                             &pTempAccesses,
                                             &pszData,
                                             SI_ACCESS_SPECIFIC,
                                             SCHEMA_CLASS | (dwFlags & SCHEMA_NO_FILTER),
                                             FALSE);
    }



    if(bExtRight)
    {
        //
        //Decide if to show "All Extended Rights" entry 
        //and "All Validated Right Entry
        //
        BOOL bAllExtRights = FALSE;
        BOOL bAllValRights = FALSE;
        if(cExtendedRights)
        {
            //
            // Add entries for Extended Rights
            //
            UINT i;
            for (i = 0; i < cExtendedRights; i++)
            {
                PER_ENTRY pER = (PER_ENTRY)DPA_FastGetPtr(hExtRightList, i);

                //
                //Show All Validated Right entry only if atleast one 
                //individual Validated Right is present
                //
                if(pER->mask & ACTRL_DS_SELF)
                    bAllValRights = TRUE;

                //
                //Show All Validated Right entry only if atleast one 
                //individual Validated Right is present
                //
                if(pER->mask & ACTRL_DS_CONTROL_ACCESS)
                    bAllExtRights = TRUE;

                pTempAccesses->mask = pER->mask;
                //
                //Extended Rights Are shown on both first page and advanced page
                //
                pTempAccesses->dwFlags = SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC;
                pTempAccesses->pguid = &pER->guid;
                pTempAccesses->pszName = pszData;
                lstrcpynW(pszData, pER->szName, MAX_TYPENAME_LENGTH);
                pszData += (lstrlen(pTempAccesses->pszName) + 1);
                pTempAccesses++;
                cAccesses++;
            }
        }
        if(!bAllExtRights && bBasicRight)
            pAccesses[g_iDSAllExtRights].dwFlags = 0;

        if(!bAllValRights && bBasicRight)
            pAccesses[g_iDSAllValRights].dwFlags = 0;

    }

    //
    //Add PropertySet Entries
    //
    if (cPropertySets > 0)
    {
        cAccesses += AddTempListToAccessList(hPropSetList,
                                             &pTempAccesses,
                                             &pszData,
                                             SI_ACCESS_GENERAL|SI_ACCESS_PROPERTY,
                                             (dwFlags & SCHEMA_NO_FILTER),
                                             TRUE);
    }

    //
    // Add property entries
    //
    if (bProp && cProperties > 0)
    {
        cAccesses += AddTempListToAccessList(hPropertyList,
                                             &pTempAccesses,
                                             &pszData,
                                             SI_ACCESS_PROPERTY,
                                             (dwFlags & SCHEMA_NO_FILTER),
                                             FALSE);
    }


    *ppAccesses = pAccesses;
    *pcAccesses = cAccesses;
    *piDefaultAccess = bBasicRight ? g_iDSDefAccess : 0;


exit_gracefully:

    if(hExtRightList)
        DPA_Destroy(hExtRightList);
    if(hClassList)
        DPA_Destroy(hClassList);
    if(hPropertyList)
        DPA_Destroy(hPropertyList);
    if(hPropSetList)
        DPA_Destroy(hPropSetList);

    TraceLeaveResult(hr);
}




HRESULT
CSchemaCache::EnumVariantList(LPVARIANT pvarList,
                              HDPA hTempList,
                              DWORD dwFlags,
                              IDsDisplaySpecifier *pDisplaySpec,
                              LPCWSTR pszPropertyClass,
                              BOOL )
{
    HRESULT hr = S_OK;
    LPVARIANT pvarItem = NULL;
    int cItems;
    BOOL bSafeArrayLocked = FALSE;

    TraceEnter(TRACE_SCHEMA, "CSchemaCache::EnumVariantList");
    TraceAssert(pvarList != NULL);
    TraceAssert(hTempList != NULL);

	if (dwFlags & SCHEMA_CLASS)
        hr = WaitOnClassThread();
    else
		hr = WaitOnPropertyThread();

	FailGracefully(hr, "Required Cache Not Available");


    if (V_VT(pvarList) == (VT_ARRAY | VT_VARIANT))
    {
        hr = SafeArrayAccessData(V_ARRAY(pvarList), (LPVOID*)&pvarItem);
        FailGracefully(hr, "Unable to access SafeArray");
        bSafeArrayLocked = TRUE;
        cItems = V_ARRAY(pvarList)->rgsabound[0].cElements;
    }
    else if (V_VT(pvarList) == VT_BSTR) // Single entry in list
    {
        pvarItem = pvarList;
        cItems = 1;
    }
    else
    {
        // Unknown format
        ExitGracefully(hr, E_INVALIDARG, "Unexpected VARIANT type");
    }

    if (NULL == m_strFilterFile)
        m_strFilterFile = GetFilterFilePath();

    //
    // Enumerate the variant list and get information about each
    // (filter, guid, display name)
    //
    for ( ; cItems > 0; pvarItem++, cItems--)
    {
        LPWSTR pszItem;
        DWORD dwFilter = 0;
        WCHAR wszDisplayName[MAX_PATH];
        PPROP_ENTRY pti;
        PID_CACHE_ENTRY pid ;


        //
        //Get the ldapDisplayName
        //            
        TraceAssert(V_VT(pvarItem) == VT_BSTR);
        pszItem = V_BSTR(pvarItem);

        //
        // Check for nonexistent or empty strings
        //
        if (!pszItem || !*pszItem)
            continue;

        //
        //Check if the string is filtered by dssec.dat file
        //
        if(m_strFilterFile)
        {
            if (dwFlags & SCHEMA_CLASS)
            {
                dwFilter = GetPrivateProfileIntW(pszItem,
                                                 c_szClassKey,
                                                 0,
                                                 m_strFilterFile);
                if(pszPropertyClass)
                    dwFilter |= GetPrivateProfileIntW(pszPropertyClass,
                                                      pszItem,
                                                      0,
                                                      m_strFilterFile);


            }
            else if (pszPropertyClass)
            {
                dwFilter = GetPrivateProfileIntW(pszPropertyClass,
                                                 pszItem,
                                                 0,
                                                 m_strFilterFile);
            }
        }
        
        //
        // Note that IDC_CLASS_NO_CREATE == IDC_PROP_NO_READ
        // and IDC_CLASS_NO_DELETE == IDC_PROP_NO_WRITE
        //
        dwFilter &= (IDC_CLASS_NO_CREATE | IDC_CLASS_NO_DELETE);

        //
        //Get the schema or property cache entry
        //
        if (dwFlags & SCHEMA_CLASS)
            pid = LookupID(m_hClassCache, pszItem);
        else
            pid = LookupID(m_hPropertyCache, pszItem);
            
        if(pid == NULL)
            continue;

        
        //
        //Get the Display Name
        //
        wszDisplayName[0] = L'\0';

        if (pDisplaySpec)
        {
            if (dwFlags & SCHEMA_CLASS)
            {
                pDisplaySpec->GetFriendlyClassName(pszItem,
                                                   wszDisplayName,
                                                   ARRAYSIZE(wszDisplayName));
            }
            else if (pszPropertyClass)
            {
                pDisplaySpec->GetFriendlyAttributeName(pszPropertyClass,
                                                       pszItem,
                                                       wszDisplayName,
                                                       ARRAYSIZE(wszDisplayName));
            }
        }

        LPWSTR pszDisplay;
        pszDisplay = (wszDisplayName[0] != L'\0') ? wszDisplayName : pszItem;
        //
        // Remember what we've got so far
        //
        pti = (PPROP_ENTRY)LocalAlloc(LPTR, sizeof(PROP_ENTRY) + StringByteSize(pszDisplay));
        if (pti)
        {
            pti->pguid = &pid->guid;
            pti->pasguid = &pid->asGuid;   
            pti->dwFlags |= dwFilter;
            lstrcpyW(pti->szName, pszDisplay);
            DPA_AppendPtr(hTempList, pti);
        }            
    }


exit_gracefully:

    if (bSafeArrayLocked)
        SafeArrayUnaccessData(V_ARRAY(pvarList));

    TraceLeaveResult(hr);
}


UINT
CSchemaCache::AddTempListToAccessList(HDPA hTempList,
                                      PSI_ACCESS *ppAccess,
                                      LPWSTR *ppszData,
                                      DWORD dwAccessFlags,
                                      DWORD dwFlags,
                                      BOOL bPropSet)
{
    UINT cTotalEntries = 0;
    int cItems;
    DWORD dwAccess1;
    DWORD dwAccess2;
    WCHAR szFmt1[MAX_TYPENAME_LENGTH];
    WCHAR szFmt2[MAX_TYPENAME_LENGTH];
    WCHAR szFmt3[MAX_TYPENAME_LENGTH];

    TraceEnter(TRACE_SCHEMA, "CSchemaCache::AddTempListToAccessList");
    TraceAssert(ppAccess != NULL);
    TraceAssert(ppszData != NULL);

    cItems = DPA_GetPtrCount(hTempList);
    if (0 == cItems)
        ExitGracefully(cTotalEntries, 0, "empty list");

    if (dwFlags & SCHEMA_CLASS)
    {
        dwAccess1 = ACTRL_DS_CREATE_CHILD;
        dwAccess2 = ACTRL_DS_DELETE_CHILD;
        LoadStringW(GLOBAL_HINSTANCE, IDS_DS_CREATE_CHILD_TYPE, szFmt1, ARRAYSIZE(szFmt1));
        LoadStringW(GLOBAL_HINSTANCE, IDS_DS_DELETE_CHILD_TYPE, szFmt2, ARRAYSIZE(szFmt2));
        LoadStringW(GLOBAL_HINSTANCE, IDS_DS_CREATEDELETE_TYPE, szFmt3, ARRAYSIZE(szFmt3));
    }
    else
    {
        dwAccess1 = ACTRL_DS_READ_PROP;
        dwAccess2 = ACTRL_DS_WRITE_PROP;
        LoadStringW(GLOBAL_HINSTANCE, IDS_DS_READ_PROP_TYPE,  szFmt1, ARRAYSIZE(szFmt1));
        LoadStringW(GLOBAL_HINSTANCE, IDS_DS_WRITE_PROP_TYPE, szFmt2, ARRAYSIZE(szFmt2));
        LoadStringW(GLOBAL_HINSTANCE, IDS_DS_READWRITE_TYPE,  szFmt3, ARRAYSIZE(szFmt3));
    }

    // Enumerate the list and make up to 2 entries for each
    for(int i = 0; i < cItems; ++i)
    {
        PER_ENTRY pER = NULL;
        PPROP_ENTRY pProp = NULL;
        LPWSTR pszData;
        LPGUID pGuid = NULL;
        PSI_ACCESS pNewAccess;
        LPCWSTR pszName;
        int cch;
        DWORD dwAccess3;
        DWORD dwFilter = 0;
        
        if(bPropSet)
        {
            pER = (PER_ENTRY)DPA_FastGetPtr(hTempList, i);
            if (!pER)
                continue;
            pGuid = &pER->guid;
            pszName = pER->szName;
            dwFilter = 0;
        }
        else
        {
            pProp = (PPROP_ENTRY)DPA_FastGetPtr(hTempList, i);
            if (!pProp)
                continue;
            pGuid = pProp->pguid;
            pszName = pProp->szName;
            dwFilter = pProp->dwFlags;
        }
    
        pszData = *ppszData;
        pNewAccess = *ppAccess;

        dwAccess3 = 0;
        if ((dwFlags & SCHEMA_NO_FILTER) ||
            !(dwFilter & IDC_CLASS_NO_CREATE))
        {
            pNewAccess->mask = dwAccess1;
            pNewAccess->dwFlags = dwAccessFlags;
            pNewAccess->pguid = pGuid;

            pNewAccess->pszName = (LPCWSTR)pszData;
            cch = wsprintfW((LPWSTR)pszData, szFmt1, pszName);
            pszData += (cch + 1);

            cTotalEntries++;
            pNewAccess++;

            dwAccess3 |= dwAccess1;
        }

        if ((dwFlags & SCHEMA_NO_FILTER) ||
            !(dwFilter & IDC_CLASS_NO_DELETE))
        {
            pNewAccess->mask = dwAccess2;
            pNewAccess->dwFlags = dwAccessFlags;
            pNewAccess->pguid = pGuid;

            pNewAccess->pszName = (LPCWSTR)pszData;
            cch = wsprintfW((LPWSTR)pszData, szFmt2, pszName);
            pszData += (cch + 1);

            cTotalEntries++;
            pNewAccess++;

            dwAccess3 |= dwAccess2;
        }

        if (dwAccess3 == (dwAccess1 | dwAccess2))
        {
            // Add a hidden entry for
            //     "Read/write <prop>"
            // or
            //     "Create/delete <child>"
            pNewAccess->mask = dwAccess3;
            // dwFlags = 0 means it will never show as a checkbox, but it
            // may be used for the name displayed on the Advanced page.
            pNewAccess->dwFlags = 0;
            pNewAccess->pguid = pGuid;

            pNewAccess->pszName = (LPCWSTR)pszData;
            cch = wsprintfW((LPWSTR)pszData, szFmt3, pszName);
            pszData += (cch + 1);

            cTotalEntries++;
            pNewAccess++;
        }

        if (*ppAccess != pNewAccess)
        {
            *ppAccess = pNewAccess; // move past new entries
            *ppszData = pszData;
        }
    }

exit_gracefully:

    TraceLeaveValue(cTotalEntries);
}


DWORD WINAPI
CSchemaCache::SchemaClassThread(LPVOID pvThreadData)
{
    PSCHEMACACHE pCache;

    HINSTANCE hInstThisDll = LoadLibrary(c_szDllName);
    InterlockedIncrement(&GLOBAL_REFCOUNT);

    pCache = (PSCHEMACACHE)pvThreadData;
    SetEvent(pCache->m_hLoadLibClassWaitEvent);
    TraceEnter(TRACE_SCHEMACLASS, "CSchemaCache::SchemaClassThread");
    TraceAssert(pCache != NULL);
    TraceAssert(pCache->m_strSchemaSearchPath != NULL);

#if DBG
    DWORD dwTime = GetTickCount();
#endif

    ThreadCoInitialize();

    pCache->m_hrClassResult = Schema_Search(pCache->m_strSchemaSearchPath,
                                            c_szClassFilter,
                                            &pCache->m_hClassCache,
                                            FALSE);

    ThreadCoUninitialize();

#if DBG
    Trace((TEXT("SchemaClassThread complete, elapsed time: %d ms"), GetTickCount() - dwTime));
#endif

    TraceLeave();

    InterlockedDecrement(&GLOBAL_REFCOUNT);
    FreeLibraryAndExitThread(hInstThisDll, 0);
}


DWORD WINAPI
CSchemaCache::SchemaPropertyThread(LPVOID pvThreadData)
{
    PSCHEMACACHE pCache = NULL;

    HINSTANCE hInstThisDll = LoadLibrary(c_szDllName);
    InterlockedIncrement(&GLOBAL_REFCOUNT);

    pCache = (PSCHEMACACHE)pvThreadData;
    SetEvent(pCache->m_hLoadLibPropWaitEvent);
    TraceEnter(TRACE_SCHEMAPROP, "CSchemaCache::SchemaPropertyThread");
    TraceAssert(pCache != NULL);
    TraceAssert(pCache->m_strSchemaSearchPath != NULL);

#if DBG
    DWORD dwTime = GetTickCount();
#endif

    ThreadCoInitialize();

    pCache->m_hrPropertyResult = Schema_Search(pCache->m_strSchemaSearchPath,
                                               c_szPropertyFilter,
                                               &pCache->m_hPropertyCache,
                                               TRUE);

    ThreadCoUninitialize();

#if DBG
    Trace((TEXT("SchemaPropertyThread complete, elapsed time: %d ms"), GetTickCount() - dwTime));
#endif

    TraceLeave();

    InterlockedDecrement(&GLOBAL_REFCOUNT);
    FreeLibraryAndExitThread(hInstThisDll, 0);

}


HRESULT
CSchemaCache::BuildInheritTypeArray(DWORD dwFlags)
{
    HRESULT hr = S_OK;
    int cItems = 0;
    DWORD cbNames = 0;
    DWORD dwBufferLength;
    PINHERIT_TYPE_ARRAY pInheritTypeArray = NULL;
    PSI_INHERIT_TYPE pNewInheritType;
    LPGUID pGuidData = NULL;
    LPWSTR pszData = NULL;
    WCHAR szFormat[MAX_TYPENAME_LENGTH];
    HDPA hTempList = NULL;
    PTEMP_INFO pti;
    IDsDisplaySpecifier *pDisplaySpec = NULL;

    TraceEnter(TRACE_SCHEMACLASS, "CSchemaCache::BuildInheritTypeArray");
    TraceAssert(m_pInheritTypeArray == NULL);   // Don't want to build this twice

    if (NULL == m_strFilterFile)
        m_strFilterFile = GetFilterFilePath();

    hr = WaitOnClassThread();
    FailGracefully(hr, "Class cache unavailable");

    cItems = DPA_GetPtrCount(m_hClassCache);
    if (cItems == 0)
        ExitGracefully(hr, E_FAIL, "No schema classes available");

    hTempList = DPA_Create(cItems);
    if (!hTempList)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to create DPA");

    // Get the display specifier object
    CoCreateInstance(CLSID_DsDisplaySpecifier,
                     NULL,
                     CLSCTX_INPROC_SERVER,
                     IID_IDsDisplaySpecifier,
                     (void**)&pDisplaySpec);

    // Enumerate child types, apply filtering, and get display names
    while (cItems > 0)
    {
        PID_CACHE_ENTRY pCacheEntry;
        WCHAR wszDisplayName[MAX_PATH];

        pCacheEntry = (PID_CACHE_ENTRY)DPA_FastGetPtr(m_hClassCache, --cItems);

        if (!pCacheEntry)
            continue;
        
        if (m_strFilterFile && !(dwFlags & SCHEMA_NO_FILTER))
        {
            DWORD dwFilter = GetPrivateProfileIntW(pCacheEntry->szLdapName,
                                                   c_szClassKey,
                                                   0,
                                                   m_strFilterFile);
            if (dwFilter & IDC_CLASS_NO_INHERIT)
                continue;
        }

        wszDisplayName[0] = L'\0';

        if (pDisplaySpec)
        {
            pDisplaySpec->GetFriendlyClassName(pCacheEntry->szLdapName,
                                               wszDisplayName,
                                               ARRAYSIZE(wszDisplayName));
        }

        if (L'\0' != wszDisplayName[0])
            cbNames += StringByteSize(wszDisplayName);
        else
            cbNames += StringByteSize(pCacheEntry->szLdapName);

        pti = (PTEMP_INFO)LocalAlloc(LPTR, sizeof(TEMP_INFO) + sizeof(WCHAR)*lstrlenW(wszDisplayName));
        if (pti)
        {
            pti->pguid = &pCacheEntry->guid;
            pti->pszLdapName = pCacheEntry->szLdapName;
            lstrcpyW(pti->szDisplayName, wszDisplayName);
            DPA_AppendPtr(hTempList, pti);
        }
    }

    // Sort by display name
    DPA_Sort(hTempList, Schema_CompareTempDisplayName, 0);

    // Get an accurate count
    cItems = DPA_GetPtrCount(hTempList);

    //
    // Allocate a buffer for the inherit type array
    //
    dwBufferLength = sizeof(INHERIT_TYPE_ARRAY) - sizeof(SI_INHERIT_TYPE)
        + sizeof(g_siDSInheritTypes)
        + cItems * (sizeof(SI_INHERIT_TYPE) + sizeof(GUID) + MAX_TYPENAME_LENGTH*sizeof(WCHAR))
        + cbNames;

    pInheritTypeArray = (PINHERIT_TYPE_ARRAY)LocalAlloc(LPTR, dwBufferLength);
    if (pInheritTypeArray == NULL)
        ExitGracefully(hr, E_OUTOFMEMORY, "LocalAlloc failed");

    pInheritTypeArray->cInheritTypes = ARRAYSIZE(g_siDSInheritTypes);

    pNewInheritType = pInheritTypeArray->aInheritType;
    pGuidData = (LPGUID)(pNewInheritType + pInheritTypeArray->cInheritTypes + cItems);
    pszData = (LPWSTR)(pGuidData + cItems);


    // Copy static entries
    CopyMemory(pNewInheritType, g_siDSInheritTypes, sizeof(g_siDSInheritTypes));
    pNewInheritType += ARRAYSIZE(g_siDSInheritTypes);

    // Load format string
    LoadString(GLOBAL_HINSTANCE,
               IDS_DS_INHERIT_TYPE,
               szFormat,
               ARRAYSIZE(szFormat));

    // Enumerate child types and make an entry for each
    while (cItems > 0)
    {
        int cch;
        LPCWSTR pszDisplayName;

        pti = (PTEMP_INFO)DPA_FastGetPtr(hTempList, --cItems);
        if (!pti)
            continue;

        if (pti->szDisplayName[0])
            pszDisplayName = pti->szDisplayName;
        else
            pszDisplayName = pti->pszLdapName;

        pNewInheritType->dwFlags = CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE;

        // The class entry name is the child class name, e.g. "Domain" or "User"
        pNewInheritType->pszName = pszData;
        cch = wsprintfW(pszData, szFormat, pszDisplayName);
        pszData += (cch + 1);

        pNewInheritType->pguid = pGuidData;
        *pGuidData = *pti->pguid;
        pGuidData++;

        pNewInheritType++;
        pInheritTypeArray->cInheritTypes++;
    }

exit_gracefully:

    DoRelease(pDisplaySpec);

    if (SUCCEEDED(hr))
    {
        m_pInheritTypeArray = pInheritTypeArray;
        // Set this master inherit type array's GUID to null
        m_pInheritTypeArray->guidObjectType = GUID_NULL;
        m_pInheritTypeArray->dwFlags = (dwFlags & SCHEMA_NO_FILTER);
    }
    else if (pInheritTypeArray != NULL)
    {
        LocalFree(pInheritTypeArray);
    }

    DestroyDPA(hTempList);

    TraceLeaveResult(hr);
}


HRESULT
Schema_BindToObject(LPCWSTR pszSchemaPath,
                    LPCWSTR pszName,
                    REFIID riid,
                    LPVOID *ppv)
{
    HRESULT hr;
    WCHAR szPath[MAX_PATH];
    UINT nSchemaRootLen;
    WCHAR chTemp;

    TraceEnter(TRACE_SCHEMA, "Schema_BindToObject");
    TraceAssert(pszSchemaPath != NULL);
    TraceAssert(pszName == NULL || *pszName);
    TraceAssert(ppv != NULL);

    if (pszSchemaPath == NULL)
    {
        ExitGracefully(hr, E_INVALIDARG, "No schema path provided");
    }

    nSchemaRootLen = lstrlenW(pszSchemaPath);

    //
    // Build the schema path to this object
    //
    lstrcpynW(szPath, pszSchemaPath, nSchemaRootLen + 1);
    chTemp = szPath[nSchemaRootLen-1];
    if (pszName != NULL)
    {
        // If there is no trailing slash, add it
        if (chTemp != TEXT('/'))
        {
            szPath[nSchemaRootLen] = TEXT('/');
            nSchemaRootLen++;
        }

        // Add the class or property name onto the end
        lstrcpynW(szPath + nSchemaRootLen,
                 pszName,
                 ARRAYSIZE(szPath) - nSchemaRootLen);
    }
    else if (nSchemaRootLen > 0)
    {
        // If there is a trailing slash, remove it
        if (chTemp == TEXT('/'))
            szPath[nSchemaRootLen-1] = TEXT('\0');
    }
    else
    {
        ExitGracefully(hr, E_INVALIDARG, "Empty schema path");
    }

    //
    // Instantiate the schema object
    //
    ThreadCoInitialize();
    hr = OpenDSObject(szPath,
                       NULL,
                       NULL,
                       ADS_SECURE_AUTHENTICATION,
                       riid,
                       ppv);

exit_gracefully:

    TraceLeaveResult(hr);
}


HRESULT
Schema_GetObjectID(IADs *pObj, LPGUID pGUID)
{
    HRESULT hr;
    VARIANT varID = {0};

    TraceEnter(TRACE_SCHEMA, "Schema_GetObjectID(IADs*)");
    TraceAssert(pObj != NULL);
    TraceAssert(pGUID != NULL && !IsBadWritePtr(pGUID, sizeof(GUID)));

    // Get the "schemaIDGUID" property
    hr = pObj->Get((LPWSTR)c_szSchemaIDGUID, &varID);

    if (SUCCEEDED(hr))
    {
        LPGUID pID = NULL;

        TraceAssert(V_VT(&varID) == (VT_ARRAY | VT_UI1));
        TraceAssert(V_ARRAY(&varID) && varID.parray->cDims == 1);
        TraceAssert(V_ARRAY(&varID)->rgsabound[0].cElements >= sizeof(GUID));

        hr = SafeArrayAccessData(V_ARRAY(&varID), (LPVOID*)&pID);
        if (SUCCEEDED(hr))
        {
            *pGUID = *pID;
            SafeArrayUnaccessData(V_ARRAY(&varID));
        }
        VariantClear(&varID);
    }

    TraceLeaveResult(hr);
}


HRESULT
Schema_Search(LPWSTR pszSchemaSearchPath,
              LPCWSTR pszFilter,
              HDPA *phCache,
              BOOL bProperty)
{
    HRESULT hr = S_OK;
    HDPA hCache = NULL;
    IDirectorySearch *pSchemaSearch = NULL;
    ADS_SEARCH_HANDLE hSearch = NULL;
    ADS_SEARCHPREF_INFO prefInfo[3];
    const LPCWSTR pProperties1[] =
    {
        c_szLDAPDisplayName,            // "lDAPDisplayName"
        c_szSchemaIDGUID,               // "schemaIDGUID"
        c_szObjectClassCategory,
    };
    const LPCWSTR pProperties2[] =
    {
        c_szLDAPDisplayName,
        c_szSchemaIDGUID,
        c_szAttributeSecurityGuid,
    };

    TraceEnter(lstrcmp(pszFilter, c_szPropertyFilter) ? TRACE_SCHEMACLASS : TRACE_SCHEMAPROP, "Schema_Search");
    TraceAssert(pszSchemaSearchPath != NULL);
    TraceAssert(phCache != NULL);

    LPCWSTR * pProperties = (LPCWSTR *)( bProperty ? pProperties2 : pProperties1 );
    DWORD dwSize = (DWORD)(bProperty ? ARRAYSIZE(pProperties2) : ARRAYSIZE(pProperties1));
    //
    // Create DPA if necessary
    //
    if (*phCache == NULL)
        *phCache = DPA_Create(100);

    if (*phCache == NULL)
        ExitGracefully(hr, E_OUTOFMEMORY, "DPA_Create failed");

    hCache = *phCache;

    // Get the schema search object
    hr = OpenDSObject(pszSchemaSearchPath,
                       NULL,
                       NULL,
                       ADS_SECURE_AUTHENTICATION,
                       IID_IDirectorySearch,
                       (LPVOID*)&pSchemaSearch);
    FailGracefully(hr, "Failed to get schema search object");

    // Set preferences to Asynchronous, Deep search, Paged results
    prefInfo[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[0].vValue.Integer = ADS_SCOPE_SUBTREE;

    prefInfo[1].dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;
    prefInfo[1].vValue.dwType = ADSTYPE_BOOLEAN;
    prefInfo[1].vValue.Boolean = TRUE;

    prefInfo[2].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    prefInfo[2].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[2].vValue.Integer = PAGE_SIZE;

    hr = pSchemaSearch->SetSearchPreference(prefInfo, ARRAYSIZE(prefInfo));

    // Do the search
    hr = pSchemaSearch->ExecuteSearch((LPWSTR)pszFilter,
                                      (LPWSTR*)pProperties,
                                      dwSize,
                                      &hSearch);
    FailGracefully(hr, "IDirectorySearch::ExecuteSearch failed");

    // Loop through the rows, getting the name and ID of each property or class
    for (;;)
    {
        ADS_SEARCH_COLUMN colLdapName;
        ADS_SEARCH_COLUMN colGuid;
        ADS_SEARCH_COLUMN colASGuid;
        LPWSTR pszLdapName;
        LPGUID pID;
        LPGUID pASID;
        INT iObjectClassCategory = 0;
        PID_CACHE_ENTRY pCacheEntry;

        hr = pSchemaSearch->GetNextRow(hSearch);

        if (FAILED(hr) || hr == S_ADS_NOMORE_ROWS)
            break;

        // Get class/property internal name
        hr = pSchemaSearch->GetColumn(hSearch, (LPWSTR)c_szLDAPDisplayName, &colLdapName);
        if (FAILED(hr))
        {
            TraceMsg("lDAPDisplayName not found for class/property");
            continue;
        }

        TraceAssert(colLdapName.dwADsType >= ADSTYPE_DN_STRING
                    && colLdapName.dwADsType <= ADSTYPE_NUMERIC_STRING);
        TraceAssert(colLdapName.dwNumValues == 1);

        pszLdapName = colLdapName.pADsValues->CaseIgnoreString;

        // Get the GUID column
        hr = pSchemaSearch->GetColumn(hSearch, (LPWSTR)c_szSchemaIDGUID, &colGuid);
        if (FAILED(hr))
        {
            Trace((TEXT("GUID not found for \"%s\""), pszLdapName));
            pSchemaSearch->FreeColumn(&colLdapName);
            continue;
        }

        // Get GUID from column
        TraceAssert(colGuid.dwADsType == ADSTYPE_OCTET_STRING);
        TraceAssert(colGuid.dwNumValues == 1);
        TraceAssert(colGuid.pADsValues->OctetString.dwLength == sizeof(GUID));

        pID = (LPGUID)(colGuid.pADsValues->OctetString.lpValue);


        pASID = (LPGUID)&GUID_NULL;
        if( bProperty )
        {
            // Get the AttrbiuteSecurityGUID column
            hr = pSchemaSearch->GetColumn(hSearch, (LPWSTR)c_szAttributeSecurityGuid, &colASGuid);
            
            if (hr != E_ADS_COLUMN_NOT_SET && FAILED(hr))
            {
                Trace((TEXT("AttributeSecurityGUID not found for \"%s\""), pszLdapName));
                pSchemaSearch->FreeColumn(&colLdapName);
                pSchemaSearch->FreeColumn(&colGuid);
                continue;
            }

            if( hr != E_ADS_COLUMN_NOT_SET )
            {
                // Get GUID from column
                TraceAssert(colASGuid.dwADsType == ADSTYPE_OCTET_STRING);
                TraceAssert(colASGuid.dwNumValues == 1);
                TraceAssert(colASGuid.pADsValues->OctetString.dwLength == sizeof(GUID));

                pASID = (LPGUID)(colASGuid.pADsValues->OctetString.lpValue);
            }
        }
        else
        {
            // Get the c_szObjectClassCategory column
            hr = pSchemaSearch->GetColumn(hSearch, (LPWSTR)c_szObjectClassCategory, &colASGuid);
            
            if (FAILED(hr))
            {
                Trace((TEXT("ObjectClassCategory not found for \"%s\""), pszLdapName));
                pSchemaSearch->FreeColumn(&colLdapName);
                pSchemaSearch->FreeColumn(&colGuid);
                continue;
            }

            // Get GUID from column
            TraceAssert(colASGuid.dwADsType == ADSTYPE_INTEGER);
            TraceAssert(colASGuid.dwNumValues == 1);
            
            iObjectClassCategory = colASGuid.pADsValues->Integer;
        }

        pCacheEntry = (PID_CACHE_ENTRY)LocalAlloc(LPTR,
                                  sizeof(ID_CACHE_ENTRY)
                                  + sizeof(WCHAR)*lstrlenW(pszLdapName));
        if (pCacheEntry != NULL)
        {
            // Copy the item name and ID
            pCacheEntry->guid = *pID;
            pCacheEntry->asGuid = *pASID;
            pCacheEntry->bAuxClass = (iObjectClassCategory == 3);
            lstrcpyW(pCacheEntry->szLdapName, pszLdapName);

            // Insert into cache
            DPA_AppendPtr(hCache, pCacheEntry);
        }
    
        pSchemaSearch->FreeColumn(&colLdapName);
        pSchemaSearch->FreeColumn(&colGuid);
        if(!bProperty || hr != E_ADS_COLUMN_NOT_SET)
        pSchemaSearch->FreeColumn(&colASGuid);
    }

    DPA_Sort(hCache, Schema_CompareLdapName, 0);

exit_gracefully:

    if (hSearch != NULL)
        pSchemaSearch->CloseSearchHandle(hSearch);

    DoRelease(pSchemaSearch);

    if (FAILED(hr))
    {
        DestroyDPA(hCache);
        *phCache = NULL;
    }

    TraceLeaveResult(hr);
}



//+--------------------------------------------------------------------------
//
//  Function:   Schema_GetExtendedRightsForOneClass
//
//  Synopsis:   This Function Gets the Extended Rights for One Class.
//              It Adds all the control rights, validated rights to 
//              phERList. It Adds all the PropertySets to phPropSetList.
//
//  Arguments:  [pszSchemaSearchPath - IN] : Path to schema
//              [pguidClass - In] : Guid Of the class
//              [phERList - OUT] : Get the output Extended Right List
//              [phPropSetList - OUT]: Gets the output PropertySet List
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//
//  History:    3-Nov 2000  hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT
CSchemaCache::GetExtendedRightsForOneClass(IN LPWSTR pszSchemaSearchPath,
                                    IN LPCGUID pguidClass,
                                    OUT HDPA *phERList,
                                    OUT HDPA *phPropSetList)
{
    TraceEnter(TRACE_SCHEMA, "CSchemaCache::GetExtendedRightsForOneClass");
    
    if(!pszSchemaSearchPath 
       || !pguidClass 
       || IsEqualGUID(*pguidClass, GUID_NULL)
       || !phERList
       || !phPropSetList)
    {
        Trace((L"Invalid Arguments Passed to Schema_GetExtendedRightsForOneClass"));          
        return E_INVALIDARG; 
    }

    HRESULT hr = S_OK;
    IDirectorySearch *pSearch = NULL;
    ADS_SEARCH_HANDLE hSearch = NULL;
    ADS_SEARCHPREF_INFO prefInfo[3];
    WCHAR szFilter[100];
    HDPA hExtRightList = NULL;
    HDPA hPropSetList = NULL;
    POBJECT_TYPE_CACHE pOTC = NULL;

    //
    //Search in the cache
    //
    if (m_hObjectTypeCache != NULL)
    {
        UINT cItems = DPA_GetPtrCount(m_hObjectTypeCache);

        while (cItems > 0)
        {
            pOTC = (POBJECT_TYPE_CACHE)DPA_FastGetPtr(m_hObjectTypeCache, --cItems);
            //
            //Found A match.
            //
            if(IsEqualGUID(pOTC->guidObject, *pguidClass))    
                break;
            
            pOTC = NULL;                
        }
        //
        //Have we already got the properties
        //
        if(pOTC && pOTC->flags & OTC_EXTR)
        {
            *phERList = pOTC->hListExtRights;
            *phPropSetList = pOTC->hListPropertySet;
            return S_OK;
        }
    }


    //
    //Attributes to fetch
    //
    const LPCWSTR pProperties[] =
    {
        c_szDisplayName,                // "displayName"
        c_szDisplayID,                  // "localizationDisplayId"
        c_szRightsGuid,                 // "rightsGuid"
        c_szValidAccesses,              // "validAccesses"
    };


    //
    // Build the filter string
    //
    wsprintfW(szFilter, c_szERFilterFormat,
              pguidClass->Data1, pguidClass->Data2, pguidClass->Data3,
              pguidClass->Data4[0], pguidClass->Data4[1],
              pguidClass->Data4[2], pguidClass->Data4[3],
              pguidClass->Data4[4], pguidClass->Data4[5],
              pguidClass->Data4[6], pguidClass->Data4[7]);
    Trace((TEXT("Filter \"%s\""), szFilter));

    //
    // Create DPA to hold results
    //
    hExtRightList = DPA_Create(8);
    

    if (hExtRightList == NULL)
        ExitGracefully(hr, E_OUTOFMEMORY, "DPA_Create failed");

    hPropSetList = DPA_Create(8);

    if( hPropSetList == NULL )
        ExitGracefully(hr, E_OUTOFMEMORY, "DPA_Create failed");

    //
    // Get the schema search object
    //
    hr = OpenDSObject(pszSchemaSearchPath,
                       NULL,
                       NULL,
                       ADS_SECURE_AUTHENTICATION,
                       IID_IDirectorySearch,
                       (LPVOID*)&pSearch);
    FailGracefully(hr, "Failed to get schema search object");
    
    //
    // Set preferences to Asynchronous, OneLevel search, Paged results
    //
    prefInfo[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[0].vValue.Integer = ADS_SCOPE_ONELEVEL;

    prefInfo[1].dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;
    prefInfo[1].vValue.dwType = ADSTYPE_BOOLEAN;
    prefInfo[1].vValue.Boolean = TRUE;

    prefInfo[2].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    prefInfo[2].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[2].vValue.Integer = PAGE_SIZE;

    hr = pSearch->SetSearchPreference(prefInfo, ARRAYSIZE(prefInfo));
    FailGracefully(hr, "IDirectorySearch::SetSearchPreference failed");
    
    //
    // Do the search
    //
    hr = pSearch->ExecuteSearch(szFilter,
                                (LPWSTR*)pProperties,
                                ARRAYSIZE(pProperties),
                                &hSearch);
    FailGracefully(hr, "IDirectorySearch::ExecuteSearch failed");
    
    //
    // Loop through the rows, getting the name and ID of each property or class
    //
    for (;;)
    {
        ADS_SEARCH_COLUMN col;
        GUID guid;
        DWORD dwValidAccesses;
        LPWSTR pszName = NULL;
        WCHAR szDisplayName[MAX_PATH];

        hr = pSearch->GetNextRow(hSearch);

        if (FAILED(hr) || hr == S_ADS_NOMORE_ROWS)
            break;
        
        //
        // Get the GUID
        //
        if (FAILED(pSearch->GetColumn(hSearch, (LPWSTR)c_szRightsGuid, &col)))
        {
            TraceMsg("GUID not found for extended right");
            continue;
        }
        TraceAssert(col.dwADsType >= ADSTYPE_DN_STRING
                    && col.dwADsType <= ADSTYPE_NUMERIC_STRING);
        wsprintfW(szFilter, c_szGUIDFormat, col.pADsValues->CaseIgnoreString);
        CLSIDFromString(szFilter, &guid);
        pSearch->FreeColumn(&col);

        //
        // Get the valid accesses mask
        //
        if (FAILED(pSearch->GetColumn(hSearch, (LPWSTR)c_szValidAccesses, &col)))
        {
            TraceMsg("validAccesses not found for Extended Right");
            continue;
        }
        TraceAssert(col.dwADsType == ADSTYPE_INTEGER);
        TraceAssert(col.dwNumValues == 1);
        dwValidAccesses = (DWORD)(DS_GENERIC_ALL & col.pADsValues->Integer);
        pSearch->FreeColumn(&col);
        
        //
        // Get the display name
        //
        szDisplayName[0] = L'\0';
        if (SUCCEEDED(pSearch->GetColumn(hSearch, (LPWSTR)c_szDisplayID, &col)))
        {
            TraceAssert(col.dwADsType == ADSTYPE_INTEGER);
            TraceAssert(col.dwNumValues == 1);
            if (FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                              g_hInstance,
                              col.pADsValues->Integer,
                              0,
                              szDisplayName,
                              ARRAYSIZE(szDisplayName),
                              NULL))
            {
                pszName = szDisplayName;
            }
            pSearch->FreeColumn(&col);
        }

        if (NULL == pszName &&
            SUCCEEDED(pSearch->GetColumn(hSearch, (LPWSTR)c_szDisplayName, &col)))
        {
            TraceAssert(col.dwADsType >= ADSTYPE_DN_STRING
                        && col.dwADsType <= ADSTYPE_NUMERIC_STRING);
            lstrcpynW(szDisplayName, col.pADsValues->CaseIgnoreString, ARRAYSIZE(szDisplayName));
            pszName = szDisplayName;
            pSearch->FreeColumn(&col);
        }

        if (NULL == pszName)
        {
            TraceMsg("displayName not found for Extended Right");
            continue;
        }

        //
        //Create A new Cache Entry
        //
        PER_ENTRY pER = (PER_ENTRY)LocalAlloc(LPTR, sizeof(ER_ENTRY) + StringByteSize(pszName));
        if( pER == NULL )
            ExitGracefully(hr, E_OUTOFMEMORY, "LocalAlloc failed");

        pER->guid = guid;
        pER->mask = dwValidAccesses;
        pER->dwFlags = 0;
        lstrcpyW(pER->szName, pszName);
        
        //
        // Is it a Property Set?
        //
        if (dwValidAccesses & (ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP))
        {   
            //         
            // Insert into list
            //
            Trace((TEXT("Adding PropertySet\"%s\""), pszName));
            DPA_AppendPtr(hPropSetList, pER);
            dwValidAccesses &= ~(ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP);            
        }    
        else if (dwValidAccesses)
        {
            //
            // Must be a Control Right, Validated Write, etc.
            //
            Trace((TEXT("Adding Extended Right \"%s\""), pszName));
            DPA_AppendPtr(hExtRightList, pER);
        }
    }

    UINT cCount;
    //
    //Get the count of Extended Rights
    //
    cCount = DPA_GetPtrCount(hExtRightList);    
    if(!cCount)
    {
        DPA_Destroy(hExtRightList);
        hExtRightList = NULL;
    }
    else
    {
        DPA_Sort(hExtRightList, Schema_CompareER, 0);
    }
    //
    //Get the Count of PropertySets
    //
    cCount = DPA_GetPtrCount(hPropSetList);    
    if(!cCount)
    {
        DPA_Destroy(hPropSetList);
        hPropSetList = NULL;
    }
    else
    {
        DPA_Sort(hPropSetList,Schema_CompareER, 0 );
    }

    //
    //Add entry to the cache
    //
    if(!m_hObjectTypeCache)
        m_hObjectTypeCache = DPA_Create(4);
    
    if(!m_hObjectTypeCache)
        ExitGracefully(hr, E_OUTOFMEMORY, "DPA_Create Failed");

    if(!pOTC)
    {
        pOTC = (POBJECT_TYPE_CACHE)LocalAlloc(LPTR,sizeof(OBJECT_TYPE_CACHE));
        if(!pOTC)
            ExitGracefully(hr, E_OUTOFMEMORY, "LocalAlloc Failed");
        pOTC->guidObject = *pguidClass;
        DPA_AppendPtr(m_hObjectTypeCache, pOTC);
    }

    pOTC->hListExtRights = hExtRightList;
    pOTC->hListPropertySet = hPropSetList;
    pOTC->flags |= OTC_EXTR;


exit_gracefully:

    if (hSearch != NULL)
        pSearch->CloseSearchHandle(hSearch);

    DoRelease(pSearch);

    if (FAILED(hr))
    {
        if(hExtRightList)
        {
            DestroyDPA(hExtRightList);
            hExtRightList = NULL;
        }
        if(hPropSetList)
        {
            DestroyDPA(hPropSetList);
            hPropSetList = NULL;
        }                        
    }

    //
    //Set The Output
    //
    *phERList = hExtRightList;
    *phPropSetList = hPropSetList;

    TraceLeaveResult(hr);
}

//+--------------------------------------------------------------------------
//
//  Function:   GetChildClassesForOneClass
//
//  Synopsis:   This Function Gets the List of child classes for a class.
//
//  Arguments:  [pguidObjectType - IN] : ObjectGuidType of the class
//              [pszClassName - IN] : Class Name
//              [pszSchemaPath - IN] : Schema Search Path
//              [phChildList - OUT]: Output childclass List
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//
//  History:    3-Nov 2000  hiteshr   Created
//
//---------------------------------------------------------------------------

HRESULT
CSchemaCache::GetChildClassesForOneClass(IN LPCGUID pguidObjectType,
                                         IN LPCWSTR pszClassName,
                                         IN LPCWSTR pszSchemaPath,
                                         OUT HDPA *phChildList)
{
    TraceEnter(TRACE_SCHEMA, "CSchemaCache::GetChildClassesForOneClass");

    HRESULT hr = S_OK;
    BOOL bContainer = FALSE;
    VARIANT varContainment = {0};
    HDPA hClassList = NULL;
    UINT cChildClass = 0;
    POBJECT_TYPE_CACHE pOTC = NULL;

    if(!pguidObjectType || 
       !pszSchemaPath ||
       !phChildList)
    {
        Trace((L"Invalid Input Arguments Passed to Schema_GetExtendedRightsForOneClass"));
        return E_INVALIDARG;
    }

    //
    //Search in the cache
    //
    if (m_hObjectTypeCache != NULL)
    {
        UINT cItems = DPA_GetPtrCount(m_hObjectTypeCache);

        while (cItems > 0)
        {
            pOTC = (POBJECT_TYPE_CACHE)DPA_FastGetPtr(m_hObjectTypeCache, --cItems);
            //
            //Found A match.
            //
            if(IsEqualGUID(pOTC->guidObject, *pguidObjectType))    
                break;

            pOTC = NULL;
        }
        //
        //Have we already got the child classes
        //
        if(pOTC && pOTC->flags & OTC_COBJ)
        {
            *phChildList = pOTC->hListChildObject;
            return S_OK;
        }
    }

    //
    // Lookup the name of this class
    //
    if (pszClassName == NULL)
        pszClassName = GetClassName(pguidObjectType);

    if (pszClassName == NULL)
        ExitGracefully(hr, E_UNEXPECTED, "Unknown child object GUID");

    //
    // Figure out if the object is a container by getting the list of child
    // classes. 
    //
    IADsClass *pDsClass;

    //
    // Get the schema object for this class
    //
    hr = Schema_BindToObject(pszSchemaPath,
                             pszClassName,
                             IID_IADsClass,
                             (LPVOID*)&pDsClass);
    FailGracefully(hr, "Schema_BindToObjectFailed");

    //
    // Get the list of possible child classes
    //
    if (SUCCEEDED(pDsClass->get_Containment(&varContainment)))
    {
        if (V_VT(&varContainment) == (VT_ARRAY | VT_VARIANT))
        {
            LPSAFEARRAY psa = V_ARRAY(&varContainment);
            TraceAssert(psa && psa->cDims == 1);
            if (psa->rgsabound[0].cElements > 0)
            bContainer = TRUE;
        }
        else if (V_VT(&varContainment) == VT_BSTR) // single entry
        {
            TraceAssert(V_BSTR(&varContainment));
            bContainer = TRUE;
        }
                
        //
        // (Requires the schema class enumeration thread to complete first,
        // and it's usually not done yet the first time we get here.)
        //
        if(bContainer)
        {
            hClassList = DPA_Create(8);
            if (hClassList)
            {
                IDsDisplaySpecifier *pDisplaySpec = NULL;
                //
                // Get the display specifier object
                //
                CoCreateInstance(CLSID_DsDisplaySpecifier,
                                 NULL,
                                 CLSCTX_INPROC_SERVER,
                                 IID_IDsDisplaySpecifier,
                                 (void**)&pDisplaySpec);
                //
                // Filter the list & get display names
                //
                EnumVariantList(&varContainment,
                                hClassList,
                                SCHEMA_CLASS,
                                pDisplaySpec,
                                pszClassName,
                                FALSE);

                DoRelease(pDisplaySpec);

                //
                //Get the count of properties
                //
                cChildClass = DPA_GetPtrCount(hClassList);    
                if(!cChildClass)
                {
                    DPA_Destroy(hClassList);
                    hClassList = NULL;
                }
                else
                {   
                    //
                    //Sort The list
                    //
                    DPA_Sort(hClassList,Schema_ComparePropDisplayName, 0 );
                }
            }
        }
    }
    DoRelease(pDsClass);

    //
    //Add entry to the cache
    //
    if(!m_hObjectTypeCache)
        m_hObjectTypeCache = DPA_Create(4);
    
    if(!m_hObjectTypeCache)
        ExitGracefully(hr, E_OUTOFMEMORY, "DPA_Create Failed");

    if(!pOTC)
    {
        pOTC = (POBJECT_TYPE_CACHE)LocalAlloc(LPTR,sizeof(OBJECT_TYPE_CACHE));
        if(!pOTC)
            ExitGracefully(hr, E_OUTOFMEMORY, "LocalAlloc Failed");
        pOTC->guidObject = *pguidObjectType;
        DPA_AppendPtr(m_hObjectTypeCache, pOTC);
    }

    pOTC->hListChildObject = hClassList;
    pOTC->flags |= OTC_COBJ;

    


exit_gracefully:

    VariantClear(&varContainment);

    if(FAILED(hr))
    {
        DestroyDPA(hClassList);
        hClassList = NULL;
    }

    //
    //Set the Output
    //
    *phChildList = hClassList;

    TraceLeaveResult(hr);
}


//+--------------------------------------------------------------------------
//
//  Function:   GetPropertiesForOneClass
//
//  Synopsis:   This Function Gets the List of properties for a class.
//
//  Arguments:  [pguidObjectType - IN] : ObjectGuidType of the class
//              [pszClassName - IN] : Class Name
//              [pszSchemaPath - IN] : Schema Search Path
//              [phPropertyList - OUT]: Output Property List
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//
//  History:    3-Nov 2000  hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT
CSchemaCache::GetPropertiesForOneClass(IN LPCGUID pguidObjectType,
                                       IN LPCWSTR pszClassName,
                                       IN LPCWSTR pszSchemaPath,
                                       OUT HDPA *phPropertyList)
{
    HRESULT hr;
    IADsClass *pDsClass = NULL;
    VARIANT varMandatoryProperties = {0};
    VARIANT varOptionalProperties = {0};
    UINT cProperties = 0;
    IDsDisplaySpecifier *pDisplaySpec = NULL;
    HDPA hPropertyList = NULL;
    POBJECT_TYPE_CACHE pOTC = NULL;

    TraceEnter(TRACE_SCHEMA, "CSchemaCache::GetPropertiesForOneClass");

    if(!pguidObjectType || 
       !pszSchemaPath ||
       !phPropertyList)
    {
        Trace((L"Invalid Input Arguments Passed to CSchemaCache::GetPropertiesForOneClass"));
        return E_INVALIDARG;
    }

    //
    //Search in the cache
    //
    if (m_hObjectTypeCache != NULL)
    {
        UINT cItems = DPA_GetPtrCount(m_hObjectTypeCache);

        while (cItems > 0)
        {
            pOTC = (POBJECT_TYPE_CACHE)DPA_FastGetPtr(m_hObjectTypeCache, --cItems);
            //
            //Found A match.
            //
            if(IsEqualGUID(pOTC->guidObject, *pguidObjectType))    
                break;
            
            pOTC = NULL;
        }
        //
        //Have we already got the properties
        //
        if(pOTC && pOTC->flags & OTC_PROP)
        {
            *phPropertyList = pOTC->hListProperty;
            return S_OK;
        }
    }


    //
    // Get the schema object for this class
    //
    if (pszClassName == NULL)
        pszClassName = GetClassName(pguidObjectType);

    if (pszClassName == NULL)
        ExitGracefully(hr, E_UNEXPECTED, "Unknown child object GUID");

    hr = Schema_BindToObject(pszSchemaPath,
                             pszClassName,
                             IID_IADsClass,
                             (LPVOID*)&pDsClass);
    FailGracefully(hr, "Unable to create schema object");

    //
    // Get the display specifier object
    //
    CoCreateInstance(CLSID_DsDisplaySpecifier,
                     NULL,
                     CLSCTX_INPROC_SERVER,
                     IID_IDsDisplaySpecifier,
                     (void**)&pDisplaySpec);

    hPropertyList = DPA_Create(8);
    if (!hPropertyList)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to create DPA");

    //
    // Get mandatory and optional property lists
    //
    if (SUCCEEDED(pDsClass->get_MandatoryProperties(&varMandatoryProperties)))
    {
        EnumVariantList(&varMandatoryProperties,
                        hPropertyList,
                        0,
                        pDisplaySpec,
                        pszClassName,
                        FALSE);
    }
    if (SUCCEEDED(pDsClass->get_OptionalProperties(&varOptionalProperties)))
    {
        EnumVariantList(&varOptionalProperties,
                        hPropertyList,
                        0,
                        pDisplaySpec,
                        pszClassName,
                        FALSE);
    }

    //
    //Get the Number of properties
    //
    cProperties = DPA_GetPtrCount(hPropertyList);    
    if(!cProperties)
    {
        DPA_Destroy(hPropertyList);
        hPropertyList = NULL;
    }
    else
    {
        //
        //Sort The list
        //
        DPA_Sort(hPropertyList,Schema_ComparePropDisplayName, 0 );
    }

    //
    //Add entry to the cache
    //
    if(!m_hObjectTypeCache)
        m_hObjectTypeCache = DPA_Create(4);
    
    if(!m_hObjectTypeCache)
        ExitGracefully(hr, E_OUTOFMEMORY, "DPA_Create Failed");

    if(!pOTC)
    {
        pOTC = (POBJECT_TYPE_CACHE)LocalAlloc(LPTR,sizeof(OBJECT_TYPE_CACHE));
        if(!pOTC)
            ExitGracefully(hr, E_OUTOFMEMORY, "LocalAlloc Failed");
        pOTC->guidObject = *pguidObjectType;
        DPA_AppendPtr(m_hObjectTypeCache, pOTC);
    }

    pOTC->hListProperty = hPropertyList;
    pOTC->flags |= OTC_PROP;

exit_gracefully:

    VariantClear(&varMandatoryProperties);
    VariantClear(&varOptionalProperties);
    
    DoRelease(pDsClass);
    DoRelease(pDisplaySpec);

    if(FAILED(hr) && hPropertyList)
    {
        DestroyDPA(hPropertyList);
        hPropertyList = NULL;
    }
    //
    //Set the Output
    //
    *phPropertyList = hPropertyList;

    TraceLeaveResult(hr);
}
//+--------------------------------------------------------------------------
//
//  Function:   GetExtendedRightsForNClasses
//
//  Synopsis:   
//              This function gets the ExtendedRigts(control rights,
//              validated rights) and PropertySets for pszClassName and
//              all the classes in AuxTypeList. 
//              Function Merges Extended Rights of all the classes in to a 
//              signle list form which duplicates are removed and list 
//              is sorted.
//              Function Merges PropertySets of all the classes in to a 
//              signle list form which duplicates are removed and list 
//              is sorted.
//
//  Arguments:  [pguidClass - IN] : ObjectGuidType of the class
//              [hAuxList - IN]:List of Auxillary Classes
//              [pszSchemaSearchPath - IN] : Schema Search Path
//              [phERList - OUT]: Output Extended Rights list
//              [phPropSetList - OUT]: Output Propset List
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//  Note:       Calling function must call DPA_Destroy on *phERList and *phPropSetList
//              to Free the memory
//
//  History:    3-Nov 2000  hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT
CSchemaCache::GetExtendedRightsForNClasses(IN LPWSTR pszSchemaSearchPath,
                                           IN LPCGUID pguidClass,
                                           IN HDPA    hAuxList,
                                           OUT HDPA *phERList,
                                           OUT HDPA *phPropSetList)
{
    TraceEnter(TRACE_SCHEMA, "CSchemaCache::GetExtendedRightsForNClasses");

    if(!pguidClass || 
       !pszSchemaSearchPath)
    {
        Trace((L"Invalid Input Arguments Passed to CSchemaCache::GetPropertiesForNClasses"));
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    HDPA hERList = NULL;
    HDPA hPropSetList = NULL;
    HDPA hFinalErList = NULL;
    HDPA hFinalPropSetList = NULL;

    //
    //Get the extended rights for pguidClass
    //
    hr = GetExtendedRightsForOneClass(pszSchemaSearchPath,
                                      pguidClass,
                                      &hERList,
                                      &hPropSetList);
    FailGracefully(hr,"GetExtendedRightsForOneClasses failed");

    if(hERList && phERList)
    {
        UINT cCount = DPA_GetPtrCount(hERList);
        hFinalErList = DPA_Create(cCount);
        if(!hFinalErList)
            ExitGracefully(hr, ERROR_NOT_ENOUGH_MEMORY,"DPA_Create Failed");
        //
        //Copy hERList to hFinalErList
        //
        DPA_Merge(hFinalErList,             //Destination
                  hERList,                  //Source
                  DPAM_SORTED|DPAM_UNION,   //Already Sorted And give me union
                  Schema_CompareER,
                  _Merge,
                  0);        
    }                    

    if(hPropSetList && phPropSetList)
    {
        UINT cCount = DPA_GetPtrCount(hPropSetList);
        hFinalPropSetList = DPA_Create(cCount);
        if(!hFinalPropSetList)
            ExitGracefully(hr, ERROR_NOT_ENOUGH_MEMORY,"DPA_Create Failed");

        //
        //Copy hPropSetList to hFinalPropSetList
        //
        DPA_Merge(hFinalPropSetList,             //Destination
                  hPropSetList,                  //Source
                  DPAM_SORTED|DPAM_UNION,   //Already Sorted And give me union
                  Schema_CompareER,
                  _Merge,
                  0);        
    }                    
    //
    //For each auxclass get the extended rights
    //and property sets
    //
    if (hAuxList != NULL)
    {

        UINT cItems = DPA_GetPtrCount(hAuxList);

        while (cItems > 0)
        {
            PAUX_INFO pAI;
            pAI = (PAUX_INFO)DPA_FastGetPtr(hAuxList, --cItems);
            if(IsEqualGUID(pAI->guid, GUID_NULL))
            {
                hr = LookupClassID(pAI->pszClassName, &pAI->guid);
				FailGracefully(hr,"Cache Not available");
            }
            
            hERList = NULL;
            hPropSetList = NULL;
            //
            //Get the ER and PropSet for AuxClass
            //
            hr = GetExtendedRightsForOneClass(pszSchemaSearchPath,
                                              &pAI->guid,
                                              &hERList,
                                              &hPropSetList);
            FailGracefully(hr,"GetExtendedRightsForOneClasses failed");
                        
            if(hERList && phERList)
            {
                if(!hFinalErList)
                {
                    UINT cCount = DPA_GetPtrCount(hERList);
                    hFinalErList = DPA_Create(cCount);

                    if(!hFinalErList)
                        ExitGracefully(hr, ERROR_NOT_ENOUGH_MEMORY,"DPA_Create Failed");
                }
        
                //
                //Merge hERList into hFinalErList
                //
                DPA_Merge(hFinalErList,             //Destination
                          hERList,                  //Source
                          DPAM_SORTED|DPAM_UNION,   //Already Sorted And give me union
                          Schema_CompareER,
                          _Merge,
                          0);        
            }                    
            
            if(hPropSetList && phPropSetList)
            {
                if(!hFinalPropSetList)
                {
                    UINT cCount = DPA_GetPtrCount(hPropSetList);
                    hFinalPropSetList = DPA_Create(cCount);

                    if(!hFinalPropSetList)
                        ExitGracefully(hr, ERROR_NOT_ENOUGH_MEMORY,"DPA_Create Failed");
                }

                //
                //Merge hPropSetList into hFinalPropSetList
                //        
                DPA_Merge(hFinalPropSetList,             //Destination
                          hPropSetList,                  //Source
                          DPAM_SORTED|DPAM_UNION,   //Already Sorted And give me union
                          Schema_CompareER,
                          _Merge,
                          0);        
            }                    

        }
    }

exit_gracefully:
    if(FAILED(hr))
    {
        if(hFinalPropSetList)
            DPA_Destroy(hFinalPropSetList);    

        if(hFinalErList)
            DPA_Destroy(hFinalErList);    

        hFinalErList = NULL;
        hFinalPropSetList = NULL;
    }
    
    if(phERList)
        *phERList = hFinalErList;
    if(phPropSetList)
        *phPropSetList = hFinalPropSetList;                     
    
    TraceLeaveResult(hr);
}

//+--------------------------------------------------------------------------
//
//  Function:   GetChildClassesForNClasses
//
//  Synopsis:   
//              This function gets the childclasses for pszClassName and
//              all the classes in AuxTypeList. Function Merges child clasess
//              of all the classes in to a signle list form which duplicates 
//              are removed and list is sorted
//
//  Arguments:  [pguidObjectType - IN] : ObjectGuidType of the class
//              [pszClassName - IN] : Class Name
//              [hAuxList - IN]:List of Auxillary Classes
//              [pszSchemaPath - IN] : Schema Search Path
//              [phChildList - OUT]: Output Child Classes List
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//  Note:       Calling function must call DPA_Destroy on *phPropertyList to
//              Free the memory
//
//  History:    3-Nov 2000  hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT
CSchemaCache::GetChildClassesForNClasses(IN LPCGUID pguidObjectType,
                                             IN LPCWSTR pszClassName,
                                             IN HDPA hAuxList,
                                             IN LPCWSTR pszSchemaPath,
                                             OUT HDPA *phChildList)
{
    TraceEnter(TRACE_SCHEMA, "CSchemaCache::GetChildClassesForNClasses");

    if(!pguidObjectType || 
       !pszSchemaPath ||
       !phChildList)
    {
        Trace((L"Invalid Input Arguments Passed to CSchemaCache::GetPropertiesForNClasses"));
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    HDPA hChildList = NULL;
    HDPA hFinalChildList = NULL;

    //
    //Get the Child Classes for pszClassName
    //
    hr = GetChildClassesForOneClass(pguidObjectType,
                                    pszClassName,
                                    pszSchemaPath,
                                    &hChildList);
    FailGracefully(hr,"GetExtendedRightsForOneClasses failed");

    if(hChildList)
    {
        if(!hFinalChildList)
        {
            UINT cCount = DPA_GetPtrCount(hChildList);
            hFinalChildList = DPA_Create(cCount);
            if(!hFinalChildList)
                ExitGracefully(hr, ERROR_NOT_ENOUGH_MEMORY,"DPA_Create Failed");
        }
        //
        //Copy hChildList to hFinalChildList
        //
        DPA_Merge(hFinalChildList,             //Destination
                  hChildList,                  //Source
                  DPAM_SORTED|DPAM_UNION,      //Already Sorted And give me union
                  Schema_ComparePropDisplayName,
                  _Merge,
                  0);        
    }                    

    //
    //For each class in hAuxList get the child classes
    //
    if (hAuxList != NULL)
    {

        UINT cItems = DPA_GetPtrCount(hAuxList);

        while (cItems > 0)
        {
            PAUX_INFO pAI;
            pAI = (PAUX_INFO)DPA_FastGetPtr(hAuxList, --cItems);
            if(IsEqualGUID(pAI->guid, GUID_NULL))
            {
                hr = LookupClassID(pAI->pszClassName, &pAI->guid);
				FailGracefully(hr,"Cache Not available");
            }
            
            //
            //GetPropertiesForOneClass returns the list of handles
            //from cache so don't delete them. Simply set them to NULL
            //
            hChildList = NULL;
            
            hr = GetChildClassesForOneClass(&pAI->guid,
                                            pAI->pszClassName,
                                            pszSchemaPath,
                                            &hChildList);
            FailGracefully(hr,"GetExtendedRightsForOneClasses failed");
                        
            if(hChildList)
            {
                if(!hFinalChildList)
                {
                    UINT cCount = DPA_GetPtrCount(hChildList);
                    hFinalChildList = DPA_Create(cCount);
                    if(!hFinalChildList)
                        ExitGracefully(hr, ERROR_NOT_ENOUGH_MEMORY,"DPA_Create Failed");
                }
        
                //
                //Merge hChildList into hFinalChildList
                //
                DPA_Merge(hFinalChildList,             //Destination
                          hChildList,                  //Source
                          DPAM_SORTED|DPAM_UNION,      //Already Sorted And give me union
                          Schema_ComparePropDisplayName,
                          _Merge,
                          0);        
            }                    

        }
    }

exit_gracefully:
    if(FAILED(hr))
    {
        if(hFinalChildList)
            DPA_Destroy(hFinalChildList);    

        hFinalChildList = NULL;
    }
    
    //
    //Set the output
    //
    *phChildList = hFinalChildList;                     

    TraceLeaveResult(hr);
}

//+--------------------------------------------------------------------------
//
//  Function:   GetPropertiesForNClasses
//
//  Synopsis:   
//              This function gets the properties for pszClassName and
//              all the classes in AuxTypeList. Function Merges properties
//              of all the classes in to a signle list form which duplicates 
//
//  Arguments:  [pguidObjectType - IN] : ObjectGuidType of the class
//              [pszClassName - IN] : Class Name
//              [hAuxList - IN]:List of Auxillary Classes
//              [pszSchemaPath - IN] : Schema Search Path
//              [phPropertyList - OUT]: Output Property List
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//  Note:       Calling function must call DPA_Destroy on *phPropertyList to
//              Free the memory
//
//  History:    3-Nov 2000  hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT
CSchemaCache::
GetPropertiesForNClasses(IN LPCGUID pguidObjectType,
                         IN LPCWSTR pszClassName,
                         IN HDPA hAuxList,
                         IN LPCWSTR pszSchemaPath,
                         OUT HDPA *phPropertyList)
{
    TraceEnter(TRACE_SCHEMA, "CSchemaCache::GetPropertiesForOneClass");

    if(!pguidObjectType || 
       !pszSchemaPath ||
       !phPropertyList)
    {
        Trace((L"Invalid Input Arguments Passed to CSchemaCache::GetPropertiesForNClasses"));
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    HDPA hPropertyList = NULL;
    HDPA hFinalPropertyList = NULL;

    //
    //Get The properties for pszClassName
    //
    hr = GetPropertiesForOneClass(pguidObjectType,
                                  pszClassName,
                                  pszSchemaPath,
                                  &hPropertyList);
    FailGracefully(hr,"GetPropertiesForOneClass failed");

    if(hPropertyList)
    {
        UINT cCount = DPA_GetPtrCount(hPropertyList);
        hFinalPropertyList = DPA_Create(cCount);
        if(!hFinalPropertyList)
            ExitGracefully(hr, ERROR_NOT_ENOUGH_MEMORY,"DPA_Create Failed");

        //
        //Copy hPropertyList to hFinalPropertyList. 
        //
        DPA_Merge(hFinalPropertyList,             //Destination
                  hPropertyList,                  //Source
                  DPAM_SORTED|DPAM_UNION,         //Already Sorted And give me union
                  Schema_ComparePropDisplayName,
                  _Merge,
                  0);        
    }                    

    //
    //Get the properties for each class in hAuxList 
    //and add them to hFinalPropertyList
    //
    if (hAuxList != NULL)
    {

        UINT cItems = DPA_GetPtrCount(hAuxList);

        while (cItems > 0)
        {
            PAUX_INFO pAI;
            pAI = (PAUX_INFO)DPA_FastGetPtr(hAuxList, --cItems);
            if(IsEqualGUID(pAI->guid, GUID_NULL))
            {
                hr = LookupClassID(pAI->pszClassName, &pAI->guid);
				FailGracefully(hr,"Cache Not available");
            }
           
            //
            //GetPropertiesForOneClass returns the list of handles
            //from cache so don't delete them. Simply set them to NULL
            //
            hPropertyList = NULL;
            
            //
            //Get properties for Aux Class
            //
            hr = GetPropertiesForOneClass(&pAI->guid,
                                          pAI->pszClassName,
                                          pszSchemaPath,
                                          &hPropertyList);
            FailGracefully(hr,"GetExtendedRightsForOneClasses failed");
                        
            if(hPropertyList)
            {
                if(!hFinalPropertyList)
                {
                    UINT cCount = DPA_GetPtrCount(hPropertyList);
                    hFinalPropertyList = DPA_Create(cCount);
                    if(!hFinalPropertyList)
                        ExitGracefully(hr, ERROR_NOT_ENOUGH_MEMORY,"DPA_Create Failed");
                }
                //
                //Merge hPropertyList with hFinalPropertyList
                //
                DPA_Merge(hFinalPropertyList,             //Destination
                          hPropertyList,                  //Source
                          DPAM_SORTED|DPAM_UNION,         //Already Sorted And give me union
                          Schema_ComparePropDisplayName,
                          _Merge,
                          0);        
            }                    

        }
    }

exit_gracefully:
    if(FAILED(hr))
    {
        if(hFinalPropertyList)
            DPA_Destroy(hFinalPropertyList);    

        hFinalPropertyList = NULL;
    }
    //
    //Set the Output
    //
    *phPropertyList = hFinalPropertyList;                     

    TraceLeaveResult(hr);
}


//+--------------------------------------------------------------------------
//
//  Function:   DoesPathContainServer
//
//  Synopsis:   
//              Checks if the path contain server name in begining
//  Arguments:  [pszPath - IN] : Path to DS object
//
//  Returns:    BOOL: true if path contain server name
//                    false if not or error occurs    
//
//  History:    27 March 2000  hiteshr   Created
//
//---------------------------------------------------------------------------

bool DoesPathContainServer(LPCWSTR pszPath)
{

	IADsPathname *pPath = NULL;
	BSTR strServerName = NULL;
	bool bReturn = false;
    
	BSTR strObjectPath = SysAllocString(pszPath);
	if(!strObjectPath)
		return false;


	//
	// Create an ADsPathname object to parse the path and get the
	// server name 
	//
	HRESULT hr = CoCreateInstance(CLSID_Pathname,
								  NULL,
								  CLSCTX_INPROC_SERVER,
								  IID_IADsPathname,
								  (LPVOID*)&pPath);
	if (pPath)
	{
		//
		//Set Full Path
		//
		if (SUCCEEDED(pPath->Set(strObjectPath, ADS_SETTYPE_FULL)))
		{
			//
			//Retrieve servername
			//
			hr = pPath->Retrieve(ADS_FORMAT_SERVER, &strServerName);
			if(SUCCEEDED(hr) && strServerName)
			{
				bReturn = true;
			}
		}
	}
	
	DoRelease(pPath);
	if(strServerName)
		SysFreeString(strServerName);
	SysFreeString(strObjectPath);

	return bReturn;
}

//*************************************************************
//
//  OpenDSObject()
//
//  Purpose:    Calls AdsOpenObject with ADS_SERVER_BIND
//  Return:		Same as AdsOpenObject
//
//*************************************************************

HRESULT OpenDSObject (LPTSTR lpPath, LPTSTR lpUserName, LPTSTR lpPassword, DWORD dwFlags, REFIID riid, void FAR * FAR * ppObject)
{
    if (DoesPathContainServer(lpPath))
    {
        dwFlags |= ADS_SERVER_BIND;
    }

    return (ADsOpenObject(lpPath, lpUserName, lpPassword, dwFlags,
                          riid, ppObject));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\dssec\sources.inc ===
TARGETNAME= dssec
TARGETTYPE= DYNLINK
TARGETPATH= obj

PASS1_PUBLISH={$(O)\$(TARGETNAME).lib=$(SDK_LIB_PATH)\$(TARGETNAME).lib}

MSC_WARNING_LEVEL= /W4
DLLDEF=$(O)\$(TARGETNAME).def

DLLENTRY=   DllMain

INCLUDES=..;$(O);..\..\inc;$(BASE_INC_PATH);$(DS_INC_PATH)

LINKLIBS=\
    ..\..\common\winnt\$(O)\common.lib \

TARGETLIBS=\
    $(SDK_LIB_PATH)\kernel32.lib    \
    $(SDK_LIB_PATH)\user32.lib      \
    $(SHELL_LIB_PATH)\comctlp.lib     \
    $(SDK_LIB_PATH)\advapi32.lib    \
    $(SDK_LIB_PATH)\uuid.lib        \
    $(SDK_LIB_PATH)\ole32.lib       \
    $(SDK_LIB_PATH)\oleaut32.lib    \
    $(SDK_LIB_PATH)\adsiid.lib      \
    $(SDK_LIB_PATH)\activeds.lib    \
    $(SDK_LIB_PATH)\authz.lib    \

SOURCES=\
    ..\extrts.mc    \
    ..\resource.rc  \
    ..\dll.cpp      \
    ..\cstrings.cpp \
    ..\security.cpp \
    ..\dssi.cpp     \
    ..\schema.cpp   \
    ..\exnc.cpp     \

MISCFILES=\
    ..\dssec.dat

PASS0_SOURCEDIR=$(O)
PASS0_HEADERDIR=$(O)

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pch.h
PRECOMPILED_PCH=pch.pch
PRECOMPILED_OBJ=pch.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\dssec\security.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       security.cpp
//
//  Invoke the security UI for DS objects
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <dssec.h>


/*-----------------------------------------------------------------------------
/ CDsSecurityClassFactory
/   Class factory for the Security property page and context menu
/----------------------------------------------------------------------------*/

#undef CLASS_NAME
#define CLASS_NAME CDsSecurityClassFactory
#include <unknown.inc>

STDMETHODIMP
CDsSecurityClassFactory::QueryInterface(REFIID riid, LPVOID* ppvObject)
{
    INTERFACES iface[] =
    {
        &IID_IClassFactory, (LPCLASSFACTORY)this,
    };

    return HandleQueryInterface(riid, ppvObject, iface, ARRAYSIZE(iface));
}


/*-----------------------------------------------------------------------------
/ IClassFactory methods
/----------------------------------------------------------------------------*/

STDMETHODIMP
CDsSecurityClassFactory::CreateInstance(LPUNKNOWN punkOuter,
                                        REFIID riid,
                                        LPVOID* ppvObject)
{
    HRESULT hr;
    CDsSecurity* pDsSecurity;

    TraceEnter(TRACE_SECURITY, "CDsSecurityClassFactory::CreateInstance");
    TraceGUID("Interface requested", riid);

    TraceAssert(ppvObject);

    if (punkOuter)
        ExitGracefully(hr, CLASS_E_NOAGGREGATION, "Aggregation is not supported");

    pDsSecurity = new CDsSecurity;

    if (!pDsSecurity)
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate CDsSecurity");

    hr = pDsSecurity->QueryInterface(riid, ppvObject);

    if (FAILED(hr))
        delete pDsSecurity;

exit_gracefully:

    TraceLeaveResult(hr);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP
CDsSecurityClassFactory::LockServer(BOOL /*fLock*/)
{
    return E_NOTIMPL;               // not supported
}


/*-----------------------------------------------------------------------------
/ CDsSecurity
/   Security property page and context menu shell extension
/----------------------------------------------------------------------------*/

// Destructor

CDsSecurity::~CDsSecurity()
{
    DoRelease(m_pSI);
}

// IUnknown bits

#undef CLASS_NAME
#define CLASS_NAME CDsSecurity
#include "unknown.inc"

STDMETHODIMP
CDsSecurity::QueryInterface(REFIID riid, LPVOID* ppvObject)
{
    INTERFACES iface[] =
    {
        &IID_IShellExtInit, (LPSHELLEXTINIT)this,
        &IID_IShellPropSheetExt, (LPSHELLPROPSHEETEXT)this,
        &IID_IContextMenu, (LPCONTEXTMENU)this,
    };

    return HandleQueryInterface(riid, ppvObject, iface, ARRAYSIZE(iface));
}


/*----------------------------------------------------------------------------
/ IShellExtInit
/----------------------------------------------------------------------------*/

STDMETHODIMP
CDsSecurity::Initialize(LPCITEMIDLIST /*pIDFolder*/,
                        LPDATAOBJECT pDataObj,
                        HKEY /*hKeyID*/)
{
    HRESULT hr;
    FORMATETC fe = {0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medObjectNames = {0};
    STGMEDIUM medDisplayOptions = {0};
    LPDSOBJECTNAMES pDsObjects;
    LPWSTR pObjectPath;
    LPWSTR pClass = NULL;
    DWORD dwFlags = 0;
    LPWSTR pszServer = NULL;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;

    static CLIPFORMAT cfDsObjectNames = 0;
    static CLIPFORMAT cfDsDisplayOptions = 0;

    TraceEnter(TRACE_SECURITY, "CDsSecurity::Initialize");

    DoRelease(m_pSI);

    // Call the data object to get the array of DS names and classes.  This
    // is stored using a private clipboard format - so we must first
    // try and register it.

    if (!cfDsObjectNames)
        cfDsObjectNames = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);

    if (!cfDsObjectNames)
        ExitGracefully(hr, E_FAIL, "Clipboard format failed to register");

    fe.cfFormat = cfDsObjectNames;            // set the clipboard format

    if (!pDataObj)
        ExitGracefully(hr, E_INVALIDARG, "No data object given");

    hr = pDataObj->GetData(&fe, &medObjectNames);
    FailGracefully(hr, "Failed to get selected objects");

    pDsObjects = (LPDSOBJECTNAMES)medObjectNames.hGlobal;
    TraceAssert(pDsObjects);

    if (!(pDsObjects->aObjects[0].dwProviderFlags & DSPROVIDER_ADVANCED))
        ExitGracefully(hr, E_FAIL, "Security page only shown in advanced mode");

    if (1 != pDsObjects->cItems)
        ExitGracefully(hr, E_FAIL, "Multiple selection not supported");

    // Get the object path
    pObjectPath = (LPWSTR)ByteOffset(pDsObjects, pDsObjects->aObjects[0].offsetName);
    Trace((TEXT("Name \"%s\""), pObjectPath));

    // Get the class name
    if (pDsObjects->aObjects[0].offsetClass)
    {
        pClass = (LPWSTR)ByteOffset(pDsObjects, pDsObjects->aObjects[0].offsetClass);
        Trace((TEXT("Class \"%s\""), pClass));
    }

// DSOBJECT_READONLYPAGES is no longer used
#ifdef DSOBJECT_READONLYPAGES
    if (pDsObjects->aObjects[0].dwFlags & DSOBJECT_READONLYPAGES)
        dwFlags = DSSI_READ_ONLY;
#endif

    //
    // Get server name and user credentials from the data object
    //
    if (!cfDsDisplayOptions)
        cfDsDisplayOptions = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DS_DISPLAY_SPEC_OPTIONS);
    if (cfDsDisplayOptions)
    {
        fe.cfFormat = cfDsDisplayOptions;
        hr = pDataObj->GetData(&fe, &medDisplayOptions);
        if (SUCCEEDED(hr))
        {
            LPDSDISPLAYSPECOPTIONS pDisplayOptions = (LPDSDISPLAYSPECOPTIONS)medDisplayOptions.hGlobal;

            if (pDisplayOptions->dwFlags & DSDSOF_HASUSERANDSERVERINFO)
            {
                if (pDisplayOptions->offsetServer)
                    pszServer = (LPWSTR)ByteOffset(pDisplayOptions, pDisplayOptions->offsetServer);
                if (pDisplayOptions->offsetUserName)
                    pszUserName = (LPWSTR)ByteOffset(pDisplayOptions, pDisplayOptions->offsetUserName);
                if (pDisplayOptions->offsetPassword)
                    pszPassword = (LPWSTR)ByteOffset(pDisplayOptions, pDisplayOptions->offsetPassword);

                Trace((TEXT("Display Options: server = %s; user = %s; pw = %s"),
                      pszServer?pszServer:TEXT("none"),
                      pszUserName?pszUserName:TEXT("none"),
                      pszPassword?pszPassword:TEXT("none")));
            }
        }
    }

    //
    // Create and initialize the ISecurityInformation object.
    //
    hr = DSCreateISecurityInfoObjectEx(pObjectPath,
                                       pClass,
                                       pszServer,
                                       pszUserName,
                                       pszPassword,
                                       dwFlags,
                                       &m_pSI,
                                       NULL,
                                       NULL,
                                       0);

exit_gracefully:

    ReleaseStgMedium(&medDisplayOptions);
    ReleaseStgMedium(&medObjectNames);

    TraceLeaveResult(hr);
}


/*----------------------------------------------------------------------------
/ IShellPropSheetExt
/----------------------------------------------------------------------------*/

STDMETHODIMP
CDsSecurity::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage,
                      LPARAM               lParam)
{
    HRESULT hr = E_FAIL;

    TraceEnter(TRACE_SECURITY, "CDsSecurity::AddPages");

    if (m_pSI != NULL)
    {
        HPROPSHEETPAGE hPermPage = NULL;

        hr = _CreateSecurityPage(m_pSI, &hPermPage);

        if (NULL != hPermPage && !lpfnAddPage(hPermPage, lParam))
            DestroyPropertySheetPage(hPermPage);
    }

    TraceLeaveResult(hr);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP
CDsSecurity::ReplacePage(UINT                 /* uPageID */,
                         LPFNADDPROPSHEETPAGE /* lpfnReplaceWith */,
                         LPARAM               /* lParam */)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------------------------
/ IContextMenu
/----------------------------------------------------------------------------*/

STDMETHODIMP
CDsSecurity::QueryContextMenu(HMENU hMenu,
                              UINT indexMenu,
                              UINT idCmdFirst,
                              UINT /*idCmdLast*/,
                              UINT /*uFlags*/)
{
    TCHAR szBuffer[MAX_PATH];
    MENUITEMINFO mii;
    int idMax = idCmdFirst;

    TraceEnter(TRACE_SECURITY, "CDsSecurity::QueryContextMenu");

    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_TYPE | MIIM_ID;
    mii.fType = MFT_STRING;
    mii.dwTypeData = szBuffer;
    mii.cch = lstrlen(szBuffer);

    // Merge our verbs into the menu we were given

    LoadString(GLOBAL_HINSTANCE, IDS_SECURITY, szBuffer, ARRAYSIZE(szBuffer));

    mii.wID = idMax++;

    InsertMenuItem(hMenu,
                   indexMenu++,
                   TRUE /*fByPosition*/,
                   &mii);

    TraceLeaveValue(ResultFromShort(idMax - idCmdFirst));
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP
CDsSecurity::InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi)
{
    HRESULT hr = E_FAIL;

    TraceEnter(TRACE_SECURITY, "CDsSecurity::InvokeCommand");

    if (HIWORD(lpcmi->lpVerb) != 0)
        TraceLeaveResult(E_NOTIMPL);

    TraceAssert(LOWORD(lpcmi->lpVerb) == 0);

    // REVIEW If they ever get around to making property pages work
    // for DS objects, we can replace this with
    // ShellExecuteEx(verb=Properties, parameters=Security) [see ..\rshx32\rshx32.cpp]
    if (m_pSI != NULL)
        hr = _EditSecurity(lpcmi->hwnd, m_pSI);

    TraceLeaveResult(hr);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP
CDsSecurity::GetCommandString(UINT_PTR /*idCmd*/,
                              UINT uFlags,
                              LPUINT /*reserved*/,
                              LPSTR pszName,
                              UINT ccMax)
{
    if (uFlags == GCS_HELPTEXT)
    {
        LoadString(GLOBAL_HINSTANCE, IDS_SECURITYHELP, (LPTSTR)pszName, ccMax);
        return S_OK;
    }

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\dssec\security.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       security.h
//
//--------------------------------------------------------------------------

#ifndef __security_h
#define __security_h


/*-----------------------------------------------------------------------------
/ CDsSecurityClassFactory
/----------------------------------------------------------------------------*/

class CDsSecurityClassFactory : public IClassFactory, CUnknown
{
public:
    // IUnkown
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP         QueryInterface(REFIID riid, LPVOID* ppvObject);

    // IClassFactory
    STDMETHODIMP CreateInstance(IUnknown* pOuter, REFIID riid, LPVOID* ppvObject);
    STDMETHODIMP LockServer(BOOL fLock);
};


/*-----------------------------------------------------------------------------
/ CDsSecurity
/----------------------------------------------------------------------------*/

class CDsSecurity : public IShellExtInit, IShellPropSheetExt, IContextMenu, CUnknown
{
private:
    LPSECURITYINFO m_pSI;

public:
    virtual ~CDsSecurity();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObject);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj, HKEY hKeyID);

    // IShellPropSheetExt methods
    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE, LPARAM);
    STDMETHODIMP ReplacePage(UINT, LPFNADDPROPSHEETPAGE, LPARAM);

    // IContextMenu
    STDMETHODIMP QueryContextMenu(HMENU hShellMenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHODIMP InvokeCommand( LPCMINVOKECOMMANDINFO lpcmi);
    STDMETHODIMP GetCommandString( UINT_PTR idCmd, UINT uFlags, UINT FAR* reserved, LPSTR pszName, UINT ccMax);
};


#endif  // __security_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\inc\debug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       debug.h
//
//--------------------------------------------------------------------------

#ifndef __debug_h
#define __debug_h

#if DBG
#define DEBUG
#else
#undef  DEBUG
#endif


/*-----------------------------------------------------------------------------
/ Debugging APIs (use the Macros, they make it easier and cope with correctly
/ removing debugging when it is disabled at build time).
/----------------------------------------------------------------------------*/
void DoTraceSetMask(DWORD dwMask);
void DoTraceSetMaskFromRegKey(HKEY hkRoot, LPCTSTR pszSubKey);
void DoTraceSetMaskFromCLSID(REFCLSID rCLSID);
void DoTraceEnter(DWORD dwMask, LPCTSTR pName);
void DoTraceLeave(void);
void DoTrace(LPCTSTR pFormat, ...);
void DoTraceGUID(LPCTSTR pPrefix, REFGUID rGUID);
void DoTraceAssert(int iLine, LPTSTR pFilename);


/*-----------------------------------------------------------------------------
/ Macros to ease the use of the debugging APIS.
/----------------------------------------------------------------------------*/

#ifdef DEBUG

void DebugThreadDetach(void);           // optional
void DebugProcessAttach(void);          // required
void DebugProcessDetach(void);          // required

#define TraceSetMask(dwMask)            DoTraceSetMask(dwMask)
#define TraceSetMaskFromRegKey(hk, psz) DoTraceSetMaskFromRegKey(hk, psz)
#define TraceSetMaskFromCLSID(rCLSID)   DoTraceSetMaskFromCLSID(rCLSID)
#define TraceEnter(dwMask, fn)          DoTraceEnter(dwMask, TEXT(fn))
#define TraceLeave()                    DoTraceLeave()

#define Trace(x)                        DoTrace x
#define TraceMsg(s)                     DoTrace(TEXT(s))
#define TraceGUID(s, rGUID)             DoTraceGUID(TEXT(s), rGUID)

#define TraceAssert(x) \
                { if ( !(x) ) DoTraceAssert(__LINE__, TEXT(__FILE__)); }

#define TraceLeaveResult(hr) \
                { HRESULT __hr = (hr); if (FAILED(__hr)) Trace((TEXT("Failed (%08x)"), __hr)); TraceLeave(); return __hr; }

#define TraceLeaveVoid() \
                { TraceLeave(); return; }

#define TraceLeaveValue(value) \
                { TraceLeave(); return (value); }

#else   // !DEBUG

#define DebugThreadDetach()
#define DebugProcessAttach()
#define DebugProcessDetach()

#define TraceSetMask(dwMask)
#define TraceSetMaskFromRegKey(hk, psz)
#define TraceSetMaskFromCLSID(rCLSID)
#define TraceEnter(dwMask, fn)
#define TraceLeave()

#define Trace(x)
#define TraceMsg(s)
#define TraceGUID(s, rGUID)

#define TraceAssert(x)
#define TraceLeaveResult(hr)    { return (hr); }
#define TraceLeaveVoid()        { return; }
#define TraceLeaveValue(value)  { return (value); }

#endif  // DEBUG


#endif  // __debug_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\dssec\filter\filter.cpp ===
#include <windows.h>
#include <ole2.h>
#include <activeds.h>
#include <commctrl.h>
#include <comctrlp.h>       // DPA/DSA

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)    (sizeof(a)/sizeof((a)[0]))
#endif

BOOL
_printf(LPCSTR pszFormat, ...)
{
    char szBuffer[MAX_PATH * 2];
    DWORD cchWritten;
    va_list va;

    va_start(va, pszFormat);
    wvsprintfA(szBuffer, pszFormat, va);
    va_end(va);

    lstrcatA(szBuffer, "\n");

    return WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),
                     szBuffer,
                     lstrlenA(szBuffer),
                     &cchWritten,
                     NULL);
}

#define FailGracefully(hr, s)       { if (FAILED(hr)) { _printf(s); goto exit_gracefully; } }
#define ExitGracefully(hr, e, s)    { hr = (e); if (FAILED(hr)) { _printf(s); } goto exit_gracefully; }

WCHAR const c_szFilterFile[]        = L"dssec.dat";
WCHAR const c_szClassProp[]         = L"@";
WCHAR const c_szLDAPDisplayName[]   = L"lDAPDisplayName";

WCHAR g_szOldFile[MAX_PATH];
WCHAR g_szTmpFile[MAX_PATH];
WCHAR g_szNewFile[MAX_PATH];

HANDLE g_hTmpFile = INVALID_HANDLE_VALUE;
HANDLE g_hNewFile = INVALID_HANDLE_VALUE;

typedef struct _SECTION_INFO
{
    DWORD dwBeginOffset;
    DWORD dwEndOffset;
    WCHAR szSectionName[ANYSIZE_ARRAY];
} SECTION_INFO, *PSECTION_INFO;

void
_PathAppend(LPWSTR pszPath, LPCWSTR pszMore)
{
    if (pszPath && pszMore)
    {
        UINT cch = lstrlenW(pszPath);
        if (0 == cch || cch >= MAX_PATH)
            return;
        if (pszPath[cch-1] != L'\\')
            pszPath[cch++] = L'\\';
        lstrcpynW(pszPath + cch, pszMore, MAX_PATH - cch);
    }
}

int CALLBACK
_LocalFreeCB(LPVOID pVoid, LPVOID /*pData*/)
{
    LocalFree(pVoid);
    return 1;
}

int CALLBACK
WriteValueCB(LPVOID pProp, LPVOID pClass)
{
    LPCWSTR pszProp = (LPCWSTR)pProp;
    LPCWSTR pszClass = (LPCWSTR)pClass;
    if (pszProp && pszClass)
    {
        DWORD dwFlags = GetPrivateProfileIntW(pszClass, pszProp, 0, g_szOldFile);
        char szValue[MAX_PATH];
        DWORD dwWritten;
        wsprintfA(szValue, "%S=%d\r\n", pszProp, dwFlags);
        WriteFile(g_hTmpFile, szValue, lstrlenA(szValue), &dwWritten, NULL);
    }
    return 1;
}

int CALLBACK
StringCompareCB(LPVOID p1, LPVOID p2, LPARAM lParam)
{
    int nResult = 0;
    if (p1 && p2)
    {
        nResult = CompareStringW(LOCALE_USER_DEFAULT,
                                 0,
                                 (LPCWSTR)p1,
                                 -1,
                                 (LPCWSTR)p2,
                                 -1) - CSTR_EQUAL;
    }
    return nResult;
}

int CALLBACK
SectionCompareCB(LPVOID p1, LPVOID p2, LPARAM lParam)
{
    int nResult = 0;
    PSECTION_INFO psi1 = (PSECTION_INFO)p1;
    PSECTION_INFO psi2 = (PSECTION_INFO)p2;
    if (psi1 && psi2)
    {
        nResult = CompareStringW(LOCALE_USER_DEFAULT,
                                 0,
                                 psi1->szSectionName,
                                 -1,
                                 psi2->szSectionName,
                                 -1) - CSTR_EQUAL;
    }
    return nResult;
}

int CALLBACK
WriteSectionCB(LPVOID pSection, LPVOID pData)
{
    PSECTION_INFO psi = (PSECTION_INFO)pSection;
    if (psi && pData)
    {
        DWORD dwWritten;
        pSection = ((PBYTE)pData) + psi->dwBeginOffset;
        WriteFile(g_hNewFile, pSection, psi->dwEndOffset - psi->dwBeginOffset, &dwWritten, NULL);
    }
    return 1;
}


BOOL
EnumVariantList(LPVARIANT pvarList, HDPA hList)
{
    LPVARIANT pvarProperty = NULL;
    ULONG cProperties = 0;

    if (V_VT(pvarList) == (VT_ARRAY | VT_VARIANT))
    {
        SafeArrayAccessData(V_ARRAY(pvarList), (LPVOID*)&pvarProperty);
        cProperties = V_ARRAY(pvarList)->rgsabound[0].cElements;
    }
    else if (V_VT(pvarList) == VT_BSTR)
    {
        pvarProperty = pvarList;
        cProperties = 1;
    }
    else
    {
        // Unknown format
        return FALSE;
    }

    for ( ; cProperties > 0; pvarProperty++, cProperties--)
    {
        if (V_VT(pvarProperty) == VT_BSTR)
            DPA_AppendPtr(hList, V_BSTR(pvarProperty));
    }

    if (V_VT(pvarList) == (VT_ARRAY | VT_VARIANT))
    {
        SafeArrayUnaccessData(V_ARRAY(pvarList));
    }

    return TRUE;
}


HRESULT
GenerateFilterFile(LPWSTR pszSchemaSearchPath, HDPA hClassList)
{
    HRESULT hr = S_OK;
    IDirectorySearch *pSchemaSearch = NULL;
    ADS_SEARCH_HANDLE hSearch = NULL;
    ADS_SEARCHPREF_INFO prefInfo[2];
    WCHAR szSchemaPath[MAX_PATH] = L"LDAP://Schema/";
    ULONG nSchemaRootLen = lstrlenW(szSchemaPath);
    const LPCWSTR pProperties[] =
    {
        c_szLDAPDisplayName,
    };
    HDPA hAttributes;

    if (!hClassList)
        return E_INVALIDARG;

    hAttributes = DPA_Create(64);
    if (!hAttributes)
        ExitGracefully(hr, E_OUTOFMEMORY, "Out of memory");

    // Get the schema search object
    hr = ADsGetObject(pszSchemaSearchPath, IID_IDirectorySearch, (LPVOID*)&pSchemaSearch);
    FailGracefully(hr, "Unable to bind to Schema container");

    prefInfo[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[0].vValue.Integer = ADS_SCOPE_SUBTREE;

    prefInfo[1].dwSearchPref = ADS_SEARCHPREF_SORT_ON;
    prefInfo[1].vValue.dwType = ADSTYPE_BOOLEAN;
    prefInfo[1].vValue.Boolean = TRUE;

    hr = pSchemaSearch->SetSearchPreference(prefInfo, 2);

    // Do the search
    hr = pSchemaSearch->ExecuteSearch(L"(objectClass=classSchema)",
                                      (LPWSTR*)pProperties,
                                      ARRAYSIZE(pProperties),
                                      &hSearch);
    FailGracefully(hr, "Schema search failed");

    // Loop through the rows, getting the name of each class
    for (;;)
    {
        ADS_SEARCH_COLUMN colClassName = {0};
        IADsClass *pClass = NULL;
        VARIANT varMandatory = {0};
        VARIANT varOptional = {0};
        LPCWSTR pszClass;
        PSECTION_INFO pSectionInfo;

        hr = pSchemaSearch->GetNextRow(hSearch);
        FailGracefully(hr, "Search error");

        if (hr == S_ADS_NOMORE_ROWS)
        {
            hr = S_OK;
            break;
        }

        // Get class name
        hr = pSchemaSearch->GetColumn(hSearch, (LPWSTR)c_szLDAPDisplayName, &colClassName);
        if (FAILED(hr))
            continue;

        pszClass = colClassName.pADsValues->CaseIgnoreString;

        // Remember where this section begins in the file
        pSectionInfo = (PSECTION_INFO)LocalAlloc(LPTR, sizeof(SECTION_INFO) + lstrlenW(pszClass)*sizeof(WCHAR));
        if (!pSectionInfo)
        {
            pSchemaSearch->FreeColumn(&colClassName);
            continue;
        }
        pSectionInfo->dwBeginOffset = SetFilePointer(g_hTmpFile, 0, NULL, FILE_CURRENT);
        lstrcpyW(pSectionInfo->szSectionName, pszClass);
        DPA_AppendPtr(hClassList, pSectionInfo);

        _printf("%S", pszClass);

        // Write the [class] header
        char szSection[MAX_PATH];
        DWORD dwWritten;
        wsprintfA(szSection, "\r\n[%S]\r\n", pszClass);
        WriteFile(g_hTmpFile, szSection, lstrlenA(szSection), &dwWritten, NULL);

        // Write the "@=" value
        WriteValueCB((LPVOID)c_szClassProp, (LPVOID)pszClass);

        lstrcpyW(szSchemaPath + nSchemaRootLen, pszClass);
        hr = ADsGetObject(szSchemaPath, IID_IADsClass, (LPVOID*)&pClass);
        if (SUCCEEDED(hr))
        {
            hr = pClass->get_MandatoryProperties(&varMandatory);
            if (SUCCEEDED(hr))
                EnumVariantList(&varMandatory, hAttributes);

            hr = pClass->get_OptionalProperties(&varOptional);
            if (SUCCEEDED(hr))
                EnumVariantList(&varOptional, hAttributes);

            pClass->Release();
        }

        // Sort attribute names
        DPA_Sort(hAttributes, StringCompareCB, 0);

        // Write attribute values
        DPA_EnumCallback(hAttributes, WriteValueCB, (LPVOID)pszClass);

        // Remember where this section ends
        pSectionInfo->dwEndOffset = SetFilePointer(g_hTmpFile, 0, NULL, FILE_CURRENT);

        // Clear the DPA for the next class
        DPA_DeleteAllPtrs(hAttributes);

        VariantClear(&varMandatory);
        VariantClear(&varOptional);

        pSchemaSearch->FreeColumn(&colClassName);
    }

exit_gracefully:

    if (hAttributes)
        DPA_Destroy(hAttributes);

    if (hSearch)
        pSchemaSearch->CloseSearchHandle(hSearch);

    if (pSchemaSearch)
        pSchemaSearch->Release();

    return hr;
}


extern "C"
int __cdecl
main()
{
    HRESULT hr;
    IADs *pRootDSE = NULL;
    VARIANT var = {0};
    WCHAR szSchemaSearchPath[MAX_PATH] = L"LDAP://";
    HDPA hClassList = DPA_Create(64);
    HANDLE hMap;
    PVOID pFileMap = NULL;

    if (!hClassList)
        ExitGracefully(hr, E_OUTOFMEMORY, "Out of memory");

    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    hr = ADsGetObject(L"LDAP://RootDSE", IID_IADs, (LPVOID*)&pRootDSE);
    FailGracefully(hr, "Unable to bind to RootDSE");

    hr = pRootDSE->Get(L"schemaNamingContext", &var);
    FailGracefully(hr, "Unable to get schemaNamingContext");

    lstrcatW(szSchemaSearchPath, V_BSTR(&var));

    g_szNewFile[0] = L'\0';
    GetCurrentDirectoryW(ARRAYSIZE(g_szNewFile), g_szNewFile);
    lstrcpyW(g_szTmpFile, g_szNewFile);
    _PathAppend(g_szTmpFile, L"dssec.tmp");
    _PathAppend(g_szNewFile, c_szFilterFile);

    g_szOldFile[0] = L'\0';
    GetSystemDirectoryW(g_szOldFile, ARRAYSIZE(g_szOldFile));
    _PathAppend(g_szOldFile, c_szFilterFile);

    // Create temp file
    g_hTmpFile = CreateFileW(g_szTmpFile,
                             GENERIC_READ | GENERIC_WRITE,
                             0,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE,
                             NULL);
    if (INVALID_HANDLE_VALUE == g_hTmpFile)
    {
        _printf("Unable to create temporary file: %S", g_szTmpFile);
        goto exit_gracefully;
    }

    // Query the schema and build the temp file
    hr = GenerateFilterFile(szSchemaSearchPath, hClassList);
    FailGracefully(hr, "Aborting due to error");

    // Sort the section list
    DPA_Sort(hClassList, SectionCompareCB, 0);

    // Map temp file into memory.  We use 0 for the size, which means
    // map the entire file, so must do this after building the file.
    hMap = CreateFileMappingW(g_hTmpFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (hMap)
    {
        pFileMap = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
        CloseHandle(hMap);
    }
    if (NULL == pFileMap)
        goto exit_gracefully;

    // Make sure we don't overwrite the old file
    if (!lstrcmpiW(g_szOldFile, g_szNewFile))
    {
        // Same path, rename the existing version as a backup
        lstrcatW(g_szOldFile, L".old");
        MoveFileExW(g_szNewFile, g_szOldFile, MOVEFILE_REPLACE_EXISTING);
    }

    // Create new file
    g_hNewFile = CreateFileW(g_szNewFile,
                             GENERIC_WRITE,
                             FILE_SHARE_READ,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                             NULL);
    if (INVALID_HANDLE_VALUE != g_hNewFile)
    {
        // Write the new file, sorted by section
        DPA_EnumCallback(hClassList, WriteSectionCB, (LPVOID)pFileMap);
        SetEndOfFile(g_hNewFile);
        CloseHandle(g_hNewFile);
    }
    else
    {
        _printf("Unable to create file: %S", g_szNewFile);
    }

exit_gracefully:

    if (hClassList)
        DPA_DestroyCallback(hClassList, _LocalFreeCB, 0);

    if (pFileMap)
        UnmapViewOfFile(pFileMap);

    if (INVALID_HANDLE_VALUE != g_hTmpFile)
        CloseHandle(g_hTmpFile);

    VariantClear(&var);

    if (pRootDSE)
        pRootDSE->Release();

    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\inc\msgpopup.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       msgpopup.h
//
//  Definitions and prototypes for MessageBox helper functions.
//
//--------------------------------------------------------------------------

#ifndef _MSGPOPUP_H_
#define _MSGPOPUP_H_

#ifdef __cplusplus
extern "C" {
#endif

int
WINAPIV
MsgPopup(HWND hwnd,                 // Owner window
         LPCTSTR pszMsg,            // May be resource ID
         LPCTSTR pszTitle,          // May be resource ID or NULL
         UINT uType,                // MessageBox flags
         HINSTANCE hInstance,       // Resource strings loaded from here
         ...);                      // Arguments to insert into pszMsg
int
WINAPI
SysMsgPopup(HWND hwnd,
            LPCTSTR pszMsg,
            LPCTSTR pszTitle,
            UINT uType,
            HINSTANCE hInstance,
            DWORD dwErrorID,
            LPCTSTR pszInsert2 = NULL);

#ifdef __cplusplus
}
#endif

#endif  // _MSGPOPUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\dssec\version.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       version.h
//
//--------------------------------------------------------------------------

// Resources for the common version chunk

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Directory Service Security UI"
#define VER_INTERNALNAME_STR            "dssec"
#define VER_LEGALCOPYRIGHT_YEARS        "1996"
#define VER_ORIGINALFILENAME_STR        "dssec.dll"

#include <ntverp.h>
#include <common.ver>

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\inc\common.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       common.h
//
//--------------------------------------------------------------------------

#ifndef __common_h
#define __common_h

//
// ARRAYSIZE, SIZEOF, and ResultFromShort are defined in private shell
// headers, but those headers tend to move around, change, and break.
// Define the macros here so we don't have to include the headers only for
// this purpose.
//
#ifndef ARRAYSIZE
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#define SIZEOF(a)       sizeof(a)
#endif

#ifndef ResultFromShort
#define ResultFromShort(i)      MAKE_HRESULT(SEVERITY_SUCCESS, 0, (USHORT)(i))
#endif


//
// Avoid bringing in C runtime code for NO reason
//
#if defined(__cplusplus)
inline void * __cdecl operator new(size_t size) { return (void *)LocalAlloc(LPTR, size); }
inline void __cdecl operator delete(void *ptr) { LocalFree(ptr); }
extern "C" inline __cdecl _purecall(void) { return 0; }
#endif  // __cplusplus

#include "debug.h"
#include "unknown.h"
#include "strings.h"
#include "priv.h"
#include "msgpopup.h"

/*-----------------------------------------------------------------------------
/ Flags to control the trace output from parts of the common library
/----------------------------------------------------------------------------*/
#define TRACE_COMMON_STR       0x80000000
#define TRACE_COMMON_ASSERT    0x40000000
#define TRACE_COMMON_MISC      0x20000000

/*-----------------------------------------------------------------------------
/ Misc functions (misc.cpp)
/----------------------------------------------------------------------------*/
HRESULT CallRegInstall(HMODULE hModule, LPCSTR pszSection);

#if(_WIN32_WINNT < 0x0500)
typedef int (CALLBACK *_PFNDPAENUMCALLBACK)(LPVOID p, LPVOID pData);
void DPA_DestroyCallback(LPVOID, _PFNDPAENUMCALLBACK, LPVOID);
#ifndef DA_LAST
#define DA_LAST         (0x7FFFFFFF)
#endif
#ifndef DPA_AppendPtr
#define DPA_AppendPtr(hdpa, pitem)  DPA_InsertPtr(hdpa, DA_LAST, pitem)
#endif
#endif


/*-----------------------------------------------------------------------------
/ Exit macros for macro
/   - these assume that a label "exit_gracefully:" prefixes the prolog
/     to your function
/----------------------------------------------------------------------------*/
#define ExitGracefully(hr, result, text)            \
            { TraceMsg(text); hr = result; goto exit_gracefully; }

#define FailGracefully(hr, text)                    \
	    { if ( FAILED(hr) ) { TraceMsg(text); goto exit_gracefully; } }


/*-----------------------------------------------------------------------------
/ Interface helper macros
/----------------------------------------------------------------------------*/
#define DoRelease(pInterface)                       \
        { if ( pInterface ) { pInterface->Release(); pInterface = NULL; } }


/*-----------------------------------------------------------------------------
/ String helper macros
/----------------------------------------------------------------------------*/
#define StringByteCopy(pDest, iOffset, sz)          \
        { memcpy(&(((LPBYTE)pDest)[iOffset]), sz, StringByteSize(sz)); }

#define StringByteSize(sz)                          \
        ((lstrlen(sz)+1)*SIZEOF(TCHAR))


/*-----------------------------------------------------------------------------
/ Other helpful macros
/----------------------------------------------------------------------------*/
#define ByteOffset(base, offset)                    \
        (((LPBYTE)base)+offset)


// This wrapper function required to make prefast shut up when we are 
// initializing a critical section in a constructor.

void ExceptionPropagatingInitializeCriticalSection(LPCRITICAL_SECTION critsec);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\inc\priv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       priv.h
//
//--------------------------------------------------------------------------

#ifndef _PRIV_H_
#define _PRIV_H_

#ifdef __cplusplus
extern "C" {
#endif

HANDLE  EnablePrivileges(PDWORD pdwPrivileges, ULONG cPrivileges);
void    ReleasePrivileges(HANDLE hToken);

#ifdef __cplusplus
}
#endif

#endif  // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\inc\unknown.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       unknown.h
//
//--------------------------------------------------------------------------

#ifndef _unknown_h
#define _unknown_h


// Global count of number of active objects

extern LONG g_cRefCount;
#define GLOBAL_REFCOUNT     (g_cRefCount)


// CUnknown

typedef struct
{
    const IID* piid;            // interface ID
    LPVOID  pvObject;           // pointer to the object
} INTERFACES, * LPINTERFACES;

class CUnknown 
{
    protected:
        LONG m_cRefCount;

    public:
        CUnknown();
        virtual ~CUnknown();
        
        STDMETHODIMP         HandleQueryInterface(REFIID riid, LPVOID* ppvObject, LPINTERFACES aInterfaces, int cif);
        STDMETHODIMP_(ULONG) HandleAddRef();
        STDMETHODIMP_(ULONG) HandleRelease();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\inc\strings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       strings.h
//
//--------------------------------------------------------------------------

#ifndef __strings_h
#define __strings_h

HRESULT LocalAllocString(LPTSTR* ppResult, LPCTSTR pString);
HRESULT LocalAllocStringLen(LPTSTR* ppResult, UINT cLen);
void    LocalFreeString(LPTSTR* ppString);

UINT SizeofStringResource(HINSTANCE hInstance, UINT idStr);
int LoadStringAlloc(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr);

// String formatting functions - *ppszResult must be LocalFree'd
DWORD FormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, ...);
DWORD FormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, ...);
DWORD vFormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, va_list *pargs);
DWORD vFormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, va_list *pargs);

DWORD GetSystemErrorText(LPTSTR *ppszResult, DWORD dwErr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\rshx32\cstrings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cstrings.h
//
//--------------------------------------------------------------------------

#ifndef __cstrings_h
#define __cstrings_h

extern TCHAR const c_szProperties[];
extern TCHAR const c_szAclUI[];
extern TCHAR const c_szWinSpool[];
extern TCHAR const c_szDot[];
extern TCHAR const c_szDotDot[];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\inc\unknown.inc ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       unknown.inc
//
//  Magic include file to help with implementing IUnknown
//
//--------------------------------------------------------------------------


/*----------------------------------------------------------------------------
/ Macros to handle AddRef & Release (by calling CUnknown methods)
/----------------------------------------------------------------------------*/

STDMETHODIMP_(ULONG) CLASS_NAME::AddRef()
{
    return CUnknown::HandleAddRef();
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP_(ULONG) CLASS_NAME::Release()
{
    return CUnknown::HandleRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\rshx32\cstrings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cstrings.cpp
//
//  Constant strings used by this module
//
//--------------------------------------------------------------------------

#include "rshx32.h"

TCHAR const c_szProperties[]    = TEXT("Properties");
TCHAR const c_szAclUI[]         = TEXT("aclui.dll");
TCHAR const c_szWinSpool[]      = TEXT("winspool.drv");
TCHAR const c_szDot[]           = TEXT(".");
TCHAR const c_szDotDot[]        = TEXT("..");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\rshx32\ntfssi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ntfssi.h
//
//  This file contains the definition of the CNTFSSecurity object.
//
//--------------------------------------------------------------------------

#ifndef _NTFSSI_H_
#define _NTFSSI_H_

#include "si.h"

STDMETHODIMP
CheckFileAccess(LPCTSTR pszObjectName, LPDWORD pdwAccessGranted);

struct NTFS_COMPARE_DATA
{
    HDPA hItemList;
    DWORD dwSIFlags;
    SECURITY_INFORMATION siConflict;
    UINT idsSaclPrompt;
    UINT idsDaclPrompt;
    LPTSTR pszSaclConflict;
    LPTSTR pszDaclConflict;
    HRESULT hrResult;
    BOOL bAbortThread;

    NTFS_COMPARE_DATA(HDPA h, DWORD dw) : hItemList(h), dwSIFlags(dw) {}
    ~NTFS_COMPARE_DATA();
};
typedef NTFS_COMPARE_DATA *PNTFS_COMPARE_DATA;

class CNTFSSecurity;
struct NTFS_PF_DATA
{
    SECURITY_INFORMATION si;
    CNTFSSecurity * pNTFSSec;
    PSECURITY_DESCRIPTOR pSD;
    BOOL bCancel;
};
typedef NTFS_PF_DATA * PNTFS_PF_DATA;


class CNTFSSecurity : public CSecurityInformation
{
private:
    HANDLE              m_hCompareThread;
    PNTFS_COMPARE_DATA  m_pCompareData;
    IProgressDialog    *m_pProgressDlg;
    HWND                m_hwndPopupOwner;
    PSECURITY_DESCRIPTOR m_psdOwnerFullControl;

public:
    CNTFSSecurity(SE_OBJECT_TYPE seType);
    virtual ~CNTFSSecurity();

    STDMETHOD(Initialize)(HDPA   hItemList,
                          DWORD  dwFlags,
                          LPTSTR pszServer,
                          LPTSTR pszObject);

    // ISecurityInformation methods not handled by CSecurityInformation
    // or overridden here.
    STDMETHOD(GetAccessRights)(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess);
    STDMETHOD(MapGeneric)(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask);
    STDMETHOD(GetInheritTypes)(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes);
    STDMETHOD(GetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault);
    STDMETHOD(SetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD);
    STDMETHOD(PropertySheetPageCallback)(HWND hwnd,
                                         UINT uMsg,
                                         SI_PAGE_TYPE uPage);
    STDMETHOD(GetInheritSource)(SECURITY_INFORMATION si,
                                PACL pACL, 
                                PINHERITED_FROM *ppInheritArray);

    HWND GetHwndPopOwner() { return m_hwndPopupOwner; }
    HRESULT SetProgress(LPTSTR pszFile);
    HRESULT GiveOwnerFullControl(LPCWSTR lpszFileName, PSECURITY_DESCRIPTOR pSD, PBOOL pbIsFile );

protected:

    HRESULT SetSecurityLocal(SECURITY_INFORMATION si,
                             PSECURITY_DESCRIPTOR pSD,
                             LPBOOL pbNotAllApplied = NULL);
    void CreateProgressDialog(SECURITY_INFORMATION si);
    void CloseProgressDialog(void);

    HRESULT BuildOwnerFullControlSD(PSECURITY_DESCRIPTOR pSD);

#ifdef SUPPORT_NTFS_DEFAULT
    HRESULT GetParentSecurity(SECURITY_INFORMATION si,
                              PSECURITY_DESCRIPTOR *ppSD);
    HRESULT GetDefaultSecurity(SECURITY_INFORMATION si,
                               PSECURITY_DESCRIPTOR *ppSD);
#endif

#ifdef DONT_USE_ACLAPI
    STDMETHOD(ReadObjectSecurity)(LPCTSTR pszObject,
                                  SECURITY_INFORMATION si,
                                  PSECURITY_DESCRIPTOR *ppSD);
#endif  // DONT_USE_ACLAPI
    STDMETHOD(WriteObjectSecurity)(LPCTSTR pszObject,
                                   SECURITY_INFORMATION si,
                                   PSECURITY_DESCRIPTOR pSD);

    void WaitForComparison();
    static DWORD WINAPI NTFSReadSD(LPCTSTR pszObject,
                                   SECURITY_INFORMATION si,
                                   PSECURITY_DESCRIPTOR* ppSD);
    static DWORD WINAPI NTFSCompareThreadProc(LPVOID pvData);
};

#endif  /* _NTFSSI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\rshx32\printsi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       printsi.cpp
//
//  This file contains the implementation of the CPrintSecurity object.
//
//--------------------------------------------------------------------------

#include "rshx32.h"


// The following array defines the permission names for NT printers.
SI_ACCESS siPrintAccesses[] =
{
    { &GUID_NULL, PRINTER_EXECUTE,           MAKEINTRESOURCE(IDS_PRINT_PRINT),           SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, PRINTER_ALL_ACCESS,        MAKEINTRESOURCE(IDS_PRINT_ADMINISTER),      SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, JOB_ALL_ACCESS,            MAKEINTRESOURCE(IDS_PRINT_ADMINISTER_JOBS), SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC | OBJECT_INHERIT_ACE | INHERIT_ONLY_ACE },
//    { &GUID_NULL, DELETE,                    MAKEINTRESOURCE(IDS_PRINT_DELETE),          SI_ACCESS_SPECIFIC },
    { &GUID_NULL, STANDARD_RIGHTS_READ,      MAKEINTRESOURCE(IDS_PRINT_READ),            SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_DAC,                 MAKEINTRESOURCE(IDS_PRINT_CHANGE_PERM),     SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_OWNER,               MAKEINTRESOURCE(IDS_PRINT_CHANGE_OWNER),    SI_ACCESS_SPECIFIC },
    { &GUID_NULL, PRINTER_ALL_ACCESS|JOB_ALL_ACCESS, MAKEINTRESOURCE(IDS_PRINT_JOB_ALL), 0 },
    { &GUID_NULL, 0,                         MAKEINTRESOURCE(IDS_NONE),                  0 },
};
#define iPrintDefAccess     0   // PRINTER_EXECUTE (i.e. "Print" access)

#define PRINTER_ALL_AUDIT           (PRINTER_ALL_ACCESS | ACCESS_SYSTEM_SECURITY)
#define JOB_ALL_AUDIT               (JOB_ALL_ACCESS | ACCESS_SYSTEM_SECURITY)
#define PRINTER_JOB_ALL_AUDIT       (PRINTER_ALL_ACCESS | JOB_ALL_ACCESS | ACCESS_SYSTEM_SECURITY)

// The following array defines the auditting names for NT printers.
SI_ACCESS siPrintAudits[] =
{
    { &GUID_NULL, PRINTER_EXECUTE,           MAKEINTRESOURCE(IDS_PRINT_PRINT),           SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, PRINTER_ALL_AUDIT,         MAKEINTRESOURCE(IDS_PRINT_ADMINISTER),      SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, JOB_ALL_AUDIT,             MAKEINTRESOURCE(IDS_PRINT_ADMINISTER_JOBS), SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC | OBJECT_INHERIT_ACE | INHERIT_ONLY_ACE },
//    { &GUID_NULL, DELETE,                    MAKEINTRESOURCE(IDS_PRINT_DELETE),          SI_ACCESS_SPECIFIC },
    { &GUID_NULL, STANDARD_RIGHTS_READ,      MAKEINTRESOURCE(IDS_PRINT_READ),            SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_DAC,                 MAKEINTRESOURCE(IDS_PRINT_CHANGE_PERM),     SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_OWNER,               MAKEINTRESOURCE(IDS_PRINT_CHANGE_OWNER),    SI_ACCESS_SPECIFIC },
    { &GUID_NULL, PRINTER_ALL_AUDIT|JOB_ALL_AUDIT, MAKEINTRESOURCE(IDS_PRINT_JOB_ALL),   0 },
    { &GUID_NULL, 0,                         MAKEINTRESOURCE(IDS_NONE),                  0 },
};
#define iPrintDefAudit      0   // PRINTER_EXECUTE (i.e. "Print" access)

// The following array defines the inheritance types for NT printers.
SI_INHERIT_TYPE siPrintInheritTypes[] =
{
    &GUID_NULL, 0,                                     MAKEINTRESOURCE(IDS_PRINT_PRINTER),
    &GUID_NULL, INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE, MAKEINTRESOURCE(IDS_PRINT_DOCUMENT_ONLY),
    &GUID_NULL, OBJECT_INHERIT_ACE,                    MAKEINTRESOURCE(IDS_PRINT_PRINTER_DOCUMENT),
};


BOOL
GetPrinterAlloc(HANDLE hPrinter, DWORD dwLevel, LPBYTE *ppBuffer)
{
    BOOL bResult;
    DWORD dwLength = 0;
    LPBYTE pBuffer = NULL;

    bResult = GetPrinter(hPrinter, dwLevel, NULL, 0, &dwLength);
    if (dwLength)
    {
        bResult = FALSE;
        pBuffer = (LPBYTE)LocalAlloc(LPTR, dwLength);
        if (pBuffer)
        {
            bResult = GetPrinter(hPrinter, dwLevel, pBuffer, dwLength, &dwLength);
            if (!bResult)
            {
                LocalFree(pBuffer);
                pBuffer = NULL;
            }
        }
    }
    *ppBuffer = pBuffer;
    return bResult;
}


STDMETHODIMP
CheckPrinterAccess(LPCTSTR pszObjectName,
                   LPDWORD pdwAccessGranted,
                   LPTSTR  pszServer,
                   ULONG   cchServer)
{
    HRESULT hr = S_OK;
    UINT i;
    PRINTER_DEFAULTS PrinterDefaults;
    DWORD dwAccessDesired[] = { ALL_SECURITY_ACCESS,
                                READ_CONTROL,
                                WRITE_DAC,
                                WRITE_OWNER,
                                ACCESS_SYSTEM_SECURITY };
    HANDLE hPrinter = NULL;

    PrinterDefaults.pDatatype = NULL;
    PrinterDefaults.pDevMode  = NULL;

    TraceEnter(TRACE_PRINTSI, "CheckPrinterAccess");
    TraceAssert(pdwAccessGranted != NULL);

    __try
    {
        *pdwAccessGranted = 0;

        for (i = 0; i < ARRAYSIZE(dwAccessDesired); i++)
        {
            if ((dwAccessDesired[i] & *pdwAccessGranted) == dwAccessDesired[i])
                continue;   // already have this access

            PrinterDefaults.DesiredAccess = dwAccessDesired[i];

            if (OpenPrinter((LPTSTR)pszObjectName, &hPrinter, &PrinterDefaults))
            {
                *pdwAccessGranted |= dwAccessDesired[i];
                ClosePrinter(hPrinter);
            }
            else
            {
                DWORD dwErr = GetLastError();

                if (dwErr != ERROR_ACCESS_DENIED &&
                    dwErr != ERROR_PRIVILEGE_NOT_HELD)
                {
                    ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr), "OpenPrinter failed");
                }
            }
        }

        if (pszServer)
        {
            PrinterDefaults.DesiredAccess = PRINTER_READ;
            if (OpenPrinter((LPTSTR)pszObjectName, &hPrinter, &PrinterDefaults))
            {
                PPRINTER_INFO_2 ppi = NULL;
                if (GetPrinterAlloc(hPrinter, 2, (LPBYTE*)&ppi))
                {
                    if (ppi && ppi->pServerName)
                        lstrcpyn(pszServer, ppi->pServerName, cchServer);
                    else
                        *pszServer = TEXT('\0');
                    LocalFree(ppi);
                }
                ClosePrinter(hPrinter);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
    }

exit_gracefully:

    Trace((TEXT("Access = 0x%08x"), *pdwAccessGranted));
    TraceLeaveResult(hr);
}


STDMETHODIMP
CPrintSecurity::Initialize(HDPA     hItemList,
                           DWORD    dwFlags,
                           LPTSTR   pszServer,
                           LPTSTR   pszObject)
{
    return CSecurityInformation::Initialize(hItemList,
                                            dwFlags | SI_NO_TREE_APPLY | SI_NO_ACL_PROTECT,
                                            pszServer,
                                            pszObject);
}


//
// NT6 REVIEW
//
// GetAceSid, FindManagePrinterACE, MungeAclForPrinter and
// CPrintSecurity::SetSecurity only exist here because
// 1) The spooler removes JOB_ACCESS_ADMINISTER from an ACE unless the
//    ACE has INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE.
// 2) The NT4 ACL editor (ACLEDIT) needs extra bogus ACEs to recognize
//    "Manage Documents" access. (Must support downlevel clients.)
//
// The first case should be rare, since you have to perform certain
// steps in the NT5 ACL editor (ACLUI) to cause this situation. The
// second situation is common, since CREATER_OWNER and Administrators
// usually have "Manage Documents" access.
//
// If the spooler guys decide to not support NT4 clients for NT6, and they
// stop stripping JOB_ACCESS_ADMINISTER from ACEs, then MungeAclForPrinter
// and CPrintSecurity::SetSecurity can be removed entirely. ENCOURAGE THEM
// TO MAKE THAT CHANGE. (They can also remove similar hacks from their own
// code that add bogus ACEs for the old ACL editor.)
//

PSID
GetAceSid(PACE_HEADER pAce)
{
    switch (pAce->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
        return (PSID)&((PKNOWN_ACE)pAce)->SidStart;

    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        return (PSID)&((PCOMPOUND_ACCESS_ALLOWED_ACE)pAce)->SidStart;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        return RtlObjectAceSid(pAce);
    }

    return NULL;
}

PACE_HEADER
FindManagePrinterACE(PACL pAcl, PSID pSid)
{
    UINT i;
    PACE_HEADER pAce;

    if (!pAcl || !pSid)
        return NULL;

    for (i = 0, pAce = (PACE_HEADER)FirstAce(pAcl);
         i < pAcl->AceCount;
         i++, pAce = (PACE_HEADER)NextAce(pAce))
    {
        if (pAce->AceType == ACCESS_ALLOWED_ACE_TYPE
            && (((PKNOWN_ACE)pAce)->Mask & PRINTER_ALL_ACCESS) == PRINTER_ALL_ACCESS
            && !(pAce->AceFlags & INHERIT_ONLY_ACE)
            && EqualSid(pSid, GetAceSid(pAce)))
        {
            return pAce;
        }
    }

    return NULL;
}

BOOL
MungeAclForPrinter(PACL pAcl, PACL *ppAclOut)
{
    USHORT i;
    PACE_HEADER pAce;
    PACE_HEADER pAceCopy = NULL;

    if (ppAclOut == NULL)
        return FALSE;

    *ppAclOut = NULL;

    if (pAcl == NULL)
        return TRUE;

    TraceEnter(TRACE_PRINTSI, "MungeAclForPrinter");

    for (i = 0, pAce = (PACE_HEADER)FirstAce(pAcl);
         i < pAcl->AceCount;
         i++, pAce = (PACE_HEADER)NextAce(pAce))
    {
        //
        // If this ACE has the JOB_ACCESS_ADMINISTER bit and the inherit
        // flags indicate that it applies to both printers and documents,
        // then we need to treat it specially, since the spooler won't save
        // JOB_ACCESS_ADMINISTER on a printer ACE (INHERIT_ONLY_ACE not set).
        //
        if ((((PKNOWN_ACE)pAce)->Mask & JOB_ACCESS_ADMINISTER) &&
            (pAce->AceFlags & (INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE)) == OBJECT_INHERIT_ACE)
        {
            //
            // Split into 2 aces: one with no inheritance, and one with
            // INHERIT_ONLY_ACE turned on. Let the spooler do whatever
            // it wants with the mask.
            //
            // This requires allocating a larger ACL and copying all
            // previous aces over.
            //

            TraceMsg("Splitting JOB_ACCESS_ADMINISTER ACE into 2");

            if (*ppAclOut == NULL)
            {
                //
                // Allocate new ACL and copy previous aces.  The length is enough
                // for 1 copy of all previous aces, and 3 copies (max) of all
                // remaining aces.
                //
                ULONG nPrevLength = (ULONG)((ULONG_PTR)pAce - (ULONG_PTR)pAcl);
                *ppAclOut = (PACL)LocalAlloc(LPTR, nPrevLength + (pAcl->AclSize - nPrevLength) * 3);
                if (!*ppAclOut)
                    TraceLeaveValue(FALSE);

                CopyMemory(*ppAclOut, pAcl, nPrevLength);
                (*ppAclOut)->AclSize = (USHORT)LocalSize(*ppAclOut);
                (*ppAclOut)->AceCount = i;
                pAceCopy = (PACE_HEADER)ByteOffset(*ppAclOut, nPrevLength);
            }

            // Turn off inheritance and copy this ace
            pAce->AceFlags &= ~OBJECT_INHERIT_ACE;
            CopyMemory(pAceCopy, pAce, pAce->AceSize);
            pAceCopy = (PACE_HEADER)NextAce(pAceCopy);
            (*ppAclOut)->AceCount++;

            // Now turn on inheritance (with INHERIT_ONLY_ACE) and copy it
            // again (it gets copied way down below).  Note that this may
            // causes the next IF clause to add a bogus ACE also.
            pAce->AceFlags |= OBJECT_INHERIT_ACE | INHERIT_ONLY_ACE;
        }

        //
        // If this ACE has JOB_ALL_ACCESS and INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE,
        // and there isn't also a "Manage Printers" ACE for the same SID, add a
        // bogus ACE with READ_CONTROL and CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE.
        // The old ACL editor on downlevel clients needs this to recognize
        // "Manage Documents" access.
        //
        if (pAce->AceType == ACCESS_ALLOWED_ACE_TYPE
            && (((PKNOWN_ACE)pAce)->Mask & JOB_ALL_ACCESS) == JOB_ALL_ACCESS
            && (pAce->AceFlags & (INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE)) == (INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE)
            && !FindManagePrinterACE(pAcl, GetAceSid(pAce)))
        {
            TraceMsg("Adding bogus ACE for downlevel support");

            if (*ppAclOut == NULL)
            {
                //
                // Allocate new ACL and copy previous aces.  The length is enough
                // for 1 copy of all previous aces, and 3 copies (max) of all
                // remaining aces.
                //
                ULONG nPrevLength = (ULONG)((ULONG_PTR)pAce - (ULONG_PTR)pAcl);
                *ppAclOut = (PACL)LocalAlloc(LPTR, nPrevLength + (pAcl->AclSize - nPrevLength) * 3);
                if (!*ppAclOut)
                    TraceLeaveValue(FALSE);

                CopyMemory(*ppAclOut, pAcl, nPrevLength);
                (*ppAclOut)->AclSize = (USHORT)LocalSize(*ppAclOut);
                (*ppAclOut)->AceCount = i;
                pAceCopy = (PACE_HEADER)ByteOffset(*ppAclOut, nPrevLength);
            }

            // Copy this ace, turn on CONTAINER_INHERIT_ACE, and set
            // the mask to STANDARD_RIGHTS_READ.
            CopyMemory(pAceCopy, pAce, pAce->AceSize);
            pAceCopy->AceFlags &= ~OBJECT_INHERIT_ACE;
            pAceCopy->AceFlags |= INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE;
            ((PKNOWN_ACE)pAceCopy)->Mask = STANDARD_RIGHTS_READ;
            pAceCopy = (PACE_HEADER)NextAce(pAceCopy);
            (*ppAclOut)->AceCount++;
        }

        if (*ppAclOut != NULL)
        {
            // Copy current ace
            CopyMemory(pAceCopy, pAce, pAce->AceSize);
            pAceCopy = (PACE_HEADER)NextAce(pAceCopy);
            (*ppAclOut)->AceCount++;
        }
    }

    if (*ppAclOut != NULL)
    {
        TraceAssert((ULONG_PTR)pAceCopy > (ULONG_PTR)*ppAclOut &&
                    (ULONG_PTR)pAceCopy <= (ULONG_PTR)*ppAclOut + (*ppAclOut)->AclSize);

        // Set the ACL size to the correct value
        (*ppAclOut)->AclSize = (WORD)((ULONG_PTR)pAceCopy - (ULONG_PTR)*ppAclOut);
    }

    TraceLeaveValue(TRUE);
}


///////////////////////////////////////////////////////////
//
// ISecurityInformation methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP
CPrintSecurity::SetSecurity(SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD)
{
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    PACL pDaclCopy = NULL;
    PACL pSaclCopy = NULL;
    BOOL bPresent;
    BOOL bDefaulted;
    SECURITY_DESCRIPTOR sd;

    TraceEnter(TRACE_PRINTSI, "CPrintSecurity::SetSecurity");

    if ((si & DACL_SECURITY_INFORMATION)
        && GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefaulted)
        && bPresent)
    {
        if (MungeAclForPrinter(pDacl, &pDaclCopy) && pDaclCopy)
            pDacl = pDaclCopy;
    }

    if ((si & SACL_SECURITY_INFORMATION)
        && GetSecurityDescriptorSacl(pSD, &bPresent, &pSacl, &bDefaulted)
        && bPresent)
    {
        if (MungeAclForPrinter(pSacl, &pSaclCopy) && pSaclCopy)
            pSacl = pSaclCopy;
    }

    if (pDaclCopy || pSaclCopy)
    {
        // Build a new SECURITY_DESCRIPTOR
        PSID psid;
        DWORD dwRevision;
        SECURITY_DESCRIPTOR_CONTROL sdControl = 0;

        GetSecurityDescriptorControl(pSD, &sdControl, &dwRevision);
        InitializeSecurityDescriptor(&sd, dwRevision);
        sd.Control = (SECURITY_DESCRIPTOR_CONTROL)(sdControl & ~SE_SELF_RELATIVE);

        if ((si & OWNER_SECURITY_INFORMATION)
            && GetSecurityDescriptorOwner(pSD, &psid, &bDefaulted))
        {
            SetSecurityDescriptorOwner(&sd, psid, bDefaulted);
        }

        if ((si & GROUP_SECURITY_INFORMATION)
            && GetSecurityDescriptorGroup(pSD, &psid, &bDefaulted))
        {
            SetSecurityDescriptorGroup(&sd, psid, bDefaulted);
        }

        if (si & SACL_SECURITY_INFORMATION)
        {
            SetSecurityDescriptorSacl(&sd,
                                      sdControl & SE_SACL_PRESENT,
                                      pSacl,
                                      sdControl & SE_SACL_DEFAULTED);
        }

        if (si & DACL_SECURITY_INFORMATION)
        {
            SetSecurityDescriptorDacl(&sd,
                                      sdControl & SE_DACL_PRESENT,
                                      pDacl,
                                      sdControl & SE_DACL_DEFAULTED);
        }

        // Switch to the new security descriptor
        pSD = &sd;
    }

    // The base class does the rest of the work
    HRESULT hr = CSecurityInformation::SetSecurity(si, pSD);

    if (pDaclCopy)
        LocalFree(pDaclCopy);

    if (pSaclCopy)
        LocalFree(pSaclCopy);

    TraceLeaveResult(hr);
}

STDMETHODIMP
CPrintSecurity::GetAccessRights(const GUID* /*pguidObjectType*/,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccesses,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess)
{
    TraceEnter(TRACE_PRINTSI, "CPrintSecurity::GetAccessRights");
    TraceAssert(ppAccesses != NULL);
    TraceAssert(pcAccesses != NULL);
    TraceAssert(piDefaultAccess != NULL);

    if (dwFlags & SI_EDIT_AUDITS)
    {
        *ppAccesses = siPrintAudits;
        *pcAccesses = ARRAYSIZE(siPrintAudits);
        *piDefaultAccess = iPrintDefAudit;
    }
    else
    {
        *ppAccesses = siPrintAccesses;
        *pcAccesses = ARRAYSIZE(siPrintAccesses);
        *piDefaultAccess = iPrintDefAccess;
    }

    TraceLeaveResult(S_OK);
}


GENERIC_MAPPING JobMap =
{
    JOB_READ,
    JOB_WRITE,
    JOB_EXECUTE,
    JOB_ALL_ACCESS
};

GENERIC_MAPPING PrinterMap =
{
    PRINTER_READ,
    PRINTER_WRITE,
    PRINTER_EXECUTE,
    PRINTER_ALL_ACCESS
};

GENERIC_MAPPING FullPrinterMap =
{
    PRINTER_READ | JOB_READ,
    PRINTER_WRITE | JOB_WRITE,
    PRINTER_EXECUTE | JOB_EXECUTE,
    PRINTER_ALL_ACCESS | JOB_ALL_ACCESS
};

STDMETHODIMP
CPrintSecurity::MapGeneric(const GUID* /*pguidObjectType*/,
                           UCHAR *pAceFlags,
                           ACCESS_MASK *pmask)
{
    PGENERIC_MAPPING pMap;

    TraceEnter(TRACE_PRINTSI, "CPrintSecurity::MapGeneric");
    TraceAssert(pAceFlags != NULL);
    TraceAssert(pmask != NULL);

    // This flag has no meaning for printers, but it's often turned on
    // in legacy ACLs.  Turn it off here
    *pAceFlags &= ~CONTAINER_INHERIT_ACE;

    // Choose the correct generic mapping according to the inherit
    // scope of this ACE.
    if (*pAceFlags & OBJECT_INHERIT_ACE)
    {
        if (*pAceFlags & INHERIT_ONLY_ACE)
            pMap = &JobMap;                 // documents only
        else
            pMap = &FullPrinterMap;         // printers & documents
    }
    else
        pMap = &PrinterMap;                 // printers only

    // Note that the case where INHERIT_ONLY_ACE is ON but OBJECT_INHERIT_ACE
    // is OFF falls under the "printers only" case above. However, this
    // case makes no sense (inherit-only, but not onto documents) and it
    // doesn't matter how we do the mapping.

    // Map any generic bits to standard & specific bits.
    // When using the NT5 ACL APIs, ntmarta.dll maps generic bits, so this
    // isn't always necessary, but we'll do it anyway to be sure.
    MapGenericMask(pmask, pMap);

    // Turn off any extra bits that ntmarta.dll may have turned on
    // (ntmarta uses a different mapping).  But leave ACCESS_SYSTEM_SECURITY
    // alone in case we're editing a SACL.
    *pmask &= (pMap->GenericAll | ACCESS_SYSTEM_SECURITY);

    TraceLeaveResult(S_OK);
}

STDMETHODIMP
CPrintSecurity::GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
                                ULONG *pcInheritTypes)
{
    TraceEnter(TRACE_PRINTSI, "CPrintSecurity::GetInheritTypes");
    TraceAssert(ppInheritTypes != NULL);
    TraceAssert(pcInheritTypes != NULL);

    *ppInheritTypes = siPrintInheritTypes;
    *pcInheritTypes = ARRAYSIZE(siPrintInheritTypes);

    TraceLeaveResult(S_OK);
}

//
// The base class versions of ReadObjectSecurity and WriteObjectSecurity
// use Get/SetNamedSecurityInfo, et al.  These API's are generic,
// involve lots of conversions, and are problematic.  Since there is no
// inheritance propagation required for printers, override them here
// and use GetPrinter/SetPrinter.
//
STDMETHODIMP
CPrintSecurity::ReadObjectSecurity(LPCTSTR pszObject,
                                   SECURITY_INFORMATION si,
                                   PSECURITY_DESCRIPTOR *ppSD)
{
    HRESULT hr;
    DWORD dwErr = NOERROR;
    HANDLE hPrinter;
    PRINTER_DEFAULTS pd = {0};
    DWORD dwLength = 0;

    TraceEnter(TRACE_PRINTSI, "CPrintSecurity::ReadObjectSecurity");
    TraceAssert(pszObject != NULL);
    TraceAssert(si != 0);
    TraceAssert(ppSD != NULL);

    //
    // Assume that required privileges have already been
    // enabled, if appropriate.
    //
    if (si & (DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION))
        pd.DesiredAccess |= READ_CONTROL;

    if (si & SACL_SECURITY_INFORMATION)
        pd.DesiredAccess |= ACCESS_SYSTEM_SECURITY;

    __try
    {
        *ppSD = NULL;

        if (OpenPrinter((LPTSTR)pszObject, &hPrinter, &pd))
        {
            PPRINTER_INFO_3 ppi = NULL;

            if (GetPrinterAlloc(hPrinter, 3, (LPBYTE*)&ppi))
            {
                //
                // Rather than allocating a new buffer and copying the
                // security descriptor, we can re-use the existing buffer
                // by simply moving the security descriptor to the top.
                //
                dwLength = GetSecurityDescriptorLength(ppi->pSecurityDescriptor);
                *ppSD = ppi;
                // This is an overlapped copy, so use MoveMemory.
                MoveMemory(*ppSD,
                           ppi->pSecurityDescriptor,
                           dwLength);
            }
            else
                dwErr = GetLastError();

            ClosePrinter(hPrinter);
        }
        else
            dwErr = GetLastError();
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = ERROR_PROC_NOT_FOUND;
    }

    hr = HRESULT_FROM_WIN32(dwErr);
    TraceLeaveResult(hr);
}

STDMETHODIMP
CPrintSecurity::WriteObjectSecurity(LPCTSTR pszObject,
                                    SECURITY_INFORMATION si,
                                    PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr;
    DWORD dwErr = NOERROR;
    HANDLE hPrinter;
    PRINTER_DEFAULTS pd = {0};

    TraceEnter(TRACE_PRINTSI, "CPrintSecurity::WriteObjectSecurity");
    TraceAssert(pszObject != NULL);
    TraceAssert(si != 0);
    TraceAssert(pSD != NULL);

    //
    // Assume that required privileges have already been
    // enabled, if appropriate.
    //
    if (si & (OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION))
        pd.DesiredAccess |= WRITE_OWNER;

    if (si & SACL_SECURITY_INFORMATION)
        pd.DesiredAccess |= ACCESS_SYSTEM_SECURITY;

    if (si & DACL_SECURITY_INFORMATION)
        pd.DesiredAccess |= WRITE_DAC;

    __try
    {
        if (OpenPrinter((LPTSTR)pszObject, &hPrinter, &pd))
        {
            PRINTER_INFO_3 pi = { pSD };

            if (!SetPrinter(hPrinter, 3, (LPBYTE)&pi, 0))
                dwErr = GetLastError();

            ClosePrinter(hPrinter);
        }
        else
            dwErr = GetLastError();
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = ERROR_PROC_NOT_FOUND;
    }

    hr = HRESULT_FROM_WIN32(dwErr);
    TraceLeaveResult(hr);
}

STDMETHODIMP
CPrintSecurity::GetInheritSource(SECURITY_INFORMATION si,
                                PACL pACL, 
                                PINHERITED_FROM *ppInheritArray)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\rshx32\printsi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       printsi.h
//
//  This file contains the definition of the CPrintSecurity object.
//
//--------------------------------------------------------------------------

#ifndef _PRINTSI_H_
#define _PRINTSI_H_

#include "si.h"

STDMETHODIMP
CheckPrinterAccess(LPCTSTR pszObjectName,
                   LPDWORD pdwAccessGranted,
                   LPTSTR  pszServer,
                   ULONG   cchServer);

DWORD LoadWinSpool();

class CPrintSecurity : public CSecurityInformation
{
public:
    CPrintSecurity(SE_OBJECT_TYPE seType) : CSecurityInformation(seType) {}

    STDMETHOD(Initialize)(HDPA   hItemList,
                          DWORD  dwFlags,
                          LPTSTR pszServer,
                          LPTSTR pszObject);

    // ISecurityInformation methods
    STDMETHOD(SetSecurity)(SECURITY_INFORMATION si,     // override
                           PSECURITY_DESCRIPTOR pSD);
    STDMETHOD(GetAccessRights)(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess);
    STDMETHOD(MapGeneric)(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask);
    STDMETHOD(GetInheritTypes)(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes);
    STDMETHOD(GetInheritSource)(SECURITY_INFORMATION si,
                                PACL pACL, 
                                PINHERITED_FROM *ppInheritArray);


protected:
    // Override these
    STDMETHOD(ReadObjectSecurity)(LPCTSTR pszObject,
                                  SECURITY_INFORMATION si,
                                  PSECURITY_DESCRIPTOR *ppSD);
    STDMETHOD(WriteObjectSecurity)(LPCTSTR pszObject,
                                   SECURITY_INFORMATION si,
                                   PSECURITY_DESCRIPTOR pSD);
};

#endif  /* _PRINTSI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\rshx32\ntfssi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ntfssi.cpp
//
//  This file contains the implementation of the CNTFSSecurity object.
//
//--------------------------------------------------------------------------

#include "rshx32.h"
#include <windowsx.h>   // GET_WM_COMMAND_ID, etc.
#include <atlconv.h>

#define MY_FILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED                    \
                            | SYNCHRONIZE                               \
                            | FILE_READ_DATA    | FILE_LIST_DIRECTORY   \
                            | FILE_WRITE_DATA   | FILE_ADD_FILE         \
                            | FILE_APPEND_DATA  | FILE_ADD_SUBDIRECTORY \
                            | FILE_CREATE_PIPE_INSTANCE                 \
                            | FILE_READ_EA                              \
                            | FILE_WRITE_EA                             \
                            | FILE_EXECUTE      | FILE_TRAVERSE         \
                            | FILE_DELETE_CHILD                         \
                            | FILE_READ_ATTRIBUTES                      \
                            | FILE_WRITE_ATTRIBUTES)

#if(FILE_ALL_ACCESS != MY_FILE_ALL_ACCESS)
#error ACL editor needs to sync with file permissions changes in ntioapi.h (or ntioapi.h is broken)
#endif

#define INHERIT_FULL            (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE)

//
// Treat SYNCHRONIZE specially. In particular, always allow SYNCHRONIZE and
// never Deny SYNCHRONIZE. Do this by removing it from the Generic Mapping,
// turning it off in all ACEs and SI_ACCESS entries, and then adding it to
// all Allow ACEs before saving a new ACL.
//
#define FILE_GENERIC_READ_      (FILE_GENERIC_READ    & ~SYNCHRONIZE)
#define FILE_GENERIC_WRITE_     (FILE_GENERIC_WRITE   & ~(SYNCHRONIZE | READ_CONTROL))
#define FILE_GENERIC_EXECUTE_   (FILE_GENERIC_EXECUTE & ~SYNCHRONIZE)
#define FILE_GENERIC_ALL_       (FILE_ALL_ACCESS      & ~SYNCHRONIZE)

#define FILE_GENERAL_MODIFY     (FILE_GENERIC_READ_  | FILE_GENERIC_WRITE_ | FILE_GENERIC_EXECUTE_ | DELETE)
#define FILE_GENERAL_PUBLISH    (FILE_GENERIC_READ_  | FILE_GENERIC_WRITE_ | FILE_GENERIC_EXECUTE_)
#define FILE_GENERAL_DEPOSIT    (FILE_GENERIC_WRITE_ | FILE_GENERIC_EXECUTE_)
#define FILE_GENERAL_READ_EX    (FILE_GENERIC_READ_  | FILE_GENERIC_EXECUTE_)

// The following array defines the permission names for NTFS objects.
SI_ACCESS siNTFSAccesses[] =
{
    { &GUID_NULL, FILE_GENERIC_ALL_,    MAKEINTRESOURCE(IDS_NTFS_GENERIC_ALL),      SI_ACCESS_GENERAL | INHERIT_FULL|SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_GENERAL_MODIFY,  MAKEINTRESOURCE(IDS_NTFS_GENERAL_MODIFY),   SI_ACCESS_GENERAL | INHERIT_FULL },
    { &GUID_NULL, FILE_GENERAL_READ_EX, MAKEINTRESOURCE(IDS_NTFS_GENERAL_READ),     SI_ACCESS_GENERAL | INHERIT_FULL },
    { &GUID_NULL, FILE_GENERAL_READ_EX, MAKEINTRESOURCE(IDS_NTFS_GENERAL_LIST),     SI_ACCESS_CONTAINER | CONTAINER_INHERIT_ACE },
    { &GUID_NULL, FILE_GENERIC_READ_,   MAKEINTRESOURCE(IDS_NTFS_GENERIC_READ),     SI_ACCESS_GENERAL | INHERIT_FULL },
    { &GUID_NULL, FILE_GENERIC_WRITE_,  MAKEINTRESOURCE(IDS_NTFS_GENERIC_WRITE),    SI_ACCESS_GENERAL | INHERIT_FULL },
    { &GUID_NULL, FILE_EXECUTE,         MAKEINTRESOURCE(IDS_NTFS_FILE_EXECUTE),     SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_READ_DATA,       MAKEINTRESOURCE(IDS_NTFS_FILE_READ_DATA),   SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_READ_ATTRIBUTES, MAKEINTRESOURCE(IDS_NTFS_FILE_READ_ATTR),   SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_READ_EA,         MAKEINTRESOURCE(IDS_NTFS_FILE_READ_EA),     SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_WRITE_DATA,      MAKEINTRESOURCE(IDS_NTFS_FILE_WRITE_DATA),  SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_APPEND_DATA,     MAKEINTRESOURCE(IDS_NTFS_FILE_APPEND_DATA), SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_WRITE_ATTRIBUTES,MAKEINTRESOURCE(IDS_NTFS_FILE_WRITE_ATTR),  SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_WRITE_EA,        MAKEINTRESOURCE(IDS_NTFS_FILE_WRITE_EA),    SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_DELETE_CHILD,    MAKEINTRESOURCE(IDS_NTFS_FILE_DELETE_CHILD),SI_ACCESS_SPECIFIC },
#if(FILE_CREATE_PIPE_INSTANCE != FILE_APPEND_DATA)
    { &GUID_NULL, FILE_CREATE_PIPE_INSTANCE, MAKEINTRESOURCE(IDS_NTFS_FILE_CREATE_PIPE), SI_ACCESS_SPECIFIC },
#endif
    { &GUID_NULL, DELETE,               MAKEINTRESOURCE(IDS_NTFS_STD_DELETE),       SI_ACCESS_SPECIFIC },
    { &GUID_NULL, READ_CONTROL,         MAKEINTRESOURCE(IDS_NTFS_STD_READ_CONTROL), SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_DAC,            MAKEINTRESOURCE(IDS_NTFS_STD_WRITE_DAC),    SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_OWNER,          MAKEINTRESOURCE(IDS_NTFS_STD_WRITE_OWNER),  SI_ACCESS_SPECIFIC },
//    { &GUID_NULL, SYNCHRONIZE,          MAKEINTRESOURCE(IDS_NTFS_STD_SYNCHRONIZE),  SI_ACCESS_SPECIFIC },
    { &GUID_NULL, 0,                    MAKEINTRESOURCE(IDS_NONE),                  0 },
    { &GUID_NULL, FILE_GENERIC_EXECUTE_,MAKEINTRESOURCE(IDS_NTFS_GENERIC_EXECUTE),  0 },
    { &GUID_NULL, FILE_GENERAL_DEPOSIT, MAKEINTRESOURCE(IDS_NTFS_GENERAL_DEPOSIT),  0 },
    { &GUID_NULL, FILE_GENERAL_PUBLISH, MAKEINTRESOURCE(IDS_NTFS_GENERAL_PUBLISH),  0 },
};
#define iNTFSDefAccess      2   // FILE_GENERAL_READ_EX
#define iNTFSDelChildAccess 14  // FILE_DELETE_CHILD
    
// The following array defines the inheritance types for NTFS directories.
SI_INHERIT_TYPE siNTFSInheritTypes[] =
{
    &GUID_NULL, 0,                                                             MAKEINTRESOURCE(IDS_NTFS_FOLDER),
    &GUID_NULL, CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,                    MAKEINTRESOURCE(IDS_NTFS_FOLDER_SUBITEMS),
    &GUID_NULL, CONTAINER_INHERIT_ACE,                                         MAKEINTRESOURCE(IDS_NTFS_FOLDER_SUBFOLDER),
    &GUID_NULL, OBJECT_INHERIT_ACE,                                            MAKEINTRESOURCE(IDS_NTFS_FOLDER_FILE),
    &GUID_NULL, INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE, MAKEINTRESOURCE(IDS_NTFS_SUBITEMS_ONLY),
    &GUID_NULL, INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE,                      MAKEINTRESOURCE(IDS_NTFS_SUBFOLDER_ONLY),
    &GUID_NULL, INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE,                         MAKEINTRESOURCE(IDS_NTFS_FILE_ONLY),
};

VOID ProgressFunction(IN LPWSTR                   pObjectName,    
                      IN DWORD                    Status,         
                      IN OUT PPROG_INVOKE_SETTING pInvokeSetting ,
                      IN PVOID                    Args,
                      IN BOOL                     SecuritySet);

BOOL SetFileSecurityUsingNTName(IN PUNICODE_STRING pFileName,
                                IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                OUT PBOOL pbIsFile);




STDMETHODIMP
CheckFileAccess(LPCTSTR pszObjectName, LPDWORD pdwAccessGranted)
{
    HRESULT hr = S_OK;
    UINT i;
    UNICODE_STRING usNtFileName = {0};
    DWORD dwAccessDesired[] = { ALL_SECURITY_ACCESS,
                                READ_CONTROL,
                                WRITE_DAC,
                                WRITE_OWNER,
                                ACCESS_SYSTEM_SECURITY };

    TraceEnter(TRACE_NTFSSI, "CheckFileAccess");
    TraceAssert(pdwAccessGranted != NULL);

    *pdwAccessGranted = 0;

    if (!RtlDosPathNameToNtPathName_U(pszObjectName,
                                      &usNtFileName,
                                      NULL,
                                      NULL))
    {
        ExitGracefully(hr, E_OUTOFMEMORY, "RtlDosPathNameToNtPathName_U failed");
    }

    for (i = 0; i < ARRAYSIZE(dwAccessDesired); i++)
    {
        OBJECT_ATTRIBUTES oa;
        IO_STATUS_BLOCK StatusBlock;
        DWORD dwErr;
        HANDLE hFile;

        if ((dwAccessDesired[i] & *pdwAccessGranted) == dwAccessDesired[i])
            continue;   // already have this access

        InitializeObjectAttributes(&oa,
                                   &usNtFileName,
                                   OBJ_CASE_INSENSITIVE,
                                   0,
                                   0);

        dwErr = RtlNtStatusToDosError(NtOpenFile(&hFile,
                                                 dwAccessDesired[i],
                                                 &oa,
                                                 &StatusBlock,
                                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                 0));
        if (dwErr == 0)
        {
            *pdwAccessGranted |= dwAccessDesired[i];
            NtClose(hFile);
        }
    }

exit_gracefully:

    RtlFreeUnicodeString(&usNtFileName);

    Trace((TEXT("Access = 0x%08x"), *pdwAccessGranted));
    TraceLeaveResult(hr);
}


DWORD
GetCurrentToken(DWORD dwDesiredAccess, PHANDLE phToken)
{
    DWORD dwErr = NOERROR;
    if (!OpenThreadToken(GetCurrentThread(), dwDesiredAccess, TRUE, phToken)
        && !OpenProcessToken(GetCurrentProcess(), dwDesiredAccess, phToken))
    {
        dwErr = GetLastError();
    }
    return dwErr;
}



///////////////////////////////////////////////////////////
//
// Constructor/destructor
//
///////////////////////////////////////////////////////////

NTFS_COMPARE_DATA::~NTFS_COMPARE_DATA()
{
    LocalFreeString(&pszSaclConflict);
    LocalFreeString(&pszDaclConflict);
}

CNTFSSecurity::CNTFSSecurity(SE_OBJECT_TYPE seType)
: CSecurityInformation(seType)
{
}

CNTFSSecurity::~CNTFSSecurity()
{
    if (m_pCompareData != NULL)
        m_pCompareData->bAbortThread = TRUE;

    WaitForComparison();
    delete m_pCompareData;
}

STDMETHODIMP
CNTFSSecurity::Initialize(HDPA      hItemList,
                          DWORD     dwFlags,
                          LPTSTR    pszServer,
                          LPTSTR    pszObject)
{
    HRESULT hr;

    //
    // If we're editing the owner on a folder, turn on the Recurse button.
    //
    if (dwFlags & SI_CONTAINER)
    {
        if ((dwFlags & (SI_EDIT_OWNER | SI_OWNER_READONLY)) == SI_EDIT_OWNER)
            dwFlags |= SI_OWNER_RECURSE;

        if (!(dwFlags & SI_READONLY))
            dwFlags |= SI_RESET_DACL_TREE;

        if (dwFlags & SI_EDIT_AUDITS)
            dwFlags |= SI_RESET_SACL_TREE;
    }

    //
    // Let the base class do its thing
    //
    hr = CSecurityInformation::Initialize(hItemList,
                                          dwFlags,
                                          pszServer,
                                          pszObject);

    //
    // If multiple selection, create thread to compare security descriptors
    //
    if (m_hItemList && DPA_GetPtrCount(m_hItemList) > 1)
    {
        m_pCompareData = new NTFS_COMPARE_DATA(m_hItemList, m_dwSIFlags);

        if (m_pCompareData != NULL)
        {
            DWORD dwID;

            m_hCompareThread = CreateThread(NULL,
                                            0,
                                            NTFSCompareThreadProc,
                                            m_pCompareData,
                                            CREATE_SUSPENDED,
                                            &dwID);
            if (m_hCompareThread != NULL)
            {
                SetThreadPriority(m_hCompareThread, THREAD_PRIORITY_BELOW_NORMAL);
                ResumeThread(m_hCompareThread);
            }
            else
            {
                delete m_pCompareData;
                m_pCompareData = NULL;
            }
        }
    }

    return hr;
}

///////////////////////////////////////////////////////////
//
// ISecurityInformation methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP
CNTFSSecurity::GetAccessRights(const GUID* /*pguidObjectType*/,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccesses,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess)
{
    TraceEnter(TRACE_NTFSSI, "CNTFSSecurity::GetAccessRights");
    TraceAssert(ppAccesses != NULL);
    TraceAssert(pcAccesses != NULL);
    TraceAssert(piDefaultAccess != NULL);
    
    //
    //Don't Show delete subfolder and files for files or
    //when applyonto is files only
    //
    if(IsFile())
        siNTFSAccesses[iNTFSDelChildAccess].dwFlags = 0;
    else
        siNTFSAccesses[iNTFSDelChildAccess].dwFlags = SI_ACCESS_SPECIFIC;


    *ppAccesses = siNTFSAccesses;
    *pcAccesses = ARRAYSIZE(siNTFSAccesses);
    *piDefaultAccess = iNTFSDefAccess;

    TraceLeaveResult(S_OK);
}

GENERIC_MAPPING NTFSMap =
{
    FILE_GENERIC_READ_,
    FILE_GENERIC_WRITE_,
    FILE_GENERIC_EXECUTE_,
    FILE_GENERIC_ALL_
};

STDMETHODIMP
CNTFSSecurity::MapGeneric(const GUID* /*pguidObjectType*/,
                          UCHAR * /*pAceFlags*/,
                          ACCESS_MASK *pmask)
{
    TraceEnter(TRACE_NTFSSI, "CNTFSSecurity::MapGeneric");
    TraceAssert(pmask != NULL);

    MapGenericMask(pmask, &NTFSMap);
    *pmask &= ~SYNCHRONIZE;

    TraceLeaveResult(S_OK);
}

STDMETHODIMP
CNTFSSecurity::GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes)
{
    TraceEnter(TRACE_NTFSSI, "CNTFSSecurity::GetInheritTypes");
    TraceAssert(ppInheritTypes != NULL);
    TraceAssert(pcInheritTypes != NULL);

    if (m_dwSIFlags & SI_CONTAINER)
    {
        *ppInheritTypes = siNTFSInheritTypes;
        *pcInheritTypes = ARRAYSIZE(siNTFSInheritTypes);
        TraceLeaveResult(S_OK);
    }

    TraceLeaveResult(E_NOTIMPL);
}

STDMETHODIMP
CNTFSSecurity::GetSecurity(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault)
{
    HRESULT hr = S_OK;
    SECURITY_INFORMATION siConflict = 0;

    TraceEnter(TRACE_NTFSSI, "CNTFSSecurity::GetSecurity");
    TraceAssert(si != 0);
    TraceAssert(ppSD != NULL);

    *ppSD = NULL;

    if (fDefault)
    {
#ifdef SUPPORT_NTFS_DEFAULT
        hr = GetDefaultSecurity(si, ppSD);
        ExitGracefully(hr, hr, "Returning default security descriptor");
#else
        ExitGracefully(hr, E_NOTIMPL, "Default security descriptor not supported");
#endif
    }

    WaitForComparison();

    if (m_pCompareData != NULL)
    {
        // Of the bits requested (si) figure out which ones
        // conflict and which ones don't.

        // First check DACL and SACL
        SECURITY_INFORMATION siAcl = si & m_pCompareData->siConflict;
        siAcl &= (SACL_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION);
        if (siAcl)
        {
            // To get here, we've already told the user there is a conflict
            // and they said to reset the ACL(s) and continue.

            // Build security descriptor with empty DACL and NULL SACL
            SECURITY_DESCRIPTOR sdEmpty = {0};
            ACL aclEmpty = {0};
            InitializeSecurityDescriptor(&sdEmpty, SECURITY_DESCRIPTOR_REVISION);
            InitializeAcl(&aclEmpty, sizeof(ACL), ACL_REVISION);
            SetSecurityDescriptorSacl(&sdEmpty, TRUE, &aclEmpty, FALSE);
            SetSecurityDescriptorDacl(&sdEmpty, TRUE, &aclEmpty, FALSE);

            // Reset the DACL and/or SACL
            hr = SetSecurity(siAcl, (PSECURITY_DESCRIPTOR)&sdEmpty);
        }

        // Note that SetSecurity will free m_pCompareData if there are
        // no more conflicts, so check the pointer again here.
        if (m_pCompareData != NULL)
            siConflict = si & m_pCompareData->siConflict;
    }

    // Read it from the first item.
    hr = CSecurityInformation::GetSecurity(si, ppSD, fDefault);

    if (SUCCEEDED(hr) && siConflict != 0)
    {
        //
        // Clear out any of the parts that conflict
        //

        PISECURITY_DESCRIPTOR psd = (PISECURITY_DESCRIPTOR)*ppSD;
        TraceAssert(psd != NULL);

        if (siConflict & OWNER_SECURITY_INFORMATION)
        {
            psd->Owner = NULL;
        }

        if (siConflict & GROUP_SECURITY_INFORMATION)
        {
            psd->Group = NULL;
        }

        // The following can happen if there was an error resetting ACLs above

        if (siConflict & SACL_SECURITY_INFORMATION)
        {
            psd->Control &= ~SE_SACL_PRESENT;
            psd->Sacl = NULL;
        }

        if (siConflict & DACL_SECURITY_INFORMATION)
        {
            psd->Control &= ~SE_DACL_PRESENT;
            psd->Dacl = NULL;
        }
    }

exit_gracefully:

    TraceLeaveResult(hr);
}


//
// See comments about SYNCHRONIZE at the top of this file
//
void
FixSynchronizeAccess(SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD)
{
    if (NULL != pSD && 0 != (si & DACL_SECURITY_INFORMATION))
    {
        BOOL bPresent;
        BOOL bDefault;
        PACL pDacl = NULL;

        GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefault);

        if (pDacl)
        {
            PACE_HEADER pAce;
            int i;

            for (i = 0, pAce = (PACE_HEADER)FirstAce(pDacl);
                 i < pDacl->AceCount;
                 i++, pAce = (PACE_HEADER)NextAce(pAce))
            {
                if (ACCESS_ALLOWED_ACE_TYPE == pAce->AceType)
                    ((PKNOWN_ACE)pAce)->Mask |= SYNCHRONIZE;
            }
        }
    }
}


STDMETHODIMP
CNTFSSecurity::SetSecurity(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = S_OK;

    if (si & DACL_SECURITY_INFORMATION)
        FixSynchronizeAccess(si, pSD);

	if(!SetAclOnRemoteNetworkDrive(m_hItemList,
									si,
									pSD,
									GetLastActivePopup(m_hwndOwner)))
	{
		return S_FALSE;
	}

    //
    // If we need to recursively set the Owner, get the Owner &
    // Group from pSD.
    //
    if (si & ( SI_OWNER_RECURSE | SI_RESET_DACL_TREE | SI_RESET_SACL_TREE ) )
    {
        si = si & (~( SI_OWNER_RECURSE | SI_RESET_DACL_TREE | SI_RESET_SACL_TREE ));
        hr = SetSecurityLocal(si, pSD, NULL);

        // Remember whether the user cancelled, since hr gets
        // reset when we call the base class below.
    }
    else 
    {
        // See comments about SYNCHRONIZE at the top of this file

        // Call the base class to do the rest
        hr = CSecurityInformation::SetSecurity(si, pSD);
    }

    if (S_OK == hr && m_pCompareData)
    {
        // If we successfully wrote it, then it doesn't conflict anymore
        m_pCompareData->siConflict &= ~(si);

        if (0 == m_pCompareData->siConflict)
        {
            delete m_pCompareData;
            m_pCompareData = NULL;
        }
    }

    return hr;
}


STDMETHODIMP
CNTFSSecurity::PropertySheetPageCallback(HWND hwnd,
                                         UINT uMsg,
                                         SI_PAGE_TYPE uPage)
{
    HRESULT hr;
    LPUINT pidsPrompt = NULL;
    LPCTSTR pszFile2 = NULL;

    TraceEnter(TRACE_NTFSSI, "CNTFSSecurity::PropertySheetPageCallback");

    hr = CSecurityInformation::PropertySheetPageCallback(hwnd, uMsg, uPage);

    if (uMsg == PSPCB_SI_INITDIALOG)
    {
        WaitForComparison();

        if (m_pCompareData != NULL)
        {
            if (SUCCEEDED(m_pCompareData->hrResult))
            {
                switch (uPage)
                {
                case SI_PAGE_PERM:
                case SI_PAGE_ADVPERM:
                    pidsPrompt = &m_pCompareData->idsDaclPrompt;
                    pszFile2 = m_pCompareData->pszDaclConflict;
                    break;

                case SI_PAGE_AUDIT:
                    pidsPrompt = &m_pCompareData->idsSaclPrompt;
                    pszFile2 = m_pCompareData->pszSaclConflict;
                    break;
                }
            }
        }

        if (pidsPrompt != NULL && *pidsPrompt != 0)
        {
            if (IDYES != MsgPopup(hwnd,
                                  MAKEINTRESOURCE(*pidsPrompt),
                                  MAKEINTRESOURCE(IDS_PROPPAGE_TITLE),
                                  MB_YESNO | MB_ICONWARNING | MB_SETFOREGROUND,
                                  g_hInstance,
                                  m_pszObjectName,
                                  pszFile2))
            {
                hr = E_FAIL;    // abort
            }

            // Don't want to prompt again for the same thing, so set
            // this to zero.
            *pidsPrompt = 0;
        }
    }

    TraceLeaveResult(hr);
}

#ifdef SUPPORT_NTFS_DEFAULT
HRESULT
CNTFSSecurity::GetParentSecurity(SECURITY_INFORMATION si,
                                 PSECURITY_DESCRIPTOR *ppSD)
{
    HRESULT hr = S_OK;
    LPTSTR pszItem;

    TraceEnter(TRACE_NTFSSI, "CNTFSSecurity::GetParentSecurity");
    TraceAssert(m_hItemList && DPA_GetPtrCount(m_hItemList));

    // Get the name of the first item
    pszItem = (LPTSTR)DPA_GetPtr(m_hItemList, 0);
    if (NULL != pszItem && !PathIsRoot(pszItem))
    {
        TCHAR szParent[MAX_PATH];

        lstrcpyn(szParent, pszItem, ARRAYSIZE(szParent));
        PathRemoveFileSpec(szParent);

        // Read the parent DACL/SACL
        hr = ReadObjectSecurity(szParent, si, ppSD);
    }
    TraceLeaveResult(hr);
}

STDMETHODIMP
CNTFSSecurity::GetDefaultSecurity(SECURITY_INFORMATION si,
                                  PSECURITY_DESCRIPTOR *ppSD)
{
    HRESULT hr = S_OK;
    DWORD dwErr;
    PSECURITY_DESCRIPTOR psdParent = NULL;
    SECURITY_INFORMATION siLocal;
    HANDLE hToken = INVALID_HANDLE_VALUE;
    ULONG ulAutoInheritFlags = (SEF_DACL_AUTO_INHERIT               |
                                SEF_SACL_AUTO_INHERIT               |
                                SEF_AVOID_PRIVILEGE_CHECK           |
                                SEF_AVOID_OWNER_CHECK);

    TraceEnter(TRACE_NTFSSI, "CNTFSSecurity::GetDefaultSecurity");
    TraceAssert(m_hItemList && DPA_GetPtrCount(m_hItemList));

    dwErr = GetCurrentToken(TOKEN_QUERY, &hToken);
    if (NOERROR != dwErr)
        ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr), "Unable to get current token");

    // Only DACL and SACL get inherited
    siLocal = si & ~(OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION);
    if (siLocal)
    {
        hr = GetParentSecurity(si, &psdParent);
        FailGracefully(hr, "Unable to get parent security descriptor");
    }

#if(_WIN32_WINNT >= 0x0500)
    if(!CreatePrivateObjectSecurityEx(psdParent,// Inherited ACEs come from here
                                      NULL,
                                      ppSD,
                                      NULL,
                                      !!(m_dwSIFlags & SI_CONTAINER),
                                      ulAutoInheritFlags,
                                      hToken,   // owner & group come from here
                                      &NTFSMap))
#else
    if(!CreatePrivateObjectSecurity(psdParent,
                                    NULL,
                                    ppSD,
                                    !!(m_dwSIFlags & SI_CONTAINER),
                                    hToken,
                                    &NTFSMap))
#endif
    {
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
    }

exit_gracefully:

    if (hToken != INVALID_HANDLE_VALUE)
        CloseHandle(hToken);

    if (psdParent)
        LocalFree(psdParent);

    TraceLeaveResult(hr);
}
#endif  // SUPPORT_NTFS_DEFAULT

#ifdef DONT_USE_ACLAPI
STDMETHODIMP
CNTFSSecurity::ReadObjectSecurity(LPCTSTR pszObject,
                                  SECURITY_INFORMATION si,
                                  PSECURITY_DESCRIPTOR *ppSD)
{
    DWORD dwErr;

    TraceEnter(TRACE_NTFSSI, "CNTFSSecurity::ReadObjectSecurity");

    dwErr = NTFSReadSD(pszObject, si, ppSD);

    TraceLeaveResult(HRESULT_FROM_WIN32(dwErr));
}
#endif  // DONT_USE_ACLAPI

STDMETHODIMP
CNTFSSecurity::WriteObjectSecurity(LPCTSTR pszObject,
                                   SECURITY_INFORMATION si,
                                   PSECURITY_DESCRIPTOR pSD)
{
    DWORD dwErr;
    HRESULT hr = S_OK;

    TraceEnter(TRACE_NTFSSI, "CNTFSSecurity::WriteObjectSecurity");
    TraceAssert(pszObject != NULL);
    TraceAssert(si != 0);
    TraceAssert(pSD != NULL);

#ifdef DONT_USE_ACLAPI
    //
    // Assume that required privileges have already been
    // enabled, if appropriate.
    //
    if (!SetFileSecurity(pszObject, si, pSD))
    {
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
    }
#else
    hr = CSecurityInformation::WriteObjectSecurity(pszObject, si, pSD);


    // This is a workaround.  SetNamedSecurityInfo[Ex] fails with Access Denied
    // in some cases where the owner is trying to set the DACL
    // (typically because the propagation code can't enumerate the children
    // because owner doesn't have read access).

    if (E_ACCESSDENIED == hr)
    {
        SECURITY_DESCRIPTOR_CONTROL wControl = 0;
        DWORD dwRevision;

        // If we're setting a protected DACL (i.e. no inheritance from parent)
        // try SetFileSecurity.  If that works, try the full write again.
        //
        // Don't do this if the DACL isn't protected since it may fool the
        // system into thinking that this is a downlevel DACL that should
        // be protected.  That would be very confusing to the user.

        GetSecurityDescriptorControl(pSD, &wControl, &dwRevision);

        if ((si & DACL_SECURITY_INFORMATION)
            && ((wControl & SE_DACL_PROTECTED) || (m_dwSIFlags & SI_NO_ACL_PROTECT))
            && SetFileSecurity(pszObject, si, pSD))
        {
            hr = CSecurityInformation::WriteObjectSecurity(pszObject, si, pSD);
        }
    }
#endif  // DONT_USE_ACLAPI

    //
    // Notify the shell if we change permissions on a folder (48220)
    //
    if (SUCCEEDED(hr) &&
        (si & DACL_SECURITY_INFORMATION) &&
        (m_dwSIFlags & SI_CONTAINER))
    {
        SHChangeNotify(SHCNE_UPDATEDIR,
                       SHCNF_PATH | SHCNF_FLUSH | SHCNF_FLUSHNOWAIT,
                       pszObject,
                       NULL);
    }

    TraceLeaveResult(hr);
}

void
CNTFSSecurity::WaitForComparison()
{
    if (m_hCompareThread != NULL)
    {
        DWORD dwResult;
        HCURSOR hcurPrevious = SetCursor(LoadCursor(NULL, IDC_WAIT));

        SetThreadPriority(m_hCompareThread, THREAD_PRIORITY_HIGHEST);

        dwResult = WaitForSingleObject(m_hCompareThread, INFINITE);

        if (m_pCompareData != NULL)
        {
            if (GetExitCodeThread(m_hCompareThread, &dwResult))
            {
                m_pCompareData->hrResult = dwResult;
            }
            else
            {
                dwResult = GetLastError();
                m_pCompareData->hrResult = HRESULT_FROM_WIN32(dwResult);
            }
        }

        CloseHandle(m_hCompareThread);
        m_hCompareThread = NULL;
        SetCursor(hcurPrevious);
    }
}

DWORD WINAPI
CNTFSSecurity::NTFSReadSD(LPCTSTR pszObject,
                          SECURITY_INFORMATION si,
                          PSECURITY_DESCRIPTOR* ppSD)
{
    DWORD dwLength = 0;
    DWORD dwErr = 0;

    TraceEnter(TRACE_NTFSSI | TRACE_NTFSCOMPARE, "CNTFSSecurity::NTFSReadSD");
    TraceAssert(pszObject != NULL);
    TraceAssert(si != 0);
    TraceAssert(ppSD != NULL);

    //
    // Assume that required privileges have already been
    // enabled, if appropriate.
    //
    GetFileSecurity(pszObject, si, NULL, 0, &dwLength);
    if (dwLength)
    {
        *ppSD = LocalAlloc(LPTR, dwLength);
        if (*ppSD &&
            !GetFileSecurity(pszObject, si, *ppSD, dwLength, &dwLength))
        {
            dwErr = GetLastError();
            LocalFree(*ppSD);
            *ppSD = NULL;
        }
    }
    else
        dwErr = GetLastError();

    TraceLeaveValue(dwErr);
}

DWORD WINAPI
CNTFSSecurity::NTFSCompareThreadProc(LPVOID pvData)
{
    PNTFS_COMPARE_DATA pCompareData = (PNTFS_COMPARE_DATA)pvData;
    HRESULT hr;
    DWORD dwSIFlags;
    BOOL bOwnerConflict = FALSE;
    BOOL bSaclConflict = FALSE;
    BOOL bDaclConflict = FALSE;

    TraceEnter(TRACE_NTFSCOMPARE, "CNTFSSecurity::NTFSCompareThreadProc");
    TraceAssert(pCompareData != NULL);

    dwSIFlags = pCompareData->dwSIFlags;

    hr = DPA_CompareSecurityIntersection(pCompareData->hItemList,
                                         NTFSReadSD,
                                         (dwSIFlags & SI_EDIT_OWNER) ? &bOwnerConflict : NULL,
                                         NULL,
                                         (dwSIFlags & SI_EDIT_AUDITS) ? &bSaclConflict : NULL,
                                         &bDaclConflict,
                                         NULL,
                                         NULL,
                                         &pCompareData->pszSaclConflict,
                                         &pCompareData->pszDaclConflict,
                                         &pCompareData->bAbortThread);
    if (SUCCEEDED(hr))
    {
        if (bOwnerConflict)
            pCompareData->siConflict |= OWNER_SECURITY_INFORMATION;

        if (bSaclConflict)
            pCompareData->siConflict |= SACL_SECURITY_INFORMATION;

        if (bDaclConflict)
            pCompareData->siConflict |= DACL_SECURITY_INFORMATION;

        if (pCompareData->pszSaclConflict)
            pCompareData->idsSaclPrompt = IDS_BAD_SACL_INTERSECTION;

        if (pCompareData->pszDaclConflict)
            pCompareData->idsDaclPrompt = IDS_BAD_DACL_INTERSECTION;
    }

    TraceLeaveResult(hr);
}


HRESULT
CNTFSSecurity::SetSecurityLocal(SECURITY_INFORMATION si,
                                PSECURITY_DESCRIPTOR pSD,
                                LPBOOL pbNotAllApplied)
{

    HRESULT hr = S_OK;
    HCURSOR hcur = NULL;
    int i;

    TraceEnter(TRACE_NTFSSI, "CNTFSSecurity::SetSecurityLocal");
    TraceAssert(pSD != NULL);
    TraceAssert(SI_CONTAINER & m_dwSIFlags);

    SECURITY_DESCRIPTOR_CONTROL wSDControl = 0;
    DWORD dwRevision;
    PSID psidOwner = NULL;
    PSID psidGroup = NULL;
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    BOOL bDefaulted;
    BOOL bPresent;

    DWORD dwErr = ERROR_SUCCESS;

    NTFS_PF_DATA dataPF;

    if( !si )
        TraceLeaveResult(hr);

    dataPF.si = si;
    dataPF.pNTFSSec = this;
    dataPF.pSD = pSD;
    dataPF.bCancel = FALSE;


    //
    // Get pointers to various security descriptor parts for
    // calling SetNamedSecurityInfo
    //
    GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision);
    GetSecurityDescriptorOwner(pSD, &psidOwner, &bDefaulted);
    GetSecurityDescriptorGroup(pSD, &psidGroup, &bDefaulted);
    GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefaulted);
    GetSecurityDescriptorSacl(pSD, &bPresent, &pSacl, &bDefaulted);
   
    if (si & DACL_SECURITY_INFORMATION)
    {
        if (wSDControl & SE_DACL_PROTECTED)
            si |= PROTECTED_DACL_SECURITY_INFORMATION;
        else
            si |= UNPROTECTED_DACL_SECURITY_INFORMATION;
    }
    if (si & SACL_SECURITY_INFORMATION)
    {
        if (wSDControl & SE_SACL_PROTECTED)
            si |= PROTECTED_SACL_SECURITY_INFORMATION;
        else
            si |= UNPROTECTED_SACL_SECURITY_INFORMATION;
    }


    if (pbNotAllApplied)
        *pbNotAllApplied = FALSE;

    if (NULL == m_hItemList)
        ExitGracefully(hr, E_UNEXPECTED, "CSecurityInformation not initialized");

    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    CreateProgressDialog(si);

    for (i = 0; i < DPA_GetPtrCount(m_hItemList); i++)
    {
        LPTSTR pszItem = (LPTSTR)DPA_FastGetPtr(m_hItemList, i);
        if (NULL != pszItem)
        {

            dwErr = TreeResetNamedSecurityInfo( pszItem,
                                                SE_FILE_OBJECT,
                                                si,
                                                si & OWNER_SECURITY_INFORMATION ? psidOwner : NULL,
                                                NULL,
                                                si & DACL_SECURITY_INFORMATION ? pDacl : NULL,
                                                si & SACL_SECURITY_INFORMATION ? pSacl : NULL,
                                                FALSE,
                                                ProgressFunction,
                                                ProgressInvokeEveryObject,
                                                (PVOID)&dataPF);

            hr = HRESULT_FROM_WIN32(dwErr);
            FailGracefully(hr, "Unable to recursively apply security");
            if(dataPF.bCancel)
            {                
                if(pbNotAllApplied)
                    *pbNotAllApplied = TRUE;
                ExitGracefully(hr, S_FALSE, "User canceled the operation");
            }               
        }
        else
        {
            hr = E_UNEXPECTED;
            break;
        }
    }

exit_gracefully:

    CloseProgressDialog();

    if (m_psdOwnerFullControl)
    {
        LocalFree(m_psdOwnerFullControl);
        m_psdOwnerFullControl = NULL;
    }

    if (hcur)
    {
        SetCursor(hcur);
    }

    TraceLeaveResult(hr);
}

BOOL PathIsDotOrDotDot(LPCTSTR pszPath)
{
    if (TEXT('.') == *pszPath++)
    {
        if (TEXT('\0') == *pszPath || (TEXT('.') == *pszPath && TEXT('\0') == *(pszPath + 1)))
            return TRUE;
    }
    return FALSE;
}

typedef struct _APPLY_SECURITY_ERROR
{
    HWND    hwndParent;
    DWORD   dwError;
    LPCTSTR pszPath;
    UINT    idMsg[1];   // Optional, string resource IDs (only 1 used so far)
} APPLY_SECURITY_ERROR;


INT_PTR CALLBACK
FailedApplySecurityProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            APPLY_SECURITY_ERROR* pae = (APPLY_SECURITY_ERROR*)lParam;
            LPTSTR pszT = NULL;

            // Set the message string(s)
            for (int i = 0; i < ARRAYSIZE(pae->idMsg); i++)
            {
                if (pae->idMsg[i])
                {
                    LoadStringAlloc(&pszT, g_hInstance, pae->idMsg[i]);
                    if (pszT)
                        SetDlgItemText(hDlg, (IDC_MSG1 + i), pszT);
                    LocalFreeString(&pszT);
                }
            }

            // Compact the path so it fits on the dialog
            PathSetDlgItemPath(hDlg, IDC_FILENAME, pae->pszPath);

            // Set the error text
            if (NOERROR != pae->dwError)
            {
                if (!GetSystemErrorText(&pszT, pae->dwError))
                    FormatStringID(&pszT, g_hInstance, IDS_FMT_UNKNOWN_ERROR, pae->dwError);
                if (pszT)
                    SetDlgItemText(hDlg, IDC_ERROR_TXT, pszT);
                LocalFreeString(&pszT);
            }
            break;
        }

        case WM_COMMAND:
        {
            WORD wControlID = GET_WM_COMMAND_ID(wParam, lParam);
            switch (wControlID)
            {
                case IDOK:
                case IDCANCEL:
                    EndDialog(hDlg, wControlID);
                    return TRUE;
            }
            break;
        }
    }
    return FALSE;
}

//
// This function displays the "An error has occured [Continue] [Cancel]" message
//
// Returns IDOK or IDCANCEL
//
int
FailedApplySecurityErrorDlg(HWND hWndParent, APPLY_SECURITY_ERROR* pae)
{
                //The progress dialog must be visible when this error message is shown
    if( !IsWindowVisible( pae->hwndParent ) )
    {
        ShowWindow( pae->hwndParent, SW_SHOW);
        SetForegroundWindow( pae->hwndParent );
    }


    return (int)DialogBoxParam(g_hInstance,
                               MAKEINTRESOURCE(IDD_SET_SECURITY_ERROR),
                               hWndParent,
                               FailedApplySecurityProc,
                               (LPARAM)pae);
}

#ifndef IDA_APPLYATTRIBS
// this is the resource ID of an AVI in shell32.dll. If shell32's
// resource ID's change, we'll get the wrong animation (or none).
// We could steal the AVI and build it into rshx32's resources, except
// it almost doubles the size of rshx32.dll (~35k to ~57k).
#define IDA_APPLYATTRIBS        165     // animation for applying file attributes
#endif

void
CNTFSSecurity::CreateProgressDialog(SECURITY_INFORMATION si)
{
    HRESULT hr = S_OK;
    // Shouldn't be necessary, but just in case
    CloseProgressDialog();

    // m_hwndOwner is the toplevel parent of the Security page
    m_hwndPopupOwner = GetLastActivePopup(m_hwndOwner);

    __try
    {
    hr = CoCreateInstance(CLSID_ProgressDialog,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IProgressDialog,
                          (void**)&m_pProgressDlg);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_OUTOFMEMORY;

    }

    if (SUCCEEDED(hr) && m_pProgressDlg)
    {
        WCHAR szT[256];
        UINT ids = IDS_RESET_SEC_TREE;
        IOleWindow *pWindow;

        LoadStringW(g_hInstance, IDS_PROPPAGE_TITLE, szT, ARRAYSIZE(szT));
        m_pProgressDlg->SetTitle(szT);

        switch (si)
        {
        case OWNER_SECURITY_INFORMATION:
            ids = IDS_RESET_OWNER_TREE;
            break;

        case SACL_SECURITY_INFORMATION:
            ids = IDS_RESET_SACL_TREE;
            break;

        case DACL_SECURITY_INFORMATION:
            ids = IDS_RESET_DACL_TREE;
            break;
        }
        LoadStringW(g_hInstance, ids, szT, ARRAYSIZE(szT));
        m_pProgressDlg->SetLine(1, szT, FALSE, NULL);

        m_pProgressDlg->SetAnimation(GetModuleHandle(TEXT("shell32.dll")), IDA_APPLYATTRIBS);
        m_pProgressDlg->StartProgressDialog(m_hwndPopupOwner,
                                            NULL,
                                            PROGDLG_MODAL | PROGDLG_NOTIME
                                             | PROGDLG_NOMINIMIZE | PROGDLG_NOPROGRESSBAR,
                                            NULL);

        if (SUCCEEDED(m_pProgressDlg->QueryInterface(IID_IOleWindow, (void**)&pWindow)))
        {
            pWindow->GetWindow(&m_hwndPopupOwner);
            pWindow->Release();
        }
    }
}

void
CNTFSSecurity::CloseProgressDialog(void)
{
    m_hwndPopupOwner = NULL;

    if (m_pProgressDlg)
    {
        m_pProgressDlg->StopProgressDialog();
        m_pProgressDlg->Release();
        m_pProgressDlg = NULL;
    }
}

HRESULT
CNTFSSecurity::SetProgress(LPTSTR pszFile)
{
    USES_CONVERSION;

    if (m_pProgressDlg)
    {
        m_pProgressDlg->SetLine(2, T2W(pszFile), TRUE, NULL);
        if (m_pProgressDlg->HasUserCancelled())
            return S_FALSE;
    }
    return S_OK;
}

HRESULT
CNTFSSecurity::BuildOwnerFullControlSD(PSECURITY_DESCRIPTOR pSD)
{
    PSID psidOwner;
    BOOL bDefaulted;
    DWORD dwAclLen;
    PACL pAcl;
    PACE_HEADER pAce;

    if (!GetSecurityDescriptorOwner(pSD, &psidOwner, &bDefaulted))
        return E_INVALIDARG;

    dwAclLen = sizeof(ACL)
        + sizeof(KNOWN_ACE) - sizeof(DWORD)
        + GetLengthSid(psidOwner);

    m_psdOwnerFullControl = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH + dwAclLen);
    if (NULL == m_psdOwnerFullControl)
        return E_OUTOFMEMORY;

    InitializeSecurityDescriptor(m_psdOwnerFullControl, SECURITY_DESCRIPTOR_REVISION);
    pAcl = (PACL)ByteOffset(m_psdOwnerFullControl, SECURITY_DESCRIPTOR_MIN_LENGTH);
    InitializeAcl(pAcl, dwAclLen, ACL_REVISION);
    AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidOwner);
    pAce = (PACE_HEADER)FirstAce(pAcl);
    pAce->AceFlags = INHERIT_FULL;
    SetSecurityDescriptorDacl(m_psdOwnerFullControl, TRUE, pAcl, TRUE);

    return S_OK;
}
VOID ProgressFunction(IN LPWSTR                   pObjectName,    
                      IN DWORD                    Status,         
                      IN OUT PPROG_INVOKE_SETTING pInvokeSetting ,
                      IN PVOID                    Args,
                      BOOL                        bSecuritySet)
{
    TraceEnter(TRACE_NTFSCOMPARE, "ProgressFunction");
    TraceAssert(pObjectName != NULL);
    TraceAssert(Args);
    
    PNTFS_PF_DATA pfData = (PNTFS_PF_DATA)(Args);
    CNTFSSecurity * pNTFSSec = pfData->pNTFSSec;
    HRESULT hr = S_OK;

    if( Status == ERROR_SUCCESS )
    {
        //
        // Notify the shell if we change permissions on a folder (48220)
        //
        if ( pfData->si & DACL_SECURITY_INFORMATION)
        {
            SHChangeNotify(SHCNE_UPDATEDIR,
                           SHCNF_PATH | SHCNF_FLUSH | SHCNF_FLUSHNOWAIT,
                           pObjectName,
                           NULL);
        }
    }
    else
    {   
        //
        //This means it was able to set security on this folder and some error 
        //occured while enumerating child. 
        //
        if(bSecuritySet && pfData->si & OWNER_SECURITY_INFORMATION)
        {
            BOOL bIsFile = FALSE;
            hr = pNTFSSec->GiveOwnerFullControl(pObjectName, pfData->pSD, &bIsFile);
            if(hr == S_OK)
            {
                //
                //Look for comment in SetFileSecurityUsingNTName
                //
                *pInvokeSetting = bIsFile ?ProgressInvokeEveryObject:ProgressRetryOperation;
                TraceLeaveVoid();
            }
        }
        
        APPLY_SECURITY_ERROR ae = { ((PNTFS_PF_DATA)(Args))->pNTFSSec->GetHwndPopOwner(),HRESULT_FROM_WIN32(Status), pObjectName, { 0 } };
        if (IDOK != FailedApplySecurityErrorDlg( ((PNTFS_PF_DATA)(Args))->pNTFSSec->GetHwndPopOwner(), &ae))
        {
            *pInvokeSetting = ProgressCancelOperation;   // abort
            pfData->bCancel = TRUE;
        }
        else
        {
            *pInvokeSetting = ProgressInvokeEveryObject;      // continue
        }
    }
    
    if (S_FALSE == ((PNTFS_PF_DATA)(Args))->pNTFSSec->SetProgress(pObjectName))
        *pInvokeSetting = ProgressCancelOperation;
    
    TraceLeaveVoid();

}

HRESULT CNTFSSecurity::GiveOwnerFullControl( LPCWSTR lpszFileName, 
                                             PSECURITY_DESCRIPTOR pSD,  
                                             BOOL *pbIsFile)
{

    HRESULT hr = S_OK;


    // Ask the user if they want to grant themselves access
    if (!m_psdOwnerFullControl)
    {
        if (IDYES == MsgPopup(m_hwndPopupOwner,
            MAKEINTRESOURCE(IDS_FMT_WRITE_OWNER_ERR),
            MAKEINTRESOURCE(IDS_PROPPAGE_TITLE),
            MB_YESNO | MB_ICONWARNING | MB_SETFOREGROUND,
            g_hInstance,
            lpszFileName))
        {
            BuildOwnerFullControlSD(pSD);
        }
        else
        {
            // Continue without enumerating this folder
            TraceLeaveResult(S_FALSE);
        }
    }
    if (m_psdOwnerFullControl)
    {
        // Give the owner Full Control
        // Use SetFileSecurity instead?, yes Use SetFileSecurity instead
        UNICODE_STRING usFileName;
        RtlInitUnicodeString(&usFileName,lpszFileName);
        
        if(!SetFileSecurityUsingNTName(&usFileName,
                                      m_psdOwnerFullControl,
                                      pbIsFile))
        {

            hr = E_FAIL;
        }

        if(SUCCEEDED(hr))
            TraceLeaveResult(S_OK);
    }
    TraceLeaveResult(S_FALSE);
}

GENERIC_MAPPING STANDARD_FILE_MAP=
{
    FILE_GENERIC_READ,
    FILE_GENERIC_WRITE,
    FILE_GENERIC_EXECUTE,
    FILE_ALL_ACCESS
};

STDMETHODIMP 
CNTFSSecurity::GetInheritSource( SECURITY_INFORMATION si,
                                 PACL pACL, 
                                 PINHERITED_FROM *ppInheritArray)
{
    HRESULT hr = S_OK;
    LPTSTR pszItem;
    DWORD dwErr = ERROR_SUCCESS;
    PINHERITED_FROM pTempInherit = NULL;
    PINHERITED_FROM pTempInherit2 = NULL;
    LPWSTR pStrTemp = NULL;
    TraceEnter(TRACE_SI, "CNTFSSecurity::GetInheritSource");
    TraceAssert(pACL != 0);
    TraceAssert(ppInheritArray != NULL);

    if( pACL == NULL || ppInheritArray == NULL )
        ExitGracefully(hr, E_POINTER, "Invalid Parameters, CNTFSSecurity::GetInheritSource");

    // Get the name of the first item
    pszItem = (LPTSTR)DPA_GetPtr(m_hItemList, 0);
    if (NULL == pszItem)
        ExitGracefully(hr, E_UNEXPECTED, "CSecurityInformation not initialized");


    pTempInherit = (PINHERITED_FROM)LocalAlloc( LPTR, sizeof(INHERITED_FROM)*pACL->AceCount);
    if(pTempInherit == NULL)
            ExitGracefully(hr, E_OUTOFMEMORY,"OUT of Memory");


    dwErr = GetInheritanceSource(pszItem,
                                 SE_FILE_OBJECT,
                                 si,
                                 m_dwSIFlags & SI_CONTAINER,
                                 NULL,
                                 0,
                                 pACL,
                                 NULL,
                                 &STANDARD_FILE_MAP,
                                 pTempInherit);
    
    hr = HRESULT_FROM_WIN32(dwErr);
    FailGracefully( hr, "GetInheritanceSource Failed");

    DWORD nSize;
    UINT i;

    nSize = sizeof(INHERITED_FROM)*pACL->AceCount;
    for(i = 0; i < pACL->AceCount; ++i)
    {
        if(pTempInherit[i].AncestorName)
            nSize += StringByteSize(pTempInherit[i].AncestorName);
    }

    pTempInherit2 = (PINHERITED_FROM)LocalAlloc( LPTR, nSize );
    if(pTempInherit2 == NULL)
        ExitGracefully(hr, E_OUTOFMEMORY,"OUT of Memory");
    
    pStrTemp = (LPWSTR)(pTempInherit2 + pACL->AceCount); 

    for(i = 0; i < pACL->AceCount; ++i)
    {
        pTempInherit2[i].GenerationGap = pTempInherit[i].GenerationGap;
        if(pTempInherit[i].AncestorName)
        {
            pTempInherit2[i].AncestorName = pStrTemp;
            wcscpy(pStrTemp,pTempInherit[i].AncestorName);
            pStrTemp += (wcslen(pTempInherit[i].AncestorName)+1);
        }
    }
            

exit_gracefully:

    if(SUCCEEDED(hr))
    {
        //FreeInheritedFromArray(pTempInherit, pACL->AceCount,NULL);
        *ppInheritArray = pTempInherit2;
            
    }                        
    if(pTempInherit)
        LocalFree(pTempInherit);

    TraceLeaveResult(hr);
}



BOOL SetFileSecurityUsingNTName(IN PUNICODE_STRING pFileName,
                                IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                IN PBOOL pbIsFile)
{


    
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE hFile = NULL;
    

    InitializeObjectAttributes(
        &Obja,
        pFileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                 &hFile,
                 WRITE_DAC,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                 FILE_OPEN_REPARSE_POINT
                 );

    if ( Status == STATUS_INVALID_PARAMETER ) {
        Status = NtOpenFile(
                     &hFile,
                     WRITE_DAC,
                     &Obja,
                     &IoStatusBlock,
                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                     0
                     );
    }


    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }


    if (!SetKernelObjectSecurity(
         hFile,
         DACL_SECURITY_INFORMATION,
         pSecurityDescriptor
         ))
    {
        ASSERT(FALSE);
        NtClose(hFile);
        return FALSE;
    }

    NtClose(hFile);
    //
    //When resetting the owner, if user is not owner and he doesn't have any permissions
    //TreeResetNamedSecurityInfo cannot determine if its a file or directory. So after 
    //setting the ownership TreeResetNamedSecurityInfo tries to enumerate the file, which fails
    //as there is nothing to enumerate and TreeResetNamedSecurityInfo calls ProgressFunction 
    //which stamps a FullControl on the file and ask TreeResetNamedSecurityInfo to retry
    //which again fails and we are infinte loop. The way to break this is ask TreeResetNamedSecurityInfo
    //not to retry if its a file. which is what we are doing below. Ugly, yup.


    //
    //default we assume its a file
    //if its a file and we assume its a dir, we are infinite loop
    //if its a dir and we assume its a file, we skip that dir which 
    //is lesser evil
    //
    *pbIsFile = TRUE;
        
    //
    //Open the file for Generic_read
    //

   if (NT_SUCCESS(Status = NtOpenFile(
                     &hFile,
                     FILE_GENERIC_READ,
                     &Obja,
                     &IoStatusBlock,
                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                     0
                     )))
    {


       //
       // Query the attributes for the file/dir.
       // In case of error, assume that it is a dir.
       //
       FILE_BASIC_INFORMATION BasicFileInfo;
       if (NT_SUCCESS(Status = NtQueryInformationFile(
               hFile,
               &IoStatusBlock,
               &BasicFileInfo,
               sizeof(BasicFileInfo),
               FileBasicInformation)))
        {
            if(BasicFileInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                *pbIsFile = FALSE;
        }

        NtClose(hFile);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\rshx32\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       resource.h
//
//  This file contains the resource IDs for all resources required by
//  this module.
//
//--------------------------------------------------------------------------

#ifndef _RESOURCE_H_
#define _RESOURCE_H_

//
// Dialogs
//

#define IDD_SET_SECURITY_ERROR              1

//
// Dialog control IDs
//

#define IDC_STATIC                          -1
#define IDC_FILENAME                        100
#define IDC_ERROR_TXT                       101
#define IDC_MSG1                            102
#define IDC_MSG2                            103

//
// General String IDs
//
#define IDS_RSHX_BASE                       0

#define IDS_SECURITY_MENU                   (IDS_RSHX_BASE+0)
#define IDS_SECURITY_HELPSTRING             (IDS_RSHX_BASE+1)
#define IDS_PROPPAGE_TITLE                  (IDS_RSHX_BASE+2)
#define IDS_NONE                            (IDS_RSHX_BASE+3)
#define IDS_MULTISEL_ELLIPSIS               (IDS_RSHX_BASE+4)
#define IDS_BAD_DACL_INTERSECTION           (IDS_RSHX_BASE+5)
#define IDS_BAD_SACL_INTERSECTION           (IDS_RSHX_BASE+6)
#define IDS_READ_DIR_ERR                    (IDS_RSHX_BASE+7)
#define IDS_FMT_VOLUME_DISPLAY              (IDS_RSHX_BASE+9)
#define IDS_FMT_UNKNOWN_ERROR               (IDS_RSHX_BASE+10)
#define IDS_FMT_WRITE_OWNER_ERR             (IDS_RSHX_BASE+11)
#define IDS_RESET_OWNER_TREE                (IDS_RSHX_BASE+12)
#define IDS_RESET_DACL_TREE                 (IDS_RSHX_BASE+13)
#define IDS_RESET_SACL_TREE                 (IDS_RSHX_BASE+14)
#define IDS_RESET_SEC_TREE                  (IDS_RSHX_BASE+15)

#define IDS_RSHX_LAST                       (IDS_RSHX_BASE+15)


//
// String IDs for NTFS permission names
//
#define IDS_NTFS_BASE                       (IDS_RSHX_LAST+1)

#define IDS_NTFS_GENERIC_ALL                (IDS_NTFS_BASE+0)
#define IDS_NTFS_GENERIC_READ               (IDS_NTFS_BASE+1)
#define IDS_NTFS_GENERIC_WRITE              (IDS_NTFS_BASE+2)
#define IDS_NTFS_GENERIC_EXECUTE            (IDS_NTFS_BASE+3)

#define IDS_NTFS_GENERAL_MODIFY             (IDS_NTFS_BASE+4)
#define IDS_NTFS_GENERAL_PUBLISH            (IDS_NTFS_BASE+5)
#define IDS_NTFS_GENERAL_DEPOSIT            (IDS_NTFS_BASE+6)
#define IDS_NTFS_GENERAL_READ               (IDS_NTFS_BASE+7)
#define IDS_NTFS_GENERAL_LIST               (IDS_NTFS_BASE+8)

#define IDS_NTFS_STD_DELETE                 (IDS_NTFS_BASE+16)
#define IDS_NTFS_STD_READ_CONTROL           (IDS_NTFS_BASE+17)
#define IDS_NTFS_STD_WRITE_DAC              (IDS_NTFS_BASE+18)
#define IDS_NTFS_STD_WRITE_OWNER            (IDS_NTFS_BASE+19)
#define IDS_NTFS_STD_SYNCHRONIZE            (IDS_NTFS_BASE+20)
#define IDS_NTFS_ACCESS_SYSTEM_SECURITY     (IDS_NTFS_BASE+21)

#define IDS_NTFS_FILE_READ_DATA             (IDS_NTFS_BASE+22)
#define IDS_NTFS_FILE_WRITE_DATA            (IDS_NTFS_BASE+23)
#define IDS_NTFS_FILE_APPEND_DATA           (IDS_NTFS_BASE+24)
#define IDS_NTFS_FILE_READ_EA               (IDS_NTFS_BASE+25)
#define IDS_NTFS_FILE_WRITE_EA              (IDS_NTFS_BASE+26)
#define IDS_NTFS_FILE_EXECUTE               (IDS_NTFS_BASE+27)
#define IDS_NTFS_FILE_DELETE_CHILD          (IDS_NTFS_BASE+28)
#define IDS_NTFS_FILE_READ_ATTR             (IDS_NTFS_BASE+29)
#define IDS_NTFS_FILE_WRITE_ATTR            (IDS_NTFS_BASE+30)
#define IDS_NTFS_FILE_CREATE_PIPE           (IDS_NTFS_BASE+31)

#define IDS_NTFS_FOLDER                     (IDS_NTFS_BASE+32)
#define IDS_NTFS_FOLDER_SUBITEMS            (IDS_NTFS_BASE+33)
#define IDS_NTFS_FOLDER_SUBFOLDER           (IDS_NTFS_BASE+34)
#define IDS_NTFS_FOLDER_FILE                (IDS_NTFS_BASE+35)
#define IDS_NTFS_SUBITEMS_ONLY              (IDS_NTFS_BASE+36)
#define IDS_NTFS_SUBFOLDER_ONLY             (IDS_NTFS_BASE+37)
#define IDS_NTFS_FILE_ONLY                  (IDS_NTFS_BASE+38)

#define IDS_NTFS_LAST                       (IDS_NTFS_BASE+47)

//
// String IDs for Printer permission names
//
#define IDS_PRINT_BASE                      (IDS_NTFS_LAST+1)

#define IDS_PRINT_PRINT                     (IDS_PRINT_BASE+0)
#define IDS_PRINT_ADMINISTER                (IDS_PRINT_BASE+1)
#define IDS_PRINT_ADMINISTER_JOBS           (IDS_PRINT_BASE+2)
#define IDS_PRINT_DELETE                    (IDS_PRINT_BASE+3)
#define IDS_PRINT_READ                      (IDS_PRINT_BASE+4)
#define IDS_PRINT_CHANGE_PERM               (IDS_PRINT_BASE+5)
#define IDS_PRINT_CHANGE_OWNER              (IDS_PRINT_BASE+6)
#define IDS_PRINT_JOB_ALL                   (IDS_PRINT_BASE+7)

#define IDS_PRINT_PRINTER                   (IDS_PRINT_BASE+8)
#define IDS_PRINT_DOCUMENT_ONLY             (IDS_PRINT_BASE+9)
#define IDS_PRINT_PRINTER_DOCUMENT          (IDS_PRINT_BASE+10)

#define IDS_PRINT_LAST                      (IDS_PRINT_BASE+15)

#endif // _RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\rshx32\rshx32.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       rshx32.h
//
//  Remote administration shell extension.
//
//--------------------------------------------------------------------------

#ifndef _RSHX32_H_
#define _RSHX32_H_

#ifndef UNICODE
#error "No ANSI support yet"
#endif

extern "C"
{
    #include <nt.h>         // for SE_TAKE_OWNERSHIP_PRIVILEGE, etc
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <seopaque.h>   // RtlObjectAceSid, etc.
    #include <sertlp.h>     // RtlpOwnerAddrSecurityDescriptor, etc.
}

#define INC_OLE2
#include <windows.h>
#include "resource.h"   // resource IDs

#ifndef RC_INVOKED

#include <winspool.h>
#include <shellapi.h>   // HDROP, ShellExecuteEx
#include <shlobj.h>     // CF_IDLIST
#include <shlwapi.h>    // StrChr
#include <commctrl.h>   // property page stuff
#include <comctrlp.h>   // DPA
#include <aclapi.h>
#include <aclui.h>
#include <common.h>
#include "cstrings.h"
#include "util.h"
extern "C"
{
#include "authz.h"
}
#include "ntfssi.h"
#include "printsi.h"


#if(_WIN32_WINNT >= 0x0500)
#include <shlobjp.h>    // ILCombine
#else   // _WIN32_WINNT < 0x0500
#define ILIsEmpty(pidl)     ((pidl)->mkid.cb==0)
STDAPI_(void) ILFree(LPITEMIDLIST pidl);
STDAPI_(LPITEMIDLIST) ILCombine(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
#endif  // _WIN32_WINNT < 0x0500


#define ALL_SECURITY_ACCESS     (READ_CONTROL | WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY)

// Magic debug flags
#define TRACE_RSHX32        0x00000001
#define TRACE_SI            0x00000002
#define TRACE_NTFSSI        0x00000004
#define TRACE_PRINTSI       0x00000008
#define TRACE_UTIL          0x00000010
#define TRACE_NTFSCOMPARE   0x00000020
#define TRACE_ALWAYS        0xffffffff          // use with caution

//
// Global variables
//
extern HINSTANCE        g_hInstance;
extern LONG             g_cRefThisDll;
extern CLIPFORMAT       g_cfShellIDList;
extern CLIPFORMAT       g_cfPrinterGroup;
extern CLIPFORMAT       g_cfMountedVolume;

#endif // RC_INVOKED
#endif // _RSHX32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\rshx32\rshx32.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       rshx32.cpp
//
//  Remote administration shell extension.
//
//--------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "rshx32.h"
#include <winnetwk.h>   // WNetGetConnection
#include <lm.h>
#include <lmdfs.h>      // NetDfsGetClientInfo
#include <atlconv.h>

#include <initguid.h>
DEFINE_GUID(CLSID_NTFSSecurityExt, 0x1f2e5c40, 0x9550, 0x11ce, 0x99, 0xd2, 0x00, 0xaa, 0x00, 0x6e, 0x08, 0x6c);
DEFINE_GUID(CLSID_PrintSecurityExt, 0xf37c5810, 0x4d3f, 0x11d0, 0xb4, 0xbf, 0x00, 0xaa, 0x00, 0xbb, 0xb7, 0x23);

#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void**>(static_cast<IType**>(ppType))

#define RSX_SECURITY_CHECKED    0x00000001L
#define RSX_HAVE_SECURITY       0x00000002L

#define DOBJ_RES_CONT           0x00000001L
#define DOBJ_RES_ROOT           0x00000002L
#define DOBJ_VOL_NTACLS         0x00000004L     // NTFS or OFS


class CRShellExtCF : public IClassFactory
{
protected:
    ULONG m_cRef;
    SE_OBJECT_TYPE m_seType;

public:
    CRShellExtCF(SE_OBJECT_TYPE seType);
    ~CRShellExtCF();

    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, void **);
    STDMETHODIMP LockServer(BOOL);
};

class CRShellExt : public IShellExtInit, IShellPropSheetExt, IContextMenu
{
protected:
    ULONG           m_cRef;
    SE_OBJECT_TYPE  m_seType;
    IDataObject    *m_lpdobj; // interface passed in by shell
    HRESULT         m_hrSecurityCheck;
    DWORD           m_dwSIFlags;
    LPTSTR          m_pszServer;
    LPTSTR          m_pszObject;
    HDPA            m_hItemList;

public:
    CRShellExt(SE_OBJECT_TYPE seType);
    ~CRShellExt();

    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IShellExtInit method
    STDMETHODIMP Initialize(LPCITEMIDLIST, LPDATAOBJECT, HKEY);

    // IShellPropSheetExt methods
    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE, LPARAM);
    STDMETHODIMP ReplacePage(UINT, LPFNADDPROPSHEETPAGE, LPARAM);

    //IContextMenu methods
    STDMETHODIMP QueryContextMenu(HMENU hMenu,
                                  UINT indexMenu,
                                  UINT idCmdFirst,
                                  UINT idCmdLast,
                                  UINT uFlags);

    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi);

    STDMETHODIMP GetCommandString(UINT_PTR idCmd,
                                  UINT uFlags,
                                  UINT *reserved,
                                  LPSTR pszName,
                                  UINT cchMax);
private:
    STDMETHODIMP DoSecurityCheck(LPIDA pIDA);
    STDMETHODIMP CheckForSecurity(LPIDA pIDA);
    STDMETHODIMP CreateSI(LPSECURITYINFO *ppsi);
    STDMETHODIMP AddSecurityPage(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

    BOOL IsAddPrinterWizard() const;
#if (_WIN32_WINNT >= 0x0500)
    STDMETHODIMP AddMountedVolumePage(LPFNADDPROPSHEETPAGE lpfnAddPage,
                                      LPARAM               lParam);
#endif
};
typedef CRShellExt* PRSHELLEXT;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HINSTANCE        g_hInstance = NULL;
LONG             g_cRefThisDll = 0;
CLIPFORMAT       g_cfShellIDList = 0;
CLIPFORMAT       g_cfPrinterGroup = 0;
CLIPFORMAT       g_cfMountedVolume = 0;
HMODULE          g_hAclui = NULL;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private prototypes                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

void GetFileInfo(LPCTSTR pszPath,
                 LPDWORD pdwFileType,
                 LPTSTR  pszServer,
                 ULONG   cchServer,
                 LPTSTR *ppszAlternatePath);

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// General routines                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

/*++

Routine Description:

    Dll's entry point.

    In order to service requests for file selection information from
    any of the file manager extensions to be included in this library,
    we must first register a window class to accept these requests.

    The Microsoft_Network provider transfers information via a private
    clipboard format called "Net Resource" which we must register.

Arguments:

    Same as DllEntryPoint.

Return Values:

    Same as DllEntryPoint.

--*/

STDAPI_(BOOL) DllMain(HINSTANCE hInstance, DWORD dwReason, void * /*lpReserved*/)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hInstance = hInstance;
        g_cfShellIDList = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLIST);
        g_cfPrinterGroup = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_PRINTERGROUP);
        g_cfMountedVolume = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_MOUNTEDVOLUME);
        DebugProcessAttach();
        TraceSetMaskFromCLSID(CLSID_NTFSSecurityExt);
#ifndef DEBUG
        DisableThreadLibraryCalls(hInstance);
#endif
        break;

    case DLL_PROCESS_DETACH:
        if (g_hAclui)
            FreeLibrary(g_hAclui);
        DebugProcessDetach();
        break;

    case DLL_THREAD_DETACH:
        DebugThreadDetach();
        break;
    }

    return TRUE;
}


/*++

Routine Description:

    Called by shell to create a class factory object.

Arguments:

    rclsid - reference to class id specifier.
    riid   - reference to interface id specifier.
    ppv    - pointer to location to receive interface pointer.

Return Values:

    Returns HRESULT signifying success or failure.

--*/

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    HRESULT hr;
    SE_OBJECT_TYPE seType;

    *ppv = NULL;

    if (IsEqualCLSID(rclsid, CLSID_NTFSSecurityExt))
        seType = SE_FILE_OBJECT;
    else if (IsEqualCLSID(rclsid, CLSID_PrintSecurityExt))
        seType = SE_PRINTER;
    else
        return CLASS_E_CLASSNOTAVAILABLE;

    CRShellExtCF *pShellExtCF = new CRShellExtCF(seType);   // ref == 1

    if (!pShellExtCF)
        return E_OUTOFMEMORY;

    hr = pShellExtCF->QueryInterface(riid, ppv);

    pShellExtCF->Release();     // release initial ref

    return hr;
}


/*++

Routine Description:

    Called by shell to find out if dll can be unloaded.

Arguments:

    None.

Return Values:

    Returns S_OK if dll can be unloaded, S_FALSE if not.

--*/

STDAPI DllCanUnloadNow()
{
    return (g_cRefThisDll == 0 ? S_OK : S_FALSE);
}


STDAPI DllRegisterServer(void)
{
    return CallRegInstall(g_hInstance, "DefaultInstall");
}


STDAPI DllUnregisterServer(void)
{
    return CallRegInstall(g_hInstance, "DefaultUninstall");
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CRShellExtCF::CRShellExtCF(SE_OBJECT_TYPE seType) : m_cRef(1), m_seType(seType)
{
    InterlockedIncrement(&g_cRefThisDll);
}

CRShellExtCF::~CRShellExtCF()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG) CRShellExtCF::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CRShellExtCF::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CRShellExtCF::QueryInterface(REFIID riid, void ** ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (IClassFactory *)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IClassFactory)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


/*++

Routine Description:

    Support for IClassFactory::CreateInstance.

Arguments:

    pUnkOuter - pointer to controlling unknown.
    riid      - reference to interface id specifier.
    ppvObj    - pointer to location to receive interface pointer.

Return Values:

    Returns HRESULT signifying success or failure.

--*/

STDMETHODIMP CRShellExtCF::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void ** ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CRShellExt *pShellExt = new CRShellExt(m_seType);// ref count == 1

    if (!pShellExt)
        return E_OUTOFMEMORY;

    HRESULT hr = pShellExt->QueryInterface(riid, ppvObj);
    pShellExt->Release();                       // release initial ref

    return hr;
}



/*++

Routine Description:

    Support for IClassFactory::LockServer (not implemented).

Arguments:

    fLock - true if lock count to be incremented.

Return Values:

    Returns E_NOTIMPL.

--*/

STDMETHODIMP CRShellExtCF::LockServer(BOOL /*fLock*/)
{
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Shell extension object implementation                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CRShellExt::CRShellExt(SE_OBJECT_TYPE seType) : m_cRef(1), m_seType(seType),
    m_dwSIFlags(SI_EDIT_ALL | SI_ADVANCED | SI_EDIT_EFFECTIVE), m_hrSecurityCheck((HRESULT)-1),
    m_hItemList(NULL)
{
    InterlockedIncrement(&g_cRefThisDll);
}

CRShellExt::~CRShellExt()
{
    DoRelease(m_lpdobj);

    LocalFreeString(&m_pszServer);
    LocalFreeString(&m_pszObject);

    LocalFreeDPA(m_hItemList);

    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Shell extension object implementation (IUnknown)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRShellExt::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CRShellExt::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CRShellExt::QueryInterface(REFIID riid, void ** ppv)
{
    if (IsEqualIID(riid, IID_IShellExtInit) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPSHELLEXTINIT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        *ppv = (LPCONTEXTMENU)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IShellPropSheetExt))
    {
        *ppv = (LPSHELLPROPSHEETEXT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Shell extension object implementation (IShellExtInit)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


/*++

Routine Description:

    Support for IShellExtInit::Initialize.

Arguments:

    pidlFolder - pointer to id list identifying parent folder.
    lpdobj     - pointer to IDataObject interface for selected object(s).
    hKeyProgId - registry key handle.

Return Values:

    Returns HRESULT signifying success or failure.

--*/

STDMETHODIMP CRShellExt::Initialize(LPCITEMIDLIST /*pidlFolder*/, IDataObject *lpdobj, HKEY /*hKeyProgID*/)
{
    DoRelease(m_lpdobj);

    m_lpdobj = lpdobj; // processed in AddPages

    if (m_lpdobj)
        m_lpdobj->AddRef();

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Shell extension object implementation (IShellPropSheetExt)                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


/*++

Routine Description:

    Support for IShellPropSheetExt::AddPages.

Arguments:

    lpfnAddPage - pointer to function called to add a page.
    lParam      - lParam parameter to be passed to lpfnAddPage.

Return Values:

    Returns HRESULT signifying success or failure.

--*/

STDMETHODIMP
CRShellExt::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage,
                     LPARAM               lParam)
{
    HRESULT hr;
    STGMEDIUM medium = {0};
    FORMATETC fe = { g_cfShellIDList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    LPIDA pIDA = NULL;

    TraceEnter(TRACE_RSHX32, "CRShellExt::AddPages");

    if (IsSimpleUI())
        ExitGracefully(hr, E_FAIL, "No Security page in simple mode");

	//	
	//Check if Security Tab is hidden by privacy policy
	//NTRAID#NTBUG9-223899-2001/03/06-hiteshr
	//
	if(IsUIHiddenByPrivacyPolicy())
		ExitGracefully(hr, E_FAIL, "Security Page is hidden by Privacy Policy");

    // Get the ID List data
    hr = m_lpdobj->GetData(&fe, &medium);
#if (_WIN32_WINNT >= 0x0500)
    if (FAILED(hr) && m_seType == SE_FILE_OBJECT)
        TraceLeaveResult(AddMountedVolumePage(lpfnAddPage, lParam));
#endif
    FailGracefully(hr, "Can't get ID List format from data object");

    pIDA = (LPIDA)GlobalLock(medium.hGlobal);
    TraceAssert(pIDA != NULL);

    // Only support single selection for printers
    if (m_seType == SE_PRINTER && pIDA->cidl != 1)
        ExitGracefully(hr, E_FAIL, "Printer multiple selection not supported");

    hr = DoSecurityCheck(pIDA);

    if (S_OK == hr)
        hr = AddSecurityPage(lpfnAddPage, lParam);

exit_gracefully:

    if (pIDA)
        GlobalUnlock(medium.hGlobal);
    ReleaseStgMedium(&medium);
    TraceLeaveResult(hr);
}



/*++

Routine Description:

    Support for IShellPropSheetExt::ReplacePages (not supported).

Arguments:

    uPageID         - page to replace.
    lpfnReplaceWith - pointer to function called to replace a page.
    lParam          - lParam parameter to be passed to lpfnReplaceWith.

Return Values:

    Returns E_FAIL.

--*/

STDMETHODIMP
CRShellExt::ReplacePage(UINT                 /* uPageID */,
                        LPFNADDPROPSHEETPAGE /* lpfnReplaceWith */,
                        LPARAM               /* lParam */)
{
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Shell extension object implementation (IContextMenu)                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//
//  FUNCTION: IContextMenu::QueryContextMenu(HMENU, UINT, UINT, UINT, UINT)
//
//  PURPOSE: Called by the shell just before the context menu is displayed.
//           This is where you add your specific menu items.
//
//  PARAMETERS:
//    hMenu      - Handle to the context menu
//    indexMenu  - Index of where to begin inserting menu items
//    idCmdFirst - Lowest value for new menu ID's
//    idCmtLast  - Highest value for new menu ID's
//    uFlags     - Specifies the context of the menu event
//
//  RETURN VALUE:
//    HRESULT signifying success or failure.
//
//  COMMENTS:
//

STDMETHODIMP
CRShellExt::QueryContextMenu(HMENU hMenu,
                             UINT indexMenu,
                             UINT idCmdFirst,
                             UINT /*idCmdLast*/,
                             UINT uFlags)
{
    HRESULT hr = ResultFromShort(0);
    STGMEDIUM medium = {0};
    FORMATETC fe = { g_cfShellIDList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    if (uFlags & (CMF_DEFAULTONLY | CMF_VERBSONLY))
        return hr;

    TraceEnter(TRACE_RSHX32, "CRShellExt::QueryContextMenu");

    // Get the ID List data
    hr = m_lpdobj->GetData(&fe, &medium);
    if (SUCCEEDED(hr))
    {
        LPIDA pIDA = (LPIDA)GlobalLock(medium.hGlobal);
        TraceAssert(pIDA != NULL);

        // Only support single selection
        if (pIDA->cidl == 1)
        {
            if (S_OK == DoSecurityCheck(pIDA))
            {
                TCHAR szSecurity[32];
                if (LoadString(g_hInstance, IDS_SECURITY_MENU, szSecurity, ARRAYSIZE(szSecurity)))
                {
                    MENUITEMINFO mii;
                    mii.cbSize = sizeof(mii);
                    mii.fMask = MIIM_TYPE | MIIM_ID;
                    mii.fType = MFT_STRING;
                    mii.wID = idCmdFirst;
                    mii.dwTypeData = szSecurity;
                    mii.cch = lstrlen(szSecurity);

                    InsertMenuItem(hMenu, indexMenu, TRUE /*fByPosition*/, &mii);

                    hr = ResultFromShort(1);    // Return number of items we added
                }
            }
        }
        GlobalUnlock(medium.hGlobal);
        ReleaseStgMedium(&medium);
    }

    TraceLeaveResult(hr);
}

//
//  FUNCTION: IContextMenu::InvokeCommand(LPCMINVOKECOMMANDINFO)
//
//  PURPOSE: Called by the shell after the user has selected on of the
//           menu items that was added in QueryContextMenu().
//
//  PARAMETERS:
//    lpcmi - Pointer to an CMINVOKECOMMANDINFO structure
//
//  RETURN VALUE:
//    HRESULT signifying success or failure.
//
//  COMMENTS:
//

STDMETHODIMP
CRShellExt::InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi)
{
    HRESULT hr = S_OK;
    STGMEDIUM medium;
    FORMATETC fe = { g_cfShellIDList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    // Don't support named verbs
    if (HIWORD(lpcmi->lpVerb))
        return E_NOTIMPL;

    TraceEnter(TRACE_RSHX32, "CRShellExt::InvokeCommand");

    // We only have one command, so we should get zero here
    TraceAssert(LOWORD(lpcmi->lpVerb) == 0);

    // This must be true for us to have added the command to the menu
    TraceAssert(S_OK == m_hrSecurityCheck);

    //
    // Call ShellExecuteEx to execute the "Properties" verb on this object, and
    // tell it to select the security property page.
    //

    // Get the ID List data
    hr = m_lpdobj->GetData(&fe, &medium);

    if (SUCCEEDED(hr))
    {
        LPIDA pIDA = (LPIDA)GlobalLock(medium.hGlobal);
        LPITEMIDLIST pidl;

        // We only support single selection for context menus
        TraceAssert(pIDA && pIDA->cidl == 1);

        // Build a fully qualified ID List for this object
        pidl = ILCombine((LPCITEMIDLIST)ByteOffset(pIDA, pIDA->aoffset[0]),
                         (LPCITEMIDLIST)ByteOffset(pIDA, pIDA->aoffset[1]));

        if (pidl != NULL)
        {
            TCHAR szTitle[64];
            SHELLEXECUTEINFO sei =
            {
                sizeof(SHELLEXECUTEINFO),
                (lpcmi->fMask  & (SEE_MASK_HOTKEY | SEE_MASK_ICON)) | SEE_MASK_INVOKEIDLIST,
                lpcmi->hwnd,
                c_szProperties,     // lpVerb ("Properties")
                NULL,               // lpFile
                szTitle,            // lpParameters ("Security")
                NULL,               // lpDirectory,
                lpcmi->nShow,       // nShow
                NULL,               // hInstApp
                (LPVOID)pidl,       // lpIDList
                NULL,               // lpClass
                NULL,               // hkeyClass
                lpcmi->dwHotKey,    // dwHotKey
                lpcmi->hIcon,       // hIcon
                NULL                // hProcess
            };

            LoadString(g_hInstance, IDS_PROPPAGE_TITLE, szTitle, ARRAYSIZE(szTitle));

            // Put up the properties dialog
            if (!ShellExecuteEx(&sei))
            {
                DWORD dwErr = GetLastError();
                hr = HRESULT_FROM_WIN32(dwErr);
            }

            ILFree(pidl);
        }

        GlobalUnlock(medium.hGlobal);
        ReleaseStgMedium(&medium);
    }

#if 0
    //
    // SHObjectProperties builds a pidl to the object and then calls
    // ShellExecuteEx.  Similar to above, but it does more work to obtain the
    // ID lists (which we already have).
    //
    SHObjectProperties(lpcmi->hwnd,
                       m_seType == SE_PRINTER ? SHOP_PRINTERNAME : SHOP_FILEPATH,
                       m_pszObject,
                       TEXT("Security"));
#endif

    TraceLeaveResult(hr);
}

//
//  FUNCTION: IContextMenu::GetCommandString(UINT, UINT, UINT, LPSTR, UINT)
//
//  PURPOSE: Called by the shell after the user has selected on of the
//           menu items that was added in QueryContextMenu().
//
//  PARAMETERS:
//    lpcmi - Pointer to an CMINVOKECOMMANDINFO structure
//
//  RETURN VALUE:
//    HRESULT signifying success or failure.
//
//  COMMENTS:
//
STDMETHODIMP
CRShellExt::GetCommandString(UINT_PTR /*idCmd*/,
                             UINT uFlags,
                             LPUINT /*reserved*/,
                             LPSTR pszName,
                             UINT cchMax)
{
    if (uFlags == GCS_HELPTEXT)
    {
        LoadString(g_hInstance, IDS_SECURITY_HELPSTRING, (LPTSTR)pszName, cchMax);
        return S_OK;
    }

    // Must be some other flag that we don't handle
    return E_NOTIMPL;
}


//
//  FUNCTION: CRShellExt::DoSecurityCheck(LPIDA)
//
//  PURPOSE: Helper function called by the Property Sheet and Context Menu
//           extension code.  Used to determine whether to add the menu item
//           or property sheet.
//
//  PARAMETERS:
//      pIDA - pointer to ID List Array specifying selected objects
//
//  RETURN VALUE: none
//
//  COMMENTS:
//      The results are stored in m_hrSecurityCheck, m_dwSIFlags, m_pszServer, and m_pszObject
//
STDMETHODIMP CRShellExt::DoSecurityCheck(LPIDA pIDA)
{
    if (((HRESULT)-1) == m_hrSecurityCheck)
    {
        if (m_seType == SE_PRINTER && IsAddPrinterWizard())
            m_hrSecurityCheck = HRESULT_FROM_WIN32(ERROR_NO_SECURITY_ON_OBJECT);
        else
            m_hrSecurityCheck = CheckForSecurity(pIDA);
    }
    return m_hrSecurityCheck;
}

//
//  PURPOSE: Helper function called by CRShellExt::DoSecurityCheck
//
//  PARAMETERS: pIDA - pointer to ID List array
//
//  RETURN VALUE: HRESULT - S_OK if ACL editing can proceed
//
//  COMMENTS:
//      The results are stored in m_dwSIFlags, m_pszServer, and m_pszObject
//
STDMETHODIMP CRShellExt::CheckForSecurity(LPIDA pIDA)
{
    HRESULT hr;
    TCHAR szServer[MAX_PATH];
    LPTSTR pszItem = NULL;
    //    LPTSTR pszAlternate = NULL;
    DWORD dwFlags = 0;
    UINT cItems;
    IShellFolder2 * psf = NULL;
    LPCITEMIDLIST pidl;
    DWORD dwAttr;
    DWORD dwPrivs[] = { SE_SECURITY_PRIVILEGE, SE_TAKE_OWNERSHIP_PRIVILEGE };
    HANDLE hToken = INVALID_HANDLE_VALUE;
    ACCESS_MASK dwAccess = 0;
    UINT i;
    
    TraceEnter(TRACE_RSHX32, "CRShellExt::CheckForSecurity");
    TraceAssert(m_pszServer == NULL);   // Shouldn't get called twice
    TraceAssert(pIDA != NULL);
    
    szServer[0] = TEXT('\0');
    
    cItems = pIDA->cidl;
    TraceAssert(cItems >= 1);
    
    //We don't show effective perm page for multiple selection
    if (cItems > 1)
        m_dwSIFlags &= ~SI_EDIT_EFFECTIVE;
    
    IShellFolder2 *psfRoot = NULL;
    LPCITEMIDLIST pidlFolder = (LPCITEMIDLIST)ByteOffset(pIDA, pIDA->aoffset[0]);
    hr = BindToObjectEx(NULL, pidlFolder, NULL, IID_PPV_ARG(IShellFolder2, &psfRoot));
    FailGracefully(hr, "Unable to bind to folder");
    TraceAssert(psfRoot);
    
    
    // Create list for item paths
    TraceAssert(NULL == m_hItemList);
    m_hItemList = DPA_Create(4);
    if (NULL == m_hItemList)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to create DPA");
    
    //
    // Get the first item and see if it supports security
    //
    LPCITEMIDLIST pidlItem = (LPCITEMIDLIST)ByteOffset(pIDA, pIDA->aoffset[1]);
    hr = BindToFolderIDListParent(psfRoot, pidlItem, IID_PPV_ARG(IShellFolder2, &psf), &pidl);
    FailGracefully(hr, "Unable to get item name");
    
    hr = IDA_GetItemName(psf, pidl, &pszItem);
    FailGracefully(hr, "Unable to get item name");
    
    dwAttr = SFGAO_FOLDER | SFGAO_STREAM | SFGAO_FILESYSTEM;
    hr = psf->GetAttributesOf(1, &pidl, &dwAttr);
    FailGracefully(hr, "Unable to get item attributes");
    
    DoRelease(psf);
    
    //
    //If ACLUI is invoked for filesystem and object is not of filesystem
    //return E_FAIL
    //
    if ((m_seType == SE_FILE_OBJECT) && !(dwAttr & SFGAO_FILESYSTEM))
        ExitGracefully(hr, E_FAIL, "Not a filesystem object");
    
    // in the case that an item is both folder and stream, assume its a stream (.zip, .cab file)
    // and not a container
    if ((dwAttr & (SFGAO_FOLDER | SFGAO_STREAM)) == SFGAO_FOLDER)
        dwFlags |= DOBJ_RES_CONT;
    
    //
    // Check access on the first item only. If we can write the DACL
    // on the first one, we will try (later) to write to all items
    // in the selection and report any errors at that time.
    //
    hToken = EnablePrivileges(dwPrivs, ARRAYSIZE(dwPrivs));
    
    switch (m_seType)
    {
    case SE_FILE_OBJECT:
        GetFileInfo(pszItem, &dwFlags, szServer, ARRAYSIZE(szServer), NULL);
        if (dwFlags & DOBJ_VOL_NTACLS)
            hr = CheckFileAccess(pszItem, &dwAccess);
        else
            hr = HRESULT_FROM_WIN32(ERROR_NO_SECURITY_ON_OBJECT);
        break;
        
    case SE_PRINTER:
        // Printers are containers (they contain documents)
        // and they don't have a parent (for acl editing purposes)
        dwFlags = DOBJ_RES_CONT | DOBJ_RES_ROOT;
        hr = CheckPrinterAccess(pszItem, &dwAccess, szServer, ARRAYSIZE(szServer));
        break;
        
    default:
        hr = E_UNEXPECTED;
    }
    FailGracefully(hr, "No access");
    
    // If we can't do anything security related, don't continue.
    if (!(dwAccess & ALL_SECURITY_ACCESS))
        ExitGracefully(hr, E_ACCESSDENIED, "No access");
    
    // Remember the server name
    if (TEXT('\0') != szServer[0])
    {
        hr = LocalAllocString(&m_pszServer, szServer);
        FailGracefully(hr, "LocalAlloc failed");
    }
    
    // Remember the item path
    DPA_AppendPtr(m_hItemList, pszItem);
    pszItem = NULL;
    
    if (!(dwAccess & WRITE_DAC))
        m_dwSIFlags |= SI_READONLY;
    
    if (!(dwAccess & WRITE_OWNER))
    {
        if (!(dwAccess & READ_CONTROL))
            m_dwSIFlags &= ~SI_EDIT_OWNER;
        else
            m_dwSIFlags |= SI_OWNER_READONLY;
    }
    
    if (!(dwAccess & ACCESS_SYSTEM_SECURITY))
        m_dwSIFlags &= ~SI_EDIT_AUDITS;
    
    //
    // Check the rest of the selection.  If any part of a multiple
    // selection doesn't support ACLs or the selection isn't homogenous,
    // then we can't create the security page.
    //
    for (i = 2; i <= cItems; i++)
    {
        DWORD dw = 0;
        
        // We only do multiple selections for files
        TraceAssert(SE_FILE_OBJECT == m_seType);
        LPCITEMIDLIST pidlItem = (LPCITEMIDLIST)ByteOffset(pIDA, pIDA->aoffset[i]);
        hr = BindToFolderIDListParent(psfRoot, pidlItem, IID_PPV_ARG(IShellFolder2, &psf), &pidl);
        FailGracefully(hr, "Unable to get item name");
        
        hr = IDA_GetItemName(psf, pidl, &pszItem);
        FailGracefully(hr, "Unable to get item name");
        
        dwAttr = SFGAO_FOLDER | SFGAO_STREAM | SFGAO_FILESYSTEM;
        hr = psf->GetAttributesOf(1, &pidl, &dwAttr);
        FailGracefully(hr, "Unable to get item attributes");
        
        DoRelease(psf);
        //
        //If ACLUI is invoked for filesystem and object is not of filesystem
        //return E_FAIL
        //
        if ((m_seType == SE_FILE_OBJECT) && !(dwAttr & SFGAO_FILESYSTEM))
            ExitGracefully(hr, E_FAIL, "Not a filesystem object");
        
        if ((dwAttr & (SFGAO_FOLDER | SFGAO_STREAM)) == SFGAO_FOLDER)
            dw |= DOBJ_RES_CONT;
        
        if ((dw & DOBJ_RES_CONT) != (dwFlags & DOBJ_RES_CONT))
            ExitGracefully(hr, E_FAIL, "Incompatible multiple selection");
        
        GetFileInfo(pszItem, &dw, szServer, ARRAYSIZE(szServer), NULL);
        
        // Compare against first item.  All flags and the server name
        // must match, otherwise we can't edit the ACLs.
        if (dw == dwFlags &&
            ((NULL == m_pszServer && TEXT('\0') == szServer[0]) ||
            (NULL != m_pszServer && 0 == lstrcmpi(m_pszServer, szServer))))
        {
            // Remember the item path
            DPA_AppendPtr(m_hItemList, pszItem);
            pszItem = NULL;
        }
        else
            ExitGracefully(hr, E_FAIL, "Incompatible multiple selection");
    }
    
    //
    // If everything has succeeded up to this point, save some flags
    // and the server and object name strings
    //
    if (dwFlags & DOBJ_RES_CONT)
        m_dwSIFlags |= SI_CONTAINER;
    
    //
    // For Root objects (e.g. "D:\") hide the ACL Protection checkbox,
    // since these objects don't appear to have parents.
    //
    if (dwFlags & DOBJ_RES_ROOT)
        m_dwSIFlags |= SI_NO_ACL_PROTECT;
    
    // Get the "Normal" display name to use as the object name
    hr = IDA_GetItemName(psfRoot, (LPCITEMIDLIST)ByteOffset(pIDA, pIDA->aoffset[1]),
        szServer, ARRAYSIZE(szServer), SHGDN_NORMAL);
    FailGracefully(hr, "Unable to get item name");
    if (cItems > 1)
    {
        int nLength = lstrlen(szServer);
        LoadString(g_hInstance, IDS_MULTISEL_ELLIPSIS, szServer + nLength, ARRAYSIZE(szServer) - nLength);
    }
    hr = LocalAllocString(&m_pszObject, szServer);
    
exit_gracefully:
    
    ReleasePrivileges(hToken);
    
    DoRelease(psf);
    DoRelease(psfRoot);
    
    LocalFreeString(&pszItem);
    
    TraceLeaveResult(hr);
}


//
//  FUNCTION: CRShellExt::CreateSI(LPSECURITYINFO *)
//
//  PURPOSE: Create a SecurityInformation object of the correct type
//
//  PARAMETERS: ppsi - Location to store ISecurityInformation pointer
//
//  RETURN VALUE: HRESULT signifying success or failure
//
//  COMMENTS:
//
STDMETHODIMP
CRShellExt::CreateSI(LPSECURITYINFO *ppsi)
{
    HRESULT hr;
    CSecurityInformation *psi;

    TraceEnter(TRACE_RSHX32, "CRShellExt::CreateSI");
    TraceAssert(ppsi != NULL);

    *ppsi = NULL;

    switch (m_seType)
    {
    case SE_FILE_OBJECT:
        psi = new CNTFSSecurity(m_seType);  // ref == 1
        break;

    case SE_PRINTER:
        psi = new CPrintSecurity(m_seType); // ref == 1
        break;

    default:
        TraceLeaveResult(E_UNEXPECTED);
    }

    if (psi == NULL)
        TraceLeaveResult(E_OUTOFMEMORY);

    hr = psi->Initialize(m_hItemList,
                         m_dwSIFlags,
                         m_pszServer,
                         m_pszObject);
    if (SUCCEEDED(hr))
    {
        *ppsi = psi;

        // The SecurityInfo object takes responsibility for these
        m_hItemList = NULL;
        m_pszServer = NULL;
        m_pszObject = NULL;
        m_hrSecurityCheck = (HRESULT)-1;
    }
    else
        psi->Release();

    TraceLeaveResult(hr);
}

typedef HPROPSHEETPAGE (WINAPI *PFN_CREATESECPAGE)(LPSECURITYINFO);

HPROPSHEETPAGE _CreateSecurityPage(LPSECURITYINFO psi)
{
    HPROPSHEETPAGE hPage = NULL;
    const TCHAR szAclui[] = TEXT("aclui.dll");
    const char szCreateSecPage[] = "CreateSecurityPage";

    if (!g_hAclui)
        g_hAclui = LoadLibrary(szAclui);

    if (g_hAclui)
    {
        static PFN_CREATESECPAGE s_pfnCreateSecPage = NULL;

        if (!s_pfnCreateSecPage)
            s_pfnCreateSecPage = (PFN_CREATESECPAGE)GetProcAddress(g_hAclui, szCreateSecPage);

        if (s_pfnCreateSecPage)
            hPage = (*s_pfnCreateSecPage)(psi);
    }

    return hPage;
}

STDMETHODIMP
CRShellExt::AddSecurityPage(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    HRESULT hr;
    LPSECURITYINFO psi;

    hr = CreateSI(&psi);            // ref == 1

    if (SUCCEEDED(hr))
    {
        HPROPSHEETPAGE hPermPage = _CreateSecurityPage(psi);

        if (hPermPage)
        {
            if (!lpfnAddPage(hPermPage, lParam))
                DestroyPropertySheetPage(hPermPage);
        }
        else
        {
            DWORD dwErr = GetLastError();
            hr = HRESULT_FROM_WIN32(dwErr);
        }

        psi->Release();             // release initial ref
    }
    return hr;
}

//
//  PURPOSE: Check for the Add Printer wizard
//
//  PARAMETERS: none
//
//  RETURN VALUE: TRUE if the selected object is the Add Printer wizard,
//                FALSE otherwise
//
//  COMMENTS:
//
BOOL CRShellExt::IsAddPrinterWizard() const
{
    BOOL bRetval = FALSE;
    STGMEDIUM medium;
    FORMATETC fe = { g_cfPrinterGroup, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    TCHAR szFile[MAX_PATH];

    TraceEnter(TRACE_RSHX32, "CRShellExt::IsAddPrinterWizard");
    TraceAssert(m_seType == SE_PRINTER);

    //
    // Fail the call if m_lpdobj is NULL.
    //
    if ( m_lpdobj && SUCCEEDED( m_lpdobj->GetData( &fe, &medium ) ) )
    {
#if (_WIN32_WINNT < 0x0500)
        //
        // In NT 4.0 the printer context menus in the shell failed
        // to handle UNICODE strings properly during a call to DragQueryFile.
        // The strings returned were always ANSI.  This has been fixed
        // in build 1393 and greater.
        //
#ifdef UNICODE
        LPDROPFILES pdf = (LPDROPFILES)GlobalLock(medium.hGlobal);
        pdf->fWide = TRUE;
        GlobalUnlock(medium.hGlobal);
#endif
#endif
        //
        // Get the selected item name.
        //
        if ( DragQueryFile( (HDROP)medium.hGlobal, 0, szFile, ARRAYSIZE( szFile ) ) )
        {
            //
            // Check if this is the magic Add Printer Wizard shell object.
            // The check is not case sensitive and the string is not localized.
            //
            if ( 0 == lstrcmpi( szFile, TEXT("WinUtils_NewObject") ) )
            {
                TraceMsg("Found Add Printer wizard");
                bRetval = TRUE;
            }
        }

        //
        // Release the storage medium.
        //
        ReleaseStgMedium( &medium );
    }

    TraceLeaveValue(bRetval);
}


#if (_WIN32_WINNT >= 0x0500)
//
//  FUNCTION: CRShellExt::AddMountedVolumePage()
//
//  PURPOSE: Create Security page for mounted volume properties
//
//  PARAMETERS: lpfnAddPage - pointer to function called to add a page.
//              lParam      - lParam parameter to be passed to lpfnAddPage.
//
//  RETURN VALUE: HRESULT signifying success or failure
//
//  COMMENTS:
//
STDMETHODIMP
CRShellExt::AddMountedVolumePage(LPFNADDPROPSHEETPAGE lpfnAddPage,
                                 LPARAM               lParam)
{
    HRESULT hr = S_OK;
    STGMEDIUM medium = {0};
    FORMATETC fe = { g_cfMountedVolume, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    TCHAR szMountPoint[MAX_PATH];
    TCHAR szVolumeID[MAX_PATH];
    TCHAR szLabel[64];
    LPTSTR pszVolID = NULL;
    DWORD dwVolFlags = 0;
    DWORD dwPrivs[] = { SE_SECURITY_PRIVILEGE, SE_TAKE_OWNERSHIP_PRIVILEGE };
    HANDLE hToken = INVALID_HANDLE_VALUE;
    ACCESS_MASK dwAccess = 0;
    BOOL bHasSecurity = FALSE;

    TraceEnter(TRACE_RSHX32, "CRShellExt::AddMountedVolumePage");
    TraceAssert(m_seType == SE_FILE_OBJECT);
    TraceAssert(m_lpdobj);

    // Try to get the mounted volume host folder path
    hr = m_lpdobj->GetData(&fe, &medium);
    FailGracefully(hr, "Not a mounted volume");

    // Get the host folder path
    if (!DragQueryFile((HDROP)medium.hGlobal, 0, szMountPoint, ARRAYSIZE(szMountPoint)))
        ExitGracefully(hr, E_FAIL, "Can't get mount point from storage medium");

    PathAddBackslash(szMountPoint);

    // Get the volume ID, which looks like
    // "\\?\Volume{9e2df3f5-c7f1-11d1-84d5-000000000000}\"
    if (!GetVolumeNameForVolumeMountPoint(szMountPoint, szVolumeID, ARRAYSIZE(szVolumeID)))
        ExitGracefully(hr, E_FAIL, "GetVolumeNameForVolumeMountPoint failed");

    if (GetVolumeInformation(szMountPoint, //szVolumeID,
                             szLabel,
                             ARRAYSIZE(szLabel),
                             NULL,
                             NULL,
                             &dwVolFlags,
                             NULL,
                             0))
    {
        if (dwVolFlags & FS_PERSISTENT_ACLS)
        {
            bHasSecurity = TRUE;
        }
    }
    else if (GetLastError() == ERROR_ACCESS_DENIED)
    {
        // If we can't get the volume information because we don't have
        // access, then there must be security!
        bHasSecurity = TRUE;
    }

    if (!bHasSecurity)
        ExitGracefully(hr, E_FAIL, "Volume inaccessible or not NTFS");

    hToken = EnablePrivileges(dwPrivs, ARRAYSIZE(dwPrivs));

    hr = CheckFileAccess(szVolumeID, &dwAccess);
    FailGracefully(hr, "Volume inaccessible");

    // If we can't do anything security related, don't continue.
    if (!(dwAccess & ALL_SECURITY_ACCESS))
        ExitGracefully(hr, E_ACCESSDENIED, "No security access");

    if (!(dwAccess & WRITE_DAC))
        m_dwSIFlags |= SI_READONLY;

    if (!(dwAccess & WRITE_OWNER))
    {
        if (!(dwAccess & READ_CONTROL))
            m_dwSIFlags &= ~SI_EDIT_OWNER;
        else
            m_dwSIFlags |= SI_OWNER_READONLY;
    }

    if (!(dwAccess & ACCESS_SYSTEM_SECURITY))
        m_dwSIFlags &= ~SI_EDIT_AUDITS;

    m_dwSIFlags |= SI_CONTAINER | SI_NO_ACL_PROTECT;



    if (!FormatStringID(&m_pszObject,
                        g_hInstance,
                        IDS_FMT_VOLUME_DISPLAY,
                        szLabel,
                        szMountPoint))
    {
        LocalAllocString(&m_pszObject, szLabel);
    }

    if (!m_pszObject)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to build volume display string");

    m_hItemList = DPA_Create(1);
    if (!m_hItemList)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to create item list");

    hr = LocalAllocString(&pszVolID, szVolumeID);
    FailGracefully(hr, "Unable to copy volume ID string");

    DPA_AppendPtr(m_hItemList, pszVolID);
    pszVolID = NULL;

    hr = AddSecurityPage(lpfnAddPage, lParam);

exit_gracefully:

    ReleasePrivileges(hToken);
    LocalFreeString(&pszVolID);
    ReleaseStgMedium(&medium);
    TraceLeaveResult(hr);
}
#endif  // _WIN32_WINNT >= 0x0500


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Miscellaneous helper functions                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


#if (_WIN32_WINNT < 0x0500)

#undef PathIsUNC
STDAPI_(BOOL)
PathIsUNC(LPCTSTR psz)
{
    return (psz && psz[0] == TEXT('\\') && psz[1] == TEXT('\\'));
}

static const TCHAR c_szColonSlash[] = TEXT(":\\");

#undef PathIsRoot
STDAPI_(BOOL)
PathIsRoot(LPCTSTR pPath)
{
    return (pPath && !lstrcmpi(pPath + 1, c_szColonSlash));
}

#endif // #if (_WIN32_WINNT < 0x0500)

BOOL
IsDfsPath(LPTSTR pszPath,       // in
          LPTSTR pszServer,     // out
          UINT   cchServer,     // in
          LPTSTR pszAltPath)    // out
{
    BOOL bIsDfs = FALSE;
    WCHAR szPath[MAX_PATH];
    PDFS_INFO_3 pDI3 = NULL;
    WCHAR szServer[MAX_PATH];
    WCHAR szStorage[MAX_PATH];

    USES_CONVERSION;

    if (!PathIsUNC(pszPath))
        return FALSE;     // local machine

    lstrcpynW(szPath, T2CW(pszPath), ARRAYSIZE(szPath));

    // Check for DFS
    for (;;)
    {
        DWORD dwErr;

        __try
        {
            // This is delay-loaded by the linker, so
            // must wrap with an exception handler.
            dwErr = NetDfsGetClientInfo(szPath,
                                        NULL,
                                        NULL,
                                        3,
                                        (LPBYTE*)&pDI3);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return FALSE;
        }

        if (NERR_Success == dwErr)
        {
            for (ULONG i = 0; i < pDI3->NumberOfStorages; i++)
            {
                if (DFS_STORAGE_STATE_ONLINE & pDI3->Storage[i].State)
                {
                    bIsDfs = TRUE;

                    szServer[0] = L'\\';
                    szServer[1] = L'\\';
                    lstrcpynW(&szServer[2], pDI3->Storage[i].ServerName, ARRAYSIZE(szServer)-2);
                    lstrcpynW(szStorage, szServer, ARRAYSIZE(szStorage));
                    PathAppendW(szStorage, pDI3->Storage[i].ShareName);

                    // If this server is active, quit looking
                    if (DFS_STORAGE_STATE_ACTIVE & pDI3->Storage[i].State)
                        break;
                }
            }
            break;
        }
        else if (NERR_DfsNoSuchVolume == dwErr)
        {
            // If we're at the root, then we can't go any farther.
            if (PathIsRoot(szPath))
                break;

            // Remove the last path element and try again, if nothing is 
			//removed, break, don't go in infinite loop
            if (!PathRemoveFileSpec(szPath))
				break;
        }
        else
        {
            // Some other error, bail
            break;
        }
    }

    if (bIsDfs)
    {
        lstrcpyn(pszServer, W2T(szServer), cchServer);

        // Note that EntryPath has only a single leading backslash, hence +1
        LPCTSTR pszEnd = pszPath + lstrlen(pDI3->EntryPath) + 1;
        while (TEXT('\\') == *pszEnd)
            pszEnd++;

        PathCombine(pszAltPath, szStorage, pszEnd);
    }

    if (NULL != pDI3)
        NetApiBufferFree(pDI3);

    return bIsDfs;
}


void
GetVolumeInfo(LPCTSTR pszPath,
              BOOL    bIsFolder,
              LPDWORD pdwFlags,
              LPTSTR  pszVolume,
              ULONG   cchVolume)
{
    TCHAR szVolume[MAX_PATH];
    TCHAR szVolumeID[MAX_PATH];

    //
    // The path can be DFS or contain volume mount points, so start
    // with the full path and try GetVolumeInformation on successively
    // shorter paths until it succeeds or we run out of path.
    //
    // However, if it's a volume mount point, we're interested in the
    // the host folder's volume so back up one level to start.  The
    // child volume is handled separately (see AddMountedVolumePage).
    //

    lstrcpyn(szVolume, pszPath, ARRAYSIZE(szVolume));

    if (!bIsFolder
        || GetVolumeNameForVolumeMountPoint(szVolume, szVolumeID, ARRAYSIZE(szVolumeID)))
    {
        PathRemoveFileSpec(szVolume);
    }

    for (;;)
    {
        PathAddBackslash(szVolume); // GetVolumeInformation likes a trailing '\'

        if (GetVolumeInformation(szVolume,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 pdwFlags,
                                 NULL,
                                 0))
        {
            break;
        }

        // Access denied implies that we've reached the deepest volume
        // in the path; we just can't get the flags.  It also implies
        // security, so assume persistent acls.
        if (ERROR_ACCESS_DENIED == GetLastError())
        {
            *pdwFlags = FS_PERSISTENT_ACLS;
            break;
        }

        // If we're at the root, then we can't go any farther.
        if (PathIsRoot(szVolume))
            break;

        // Remove the last path element and try again
        PathRemoveBackslash(szVolume);
		//if nothing is removed break instead of going in infinite loop
        if (!PathRemoveFileSpec(szVolume))
			break;
    }

    if (pszVolume)
    {
        PathRemoveBackslash(szVolume);
        lstrcpyn(pszVolume, szVolume, cchVolume);
    }
}


void
GetFileInfo(LPCTSTR pszPath,
            LPDWORD pdwFileType,
            LPTSTR  pszServer,
            ULONG   cchServer,
            LPTSTR *ppszAlternatePath)
{
    DWORD dwVolumeFlags = 0;
    TCHAR szVolume[MAX_PATH];
    LPTSTR pszUNC = NULL;

    TraceEnter(TRACE_RSHX32, "GetFileInfo");
    TraceAssert(NULL != pszServer);

    pszServer[0] = TEXT('\0');

    if (ppszAlternatePath)
        *ppszAlternatePath = NULL;

    if (!PathIsUNC(pszPath) && S_OK == GetRemotePath(pszPath, &pszUNC))
        pszPath = pszUNC;

    if (PathIsRoot(pszPath))
        *pdwFileType |= DOBJ_RES_ROOT;

    GetVolumeInfo(pszPath,
                  *pdwFileType & DOBJ_RES_CONT,
                  &dwVolumeFlags,
                  szVolume,
                  ARRAYSIZE(szVolume));
    if (dwVolumeFlags & FS_PERSISTENT_ACLS)
    {
        TCHAR szAltVolume[MAX_PATH];

        *pdwFileType |= DOBJ_VOL_NTACLS;

        if (IsDfsPath(szVolume, pszServer, cchServer, szAltVolume))
        {
            if (ppszAlternatePath)
            {
                LPCTSTR pszEnd = pszPath + lstrlen(szVolume);
                while (TEXT('\\') == *pszEnd)
                    pszEnd++;

                *ppszAlternatePath = (LPTSTR)LocalAlloc(LPTR, StringByteSize(szAltVolume)
                                                            + StringByteSize(pszEnd));
                if (*ppszAlternatePath)
                {
                    // PathCombine asserts that the buffer is at least MAX_PATH,
                    // so don't use it here.  We know the buffer is big enough.
                    lstrcpy(*ppszAlternatePath, szAltVolume);
                    LPTSTR pszT = PathAddBackslash(*ppszAlternatePath);
                    if (pszT)
                        lstrcpy(pszT, pszEnd);
                    //PathCombine(*ppszAlternatePath, szAltVolume, pszEnd);
                }
            }
        }
        else if (PathIsUNC(szVolume))
        {
            LPTSTR pSlash = StrChr(&szVolume[2], TEXT('\\'));
            if (pSlash)
                cchServer = min(cchServer, (ULONG)(pSlash - szVolume) + 1);
            lstrcpyn(pszServer, szVolume, cchServer);
        }
    }

    LocalFreeString(&pszUNC);

    TraceLeaveVoid();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\rshx32\si.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       si.h
//
//  This file contains the definition of the CSecurityInformation
//  base class.
//
//--------------------------------------------------------------------------

#ifndef _SI_H_
#define _SI_H_

class CSecurityInformation : public ISecurityInformation, IEffectivePermission, ISecurityObjectTypeInfo
{
protected:
    ULONG           m_cRef;
    SE_OBJECT_TYPE  m_seType;
    HDPA            m_hItemList;
    DWORD           m_dwSIFlags;
    LPTSTR          m_pszServerName;
    LPTSTR          m_pszObjectName;
    HWND            m_hwndOwner;
    AUTHZ_RESOURCE_MANAGER_HANDLE m_ResourceManager;    //Used for access check
    BOOL            m_bIsStandAlone;

public:
    CSecurityInformation(SE_OBJECT_TYPE seType);
    virtual ~CSecurityInformation();

    STDMETHOD(Initialize)(HDPA   hItemList,
                          DWORD  dwFlags,
                          LPTSTR pszServer,
                          LPTSTR pszObject);

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID, LPVOID *);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    
    // ISecurityInformation methods
    STDMETHOD(GetObjectInformation)(PSI_OBJECT_INFO pObjectInfo);
    STDMETHOD(GetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault);
    STDMETHOD(SetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD);
    STDMETHOD(GetAccessRights)(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess) PURE;
    STDMETHOD(MapGeneric)(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask) PURE;
    STDMETHOD(GetInheritTypes)(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes) PURE;
    STDMETHOD(PropertySheetPageCallback)(HWND hwnd,
                                         UINT uMsg,
                                         SI_PAGE_TYPE uPage);

    STDMETHOD(GetEffectivePermission) (  const GUID* pguidObjectType,
                                         PSID pUserSid,
                                         LPCWSTR pszServerName,
                                         PSECURITY_DESCRIPTOR pSD,
                                         POBJECT_TYPE_LIST *ppObjectTypeList,
                                         ULONG *pcObjectTypeListLength,
                                         PACCESS_MASK *ppGrantedAccessList,
                                         ULONG *pcGrantedAccessListLength);

    STDMETHOD(GetInheritSource)(SECURITY_INFORMATION si,
                                PACL pACL, 
                                PINHERITED_FROM *ppInheritArray) PURE;


protected:
    STDMETHOD(ReadObjectSecurity)(LPCTSTR pszObject,
                                  SECURITY_INFORMATION si,
                                  PSECURITY_DESCRIPTOR *ppSD);
    STDMETHOD(WriteObjectSecurity)(LPCTSTR pszObject,
                                   SECURITY_INFORMATION si,
                                   PSECURITY_DESCRIPTOR pSD);

    AUTHZ_RESOURCE_MANAGER_HANDLE GetAUTHZ_RM(){ return m_ResourceManager; }

    BOOL IsFile(){ return !(m_dwSIFlags & SI_CONTAINER); }
};

#endif  /* _SI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\rshx32\sources.inc ===
TARGETNAME=rshx32
TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLENTRY=DllMain
DLLDEF=$(O)\$(TARGETNAME).def

INCLUDES=..;..\..\inc;$(BASE_INC_PATH);$(QFE_INC_PATH)

DELAYLOAD=ole32.dll;shlwapi.dll;netapi32.dll;mpr.dll;winspool.drv

LINKLIBS=\
    ..\..\common\winnt\$(O)\common.lib     \

TARGETLIBS=\
    $(SDK_LIB_PATH)\kernel32.lib    \
    $(SDK_LIB_PATH)\user32.lib      \
    $(SDK_LIB_PATH)\ole32.lib       \
    $(SHELL_LIB_PATH)\comctlp.lib   \
    $(SDK_LIB_PATH)\shell32.lib     \
    $(SHELL_LIB_PATH)\shell32p.lib  \
    $(SHELL_LIB_PATH)\shlwapip.lib  \
    $(SDK_LIB_PATH)\shlwapi.lib     \
    $(SDK_LIB_PATH)\advapi32.lib    \
    $(SDK_LIB_PATH)\winspool.lib    \
    $(SDK_LIB_PATH)\netapi32.lib    \
    $(SDK_LIB_PATH)\mpr.lib         \
    $(SDK_LIB_PATH)\uuid.lib        \
    $(SDK_LIB_PATH)\authz.lib        \

SOURCES=\
     ..\rshx32.rc       \
     ..\rshx32.cpp      \
     ..\cstrings.cpp    \
     ..\si.cpp          \
     ..\ntfssi.cpp      \
     ..\printsi.cpp     \
     ..\util.cpp        \

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\rshx32.h
PRECOMPILED_PCH=pch.pch
PRECOMPILED_OBJ=pch.obj

MISCFILES=..\rshx32{377911D2-245E-4c93-82F4-7B023EC6BCC4}.sld
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\rshx32\util.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       util.cpp
//
//  This file contains misc functions.
//
//--------------------------------------------------------------------------

#include "rshx32.h"
#include <shlobjp.h>    // SHFree
#include <shlwapip.h>   // IsOS
#include <safeboot.h>   // SAFEBOOT_* flags
#undef IDC_STATIC
#include <xpsp1res.h>


STDMETHODIMP
IDA_BindToFolder(LPIDA pIDA, LPSHELLFOLDER *ppsf)
{
    HRESULT hr;
    LPSHELLFOLDER psfDesktop;

    TraceEnter(TRACE_UTIL, "IDA_BindToFolder");
    TraceAssert(pIDA != NULL);
    TraceAssert(ppsf != NULL);

    *ppsf = NULL;

    hr = SHGetDesktopFolder(&psfDesktop);
    if (SUCCEEDED(hr))
    {
        LPCITEMIDLIST pidlFolder = (LPCITEMIDLIST)ByteOffset(pIDA, pIDA->aoffset[0]);

        if (ILIsEmpty(pidlFolder))
        {
            // We're binding to the desktop
            *ppsf = psfDesktop;
        }
        else
        {
            hr = psfDesktop->BindToObject(pidlFolder,
                                          NULL,
                                          IID_IShellFolder,
                                          (PVOID*)ppsf);
            psfDesktop->Release();
        }
    }

    TraceLeaveResult(hr);
}


STDMETHODIMP
IDA_GetItemName(LPSHELLFOLDER psf,
                LPCITEMIDLIST pidl,
                LPTSTR pszName,
                UINT cchName,
                SHGNO uFlags)
{
    STRRET str;
    HRESULT hr;

    hr = psf->GetDisplayNameOf(pidl, uFlags, &str);

    if (SUCCEEDED(hr))
    {
        DWORD dwErr;
        LPSTR psz;

        switch (str.uType)
        {
        case STRRET_WSTR:
#ifdef UNICODE
            lstrcpyn(pszName, str.pOleStr, cchName);
#else   // !UNICODE
            if (!WideCharToMultiByte(CP_ACP,
                                     0,
                                     str.pOleStr,
                                     -1,
                                     pszName,
                                     cchName,
                                     NULL,
                                     NULL))
            {
                dwErr = GetLastError();
                hr = HRESULT_FROM_WIN32(dwErr);
            }
#endif  // !UNICODE

            //
            // Since this string was alocated from the shell's IMalloc heap,
            // we must free it to the same place.
            //
            SHFree(str.pOleStr);
            break;

        case STRRET_OFFSET:
            psz = (LPSTR)ByteOffset(pidl, str.uOffset);
            goto GetItemName_ANSI;

        case STRRET_CSTR:
            psz = str.cStr;
GetItemName_ANSI:
#ifdef UNICODE
            if (!MultiByteToWideChar(CP_ACP,
                                     0,
                                     psz,
                                     -1,
                                     pszName,
                                     cchName))
            {
                dwErr = GetLastError();
                hr = HRESULT_FROM_WIN32(dwErr);
            }
#else   // !UNICODE
            lstrcpyn(pszName, psz, cchName);
#endif  // !UNICODE
            break;

        default:
            hr = E_UNEXPECTED;
            break;
        }
    }

    return hr;
}


STDMETHODIMP
IDA_GetItemName(LPSHELLFOLDER psf,
                LPCITEMIDLIST pidl,
                LPTSTR *ppszName,
                SHGNO uFlags)
{
    TCHAR szName[MAX_PATH];
    HRESULT hr = IDA_GetItemName(psf, pidl, szName, ARRAYSIZE(szName));
    if (SUCCEEDED(hr))
        hr = LocalAllocString(ppszName, szName);
    else
        *ppszName = NULL;
    return hr;
}


//
// Helper functions used by DPA_CompareSecurityIntersection
//
BOOL
IsEqualSID(PSID pSid1, PSID pSid2)
{
    //
    // Are they both NULL?
    //
    if (pSid1 || pSid2)
    {
        //
        // At least one is non-NULL, so if one is NULL then they can't
        // be equal.
        //
        if (pSid1 == NULL || pSid2 == NULL)
            return FALSE;

        //
        // Both are non-NULL. Check the SIDs.
        //
        if (!EqualSid(pSid1, pSid2))
            return FALSE;
    }

    return TRUE;
}

BOOL
IsEqualACL(PACL pA1, PACL pA2)
{
    //
    // Are they both NULL?
    //
    if (pA1 || pA2)
    {
        //
        // At least one is non-NULL, so if one is NULL then they can't
        // be equal.
        //
        if (pA1 == NULL || pA2 == NULL)
            return FALSE;

        //
        // At this point we know that both are non-NULL.  Check the
        // sizes and contents.
        //
        // could do a lot more here
        if (pA1->AclSize != pA2->AclSize || memcmp(pA1, pA2, pA1->AclSize))
            return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CompareSecurityDescriptors
//
//  Synopsis:   Determines if 2 security descriptors are identical.  It does
//              this by comparing control fields, owner/group, and acls.
//
//  Arguments:  [IN]  pSD1         - 1st SD to compare
//              [IN]  pSD2         - 2nd SD to compare
//              [OUT] pfOwnerConflict - (optional) Set to TRUE if the Owner SIDs are not equal
//              [OUT] pfGroupConflict - (optional) Set to TRUE if the Group SIDs are not equal
//              [OUT] pfDACLConflict  - (optional) Set to TRUE if the DACLs are not equal
//              [OUT] pfSACLConflict  - (optional) Set to TRUE if the SACLs are not equal
//
//  Returns:    nothing
//
//
//----------------------------------------------------------------------------

#define DACL_CONTROL_MASK   (SE_DACL_PRESENT | SE_DACL_DEFAULTED | SE_DACL_AUTO_INHERITED | SE_DACL_PROTECTED)
#define SACL_CONTROL_MASK   (SE_SACL_PRESENT | SE_SACL_DEFAULTED | SE_SACL_AUTO_INHERITED | SE_SACL_PROTECTED)

void
CompareSecurityDescriptors(PSECURITY_DESCRIPTOR pSD1,
                           PSECURITY_DESCRIPTOR pSD2,
                           BOOL                *pfOwnerConflict,
                           BOOL                *pfGroupConflict,
                           BOOL                *pfSACLConflict,
                           BOOL                *pfDACLConflict)
{
    PISECURITY_DESCRIPTOR pS1 = (PISECURITY_DESCRIPTOR)pSD1;
    PISECURITY_DESCRIPTOR pS2 = (PISECURITY_DESCRIPTOR)pSD2;

    //
    // Are the pointers identical?
    // This includes the case where both are NULL.
    //
    if (pS1 == pS2)
    {
        if (pfOwnerConflict)
            *pfOwnerConflict = FALSE;
        if (pfGroupConflict)
            *pfGroupConflict = FALSE;
        if (pfSACLConflict)
            *pfSACLConflict = FALSE;
        if (pfDACLConflict)
            *pfDACLConflict = FALSE;
        return;
    }

    //
    // Is (only) one of them NULL?  If so, then we can't compare so
    // assume that nothing matches.
    //
    if (!pS1 || !pS2)
    {
        if (pfOwnerConflict)
            *pfOwnerConflict = TRUE;
        if (pfGroupConflict)
            *pfGroupConflict = TRUE;
        if (pfSACLConflict)
            *pfSACLConflict = TRUE;
        if (pfDACLConflict)
            *pfDACLConflict = TRUE;
        return;
    }

    //
    // Owner
    //
    if (pfOwnerConflict)
    {
        if ((pS1->Control & SE_OWNER_DEFAULTED) != (pS2->Control & SE_OWNER_DEFAULTED))
        {
            *pfOwnerConflict = TRUE;
        }
        else
        {
            *pfOwnerConflict = !IsEqualSID(RtlpOwnerAddrSecurityDescriptor(pS1),
                                           RtlpOwnerAddrSecurityDescriptor(pS2));
        }
    }

    //
    // Group
    //
    if (pfGroupConflict)
    {
        if ((pS1->Control & SE_GROUP_DEFAULTED) != (pS2->Control & SE_GROUP_DEFAULTED))
        {
            *pfGroupConflict = TRUE;
        }
        else
        {
            *pfGroupConflict = !IsEqualSID(RtlpGroupAddrSecurityDescriptor(pS1),
                                           RtlpGroupAddrSecurityDescriptor(pS2));
        }
    }

    //
    // Sacl
    //
    if (pfSACLConflict)
    {
        if ((pS1->Control & SACL_CONTROL_MASK) != (pS2->Control & SACL_CONTROL_MASK))
        {
            *pfSACLConflict = TRUE;
        }
        else
        {
            *pfSACLConflict = !IsEqualACL(RtlpSaclAddrSecurityDescriptor(pS1),
                                          RtlpSaclAddrSecurityDescriptor(pS2));
        }
    }

    //
    // Dacl
    //
    if (pfDACLConflict)
    {
        if ((pS1->Control & DACL_CONTROL_MASK) != (pS2->Control & DACL_CONTROL_MASK))
        {
            *pfDACLConflict = TRUE;
        }
        else
        {
            *pfDACLConflict = !IsEqualACL(RtlpDaclAddrSecurityDescriptor(pS1),
                                          RtlpDaclAddrSecurityDescriptor(pS2));
        }
    }
}


/*******************************************************************

    NAME:       DPA_CompareSecurityIntersection

    SYNOPSIS:   Determines if the selected objects have
                equivalent security descriptors

    ENTRY:      hItemList - DPA containing item names
                pfnReadSD - callback function to read the Security Descriptor
                                for a single item.
                pfOwnerConflict - (optional) Set to TRUE if not all Owner SIDs are equal
                pfGroupConflict - (optional) Set to TRUE if not all Group SIDs are equal
                pfDACLConflict  - (optional) Set to TRUE if not all DACLs are equal
                pfSACLConflict  - (optional) Set to TRUE if not all SACLs are equal
                ppszOwnerConflict - (optional) The name of the first item
                                with a different Owner is returned here.
                                Free with LocalFreeString.
                ppszGroupConflict - (optional) similar to ppszOwnerConflict
                ppszDaclConflict - (optional) similar to ppszOwnerConflict
                ppszSaclConflict - (optional) similar to ppszOwnerConflict

    RETURNS:    S_OK if successful, HRESULT error code otherwise

    NOTES:      The function may exit without checking all objects if all of
                the requested flags become FALSE.  All out parameters are
                valid if the function succeeds, and undetermined otherwise.

    HISTORY:
        JeffreyS 18-Feb-1997     Created

********************************************************************/

STDMETHODIMP
DPA_CompareSecurityIntersection(HDPA         hItemList,
                                PFN_READ_SD  pfnReadSD,
                                BOOL        *pfOwnerConflict,
                                BOOL        *pfGroupConflict,
                                BOOL        *pfSACLConflict,
                                BOOL        *pfDACLConflict,
                                LPTSTR      *ppszOwnerConflict,
                                LPTSTR      *ppszGroupConflict,
                                LPTSTR      *ppszSaclConflict,
                                LPTSTR      *ppszDaclConflict,
                                LPBOOL       pbCancel)
{
    HRESULT hr = S_OK;
    DWORD dwErr;
    SECURITY_INFORMATION si = 0;
    DWORD dwPriv = SE_SECURITY_PRIVILEGE;
    HANDLE hToken = INVALID_HANDLE_VALUE;
    LPTSTR pszItem;
    LPTSTR pszFile;
    PSECURITY_DESCRIPTOR pSD1 = NULL;
    PSECURITY_DESCRIPTOR pSD2 = NULL;
    int i;

#if DBG
    DWORD dwTimeStart = GetTickCount();
#endif

    TraceEnter(TRACE_UTIL, "DPA_CompareSecurityIntersection");
    TraceAssert(hItemList != NULL);
    TraceAssert(pfnReadSD != NULL);

    if (pfOwnerConflict)
    {
        *pfOwnerConflict = FALSE;
        si |= OWNER_SECURITY_INFORMATION;
    }
    if (pfGroupConflict)
    {
        *pfGroupConflict = FALSE;
        si |= GROUP_SECURITY_INFORMATION;
    }
    if (pfSACLConflict)
    {
        *pfSACLConflict = FALSE;

        // SeAuditPrivilege must be enabled to read the SACL.
        hToken = EnablePrivileges(&dwPriv, 1);
        if (INVALID_HANDLE_VALUE != hToken)
        {
            si |= SACL_SECURITY_INFORMATION;
        }
        else
        {
            // Leave *pfSACLConflict set to FALSE
            pfSACLConflict = NULL;
            TraceMsg("Security privilege not enabled -- not checking SACL");
        }
    }
    if (pfDACLConflict)
    {
        *pfDACLConflict = FALSE;
        si |= DACL_SECURITY_INFORMATION;
    }

    if (ppszOwnerConflict != NULL)
        *ppszOwnerConflict = NULL;
    if (ppszGroupConflict != NULL)
        *ppszGroupConflict = NULL;
    if (ppszSaclConflict != NULL)
        *ppszSaclConflict = NULL;
    if (ppszDaclConflict != NULL)
        *ppszDaclConflict = NULL;

    if (si == 0 || DPA_GetPtrCount(hItemList) < 2)
        ExitGracefully(hr, S_OK, "Nothing requested or list contains only one item");

    if (pbCancel && *pbCancel)
        ExitGracefully(hr, S_OK, "DPA_CompareSecurityIntersection cancelled");

    //
    // Get the first item name and load its security descriptor.
    //
    pszItem = (LPTSTR)DPA_FastGetPtr(hItemList, 0);
    if (NULL == pszItem)
        ExitGracefully(hr, E_UNEXPECTED, "Item list is empty");

    dwErr = (*pfnReadSD)(pszItem, si, &pSD1);
    if (dwErr)
        ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr), "Unable to read Security Descriptor");

    //
    // Go through the rest of the list and compare their security
    // descriptors to the first one.
    //
    for (i = 1; i < DPA_GetPtrCount(hItemList) && si != 0; i++)
    {
        if (pbCancel && *pbCancel)
            ExitGracefully(hr, S_OK, "DPA_CompareSecurityIntersection cancelled");

        pszItem = (LPTSTR)DPA_FastGetPtr(hItemList, i);
        if (NULL == pszItem)
            ExitGracefully(hr, E_UNEXPECTED, "Unable to retrieve item name from list");

        dwErr = (*pfnReadSD)(pszItem, si, &pSD2);
        if (dwErr)
            ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr), "Unable to read Security Descriptor");

        CompareSecurityDescriptors(pSD1,
                                   pSD2,
                                   pfOwnerConflict,
                                   pfGroupConflict,
                                   pfSACLConflict,
                                   pfDACLConflict);
        if (pSD2 != NULL)
        {
            LocalFree(pSD2);
            pSD2 = NULL;
        }

        //
        // Get the leaf name of the item to return as the conflict name
        //
        pszFile = PathFindFileName(pszItem);
        if (!pszFile)
            pszFile = pszItem;

        // If we find an owner that doesn't match, we can stop checking owners
        if (pfOwnerConflict && *pfOwnerConflict)
        {
            pfOwnerConflict = NULL;
            si &= ~OWNER_SECURITY_INFORMATION;

            if (ppszOwnerConflict)
                LocalAllocString(ppszOwnerConflict, pszFile);
        }

        // Ditto for the group
        if (pfGroupConflict && *pfGroupConflict)
        {
            pfGroupConflict = NULL;
            si &= ~GROUP_SECURITY_INFORMATION;

            if (ppszGroupConflict)
                LocalAllocString(ppszGroupConflict, pszFile);
        }

        // Same for SACLs
        if (pfSACLConflict && *pfSACLConflict)
        {
            pfSACLConflict = NULL;
            si &= ~SACL_SECURITY_INFORMATION;

            if (ppszSaclConflict)
                LocalAllocString(ppszSaclConflict, pszFile);
        }

        // Same for DACLs
        if (pfDACLConflict && *pfDACLConflict)
        {
            pfDACLConflict = NULL;
            si &= ~DACL_SECURITY_INFORMATION;

            if (ppszDaclConflict)
                LocalAllocString(ppszDaclConflict, pszFile);
        }
    }

exit_gracefully:

    // Release any privileges we enabled
    ReleasePrivileges(hToken);

    if (FAILED(hr))
    {
        LocalFreeString(ppszOwnerConflict);
        LocalFreeString(ppszGroupConflict);
        LocalFreeString(ppszSaclConflict);
        LocalFreeString(ppszDaclConflict);
    }

    if (pSD1 != NULL)
        LocalFree(pSD1);

#if DBG
    Trace((TEXT("DPA_CompareSecurityIntersection done: %d"), GetTickCount() - dwTimeStart));
#endif

    TraceLeaveResult(hr);
}


//*************************************************************
//
//  GetRemotePath
//
//  Purpose:    Return UNC version of a path
//
//  Parameters: pszInName - initial path
//              ppszOutName - UNC path returned here
//
//
//  Return:     HRESULT
//              S_OK - UNC path returned
//              S_FALSE - drive not connected (UNC not returned)
//              or failure code
//
//  Notes:      The function fails is the path is not a valid
//              network path.  If the path is already UNC,
//              a copy is made without validating the path.
//              *ppszOutName must be LocalFree'd by the caller.
//
//*************************************************************

DWORD _WNetGetConnection(LPCTSTR pszLocal, LPTSTR pszRemote, LPDWORD pdwLen)
{
    DWORD dwErr = ERROR_PROC_NOT_FOUND;

    // This is the only function we call in mpr.dll, and it's delay-loaded
    // so wrap it with SEH.
    __try
    {
        dwErr = WNetGetConnection(pszLocal, pszRemote, pdwLen);
    }
    __finally
    {
    }

    return dwErr;
}

STDMETHODIMP
GetRemotePath(LPCTSTR pszInName, LPTSTR *ppszOutName)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);

    TraceEnter(TRACE_UTIL, "GetRemotePath");
    TraceAssert(pszInName);
    TraceAssert(ppszOutName);

    *ppszOutName = NULL;

    

    if (pszInName[1] == TEXT(':'))
    {
        DWORD dwErr;
        TCHAR szLocalName[3];
        TCHAR szRemoteName[MAX_PATH];
        DWORD dwLen = ARRAYSIZE(szRemoteName);

        szLocalName[0] = pszInName[0];
        szLocalName[1] = pszInName[1];
        szLocalName[2] = TEXT('\0');

        dwErr = _WNetGetConnection(szLocalName, szRemoteName, &dwLen);

        if (NO_ERROR == dwErr)
        {
            hr = S_OK;
            dwLen = lstrlen(szRemoteName);
        }
        else if (ERROR_NOT_CONNECTED == dwErr)
        {
            ExitGracefully(hr, S_FALSE, "Drive not connected");
        }
        else if (ERROR_MORE_DATA != dwErr)
            ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr), "WNetGetConnection failed");
        // if dwErr == ERROR_MORE_DATA, dwLen already has the correct value

        // Skip the drive letter and add the length of the rest of the path
        // (including NULL)
        pszInName += 2;
        dwLen += lstrlen(pszInName) + 1;

        // We should never get incomplete paths, so we should always
        // see a backslash after the "X:".  If this isn't true, then
        // we should call GetFullPathName above.
        TraceAssert(TEXT('\\') == *pszInName);

        // Allocate the return buffer
        *ppszOutName = (LPTSTR)LocalAlloc(LPTR, dwLen * SIZEOF(TCHAR));
        if (!*ppszOutName)
            ExitGracefully(hr, E_OUTOFMEMORY, "LocalAlloc failed");

        if (ERROR_MORE_DATA == dwErr)
        {
            // Try again with the bigger buffer
            dwErr = _WNetGetConnection(szLocalName, *ppszOutName, &dwLen);
            hr = HRESULT_FROM_WIN32(dwErr);
            FailGracefully(hr, "WNetGetConnection failed");
        }
        else
        {
            // WNetGetConnection succeeded. Copy the result
            lstrcpy(*ppszOutName, szRemoteName);
        }

        // Copy the rest of the path
        lstrcat(*ppszOutName, pszInName);
    }
    else if (PathIsUNC(pszInName))
    {
        // Just copy the path without validating it
        hr = LocalAllocString(ppszOutName, pszInName);
    }

exit_gracefully:

    if (FAILED(hr))
        LocalFreeString(ppszOutName);

    TraceLeaveResult(hr);
}


/*******************************************************************

    NAME:       LocalFreeDPA

    SYNOPSIS:   LocalFree's all pointers in a Dynamic Pointer
                Array and then frees the DPA.

    ENTRY:      hList - handle of list to destroy

    RETURNS:    nothing

********************************************************************/
int CALLBACK
_LocalFreeCB(LPVOID pVoid, LPVOID /*pData*/)
{
    if (pVoid)
        LocalFree(pVoid);
    return 1;
}

void
LocalFreeDPA(HDPA hList)
{
    if (hList != NULL)
        DPA_DestroyCallback(hList, _LocalFreeCB, 0);
}


//+---------------------------------------------------------------------------
//
//  Function:   IsSafeMode
//
//  Synopsis:   Checks the registry to see if the system is in safe mode.
//
//  History:    06-Oct-00 JeffreyS  Created
//
//----------------------------------------------------------------------------

BOOL
IsSafeMode(void)
{
    BOOL    fIsSafeMode = FALSE;
    LONG    ec;
    HKEY    hkey;

    ec = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Option"),
                0,
                KEY_QUERY_VALUE,
                &hkey
                );

    if (ec == NO_ERROR)
    {
        DWORD dwValue;
        DWORD dwValueSize = sizeof(dwValue);

        ec = RegQueryValueEx(hkey,
                             TEXT("OptionValue"),
                             NULL,
                             NULL,
                             (LPBYTE)&dwValue,
                             &dwValueSize);

        if (ec == NO_ERROR)
        {
            fIsSafeMode = (dwValue == SAFEBOOT_MINIMAL || dwValue == SAFEBOOT_NETWORK);
        }

        RegCloseKey(hkey);
    }

    return fIsSafeMode;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsGuestAccessMode
//
//  Synopsis:   Checks the registry to see if the system is using the
//              Guest-only network access mode.
//
//  History:    06-Oct-00 JeffreyS  Created
//              19-Apr-00 GPease    Modified and changed name
//
//----------------------------------------------------------------------------

BOOL
IsForcedGuestModeOn(void)
{
    BOOL fIsForcedGuestModeOn = FALSE;

    if (IsOS(OS_PERSONAL))
    {
        // Guest mode is always on for Personal
        fIsForcedGuestModeOn = TRUE;
    }
    else if (IsOS(OS_PROFESSIONAL) && !IsOS(OS_DOMAINMEMBER))
    {
        LONG    ec;
        HKEY    hkey;

        // Professional, not in a domain. Check the ForceGuest value.

        ec = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    TEXT("SYSTEM\\CurrentControlSet\\Control\\LSA"),
                    0,
                    KEY_QUERY_VALUE,
                    &hkey
                    );

        if (ec == NO_ERROR)
        {
            DWORD dwValue;
            DWORD dwValueSize = sizeof(dwValue);

            ec = RegQueryValueEx(hkey,
                                 TEXT("ForceGuest"),
                                 NULL,
                                 NULL,
                                 (LPBYTE)&dwValue,
                                 &dwValueSize);

            if (ec == NO_ERROR && 1 == dwValue)
            {
                fIsForcedGuestModeOn = TRUE;
            }

            RegCloseKey(hkey);
        }
    }

    return fIsForcedGuestModeOn;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsSimpleUI
//
//  Synopsis:   Checks whether to show the simple version of the UI.
//
//  History:    06-Oct-00 JeffreyS  Created
//              19-Apr-00 GPease    Removed CTRL key check
//
//----------------------------------------------------------------------------

BOOL
IsSimpleUI(void)
{
    // Show old UI in safe mode and anytime network access involves
    // true user identity (server, pro with GuestMode off).
    
    // Show simple UI anytime network access is done using the Guest
    // account (personal, pro with GuestMode on) except in safe mode.

    return (!IsSafeMode() && IsForcedGuestModeOn());
}


HRESULT BindToObjectEx(IShellFolder *psf, LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr;
    IShellFolder *psfRelease = NULL;

    if (!psf)
    {
        SHGetDesktopFolder(&psf);
        psfRelease = psf;
    }

    if (psf)
    {
        if (!pidl || ILIsEmpty(pidl))
        {
            hr = psf->QueryInterface(riid, ppv);
        }
        else
        {
            hr = psf->BindToObject(pidl, pbc, riid, ppv);
        }
    }
    else
    {
        *ppv = NULL;
        hr = E_FAIL;
    }

    if (psfRelease)
    {
        psfRelease->Release();
    }

    if (SUCCEEDED(hr) && (*ppv == NULL))
    {
        // Some shell extensions (eg WS_FTP) will return success and a null out pointer
        hr = E_FAIL;
    }

    return hr;
}
LPITEMIDLIST ILCloneParent(LPCITEMIDLIST pidl)
{   
    LPITEMIDLIST pidlParent = ILClone(pidl);
    if (pidlParent)
        ILRemoveLastID(pidlParent);

    return pidlParent;
}
// psfRoot is the base of the bind.  If NULL, then we use the shell desktop.
// If you want to bind relative to the explorer root (e.g., CabView, MSN),
// then use SHBindToIDListParent.
HRESULT BindToFolderIDListParent(IShellFolder *psfRoot, LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast)
{
    HRESULT hr;

    // Old shell32 code in some cases simply whacked the pidl,
    // but this is unsafe.  Do what shdocvw does and clone/remove:
    //
    LPITEMIDLIST pidlParent = ILCloneParent(pidl);
    if (pidlParent) 
    {
        hr = BindToObjectEx(psfRoot, pidlParent, NULL, riid, ppv);
        ILFree(pidlParent);
    }
    else
        hr = E_OUTOFMEMORY;

    if (ppidlLast)
        *ppidlLast = ILFindLastID(pidl);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsUIHiddenByPrivacyPolicy
//
//  Synopsis:   Checks if Security Tab is hidden by privacy policy
//				NTRAID#NTBUG9-223899-2001/03/06-hiteshr
//  History:    06-March-01 hiteshr Created
//
//----------------------------------------------------------------------------

BOOL
IsUIHiddenByPrivacyPolicy(void)
{
    BOOL fIsUIHiddenByPrivacyPolicy = FALSE;
	
	LONG    ec;
    HKEY    hkey = NULL;

    
    ec = RegOpenKeyEx(HKEY_CURRENT_USER,
                      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer"),
                      0,
                      KEY_QUERY_VALUE,
                      &hkey
                      );

	if (ec == NO_ERROR)
    {
		DWORD dwValue = 0;
        DWORD dwValueSize = sizeof(dwValue);

        ec = RegQueryValueEx(hkey,
						     TEXT("NoSecurityTab"),
                             NULL,
                             NULL,
                             (LPBYTE)&dwValue,
                             &dwValueSize);

		if (ec == NO_ERROR && 1 == dwValue)
        {
			fIsUIHiddenByPrivacyPolicy = TRUE;
		}

		RegCloseKey(hkey);
	}
	return fIsUIHiddenByPrivacyPolicy;
}

//+----------------------------------------------------------------------------
//  Function:SetAclOnRemoteNetworkDrive   
//  Synopsis: If Z: is a mapped drive( mapped to \\machineA\share), when 
//			  we set DACL/SACL on Z:, Security API's cannot determine
//			  the parent of "share" on machineA and so we lose all the
//			  inherited aces. All UI can do is to detect such cases and
//			  show a warning. Thats what this function does. 
//  Arguments:hItemList List of items on which security is going to be set
//			  si: SECURITY_INFORMATION
//			  pSD: Security Descriptor to be set
//			  hWndPopupOwner: Owner window for message box
//  Returns:  
//  NTRAID#NTBUG9-581195-2002/03/26-hiteshr
//  NOTES:Since this fix is XPSP1, resources are going to be loaded from
//		  xpsp1res.dll
//-----------------------------------------------------------------------------
BOOL SetAclOnRemoteNetworkDrive(HDPA hItemList,
								SECURITY_INFORMATION si,
								PSECURITY_DESCRIPTOR pSD,
								HWND hWndPopupOwner)
{
	if(!hItemList || !pSD)
	{
		ASSERT(hItemList);
		ASSERT(pSD);
		return FALSE;
	}

	//We care only about DACL and SACL
	if(!(si & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION)))
	{
		return TRUE;
	}

	SECURITY_DESCRIPTOR_CONTROL Control = 0;
	DWORD dwRevision = 0;
	//Check if DACL or SACL is protected
	if(!GetSecurityDescriptorControl(pSD,&Control,&dwRevision))
	{
		return FALSE;
	}

	//If inheritance is prevented for this object,there is no loss of inheritance
	//so we are fine
	if( ((si & DACL_SECURITY_INFORMATION) && (Control & SE_DACL_PROTECTED)) ||
		((si & SACL_SECURITY_INFORMATION) && (Control & SE_SACL_PROTECTED)))
	{
		return TRUE;
	}

	LPWSTR pszMessage = NULL;
	LPWSTR pszTitle = NULL;
	BOOL bRet = TRUE;
	HINSTANCE hResModule = NULL;

	//Now Check if any of the items in hItemList is a mapped network drive 

	for (int i = 0; i < DPA_GetPtrCount(hItemList); i++)
    {
        LPTSTR pszPath = (LPTSTR)DPA_FastGetPtr(hItemList, i);

		//Path in not a root
		if(!PathIsRoot(pszPath))
		{
			continue;
		}

		//Path is root but not remote
		if(GetDriveType(pszPath) != DRIVE_REMOTE)
		{
			continue;
		}

		int nMsgId = (si & DACL_SECURITY_INFORMATION) ? IDS_RSHX32_SET_PERMS_ON_NETWORK_DRIVE : IDS_RSHX32_SET_SACLS_ON_NETWORK_DRIVE;

		//LOAD Resource from 
		WCHAR szResourceDLL[] = L"xpsp1res.dll";
        hResModule = LoadLibrary(szResourceDLL); 
		if(hResModule)
		{
			if(!LoadStringAlloc(&pszTitle, hResModule, IDS_RSHX32_PROP_PAGE_TITLE))
				break;

			if(!LoadStringAlloc(&pszMessage, hResModule, nMsgId))
				break;            
		
			//Ok, this is a remote network drive, display Warning.
			//We display only one warning per list
			if (IDNO == MsgPopup(hWndPopupOwner,
								 pszMessage,
								 pszTitle,
								 MB_YESNO|MB_DEFBUTTON2| MB_ICONWARNING | MB_SETFOREGROUND,
								 g_hInstance,
								 pszPath))
			{
				bRet = FALSE;
			}
		}

		break;
	}

	LocalFreeString(&pszTitle);
	LocalFreeString(&pszMessage);

	if(hResModule)
		FreeLibrary(hResModule);

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\shcompui\debug.h ===
#ifndef __SHCOMPUI_DEBUG_H
#define __SHCOMPUI_DEBUG_H
///////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995.
//
//  FILE: DEBUG.H
//
//  DESCRIPTION:
//
//    Header for debug support in SHCOMPUI.DLL.
//
//
//    REVISIONS:
//
//    Date       Description                                         Programmer
//    ---------- --------------------------------------------------- ----------
//    09/15/95   Initial creation.                                   brianau
//
///////////////////////////////////////////////////////////////////////////////
#ifdef ASSERT
#   undef ASSERT
#endif

#if defined(DEBUG) || defined(DBG)

#include <windows.h>
#include <tchar.h>

void WINAPI AssertFailed(LPCTSTR szFile, int line);

#ifdef UNICODE
#define ASSERT(f)                                 \
    {                                             \
        if (!(f)) {                               \
            TCHAR szFile[MAX_PATH];               \
            MultiByteToWideChar(CP_ACP,0,__FILE__,-1,szFile,MAX_PATH); \
            AssertFailed(szFile, __LINE__);       \
        }                                         \
    }
#else
#define ASSERT(f)                                 \
    {                                             \
        if (!(f))                                 \
            AssertFailed((LPCTSTR)__FILE__, __LINE__);       \
    }
#endif
#else

#define ASSERT(f)   (NULL)  // No action.

#endif

void DbgOut(LPCTSTR fmt, ...);

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\rshx32\si.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       si.cpp
//
//  This file contains the implementation of the CSecurityInformation
//  base class.
//
//--------------------------------------------------------------------------

#include "rshx32.h"
#include <shlapip.h>

#if(_WIN32_WINNT < 0x0500)
//
// NT4 SP4 doesn't support SetSecurityDescriptorControl, so
// emulate it here
//
BOOL
WINAPI
SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR psd,
                             SECURITY_DESCRIPTOR_CONTROL wControlMask,
                             SECURITY_DESCRIPTOR_CONTROL wControlBits)
{
    DWORD dwErr = NOERROR;
    PISECURITY_DESCRIPTOR pSD = (PISECURITY_DESCRIPTOR)psd;

    if (pSD)
        pSD->Control = (pSD->Control & ~wControlMask) | wControlBits;
    else
        dwErr = ERROR_INVALID_PARAMETER;

    return dwErr;
}
#endif


#include <dsrole.h>
BOOL IsStandalone(LPCTSTR pszMachine, PBOOL pbIsDC)
{
    BOOL bStandalone = TRUE;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pDsRole = NULL;

    //
    // Find out if target machine is a standalone machine or joined to
    // an NT domain.
    //

    __try
    {
        if (pbIsDC)
            *pbIsDC = FALSE;

        DsRoleGetPrimaryDomainInformation(pszMachine,
                                          DsRolePrimaryDomainInfoBasic,
                                          (PBYTE*)&pDsRole);
    }
    __finally
    {
    }

    if (NULL != pDsRole)
    {
        if (pDsRole->MachineRole == DsRole_RoleStandaloneWorkstation ||
            pDsRole->MachineRole == DsRole_RoleStandaloneServer)
        {
            bStandalone = TRUE;
        }
        else
            bStandalone = FALSE;

        if (pbIsDC)
        {
            if (pDsRole->MachineRole == DsRole_RolePrimaryDomainController ||
                pDsRole->MachineRole == DsRole_RoleBackupDomainController)
            {
                *pbIsDC = TRUE;
            }
        }

        DsRoleFreeMemory(pDsRole);
    }

    return bStandalone;
}


void
ProtectACLs(SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD)
{
    SECURITY_DESCRIPTOR_CONTROL wSDControl;
    DWORD dwRevision;
    PACL pAcl;
    BOOL bDefaulted;
    BOOL bPresent;
    PACE_HEADER pAce;
    UINT cAces;

    TraceEnter(TRACE_SI, "ProtectACLs");

    if (0 == si || NULL == pSD)
        TraceLeaveVoid();   // Nothing to do

    // Get the ACL protection control bits
    GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision);
    wSDControl &= SE_DACL_PROTECTED | SE_SACL_PROTECTED;

    if ((si & DACL_SECURITY_INFORMATION) && !(wSDControl & SE_DACL_PROTECTED))
    {
        wSDControl |= SE_DACL_PROTECTED;
        pAcl = NULL;
        GetSecurityDescriptorDacl(pSD, &bPresent, &pAcl, &bDefaulted);

        // Theoretically, modifying the DACL in this way can cause it to be
        // no longer canonical.  However, the only way this can happen is if
        // there is an inherited Deny ACE and a non-inherited Allow ACE.
        // Since this function is only called for root objects, this means
        // a) the server DACL must have a Deny ACE and b) the DACL on this
        // object must have been modified later.  But if the DACL was
        // modified through the UI, then we would have eliminated all of the
        // Inherited ACEs already.  Therefore, it must have been modified
        // through some other means.  Considering that the DACL originally
        // inherited from the server never has a Deny ACE, this situation
        // should be extrememly rare.  If it ever does happen, the ACL
        // Editor will just tell the user that the DACL is non-canonical.
        //
        // Therefore, let's ignore the possibility here.

        if (NULL != pAcl)
        {
            for (cAces = pAcl->AceCount, pAce = (PACE_HEADER)FirstAce(pAcl);
                 cAces > 0;
                 --cAces, pAce = (PACE_HEADER)NextAce(pAce))
            {
                pAce->AceFlags &= ~INHERITED_ACE;
            }
        }
    }

    if ((si & SACL_SECURITY_INFORMATION) && !(wSDControl & SE_SACL_PROTECTED))
    {
        wSDControl |= SE_SACL_PROTECTED;
        pAcl = NULL;
        GetSecurityDescriptorSacl(pSD, &bPresent, &pAcl, &bDefaulted);

        if (NULL != pAcl)
        {
            for (cAces = pAcl->AceCount, pAce = (PACE_HEADER)FirstAce(pAcl);
                 cAces > 0;
                 --cAces, pAce = (PACE_HEADER)NextAce(pAce))
            {
                pAce->AceFlags &= ~INHERITED_ACE;
            }
        }
    }

    SetSecurityDescriptorControl(pSD, SE_DACL_PROTECTED | SE_SACL_PROTECTED, wSDControl);

    TraceLeaveVoid();
}


CSecurityInformation::CSecurityInformation(SE_OBJECT_TYPE seType)
: m_cRef(1), m_seType(seType), m_hwndOwner(NULL),m_ResourceManager(NULL),m_bIsStandAlone(FALSE)   
{
    InterlockedIncrement(&g_cRefThisDll);
    AuthzInitializeResourceManager(0,
                                   NULL,
                                   NULL,
                                   NULL,
                                   L"Dummy",                                  
                                   &m_ResourceManager );

}

CSecurityInformation::~CSecurityInformation()
{
    LocalFreeDPA(m_hItemList);
    LocalFreeString(&m_pszObjectName);
    LocalFreeString(&m_pszServerName);
    AuthzFreeResourceManager(m_ResourceManager);

    InterlockedDecrement(&g_cRefThisDll);
}

STDMETHODIMP
CSecurityInformation::Initialize(HDPA   hItemList,
                                 DWORD  dwFlags,
                                 LPTSTR pszServer,
                                 LPTSTR pszObject)
{
    TraceEnter(TRACE_SI, "CSecurityInformation::Initialize");
    TraceAssert(hItemList != NULL);
    TraceAssert(DPA_GetPtrCount(hItemList) > 0);
    TraceAssert(pszObject != NULL);
    TraceAssert(m_pszObjectName == NULL);   // only initialize once

    m_hItemList = hItemList;
    m_dwSIFlags = dwFlags;
    m_pszServerName = pszServer;
    m_pszObjectName = pszObject;
    m_bIsStandAlone = IsStandalone(pszServer, NULL);


    TraceLeaveResult(S_OK);
}


///////////////////////////////////////////////////////////
//
// IUnknown methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CSecurityInformation::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CSecurityInformation::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CSecurityInformation::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
    {
        *ppv = (LPSECURITYINFO)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IEffectivePermission))
    {
        *ppv = (LPEFFECTIVEPERMISSION)this;
        m_cRef++;
        return S_OK;
    }
    else if((m_seType != SE_PRINTER) && IsEqualIID(riid, IID_ISecurityObjectTypeInfo))
    {
        *ppv = (LPSecurityObjectTypeInfo)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////
//
// ISecurityInformation methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP
CSecurityInformation::GetObjectInformation(PSI_OBJECT_INFO pObjectInfo)
{
    TraceEnter(TRACE_SI, "CSecurityInformation::GetObjectInformation");
    TraceAssert(pObjectInfo != NULL &&
                !IsBadWritePtr(pObjectInfo, sizeof(*pObjectInfo)));

    pObjectInfo->dwFlags = m_dwSIFlags;
    pObjectInfo->hInstance = g_hInstance;
    pObjectInfo->pszServerName = m_pszServerName;
    pObjectInfo->pszObjectName = m_pszObjectName;

    TraceLeaveResult(S_OK);
}

STDMETHODIMP
CSecurityInformation::GetSecurity(SECURITY_INFORMATION si,
                                  PSECURITY_DESCRIPTOR *ppSD,
                                  BOOL fDefault)
{
    HRESULT hr = S_OK;
    LPTSTR pszItem;

    TraceEnter(TRACE_SI, "CSecurityInformation::GetSecurity");
    TraceAssert(si != 0);
    TraceAssert(ppSD != NULL);

    *ppSD = NULL;

    //Default security descriptor not supported
    if (fDefault)
        ExitGracefully(hr, E_NOTIMPL, "Default security descriptor not supported");

    // Get the name of the first item
    pszItem = (LPTSTR)DPA_GetPtr(m_hItemList, 0);
    if (NULL == pszItem)
        ExitGracefully(hr, E_UNEXPECTED, "CSecurityInformation not initialized");

    hr = ReadObjectSecurity(pszItem, si, ppSD);

    // If this is a Root object, then we pretend that the ACLs are
    // always protected and no ACEs are inherited.
    if (SUCCEEDED(hr) && (m_dwSIFlags & SI_NO_ACL_PROTECT))
        ProtectACLs(si & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION), *ppSD);

exit_gracefully:

    TraceLeaveResult(hr);
}

STDMETHODIMP
CSecurityInformation::SetSecurity(SECURITY_INFORMATION si,
                                  PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = S_OK;
    HCURSOR hcurPrevious = (HCURSOR)INVALID_HANDLE_VALUE;
    UINT cItems;
    int i;

    TraceEnter(TRACE_SI, "CSecurityInformation::SetSecurity");
    TraceAssert(si != 0);
    TraceAssert(pSD != NULL);

    if (NULL == m_hItemList)
        ExitGracefully(hr, E_UNEXPECTED, "CSecurityInformation not initialized");

    hcurPrevious = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    //  Apply the new permissions to every item in the list
    //
    for (i = 0; i < DPA_GetPtrCount(m_hItemList); i++)
    {
        LPTSTR pszItem = (LPTSTR)DPA_FastGetPtr(m_hItemList, i);
        hr = WriteObjectSecurity(pszItem, si, pSD);
        FailGracefully(hr, "Unable to write new security descriptor");
        if (IsFile())  // If this is a file, delete it's thumbnail from the database, it will get put back if appropriate
        {
            DeleteFileThumbnail(pszItem);
        }
    }

exit_gracefully:

    // Restore previous cursor
    if (hcurPrevious != INVALID_HANDLE_VALUE)
        SetCursor(hcurPrevious);

    TraceLeaveResult(hr);
}

STDMETHODIMP
CSecurityInformation::PropertySheetPageCallback(HWND hwnd,
                                                UINT uMsg,
                                                SI_PAGE_TYPE uPage)
{
    if (SI_PAGE_PERM == uPage)
    {
        switch (uMsg)
        {
        case PSPCB_SI_INITDIALOG:
            do
            {
                m_hwndOwner = hwnd;
            } while (hwnd = GetParent(hwnd));

            break;

        case PSPCB_RELEASE:
            m_hwndOwner = NULL;
            break;
        }
    }
    return S_OK;
}


STDMETHODIMP
CSecurityInformation::ReadObjectSecurity(LPCTSTR pszObject,
                                         SECURITY_INFORMATION si,
                                         PSECURITY_DESCRIPTOR *ppSD)
{
    DWORD dwErr;

    TraceEnter(TRACE_SI, "CSecurityInformation::ReadObjectSecurity");
    TraceAssert(pszObject != NULL);
    TraceAssert(si != 0);
    TraceAssert(ppSD != NULL);

    //
    // This is kinda screwy.  The new APIs are being removed from NT5, but have
    // already been added to NT4 SP4.  The old APIs have new functionality on NT5,
    // but not on NT4 SPx.  Since we need the new functionality (auto-inheritance),
    // we have to call the new (defunct) API on NT4 and the old API on NT5.
    //
#if(_WIN32_WINNT >= 0x0500)
    dwErr = GetNamedSecurityInfo((LPTSTR)pszObject,
                                 m_seType,
                                 si,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 ppSD);
#else   // _WIN32_WINNT < 0x0500
    PACTRL_ACCESS pAccessList = NULL;
    PACTRL_AUDIT pAuditList = NULL;
    LPTSTR pOwner = NULL;
    LPTSTR pGroup = NULL;

    dwErr = GetNamedSecurityInfoEx(pszObject,
                                   m_seType,
                                   si,
                                   NULL,
                                   NULL,
                                   (si & DACL_SECURITY_INFORMATION) ? &pAccessList : NULL,
                                   (si & SACL_SECURITY_INFORMATION) ? &pAuditList : NULL,
                                   (si & OWNER_SECURITY_INFORMATION) ? &pOwner : NULL,
                                   (si & GROUP_SECURITY_INFORMATION) ? &pGroup : NULL);
    if (!dwErr)
    {
        dwErr = ConvertAccessToSecurityDescriptor(pAccessList,
                                                  pAuditList,
                                                  pOwner,
                                                  pGroup,
                                                  ppSD);
        if (pAccessList)
            LocalFree(pAccessList);
        if (pAuditList)
            LocalFree(pAuditList);
        if (pOwner)
            LocalFree(pOwner);
        if (pGroup)
            LocalFree(pGroup);
    }
#endif  // _WIN32_WINNT < 0x0500

    TraceLeaveResult(HRESULT_FROM_WIN32(dwErr));
}


STDMETHODIMP
CSecurityInformation::WriteObjectSecurity(LPCTSTR pszObject,
                                          SECURITY_INFORMATION si,
                                          PSECURITY_DESCRIPTOR pSD)
{
    DWORD dwErr;

    TraceEnter(TRACE_SI, "CSecurityInformation::WriteObjectSecurity");
    TraceAssert(pszObject != NULL);
    TraceAssert(si != 0);
    TraceAssert(pSD != NULL);

    //
    // This is kinda screwy.  The new APIs are being removed from NT5, but have
    // already been added to NT4 SP4.  The old APIs have new functionality on NT5,
    // but not on NT4 SPx.  Since we need the new functionality (auto-inheritance),
    // we have to call the new (defunct) API on NT4 and the old API on NT5.
    //

#if(_WIN32_WINNT >= 0x0500)
    SECURITY_DESCRIPTOR_CONTROL wSDControl = 0;
    DWORD dwRevision;
    PSID psidOwner = NULL;
    PSID psidGroup = NULL;
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    BOOL bDefaulted;
    BOOL bPresent;

    //
    // Get pointers to various security descriptor parts for
    // calling SetNamedSecurityInfo
    //
    GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision);
    GetSecurityDescriptorOwner(pSD, &psidOwner, &bDefaulted);
    GetSecurityDescriptorGroup(pSD, &psidGroup, &bDefaulted);
    GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefaulted);
    GetSecurityDescriptorSacl(pSD, &bPresent, &pSacl, &bDefaulted);

    if (si & DACL_SECURITY_INFORMATION)
    {
        if (wSDControl & SE_DACL_PROTECTED)
            si |= PROTECTED_DACL_SECURITY_INFORMATION;
        else
            si |= UNPROTECTED_DACL_SECURITY_INFORMATION;
    }
    if (si & SACL_SECURITY_INFORMATION)
    {
        if (wSDControl & SE_SACL_PROTECTED)
            si |= PROTECTED_SACL_SECURITY_INFORMATION;
        else
            si |= UNPROTECTED_SACL_SECURITY_INFORMATION;
    }

    dwErr = SetNamedSecurityInfo((LPTSTR)pszObject,
                                 m_seType,
                                 si,
                                 psidOwner,
                                 psidGroup,
                                 pDacl,
                                 pSacl);
#else   // _WIN32_WINNT < 0x0500
    PACTRL_ACCESS pAccessList = NULL;
    PACTRL_AUDIT pAuditList = NULL;
    LPTSTR pOwner = NULL;
    LPTSTR pGroup = NULL;

    dwErr = ConvertSecurityDescriptorToAccessNamed(pszObject,
                                                   m_seType,
                                                   pSD,
                                                   (si & DACL_SECURITY_INFORMATION) ? &pAccessList : NULL,
                                                   (si & SACL_SECURITY_INFORMATION) ? &pAuditList : NULL,
                                                   (si & OWNER_SECURITY_INFORMATION) ? &pOwner : NULL,
                                                   (si & GROUP_SECURITY_INFORMATION) ? &pGroup : NULL);
    if (!dwErr)
    {
        dwErr = SetNamedSecurityInfoEx(pszObject,
                                       m_seType,
                                       si,
                                       NULL,
                                       pAccessList,
                                       pAuditList,
                                       pOwner,
                                       pGroup,
                                       NULL);
        if (pAccessList)
            LocalFree(pAccessList);
        if (pAuditList)
            LocalFree(pAuditList);
        if (pOwner)
            LocalFree(pOwner);
        if (pGroup)
            LocalFree(pGroup);
    }
#endif  // _WIN32_WINNT < 0x0500

    TraceLeaveResult(HRESULT_FROM_WIN32(dwErr));
}

OBJECT_TYPE_LIST g_DefaultOTL[] = {
                                    {0, 0, (LPGUID)&GUID_NULL},
                                    };
BOOL SkipLocalGroup(LPCWSTR pszServerName, PSID psid)
{

	SID_NAME_USE use;
	WCHAR szAccountName[MAX_PATH];
	WCHAR szDomainName[MAX_PATH];
	DWORD dwAccountLen = MAX_PATH;
	DWORD dwDomainLen = MAX_PATH;

	if(LookupAccountSid(pszServerName,
						 psid,
						 szAccountName,
						 &dwAccountLen,
						 szDomainName,
						 &dwDomainLen,
						 &use))
	{
		if(use == SidTypeWellKnownGroup)
			return TRUE;
	}

	//Built In sids have first subauthority of 32 ( s-1-5-32 )
	//
	if((*(GetSidSubAuthorityCount(psid)) >= 1 ) && (*(GetSidSubAuthority(psid,0)) == 32))
		return TRUE;

	return FALSE;
}

		

STDMETHODIMP 
CSecurityInformation::GetEffectivePermission(const GUID* pguidObjectType,
                                        PSID pUserSid,
                                        LPCWSTR pszServerName,
                                        PSECURITY_DESCRIPTOR pSD,
                                        POBJECT_TYPE_LIST *ppObjectTypeList,
                                        ULONG *pcObjectTypeListLength,
                                        PACCESS_MASK *ppGrantedAccessList,
                                        ULONG *pcGrantedAccessListLength)
{

    AUTHZ_RESOURCE_MANAGER_HANDLE RM = NULL;    //Used for access check
    AUTHZ_CLIENT_CONTEXT_HANDLE CC = NULL;
    LUID luid = {0xdead,0xbeef};
    AUTHZ_ACCESS_REQUEST AReq;
    AUTHZ_ACCESS_REPLY AReply;
    HRESULT hr = S_OK;    
    DWORD dwFlags;

    TraceEnter(TRACE_SI, "CDSSecurityInfo::GetEffectivePermission");
    TraceAssert(pUserSid && IsValidSecurityDescriptor(pSD));
    TraceAssert(ppObjectTypeList != NULL);
    TraceAssert(pcObjectTypeListLength != NULL);
    TraceAssert(ppGrantedAccessList != NULL);
    TraceAssert(pcGrantedAccessListLength != NULL);

    AReq.ObjectTypeList = g_DefaultOTL;
    AReq.ObjectTypeListLength = ARRAYSIZE(g_DefaultOTL);
    AReply.GrantedAccessMask = NULL;
    AReply.Error = NULL;

    //Get RM
    if( (RM = GetAUTHZ_RM()) == NULL )
        ExitGracefully(hr, E_UNEXPECTED, "LocalAlloc failed");    

    //Initialize the client context

	BOOL bSkipLocalGroup = SkipLocalGroup(pszServerName, pUserSid);
    
    if( !AuthzInitializeContextFromSid((m_bIsStandAlone||bSkipLocalGroup)? AUTHZ_SKIP_TOKEN_GROUPS :0,
                                       pUserSid,
                                       RM,
                                       NULL,
                                       luid,                                      
                                       NULL,
                                       &CC) )
    {
        DWORD dwErr = GetLastError();
        ExitGracefully(hr, 
                       HRESULT_FROM_WIN32(dwErr),
                       "AuthzInitializeContextFromSid Failed");
    }



    //Do the Access Check

    AReq.DesiredAccess = MAXIMUM_ALLOWED;
    AReq.PrincipalSelfSid = NULL;
    AReq.OptionalArguments = NULL;

    AReply.ResultListLength = AReq.ObjectTypeListLength;
    AReply.SaclEvaluationResults = NULL;
    if( (AReply.GrantedAccessMask = (PACCESS_MASK)LocalAlloc(LPTR, sizeof(ACCESS_MASK)*AReply.ResultListLength) ) == NULL )
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to LocalAlloc");
    if( (AReply.Error = (PDWORD)LocalAlloc(LPTR, sizeof(DWORD)*AReply.ResultListLength)) == NULL )
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to LocalAlloc");
    
    if( !AuthzAccessCheck(0,
                          CC,
                          &AReq,
                          NULL,
                          pSD,
                          NULL,
                          0,
                          &AReply,
                          NULL) )
    {
        DWORD dwErr = GetLastError();
        ExitGracefully(hr,                        
                       HRESULT_FROM_WIN32(dwErr),
                       "AuthzAccessCheck Failed");
    }

exit_gracefully:

    if(CC)
        AuthzFreeContext(CC);
    
    if(!SUCCEEDED(hr))
    {
        if(AReply.GrantedAccessMask)
            LocalFree(AReply.GrantedAccessMask);
        if(AReply.Error)
            LocalFree(AReply.Error);
        AReply.Error = NULL;
        AReply.GrantedAccessMask = NULL;
    }
    else
    {
        *ppObjectTypeList = AReq.ObjectTypeList;                                  
        *pcObjectTypeListLength = AReq.ObjectTypeListLength;
        *ppGrantedAccessList = AReply.GrantedAccessMask;
        *pcGrantedAccessListLength = AReq.ObjectTypeListLength;
    }

    TraceLeaveResult(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\shcompui\resids.h ===
#ifndef __SHCOMPUI_RESIDS_H
#define __SHCOMPUI_RESIDS_H
///////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995.
//
//  FILE: RESIDS.H
//
//  DESCRIPTION:
//
//    Resource IDs for SHCOMPUI.DLL.
//
//
//    REVISIONS:
//
//    Date       Description                                         Programmer
//    ---------- --------------------------------------------------- ----------
//    09/15/95   Initial creation.                                   brianau
//
///////////////////////////////////////////////////////////////////////////////
#ifdef WINNT

//
// Confirmation dialog ids.
//
#define DLG_COMPRESS_CONFIRMATION     100  // The dialog.
#define IDC_COMPRESS_CONFIRM_TEXT     101  // Text message control ID.
#define IDC_COMPRESS_SUBFOLDERS       102  // "Also compress sub-folders." cbx control.
#define IDC_COMPRESS_ACTION_TEXT      103

//
// Progress dialog ids.
//
#define DLG_COMPRESS_PROGRESS         104
#define DLG_UNCOMPRESS_PROGRESS       105
#define DLG_COMPRESS_ERROR            106

//
// Compression progress dialog control IDs.
//
#define IDC_COMPRESS_FILE             107  // "Current" file name.
#define IDC_COMPRESS_DIR              108  // "Current" directory text.
#define IDC_COMPRESS_DIRCNT           109  // Count of directories processed.
#define IDC_COMPRESS_FILECNT          110  // Count of files processed.
#define IDC_COMPRESS_USIZE            111  // Cummulative pre-compression bytes.
#define IDC_COMPRESS_CSIZE            112  // Cummulative post-compression bytes.
#define IDC_COMPRESS_RATIO            113  // Cummulative compression ratio as pct.
#define IDC_TEXT1                     114

//
// Uncompression progress dialog control IDs.
//
#define IDC_UNCOMPRESS_FILE           115  // "Current" file name.
#define IDC_UNCOMPRESS_DIR            116  // "Current" directory text.
#define IDC_UNCOMPRESS_DIRCNT         117  // Count of directories processed.
#define IDC_UNCOMPRESS_FILECNT        118  // Count of files processed.

//
// Compression error dialog control IDs.
//
#define IDC_COMPRESS_IGNOREALL        119  // "Ignore all errors" button control.
#define IDC_COMPRESS_ERRTEXT          120  // Error message text control.


//
// Context menu extension string ids.
//
#define IDS_COMPRESS_CMDVERB          200  // Command string returned to shell.
#define IDS_COMPRESS_MENUITEM         201  // Context menu item.
#define IDS_COMPRESS_MENUITEM_ELLIP   202  // Context menu item with ellipsis.
#define IDS_COMPRESS_SBARTEXT         203  // Status bar text, single file.
#define IDS_COMPRESS_SBARTEXT_M       204  // Status bar text, multiple files.
#define IDS_COMPRESS_SBARTEXT_DRV     205  // Status bar text, single drive.
#define IDS_COMPRESS_SBARTEXT_DRV_M   206  // Status bar text, multiple drives.

#define IDS_UNCOMPRESS_CMDVERB        207  // Command string returned to shell.
#define IDS_UNCOMPRESS_MENUITEM       208  // Context menu item.
#define IDS_UNCOMPRESS_MENUITEM_ELLIP 209  // Context menu item with ellipsis.
#define IDS_UNCOMPRESS_SBARTEXT       210  // Status bar text, single file.
#define IDS_UNCOMPRESS_SBARTEXT_M     211  // Status bar text, multiple file.
#define IDS_UNCOMPRESS_SBARTEXT_DRV   212  // Status bar text, single drive.
#define IDS_UNCOMPRESS_SBARTEXT_DRV_M 213  // Status bar text, multiple drives.

//
// Miscellaneous compression support string ids.
//
#define IDS_COMPRESS_DIR              214
#define IDS_UNCOMPRESS_DIR            215
#define IDS_COMPRESS_ATTRIB_ERR       216
#define IDS_NTLDR_COMPRESS_ERR        217
#define IDS_MULTI_COMPRESS_ERR        218

//
// Confirmation dialog string ids.
//
#define IDS_COMPRESS_CONFIRMATION     219  // Compress text message string.
#define IDS_UNCOMPRESS_CONFIRMATION   220  // Uncompress text message string.
#define IDS_COMPRESS_ALSO             221  // "Also compress sub-folders." message.
#define IDS_UNCOMPRESS_ALSO           222  // "Also uncompress sub-folders." message.
#define IDS_COMPRESS_ACTION           223  // "This action compresses..."
#define IDS_UNCOMPRESS_ACTION         224

#define IDS_APP_NAME                  225  // "Explorer"

//
// Byte count display fmt strings.
//
#define IDS_BYTECNT_FMT               226  // "bytes %1".

#define IDS_UNCOMPRESS_DISKFULL       227

#endif  // ifdef WINNT

#endif  // ifdef __SHCOMPUI_RESIDS_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\security\rshx32\util.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       util.h
//
//  miscellaneous utility functions
//
//--------------------------------------------------------------------------

#ifndef _UTIL_H_
#define _UTIL_H_

STDMETHODIMP
IDA_BindToFolder(LPIDA pIDA, LPSHELLFOLDER *ppsf);

STDMETHODIMP
IDA_GetItemName(LPSHELLFOLDER psf,
                LPCITEMIDLIST pidl,
                LPTSTR pszName,
                UINT cchName,
                SHGNO uFlags = SHGDN_FORPARSING);
STDMETHODIMP
IDA_GetItemName(LPSHELLFOLDER psf,
                LPCITEMIDLIST pidl,
                LPTSTR *ppszName,
                SHGNO uFlags = SHGDN_FORPARSING);

typedef DWORD (WINAPI *PFN_READ_SD)(LPCTSTR pszItemName,
                                    SECURITY_INFORMATION si,
                                    PSECURITY_DESCRIPTOR* ppSD);

STDMETHODIMP
DPA_CompareSecurityIntersection(HDPA         hItemList,
                                PFN_READ_SD  pfnReadSD,
                                BOOL        *pfOwnerConflict,
                                BOOL        *pfGroupConflict,
                                BOOL        *pfSACLConflict,
                                BOOL        *pfDACLConflict,
                                LPTSTR      *ppszOwnerConflict,
                                LPTSTR      *ppszGroupConflict,
                                LPTSTR      *ppszSaclConflict,
                                LPTSTR      *ppszDaclConflict,
                                LPBOOL       pbCancel);

STDMETHODIMP
GetRemotePath(LPCTSTR pszInName, LPTSTR *ppszOutName);

void
LocalFreeDPA(HDPA hList);

BOOL
IsSafeMode(void);

BOOL
IsGuestAccessMode(void);

BOOL
IsSimpleUI(void);

BOOL 
IsUIHiddenByPrivacyPolicy(void);

HRESULT BindToObjectEx(IShellFolder *psf, LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
HRESULT BindToFolderIDListParent(IShellFolder *psfRoot, LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast);

//+----------------------------------------------------------------------------
//  Function:SetAclOnRemoteNetworkDrive   
//  Synopsis: If Z: is a mapped drive( mapped to \\machineA\share), when 
//			  we set DACL/SACL on Z:, Security API's cannot determine
//			  the parent of "share" on machineA and so we lose all the
//			  inherited aces. All UI can do is to detect such cases and
//			  show a warning. Thats what this function does. 
//  Arguments:hItemList List of items on which security is going to be set
//			  si: SECURITY_INFORMATION
//			  pSD: Security Descriptor to be set
//			  hWndPopupOwner: Owner window for message box
//  Returns:  
//  NTRAID#NTBUG9-581195-2002/03/26-hiteshr
//  NOTES:Since this fix is XPSP1, resources are going to be loaded from
//		  xpsp1res.dll
//-----------------------------------------------------------------------------
BOOL SetAclOnRemoteNetworkDrive(HDPA hItemList,
								SECURITY_INFORMATION si,
								PSECURITY_DESCRIPTOR pSD,
								HWND hWndPopupOwner);
#endif  /* _UTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\shcompui\debug.c ===
///////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995.
//
//  FILE: DEBUG.C
//
//  DESCRIPTION:
//
//    Debug support for SHCOMPUI.DLL.
//
//
//    REVISIONS:
//
//    Date       Description                                         Programmer
//    ---------- --------------------------------------------------- ----------
//    09/15/95   Initial creation.                                   brianau
//
///////////////////////////////////////////////////////////////////////////////

#if defined(DEBUG) || defined(DBG)

#include "debug.h"

#ifdef WIN32
#define DEBUG_BREAK        _try { DebugBreak(); } _except (EXCEPTION_EXECUTE_HANDLER) {;}
#else
#define DEBUG_BREAK        _asm { int 3 }
#endif


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: DbgOut
//
// DESCRIPTION:
//
//    Display a message string on the debugger output terminal.
//    The function accepts a variable length printf-style arg list.
//    A terminating newline is appended to the message string.
//
// ARGUMENTS:
//
//    fmt
//       printf-style format string.
//
//    ...
//       Variable-length arg list.
//
// RETURNS:
//
//    Nothing.
//
///////////////////////////////////////////////////////////////////////////////
void DbgOut(LPCTSTR fmt, ...)
{
   TCHAR szBuf[512];

   va_list args;
   va_start(args, fmt);

   ASSERT(NULL != fmt);

   wvsprintf(szBuf, fmt, args);
   lstrcat(szBuf, __TEXT("\r\n"));

   va_end(args);
   OutputDebugString(szBuf);
}



void WINAPI AssertFailed(LPCTSTR pszFile, int line)
{
    LPCTSTR psz;
    TCHAR ach[256];
    static TCHAR szAssertFailed[] = __TEXT("SHCOMPUI: assert %s, line %d\r\n");

    // Strip off path info from filename string, if present.
    //
    for (psz = pszFile + lstrlen(pszFile); psz != pszFile; psz=CharPrev(pszFile, psz))
    {
        if ((CharPrev(pszFile, psz)!= (psz-2)) && *(psz - 1) == TEXT('\\'))
            break;
    }
    DbgOut(szAssertFailed, psz, line);

    DEBUG_BREAK
}



#endif  // #ifdef DBG


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\shole\debug.c ===
#include "shole.h"

#ifdef WIN32
#define DEBUG_BREAK        _try { DebugBreak(); } except (EXCEPTION_EXECUTE_HANDLER) {;}
#else
#define DEBUG_BREAK        _asm { int 3 }
#endif


#ifdef DEBUG

//========== Debug output routines =========================================

UINT wDebugMask = 0x00ff;

UINT WINAPI SetDebugMask(UINT mask)
{
    UINT wOld = wDebugMask;
    wDebugMask = mask;

    return wOld;
}

UINT WINAPI GetDebugMask()
{
    return wDebugMask;
}

void WINAPI AssertFailed(LPCTSTR pszFile, int line)
{
    LPCTSTR psz;
    TCHAR ach[256];
    static TCHAR szAssertFailed[] = TEXT("Assertion failed in %s on line %d\r\n");

    // Strip off path info from filename string, if present.
    //
    if (wDebugMask & DM_ASSERT)
    {
        for (psz = pszFile + lstrlen(pszFile); psz != pszFile; psz=CharPrev(pszFile, psz))
        {
            if ((CharPrev(pszFile, psz)!= (psz-2)) && *(psz - 1) == TEXT('\\'))
                break;
        }
        wsprintf(ach, szAssertFailed, psz, line);
        OutputDebugString(ach);
        
        DEBUG_BREAK
    }
}

#define WINCAPI __cdecl
void WINCAPI _AssertMsg(BOOL f, LPCTSTR pszMsg, ...)
{
    TCHAR ach[256];

    if (!f && (wDebugMask & DM_ASSERT))
    {
#ifdef WINNT
        va_list ArgList;

        va_start(ArgList, pszMsg);
        wvsprintf(ach, pszMsg, ArgList);
        va_end(ArgList);
#else
        wvsprintf(ach, pszMsg, (LPVOID)(&pszMsg + 1));
#endif
        lstrcat(ach, TEXT("\r\n"));
        OutputDebugString(ach);
        DEBUG_BREAK
    }
}

void WINCAPI _DebugMsg(UINT mask, LPCTSTR pszMsg, ...)
{
    TCHAR ach[2*MAX_PATH+40];  // Handles 2*largest path + slop for message

    if (wDebugMask & mask)
    {
#ifdef WINNT
        va_list ArgList;

        va_start(ArgList, pszMsg);
        try {
            wvsprintf(ach, pszMsg, ArgList);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            OutputDebugString(TEXT("SHELL32: DebugMsg exception: "));
            OutputDebugString(pszMsg);
        }
        va_end(ArgList);
        OutputDebugString(TEXT("SHELL32: "));
#else
        wvsprintf(ach, pszMsg, (LPVOID)(&pszMsg + 1));
#endif
        lstrcat(ach, TEXT("\r\n"));
        OutputDebugString(ach);
    }
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\shcompui\shcompui.c ===
///////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995.
//
//  FILE: SHCOMPUI.C
//
//  DESCRIPTION:
//
//    This module provides the code for supporting NTFS file compression
//    in the NT Explorer user interface.  There are two interfaces to the
//    compression features.
//
//    The first interface is a shell context menu extension that adds
//    the options "Compress" and "Uncompress" to the context/file menu of
//    an object that has registered the extension.  This interface
//    uses the standard shell extension protocol of QueryContextMenu,
//    InvokeCommand etc.  InvokeCommand calls ShellChangeCompressionAttribute()
//    to do the actual compression/uncompression.
//
//    The shell extension CLSID is {764BF0E1-F219-11ce-972D-00AA00A14F56}
//    and is represented by the symbol CLSID_CompressMenuExt.
//
//    The second interface is provided for handling compression
//    requests through object property pages.  Property page action
//    code calls ShellChangeCompressionAttribute( ).
//
//    This way, through either interface, compression appears the same
//    to the user.
//
//    Note that a good portion of the actual compression code was taken
//    from the WinFile implementation.  Some changes were made to
//    eliminate redundant code and to produce the desired Explorer
//    compression behavior.
//
//    The comment string "WARNING" points out areas that are sensitive to maintenance activity.
//
//    This module is applicable only to the NT version of the shell.
//
//    REVISIONS:
//
//    Date       Description                                         Programmer
//    ---------- --------------------------------------------------- ----------
//    09/15/95   Initial creation.                                   brianau
//    09/20/95   Incorporated changes from 1st code review.          brianau
//    10/02/95   Added SCCA context structure.                       brianau
//               Changed all __TEXT() macros to TEXT()
//    10/13/95   Removed function Int64ToString and moved it to      brianau
//               util.c.
//    02/22/96   Check for shift-key before adding context menu      brianau
//               items.  No shift key, no items.
//               Also added call to SHChangeNotify to notify shell
//               that compression attribute changed on each file.
//    03/20/96   Added invalidation of drive type flags cache.       brianau
//               Replaced imported function declarations with
//               #include <shellprv.h>
//
///////////////////////////////////////////////////////////////////////////////
#ifdef WINNT
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <tchar.h>
#include <shlobj.h>
#include <shellapi.h>
#include <shlobjp.h>
#define INITGUID
#include <initguid.h>
#include "resids.h"     // SHCOMPUI Resource IDs.
#include "debug.h"      // DbgOut and ASSERT.
#include "shcompui.h"

#define Assert(f)
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

//
// Debug message control.
//
//#define TRACE_SHEXT 1        // Un-comment for shell extension tracing.
//#define TRACE_DLL   1        // Un-comment for DLL load/unload tracing.
//#define TRACE_COMPRESSION  1 // Un-comment for compression code tracing.
//#define SIM_DISK_FULL 1      // Un-comment to test disk-full condition.

//
// Define context menu position offsets for each option.
//
#define MENUOFS_FIRST      0     // For index range checking.
#define MENUOFS_COMPRESS   0     // Command index for "Compress" menu opt..
#define MENUOFS_UNCOMPRESS 1     // Command index for "Uncompress" menu opt.
#define MENUOFS_LAST       1     // For index range checking.

//
// Return values for compression confirmation dialog.
//
#define COMPRESS_CANCELLED 0     // User pressed Cancel.
#define COMPRESS_SUBSNO    1     // User pressed OK without box checked.
#define COMPRESS_SUBSYES   2     // User pressed OK with box checked.

//
//  Control values for DisplayCompressProgress( ) and
//  DisplayUncompressProgress( )
//
#define PROGRESS_UPD_FILENAME            1
#define PROGRESS_UPD_DIRECTORY           2
#define PROGRESS_UPD_FILEANDDIR          3
#define PROGRESS_UPD_DIRCNT              4
#define PROGRESS_UPD_FILECNT             5
#define PROGRESS_UPD_COMPRESSEDSIZE      6
#define PROGRESS_UPD_FILESIZE            7
#define PROGRESS_UPD_PERCENTAGE          8
#define PROGRESS_UPD_FILENUMBERS         9
#define PROGRESS_UPD_FINAL              10

//
//  Return values for CompressErrMessageBox routine.
//
#define RETRY_CREATE     1
#define RETRY_DEVIO      2

//
// Some text string and character constants.
// FEATURE: These should probably come from some locale info.
//
const TCHAR c_szSTAR[]      = TEXT("*");
const TCHAR c_szDOT[]       = TEXT(".");
const TCHAR c_szDOTDOT[]    = TEXT("..");
const TCHAR c_szNTLDR[]     = TEXT("NTLDR");
const TCHAR c_szBACKSLASH[] = TEXT("\\");

#define CH_NULL       TEXT('\0')


//
// String length constants.
//
#define MAX_DLGTITLE_LEN    128             // Max length of dialog title.
#define MAX_MESSAGE_LEN     (_MAX_PATH * 3) // General dialog text message.
#define MAX_MENUITEM_LEN     40             // Max length of context menu item.
#define MAX_CMDVERB_LEN      40             // Max length of cmd verb.

typedef HRESULT (CALLBACK FAR * LPFNCREATEINSTANCE)(LPUNKNOWN pUnkOuter,
        REFIID riid, LPVOID FAR* ppvObject);


static INT_PTR CALLBACK CompressSubsConfirmDlgProc(HWND hDlg, UINT uMsg,
                                WPARAM wParam, LPARAM lParam);

static BOOL DoCompress(HWND hwndParent,
                                LPTSTR DirectorySpec, LPTSTR FileSpec);

static BOOL DoUncompress(HWND hwndParent,
                                LPTSTR DirectorySpec, LPTSTR FileSpec);

static int  CompressErrMessageBox(HWND hwndActive,
                                LPTSTR szFile, PHANDLE phFile);

static INT_PTR CALLBACK CompressErrDialogProc(HWND hDlg, UINT uMsg,
                                WPARAM wParam, LPARAM lParam);

static BOOL OpenFileForCompress(PHANDLE phFile, LPTSTR szFile);

static DWORD FormatStringWithArgs(LPCTSTR pszFormat, LPTSTR pszBuffer,
                                                       DWORD nSize, ...);

static DWORD LoadStringWithArgs(HINSTANCE hInstance, UINT uId,
                                LPTSTR pszBuffer, DWORD nSize, ...);

static VOID CompressProgressYield(void);

static VOID DisplayUncompressProgress(int iType);

static void UncompressDiskFullError(HWND hwndParent, HANDLE hFile);


//
// Structure used to communicate with the compression confirmation dialog.
//
typedef struct {
   BOOL  bCompress;               // TRUE = compress, FALSE = uncompress
   TCHAR szFileName[_MAX_PATH+1]; // File to be acted on.
} CompressionDesc;


//
// Macros for converting between interface and class pointers.
//
#define CMX_OFFSETOF(x)          ((UINT_PTR)(&((CContextMenuExt *)0)->x))
#define PVOID2PCMX(pv,offset)    ((CContextMenuExt *)(((LPBYTE)pv)-offset))
#define PCM2PCMX(pcmx)           PVOID2PCMX(pcmx, CMX_OFFSETOF(ctm))
#define PSEI2PCMX(psei)          PVOID2PCMX(psei, CMX_OFFSETOF(sei))

INT g_cRefThisDll        = 0;       // Reference count for this DLL.
HINSTANCE g_hmodThisDll  = NULL;    // Handle to the DLL.
HANDLE g_hProcessHeap    = NULL;    // Handle to the process heap.
HANDLE g_hdlgProgress    = NULL;    // Operation progress dialog.

TCHAR szMessage[MAX_MESSAGE_LEN+1]; // FEATURE:  This need not be global.
TCHAR g_szByteCntFmt[10];           // Byte cnt disp fmt str ( "%1 bytes" ).

#define SZ_SEMAPHORE_NAME   TEXT("SHCOMPUI_SEMAPHORE")
HANDLE g_hSemaphore       = NULL;    // Re-entrancy semaphore.

LPSCCA_CONTEXT g_pContext = NULL;   // Ptr to current context structure.

INT g_iRecursionLevel = 0;          // Used to control shell change notifications.

//
//  Global variables to hold the User option information.
//
BOOL g_bDoSubdirectories = FALSE;   // Include all subdirectories ?
BOOL g_bShowProgress     = FALSE;   // Show operation progress dialog ?
BOOL g_bIgnoreAllErrors  = FALSE;   // User wants to ignore all errors ?
BOOL g_bDiskFull         = FALSE;   // Is disk full on uncompression ?

//
//  Global variables to hold compression statistics.
//
LONGLONG g_cTotalDirectories       = 0;
LONGLONG g_cTotalFiles             = 0;

//
// Compression ratio statistics values.
//
unsigned _int64 g_iTotalFileSize       = 0;
unsigned _int64 g_iTotalCompressedSize = 0;

//
// "Current" file and directory names are global.
//
TCHAR  g_szFile[_MAX_PATH + 1];
TCHAR  g_szDirectory[_MAX_PATH + 1];

//
// Directory text control in progress dialog.
//
HDC   g_hdcDirectoryTextCtrl = NULL; // Control handle.
DWORD g_cDirectoryTextCtrlWd = 0;    // Width of control.

//
// Number format locale information.
//
NUMBERFMT g_NumberFormat;
TCHAR g_szDecimalSep[5];
TCHAR g_szThousandSep[5];


//
// Context menu extension GUID generated with GUIDGEN.
//
// {764BF0E1-F219-11ce-972D-00AA00A14F56}
DEFINE_GUID(CLSID_CompressMenuExt,
0x764bf0e1, 0xf219, 0x11ce, 0x97, 0x2d, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);

//
// Structure representing the class factory for this in-process server.
//
typedef struct
{
   IClassFactory        cf;       // Pointer to class factory vtbl.
   UINT                 cRef;     // Interface reference counter.
   LPFNCREATEINSTANCE   pfnCI;    // Pointer to instance generator function.
} CClassFactory;

//
// Structure representing the context menu extension.
//
typedef struct
{
   IContextMenu   ctm;            // Pointer to context menu interface.
   IShellExtInit  sei;            // Pointer to shell extension init interface.
   UINT           cRef;           // Interface reference counter.
   STGMEDIUM      medium;         // OLE data xfer storage medium descriptor.
   INT            cSelectedFiles; // Cnt of files selected. Must be signed.
   BOOL           bDriveSelected; // Are drives selected ?
   LPDATAOBJECT   pDataObj;       // Saved pointer to Data Object.
} CContextMenuExt;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: PathRemoveTheBackslash
//
// DESCRIPTION:
//
//    Removes trailing backslash from path string if it exists.
//    This code was cut directly from path.c in shell32.dll and
//    renamed from PathRemoveBackslash to avoid linkage naming
//    conflicts.
//
// in:
//  lpszPath    (A:\, C:\foo\, etc)
//
// out:
//  lpszPath    (A:\, C:\foo, etc)
//
// returns:
//  ponter to NULL that replaced the backslash
//  or the pointer to the last character if it isn't a backslash.
//
///////////////////////////////////////////////////////////////////////////////
LPTSTR WINAPI PathRemoveTheBackslash(LPTSTR lpszPath)
{
  int len = lstrlen(lpszPath)-1;
  if (IsDBCSLeadByte(*((LPSTR)CharPrev(lpszPath,lpszPath+len+1))))
      len--;

  if (!PathIsRoot(lpszPath) && lpszPath[len] == TEXT('\\'))
      lpszPath[len] = TEXT('\0');

  return lpszPath + len;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: FileAttribString
//
// DESCRIPTION:
//
//    Formats a file's attribute word into a string of characters.
//    Used for program tracing and debugging only.
//
// ARGUMENTS:
//
//    dwAttrib
//       Attribute bits to be decoded.
//
//    pszDest
//       Address of destination string.
//       String must be at least 8 characters long.
//
// RETURNS:
//
//    Pointer to destination string.
//
///////////////////////////////////////////////////////////////////////////////
#ifdef TRACE_COMPRESSION
static LPTSTR FileAttribString(DWORD dwAttrib, LPTSTR pszDest)
{
   if (dwAttrib != (DWORD)-1)
   {
      wsprintf(pszDest, TEXT("%c%c%c%c%c%c%c"),
                  dwAttrib & FILE_ATTRIBUTE_ARCHIVE    ? TEXT('A') : TEXT('.'),
                  dwAttrib & FILE_ATTRIBUTE_COMPRESSED ? TEXT('C') : TEXT('.'),
                  dwAttrib & FILE_ATTRIBUTE_DIRECTORY  ? TEXT('D') : TEXT('.'),
                  dwAttrib & FILE_ATTRIBUTE_HIDDEN     ? TEXT('H') : TEXT('.'),
                  dwAttrib & FILE_ATTRIBUTE_NORMAL     ? TEXT('N') : TEXT('.'),
                  dwAttrib & FILE_ATTRIBUTE_READONLY   ? TEXT('R') : TEXT('.'),
                  dwAttrib & FILE_ATTRIBUTE_SYSTEM     ? TEXT('S') : TEXT('.'));
   }
   else
     lstrcpy(pszDest, TEXT("INVALID"));

   return pszDest;
}
#endif


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: ChgDllRefCnt
//
// DESCRIPTION:
//
//    Adds reference count tracking to the incrementing and decrementing of the
//    module reference count.
//
// ARGUMENTS:
//
//    n
//       Should be +1 or -1.
//
// RETURNS:
//
//    Nothing.
//
///////////////////////////////////////////////////////////////////////////////
__inline void ChgDllRefCnt(INT n)
{
   ASSERT(g_cRefThisDll >= 0 && g_cRefThisDll+(n) >= 0);

   g_cRefThisDll += (n);

#ifdef TRACE_DLL
   DbgOut(TEXT("SHCOMPUI: ChgDllRefCnt. Count = %d"), g_cRefThisDll);
#endif
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CClassFactory_QueryInterface
//
// DESCRIPTION:
//
//    Class factory support for IUnknown::QueryInterface( ).
//    Queries class factory object for a specific interface.
//
// ARGUMENTS:
//
//    pcf
//       Pointer to class factory interface.
//
//    riid
//       Reference to ID of interface being requested.
//
//    ppvOut
//       Destination for address of vtable for requested interface.
//
// RETURNS:
//
//    NOERROR        = Success.
//    E_NOINTERFACE  = Requested interface not supported.
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClassFactory_QueryInterface(IClassFactory *pcf, REFIID riid,
                                                              LPVOID *ppvOut)
{
   CClassFactory *this = IToClass(CClassFactory, cf, pcf);
   HRESULT hResult     = E_NOINTERFACE;

   ASSERT(NULL != this);
   ASSERT(NULL != ppvOut);

#ifdef TRACE_SHEXT
   DbgOut(TEXT("SHCOMPUI: CClassFactory::QueryInterface"));
#endif

   *ppvOut = NULL;

   if (IsEqualIID(riid, &IID_IClassFactory) ||
       IsEqualIID(riid, &IID_IUnknown))
   {
      (LPCLASSFACTORY)*ppvOut = &this->cf;
      this->cRef++;
      hResult = NOERROR;
   }

   return hResult;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CClassFactory_AddRef
//
// DESCRIPTION:
//
//    Class factory support for IUnknown::AddRef( ).
//    Increments object reference count.
//
// ARGUMENTS:
//
//    pcf
//       Pointer to class factory interface.
//
// RETURNS:
//
//    Returns object reference count after it is incremented.
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CClassFactory_AddRef(IClassFactory *pcf)
{
   CClassFactory *this = IToClass(CClassFactory, cf, pcf);

#ifdef TRACE_SHEXT
   DbgOut(TEXT("SHCOMPUI: CClassFactory::AddRef"));
#endif

   ASSERT(NULL != this);

   return ++this->cRef;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CClassFactory_Release
//
// DESCRIPTION:
//
//    Class factory support for IUnknown::Release( ).
//    Decrements object reference count.
//    Deletes object from memory when reference count reaches 0.
//
// ARGUMENTS:
//
//    pcf
//       Pointer to class factory interface.
//
// RETURNS:
//
//    Returns object reference count after it is incremented.
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CClassFactory_Release(IClassFactory *pcf)
{
   CClassFactory *this = IToClass(CClassFactory, cf, pcf);
   ULONG refCnt = 0;

#ifdef TRACE_SHEXT
   DbgOut(TEXT("SHCOMPUI: CClassFactory::Release"));
#endif

   ASSERT(NULL != this);

   if ((refCnt = --this->cRef) == 0)
   {
      LocalFree((HLOCAL)this);
      ChgDllRefCnt(-1);
   }

   return refCnt;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CClassFactory_CreateInstance
//
// DESCRIPTION:
//
//    Generates an instance of the class factory.
//
// ARGUMENTS:
//
//    pcf
//       Pointer to class factory interface.
//
//    punkOuter
//       Pointer to outer object's IUnknown interface.  Only used when
//       object aggregation is requested.
//
//    riid
//       Reference to requested interface ID.
//
//    ppv
//       Destination for address of requested interface.
//
// RETURNS:
//
//
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClassFactory_CreateInstance(IClassFactory *pcf, IUnknown *punkOuter,
                                           REFIID riid, LPVOID *ppv)
{
   CClassFactory *this = IToClass(CClassFactory, cf, pcf);
   HRESULT hResult     = CLASS_E_NOAGGREGATION;

#ifdef TRACE_SHEXT
   DbgOut(TEXT("SHCOMPUI: CClassFactory::CreateInstance"));
#endif

   ASSERT(NULL != this);

   if (NULL == punkOuter)
   {
      hResult = this->pfnCI(punkOuter, riid, ppv);
   }

   return hResult;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CClassFactory_LockServer
//
// DESCRIPTION:
//
//    Explicitly locks the server from unloading regardless of the module
//    reference count.
//    Not used for DLL servers.  Therefore, this implementation is nul.
//
//
// ARGUMENTS:
//    pcf
//       Pointer to class factory object.
//
//    fLock
//       TRUE  = Lock server.
//       FALSE = Unlock server.
//
//
// RETURNS:
//
//    E_NOTIMPL  = Server locking not required for DLL server.
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClassFactory_LockServer(IClassFactory *pcf, BOOL fLock)
{
#ifdef TRACE_SHEXT
   DbgOut(TEXT("SHCOMPUI: CClassFactory::LockServer"));
#endif

   return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CContextMenuExt_QueryInterface
//
// DESCRIPTION:
//
//    Context menu extension support for IUnknown::QueryInterface( ).
//    Queries context menu extension object for a specific interface.
//
// ARGUMENTS:
//
//    pctm
//       Pointer to context menu interface.
//
//    riid
//       Reference to ID of interface being requested.
//
//    ppvOut
//       Destination for address of vtable for requested interface.
//
// RETURNS:
//
//    NOERROR        = Success.
//    E_NOINTERFACE  = Requested interface not supported.
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CContextMenuExt_QueryInterface(IContextMenu *pctm, REFIID riid,
                                                                LPVOID *ppvOut)
{
   CContextMenuExt *this = IToClass(CContextMenuExt, ctm, pctm);
   HRESULT hResult       = NOERROR;

#ifdef TRACE_SHEXT
   DbgOut(TEXT("SHCOMPUI: CContextMenuExt::QueryInterface"));
#endif

   ASSERT(NULL != this);
   ASSERT(NULL != ppvOut);

   *ppvOut = NULL;

   if (IsEqualIID(riid, &IID_IContextMenu) || IsEqualIID(riid, &IID_IUnknown))
   {
      (IContextMenu *)*ppvOut = &this->ctm;
      this->cRef++;
   }
   else if (IsEqualIID(riid, &IID_IShellExtInit))
   {
      (IShellExtInit *)*ppvOut = &this->sei;
      this->cRef++;
   }
   else
      hResult = E_NOINTERFACE;

   return hResult;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CContextMenuExt_AddRef
//
// DESCRIPTION:
//
//    Context menu extension support for IUnknown::AddRef( ).
//    Increments object reference count.
//
// ARGUMENTS:
//
//    pctm
//       Pointer to context menu interface.
//
// RETURNS:
//
//    Returns object reference count after it is incremented.
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CContextMenuExt_AddRef(IContextMenu *pctm)
{
   CContextMenuExt *this = IToClass(CContextMenuExt, ctm, pctm);

#ifdef TRACE_SHEXT
   DbgOut(TEXT("SHCOMPUI: CContextMenuExt::AddRef"));
#endif

   ASSERT(NULL != this);

   return ++this->cRef;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CContextMenuExt_Cleanup
//
// DESCRIPTION:
//
//    Does the cleanup associated with a previous IShellExtInit_Initialize call
//
// ARGUMENTS:
//
//    this
//       Pointer to context menu extension
//
// RETURNS:
//
//    -nothing-
//
///////////////////////////////////////////////////////////////////////////////
void CContextMenu_Cleanup( CContextMenuExt *this )
{
      if (this->pDataObj)
      {
         this->pDataObj->lpVtbl->Release(this->pDataObj);
      }
      //
      // Now release the stgmedium (FEATURE - Replace this with OLE's ReleaseStgMedium
      //
      if (this->medium.pUnkForRelease)
      {
         this->medium.pUnkForRelease->lpVtbl->Release(this->medium.pUnkForRelease);
      }
      else
      {
          switch(this->medium.tymed)
          {
             case TYMED_HGLOBAL:
                GlobalFree(this->medium.hGlobal);
                break;

             case TYMED_ISTORAGE: // depends on pstm/pstg overlap in union
             case TYMED_ISTREAM:
                this->medium.pstm->lpVtbl->Release(this->medium.pstm);
                break;

             default:
                Assert(0);  // unknown type
          }
      }
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CContextMenuExt_Release
//
// DESCRIPTION:
//
//    Context menu extension support for IUnknown::Release( ).
//    Decrements object reference count.
//    Deletes object from memory when reference count reaches 0.
//
// ARGUMENTS:
//
//    pctm
//       Pointer to context menu interface.
//
// RETURNS:
//
//    Returns object reference count after it is decremented.
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CContextMenuExt_Release(IContextMenu *pctm)
{
   CContextMenuExt *this = IToClass(CContextMenuExt, ctm, pctm);
   ULONG refCnt = 0;

#ifdef TRACE_SHEXT
   DbgOut(TEXT("SHCOMPUI: CContextMenuExt::Release"));
#endif

   ASSERT(NULL != this);

   if ((refCnt = --this->cRef) == 0)
   {
      CContextMenu_Cleanup(this);
      LocalFree((HLOCAL)this);

      ChgDllRefCnt(-1);
   }

   return refCnt;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CContextMenuExt_QueryContextMenu
//
// DESCRIPTION:
//
//    Called by NT Shell when requesting menu option text and command numbers.
//
// ARGUMENTS:
//
//    pctm
//       Pointer to context menu interface.
//
//    hMenu
//       Handle to context menu to be modified.
//
//    indexMenu
//       Index where first menu item may be inserted.
//
//    idCmdFirst
//       Lower bound of available menu command IDs.
//
//    idCmdLast
//       Upper bound of available menu command IDs.
//
//    uFlags
//       Flag indicating context of function call.
//
// RETURNS:
//
//    Returns the number of menu items added (excluding separators).
//
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CContextMenuExt_QueryContextMenu(IContextMenu *pctm, HMENU hMenu,
                 UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
   CContextMenuExt *this = IToClass(CContextMenuExt, ctm, pctm);
   BOOL bDisableCompress        = FALSE;
   BOOL bDisableUncompress      = FALSE;
   BOOL bDirectorySelected      = FALSE;
   BOOL bNonCompressibleVol     = FALSE;
   DWORD dwAttribTalley         = 0;
   INT i                        = 0;
   INT cMenuItemsAdded          = 0;
   HCURSOR hCursor              = NULL;
   DRAGINFO di;                      // Drag information.
   LPTSTR pDragFileName = NULL;      // Ptr into list of drag info names.
   LPTSTR pNextName = NULL;          // Lookahead pointer into name list.

#ifdef TRACE_SHEXT
   DbgOut(TEXT("SHCOMPUI: CContextMenuExt::QueryContextMenu"));
#endif

   ASSERT(NULL != this);


   //
   // Only allow addition of Compress/Uncompress when user is pressing
   // shift key.
   //
   // cSelectedFiles will be -1 if user selected only a virtual object.
   // i.e. Control Panel, Printer etc.
   //
   if (GetAsyncKeyState(VK_SHIFT) >= 0 || this->cSelectedFiles <= 0)
      return 0;

   //
   // Determine if we should hide both of the context menu items or
   // disable one of them.
   // If no selected device supports compression, HIDE both items.
   // If a directory is selected, show both menu items.
   // If a directory is not in the selected list, disable a menu item
   // if all of the selected files have the same compression state.
   // i.e.:  All items compressed - disable the "Compress" item.
   // A mix of compression states activates both items.
   //

   dwAttribTalley = 0;   // Attribute talley mask.

   //
   // Attribute talley mask bits.
   //
#define TALLEY_UNCOMPRESSED 0x0001  // Object is an uncompressed file.
#define TALLEY_COMPRESSED   0x0002  // Object is a compressed file.
#define TALLEY_DIRECTORY    0x0004  // Object is a directory.
#define TALLEY_NOCOMPSUPT   0x0008  // At least 1 file from FAT/HPFS drive.

   //
   // Display the hourglass cursor so that the user knows something is
   // happening.  This loop can take a long time on large selections.
   //
   if (hCursor = LoadCursor(NULL, IDC_WAIT))
      hCursor = SetCursor(hCursor);
   ShowCursor(TRUE);

   //
   // Determine if the user has selected drives.
   // Since you can't select a combination of drive(s) and folders/files,
   // if there are ANY drives selected, the first one must be a drive.
   //
   {
      TCHAR szFileName[_MAX_PATH + 1];
      TCHAR szRootName[_MAX_PATH + 1];

      DragQueryFile((HDROP)this->medium.hGlobal, 0, szFileName,
                                                    ARRAYSIZE(szFileName));
      lstrcpy(szRootName, szFileName);
      PathStripToRoot(szRootName);
      this->bDriveSelected = (lstrcmpi(szRootName, szFileName) == 0);
   }

   //
   // Get list of file names selected.
   // The string contains nul-terminated names.
   // The entire list is terminated with a double-nul.
   //
   // FEATURE: We need to write ANSI/UNICODE thunking layer for
   //         DragQueryInfo().
   //
   di.uSize = sizeof(DRAGINFO);
   DragQueryInfo((HDROP)this->medium.hGlobal, &di);
   pDragFileName = pNextName = di.lpFileList;

   for (i = 0; i < this->cSelectedFiles; i++)
   {
      DWORD dwFlags      = 0;
      DWORD dwAttrib     = 0;

      //
      // Set bits in the attribute "talley" word.  This signals the existence of
      // each desired quantity for all selected files.
      //
      if ((dwAttrib = GetFileAttributes(pDragFileName)) != (DWORD)-1)
      {
         if ((dwAttrib & FILE_ATTRIBUTE_DIRECTORY))
            dwAttribTalley |= TALLEY_DIRECTORY;

         if ((dwAttrib & FILE_ATTRIBUTE_COMPRESSED))
            dwAttribTalley |= TALLEY_COMPRESSED;
         else
            dwAttribTalley |= TALLEY_UNCOMPRESSED;
      }

      //
      // Save pointer to next name.
      //
      pNextName += lstrlen(pNextName) + 1;

      if (!(dwAttribTalley & TALLEY_NOCOMPSUPT))
      {
         //
         // Do we have at least one drive that DOES NOT support compression?
         // If so, we don't show the menu items.  This provides the INTERSECTION
         // of capabilities for the selected files per the UI design guide.
         // Note that if GetVolumeInformation fails for a drive, the drive is empty
         // and is therefore uncompressible.
         //
         PathStripToRoot(pDragFileName);
         // GetVolumeInformation requires a trailing backslash.  Append
         // one if this is a UNC path.
         if (PathIsUNC(pDragFileName))
         {
             lstrcat(pDragFileName, c_szBACKSLASH);
         }
         if (GetVolumeInformation(pDragFileName, NULL, 0, NULL, NULL, &dwFlags, NULL, 0))
            dwAttribTalley |= (dwFlags & FS_FILE_COMPRESSION) == 0 ?
                                                TALLEY_NOCOMPSUPT : 0;
         else
            dwAttribTalley |= TALLEY_NOCOMPSUPT;
      }

      //
      // If all of the flag bits are set, no need to check more files.
      // We have all the info we need to properly configure the UI.
      //
      if ( (dwAttribTalley & ((DWORD)-1) ) == (TALLEY_DIRECTORY    |
                                               TALLEY_COMPRESSED   |
                                               TALLEY_UNCOMPRESSED |
                                               TALLEY_NOCOMPSUPT))
      {
         break;
      }

      //
      // Advance name pointer to next name.
      //
      pDragFileName = pNextName;
   }

   //
   // Free the file name list we got through DragQueryInfo().
   //
   if (di.lpFileList)
      SHFree(di.lpFileList);

   //
   // Convert the settings of the talley flag bits to more meaningful names.
   //
   bNonCompressibleVol = (dwAttribTalley & TALLEY_NOCOMPSUPT) != 0;
   bDirectorySelected  = (dwAttribTalley & TALLEY_DIRECTORY) != 0;

   if (!bDirectorySelected)
   {
      bDisableUncompress = (dwAttribTalley &
            (TALLEY_COMPRESSED | TALLEY_UNCOMPRESSED)) == TALLEY_UNCOMPRESSED;
      bDisableCompress   = (dwAttribTalley &
            (TALLEY_COMPRESSED | TALLEY_UNCOMPRESSED)) == TALLEY_COMPRESSED;
   }

   switch(uFlags & 0x0F)  // Upper 28 bits are reserved.
   {
      case CMF_EXPLORE:
         //
         // Win32 SDK says we should only get this flag bit set when the user
         // has selected an object in the left pane of the Explorer. This is a
         // doc bug in the SDK verified by "satona".  We get it via selection
         // in either pane.
         //

      case CMF_NORMAL:

         if (!bNonCompressibleVol)
         {
            INT cchLoaded = 0;
            TCHAR szMenuItem[MAX_MENUITEM_LEN + 1];

            //
            // Regarding item separators; can we always count on there being
            //         an item above and below our new items?  If not, we're
            //         in danger of adding a separator at the top or bottom of
            //         the menu.  BobDay says we'll always have something above
            //         and below us.
            //
            cchLoaded = LoadString(g_hmodThisDll,
                                   bDirectorySelected ? IDS_COMPRESS_MENUITEM_ELLIP :
                                                        IDS_COMPRESS_MENUITEM,
                                   szMenuItem, ARRAYSIZE(szMenuItem));
            ASSERT(cchLoaded > 0);

            InsertMenu(hMenu, indexMenu++, MF_SEPARATOR | MF_BYPOSITION, 0, NULL);
            InsertMenu(hMenu, indexMenu++, MF_STRING | MF_BYPOSITION | (bDisableCompress ? MF_GRAYED : 0),
                                           idCmdFirst + MENUOFS_COMPRESS, szMenuItem);
            cMenuItemsAdded++;
            cchLoaded = LoadString(g_hmodThisDll,
                                   bDirectorySelected ? IDS_UNCOMPRESS_MENUITEM_ELLIP :
                                                        IDS_UNCOMPRESS_MENUITEM,
                                   szMenuItem, ARRAYSIZE(szMenuItem));
            ASSERT(cchLoaded > 0);

            InsertMenu(hMenu, indexMenu++, MF_STRING | MF_BYPOSITION | (bDisableUncompress ? MF_GRAYED : 0),
                                           idCmdFirst + MENUOFS_UNCOMPRESS, szMenuItem);
            cMenuItemsAdded++;
            InsertMenu(hMenu, indexMenu,   MF_SEPARATOR | MF_BYPOSITION, 0, NULL);

         }
         break;

      case CMF_DEFAULTONLY:
      case CMF_VERBSONLY:
         //
         // SDK Docs say Context Menu Extensions should ignore these.
         //
         break;

      default:
         break;
   }

   //
   // Restore original cursor and return number of menu items added.
   //
   if (hCursor)
      SetCursor(hCursor);
   ShowCursor(FALSE);

   return cMenuItemsAdded;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CContextMenuExt_InvokeCommand
//
// DESCRIPTION:
//
//    Called by the shell whenever the user selects one of the registered
//    items on the context menu.
//
//    Or may be called programmatically with one of the following verb
//    strings:
//               "COMPRESS"    to compress files.
//               "UNCOMPRESS"  to uncompress files.
//
//               These verb names are case-sensitive and language-
//               insensitive.
//
// ARGUMENTS:
//
//    pctm
//       Pointer to the context menu interface.
//
//    pici
//       Pointer to the command info structure associated with the selected
//       menu command.
//
// RETURNS:
//
//    NOERROR              = Success
//    OLEOBJ_E_INVALIDVERB = Invalid verb was specified in programatic
//                           invocation.
//    E_FAIL               = User aborted operation or an error occured during
//                           compression/uncompression.  We should have more
//                           descriptive failure return info.  The original
//                           implementation of compression in WinFile only
//                           returned TRUE/FALSE.  In the interest of time,
//                           that "feature" was retained.
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CContextMenuExt_InvokeCommand(IContextMenu *pctm,
                                           LPCMINVOKECOMMANDINFO pici)
{
   HRESULT hResult   = NOERROR;
   INT i = 0;
   CContextMenuExt *this = IToClass(CContextMenuExt, ctm, pctm);
   BOOL bCompressing = FALSE;
   BOOL bShowUI      = FALSE;
   HWND hwndParent   = NULL;

#ifdef TRACE_SHEXT
   DbgOut(TEXT("SHCOMPUI: CContextMenuExt::InvokeCommand"));
#endif

   ASSERT(NULL != pici);

   //
   // Caller can request that no UI be activated.
   //
   bShowUI = (pici->fMask & CMIC_MASK_FLAG_NO_UI) == 0;

   //
   // Parent all displayed dialogs with the handle passed in from the caller.
   // Use the desktop as a default if one wasn't provided.
   //
   if ((hwndParent = pici->hwnd) == NULL)
      hwndParent = GetDesktopWindow();

   if (HIWORD(pici->lpVerb) == 0)
   {
      //
      // InvokeCommand was called through the context menu extension protocol.
      //
      bCompressing = LOWORD(pici->lpVerb) == MENUOFS_COMPRESS;
   }
   else
   {
      //
      // InvokeCommand was called programatically.
      // If lpVerb is "COMPRESS", compress the file(s).
      // If lpVerb is "UNCOMPRESS", uncompress the file(s).
      // Otherwise, do nothing and return OLE error code.
      //
      TCHAR szValidVerb[MAX_CMDVERB_LEN + 1];
      TCHAR szVerb[MAX_CMDVERB_LEN + 1];
      INT cchLoaded = 0;

      //
      // Convert verb string to unicode.
      //
      MultiByteToWideChar(CP_ACP, 0L, pici->lpVerb, -1, szVerb, ARRAYSIZE(szVerb));

      bCompressing = FALSE;

      cchLoaded = LoadString(g_hmodThisDll, IDS_COMPRESS_CMDVERB, szValidVerb,
                                                        ARRAYSIZE(szValidVerb));
      ASSERT(cchLoaded > 0);

      if (!lstrcmp(szValidVerb, szVerb))
      {
         bCompressing = TRUE;
      }
      else
      {
         cchLoaded = LoadString(g_hmodThisDll, IDS_UNCOMPRESS_CMDVERB, szValidVerb,
                                                            ARRAYSIZE(szValidVerb));
         ASSERT(cchLoaded > 0);
         if (!lstrcmp(szValidVerb, szVerb))
         {
            bCompressing = FALSE;
         }
         else
         {
            //
            // Verb isn't COMPRESS or UNCOMPRESS.
            //
            hResult = OLEOBJ_E_INVALIDVERB;
         }
      }
   }

   //
   // Do the compression/uncompression.
   //
   if (hResult == NOERROR)
   {
      SCCA_CONTEXT Context;        // Compression context structure.

      SCCA_CONTEXT_INIT(&Context); // Initialize context.

      for (i = 0; i < this->cSelectedFiles; i++)
      {
         TCHAR szFileName[_MAX_PATH + 1];

         //
         // Get the name of the file to compress.
         //
         DragQueryFile((HDROP)this->medium.hGlobal, i, szFileName, ARRAYSIZE(szFileName));

         //
         // Compress/uncompress file.  Return value of FALSE indicates either an error
         // occured or the user cancelled the operation.  In either case, don't process
         // any more files.
         //
         if (!ShellChangeCompressionAttribute(hwndParent, szFileName, &Context,
                                              bCompressing, bShowUI))
         {
            hResult = E_FAIL;
            break;
         }
      }
   }

   return hResult;
}



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CContextMenuExt_GetCommandString
//
// DESCRIPTION:
//
//    Called by the shell when it wants a text string associated with a menu
//    item.  Status bar text for example or a menu command verb.
//
// ARGUMENTS:
//
//    pctm
//       Pointer to the context menu interface.
//
//    idCmd
//       Integer identifier of the command in question.  The number is the
//       offset of the menu item in the set of added menu items, based 0.
//
//    uFlags
//       Indicates what type of service the shell is requesting.
//
//    pwReserved
//       Unused.
//
//    pszName
//       Destination for menu item character string.  Provided by shell.
//
//    cchMax
//       Max size of destination buffer.  Provided by shell.
//
// RETURNS:
//
//    NOERROR = Success.
//    E_FAIL  = Requested menu idCmd not recognized.
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CContextMenuExt_GetCommandString(IContextMenu *pctm, UINT_PTR idCmd,
                                              UINT uFlags, UINT *pwReserved, LPSTR pszName,
                                              UINT cchMax)
{
   CContextMenuExt *this = IToClass(CContextMenuExt, ctm, pctm);
   HRESULT hResult       = NOERROR;

#ifdef TRACE_SHEXT
   DbgOut(TEXT("SHCOMPUI: CContextMenuExt::GetCommandString idCmd = %d"), idCmd);
#endif

   ASSERT(NULL != this);
   ASSERT(NULL != pszName);

   //
   // Start with destination buffer blank.
   //
   if (cchMax > 0)
      pszName[0] = TEXT('\0');


   if (idCmd >= MENUOFS_FIRST && idCmd <= MENUOFS_LAST)
   {
      DWORD *pStrIdArray = NULL;
      BOOL bUnicode      = FALSE;
      DWORD dwCmdVerbIds[]         = { IDS_COMPRESS_CMDVERB,
                                       IDS_UNCOMPRESS_CMDVERB };
      DWORD dwSbarTextIds[]        = { IDS_COMPRESS_SBARTEXT,
                                       IDS_UNCOMPRESS_SBARTEXT };
      DWORD dwSbarTextMultIds[]    = { IDS_COMPRESS_SBARTEXT_M,
                                       IDS_UNCOMPRESS_SBARTEXT_M };
      DWORD dwSbarDrvTextIds[]     = { IDS_COMPRESS_SBARTEXT_DRV,
                                       IDS_UNCOMPRESS_SBARTEXT_DRV };
      DWORD dwSbarDrvTextMultIds[] = { IDS_COMPRESS_SBARTEXT_DRV_M,
                                       IDS_UNCOMPRESS_SBARTEXT_DRV_M };

      switch(uFlags)
      {
         //
         // Provide help text for menu item.
         //
         case GCS_HELPTEXTW:
         case GCS_HELPTEXTA:
            //
            // If drives selected, use "Drive" strings. Otherwise, use "File"
            // strings. Also address multiplicity.
            //
            if (this->cSelectedFiles == 1)
               pStrIdArray = this->bDriveSelected ? dwSbarDrvTextIds : dwSbarTextIds;
            else
               pStrIdArray = this->bDriveSelected ? dwSbarDrvTextMultIds : dwSbarTextMultIds;

            bUnicode    = uFlags == GCS_HELPTEXTW;
            break;

         //
         // Provide command verb recognized by InvokeCommand( ).
         //
         case GCS_VERBW:
         case GCS_VERBA:
            pStrIdArray = dwCmdVerbIds;
            bUnicode    = uFlags == GCS_VERBW;
            break;

         //
         // Validate that the menu cmd exists.
         //
         case GCS_VALIDATE:
            hResult = NOERROR;
            break;

         default:
            break;
      }

      //
      // If we've identified what array to get the string resource ID from, load
      // the ANSI or UNICODE version of the string related to the command id.
      //
      if (NULL != pStrIdArray)
      {
         INT cchLoaded = 0;

         if (bUnicode)
            cchLoaded = LoadStringW(g_hmodThisDll, *(pStrIdArray + idCmd), (LPWSTR)pszName, cchMax);
         else
            cchLoaded = LoadStringA(g_hmodThisDll, *(pStrIdArray + idCmd), pszName, cchMax);

         ASSERT(cchLoaded > 0);
      }
   }
   else
      hResult = E_FAIL;

   return hResult;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CShellExtInit_QueryInterface
//
// DESCRIPTION:
//
//    Called by the shell to obtain an interface from the shell extension.
//
// ARGUMENTS:
//
//    psei
//       Pointer to the shell extension interface.
//
//    riid
//       Reference to the requested interface ID.
//
//    ppvOut
//       Address of destination for resulting interface pointer.
//
//
// RETURNS:
//
//    NOERROR
//    E_NOINTERFACE
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CShellExtInit_QueryInterface(IShellExtInit *psei, REFIID riid,
                                                               LPVOID *ppvOut)
{
   CContextMenuExt *this = PSEI2PCMX(psei);

#ifdef TRACE_SHEXT
   DbgOut(TEXT("SHCOMPUI: CShellExtInit::QueryInterface"));
#endif

   ASSERT(NULL != this);
   ASSERT(NULL != ppvOut);

   return CContextMenuExt_QueryInterface(&this->ctm, riid, ppvOut);
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CShellExtInit_AddRef
//
// DESCRIPTION:
//
//    Increments the reference count for the shell extension init
//    interface.
//
// ARGUMENTS:
//
//    psei
//       Pointer to the shell extension interface.
//
// RETURNS:
//
//    New reference counter value.
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CShellExtInit_AddRef(IShellExtInit *psei)
{
   CContextMenuExt *this = PSEI2PCMX(psei);

#ifdef TRACE_SHEXT
   DbgOut(TEXT("SHCOMPUI: CShellExtInit::AddRef"));
#endif

   ASSERT(NULL != this);

   return CContextMenuExt_AddRef(&this->ctm);
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CShellExtInit_Release
//
// DESCRIPTION:
//
//    Decrements the reference count for the shell extension init
//    interface.  When count reaches 0, the interface object is
//    deleted.
//
// ARGUMENTS:
//
//    psei
//       Pointer to the shell extension interface.
//
// RETURNS:
//
//    New reference counter value.
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CShellExtInit_Release(IShellExtInit *psei)
{
   CContextMenuExt *this = PSEI2PCMX(psei);
   ULONG refCnt          = 0;

#ifdef TRACE_SHEXT
   DbgOut(TEXT("SHCOMPUI: CShellExtInit::Release"));
#endif

   ASSERT(NULL != this);

   return CContextMenuExt_Release(&this->ctm);
}


///////////////////////////////////////////////////////////////////////////////
//
// CShellExtInit::Initialize
//
// Called by the shell to initialize the shell extension.
//
// Arguments:
//
//    psei
//       Pointer to the IShellExtInit interface.
//
//    pidlFolder
//       Pointer to item ID list of parent folder.
//
//    lpdobj
//       Pointer to data object containing selected file names.
//
//    hkeyProgID
//       Registry class of the file object that has focus.
//
// RETURNS:
//
//    S_OK
//    E_FAIL
//    E_INVALIDARG
//    E_UNEXPECTED
//    E_OUTOFMEMORY
//    DV_E_LINDEX
//    DV_E_FORMATETC
//    DV_E_TYMED
//    DV_E_DVASPECT
//    OLE_E_NOTRUNNING
//    STG_E_MEDIUMFULL
//
///////////////////////////////////////////////////////////////////////////////
static STDMETHODIMP CShellExtInit_Initialize(IShellExtInit *psei,
                 LPCITEMIDLIST pidlFolder, LPDATAOBJECT lpdobj, HKEY hkeyProgID)
{
   CContextMenuExt *this = PSEI2PCMX(psei);
   FORMATETC fe          = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
   HRESULT hResult       = NOERROR;

#ifdef TRACE_SHEXT
   DbgOut(TEXT("SHCOMPUI: CShellExtInit::Initialize"));
#endif

   ASSERT(NULL != this);

   //
   // According to Win32 SDK, Initialize can be called more than once.
   //
   CContextMenu_Cleanup(this);

   if (NULL != lpdobj)
   {
      this->pDataObj = lpdobj;
      lpdobj->lpVtbl->AddRef(lpdobj);

      //
      // If we are allowed to get data from the data object, save the medium
      // descriptor in our context menu extension object.  We'll use it to
      // iterate through the names of the selected files in
      // CContextMenuExt::InvokeCommand( ).
      //
      hResult = lpdobj->lpVtbl->GetData(lpdobj, &fe, &this->medium);
      if (NOERROR == hResult)
         this->cSelectedFiles = DragQueryFile((HDROP)this->medium.hGlobal, (DWORD)-1, NULL, 0);
      else
         this->cSelectedFiles = 0;
   }
   else
      hResult = E_FAIL;

   return hResult;
}

///////////////////////////////////////////////////////////////////////////////
//                              CLASS VTABLES
///////////////////////////////////////////////////////////////////////////////
#pragma data_seg(".text")

//
// Create the class factory vtbl in a read-only segment.
//
IClassFactoryVtbl c_vtblCClassFactory = {
   CClassFactory_QueryInterface,
   CClassFactory_AddRef,
   CClassFactory_Release,
   CClassFactory_CreateInstance,
   CClassFactory_LockServer
};

//
// Create the context menu extension vtbl in a read-only segment.
//
IContextMenuVtbl c_vtblContextMenuExt = {
   CContextMenuExt_QueryInterface,
   CContextMenuExt_AddRef,
   CContextMenuExt_Release,
   CContextMenuExt_QueryContextMenu,
   CContextMenuExt_InvokeCommand,
   CContextMenuExt_GetCommandString
};

//
// Create the shell extension initialization vtbl in a read-only segment.
//
IShellExtInitVtbl c_vtblShellExtInit = {
   CShellExtInit_QueryInterface,
   CShellExtInit_AddRef,
   CShellExtInit_Release,
   CShellExtInit_Initialize
};

#pragma data_seg()


///////////////////////////////////////////////////////////////////////////////
//
// CContextMenuExt_CreateInstance
//
// Context menu extension instance generator.  Creates a context menu extension
// object and returns a pointer to the requested interface.
//
// Arguments:
//
//    punkOuter
//       Not used for objects that don't support aggregation.  We don't support
//       aggregation so we don't use it.
//
//    riid
//       Reference to the requested interface ID.
//
//    ppvOut
//       Address of the destination for the interface pointer.
//
// RETURNS:
//
//    NOERROR                = Success.
//    E_OUTOFMEMORY          = Can't allocate extension object.
//    E_NOINTERFACE          = Interface not supported.
//    CLASS_E_NOAGGREGATION  = Aggregation not supported.
//
///////////////////////////////////////////////////////////////////////////////
static HRESULT CContextMenuExt_CreateInstance(IUnknown *punkOuter,
                                              REFIID riid, void **ppvOut)
{
   CContextMenuExt *pcmx = NULL;
   HRESULT hResult       = NOERROR;

#ifdef TRACE_SHEXT
   DbgOut(TEXT("SHCOMPUI: CContextMenuExt::CreateInstance"));
#endif

   ASSERT(NULL != ppvOut);

   *ppvOut = NULL;

   if (NULL == punkOuter)
   {
      pcmx = (CContextMenuExt *)LocalAlloc(LPTR, sizeof(CContextMenuExt));
      if (NULL != pcmx)
      {
         pcmx->ctm.lpVtbl = &c_vtblContextMenuExt;  // Context menu ext vtable ptr.
         pcmx->sei.lpVtbl = &c_vtblShellExtInit;    // Shell extention int vtable ptr.
         pcmx->cRef = 0;                            // Initialize reference counter.
         pcmx->medium.tymed = TYMED_NULL;           // Not yet initialized by shell.
         pcmx->medium.hGlobal = (HGLOBAL)NULL;      // Not yet initialized by shell.
         pcmx->medium.pUnkForRelease = NULL;        // Not yet initialized by shell.
         pcmx->cSelectedFiles = 0;                  // Not yet initialized by shell.
         pcmx->bDriveSelected = FALSE;              // No drives selected yet.
         pcmx->pDataObj = NULL;
         hResult = c_vtblContextMenuExt.QueryInterface(&pcmx->ctm, riid, ppvOut);
         ChgDllRefCnt(+1);
      }

      else
         hResult = E_OUTOFMEMORY;
   }
   else
      hResult = CLASS_E_NOAGGREGATION;  // Extension doesn't support aggregation.

   return hResult;
}

///////////////////////////////////////////////////////////////////////////////
//
// CreateClassObject
//
// Creates a class factory object returning a pointer to its IUnknown interface.
//
// Arguments:
//
//    riid
//       Reference to interface on class factory object.
//
//    pfcnCI
//       Pointer to instance creation function.
//       In this application, this is CContextMenuExt_CreateInstance.
//
//    ppvOut
//       Destination for pointer to class factory interface (Vtable).
//
// RETURNS:
//
//    NOERROR        = Success.
//    E_NOINTERFACE  = Interface not supported.
//    E_OUTOFMEMORY  = Can't create class factory object.
//
///////////////////////////////////////////////////////////////////////////////
STDAPI CreateClassObject(REFIID riid, LPFNCREATEINSTANCE pfnCI, LPVOID *ppvOut)
{
   HRESULT hResult = NOERROR;

#ifdef TRACE_SHEXT
   DbgOut(TEXT("SHCOMPUI: CreateClassObject"));
#endif

   ASSERT(NULL != ppvOut);
   ASSERT(NULL != pfnCI);

   *ppvOut = NULL;                 // Initialize pointer transfer buffer.

   if (IsEqualIID(riid, &IID_IClassFactory))
   {
      //
      // Allocate the class factory structure.
      //
      CClassFactory *pcf = (CClassFactory *)LocalAlloc(LPTR, sizeof(CClassFactory));
      if (NULL != pcf)
      {
         pcf->cf.lpVtbl = &c_vtblCClassFactory;  // Assign ptr to vtbl.
         pcf->cRef++;                            // Increment interface ref count.
         pcf->pfnCI = pfnCI;                     // Assign ptr instance creation proc.
         (IClassFactory *)*ppvOut = &pcf->cf;    // Return ptr to vtbl (interface).
         ChgDllRefCnt(+1);
      }
      else
         hResult = E_OUTOFMEMORY;    // Cannot get or use shell memory allocator interface.
   }
   else
      hResult = E_NOINTERFACE;      // Cannot produce requested interface.

return hResult;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: DllGetClassObject
//
// DESCRIPTION:
//
//    Called by NT Shell to retrieve the interface to the Class factory.
//
// ARGUMENTS:
//
//    rclsid
//       Reference to class ID that identifies the type of object that the
//       class factory will be asked to create.
//
//    riid
//       Reference to interface ID on the class factory object.
//
//    ppvOut
//       Destination location for class factory object pointer after instantiation.
//
// RETURNS:
//
//    NOERROR                   = Success.
//    E_OUTOFMEMORY             = Can't create class factory object.
//    E_NOINTERFACE             = Interface not supported.
//    CLASS_E_CLASSNOTAVAILABLE = Context menu extension not available.
//
///////////////////////////////////////////////////////////////////////////////
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvOut)
{
   HRESULT hResult = CLASS_E_CLASSNOTAVAILABLE;

#ifdef TRACE_SHEXT
   DbgOut(TEXT("SHCOMPUI: DllGetClassObject"));
#endif

   ASSERT(NULL != ppvOut);

   *ppvOut = NULL;

   //
   // Call the extension-provided creation function corresponding
   // to the class ID of the requested extension.
   //
   if (IsEqualIID(rclsid, &CLSID_CompressMenuExt ))
   {
      hResult = CreateClassObject(riid,
                (LPFNCREATEINSTANCE)CContextMenuExt_CreateInstance, ppvOut);
   }

#ifdef DBG
   if (hResult != NOERROR)
      DbgOut(TEXT("SHCOMPUI: Context menu extension [CLSID_CompressMenuExt] creation failed."));
#endif

   return hResult;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: DllCanUnloadNow
//
// DESCRIPTION:
//
//    Called by NT to determine if DLL can be unloaded.
//
// ARGUMENTS:
//
//    None.
//
// RETURNS:
//
//    S_FALSE   = Can't unload.
//    S_OK      = OK to unload.
//
///////////////////////////////////////////////////////////////////////////////
STDAPI DllCanUnloadNow(void)
{

#ifdef TRACE_SHEXT
   DbgOut(TEXT("SHCOMPUI: DllCanUnloadNow.  Dll reference count = %d"), g_cRefThisDll);
#endif

   ASSERT(g_cRefThisDll >= 0);

   //
   // I test for <= 0 so that the DLL can be unloaded even if the ref
   // count drops below 0 (reference count error).  The preceding
   // ASSERT( ) catches this during development.  This means that
   // the ref counter has to be signed.
   //
   return ResultFromScode((g_cRefThisDll <= 0) ? S_OK : S_FALSE);
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: DllMain
//
// DESCRIPTION:
//
//    Dll entry point.
//
///////////////////////////////////////////////////////////////////////////////
int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
   TCHAR szLocaleInfo[20];

   switch(dwReason)
   {
      case DLL_PROCESS_ATTACH:
#ifdef TRACE_DLL
         DbgOut(TEXT("SHCOMPUI: DLL_PROCESS_ATTACH"));
#endif
         g_hmodThisDll  = hInstance;
         g_hProcessHeap = GetProcessHeap();

         DisableThreadLibraryCalls(hInstance);

         //
         // Create/Open semaphore to prevent re-entrancy.
         //
         g_hSemaphore = CreateSemaphore(NULL, 1, 1, SZ_SEMAPHORE_NAME);
         if (GetLastError() == ERROR_ALREADY_EXISTS)
            g_hSemaphore = OpenSemaphore(SEMAPHORE_ALL_ACCESS, FALSE, SZ_SEMAPHORE_NAME);

         if (NULL == g_hSemaphore)
            return FALSE;       // Can't create/open semaphore object.

         //
         // Prepare number format info for current locale.
         // Used in progress dialog display of 64-bit integers.
         //
         g_NumberFormat.NumDigits    = 0;  // This is locale-insensitive.
         g_NumberFormat.LeadingZero	 = 0;  // So is this.

         GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szLocaleInfo, ARRAYSIZE(szLocaleInfo));
         g_NumberFormat.Grouping       = StrToLong(szLocaleInfo);

         GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, g_szDecimalSep, ARRAYSIZE(g_szDecimalSep));
         g_NumberFormat.lpDecimalSep   = g_szDecimalSep;

         GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, g_szThousandSep, ARRAYSIZE(g_szThousandSep));
         g_NumberFormat.lpThousandSep  = g_szThousandSep;

         GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_INEGNUMBER, szLocaleInfo, ARRAYSIZE(szLocaleInfo));
         g_NumberFormat.NegativeOrder  = StrToLong(szLocaleInfo);

         break;

      case DLL_PROCESS_DETACH:
#ifdef TRACE_DLL
         DbgOut(TEXT("SHCOMPUI: DLL_PROCESS_DETACH"));
#endif
         CloseHandle(g_hSemaphore);
         break;

      case DLL_THREAD_ATTACH:
#ifdef TRACE_DLL
         DbgOut(TEXT("SHCOMPUI: DLL_THREAD_ATTACH"));
#endif
         break;

      case DLL_THREAD_DETACH:
#ifdef TRACE_DLL
         DbgOut(TEXT("SHCOMPUI: DLL_THREAD_DETACH"));
#endif
         break;

      default:
         break;
   }
   return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: FormatStringWithArgs
//
// DESCRIPTION:
//
//    Formats a text string with variable arguments.
//
// ARGUMENTS:
//
//    pszFormat
//       Address of format text string using %1,%2 etc. format specifiers.
//
//    pszBuffer
//       Address of destination buffer.
//
//    nSize
//       Number of characters in destination buffer.
//
//    ...
//       Variable length list of replacement parameters.
//
// RETURNS:
//
//    Returns number of characters copied to buffer.
//    0 = Error.  GetLastError() if you're interested in why.
//
///////////////////////////////////////////////////////////////////////////////
static DWORD FormatStringWithArgs(LPCTSTR pszFormat, LPTSTR pszBuffer,
                                                       DWORD nSize, ...)
{
   DWORD dwCharCount   = 0;
   va_list args;

   ASSERT(NULL != pszBuffer);
   ASSERT(NULL != pszFormat);

   //
   // Format the resource string by replacing parameters if present.
   //
   va_start(args, nSize);
   dwCharCount = FormatMessage(FORMAT_MESSAGE_FROM_STRING,
                          pszFormat,
                          0,
                          0,
                          pszBuffer,
                          nSize,
                          &args);
   va_end(args);

   return dwCharCount;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: LoadStringWithArgs
//
// DESCRIPTION:
//
//    Formats a resource string with variable arguments.
//
// ARGUMENTS:
//
//    hInstance
//       Instance handle for module containing resource string.
//
//    uId
//       Resource string ID.  String may contain embedded formatting characters
//       for replaceable parameters (i.e. "Delete file %1 ?")
//
//    szBuffer
//       Destination buffer.
//
//    nSize
//       Number of characters in destination buffer.
//
//    ...
//       Variable length list of replacement parameters.
//
// RETURNS:
//
//    Returns number of characters copied to buffer.
//    0 = Error.  GetLastError() if you're interested in why.
//    Function does set last error to E_OUTOFMEMORY on LocalAlloc fail.
//
///////////////////////////////////////////////////////////////////////////////
static DWORD LoadStringWithArgs(HINSTANCE hInstance, UINT uId,
                                           LPTSTR pszBuffer, DWORD nSize, ...)
{
   DWORD dwCharCount = 0;
   LPTSTR pszFormat  = NULL;
   va_list args;

   ASSERT(NULL != pszBuffer);

   //
   // Allocate a buffer for the resource string.
   //
   if ((pszFormat = LocalAlloc(LMEM_FIXED, nSize * sizeof(TCHAR))) != NULL)
   {
      //
      // Load the resource string from the specified module.
      //
      if (LoadString(hInstance, uId, pszFormat, nSize) != 0)
      {
         va_start(args, nSize);
         dwCharCount = FormatMessage(FORMAT_MESSAGE_FROM_STRING,
                                pszFormat,
                                0,
                                0,
                                pszBuffer,
                                nSize,
                                &args);
         va_end(args);
      }
      LocalFree(pszFormat);
   }
   else
      SetLastError((DWORD)E_OUTOFMEMORY);

   return dwCharCount;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CenterWindowInParent
//
// DESCRIPTION:
//
//    Positions a window centered in its parent.
//    This function was taken from WinFile.
//
// ARGUMENTS:
//
//    hwnd
//       Handle of window to be centered.
//
//
// RETURNS:
//
//    Nothing.
//
///////////////////////////////////////////////////////////////////////////////
static VOID CenterWindowInParent(HWND hwnd)
{
    RECT    rect;
    RECT    rectParent;
    HWND    hwndParent;
    LONG    Style;

    //
    //  Get window rect.
    //
    GetWindowRect(hwnd, &rect);

    //
    //  Get parent rect.
    //
    Style = GetWindowLong(hwnd, GWL_STYLE);
    if ((Style & WS_CHILD) == 0)
    {
        hwndParent = GetDesktopWindow();
    }
    else
    {
        hwndParent = GetParent(hwnd);
        if (hwndParent == NULL)
        {
            hwndParent = GetDesktopWindow();
        }
    }
    GetWindowRect(hwndParent, &rectParent);

    //
    //  Center the child in the parent.
    //
    rect.left = rectParent.left + (((rectParent.right - rectParent.left) - (rect.right - rect.left)) >> 1);
    rect.top  = rectParent.top +  (((rectParent.bottom - rectParent.top) - (rect.bottom - rect.top)) >> 1);

    //
    //  Move the child into position.
    //
    SetWindowPos( hwnd,
                  NULL,
                  rect.left,
                  rect.top,
                  0,
                  0,
                  SWP_NOSIZE | SWP_NOZORDER );

    SetForegroundWindow(hwnd);
}



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CompressSubsConfirmDlgProc
//
// DESCRIPTION:
//
//    Message proc for compression UI confirmation dialog.  The dialog is
//    displayed whenever a selected directory is about to be compressed or
//    uncompressed.  The dialog includes a message stating that all files
//    in the selected directory are about to be compressed/uncompressed.
//    Included is a checkbox that may be checked to approve compression/
//    uncompression of all sub-folders.
//
// ARGUMENTS:
//
//    wParam
//       Unused.
//
//    lParam
//       Address of a "Compression Descriptor" (type CompressionDesc).
//       The descriptor contains the name of the file to be compresssed/
//       uncompressed along with a flag value indicating which operation
//       is being performed.
//
//
// RETURNS:
//
//    0  = User pressed Cancel button.  Don't compress this folder.
//          (COMPRESS_CANCELLED)
//    1  = User pressed OK button.  Sub-folder checkbox is unchecked.
//          (COMPRESS_SUBSNO)
//    2  = User pressed OK button.  Sub-folder checkbox is checked.
//          (COMPRESS_SUBSYES)
//
///////////////////////////////////////////////////////////////////////////////
static INT_PTR CALLBACK CompressSubsConfirmDlgProc(HWND hDlg, UINT uMsg,
                                                   WPARAM wParam, LPARAM lParam)
{
   //
   // Dialog message string resource IDs.  Array indexes map directly to values
   // of lParam.
   //
   UINT uDlgTextIds[] = { IDS_UNCOMPRESS_CONFIRMATION, IDS_COMPRESS_CONFIRMATION };
   UINT uCbxTextIds[] = { IDS_UNCOMPRESS_ALSO,         IDS_COMPRESS_ALSO         };
   UINT uActionTextIds[] = { IDS_UNCOMPRESS_ACTION,    IDS_COMPRESS_ACTION       };

   TCHAR szDlgText[40 + _MAX_PATH];         // Dialog text resource string buffer.
   CompressionDesc *cd = (CompressionDesc *)lParam;
   UINT cchLoaded = 0;

   switch(uMsg)
   {
      case WM_INITDIALOG:
         ASSERT(NULL != (void *)lParam);

         //
         // Initialize the "Compress/Uncompress all files in..." message.
         //
         LoadStringWithArgs(g_hmodThisDll, uDlgTextIds[cd->bCompress], szDlgText,
                                ARRAYSIZE(szDlgText), cd->szFileName);
         SetDlgItemText(hDlg, IDC_COMPRESS_CONFIRM_TEXT, szDlgText);

         //
         // Initialize the "This action compresses..." message.
         //
         cchLoaded = LoadString(g_hmodThisDll, uActionTextIds[cd->bCompress],
                                              szDlgText, ARRAYSIZE(szDlgText));
         ASSERT(cchLoaded > 0);
         SetDlgItemText(hDlg, IDC_COMPRESS_ACTION_TEXT, szDlgText);

         //
         // Initialize the "also compress/uncompress subfolders" checkbox message.
         //
         cchLoaded = LoadString(g_hmodThisDll, uCbxTextIds[cd->bCompress], szDlgText,
                                                                 ARRAYSIZE(szDlgText));
         ASSERT(cchLoaded > 0);

         SetDlgItemText(hDlg, IDC_COMPRESS_SUBFOLDERS,  szDlgText);

         return TRUE;

      case WM_COMMAND:
         //
         // Handle user button selections.
         //
         switch(wParam)
         {
            case IDOK:
               EndDialog(hDlg, Button_GetCheck(GetDlgItem(hDlg, IDC_COMPRESS_SUBFOLDERS)) ?
                                                                COMPRESS_SUBSYES :
                                                                COMPRESS_SUBSNO);
               return TRUE;

            case IDCANCEL:
               g_pContext->uCompletionReason = SCCA_REASON_USERCANCEL;
               EndDialog(hDlg, COMPRESS_CANCELLED);

               //
               // Fall through to return TRUE.
               //

            case IDC_COMPRESS_SUBFOLDERS:
               //
               // Do nothing when the checkbox is selected.
               //
               return TRUE;
         }
      }

      return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CompressProgressYield
//
// DESCRIPTION:
//
//   Allow other messages including Dialog messages for Modeless dialog to be
//   processed while we are Compressing and Uncompressing files.  This message
//   loop is similar to "wfYield" in treectl.c except that it allows for the
//   processing of Modeless dialog messages also (specifically for the Progress
//   Dialogs).
//
//   Since the file/directory Compression/Uncompression is done on a single
//   thread (in order to keep it synchronous with the existing Set Attributes
//   processing) we need to provide a mechanism that will allow a user to
//   Cancel out of the operation and also allow window messages, like WM_PAINT,
//   to be processed by other Window Procedures.
//
//   Taken from WinFile.  Removed MDI-related processing.
//
// ARGUMENTS:
//
//    None.
//
// RETURNS:
//
//    Nothing.
//
///////////////////////////////////////////////////////////////////////////////
static VOID CompressProgressYield(void)
{
    MSG msg;

    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
        if (!g_hdlgProgress || !IsDialogMessage(g_hdlgProgress, &msg))
        {
           TranslateMessage(&msg);
           DispatchMessage(&msg);
        }
    }
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: DisplayUncompressProgress
//
// DESCRIPTION:
//
//  Update the progress of uncompressing files.
//
//   This routine uses the global variables to update the Dialog box items
//   which display the progress through the uncompression process.  The global
//   variables are updated by individual routines.  An ordinal value is sent
//   to this routine which determines which dialog box item to update.
//   Taken from WinFile.
//
//
// ARGUMENTS:
//
//    iType
//       Control value to determine what is to be updated.
//       Value names are self-descriptive.
//
// RETURNS:
//
//    Nothing.
//
///////////////////////////////////////////////////////////////////////////////
static VOID DisplayUncompressProgress(int iType)
{
    TCHAR szNum[30];

    if (!g_bShowProgress)
    {
        return;
    }

    switch (iType)
    {
        case ( PROGRESS_UPD_FILEANDDIR ) :
        case ( PROGRESS_UPD_FILENAME ) :
        {
            SetDlgItemText(g_hdlgProgress, IDC_UNCOMPRESS_FILE, g_szFile);
            if (iType != PROGRESS_UPD_FILEANDDIR)
            {
                break;
            }

            // else...fall thru
        }
        case ( PROGRESS_UPD_DIRECTORY ) :
        {
            RECT rect;
            //
            //  Preprocess the directory name to shorten it to fit
            //  into the alloted space.
            //
            GetWindowRect(GetDlgItem(g_hdlgProgress, IDC_UNCOMPRESS_DIR), &rect);
            DrawTextEx(g_hdcDirectoryTextCtrl, g_szDirectory, lstrlen(g_szDirectory), &rect, DT_MODIFYSTRING | DT_PATH_ELLIPSIS, NULL);
            SetDlgItemText(g_hdlgProgress, IDC_UNCOMPRESS_DIR, g_szDirectory);

            break;
        }
        case ( PROGRESS_UPD_DIRCNT ) :
        {
            AddCommas((DWORD)g_cTotalDirectories, szNum);
            SetDlgItemText(g_hdlgProgress, IDC_UNCOMPRESS_DIRCNT, szNum);

            break;
        }
        case ( PROGRESS_UPD_FILENUMBERS ) :
        case ( PROGRESS_UPD_FILECNT ) :
        {
            AddCommas((DWORD)g_cTotalFiles, szNum);
            SetDlgItemText(g_hdlgProgress, IDC_UNCOMPRESS_FILECNT, szNum);

            break;
        }
    }

    CompressProgressYield();
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: UncompressProgDlg
//
// DESCRIPTION:
//
//   Display progress information.
//   Taken from WinFile.
//
//   NOTE:  This is a modeless dialog and must be terminated with DestroyWindow
//          and NOT EndDialog
//
// ARGUMENTS:
//
//    Standard dialog proc args.
//
// RETURNS:
//
//    TRUE  = Message handled.
//    FALSE = Message not handled.
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY UncompressProgDlg(
    HWND hDlg,
    UINT nMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szTemp[120];
    RECT  rect;

    switch (nMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            CenterWindowInParent(hDlg);

            g_hdlgProgress = hDlg;

            //
            //  Clear Dialog items.
            //
            szTemp[0] = TEXT('\0');

            SetDlgItemText(hDlg, IDC_UNCOMPRESS_FILE,    szTemp);
            SetDlgItemText(hDlg, IDC_UNCOMPRESS_DIR,     szTemp);
            SetDlgItemText(hDlg, IDC_UNCOMPRESS_DIRCNT,  szTemp);
            SetDlgItemText(hDlg, IDC_UNCOMPRESS_FILECNT, szTemp);

            g_hdcDirectoryTextCtrl = GetDC(GetDlgItem(hDlg, IDC_UNCOMPRESS_DIR));
            GetClientRect(GetDlgItem(hDlg, IDC_UNCOMPRESS_DIR), &rect);
            g_cDirectoryTextCtrlWd = rect.right;

            EnableWindow(hDlg, TRUE);
            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( IDOK ) :
                case ( IDCANCEL ) :
                {
                    if (LOWORD(wParam) == IDCANCEL)
                       g_pContext->uCompletionReason = SCCA_REASON_USERCANCEL;

                    if (g_hdcDirectoryTextCtrl)
                    {
                        ReleaseDC(GetDlgItem(hDlg, IDC_UNCOMPRESS_DIR), g_hdcDirectoryTextCtrl);
                        g_hdcDirectoryTextCtrl = NULL;
                    }
                    DestroyWindow(hDlg);
                    g_hdlgProgress = NULL;
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: DisplayCompressProgress
//
// DESCRIPTION:
//
//  Update the progress of compressing files.
//
//   This routine uses the global variables to update the Dialog box items
//   which display the progress through the compression process.  The global
//   variables are updated by individual routines.  An ordinal value is sent
//   to this routine which determines which dialog box item to update.
//   Taken from WinFile.
//
//
// ARGUMENTS:
//
//    iType
//       Control value to determine what is to be updated.
//       Value names are self-descriptive.
//
// RETURNS:
//
//    Nothing.
//
///////////////////////////////////////////////////////////////////////////////
void DisplayCompressProgress(int iType)
{
    TCHAR szTemp[120];
    TCHAR szNum[30];
    unsigned _int64 Percentage;

    if (!g_bShowProgress)
    {
        return;
    }

    switch (iType)
    {
        case ( PROGRESS_UPD_FILEANDDIR ) :
        case ( PROGRESS_UPD_FILENAME ) :
        {
            SetDlgItemText(g_hdlgProgress, IDC_COMPRESS_FILE, g_szFile);
            if (iType != PROGRESS_UPD_FILEANDDIR)
            {
                break;
            }

            // else...fall thru
        }
        case ( PROGRESS_UPD_DIRECTORY ) :
        {
            RECT rect;
            //
            //  Preprocess the directory name to shorten it to fit
            //  into the alloted space.
            //
            GetWindowRect(GetDlgItem(g_hdlgProgress, IDC_COMPRESS_DIR), &rect);
            DrawTextEx(g_hdcDirectoryTextCtrl, g_szDirectory, lstrlen(g_szDirectory), &rect, DT_MODIFYSTRING | DT_PATH_ELLIPSIS, NULL);
            SetDlgItemText(g_hdlgProgress, IDC_COMPRESS_DIR, g_szDirectory);

            break;
        }
        case ( PROGRESS_UPD_DIRCNT ) :
        {
            AddCommas((DWORD)g_cTotalDirectories, szNum);
            SetDlgItemText(g_hdlgProgress, IDC_COMPRESS_DIRCNT, szNum);

            break;
        }
        case ( PROGRESS_UPD_FILENUMBERS ) :
        case ( PROGRESS_UPD_FILECNT ) :
        {
            AddCommas((DWORD)g_cTotalFiles, szNum);
            SetDlgItemText(g_hdlgProgress, IDC_COMPRESS_FILECNT, szNum);
            if (iType != PROGRESS_UPD_FILENUMBERS)
            {
                break;
            }

            // else...fall thru
        }
        case ( PROGRESS_UPD_COMPRESSEDSIZE ) :
        {
            Int64ToString(g_iTotalCompressedSize, szTemp, ARRAYSIZE(szTemp), TRUE, &g_NumberFormat, NUMFMT_ALL);
            FormatStringWithArgs(g_szByteCntFmt, szNum, ARRAYSIZE(szNum), szTemp);
            SetDlgItemText(g_hdlgProgress, IDC_COMPRESS_CSIZE, szNum);
            if (iType != PROGRESS_UPD_FILENUMBERS)
            {
                break;
            }

            // else...fall thru
        }
        case ( PROGRESS_UPD_FILESIZE ) :
        {
            Int64ToString(g_iTotalFileSize, szTemp, ARRAYSIZE(szTemp), TRUE, &g_NumberFormat, NUMFMT_ALL);
            FormatStringWithArgs(g_szByteCntFmt, szNum, ARRAYSIZE(szNum), szTemp);
            SetDlgItemText(g_hdlgProgress, IDC_COMPRESS_USIZE, szNum);
            if (iType != PROGRESS_UPD_FILENUMBERS)
            {
                break;
            }

            // else...fall thru
        }

        case ( PROGRESS_UPD_PERCENTAGE ) :
        {
            if (g_iTotalFileSize != 0)
            {
                //
                //  Percentage = 100 - ((CompressSize * 100) / FileSize)
                //
                Percentage = (g_iTotalCompressedSize * 100) / g_iTotalFileSize;

                if (Percentage > 100)
                {
                    Percentage = 100;
                }
                else
                    Percentage = 100 - Percentage;
            }
            else
            {
                Percentage = 0;
            }
            //
            // Note that percentage string is not formatted.
            // i.e. no commas or decimal places.
            //
            Int64ToString(Percentage, szTemp, ARRAYSIZE(szTemp), FALSE, NULL, 0);
            wsprintf(szNum, TEXT("%s%%"), szTemp);
            SetDlgItemText(g_hdlgProgress, IDC_COMPRESS_RATIO, szNum);

            break;
        }
    }

    CompressProgressYield();
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CompressProgDlg
//
// DESCRIPTION:
//
//   Display progress information.
//   Taken from WinFile.
//
//   NOTE:  This is a modeless dialog and must be terminated with DestroyWindow
//          and NOT EndDialog
//
// ARGUMENTS:
//
//    Standard dialog proc args.
//
// RETURNS:
//
//    TRUE  = Message handled.
//    FALSE = Message not handled.
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY CompressProgDlg(
    HWND hDlg,
    UINT nMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szTemp[120];
    RECT  rect;

    switch (nMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            CenterWindowInParent(hDlg);

            g_hdlgProgress = hDlg;

            //
            //  Clear Dialog items.
            //
            szTemp[0] = TEXT('\0');

            SetDlgItemText(hDlg, IDC_COMPRESS_FILE, szTemp);
            SetDlgItemText(hDlg, IDC_COMPRESS_DIR,  szTemp);
            SetDlgItemText(hDlg, IDC_COMPRESS_DIRCNT, szTemp);
            SetDlgItemText(hDlg, IDC_COMPRESS_FILECNT, szTemp);
            SetDlgItemText(hDlg, IDC_COMPRESS_CSIZE, szTemp);
            SetDlgItemText(hDlg, IDC_COMPRESS_USIZE, szTemp);
            SetDlgItemText(hDlg, IDC_COMPRESS_RATIO, szTemp);

            g_hdcDirectoryTextCtrl = GetDC(GetDlgItem(hDlg, IDC_COMPRESS_DIR));
            GetClientRect(GetDlgItem(hDlg, IDC_COMPRESS_DIR), &rect);
            g_cDirectoryTextCtrlWd = rect.right;

            //
            // Set Dialog message text.
            //
            LoadString(g_hmodThisDll, IDS_COMPRESS_DIR, szTemp, ARRAYSIZE(szTemp));
            EnableWindow(hDlg, TRUE);

            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( IDOK ) :
                case ( IDCANCEL ) :
                {
                    if (LOWORD(wParam) == IDCANCEL)
                       g_pContext->uCompletionReason = SCCA_REASON_USERCANCEL;

                    if (g_hdcDirectoryTextCtrl)
                    {
                        ReleaseDC(GetDlgItem(hDlg, IDC_COMPRESS_DIR), g_hdcDirectoryTextCtrl);
                        g_hdcDirectoryTextCtrl = NULL;
                    }
                    DestroyWindow(hDlg);
                    g_hdlgProgress = NULL;

                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: NotifyShellOfAttribChange
//
// DESCRIPTION:
//
//   If the item is visible or is a directory, tell the shell that it's
//   attributes have changed.  This will cause the shell to update any
//   compression-related display characteristics.
//
// ARGUMENTS:
//
//   pszPath
//      Fully-qualified path to file/directory that changed.
//
//   bIsDirectory
//      If TRUE, shell is notified.
//      If FALSE, shell is notified only if global recursion level counter
//          is 1.  This ensures that we don't send unnecessary notifications to
//          the shell for items that definitely are not visible in the shell view.
//
// RETURNS:
//
//    Nothing.
//
///////////////////////////////////////////////////////////////////////////////
void NotifyShellOfAttribChange(LPTSTR pszPath, BOOL bIsDirectory)
{
    //
    // Only notify shell if item is visible.
    // All items handled at recursion level 1 are visible by default.
    // Subdirectories must always be updated because they may be visible
    // the Explorer tree view.
    //
    if (1 == g_iRecursionLevel || bIsDirectory)
    {
        if (PathIsRoot(pszPath))
        {
            //
            // Invalidate the drive type flags cache for this drive.
            // Cache will be updated with new information on next call to
            // RealDriveTypeFlags( ).
            //
            InvalidateDriveType(PathGetDriveNumber(pszPath));
        }
        else
        {
            PathRemoveTheBackslash(pszPath);
        }
        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, pszPath, NULL);

#ifdef TRACE_COMPRESSION
        DbgOut(TEXT("SHCOMPUI: Shell notified. %s"), pszPath);
#endif

    }
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: ShellChangeCompressionAttribute
//
// DESCRIPTION:
//
//   Main entry point for file compression/uncompression.
//
// ARGUMENTS:
//
//    hwndParent
//       Handle to window for parenting dialogs.
//
//    szFileSpec
//       Fully-qualified path of file to be compressed/uncompressed.
//
//    pContext
//       Address of a context structure as defined in shcompui.h
//       This structure is created by the caller so that we can maintain
//       information about the compression process across a series of
//       calls to this function.  In particular, the user can press the
//       "Ignore All Errors" button and we must remember this during
//       subsequent calls.  The structure also maintains error count
//       information and completion status.  This may be used to supplement
//       the TRUE/FALSE return mechanism to further discriminate a FALSE
//       return value.
//
//    bCompressing
//       Control variable.  TRUE = compress file.  FALSE = uncompress file.
//
//    bShowUI
//       Control of message box and dialog displays.
//       TRUE  = Show all dialogs and messages.
//       FALSE = Hide all dialogs and messages.  Used when compression is desired
//               without any user interactiion.
//
//          ***********************************************************
//                                    NOTE
//
//            The bShowUI argument has been introduced to support
//            programmatic invocation of shell compression in cases
//            where a UI display is not wanted.  The functionality
//            of preventing UI display is not complete at this time.
//            To meet the SUR beta deadline, this parameter is ignored.
//
//          ***********************************************************
//
// RETURNS:
//
//    TRUE  = Operation successful.  Continue if iterating
//            through set of files/directories.
//    FALSE = User aborted compression/uncompression or error occurred.
//            Stop if iterating through set of files/directories.
//            Query the context structure for additional completion information.
//
///////////////////////////////////////////////////////////////////////////////
BOOL ShellChangeCompressionAttribute(
    HWND hwndParent,
    LPTSTR szNameSpec,
    LPSCCA_CONTEXT pContext,
    BOOL bCompressing,
    BOOL bShowUI)
{
    TCHAR   szTitle[MAX_DLGTITLE_LEN+1];
    TCHAR   szTemp[MAX_MESSAGE_LEN+1];
    TCHAR   szFilespec[_MAX_PATH+1];
    BOOL    bCompressionAttrChange;
    BOOL    bIsDir       = FALSE;
    BOOL    bRet         = TRUE;
    HCURSOR hCursor      = NULL;
    DWORD   dwAttribs    = 0;
    DWORD   dwNewAttribs = 0;
    DWORD   dwFlags      = 0;

    ASSERT(hwndParent != NULL);
    ASSERT(szNameSpec != NULL);

    //
    //  Make sure we're not in the middle of another compression operation.
    //  If so, put up an error box warning the user that they need to wait
    //  to do another compression operation.
    //
    if (WaitForSingleObject(g_hSemaphore, 0L) == WAIT_TIMEOUT)
    {
        //
        // REARCHITECT: Shouldn't assume the UI is being displayed on behalf of
        //         Explorer.  The code should be modified so that the app
        //         name is passed in through ShellChangeCompressionAtttribute.
        //
        LoadString(g_hmodThisDll, IDS_APP_NAME, szTitle, ARRAYSIZE(szTitle));
        LoadString(g_hmodThisDll, IDS_MULTI_COMPRESS_ERR, szMessage, ARRAYSIZE(szMessage));
        MessageBox(hwndParent, szMessage, szTitle, MB_OK | MB_ICONEXCLAMATION);

#ifdef TRACE_COMPRESSION
        DbgOut(TEXT("SHCOMPUI: Re-entrancy attempted and denied"));
#endif

        return (TRUE);
    }

    //
    // Give the context structure "file" scope.
    //
    g_pContext = pContext;

    //
    // Reset recursion level counter.
    //
    g_iRecursionLevel = 0;

    //
    //  Make sure the volume supports File Compression.
    //
    lstrcpy(szTemp, szNameSpec);
    PathStripToRoot(szTemp);
    // GetVolumeInformation requires a trailing backslash.  Append
    // one if this is a UNC path.
    if (PathIsUNC(szTemp))
    {
        lstrcat(szTemp, c_szBACKSLASH);
    }
    if (!GetVolumeInformation (szTemp, NULL, 0L, NULL, NULL, &dwFlags, NULL, 0L)
       || !(dwFlags & FS_FILE_COMPRESSION))
    {
        //
        //  The volume does not support file compression, so just
        //  quit out.  Do not return FALSE, since that will not
        //  allow any other attributes to be changed.
        //

#ifdef TRACE_COMPRESSION
        DbgOut(TEXT("SHCOMPUI: Volume %s doesn't support compression."), szTemp);
#endif
        ReleaseSemaphore(g_hSemaphore, 1, NULL);
        return (TRUE);
    }

    //
    //  Show the hour glass cursor.
    //
    if (hCursor = LoadCursor(NULL, IDC_WAIT))
    {
        hCursor = SetCursor(hCursor);
    }
    ShowCursor(TRUE);

    //
    //  Get the file attributes (current and new).
    //  On error, don't change the attribute.
    //
    if ((dwAttribs = GetFileAttributes(szNameSpec)) != (DWORD)-1)
    {
       if (bCompressing)
          dwNewAttribs = dwAttribs | FILE_ATTRIBUTE_COMPRESSED;
       else
          dwNewAttribs = dwAttribs & ~FILE_ATTRIBUTE_COMPRESSED;
   }

    //
    //  Determine if ATTR_COMPRESSED is changing state.
    //
    bCompressionAttrChange = ( (dwAttribs & FILE_ATTRIBUTE_COMPRESSED) !=
                               (dwNewAttribs & FILE_ATTRIBUTE_COMPRESSED) );

#ifdef TRACE_COMPRESSION
    {
       TCHAR szAttribStr[40];
       TCHAR szNewAttribStr[40];
       DbgOut(TEXT("SHCOMPUI: File = \"%-30s\"  Attr = [%s]  New = [%s]"), szNameSpec,
                               FileAttribString(dwAttribs, szAttribStr),
                               FileAttribString(dwNewAttribs, szNewAttribStr));
    }
#endif

    g_bShowProgress     = FALSE;
    g_bIgnoreAllErrors  = g_pContext->bIgnoreAllErrors;
    g_bDiskFull         = FALSE;
    g_pContext->cErrors = 0;          // Clear "current" error counter.


    //
    //  If the Compression attribute changed or if we're dealing with
    //  a directory, perform action.
    //
    bIsDir = PathIsDirectory(szNameSpec);
    if (bCompressionAttrChange || bIsDir)
    {
        INT cchLoaded = 0;

        //
        //  Reset globals before progress display.
        //
        g_cTotalDirectories       = 0;
        g_cTotalFiles             = 0;
        g_iTotalFileSize          = 0;
        g_iTotalCompressedSize    = 0;
        g_szFile[0]               = CH_NULL;
        g_szDirectory[0]          = CH_NULL;

        cchLoaded = LoadString(g_hmodThisDll, IDS_BYTECNT_FMT, g_szByteCntFmt, ARRAYSIZE(g_szByteCntFmt));
        ASSERT(cchLoaded > 0);

        if (bIsDir)
        {
            BOOL bIgnoreAll = FALSE;
            UINT_PTR uDlgResult = 0;
            CompressionDesc compdesc = { bCompressing, TEXT("") };

            lstrcpy(compdesc.szFileName, szNameSpec);
            uDlgResult = DialogBoxParam(g_hmodThisDll, MAKEINTRESOURCE(DLG_COMPRESS_CONFIRMATION),
                         hwndParent, CompressSubsConfirmDlgProc, (LPARAM)&compdesc);

            lstrcpy(szFilespec, c_szSTAR);
            g_bShowProgress = TRUE;
            switch(uDlgResult)
            {
               case COMPRESS_SUBSYES:
                  g_bDoSubdirectories = TRUE;
                  break;

               case COMPRESS_SUBSNO:
                  g_bDoSubdirectories = FALSE;
                  break;

               case COMPRESS_CANCELLED:
                  bRet = FALSE;
                  goto CancelCompress;
                  break;

               default:
                  ASSERT(0);
                  break;
            }

            if (g_bShowProgress)
            {
                g_hdlgProgress = CreateDialog(
                                   g_hmodThisDll,
                                   MAKEINTRESOURCE(bCompressing ? DLG_COMPRESS_PROGRESS : DLG_UNCOMPRESS_PROGRESS),
                                   hwndParent,
                                   (bCompressing ? CompressProgDlg :
                                                   UncompressProgDlg));


                ShowWindow(g_hdlgProgress, SW_SHOW);
            }
            PathAddBackslash(szNameSpec);
            lstrcpy(szTemp, szNameSpec);

            bRet = bCompressing ? DoCompress(hwndParent, szNameSpec, szFilespec) :
                                  DoUncompress(hwndParent, szNameSpec, szFilespec);

            //
            //  Set attribute on Directory if last call was successful.
            //
            if (bRet)
            {
                szFilespec[0] = TEXT('\0');
                g_bDoSubdirectories = FALSE;
                lstrcpy(szNameSpec, szTemp);
                bRet = bCompressing ? DoCompress(hwndParent, szNameSpec, szFilespec) :
                                      DoUncompress(hwndParent, szNameSpec, szFilespec);
            }

            //
            // If the progress dialog was being displayed, destroy it.
            //
            if (g_hdlgProgress)
            {
                if (g_hdcDirectoryTextCtrl)
                {
                    ReleaseDC( GetDlgItem(g_hdlgProgress,
                                          (bCompressing ? IDC_COMPRESS_DIR : IDC_UNCOMPRESS_DIR)),
                                          g_hdcDirectoryTextCtrl);
                    g_hdcDirectoryTextCtrl = NULL;
                }
                DestroyWindow(g_hdlgProgress);
                g_hdlgProgress = NULL;
            }
        }
        else
        {
            //
            //  Compress single file.
            //
            g_bDoSubdirectories = FALSE;
            lstrcpy(szFilespec, szNameSpec);

            PathStripPath(szFilespec);
            PathRemoveFileSpec(szNameSpec);

            PathAddBackslash(szNameSpec);

#ifdef TRACE_COMPRESSION
            DbgOut(TEXT("Compress/Uncompress single file %s%s"),szNameSpec,szFilespec);
#endif

            bRet = bCompressing ? DoCompress(hwndParent, szNameSpec, szFilespec) :
                                  DoUncompress(hwndParent, szNameSpec, szFilespec);
        }
    }

CancelCompress:

    //
    //  Reset the cursor.
    //
    if (hCursor)
    {
        SetCursor(hCursor);
    }
    ShowCursor(FALSE);

    //
    // Tell the shell that the free space on this volume has changed.
    //
    lstrcpy(szTemp, szNameSpec);
    PathStripToRoot(szTemp);
    if (PathIsUNC(szTemp))
    {
        lstrcat(szTemp, c_szBACKSLASH);
    }
    SHChangeNotify(SHCNE_FREESPACE, SHCNF_PATH, szTemp, NULL);

    //
    //  Return the appropriate value.
    //
    g_pContext->bIgnoreAllErrors = g_bIgnoreAllErrors;
    ReleaseSemaphore(g_hSemaphore, 1, NULL);
    return (bRet);
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CompressFile
//
// DESCRIPTION:
//
//   Compress a single file.
//   Originally take from WinFile.
//
// ARGUMENTS:
//
//    Handle
//       Handle to file to be compressed.
//
//    FileSpec
//       Full file specification.
//       Required to obtain compressed file size.
//       FindData->cFileName[] doesn't include the path.
//
//    FindData
//       Pointer to file search context data.  Contains file name.
//
// RETURNS:
//
//    TRUE  = Success.
//    FALSE = Device IO error during compression.
//
///////////////////////////////////////////////////////////////////////////////
BOOL CompressFile(
    HANDLE Handle,
    LPTSTR FileSpec,
    PWIN32_FIND_DATA FindData)
{
    USHORT State;
    ULONG Length;
    LARGE_INTEGER TempLarge;


    //
    //  Print out the file name and then do the Ioctl to compress the
    //  file.  When we are done we'll print the okay message.
    //
    lstrcpy(g_szFile, FindData->cFileName);
    DisplayCompressProgress(PROGRESS_UPD_FILENAME);

    State = 1;

    if (!DeviceIoControl( Handle,
                          FSCTL_SET_COMPRESSION,
                          &State,
                          sizeof(USHORT),
                          NULL,
                          0,
                          &Length,
                          FALSE ))
    {
        g_pContext->cErrors++;
        g_pContext->cCummErrors++;

#ifdef TRACE_COMPRESSION
        DbgOut(TEXT("SHCOMPUI: CompressFile, DeviceIoControl failed with error 0x%08X"),
                       GetLastError());
#endif
        return (FALSE);
    }

    //
    //  Gather statistics (File size, compressed size and count).
    //
    TempLarge.LowPart  = FindData->nFileSizeLow;
    TempLarge.HighPart = FindData->nFileSizeHigh;
    g_iTotalFileSize += TempLarge.QuadPart;

    TempLarge.LowPart = GetCompressedFileSize(FileSpec, &(TempLarge.HighPart));
    g_iTotalCompressedSize += TempLarge.QuadPart;

    g_cTotalFiles++;

    DisplayCompressProgress(PROGRESS_UPD_FILENUMBERS);

    return (TRUE);
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: DoCompress
//
// DESCRIPTION:
//
//   Compress a directory and its subdirectories if necessary.
//   Originally take from WinFile.
//
// ARGUMENTS:
//
//   hwndParent
//      Window handle for parenting dialogs and message boxes.
//
//   DirectorySpec
//      Fully-qualified directory specification with backslash appended.
//
//   FileSpec
//      File name with directory path removed.
//
// RETURNS:
//
//    TRUE  = Success.
//    FALSE = Device IO error or user aborted compression.
//
///////////////////////////////////////////////////////////////////////////////
BOOL DoCompress(
    HWND hwndParent,
    LPTSTR DirectorySpec,
    LPTSTR FileSpec)
{
    LPTSTR DirectorySpecEnd;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    USHORT State;
    ULONG  Length;
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;
    int MBRet;
    TCHAR szTitle[128];

    g_iRecursionLevel++;

#ifdef TRACE_COMPRESSION
    DbgOut(TEXT("SHCOMPUI: DoCompress with %s%s"), DirectorySpec, FileSpec);
    DbgOut(TEXT("          Recursion Level: %d -> %d"), g_iRecursionLevel-1, g_iRecursionLevel);
#endif

    //
    //  If the file spec is null, then set the compression bit for
    //  the directory spec and get out.
    //
    lstrcpy(g_szDirectory, DirectorySpec);
    g_szFile[0] = CH_NULL;
    DisplayCompressProgress(PROGRESS_UPD_FILEANDDIR);

    if (lstrlen(FileSpec) == 0)
    {
DoCompressRetryCreate:

        if (!OpenFileForCompress(&FileHandle, DirectorySpec))
        {
#ifdef TRACE_COMPRESSION
           DbgOut(TEXT("SHCOMPUI: DoCompress, OpenFileForCompress failed."));
#endif
            goto DoCompressError;
        }

DoCompressRetryDevIo:

        State = 1;
        if (!DeviceIoControl( FileHandle,
                              FSCTL_SET_COMPRESSION,
                              &State,
                              sizeof(USHORT),
                              NULL,
                              0,
                              &Length,
                              FALSE ))
        {
            g_pContext->cErrors++;
            g_pContext->cCummErrors++;

DoCompressError:

#ifdef TRACE_COMPRESSION
            DbgOut(TEXT("SHCOMPUI: DoCompress, DeviceIoControl failed with error 0x%08X"),
                       GetLastError());
#endif

            if (!g_bIgnoreAllErrors)
            {
                MBRet = CompressErrMessageBox( hwndParent,
                                               DirectorySpec,
                                               &FileHandle );
                if (MBRet == RETRY_CREATE)
                {
                    goto DoCompressRetryCreate;
                }
                else if (MBRet == RETRY_DEVIO)
                {
                    goto DoCompressRetryDevIo;
                }
                else if (MBRet == IDABORT)
                {
                    //
                    //  Return error.
                    //  File handle was closed by CompressErrMessageBox( ).
                    //
                    g_pContext->uCompletionReason = SCCA_REASON_USERABORT;
                    g_iRecursionLevel--;
                    return (FALSE);
                }
                //
                //  Else (MBRet == IDIGNORE)
                //  Continue on as if the error did not occur.
                //
            }
        }
        if (INVALID_HANDLE_VALUE != FileHandle)
        {
            CloseHandle(FileHandle);
            FileHandle = INVALID_HANDLE_VALUE;
        }

        g_cTotalDirectories++;
        g_cTotalFiles++;

        DisplayCompressProgress(PROGRESS_UPD_DIRCNT);
        DisplayCompressProgress(PROGRESS_UPD_FILECNT);

        NotifyShellOfAttribChange(DirectorySpec, TRUE);

        g_iRecursionLevel--;
        return (TRUE);
    }

    //
    //  Get a pointer to the end of the directory spec, so that we can
    //  keep appending names to the end of it.
    //
    DirectorySpecEnd = DirectorySpec + lstrlen(DirectorySpec);

    //
    //  List the directory that is being compressed and display
    //  its current compress attribute.
    //
    g_cTotalDirectories++;
    DisplayCompressProgress(PROGRESS_UPD_DIRCNT);

    //
    //  For every file in the directory that matches the file spec,
    //  open the file and compress it.
    //
    //  Setup the template for findfirst/findnext.
    //
    lstrcpy(DirectorySpecEnd, FileSpec);

    if ((FindHandle = FindFirstFile(DirectorySpec, &FindData)) != INVALID_HANDLE_VALUE)
    {
        do
        {
            DWORD dwAttrib = FindData.dwFileAttributes;

            //
            //  Make sure the user hasn't hit cancel.
            //
            if (g_bShowProgress && !g_hdlgProgress)
            {
               g_iRecursionLevel--;
               FindClose(FindHandle);
               return FALSE;
            }

            //
            //  Skip over the . and .. entries.
            //
            if ( !lstrcmp(FindData.cFileName, c_szDOT) ||
                 !lstrcmp(FindData.cFileName, c_szDOTDOT) )
            {
                continue;
            }
            else if ((DirectorySpecEnd == (DirectorySpec + 3)) &&
                     !lstrcmpi(FindData.cFileName, c_szNTLDR))
            {
               //
               //  Do not allow \NTLDR to be compressed.
               //  Put up OK message box and then continue.
               //
               lstrcpy(DirectorySpecEnd, FindData.cFileName);
               LoadString(g_hmodThisDll, IDS_NTLDR_COMPRESS_ERR, szTitle, ARRAYSIZE(szTitle));
               wsprintf(szMessage, szTitle, DirectorySpec);
               LoadString(g_hmodThisDll, IDS_APP_NAME, szTitle, ARRAYSIZE(szTitle));
               MessageBox(g_hdlgProgress ? g_hdlgProgress : hwndParent, szMessage,
                                          szTitle, MB_OK | MB_ICONEXCLAMATION);

               continue;
            }
            else
            {
                //
                //  Append the found file to the directory spec and
                //  open the file.
                //
                lstrcpy(DirectorySpecEnd, FindData.cFileName);

                if ((dwAttrib & FILE_ATTRIBUTE_COMPRESSED) ||
                    (!g_bDoSubdirectories && (dwAttrib & FILE_ATTRIBUTE_DIRECTORY)))
                {
                    //
                    //  File is a directory or is already compressed.
                    //  So just skip it.
                    //
                    continue;
                }

CompressFileRetryCreate:

                if (!OpenFileForCompress(&FileHandle, DirectorySpec))
                {
#ifdef TRACE_COMPRESSION
                   DbgOut(TEXT("SHCOMPUI: DoCompress, OpenFileForCompress failed."),
                       GetLastError());
#endif
                    goto CompressFileError;
                }

CompressFileRetryDevIo:

                //
                //  Compress the file.
                //
                if (!CompressFile(FileHandle, DirectorySpec, &FindData))
                {
CompressFileError:

                    if (!g_bIgnoreAllErrors)
                    {
                        MBRet = CompressErrMessageBox( hwndParent,
                                                       DirectorySpec,
                                                       &FileHandle );
                        if (MBRet == RETRY_CREATE)
                        {
                            goto CompressFileRetryCreate;
                        }
                        else if (MBRet == RETRY_DEVIO)
                        {
                            goto CompressFileRetryDevIo;
                        }
                        else if (MBRet == IDABORT)
                        {
                            //
                            //  Return error.
                            //  File handle was closed by CompressErrMessageBox( ).
                            //
                            g_pContext->uCompletionReason = SCCA_REASON_USERABORT;
                            g_iRecursionLevel--;
                            FindClose(FindHandle);
                            return (FALSE);
                        }
                        //
                        //  Else (MBRet == IDIGNORE)
                        //  Continue on as if the error did not occur.
                        //
                    }
                }
                if (INVALID_HANDLE_VALUE != FileHandle)
                {
                    CloseHandle(FileHandle);
                    FileHandle = INVALID_HANDLE_VALUE;
                }
            }

            NotifyShellOfAttribChange(DirectorySpec,
                                     (dwAttrib & FILE_ATTRIBUTE_DIRECTORY) != 0);

            CompressProgressYield();

        } while (FindNextFile(FindHandle, &FindData));

        FindClose(FindHandle);
    }

    //
    //  If we are to do subdirectores, then look for every subdirectory
    //  and recursively call ourselves to list the subdirectory.
    //
    if (g_bDoSubdirectories)
    {
        //
        //  Setup findfirst/findnext to search the entire directory.
        //
        lstrcpy(DirectorySpecEnd, c_szSTAR);

        if ((FindHandle = FindFirstFile(DirectorySpec, &FindData)) != INVALID_HANDLE_VALUE)
        {
            do
            {
                //
                //  Skip over the . and .. entries, otherwise recurse.
                //
                if ( !lstrcmp(FindData.cFileName, c_szDOT) ||
                     !lstrcmp(FindData.cFileName, c_szDOTDOT) )
                {
                    continue;
                }
                else
                {
                    //
                    //  If the entry is for a directory, then tack
                    //  on the subdirectory name to the directory spec
                    //  and recurse.
                    //
                    if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        lstrcpy(DirectorySpecEnd, FindData.cFileName);
                        lstrcat(DirectorySpecEnd, c_szBACKSLASH);

                        if (!DoCompress(hwndParent, DirectorySpec, FileSpec))
                        {
                            g_iRecursionLevel--;
                            FindClose(FindHandle);
                            return (FALSE || g_bIgnoreAllErrors);
                        }
                    }
                }

            } while (FindNextFile(FindHandle, &FindData));

            FindClose(FindHandle);
        }
    }

    g_iRecursionLevel--;
    return (TRUE);
}



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: UncompressFile
//
// DESCRIPTION:
//
//   Uncompress a single file.
//   Originally take from WinFile.
//
// ARGUMENTS:
//
//    hwndParent
//       Handle to window for parenting any dialogs.
//
//    hFile
//       Handle to file to be compressed.
//
//    FindData
//       Pointer to file search context data.  Contains file name.
//
// RETURNS:
//
//    TRUE  = Success.
//    FALSE = Device IO error during compression.
//
///////////////////////////////////////////////////////////////////////////////
BOOL UncompressFile(HWND hwndParent, HANDLE hFile, PWIN32_FIND_DATA FindData)
{
    USHORT State;
    ULONG Length;

    //
    //  Print out the file name and then do the Ioctl to uncompress the
    //  file.  When we are done we'll print the okay message.
    //
    lstrcpy(g_szFile, FindData->cFileName);
    DisplayUncompressProgress(PROGRESS_UPD_FILENAME);

    State = 0;

    if (!DeviceIoControl( hFile,
                          FSCTL_SET_COMPRESSION,
                          &State,
                          sizeof(USHORT),
                          NULL,
                          0,
                          &Length,
                          FALSE )
#ifdef SIM_DISK_FULL
                          || TRUE
#endif
                          )
    {
        g_pContext->cErrors++;
        g_pContext->cCummErrors++;

#ifdef TRACE_COMPRESSION
        DbgOut(TEXT("SHCOMPUI: UncompressFile, DeviceIoControl failed with error 0x%08X"),
                       GetLastError());
#endif

#ifdef SIM_DISK_FULL
        SetLastError((DWORD)STATUS_DISK_FULL);
#endif

        if (GetLastError() == STATUS_DISK_FULL)
        {
           UncompressDiskFullError(hwndParent, hFile);
           g_bDiskFull = TRUE;
        }

        return (FALSE);
    }

    //
    //  Increment the running total.
    //
    g_cTotalFiles++;
    DisplayUncompressProgress(PROGRESS_UPD_FILENUMBERS);

    return (TRUE);
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: DoUncompress
//
// DESCRIPTION:
//
//   Uncompress a directory and its subdirectories if necessary.
//   Originally take from WinFile.
//
// ARGUMENTS:
//
//   hwndParent
//      Window handle for parenting dialogs and message boxes.
//
//   DirectorySpec
//      Fully-qualified directory specification with backslash appended.
//
//   FileSpec
//      File name with directory path removed.
//
// RETURNS:
//
//    TRUE  = Success.
//    FALSE = Device IO error or user aborted uncompression.
//
///////////////////////////////////////////////////////////////////////////////
BOOL DoUncompress(
    HWND hwndParent,
    LPTSTR DirectorySpec,
    LPTSTR FileSpec)
{
    LPTSTR DirectorySpecEnd;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    USHORT State;
    ULONG  Length;
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;
    int MBRet;

    g_iRecursionLevel++;

#ifdef TRACE_COMPRESSION
    DbgOut(TEXT("SHCOMPUI: DoUncompress with %s%s"), DirectorySpec, FileSpec);
    DbgOut(TEXT("          Recursion Level: %d -> %d"), g_iRecursionLevel-1, g_iRecursionLevel);
#endif

    //
    //  If the file spec is null, then clear the compression bit for
    //  the directory spec and get out.
    //
    lstrcpy(g_szDirectory, DirectorySpec);
    g_szFile[0] = CH_NULL;
    DisplayUncompressProgress(PROGRESS_UPD_FILEANDDIR);

    if (lstrlen(FileSpec) == 0)
    {
DoUncompressRetryCreate:

        if (!OpenFileForCompress(&FileHandle, DirectorySpec))
        {
#ifdef TRACE_COMPRESSION
        DbgOut(TEXT("SHCOMPUI: UncompressDirecory, OpenFileForCompress failed."));
#endif
            goto DoUncompressError;
        }

DoUncompressRetryDevIo:

        State = 0;
        if (!DeviceIoControl( FileHandle,
                              FSCTL_SET_COMPRESSION,
                              &State,
                              sizeof(USHORT),
                              NULL,
                              0,
                              &Length,
                              FALSE )
#ifdef SIM_DISK_FULL
                              || TRUE
#endif
                              )
        {
            g_pContext->cErrors++;
            g_pContext->cCummErrors++;

DoUncompressError:

            //
            // Handle disk-full error.
            //
#ifdef TRACE_COMPRESSION
        DbgOut(TEXT("SHCOMPUI: DoUncompress, DeviceIoControl failed with error 0x%08X"),
                       GetLastError());
#endif
#ifdef SIM_DISK_FULL
            SetLastError((DWORD)STATUS_DISK_FULL);
#endif
            if (GetLastError() == STATUS_DISK_FULL)
            {
               UncompressDiskFullError(hwndParent, FileHandle);
               g_bDiskFull = TRUE;
               CloseHandle(FileHandle);
               g_iRecursionLevel--;
               return FALSE;
            }

            if (!g_bIgnoreAllErrors)
            {
                MBRet = CompressErrMessageBox( hwndParent,
                                               DirectorySpec,
                                               &FileHandle );
                if (MBRet == RETRY_CREATE)
                {
                    goto DoUncompressRetryCreate;
                }
                else if (MBRet == RETRY_DEVIO)
                {
                    goto DoUncompressRetryDevIo;
                }
                else if (MBRet == IDABORT)
                {
                    //
                    //  Return error.
                    //  File handle was closed by CompressErrMessageBox.
                    //
                    g_pContext->uCompletionReason = SCCA_REASON_USERABORT;
                    g_iRecursionLevel--;
                    return (FALSE);
                }
                //
                //  Else (MBRet == IDIGNORE)
                //  Continue on as if the error did not occur.
                //
            }
        }
        if (INVALID_HANDLE_VALUE != FileHandle)
        {
            CloseHandle(FileHandle);
            FileHandle = INVALID_HANDLE_VALUE;
        }

        g_cTotalDirectories++;
        g_cTotalFiles++;

        DisplayUncompressProgress(PROGRESS_UPD_DIRCNT);
        DisplayUncompressProgress(PROGRESS_UPD_FILECNT);

        NotifyShellOfAttribChange(DirectorySpec, TRUE);

        g_iRecursionLevel--;
        return (TRUE);
    }

    //
    //  Get a pointer to the end of the directory spec, so that we can
    //  keep appending names to the end of it.
    //
    DirectorySpecEnd = DirectorySpec + lstrlen(DirectorySpec);

    g_cTotalDirectories++;
    DisplayUncompressProgress(PROGRESS_UPD_DIRCNT);

    //
    //  For every file in the directory that matches the file spec,
    //  open the file and uncompress it.
    //
    //  Setup the template for findfirst/findnext.
    //
    lstrcpy(DirectorySpecEnd, FileSpec);

    if ((FindHandle = FindFirstFile(DirectorySpec, &FindData)) != INVALID_HANDLE_VALUE)
    {
        do
        {
            DWORD dwAttrib = FindData.dwFileAttributes;

            //
            //  Make sure the user hasn't hit cancel.
            //
            if (g_bShowProgress && !g_hdlgProgress)
            {
               g_iRecursionLevel--;
               FindClose(FindHandle);
               return FALSE;
            }

            //
            //  Skip over the . and .. entries.
            //
            if ( !lstrcmp(FindData.cFileName, c_szDOT) ||
                 !lstrcmp(FindData.cFileName, c_szDOTDOT) )
            {
                continue;
            }
            else
            {
                //
                //  Append the found file to the directory spec and
                //  open the file.
                //
                lstrcpy(DirectorySpecEnd, FindData.cFileName);

                if (!(dwAttrib & FILE_ATTRIBUTE_COMPRESSED) ||
                    (!g_bDoSubdirectories && (dwAttrib & FILE_ATTRIBUTE_DIRECTORY)))
                {
                    //
                    //  File is a directory or already uncompressed.
                    //  So skip it.
                    //
                    continue;
                }

UncompressFileRetryCreate:

                if (!OpenFileForCompress(&FileHandle, DirectorySpec))
                {
#ifdef TRACE_COMPRESSION
                    DbgOut(TEXT("SHCOMPUI: OpenFileForCompress failed."));
#endif
                    goto UncompressFileError;
                }

UncompressFileRetryDevIo:

                //
                //  Uncompress the file.
                //
                if (!UncompressFile(hwndParent, FileHandle, &FindData))
                {
UncompressFileError:

                    //
                    // If disk is full, UncompressFile( ) already handled the error.
                    // Don't handle it again.  Just return.
                    //
                    if (g_bDiskFull)
                    {
                       g_pContext->uCompletionReason = SCCA_REASON_DISKFULL;
                       CloseHandle(FileHandle);
                       FindClose(FindHandle);
                       g_iRecursionLevel--;
                       return FALSE;
                    }

                    if (!g_bIgnoreAllErrors)
                    {
                        MBRet = CompressErrMessageBox( hwndParent,
                                                       DirectorySpec,
                                                       &FileHandle );
                        if (MBRet == RETRY_CREATE)
                        {
                            goto UncompressFileRetryCreate;
                        }
                        else if (MBRet == RETRY_DEVIO)
                        {
                            goto UncompressFileRetryDevIo;
                        }
                        else if (MBRet == IDABORT)
                        {
                            //
                            //  Return error.
                            //  File handle was closed by CompressErrMessageBox.
                            //
                            g_pContext->uCompletionReason = SCCA_REASON_USERABORT;
                            g_iRecursionLevel--;
                            FindClose(FindHandle);
                            return (FALSE);
                        }
                        //
                        //  Else (MBRet == IDIGNORE)
                        //  Continue on as if the error did not occur.
                        //
                    }
                }
                if (INVALID_HANDLE_VALUE != FileHandle)
                {
                    CloseHandle(FileHandle);
                    FileHandle = INVALID_HANDLE_VALUE;
                }
            }

            NotifyShellOfAttribChange(DirectorySpec,
                                      (dwAttrib & FILE_ATTRIBUTE_DIRECTORY) != 0);

            CompressProgressYield();

        } while (FindNextFile(FindHandle, &FindData));

        FindClose(FindHandle);
    }

    //
    //  If we are to do subdirectores, then look for every subdirectory
    //  and recursively call ourselves to list the subdirectory.
    //
    if (g_bDoSubdirectories)
    {
        //
        //  Setup findfirst/findnext to search the entire directory.
        //
        lstrcpy(DirectorySpecEnd, c_szSTAR);

        if ((FindHandle = FindFirstFile(DirectorySpec, &FindData)) != INVALID_HANDLE_VALUE)
        {
            do
            {
                //
                //  Skip over the . and .. entries, otherwise recurse.
                //
                if ( !lstrcmp(FindData.cFileName, c_szDOT) ||
                     !lstrcmp(FindData.cFileName, c_szDOTDOT) )
                {
                    continue;
                }
                else
                {
                    //
                    //  If the entry is for a directory, then tack
                    //  on the subdirectory name to the directory spec
                    //  and recurse.
                    //
                    if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        lstrcpy(DirectorySpecEnd, FindData.cFileName);
                        lstrcat(DirectorySpecEnd, c_szBACKSLASH);

                        if (!DoUncompress(hwndParent, DirectorySpec, FileSpec))
                        {
                            g_iRecursionLevel--;
                            FindClose(FindHandle);
                            return (FALSE || g_bIgnoreAllErrors);
                        }
                    }
                }

            } while (FindNextFile(FindHandle, &FindData));

            FindClose(FindHandle);
        }
    }

    g_iRecursionLevel--;
    return (TRUE);
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CompressErrMessageBox
//
// DESCRIPTION:
//
//   Puts up the error message box when a file cannot be compressed or
//   uncompressed.  It also returns the user preference.
//
//   NOTE: The file handle is closed if the abort or ignore option is
//         chosen by the user.
//
// ARGUMENTS:
//
//
// RETURNS:
//
//    RETRY_CREATE            = User selected "Retry"
//    RETRY_DEVIO             = User selected "Retry"
//    IDABORT
//    IDIGNORE
//    IDC_COMPRESS_IGNOREALL
//
///////////////////////////////////////////////////////////////////////////////
int CompressErrMessageBox(
    HWND hwndActive,
    LPTSTR szFile,
    PHANDLE phFile)
{
    int rc;

    //
    //  Put up the error message box - ABORT, RETRY, IGNORE, IGNORE ALL.
    //
    rc = (int)DialogBoxParam( g_hmodThisDll,
                              (LPTSTR) MAKEINTRESOURCE(DLG_COMPRESS_ERROR),
                              g_hdlgProgress ? g_hdlgProgress : hwndActive,
                              CompressErrDialogProc,
                              (LPARAM)szFile );

    //
    //  Return the user preference.
    //
    if (rc == IDRETRY)
    {
        if (*phFile == INVALID_HANDLE_VALUE)
        {
            return (RETRY_CREATE);
        }
        else
        {
            return (RETRY_DEVIO);
        }
    }
    else
    {
        //
        //  IDABORT or IDIGNORE or IDC_COMPRESS_IGNOREALL
        //
        //  Close the file handle and return the message box result.
        //
        if (*phFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(*phFile);
            *phFile = INVALID_HANDLE_VALUE;
        }

        return (rc);
    }
}



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CompressErrDialogProc
//
// DESCRIPTION:
//
//   Puts up a dialog to allow the user to Abort, Retry, Ignore, or
//   Ignore All when an error occurs during compression.
//
//
//   Taken from WinFile source wffile.c.  Modified control resource IDs to
//   be consistent with other Explorer ID naming conventions.
//
// ARGUMENTS:
//
//   Standard Dialog Proc args.
//
// RETURNS:
//
//   Standard Dialog Proc return values..
//
//   Returns through EndDialog( ):
//
//      IDABORT
//      IDRETRY
//      IDIGNORE
//      IDC_COMPRESS_IGNOREALL
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CompressErrDialogProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    WORD IdControl = TRUE;
    TCHAR szTitle[MAX_DLGTITLE_LEN + 1];

    switch (uMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            //
            // Modify very long path names so that they fit into the message box.
            // They are formatted as "c:\dir1\dir2\dir3\...\dir8\filename.ext"
            // DrawTextEx isn't drawing on anything.  Only it's formatting capabilities are
            // being used. The DT_CALCRECT flag prevents drawing.
            //
            HDC  hDC        = GetDC(hDlg);
            LONG iBaseUnits = GetDialogBaseUnits();
            RECT rc;
            TCHAR szFilePath[MAX_PATH];         // Local copy of path name string.
            const int MAX_PATH_DISPLAY_WD = 50; // Max characters to display in path name.
            const int MAX_PATH_DISPLAY_HT =  1; // Path name is 1 character high.

            rc.left   = 0;
            rc.top    = 0;
            rc.right  = MAX_PATH_DISPLAY_WD * LOWORD(iBaseUnits);
            rc.bottom = MAX_PATH_DISPLAY_HT * HIWORD(iBaseUnits);

            lstrcpyn(szFilePath, (LPCTSTR)lParam, ARRAYSIZE(szFilePath));
            DrawTextEx(hDC, szFilePath, ARRAYSIZE(szFilePath), &rc,
                                        DT_CALCRECT | DT_PATH_ELLIPSIS | DT_MODIFYSTRING, NULL);
            ReleaseDC(hDlg, hDC);

            //
            //  Set the dialog message text.
            //
            LoadString( g_hmodThisDll,
                        IDS_COMPRESS_ATTRIB_ERR,
                        szTitle,
                        ARRAYSIZE(szTitle) );

            wsprintf(szMessage, szTitle, szFilePath);
            SetDlgItemText(hDlg, IDC_COMPRESS_ERRTEXT, szMessage);
            EnableWindow (hDlg, TRUE);

            break;
        }
        case ( WM_COMMAND ) :
        {
            IdControl = GET_WM_COMMAND_ID(wParam, lParam);
            switch (IdControl)
            {
                case ( IDC_COMPRESS_IGNOREALL ) :
                {
                    g_bIgnoreAllErrors = TRUE;

                    //  fall thru...
                }
                case ( IDABORT ) :
                case ( IDRETRY ) :
                case ( IDIGNORE ) :
                {
                    EndDialog(hDlg, IdControl);
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        default :
        {
            return (FALSE);
        }
    }
    return (IdControl);
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: OpenFileForCompress
//
// DESCRIPTION:
//
//   Opens the file for compression.  It handles the case where a READONLY
//   file is trying to be compressed or uncompressed.  Since read only files
//   cannot be opened for WRITE_DATA, it temporarily resets the file to NOT
//   be READONLY in order to open the file, and then sets it back once the
//   file has been compressed.
//
//   Taken from WinFile module wffile.c without change.  Originally from
//   G. Kimura's compact.c.
//
// ARGUMENTS:
//
//   phFile
//      Address of file handle variable for handle of open file if
//      successful.
//
//   szFile
//      Name string of file to be opened.
//
// RETURNS:
//
//    TRUE  = File successfully opened.  Handle in *phFile.
//    FALSE = File couldn't be opened. *phFile == INVALID_HANDLE_VALUE
//
///////////////////////////////////////////////////////////////////////////////
BOOL OpenFileForCompress(
    PHANDLE phFile,
    LPTSTR szFile)
{
    HANDLE hAttr;
    BY_HANDLE_FILE_INFORMATION fi;

    //
    //  Try to open the file - READ_DATA | WRITE_DATA.
    //
    if ((*phFile = CreateFile( szFile,
                               FILE_READ_DATA | FILE_WRITE_DATA,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,
                               NULL )) != INVALID_HANDLE_VALUE)
    {
        //
        //  Successfully opened the file.
        //
        return (TRUE);
    }

    if (GetLastError() != ERROR_ACCESS_DENIED)
    {
        return (FALSE);
    }

    //
    //  Try to open the file - READ_ATTRIBUTES | WRITE_ATTRIBUTES.
    //
    if ((hAttr = CreateFile( szFile,
                             FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,
                             NULL )) == INVALID_HANDLE_VALUE)
    {
        return (FALSE);
    }

    //
    //  See if the READONLY attribute is set.
    //
    if ( (!GetFileInformationByHandle(hAttr, &fi)) ||
         (!(fi.dwFileAttributes & FILE_ATTRIBUTE_READONLY)) )
    {
        //
        //  If the file could not be open for some reason other than that
        //  the readonly attribute was set, then fail.
        //
        CloseHandle(hAttr);
        return (FALSE);
    }

    //
    //  Turn OFF the READONLY attribute.
    //
    fi.dwFileAttributes &= ~FILE_ATTRIBUTE_READONLY;
    if (!SetFileAttributes(szFile, fi.dwFileAttributes))
    {
        CloseHandle(hAttr);
        return (FALSE);
    }

    //
    //  Try again to open the file - READ_DATA | WRITE_DATA.
    //
    *phFile = CreateFile( szFile,
                          FILE_READ_DATA | FILE_WRITE_DATA,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_EXISTING,
                          FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,
                          NULL );

    //
    //  Close the file handle opened for READ_ATTRIBUTE | WRITE_ATTRIBUTE.
    //
    CloseHandle(hAttr);

    //
    //  Make sure the open succeeded.  If it still couldn't be opened with
    //  the readonly attribute turned off, then fail.
    //
    if (*phFile == INVALID_HANDLE_VALUE)
    {
        return (FALSE);
    }

    //
    //  Turn the READONLY attribute back ON.
    //
    fi.dwFileAttributes |= FILE_ATTRIBUTE_READONLY;
    if (!SetFileAttributes(szFile, fi.dwFileAttributes))
    {
        CloseHandle(*phFile);
        *phFile = INVALID_HANDLE_VALUE;
        return (FALSE);
    }

    //
    //  Return success.  A valid file handle is in *phFile.
    //
    return (TRUE);
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: UncompressDiskFullError
//
// DESCRIPTION:
//
//    To be called when disk space is exhausted during uncompression.
//    The function displays a message box with an OK button.
//    NTFS leaves a file partially compressed when DeviceIoControl( )
//    returns STATUS_DISK_FULL in GetLastError( ).  It also leaves the
//    compressed attribute as "compressed".
//    Once the user acknowledges the message, we attempt to re-compress the
//    file so that the entire file is compressed and matches its
//    attribute setting.
//
// ARGUMENTS:
//
//    hFile
//       Handle to file being uncompressed at the time of the error.
//
// RETURNS:
//
//    Nothing.
//
///////////////////////////////////////////////////////////////////////////////
static void UncompressDiskFullError(HWND hwndParent, HANDLE hFile)
{
   TCHAR szTitle[MAX_DLGTITLE_LEN + 1];
   USHORT State = 1; // 1 = Compress.
   ULONG Length = 0;

   LoadString(g_hmodThisDll, IDS_APP_NAME, szTitle, ARRAYSIZE(szTitle));
   LoadString(g_hmodThisDll, IDS_UNCOMPRESS_DISKFULL, szMessage, ARRAYSIZE(szMessage));

   MessageBox(hwndParent, szMessage, szTitle, MB_OK | MB_ICONSTOP);

   //
   // Try to compress the file.
   // Don't worry about errors on the compression attempt.
   // At worst case, the file is left partially compressed with the attribute
   // set as "compressed".  According to the NTFS people, this is not
   // harmful and the file is still usable.  Besides, there isn't much else
   // we could do at this point.
   //
   DeviceIoControl( hFile,
                    FSCTL_SET_COMPRESSION,
                    &State,
                    sizeof(USHORT),
                    NULL,
                    0,
                    &Length,
                    FALSE );

}



#endif        // ifdef WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\shcompui\shcompui.h ===
#ifndef __SHCOMPUI_H
#define __SHCOMPUI_H
///////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995.
//
//  FILE: SHCOMPUI.H
//
//  DESCRIPTION:
//
//    Header for users of SHCOMPUI.DLL.
//
//    REVISIONS:
//
//    Date       Description                                         Programmer
//    ---------- --------------------------------------------------- ----------
//    09/15/95   Initial creation.                                   brianau
//    09/21/95   Changes per first code review.                      brianau
//    09/28/95   Added SCCA_CONTEXT structure.                       brianau
//
///////////////////////////////////////////////////////////////////////////////
#ifdef WINNT

#include <windows.h>

//
// Define a context structure for keeping track of what's going on during the
// compression/uncompression operations.
//
typedef struct {
   BOOL bIgnoreAllErrors;       // User wants to ignore all errors.
   DWORD uCompletionReason;     // Reason operation completed.
   DWORD cErrors;               // Number of errors on last call.
   DWORD cCummErrors;           // Cummulative error count.
} SCCA_CONTEXT, *LPSCCA_CONTEXT;


//
// Values for uCompletionReason member of SCCA_CONTEXT.
//
#define SCCA_REASON_NORMAL         0  // No problems.
#define SCCA_REASON_USERCANCEL     1  // User cancel in confirm dlg.
#define SCCA_REASON_USERABORT      2  // User abort in error dlg.
#define SCCA_REASON_IOERROR        3  // Device IO error.
#define SCCA_REASON_DISKFULL       4  // Disk full on uncompression.

//
// Initialize a new context structure.
// Use address of structure as argument.
//
#define SCCA_CONTEXT_INIT(c)  { memset((LPVOID)c, 0, sizeof(SCCA_CONTEXT)); }

//
// To call this function, create a SCCA_CONTEXT variable, initialize
// it with SCCA_CONTEXT_INIT( ) and pass it's address in the "context"
// argument.  The context structure maintains information that must
// persist between successive calls while processing an Explorer
// selection set.  The structure is also used to collect performance
// data such as error counts and completion status that may be queried
// once the function returns.
//
BOOL ShellChangeCompressionAttribute(HWND hActiveWnd, LPTSTR szNameSpec,
                      LPSCCA_CONTEXT context, BOOL bCompress, BOOL bShowUI);

#define SZ_SHCOMPUI_DLLNAME    __TEXT("SHCOMPUI.DLL")

//
// Note:  This must be an ANSI string for GetProcAddress( ).
//
#define SZ_COMPRESS_PROCNAME   "ShellChangeCompressionAttribute"


#endif  // ifdef WINNT

#endif  // ifdef __SHCOMPUI_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\shole\ids.h ===
#define IDI_ICON                100

#define IDS_TITLE                       0x100
#define IDS_TITLE_ERR                   0x101

#define IDS_ERR_DOVERB                  0x110
#define IDS_ERR_DOVERB_F                0x111
#define IDS_ERR_COMMIT                  0x112
#define IDS_ERR_COMMIT_F                0x113
#define IDS_ERR_SCRAPSAVE               0x114
#define IDS_ERR_SCRAPSAVE_F             0x115
#define IDS_ERR_CREATESTORAGE           0x116
#define IDS_ERR_CREATESTORAGE_F         0x117
#define IDS_ERR_CREATEDOCFILE           0x118
#define IDS_ERR_CREATEDOCFILE_F         0x119

#define IDS_BOOKMARK_S          0x200
#define IDS_BOOKMARK_L          0x201
#define IDS_FINDINVALIDFILENAME 0x202
#define IDS_NEWLINK             0x202
#define IDS_SCRAP_S             0x203
#define IDS_SCRAP_L             0x204
#define IDS_TEMPSCRAP           0x205
#define IDS_TEMPLINK            0x206

#define IDS_WOULDYOUSAVEAS      0x210
#define IDS_MOVEFAILED          0x211
#define IDS_SCRAPFILTER         0x212

#define IDS_HRES_MIN                    0x400
#define IDS_HRES_MAX                    0x800
#define IDS_HRES_INVALID_SCRAPFILE      0x400

#define IDR_FANCYERR            0x100

// reserved up to 0x1fff
#define IDS_FANCYERR            0x1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\shole\debug.h ===
//====== Assertion/Debug output APIs =================================

#include <platform.h> // sdk\inc, for __endexcept


#ifdef __cplusplus
extern "C" {
#endif

//
// Debug macros and validation code
//

#if !defined(UNIX) || (defined(UNIX) && !defined(NOSHELLDEBUG))

// Undefine the macros that we define in case some other header
// might have tried defining these commonly-named macros.
#undef Assert
#undef AssertE
#undef AssertMsg
#undef AssertStrLen
#undef DebugMsg
#undef FullDebugMsg
#undef EVAL
#undef ASSERTMSG            // catch people's typos
#undef DBEXEC

#endif

//
// Debug macros and validation code
//

// Trace flags for g_dwTraceFlags
#define TF_ALWAYS           0xFFFFFFFF
#define TF_NEVER            0x00000000
#define TF_WARNING          0x00000001
#define TF_ERROR            0x00000002
#define TF_GENERAL          0x00000004      // Standard messages
#define TF_FUNC             0x00000008      // Trace function calls
#define TF_ATL              0x00000008      // Since TF_FUNC is so-little used, I'm overloading this bit
// (Upper 28 bits reserved for custom use per-module)

// Old, archaic debug flags.  
// (scotth): the following flags will be phased out over time.
#ifdef DM_TRACE
#undef DM_TRACE
#undef DM_WARNING
#undef DM_ERROR
#endif
#define DM_TRACE            TF_GENERAL      // OBSOLETE Trace messages
#define DM_WARNING          TF_WARNING      // OBSOLETE Warning
#define DM_ERROR            TF_ERROR        // OBSOLETE Error


// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
#define DEBUGTEXT(sz, msg)      /* ;Internal */ \
    static const TCHAR sz[] = msg

#ifdef DEBUG

#ifdef _X86_
// Use int 3 so we stop immediately in the source
#define DEBUG_BREAK        do { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while (0)
#else
#define DEBUG_BREAK        do { _try { DebugBreak(); } _except (EXCEPTION_EXECUTE_HANDLER) {;} __endexcept } while (0)
#endif

#endif // DEBUG


// ASSERT(f)
//
//   Generates a "Assert file.c, line x (eval)" message if f is NOT true.
//
//   Use ASSERT() to check for logic invariance.  These are typically considered
//   fatal problems, and falls into the 'this should never ever happen' 
//   category.
//
//   Do *not* use ASSERT() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//

#ifdef DEBUG

BOOL CcshellAssertFailedA(LPCSTR szFile, int line, LPCSTR pszEval, BOOL bBreakInside);
BOOL CcshellAssertFailedW(LPCWSTR szFile, int line, LPCWSTR pwszEval, BOOL bBreakInside);
#ifdef UNICODE
#define CcshellAssertFailed     CcshellAssertFailedW
#else
#define CcshellAssertFailed     CcshellAssertFailedA
#endif

#define ASSERT(f)                                 \
    {                                             \
        DEBUGTEXT(szFile, TEXT(__FILE__));              \
        if (!(f) && CcshellAssertFailed(szFile, __LINE__, TEXT(#f), FALSE)) \
            DEBUG_BREAK;       \
    }

#else  // DEBUG
#define ASSERT(f)
#endif // DEBUG


#ifdef DEBUG

void CDECL _DebugMsgA(DWORD flag, LPCSTR psz, ...);
void CDECL _DebugMsgW(DWORD flag, LPCWSTR psz, ...);

#ifdef UNICODE
#define _DebugMsg               _DebugMsgW
#else
#define _DebugMsg               _DebugMsgA
#endif

#define DebugMsg            _DebugMsg

#else  // DEBUG
#define DebugMsg        1 ? (void)0 : (void)
#endif // DEBUG

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\shole\sccls.c ===
#include "shole.h"
#include "ids.h"
#include "scguid.h"

UINT g_cRefThisDll = 0;         // per-instance

class CMyClassFactory : public IClassFactory
{
public:
    CMyClassFactory(REFCLSID rclsid);
    ~CMyClassFactory() { g_cRefThisDll--; }

    // IUnKnown
    virtual HRESULT __stdcall QueryInterface(REFIID,void **);
    virtual ULONG __stdcall AddRef(void);
    virtual ULONG __stdcall Release(void);

    // IClassFactory
    virtual HRESULT __stdcall CreateInstance(
            IUnknown *pUnkOuter, REFIID riid, void **ppvObject);
    virtual HRESULT __stdcall LockServer(BOOL fLock);

protected:
    UINT   _cRef;
    CLSID  _clsid;
};

CMyClassFactory::CMyClassFactory(REFCLSID rclsid) : _cRef(1), _clsid(rclsid)
{
    g_cRefThisDll++;
}

HRESULT CMyClassFactory::QueryInterface(REFIID riid, void **ppvObject)
{
    HRESULT hres;
    if (IsEqualGUID(riid, IID_IClassFactory) || IsEqualGUID(riid, IID_IUnknown)) {
        _cRef++;
        *ppvObject = (LPCLASSFACTORY)this;
        hres = NOERROR;
    }
    else
    {
        *ppvObject = NULL;
        hres = ResultFromScode(E_NOINTERFACE);
    }

    return hres;
}

ULONG CMyClassFactory::AddRef(void)
{
    return ++_cRef;
}

ULONG CMyClassFactory::Release(void)
{
    if (--_cRef>0) {
        return _cRef;
    }

    delete this;
    return 0;
}

HRESULT CMyClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject)
{
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    LPUNKNOWN punk;
    HRESULT hres;
    if (IsEqualGUID(_clsid, CLSID_CScrapData))
    {
        hres = CScrapData_CreateInstance(&punk);
    }
    else
    {
        return E_UNEXPECTED;
    }

    if (SUCCEEDED(hres))
    {
        hres = punk->QueryInterface(riid, ppvObject);
        punk->Release();
    }
    return hres;
}

HRESULT CMyClassFactory::LockServer(BOOL fLock)
{
    return S_OK;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppvOut)
{
    if (IsEqualGUID(rclsid,CLSID_CScrapData))
    {
        CMyClassFactory *pmycls = new CMyClassFactory(rclsid);
        if (pmycls)
        {
            HRESULT hres = pmycls->QueryInterface(riid, ppvOut);
            pmycls->Release();
            return hres;
        }
        return E_OUTOFMEMORY;
    }
    return CLASS_E_CLASSNOTAVAILABLE;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_cRefThisDll)
    {
        return S_FALSE;
    }

    DebugMsg(DM_TRACE, TEXT("sc TR - DllCanUnloadNow returning S_OK (bye, bye...)"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\shole\scguid.h ===
// for .reg file 56117100-C0CD-101B-81E2-00AA004AE837
DEFINE_GUID(CLSID_CScrapData, 0x56117100L, 0xC0CD, 0x101B, 0x81, 0xE2, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\shole\shole.c ===
#include "shole.h"
#include "ids.h"

#define CLONE_IT_IF_READONLY
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

class CShClientSite : public IOleClientSite, public IAdviseSink2
{
public:
    CShClientSite(HWND hwndOwner, LPCTSTR pszCmdLine);
    LPCTSTR  ParseCmdLine(LPCTSTR pszCmdLine);
    HRESULT DoVerb(LONG iVerb);
    void    CloseOleObject();
    void    ReleaseOleObject();
    void    ReleaseStorage(void);
    void    MaySaveAs(void);
    void    Draw(HWND hwnd, HDC hdc);
    void    GetFileName(LPTSTR szFile, UINT cchMax);
    void    Quit(void) { _hwndOwner = NULL ; _fQuit = TRUE; }
    BOOL    FContinue(void) { return !_fQuit; }

    // IUnKnown
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID,void **);
    virtual ULONG STDMETHODCALLTYPE AddRef(void);
    virtual ULONG STDMETHODCALLTYPE Release(void);

    // IOleClientSite
    virtual HRESULT STDMETHODCALLTYPE SaveObject(void);
    virtual HRESULT STDMETHODCALLTYPE GetMoniker(DWORD, DWORD, IMoniker **);
    virtual HRESULT STDMETHODCALLTYPE GetContainer(IOleContainer **);
    virtual HRESULT STDMETHODCALLTYPE ShowObject(void);
    virtual HRESULT STDMETHODCALLTYPE OnShowWindow(BOOL fShow);
    virtual HRESULT STDMETHODCALLTYPE RequestNewObjectLayout(void);

    // IAdviseSink2
    virtual void STDMETHODCALLTYPE OnDataChange(FORMATETC *,STGMEDIUM *);
    virtual void STDMETHODCALLTYPE OnViewChange(DWORD dwAspect,LONG lindex);
    virtual void STDMETHODCALLTYPE OnRename(IMoniker *pmk);
    virtual void STDMETHODCALLTYPE OnSave(void);
    virtual void STDMETHODCALLTYPE OnClose(void);
    virtual void STDMETHODCALLTYPE OnLinkSrcChange(IMoniker *pmk);

protected:
    ~CShClientSite();

    UINT                _cRef;
    HWND                _hwndOwner;
    LPSTORAGE           _pstgDoc;       // document
    LPSTORAGE           _pstg;          // the embedding (only one)
    LPPERSISTSTORAGE    _ppstg;
    LPOLEOBJECT         _pole;
    BOOL                _fDirty:1;
    BOOL                _fNeedToSave:1;
    BOOL                _fReadOnly:1;
    BOOL                _fCloned:1;
    BOOL                _fQuit:1;
    BOOL                _fCloseImmediately:1;
    DWORD               _dwConnection;  // non-zero, if valid
    WCHAR               _wszFileName[MAX_PATH];
};
typedef CShClientSite * LPSHCLIENTSITE;

const TCHAR c_szAppName[] = TEXT("ShellOleViewer");
LRESULT CALLBACK ShWndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam);
void DisplayError(HWND hwndOwner, HRESULT hres, UINT idsMsg, LPCTSTR szFileName);

HINSTANCE g_hinst = NULL;

extern "C"
BOOL APIENTRY LibMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    switch(dwReason) {
    case DLL_PROCESS_ATTACH:
        g_hinst = (HINSTANCE)hDll;
        DisableThreadLibraryCalls(g_hinst);
        break;

    default:
        break;
    }

    return TRUE;
}

extern "C" void WINAPI
OpenScrap_RunDLL_Common(HWND hwndStub, HINSTANCE hInstApp, LPTSTR pszCmdLine, int nCmdShow)
{
    WNDCLASS wc;

    // wc.cbSize        = sizeof(WNDCLASSEX);
    wc.style         = CS_DBLCLKS|CS_VREDRAW|CS_HREDRAW ;
    wc.lpfnWndProc   = ShWndProc ;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(LPSHCLIENTSITE) ;
    wc.hInstance     = g_hinst ;
    wc.hIcon         = NULL ;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW) ;
    wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH) ;
    wc.lpszMenuName  = NULL ;
    wc.lpszClassName = c_szAppName ;
    // wc.hIconSm       = NULL;

    RegisterClass(&wc);

    HWND hwndClientSite = CreateWindowEx(WS_EX_TOOLWINDOW | WS_EX_OVERLAPPEDWINDOW,
                                   c_szAppName,
#ifdef DEBUG
                                   TEXT("(Debug only) SHOLE.EXE"),
                                   WS_VISIBLE | WS_OVERLAPPEDWINDOW,
#else
                                   TEXT(""),
                                   WS_OVERLAPPEDWINDOW,
#endif
                                   CW_USEDEFAULT, CW_USEDEFAULT,
                                   128, 128, NULL, NULL, g_hinst, NULL);
    if (hwndClientSite)
    {
        HRESULT hres;

        hres = OleInitialize(NULL);
        if (SUCCEEDED(hres))
        {
            DWORD dwTick;
            LPSHCLIENTSITE pscs= new CShClientSite(hwndClientSite, pszCmdLine);

            if (pscs)
            {
                UINT cRef;

                hres = pscs->DoVerb(OLEIVERB_OPEN);

                if (hres == S_OK)
                {
                    MSG msg;
                    while (pscs->FContinue() && GetMessage(&msg, NULL, 0, 0))
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }
                else
                {
                    // DoVerb failed.

                    if (FAILED(hres) || (hres>=IDS_HRES_MIN && hres<IDS_HRES_MAX))
                    {
                        TCHAR szFile[MAX_PATH];
                        pscs->GetFileName(szFile, ARRAYSIZE(szFile));
                        DisplayError(hwndClientSite, hres, IDS_ERR_DOVERB, szFile);
                    }
                    DestroyWindow(hwndClientSite);
                }

                //
                //  We call them just in case, the following Release
                // does not release the object.
                //
                pscs->ReleaseOleObject();
                pscs->ReleaseStorage();
                pscs->MaySaveAs();

                cRef = pscs->Release();
                ASSERT(cRef==0);
            }

            DebugMsg(DM_TRACE, TEXT("so TR - WinMain About to call OleUninitialize"));
            dwTick = GetCurrentTime();
            OleUninitialize();
            DebugMsg(DM_TRACE, TEXT("so TR - WinMain OleUninitialize took %d ticks"), GetCurrentTime()-dwTick);
        }

        if (IsWindow(hwndClientSite)) {
            DebugMsg(DM_WARNING, TEXT("so WA - WinMain IsWindow(hwndClientSite) is still TRUE"));
            DestroyWindow(hwndClientSite);
        }
    }
}

extern "C" void WINAPI
OpenScrap_RunDLL(HWND hwndStub, HINSTANCE hAppInstance, LPSTR lpszCmdLine, int nCmdShow)
{
#ifdef UNICODE
    UINT iLen = lstrlenA(lpszCmdLine)+1;
    LPWSTR  lpwszCmdLine;

    lpwszCmdLine = (LPWSTR)LocalAlloc(LPTR,iLen*sizeof(WCHAR));
    if (lpwszCmdLine)
    {
        MultiByteToWideChar(CP_ACP, 0,
                            lpszCmdLine, -1,
                            lpwszCmdLine, iLen);
        OpenScrap_RunDLL_Common( hwndStub,
                                 hAppInstance,
                                 lpwszCmdLine,
                                 nCmdShow );
        LocalFree(lpwszCmdLine);
    }
#else
    OpenScrap_RunDLL_Common( hwndStub,
                             hAppInstance,
                             lpszCmdLine,
                             nCmdShow );
#endif
}

extern "C" void WINAPI
OpenScrap_RunDLLW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpwszCmdLine, int nCmdShow)
{
#ifdef UNICODE
    OpenScrap_RunDLL_Common( hwndStub,
                             hAppInstance,
                             lpwszCmdLine,
                             nCmdShow );
#else
    UINT iLen = WideCharToMultiByte(CP_ACP, 0,
                                    lpwszCmdLine, -1,
                                    NULL, 0, NULL, NULL)+1;
    LPSTR  lpszCmdLine;

    lpszCmdLine = (LPSTR)LocalAlloc(LPTR,iLen);
    if (lpszCmdLine)
    {
        WideCharToMultiByte(CP_ACP, 0,
                            lpwszCmdLine, -1,
                            lpszCmdLine, iLen,
                            NULL, NULL);
        OpenScrap_RunDLL_Common( hwndStub,
                                 hAppInstance,
                                 lpszCmdLine,
                                 nCmdShow );
        LocalFree(lpszCmdLine);
    }
#endif
}


#ifdef DEBUG
//
// Type checking
//
static RUNDLLPROC lpfnRunDLL=OpenScrap_RunDLL;
#endif

void DisplayError(HWND hwndOwner, HRESULT hres, UINT idsMsg, LPCTSTR pszFileName)
{
    TCHAR szErrMsg[MAX_PATH*2];
    TCHAR szFancyErr[MAX_PATH*2];
    HRSRC hrsrc;

    if (HIWORD(hres))
    {
        BOOL fSuccess = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                  NULL,
                  hres,
                  0,
                  szErrMsg,
                  ARRAYSIZE(szErrMsg),
                  (va_list *)&pszFileName);
        if (!fSuccess) {
            idsMsg++;   // map IDS_ERR_DOVERB to IDS_ERR_DOVERB_F
        }
    } else {
        LoadString(g_hinst, LOWORD(hres), szErrMsg, ARRAYSIZE(szErrMsg));
    }

    szFancyErr[0] = TEXT('\0');
    hrsrc = FindResource(g_hinst, MAKEINTRESOURCE(IDR_FANCYERR), RT_RCDATA);
    if (hrsrc)
    {
        HGLOBAL hmem = LoadResource(g_hinst, hrsrc);
        if (hmem)
        {
            HRESULT* phres = (HRESULT*)LockResource(hmem);
            if (phres)
            {
                UINT i;
                LPTSTR pszLoad = szFancyErr;
                int cchLeft = ARRAYSIZE(szFancyErr);
                for (i=0; phres[i] && cchLeft>0; i++) {
                    if (phres[i] == hres)
                    {
                        int cchRead;
                        cchRead = LoadString(g_hinst, IDS_FANCYERR+i, pszLoad, cchLeft);
                        pszLoad += cchRead;
                        cchLeft -= cchRead;
                    }
                }

                //
                // If we have a fancy error message, hide ugly message
                // from FormatMessage.
                //
                if (szFancyErr[0]) {
                    szErrMsg[0] = TEXT('\0');
                }
            }
        }
    }

    ShellMessageBox(g_hinst,
                    hwndOwner,
                    MAKEINTRESOURCE(idsMsg),
                    MAKEINTRESOURCE(IDS_TITLE_ERR),
                    MB_OK | MB_ICONWARNING | MB_SETFOREGROUND,
                    pszFileName,
                    szErrMsg,
                    szFancyErr,
                    hres);
}


void CShClientSite::CloseOleObject()
{
    if (_pole)
        _pole->Close(OLECLOSE_NOSAVE);
}

void CShClientSite::ReleaseOleObject()
{
    UINT cRef;
    if (_pole)
    {
        if (_dwConnection) {
            _pole->Unadvise(_dwConnection);
            _dwConnection = 0;
        }
        _pole->SetClientSite(NULL);
        cRef = _pole->Release();
        DebugMsg(DM_TRACE, TEXT("so - TR SCS::ReleaseOleObject IOleObj::Rel returned (%d)"), cRef);
        _pole=NULL;
    }

    if (_ppstg)
    {
        cRef=_ppstg->Release();
        _ppstg=NULL;
        DebugMsg(DM_TRACE, TEXT("so TR - SCS::ReleaseOleObject IPSTG::Release returned (%x)"), cRef);
    }
}

void CShClientSite::ReleaseStorage(void)
{
    UINT cRef;

    if (_pstg)
    {
        cRef=_pstg->Release();
        _pstg=NULL;
        DebugMsg(DM_TRACE, TEXT("so TR - SCS::ReleaseStorage _pstg->Release returned (%x)"), cRef);
    }

    if (_pstgDoc)
    {
        cRef=_pstgDoc->Release();
        _pstgDoc=NULL;
        DebugMsg(DM_TRACE, TEXT("so TR - SCS::ReleaseStorage _pstgDoc->Release returned (%x)"), cRef);
    }
}

void CShClientSite::MaySaveAs()
{
    DebugMsg(DM_TRACE, TEXT("so TR - SCS::MaySaveAs called (%d,%d)"), _fCloned, _fNeedToSave);
    if (_fCloned)
    {
        TCHAR szTempFile[MAX_PATH];
#ifdef UNICODE
        lstrcpyn(szTempFile,_wszFileName,ARRAYSIZE(szTempFile));
#else
        WideCharToMultiByte(CP_ACP, 0, _wszFileName, -1, szTempFile, ARRAYSIZE(szTempFile), NULL, NULL);
#endif

        UINT id = IDNO;
        if (_fNeedToSave)
        {
            id= ShellMessageBox(g_hinst,
                        _hwndOwner,
                        MAKEINTRESOURCE(IDS_WOULDYOUSAVEAS),
                        MAKEINTRESOURCE(IDS_TITLE),
                        MB_YESNO | MB_ICONQUESTION | MB_SETFOREGROUND,
                        NULL);
        }

        DebugMsg(DM_TRACE, TEXT("so TR - SCS::MaySaveAs id==%d"), id);

        if (id==IDYES)
        {
            TCHAR szDesktop[MAX_PATH];
            SHGetSpecialFolderPath(NULL, szDesktop, CSIDL_DESKTOP, FALSE);

            BOOL fContinue;
            do
            {
                fContinue = FALSE;

                TCHAR szFile[MAX_PATH];
                TCHAR szFilter[64];
                szFile[0] = TEXT('\0');
                LoadString(g_hinst, IDS_SCRAPFILTER, szFilter, ARRAYSIZE(szFilter));

                OPENFILENAME of = {
                    sizeof(OPENFILENAME), // DWORD        lStructSize;
                    _hwndOwner,               // HWND         hwndOwner;
                    NULL,                     // HINSTANCE    hInstance;
                    szFilter,         // LPCSTR       lpstrFilter;
                    NULL,                     // LPSTR        lpstrCustomFilter;
                    0,                // DWORD        nMaxCustFilter;
                    1,                // DWORD        nFilterIndex;
                    szFile,           // LPSTR        lpstrFile;
                    ARRAYSIZE(szFile),    // DWORD        nMaxFile;
                    NULL,                     // LPSTR        lpstrFileTitle;
                    0,                // DWORD        nMaxFileTitle;
                    szDesktop,        // LPCSTR       lpstrInitialDir;
                    NULL,                     // LPCSTR       lpstrTitle;
                    OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT
                     | OFN_NOREADONLYRETURN | OFN_PATHMUSTEXIST,
                                          // DWORD        Flags;
                    0,                // WORD         nFileOffset;
                    0,                // WORD         nFileExtension;
                    TEXT("shs"),                      // LPCSTR       lpstrDefExt;
                    NULL,                     // LPARAM       lCustData;
                    NULL,                     // LPOFNHOOKPROC lpfnHook;
                    NULL,                     // LPCSTR       lpTemplateName;
                };

                if (GetSaveFileName(&of))
                {
                    DeleteFile(szFile);
                    BOOL fRet = MoveFile(szTempFile, szFile);
                    if (fRet)
                    {
                        // Indicated that the temp file is moved
                        szTempFile[0] = TEXT('\0');
                    }
                    else
                    {
                        id = ShellMessageBox(g_hinst,
                                _hwndOwner,
                                MAKEINTRESOURCE(IDS_MOVEFAILED),
                                MAKEINTRESOURCE(IDS_TITLE),
                                MB_YESNO | MB_ICONWARNING | MB_SETFOREGROUND);
                        if (id==IDYES)
                        {
                            fContinue = TRUE;
                        }
                    }
                }
            } while (fContinue);
        }

        // If the temp file is not moved, delete it.
        if (szTempFile[0])
        {
            DeleteFile(szTempFile);
        }
    }
}

void CShClientSite::Draw(HWND hwnd, HDC hdc)
{
#ifdef DEBUG
    if (_ppstg)
    {
        HRESULT hres;
        RECT rc;

        GetClientRect(hwnd, &rc);

        hres = OleDraw(_ppstg, DVASPECT_ICON, hdc, &rc);
        DebugMsg(DM_TRACE, TEXT("so TR - SCS::Draw OleDraw(DVASPECT_ICON) returned %x"), hres);

        if (FAILED(hres))
        {
            LPVIEWOBJECT2 pview;
            hres = _ppstg->QueryInterface(IID_IViewObject2, (LPVOID*)&pview);
            if (SUCCEEDED(hres))
            {
                SIZE size;
                hres = pview->GetExtent(DVASPECT_CONTENT, (DWORD)-1,
                                        (DVTARGETDEVICE*)NULL, &size);
                DebugMsg(DM_TRACE, TEXT("so TR - SCS::Draw IVO2::GetExtent returned %x"), hres);
                if (SUCCEEDED(hres))
                {
                    int mmOld = SetMapMode(hdc, MM_HIMETRIC);
                    LPtoDP(hdc, (LPPOINT)&size, 1);
                    rc.right = size.cx;
                    rc.bottom = -size.cy;
                    SetMapMode(hdc, mmOld);
                }
                pview->Release();
            }
            hres = OleDraw(_ppstg, DVASPECT_CONTENT, hdc, &rc);
            DebugMsg(DM_TRACE, TEXT("so TR - SCS::Draw OleDraw(DVASPECT_CONTENT,%d,%d) returned %x"),
                        hres, rc.right, rc.bottom);
        }

        LPOLELINK plink;
        if (SUCCEEDED(hres = _ppstg->QueryInterface(IID_IOleLink, (LPVOID *)&plink)))
        {
            LPOLESTR pwsz;
            hres = plink->GetSourceDisplayName(&pwsz);
            if (SUCCEEDED(hres))
            {
#ifdef UNICODE
                TextOut(hdc, 0, 0, pwsz, lstrlen(pwsz));
#else
                TCHAR szDisplayName[256] = TEXT("##ERROR##");
                WideCharToMultiByte(CP_ACP, 0, pwsz, -1, szDisplayName, ARRAYSIZE(szDisplayName), NULL, NULL);
                TextOut(hdc, 0, 0, szDisplayName, lstrlen(szDisplayName));
#endif
                CoTaskMemFree(pwsz);
            }
            else
            {
                DebugMsg(DM_TRACE, TEXT("so TR SCS:Draw IMK:GetSDN failed %x"), hres);
            }
            plink->Release();
        }
        else
        {
            DebugMsg(DM_TRACE, TEXT("so TR SCS:Draw IPSTG:QI failed %x"), hres);
        }
    }
#endif
}

STDMETHODIMP CShClientSite::QueryInterface(REFIID riid,
        void **ppvObject)
{
    HRESULT hres;
    if (IsEqualGUID(riid, IID_IOleClientSite) || IsEqualGUID(riid, IID_IUnknown)) {
        _cRef++;
        *ppvObject = (LPOLECLIENTSITE)this;
        hres = NOERROR;
    }
    else if (IsEqualGUID(riid, IID_IAdviseSink) || IsEqualGUID(riid, IID_IAdviseSink2)) {
        _cRef++;
        *ppvObject = (LPADVISESINK2)this;
        hres = NOERROR;
    }
    else
    {
        *ppvObject = NULL;
        hres = ResultFromScode(E_NOINTERFACE);
    }
    return hres;
}

STDMETHODIMP_(ULONG) CShClientSite::AddRef(void)
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CShClientSite::Release(void)
{
    if (--_cRef>0) {
        return _cRef;
    }

    delete this;
    return 0;
}


void Scrap_UpdateCachedData(LPSTORAGE pstgDoc, LPOLEOBJECT pole, LPPERSIST pps)
{
    extern void Scrap_CacheClipboardData(LPSTORAGE pstgDoc, LPDATAOBJECT pdtobj, LPPERSIST pps);
    DebugMsg(DM_TRACE, TEXT("so TR - S_UCD called"));
    if (pstgDoc && pole && pps)
    {
        IDataObject *pdtobj = NULL;
        HRESULT hres = pole->QueryInterface(IID_IDataObject, (LPVOID*)&pdtobj);
        if (SUCCEEDED(hres)) {
            DebugMsg(DM_TRACE, TEXT("so TR - S_UCD QI succeeded"));
            Scrap_CacheClipboardData(pstgDoc, pdtobj, pps);
            pdtobj->Release();
        }
    }
}

STDMETHODIMP CShClientSite::SaveObject(void)
{
    DebugMsg(DM_TRACE, TEXT("sc TR - CSCS::SaveObject called"));
    //
    // NOTES: We need to update the cache here.
    //  Doing so on ::OnSave does not work (async)
    //  Doing so on ::OnClose is too late.
    //
    Scrap_UpdateCachedData(_pstgDoc, _pole, _ppstg);

    HRESULT hres;
    if (_pstg && _ppstg)
    {
        hres = OleSave(_ppstg, _pstg, TRUE);
        if (SUCCEEDED(hres))
        {
            hres = _ppstg->SaveCompleted(NULL);
        }
    }
    else
    {
        hres = ResultFromScode(E_FAIL);
    }
    return hres;
}

STDMETHODIMP CShClientSite::GetMoniker(DWORD dwAssign,
    DWORD dwWhichMoniker,
    IMoniker **ppmk)
{
    HRESULT hres;

    *ppmk = NULL;

    switch(dwWhichMoniker)
    {
    case OLEWHICHMK_CONTAINER:
        hres = CreateFileMoniker(_wszFileName, ppmk);
        break;

    case OLEWHICHMK_OBJREL:
        hres = CreateItemMoniker(L"\\", L"Object", ppmk);
        break;

    case OLEWHICHMK_OBJFULL:
        {
            LPMONIKER pmkItem;
            hres = CreateItemMoniker(L"\\", L"Object", &pmkItem);
            if (SUCCEEDED(hres))
            {
                LPMONIKER pmkDoc;
                hres = CreateFileMoniker(_wszFileName, &pmkDoc);
                if (SUCCEEDED(hres))
                {
                    hres = CreateGenericComposite(pmkDoc, pmkItem, ppmk);
                    pmkDoc->Release();
                }
                pmkItem->Release();
            }
        }
        break;

    default:
        hres = ResultFromScode(E_INVALIDARG);
    }

    return hres;
}

STDMETHODIMP CShClientSite::GetContainer(
    IOleContainer **ppContainer)
{
    *ppContainer = NULL;
    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP CShClientSite::ShowObject(void)
{
    return NOERROR;
}

STDMETHODIMP CShClientSite::OnShowWindow(BOOL fShow)
{
    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::OnShowWindow called with %d"), fShow);
    return NOERROR;
}

STDMETHODIMP CShClientSite::RequestNewObjectLayout(void)
{
    return ResultFromScode(E_NOTIMPL);
}

//
// _cRef <- 2 because _hwndOwner has a reference count as well.
//
CShClientSite::CShClientSite(HWND hwndOwner, LPCTSTR pszCmdLine)
                : _cRef(2), _hwndOwner(hwndOwner),
                  _pstgDoc(NULL), _pstg(NULL), _ppstg(NULL), _pole(NULL),
                  _fDirty(FALSE), _fNeedToSave(FALSE),
                  _fReadOnly(FALSE), _fCloned(FALSE), _fCloseImmediately(FALSE),
                  _fQuit(FALSE)
{
    LPCTSTR pszFileName = ParseCmdLine(pszCmdLine);

//
// We'd better deal with quoted LFN name.
//
#ifdef NASHVILLE
    //
    // Strip out quotes if exists.
    //
    TCHAR szT[MAX_PATH];
    if (*pszFileName==TEXT('"'))
    {
        lstrcpy(szT, pszFileName+1);
        LPTSTR pszT = CharPrev(szT, szT+lstrlen(szT));
        if (*pszT==TEXT('"')) {
            *pszT=TEXT('\0');
        }
        pszFileName = szT;
    }
#endif // NASHVILLE

#ifdef UNICODE
    lstrcpyn(_wszFileName, pszFileName, ARRAYSIZE(_wszFileName));
#else
    MultiByteToWideChar(CP_ACP, 0, pszFileName, lstrlen(pszFileName)+1,
                        _wszFileName, ARRAYSIZE(_wszFileName));
#endif

    ASSERT(_hwndOwner)
    SetWindowLongPtr(_hwndOwner, GWLP_USERDATA, (LONG_PTR)this);
}

CShClientSite::~CShClientSite()
{
    ReleaseOleObject();
    ReleaseStorage();
}

LPCTSTR _SkipSpace(LPCTSTR psz)
{
    while(*psz==TEXT(' '))
        psz++;
    return psz;
}

LPCTSTR CShClientSite::ParseCmdLine(LPCTSTR pszCmdLine)
{
    for (LPCTSTR psz = _SkipSpace(pszCmdLine);
         (*psz == TEXT('/') || *psz == TEXT('-')) && *++psz;
         psz = _SkipSpace(psz))
    {
        switch(*psz++)
        {
        case TEXT('r'):
        case TEXT('R'):
            _fReadOnly = TRUE;
            break;

        case TEXT('x'):
        case TEXT('X'):
            _fCloseImmediately = TRUE;
            break;
        }
    }

    return psz;
}

void CShClientSite::GetFileName(LPTSTR szFile, UINT cchMax)
{
#ifdef UNICODE
    lstrcpyn(szFile, _wszFileName, cchMax);
#else
    WideCharToMultiByte(CP_ACP, 0, _wszFileName, -1, szFile, cchMax, NULL, NULL);
#endif
}
const WCHAR c_wszContents[] = WSTR_SCRAPITEM;

//
// Returns:
//      S_OK, succeeded. Start the message loop.
//      S_FALSE, succeeded. Release the object.
//      Others, failed.
//
HRESULT CShClientSite::DoVerb(LONG iVerb)
{
    HRESULT hres;
    DWORD wStgm;

    // Must be called only once.
    if (_pstgDoc) {
        return ResultFromScode(E_UNEXPECTED);
    }

    wStgm = _fReadOnly ?
                (STGM_READ | STGM_SHARE_DENY_WRITE) :
                (STGM_TRANSACTED | STGM_READWRITE | STGM_SHARE_EXCLUSIVE);
    hres = StgIsStorageFile(_wszFileName);
    if (hres != S_OK)
    {
        if (hres==S_FALSE) {
            hres = IDS_HRES_INVALID_SCRAPFILE;
        }
        return hres;
    }

    hres = StgOpenStorage(_wszFileName, NULL, wStgm, NULL, 0, &_pstgDoc);

#ifndef CLONE_IT_IF_READONLY
    //
    //  If we are opening without read-only flag and StgOpenStorage failed
    // with STG_E_ACCESSDENIED, retry it with read-only mode.
    //
    if ((hres==STG_E_ACCESSDENIED) && !_fReadOnly)
    {
        DebugMsg(DM_TRACE, TEXT("so TR - CSCS::DoVerb first StgOpenStorage failed, retrying it in read-only mode"));
        _fReadOnly = TRUE;
        wStgm = (STGM_READ | STGM_SHARE_DENY_WRITE);
        hres = StgOpenStorage(_wszFileName, NULL, wStgm, NULL, 0, &_pstgDoc);
    }
#else // CLONE_IT_IF_READONLY
    //
    //  If we are opening without read-only flag and StgOpenStorage failed
    // with STG_E_ACCESSDENIED, retry it with read-only mode.
    //
    if ((hres==STG_E_ACCESSDENIED) && !_fReadOnly)
    {
        LPSTORAGE pstgRead;
        DebugMsg(DM_TRACE, TEXT("so TR - CSCS::DoVerb first StgOpenStorage failed, retrying it in read-only mode"));
        hres = StgOpenStorage(_wszFileName, NULL, STGM_READ | STGM_SHARE_DENY_WRITE, NULL, 0, &pstgRead);
        if (SUCCEEDED(hres))
        {
            TCHAR szDesktop[MAX_PATH];
            TCHAR szTempFile[MAX_PATH];
            SHGetSpecialFolderPath(_hwndOwner, szDesktop, CSIDL_DESKTOP, FALSE);
            GetTempFileName(szDesktop, TEXT("Sh"), 0, szTempFile);
#ifdef UNICODE
            lstrcpyn(_wszFileName,szTempFile,ARRAYSIZE(szTempFile));
#else
            MultiByteToWideChar(CP_ACP, 0, szTempFile, -1, _wszFileName, ARRAYSIZE(_wszFileName));
#endif

            hres = StgCreateDocfile(_wszFileName,
                            STGM_DIRECT | STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                            0, &_pstgDoc);
            if (SUCCEEDED(hres))
            {
                hres = pstgRead->CopyTo(0, NULL, NULL, _pstgDoc);
                _pstgDoc->Release();
                _pstgDoc = NULL;

                if (SUCCEEDED(hres))
                {
                    hres = StgOpenStorage(_wszFileName, NULL, wStgm, NULL, 0, &_pstgDoc);
                    if (SUCCEEDED(hres))
                    {
                        _fCloned = TRUE;
                    }
                }
                else
                {
                    DeleteFile(szTempFile);
                }
            }
            pstgRead->Release();
        }
    }
#endif // CLONE_IT_IF_READONLY

    if (SUCCEEDED(hres))
    {
        if (_fReadOnly) {
            wStgm = STGM_READ|STGM_SHARE_EXCLUSIVE;
        }
        hres = _pstgDoc->OpenStorage(c_wszContents, NULL, wStgm, NULL, 0, &_pstg);
        if (SUCCEEDED(hres))
        {
            hres = OleLoad(_pstg, IID_IPersistStorage, this, (LPVOID *)&_ppstg);

            if (SUCCEEDED(hres)) {
                hres = _ppstg->QueryInterface(IID_IOleObject, (LPVOID *)&_pole);

                if (SUCCEEDED(hres))
                {
                    hres = _pole->Advise(this, &_dwConnection);
                    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::DoVerb IOleObject::Advise returned %x"), hres);
                    if (SUCCEEDED(hres))
                    {
                        TCHAR szTitle[MAX_PATH];
                        WCHAR wszTitle[MAX_PATH];
                        LoadString(g_hinst, IDS_TITLE, szTitle, ARRAYSIZE(szTitle));
#ifdef UNICODE
                        lstrcpyn(wszTitle,szTitle,ARRAYSIZE(wszTitle));
#else
                        MultiByteToWideChar(CP_ACP, 0, szTitle, lstrlen(szTitle)+1,
                                wszTitle, ARRAYSIZE(wszTitle));
#endif

                        GetFileName(szTitle, ARRAYSIZE(szTitle));
                        LPCWSTR pwszDisplayName = _wszFileName;
#ifndef UNICODE
                        WCHAR wszDisplayName[MAX_PATH];
#endif
                        SHFILEINFO info;
                        DWORD result = (DWORD)SHGetFileInfo(szTitle, 0,
                            &info, sizeof(info), SHGFI_DISPLAYNAME);

                        if(result && *info.szDisplayName)
                        {
#ifdef UNICODE
                            pwszDisplayName = info.szDisplayName;
#else
                            MultiByteToWideChar(CP_ACP, 0,
                                    info.szDisplayName, -1,
                                    wszDisplayName, ARRAYSIZE(wszDisplayName));
                            pwszDisplayName = wszDisplayName;
#endif
                        }

                        _pole->SetHostNames(wszTitle, pwszDisplayName);

                        //
                        // OLEBUG? Unless _hwndOwner has the input focus, 16-bit
                        //  server won't get the input focus.
                        //
                        SetFocus(_hwndOwner);

                        hres = _pole->DoVerb(iVerb, NULL, this, 0, _hwndOwner, NULL);
                        DebugMsg(DM_TRACE, TEXT("so TR - CSCS::DoVerb IOleObject::DoVerb returned %x"), hres);
                        if (SUCCEEDED(hres) && _fCloseImmediately) {
                            hres = S_FALSE;
                        }
                    }
                }
                else
                {
                    DebugMsg(DM_TRACE, TEXT("so ER - CSCS::DoVerb IPSTG::QI failed %x"), hres);
                }
            }
            else
            {
                DebugMsg(DM_TRACE, TEXT("so ER - CSCS::DoVerb OleLoad failed %x"), hres);
            }
        }
        else
        {
            DebugMsg(DM_TRACE, TEXT("so ER - CSCS::DoVerb _pstgDoc->OpenStorage failed %x"), hres);

            //
            // Notes: If we just return this hres as is, the user will see
            //  "Can't open file, FOO.SHS", which is bogus. We need to
            //  translate it into a much informative message.
            //
            hres = IDS_HRES_INVALID_SCRAPFILE;
        }
    }
    else
    {
        DebugMsg(DM_TRACE, TEXT("so ER - CSCS::DoVerb StgOpenStg failed %x"), hres);
    }

    return hres;
}

STDMETHODIMP_(void) CShClientSite::OnDataChange(FORMATETC *pFormatetc, STGMEDIUM *pStgmed)
{
    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::OnDataChange called"));
    _fDirty = TRUE;
}

STDMETHODIMP_(void) CShClientSite::OnViewChange(DWORD dwAspect, LONG lindex)
{
    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::OnViewChange called"));
    _fDirty = TRUE;
}

STDMETHODIMP_(void) CShClientSite::OnRename(IMoniker *pmk)
{
    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::OnRename called"));
    _fDirty = TRUE;
}

STDMETHODIMP_(void) CShClientSite::OnSave(void)
{
    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::OnSave called"));
    _fNeedToSave = TRUE;
}

STDMETHODIMP_(void) CShClientSite::OnClose(void)
{
    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::OnClose called"));
    if (_fNeedToSave /* && _fDirty */)
    {
        HRESULT hres;
        hres=OleSave(_ppstg, _pstg, TRUE);      // fSameStorage=TRUE
        DebugMsg(DM_TRACE, TEXT("so TR - CSCS:OnClose OleSave returned (%x)"), hres);
        hres=_ppstg->HandsOffStorage();
        DebugMsg(DM_TRACE, TEXT("so TR - CSCS:OnClose IPS:HandsOffStorage returned (%x)"), hres);
        if (SUCCEEDED(hres))
        {
            hres = _pstg->Commit(STGC_OVERWRITE);
            DebugMsg(DM_TRACE, TEXT("so TR - CSCS:OnClose _psg->Commit returned (%x)"), hres);
            hres = _pstgDoc->Commit(STGC_OVERWRITE);
            DebugMsg(DM_TRACE, TEXT("so TR - CSCS:OnClose _psgDoc->Commit returned (%x)"), hres);
        }
    }

    //
    // WARNING:
    //
    //  OLE1 server pukes if we release object here. However, we need to
    // call IOleObject::UnAdvice and IOleObject::SetClientSite(NULL) here
    // to avoid memory leak (RPC keeps 3 reference counts to IOleClientSite
    // if we delay it as well).
    //
    // ReleaseOleObject();
    //
    if (_dwConnection) {
        _pole->Unadvise(_dwConnection);
        _dwConnection = 0;
    }
    _pole->SetClientSite(NULL);

    PostMessage(_hwndOwner, WM_USER, 0, 0);
}

STDMETHODIMP_(void) CShClientSite::OnLinkSrcChange
(
    IMoniker *pmk
)
{
    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::OnLinkSrcChange called"));
    _fDirty = TRUE;
}

LRESULT CALLBACK ShWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT ps;
    HDC hdc;
    LPSHCLIENTSITE pscs = (LPSHCLIENTSITE)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        if (pscs)
        {
            pscs->Draw(hwnd, hdc);
        }
        EndPaint(hwnd, &ps);
        break;

    case WM_CLOSE:
        if (pscs)
        {
            pscs->CloseOleObject();
            DestroyWindow(hwnd);
        }
        break;

    case WM_USER:
        if (pscs)
        {
            pscs->ReleaseOleObject();
            PostMessage(hwnd, WM_CLOSE, 0, 0);
        }
        break;

    case WM_DESTROY:
        DebugMsg(DM_WARNING, TEXT("so WA - ShWndProc processing WM_DESTROY"));
        if (pscs)
        {
            pscs->Quit();
            pscs->Release();
            SetWindowLongPtr(hwnd, GWLP_USERDATA, 0);
        }
        else
        {
            DebugMsg(DM_WARNING, TEXT("so WA - ShWndProc pscs==NULL on WM_DESTROY"));
        }

#if 0
        //
        // Process all the pending messages, before we post WM_QUIT message.
        //
        MSG msg;
        while (PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
#endif

        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\shole\shole.h ===
//Prevent windows.h from pulling in OLE 1
#define _INC_OLE

#include <windows.h>
#include <stdlib.h>
#include <shlobj.h>
#include <shellapi.h>
#include <shlobjp.h>
#include <ole2ver.h>
#include <debug.h>

#define SAVE_OBJECTDESCRIPTOR
#define FIX_ROUNDTRIP

#define CCF_CACHE_GLOBAL        32
#define CCF_CACHE_CLSID         32
#define CCF_RENDER_CLSID        32
#define CCFCACHE_TOTAL  (CC_FCACHE_GLOBAL+CCF_CACHE_CLSID+CCF_RENDER_CLSID)


HRESULT CScrapData_CreateInstance(LPUNKNOWN * ppunk);

//
// global variables
//
extern UINT g_cRefThisDll;              // per-instance
extern HINSTANCE g_hinst;
extern "C" const WCHAR c_wszContents[];
extern "C" const WCHAR c_wszDescriptor[];

#define HINST_THISDLL g_hinst



#define CFID_EMBEDDEDOBJECT     0
#define CFID_OBJECTDESCRIPTOR   1
#define CFID_LINKSRCDESCRIPTOR  2
#define CFID_RICHTEXT           3
#define CFID_SCRAPOBJECT        4
#define CFID_MAX                5

#define CF_EMBEDDEDOBJECT       _GetClipboardFormat(CFID_EMBEDDEDOBJECT)
#define CF_OBJECTDESCRIPTOR     _GetClipboardFormat(CFID_OBJECTDESCRIPTOR)
#define CF_LINKSRCDESCRIPTOR    _GetClipboardFormat(CFID_LINKSRCDESCRIPTOR)
#define CF_RICHTEXT             _GetClipboardFormat(CFID_RICHTEXT)
#define CF_SCRAPOBJECT          _GetClipboardFormat(CFID_SCRAPOBJECT)

UINT _GetClipboardFormat(UINT id);
void DisplayError(HWND hwndOwner, HRESULT hres, UINT idsMsg, LPCTSTR szFileName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\shole\sccreate.c ===
#include "shole.h"
#include "ids.h"
#include <winnlsp.h>
#include <stdio.h>

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#ifdef SAVE_OBJECTDESCRIPTOR
extern "C" const WCHAR c_wszDescriptor[] = WSTR_SCRAPITEM L"ODS";


HRESULT Scrap_SaveODToStream(IStorage *pstgDoc, OBJECTDESCRIPTOR * pods)
{
    //
    // According to Anthony Kitowicz, we must clear this flag.
    //
    pods->dwStatus &= ~OLEMISC_CANLINKBYOLE1;

    IStream *pstm;
    HRESULT hres = pstgDoc->CreateStream(c_wszDescriptor, STGM_CREATE|STGM_WRITE|STGM_SHARE_EXCLUSIVE, 0, 0, &pstm);
    if (SUCCEEDED(hres))
    {
        ULONG cbWritten;
        hres = pstm->Write(pods, pods->cbSize, &cbWritten);
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_SOD descriptor written (%x, %d, %d)"),
                 hres, pods->cbSize, cbWritten);
        pstm->Release();

        if (FAILED(hres) || cbWritten<pods->cbSize) {
            pstgDoc->DestroyElement(c_wszDescriptor);
        }
    }
    else
    {
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_SOD pstg->CreateStream failed (%x)"), hres);
    }

    return hres;
}

HRESULT Scrap_SaveObjectDescriptor(IStorage *pstgDoc, IDataObject *pdtobj, IPersistStorage *pps, BOOL fLink)
{
    STGMEDIUM medium;
    FORMATETC fmte = {fLink ? CF_LINKSRCDESCRIPTOR : CF_OBJECTDESCRIPTOR, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    HRESULT hres = pdtobj->GetData(&fmte, &medium);
    if (hres == S_OK)
    {
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_SOD found CF_OBJECTDESCRIPTOR (%x)"), medium.hGlobal);
        LPOBJECTDESCRIPTOR pods = (LPOBJECTDESCRIPTOR)GlobalLock(medium.hGlobal);
        if (pods)
        {
            hres = Scrap_SaveODToStream(pstgDoc, pods);
            GlobalUnlock(medium.hGlobal);
        }
        ReleaseStgMedium(&medium);
    }
//
// Attempt to create object descriptor
//
#if 0
    else
    {
        hres = E_FAIL;
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_SOD CAN'T find CF_OBJECTDESCRIPTOR (%x)"), hres);
        LPOLEOBJECT pole;
        if (SUCCEEDED(pps->QueryInterface(IID_IOleObject, (LPVOID*)&pole)))
        {
            IMalloc *pmem;
            if (SUCCEEDED(CoGetMalloc(MEMCTX_TASK, &pmem)))
            {
                LPWSTR pwsz;
                if (SUCCEEDED(pole->GetUserType(USERCLASSTYPE_FULL, &pwsz)))
                {
                    UINT cbStr = pmem->GetSize(pwsz) + 1;
                    UINT cb = sizeof(OBJECTDESCRIPTOR) + cbStr;
                    LPOBJECTDESCRIPTOR pods=(LPOBJECTDESCRIPTOR)LocalAlloc(LPTR, cb);
                    if (pods)
                    {
                        pods->cbSize = cb;
                        pole->GetUserClassID(&pods->clsid);
                        pole->GetMiscStatus(DVASPECT_CONTENT, &pods->dwStatus);
                        pole->GetExtent(DVASPECT_CONTENT, &pods->sizel);
                        pods->dwFullUserTypeName = sizeof(OBJECTDESCRIPTOR);
                        MoveMemory(pods+1, pwsz, cbStr);
                        hres = Scrap_SaveODToStream(pstgDoc, pods);
                    }
                    pmem->Free(pwsz);
                }
                pmem->Release();
            }
            pole->Release();
        }
    }
#endif

    return hres;
}
#else
#define Scrap_SaveObjectDescriptor(pstgDoc, pdtobj, fLink) (0)
#endif // SAVE_OBJECTDESCRIPTOR

#ifdef FIX_ROUNDTRIP
extern "C" const TCHAR c_szCLSID[] = TEXT("CLSID");

//
//  This function opens the HKEY for the specified CLSID or its sub-key.
//
// Parameters:
//  rclsid    -- Specifies the CLSID
//  pszSubKey -- Specifies the subkey name, may be NULL
//
// Returns:
//  non-NULL, if succeeded; the caller must RegCloseKey it.
//  NULL, if failed.
//
HKEY _OpenCLSIDKey(REFCLSID rclsid, LPCTSTR pszSubKey)
{
#ifdef UNICODE
    WCHAR szCLSID[256];
    if (StringFromGUID2(rclsid, szCLSID, ARRAYSIZE(szCLSID)))
    {
#else
    WCHAR wszCLSID[256];
    if (StringFromGUID2(rclsid, wszCLSID, ARRAYSIZE(wszCLSID)))
    {
        TCHAR szCLSID[80];
        WideCharToMultiByte(CP_ACP, 0, wszCLSID, -1, szCLSID, ARRAYSIZE(szCLSID), NULL, NULL);
#endif

        TCHAR szKey[256];
        if (pszSubKey) {
            wsprintf(szKey, TEXT("%s\\%s\\%s"), c_szCLSID, szCLSID, pszSubKey);
        } else {
            wsprintf(szKey, TEXT("%s\\%s"), c_szCLSID, szCLSID);
        }
        DebugMsg(DM_TRACE, TEXT("sc TR - _OpelCLSIDKey RegOpenKey(%s)"), szKey);

        HKEY hkey;
        if (RegOpenKey(HKEY_CLASSES_ROOT, szKey, &hkey)==ERROR_SUCCESS)
        {
            return hkey;
        }
    }
    return NULL;
}

extern "C" const WCHAR c_wszFormatNames[] = WSTR_SCRAPITEM L"FMT";
#define CCH_FORMATNAMES (ARRAYSIZE(c_wszFormatNames)-1)

//
//  This function generates the stream name (UNICODE) for the spcified
// clipboard format.
//
// Parameters:
//  pszFormat -- Specifies the clipboard format ("#0"-"#15" for predefined ones)
//  wszStreamName -- Specifies the UNICODE buffer.
//  cchmax -- Specifies the size of buffer.
//
void _GetCacheStreamName(LPCTSTR pszFormat, LPWSTR wszStreamName, UINT cchMax)
{
    MoveMemory(wszStreamName, c_wszFormatNames, sizeof(c_wszFormatNames));
#ifdef UNICODE
    lstrcpyn(wszStreamName+CCH_FORMATNAMES,pszFormat,cchMax-CCH_FORMATNAMES);
#ifdef DEBUG
    DebugMsg(DM_TRACE, TEXT("sc TR _GetCacheStreamName returning %s"), wszStreamName);
#endif
#else
    MultiByteToWideChar(CP_ACP, 0, pszFormat, -1,
                        wszStreamName+CCH_FORMATNAMES,
                        cchMax-CCH_FORMATNAMES);
#ifdef DEBUG
    TCHAR szT[256];
    WideCharToMultiByte(CP_ACP, 0, wszStreamName, -1, szT, ARRAYSIZE(szT), NULL, NULL);
    DebugMsg(DM_TRACE, TEXT("sc TR _GetCacheStreamName returning %s"), szT);
#endif
#endif
}

HRESULT Scrap_CacheOnePictureFormat(LPCTSTR pszFormat, FORMATETC * pfmte, STGMEDIUM * pmedium, REFCLSID rclsid, LPSTORAGE pstgDoc, LPDATAOBJECT pdtobj)
{
    LPPERSISTSTORAGE ppstg;
    HRESULT hres = OleCreateDefaultHandler(rclsid, NULL, IID_IPersistStorage, (LPVOID *)&ppstg);
    DebugMsg(DM_TRACE, TEXT("sc TR Scrap_CacheOPF OleCreteDefHandler returned %x"), hres);
    if (SUCCEEDED(hres))
    {
        //
        // Generate the stream name based on the clipboard format name.
        //
        WCHAR wszStorageName[256];
        _GetCacheStreamName(pszFormat, wszStorageName, ARRAYSIZE(wszStorageName));

        LPSTORAGE pstgPicture;
        hres = pstgDoc->CreateStorage(wszStorageName, STGM_DIRECT | STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                    0, 0, &pstgPicture);
        if (SUCCEEDED(hres))
        {
            ppstg->InitNew(pstgPicture);

            LPOLECACHE pcache;
            hres = ppstg->QueryInterface(IID_IOleCache, (LPVOID*)&pcache);
            DebugMsg(DM_TRACE, TEXT("sc TR Scrap_CacheOPF QI returned %x"), hres);
            if (SUCCEEDED(hres))
            {
                hres = pcache->Cache(pfmte, ADVF_PRIMEFIRST, NULL);
                DebugMsg(DM_TRACE, TEXT("sc TR pcache->Cache returned %x"), hres);
                hres = pcache->SetData(pfmte, pmedium, FALSE);
                DebugMsg(DM_TRACE, TEXT("sc TR pcache->SetData returned %x"), hres);
                pcache->Release();

                if (SUCCEEDED(hres))
                {
                    hres = OleSave(ppstg, pstgPicture, TRUE);
                    DebugMsg(DM_TRACE, TEXT("sc TR Scrap_CacheOnePictureFormat OleSave returned (%x)"), hres);
                    ppstg->HandsOffStorage();

                    if (SUCCEEDED(hres))
                    {
                        hres = pstgPicture->Commit(STGC_OVERWRITE);
                        DebugMsg(DM_TRACE, TEXT("sc TR Scrap_CacheOnePictureFormat Commit() returned (%x)"), hres);
                    }
                }
            }

            pstgPicture->Release();

            if (FAILED(hres))
            {
                pstgDoc->DestroyElement(wszStorageName);
            }
        }

        ppstg->Release();
    }

    return hres;
}

//
//  This function stores the specified format of clipboard data.
//
// Parameters:
//  pszFormat -- Specifies the clipboard format ("#0"-"#15" for predefined ones)
//  pstgDoc -- Specifies the top level IStorage.
//  pdtobj -- Sepcified the data object we should get the data from.
//
HRESULT Scrap_CacheOneFormat(LPCTSTR pszFormat, LPSTORAGE pstgDoc, LPDATAOBJECT pdtobj)
{
    UINT cf = RegisterClipboardFormat(pszFormat);
    STGMEDIUM medium;
    FORMATETC fmte = {(CLIPFORMAT)cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    const CLSID * pclsid = NULL;
    switch(cf)
    {
    case CF_METAFILEPICT:
        pclsid = &CLSID_Picture_Metafile;
        fmte.tymed = TYMED_MFPICT;
        break;

    case CF_ENHMETAFILE:
        pclsid = &CLSID_Picture_EnhMetafile;
        fmte.tymed = TYMED_ENHMF;
        break;

    case CF_PALETTE:
    case CF_BITMAP:
        pclsid = &CLSID_Picture_Dib;
        fmte.tymed = TYMED_GDI;
        break;
    }

    //
    // Get the specified format of data (TYMED_GLOBAL only)
    //
    HRESULT hres = pdtobj->GetData(&fmte, &medium);
    if (hres == S_OK)
    {
        if (medium.tymed != TYMED_HGLOBAL)
        {
            hres = Scrap_CacheOnePictureFormat(pszFormat, &fmte, &medium, *pclsid, pstgDoc, pdtobj);
        }
        else
        {
            //
            // Global lock the data.
            //
            UINT cbData = (UINT)GlobalSize(medium.hGlobal);
            const BYTE * pbData = (const BYTE*)GlobalLock(medium.hGlobal);
            if (pbData)
            {
                //
                // Generate the stream name based on the clipboard format name.
                //
                WCHAR wszStreamName[256];
                _GetCacheStreamName(pszFormat, wszStreamName, ARRAYSIZE(wszStreamName));

                //
                // Create the stream.
                //
                LPSTREAM pstm;
                hres = pstgDoc->CreateStream(wszStreamName, STGM_CREATE|STGM_WRITE|STGM_SHARE_EXCLUSIVE, 0, 0, &pstm);
                if (SUCCEEDED(hres))
                {
                    //
                    // Save the size of data.
                    //
                    ULONG cbWritten;
                    hres = pstm->Write(&cbData, sizeof(cbData), &cbWritten);
                    if (SUCCEEDED(hres) && cbWritten==sizeof(cbData))
                    {
                        //
                        // Save the data itself.
                        //
                        hres = pstm->Write(pbData, cbData, &cbWritten);
                        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_Save %s written (%x, %d, %d)"),
                             pszFormat, hres, cbData, cbWritten);
                    }
                    pstm->Release();

                    //
                    // If anything goes wrong, destroy the stream.
                    //
                    if (FAILED(hres) || cbWritten<cbData)
                    {
                        pstgDoc->DestroyElement(wszStreamName);
                        hres = E_FAIL;
                    }
                }
                GlobalUnlock(medium.hGlobal);
            }
            else
            {
                hres = E_FAIL;
            }
        }
        ReleaseStgMedium(&medium);
    }
    else
    {
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CacheOneFormat IDO::GetData(cf=%x,tm=%x) failed (%x)"),
                 fmte.cfFormat, fmte.tymed, hres);
    }

    return hres;
}

//
//  This function caches the specified format of data if the data object
// support that format.
//
// Parameters:
//  szFormat -- Specifies the format to be cahced
//  pstgDoc  -- Specifies the top level IStorage
//  pdtobj   -- Specifies the data object from where we get data
//  pstm     -- Specifies the stream we should write cached format name.
//
// Returns:
//  TRUE if the data object support it.
//
BOOL Scrap_MayCacheOneFormat(LPCTSTR szFormat, LPSTORAGE pstgDoc, LPDATAOBJECT pdtobj, LPSTREAM pstm)
{
    //
    // Try to cache the format.
    //
    HRESULT hres = Scrap_CacheOneFormat(szFormat, pstgDoc, pdtobj);
    if (SUCCEEDED(hres))
    {
        //
        //  Store the name of format only if we actually
        // succeeded to cache the data.
        //
#ifdef UNICODE
        CHAR szAnsiFormat[128];
        WideCharToMultiByte(CP_ACP, 0,
                            szFormat, -1,
                            szAnsiFormat, ARRAYSIZE(szAnsiFormat),
                            NULL, NULL );
        USHORT cb = (USHORT)lstrlenA(szAnsiFormat);
#else
        USHORT cb = (USHORT)lstrlen(szFormat);
#endif
        pstm->Write(&cb, sizeof(cb), NULL);
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_MayCacheOneFormat writing %s, %d"), szFormat, cb);
#ifdef UNICODE
        pstm->Write(szAnsiFormat, cb, NULL);
#else
        pstm->Write(szFormat, cb, NULL);
#endif

        return TRUE;
    }

    return FALSE;
}

//
// Returns:
//  TRUE, if the specified format is already cached (from Global list).
//
BOOL Scrap_IsAlreadyCached(UINT acf[], UINT ccf, LPCTSTR szFormat)
{
    if (ccf)
    {
        UINT cf = RegisterClipboardFormat(szFormat);
        for (UINT icf=0; icf<ccf; icf++) {
            if (acf[icf]==cf) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

extern "C" const TCHAR c_szCacheFMT[] = TEXT("DataFormats\\PriorityCacheFormats");
#define REGSTR_PATH_SCRAP TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ShellScrap")
extern "C" const TCHAR c_szGlobalCachedFormats[] = REGSTR_PATH_SCRAP TEXT("\\PriorityCacheFormats");

//
//  This function enumerate the list of to-be-cached clipboard data and
// calls Scrap_CacheOneFormat for each of them.
//
// Parameters:
//  pstgDoc -- Specifies the top level IStorage.
//  pdtobj  -- Specifies the data object we'll get the data from.
//  pps     -- Specifies the "embedded object" (to get CLSID from)
//
void Scrap_CacheClipboardData(LPSTORAGE pstgDoc, LPDATAOBJECT pdtobj, LPPERSIST pps)
{
    //
    //  Create the stream where we'll store the list of actually
    // cached formats, which might be just a subset of to-be-cached
    // format specified in the registry.
    //
    LPSTREAM pstm;
    HRESULT hres = pstgDoc->CreateStream(c_wszFormatNames, STGM_CREATE|STGM_WRITE|STGM_SHARE_EXCLUSIVE, 0, 0, &pstm);

    DebugMsg(DM_TRACE, TEXT("sc TR S_CCD CreateStream returned %x"), hres);

    if (SUCCEEDED(hres))
    {
        USHORT cb;
        HKEY hkey;
        TCHAR szFormatName[128];
        DWORD cchValueName;
        DWORD dwType;
        UINT  acf[CCF_CACHE_GLOBAL];
        UINT  ccf = 0;

        //
        // First, try the formats in the global list.
        //
        if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szGlobalCachedFormats, &hkey)==ERROR_SUCCESS)
        {
            //
            // For each global to-be-cached format...
            //
            for(int iValue=0; iValue<CCF_CACHE_GLOBAL ;iValue++)
            {
                //
                //  Get the value name of the iValue'th value. The value
                // name specifies the clipboard format.
                // ("#0"-"#15" for predefined formats).
                //
                cchValueName = ARRAYSIZE(szFormatName);
                if (RegEnumValue(hkey, iValue, szFormatName, &cchValueName, NULL,
                                 &dwType, NULL, NULL)==ERROR_SUCCESS)
                {
                    DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CacheClipboardData found with %s, %x (Global)"), szFormatName, dwType);
                    if (Scrap_MayCacheOneFormat(szFormatName, pstgDoc, pdtobj, pstm))
                    {
                        acf[ccf++] = RegisterClipboardFormat(szFormatName);
                    }
                }
                else
                {
                    break;
                }
            }

            RegCloseKey(hkey);
        }

        //
        // Then, try the CLSID specific formats.
        //
        // Get the CLSID of the "embedded object" (the body of scrap)
        //
        CLSID clsid;
        hres = pps->GetClassID(&clsid);
        if (SUCCEEDED(hres))
        {
            //
            // Open the key for the list of to-be-cached formats.
            //
            hkey = _OpenCLSIDKey(clsid, c_szCacheFMT);
            if (hkey)
            {
                //
                // For each class specific to-be-cached format...
                //
                for(int iValue=0; iValue<CCF_CACHE_CLSID ;iValue++)
                {
                    //
                    //  Get the value name of the iValue'th value. The value
                    // name specifies the clipboard format.
                    // ("#0"-"#15" for predefined formats).
                    //
                    cchValueName = ARRAYSIZE(szFormatName);

                    if (RegEnumValue(hkey, iValue, szFormatName, &cchValueName, NULL,
                                     &dwType, NULL, NULL)==ERROR_SUCCESS)
                    {
                        if (!Scrap_IsAlreadyCached(acf, ccf, szFormatName))
                        {
                            DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CacheClipboardData found with %s, %x (CLSID specific)"), szFormatName, dwType);
                            Scrap_MayCacheOneFormat(szFormatName, pstgDoc, pdtobj, pstm);
                        }
                        else
                        {
                            DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CacheClipboardData skipping %s (already cached)"), szFormatName);
                        }
                    }
                    else
                    {
                        break;
                    }
                }

                //
                // HACK: NT 3.5's RegEdit does not support named values...
                //
                for(iValue=0; iValue<CCF_CACHE_CLSID ;iValue++)
                {
                    TCHAR szKeyName[128];
                    if (RegEnumKey(hkey, iValue, szKeyName, ARRAYSIZE(szKeyName))==ERROR_SUCCESS)
                    {
                        LONG cbValue = ARRAYSIZE(szFormatName);
                        if ((RegQueryValue(hkey, szKeyName, szFormatName, &cbValue)==ERROR_SUCCESS) && cbValue)
                        {
                            if (!Scrap_IsAlreadyCached(acf, ccf, szFormatName))
                            {
                                DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CacheClipboardData found with %s, %x (CLSID specific)"), szFormatName, dwType);
                                Scrap_MayCacheOneFormat(szFormatName, pstgDoc, pdtobj, pstm);
                            }
                            else
                            {
                                DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CacheClipboardData skipping %s (already cached)"), szFormatName);
                            }
                        }
                    }
                    else
                    {
                        break;
                    }
                }

                RegCloseKey(hkey);
            }
        }

        //
        // Put the terminator.
        //
        cb = 0;
        pstm->Write(&cb, sizeof(cb), NULL);
        pstm->Release();

    }

}
#endif // FIX_ROUNDTRIP

// out:
//      pszName - short name for object type ("Worksheet", "Word Document", etc)
//
// returns:
//

HRESULT Scrap_Save(IStorage *pstg, IStorage *pstgDoc, IDataObject *pdtobj, BOOL fLink, LPTSTR pszName)
{
    IPersistStorage *pps;
    HRESULT hres;

    if (fLink)
    {
        FORMATETC fmte = {CF_METAFILEPICT, NULL, DVASPECT_ICON, -1, TYMED_MFPICT};
        hres = OleCreateLinkFromData(pdtobj, IID_IPersistStorage, OLERENDER_FORMAT,
                                     &fmte, NULL, pstg, (LPVOID*)&pps);
        DebugMsg(DM_TRACE, TEXT("sc Scrap_Save OleCreateLinkFromData(FMT) returned (%x)"), hres);
    }
    else
    {
        hres = OleCreateFromData(pdtobj, IID_IPersistStorage, OLERENDER_DRAW,
                                 NULL, NULL, pstg, (LPVOID*)&pps);
        DebugMsg(DM_TRACE, TEXT("sc Scrap_Save OleCreateFromData(FMT) returned (%x)"), hres);
    }

    if (SUCCEEDED(hres))
    {
        hres = OleSave(pps, pstg, TRUE);        // fSameStorage=TRUE

        DebugMsg(DM_TRACE, TEXT("sc Scrap_Save OleSave returned (%x)"), hres);

        if (SUCCEEDED(hres) && pszName)
        {
            LPOLEOBJECT pole;
            if (SUCCEEDED(pps->QueryInterface(IID_IOleObject, (LPVOID*)&pole)))
            {
                IMalloc *pmem;
                if (SUCCEEDED(CoGetMalloc(MEMCTX_TASK, &pmem)))
                {
                    LPWSTR pwsz;
                    if (SUCCEEDED(pole->GetUserType(USERCLASSTYPE_SHORT, &pwsz)))
                    {
#ifdef UNICODE
                        lstrcpyn(pszName, pwsz, 64);    // What is 64?
#else
                        WideCharToMultiByte(CP_ACP, 0, pwsz, -1, pszName, 64, NULL, NULL);
#endif

                        DebugMsg(DM_TRACE, TEXT("sc Scrap_Save short name (%s)"), pszName);

                        // Assert(lstrlen(pszName) < 15); // USERCLASSTYPE_SHORT docs say so
                        pmem->Free(pwsz);
                    }
                    pmem->Release();
                }
                pole->Release();
            }
        }

        // This is no-op if SAVE_OBJECTDESCRIPTOR is not defined.
        Scrap_SaveObjectDescriptor(pstgDoc, pdtobj, pps, fLink);

#ifdef FIX_ROUNDTRIP
        if (!fLink)
        {
            Scrap_CacheClipboardData(pstgDoc, pdtobj, pps);
        }
#endif // FIX_ROUNDTRIP

        hres = pps->HandsOffStorage();

        pps->Release();
    }

    return hres;
}

// get some text from the data object
//
// out:
//      pszOut  filled in with text
//

HRESULT Scrap_GetText(IDataObject *pdtobj, LPTSTR pszOut, UINT cchMax)
{
    UINT cbMac = (cchMax-1)*sizeof(pszOut[0]);
    memset(pszOut, 0, cchMax * sizeof(pszOut[0]));

    STGMEDIUM medium;
    HRESULT hres;
#ifdef UNICODE
    UINT CodePage = CP_ACP;
    BOOL bUnicode = TRUE;

    FORMATETC fmte = { CF_UNICODETEXT, NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM | TYMED_HGLOBAL };
    hres = pdtobj->QueryGetData( &fmte );
    if (hres != S_OK)           // S_FALSE means no.
    {
        fmte.cfFormat = CF_TEXT;
        bUnicode = FALSE;
    }
    hres = pdtobj->GetData(&fmte, &medium);

    if (bUnicode == FALSE && hres == S_OK)
    {
        //
        //  We have ANSI text but no UNICODE Text.  Look for RTF in order to
        //  see if we can find a language id so that we can use the correct
        //  code page for the Ansi to Unicode translation.
        //
        FORMATETC fetcrtf = { 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL | TYMED_ISTREAM };
        fetcrtf.cfFormat = (CLIPFORMAT)RegisterClipboardFormat(TEXT("Rich Text Format"));
        STGMEDIUM mediumrtf;

        if (SUCCEEDED(pdtobj->GetData(&fetcrtf, &mediumrtf)))
        {
            CHAR szBuf[MAX_PATH * 8];
            LPSTR pszRTF = NULL;

            if (mediumrtf.tymed == TYMED_ISTREAM)
            {
                if (SUCCEEDED(mediumrtf.pstm->Read((LPTSTR)szBuf, ARRAYSIZE(szBuf), NULL)))
                {
                    pszRTF = szBuf;
                }
            }
            else
            {
                pszRTF = (LPSTR)GlobalLock(mediumrtf.hGlobal);
            }

            if (pszRTF)
            {
                LPSTR pTmp;

                //
                //  Find the language id used for this text.
                //
                //  Ugly way to search, but can't use c-runtimes in the
                //  shell.
                //
                CHAR szLang[5];
                UINT LangID = 0;

                pTmp = pszRTF;
                while (*pTmp)
                {
                    if ((*pTmp == '\\') &&
                        *(pTmp + 1)    && (*(pTmp + 1) == 'l') &&
                        *(pTmp + 2)    && (*(pTmp + 2) == 'a') &&
                        *(pTmp + 3)    && (*(pTmp + 3) == 'n') &&
                        *(pTmp + 4)    && (*(pTmp + 4) == 'g'))
                    {
                        //
                        //  Get number following the \lang identifier.
                        //
                        int ctr;

                        pTmp += 5;
                        for (ctr = 0;
                             (ctr < 4) && (*(pTmp + ctr)) &&
                             ((*(pTmp + ctr)) >= '0') && ((*(pTmp + ctr)) <= '9');
                             ctr++)
                        {
                            szLang[ctr] = *(pTmp + ctr);
                        }
                        szLang[ctr] = 0;

                        for (pTmp = szLang; *pTmp; pTmp++)
                        {
                            LangID *= 10;
                            LangID += (*pTmp - '0');
                        }

                        break;
                    }
                    pTmp++;
                }
                if (LangID)
                {
                    if (!GetLocaleInfo( LangID,
                                        LOCALE_IDEFAULTANSICODEPAGE |
                                          LOCALE_RETURN_NUMBER,
                                        (LPTSTR)&CodePage,
                                        sizeof(UINT) / sizeof(TCHAR) ))
                    {
                        CodePage = CP_ACP;
                    }
                }

                if (mediumrtf.tymed == TYMED_HGLOBAL)
                {
                    GlobalUnlock(mediumrtf.hGlobal);
                }
            }
        }
    }

#else
    FORMATETC fmte = { CF_TEXT, NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM|TYMED_HGLOBAL };
    hres = pdtobj->GetData(&fmte, &medium);
#endif

    if (SUCCEEDED(hres))
    {
        DebugMsg(DM_TRACE, TEXT("sh TR - Scrap_GetText found CF_TEXT/CF_UNICODETEXT in %d"), medium.tymed);
        if (medium.tymed == TYMED_ISTREAM)
        {
            hres = medium.pstm->Read(pszOut, cbMac, NULL);
        }
        else if (medium.tymed == TYMED_HGLOBAL)
        {
            DebugMsg(DM_TRACE, TEXT("sh TR - Scrap_GetText found CF_TEXT/CF_UNICODETEXT in global"));
            LPCTSTR pszSrc = (LPCTSTR)GlobalLock(medium.hGlobal);
            if (pszSrc)
            {
#ifdef UNICODE
                if ( fmte.cfFormat == CF_TEXT )
                {
                    MultiByteToWideChar( CodePage, 0,
                                         (LPSTR)pszSrc, cchMax,
                                         pszOut, cchMax );
                }
                else
#endif
                {
                    MoveMemory(pszOut, pszSrc, cbMac);
                }
                GlobalUnlock(medium.hGlobal);
            }
        }
        ReleaseStgMedium(&medium);
    }

    return hres;
}


// Avoid linking lots of CRuntime stuff.
#undef isdigit
#undef isalpha
#define isdigit(ch) (ch>=TEXT('0') && ch<=TEXT('9'))
#define isalpha(ch) ((ch&0xdf)>=TEXT('A') && (ch&0xdf)<=TEXT('Z'))

#define CCH_MAXLEADINGSPACE     256
#define CCH_COPY                16

//
// create a fancy name for a scrap/doc shortcut given the data object to get some
// text from
//
// out:
//      pszNewName      - assumed to be 64 chars at least
//

BOOL Scrap_GetFancyName(IDataObject *pdtobj, UINT idTemplate, LPCTSTR pszPath, LPCTSTR pszTypeName, LPTSTR pszNewName)
{
    TCHAR szText[CCH_MAXLEADINGSPACE + CCH_COPY + 1];
    HRESULT hres = Scrap_GetText(pdtobj, szText, ARRAYSIZE(szText));

    if (SUCCEEDED(hres))
    {
#ifdef UNICODE
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_GetFancyName CF_UNICODETEXT has (%s)"), szText);
#else
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_GetFancyName CF_TEXT has (%s)"), szText);
#endif
        LPTSTR pszStart;
        //
        // skip leading space/non-printing characters
        //
        for (pszStart = szText; *pszStart <= TEXT(' '); pszStart++)
        {
            if (*pszStart == TEXT('\0'))
                return FALSE;   // empty string

            if (pszStart - szText >= CCH_MAXLEADINGSPACE)
                return FALSE;   // too many leading space
        }
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_GetFancyName pszStart (%s)"), pszStart);

        //
        // Chacter conversion
        //  (1) non-printing characters -> ' '
        //  (2) invalid characters -> '_'
        //
        for (LPTSTR pszT = pszStart; *pszT && ((pszT-pszStart) < CCH_COPY); pszT = CharNext(pszT))
        {
            TCHAR ch = *pszT;
            if (ch <= TEXT(' '))
            {
                *pszT = TEXT(' ');
            }
            else if (ch < 127 && !isdigit(ch) && !isalpha(ch))
            {
                switch(ch)
                {
                case TEXT('$'):
                case TEXT('%'):
                case TEXT('\''):
                case TEXT('-'):
                case TEXT('_'):
                case TEXT('@'):
                case TEXT('~'):
                case TEXT('`'):
                case TEXT('!'):
                case TEXT('('):
                case TEXT(')'):
                case TEXT('{'):
                case TEXT('}'):
                case TEXT('^'):
                case TEXT('#'):
                case TEXT('&'):
                    break;

                default:
                    *pszT = TEXT('_');
                    break;
                }
            }
        }
        *pszT = 0;

        TCHAR szTemplate[MAX_PATH];
        TCHAR szName[MAX_PATH];

        LoadString(HINST_THISDLL, idTemplate, szTemplate, ARRAYSIZE(szTemplate));
        wsprintf(szName, szTemplate, pszTypeName, pszStart);

        PathCombine(szName, pszPath, szName);

        if (!PathFileExists(szName))
        {
            DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_GetFancyName (%s)"), szName);
            lstrcpy(pszNewName, szName);
            return TRUE;
        }
    }
    return FALSE;
}

// *** WARNING ***
//
// Scrap_CreateFromDataObject is a TCHAR export from SHSCRAP.DLL that is used by SHELL32.DLL. If you
// change its calling convention, you must modify shell32's wrapper as well as well.
//
// *** WARNING ***
HRESULT WINAPI Scrap_CreateFromDataObject(LPCTSTR pszPath, IDataObject *pdtobj, BOOL fLink, LPTSTR pszNewFile)
{
    HRESULT hres;
    TCHAR szTemplateS[32];
    TCHAR szTemplateL[128];
    TCHAR szTypeName[64];
#ifndef UNICODE
    WCHAR wszNewFile[MAX_PATH];
#endif
    IStorage *pstg;
    UINT idErr = 0;

    DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CreateFromDataObject called at %s"), pszPath);

    LoadString(HINST_THISDLL, fLink ? IDS_BOOKMARK_S : IDS_SCRAP_S, szTemplateS, ARRAYSIZE(szTemplateS));
    LoadString(HINST_THISDLL, fLink ? IDS_BOOKMARK_L : IDS_SCRAP_L, szTemplateL, ARRAYSIZE(szTemplateL));

    PathYetAnotherMakeUniqueName(pszNewFile, pszPath, szTemplateS, szTemplateL);

    DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CreateFromDataObject creating %s"), pszNewFile);

#ifdef UNICODE
    hres = StgCreateDocfile(pszNewFile,
                    STGM_DIRECT | STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                    0, &pstg);
#else
    MultiByteToWideChar(CP_ACP, 0, pszNewFile, -1, wszNewFile, ARRAYSIZE(wszNewFile));

    hres = StgCreateDocfile(wszNewFile,
                    STGM_DIRECT | STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                    0, &pstg);
#endif

    if (SUCCEEDED(hres))
    {
        IStorage *pstgContents;

        hres = pstg->CreateStorage(c_wszContents, STGM_DIRECT | STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                    0, 0, &pstgContents);

        if (SUCCEEDED(hres))
        {
            hres = Scrap_Save(pstgContents, pstg, pdtobj, fLink, szTypeName);
            if (SUCCEEDED(hres))
            {
                hres = pstgContents->Commit(STGC_OVERWRITE);
                if (FAILED(hres))
                    idErr = IDS_ERR_COMMIT;
            }
            else
            {
                idErr = IDS_ERR_SCRAPSAVE;
            }
            pstgContents->Release();
        }
        else
        {
            idErr = IDS_ERR_CREATESTORAGE;
        }

        //
        // We need to delete the file, if failed to save/commit.
        //
        if (SUCCEEDED(hres))
        {
            hres = pstg->Commit(STGC_OVERWRITE);
            if (FAILED(hres))
                idErr = IDS_ERR_COMMIT;
        }

        pstg->Release();

        if (FAILED(hres))
            DeleteFile(pszNewFile);
    }
    else
    {
        idErr = IDS_ERR_CREATEDOCFILE;
    }

    if (SUCCEEDED(hres))
    {
        if (IsLFNDrive(pszPath))
        {
            TCHAR szFancyName[MAX_PATH];

            if (Scrap_GetFancyName(pdtobj, fLink ? IDS_TEMPLINK : IDS_TEMPSCRAP, pszPath, szTypeName, szFancyName))
            {
                if (MoveFile(pszNewFile, szFancyName))
                    lstrcpy(pszNewFile, szFancyName);
            }
        }
    }
    else
    {
        DisplayError((HWND)NULL, hres, idErr, pszNewFile);
    }

    return hres;
}

#ifdef DEBUG
static const LPFNSCRAPCREATEFROMDATAOBJECT s_pfn = Scrap_CreateFromDataObject;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\shole\template.c ===
#include "shole.h"
#include "ids.h"
#include "scguid.h"

extern TEXT("C") const TCHAR c_szCLSID[];

class CTemplateFolder : public IShellFolder, public IPersistFolder
{
public:
    CTemplateFolder();
    ~CTemplateFolder();

protected:
    // IUnKnown
    virtual HRESULT __stdcall QueryInterface(REFIID,void **);
    virtual ULONG   __stdcall AddRef(void);
    virtual ULONG   __stdcall Release(void);

    // IShellFolder
    virtual HRESULT __stdcall ParseDisplayName(HWND hwndOwner,
        LPBC pbcReserved, LPOLESTR lpszDisplayName,
        ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);

    virtual HRESULT __stdcall EnumObjects( THIS_ HWND hwndOwner, DWORD grfFlags, LPENUMIDLIST * ppenumIDList);

    virtual HRESULT __stdcall BindToObject(LPCITEMIDLIST pidl, LPBC pbcReserved,
                                 REFIID riid, LPVOID * ppvOut);
    virtual HRESULT __stdcall BindToStorage(LPCITEMIDLIST pidl, LPBC pbcReserved,
                                 REFIID riid, LPVOID * ppvObj);
    virtual HRESULT __stdcall CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual HRESULT __stdcall CreateViewObject (HWND hwndOwner, REFIID riid, LPVOID * ppvOut);
    virtual HRESULT __stdcall GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl,
                                    ULONG * rgfInOut);
    virtual HRESULT __stdcall GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, LPVOID * ppvOut);
    virtual HRESULT __stdcall GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    virtual HRESULT __stdcall SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl,
                                 LPCOLESTR lpszName, DWORD uFlags,
                                 LPITEMIDLIST * ppidlOut);

    // IPersistFolder
    virtual HRESULT __stdcall GetClassID(LPCLSID lpClassID);
    virtual HRESULT __stdcall Initialize(LPCITEMIDLIST pidl);

    // Defview callback
    friend HRESULT CALLBACK DefViewCallback(
                                LPSHELLVIEW psvOuter, LPSHELLFOLDER psf,
                                HWND hwndOwner, UINT uMsg,
                                WPARAM wParam, LPARAM lParam);

    BOOL IsMyPidl(LPCITEMIDLIST pidl)
        { return pidl->mkid.cb == SIZEOF(pidl->mkid.cb)+SIZEOF(CLSID); }

    UINT _cRef;
};

class CEnumTemplate : public IEnumIDList
{
public:
    CEnumTemplate();
    ~CEnumTemplate();

protected:
    // IUnKnown
    virtual HRESULT __stdcall QueryInterface(REFIID,void **);
    virtual ULONG   __stdcall AddRef(void);
    virtual ULONG   __stdcall Release(void);

    virtual HRESULT __stdcall Next(ULONG celt,
                      LPITEMIDLIST *rgelt,
                      ULONG *pceltFetched);
    virtual HRESULT __stdcall Skip(ULONG celt);
    virtual HRESULT __stdcall Reset();
    virtual HRESULT __stdcall Clone(IEnumIDList **ppenum);

    UINT        _cRef;
    UINT        _iCur;
    HKEY        _hkeyCLSID;
    struct {
        ITEMIDLIST  idl;
        BYTE        __abRest[255];      // Enough for CLSID or ProgID
    } _tidl;
};


class CTemplateUIObj : public IExtractIcon, public IDataObject
{
public:
    static HRESULT Create(REFCLSID, REFIID, LPVOID*);
protected:
    CTemplateUIObj(REFCLSID rclsid)
                    : _clsid(rclsid), _cRef(1)
                                { g_cRefThisDll++; }
    ~CTemplateUIObj()           { g_cRefThisDll--; }
    HRESULT _CreateInstance(IStorage* pstg);

    // IUnKnown
    virtual HRESULT __stdcall QueryInterface(REFIID,void **);
    virtual ULONG   __stdcall AddRef(void);
    virtual ULONG   __stdcall Release(void);

    // *** IExtractIcon methods ***
    virtual HRESULT __stdcall GetIconLocation(
                         UINT   uFlags, LPTSTR  szIconFile,
                         UINT   cchMax, int   * piIndex,
                         UINT  * pwFlags);

    virtual HRESULT __stdcall Extract(
                           LPCTSTR pszFile, UINT          nIconIndex,
                           HICON   *phiconLarge, HICON   *phiconSmall,
                           UINT    nIconSize);

    // IDataObject
    virtual HRESULT __stdcall GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);
    virtual HRESULT __stdcall GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium);
    virtual HRESULT __stdcall QueryGetData(FORMATETC *pformatetc);
    virtual HRESULT __stdcall GetCanonicalFormatEtc(FORMATETC *pformatectIn, FORMATETC *pformatetcOut);
    virtual HRESULT __stdcall SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease);
    virtual HRESULT __stdcall EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc);
    virtual HRESULT __stdcall DAdvise(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, DWORD *pdwConnection);
    virtual HRESULT __stdcall DUnadvise(DWORD dwConnection);
    virtual HRESULT __stdcall EnumDAdvise(IEnumSTATDATA **ppenumAdvise);

    UINT        _cRef;
    CLSID       _clsid;
};


CTemplateFolder::CTemplateFolder() : _cRef(1)
{
    OleInitialize(NULL);
    g_cRefThisDll++;
}

CTemplateFolder::~CTemplateFolder()
{
    OleUninitialize();
    g_cRefThisDll--;
}

HRESULT CTemplateFolder::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IShellFolder) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IShellFolder*)this;
        _cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IPersistFolder))
    {
        *ppvObj = (IPersistFolder*)this;
        _cRef++;
        return S_OK;
    }
    *ppvObj = NULL;

    return E_NOINTERFACE;
}

ULONG CTemplateFolder::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CTemplateFolder::Release()
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CTemplateFolder_CreateInstnace(LPUNKNOWN * ppunk)
{
    CTemplateFolder* ptfld = new CTemplateFolder();
    if (ptfld) {
        *ppunk = (IShellFolder *)ptfld;
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT CTemplateFolder::ParseDisplayName(HWND hwndOwner,
        LPBC pbcReserved, LPOLESTR lpszDisplayName,
        ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes)
{
    return E_NOTIMPL;
}

HRESULT CTemplateFolder::EnumObjects(HWND hwndOwner, DWORD grfFlags, LPENUMIDLIST * ppenumIDList)
{
    *ppenumIDList = new CEnumTemplate();
    return S_OK;
}

HRESULT CTemplateFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbcReserved,
                                 REFIID riid, LPVOID * ppvOut)
{
    return E_NOTIMPL;
}

HRESULT CTemplateFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbcReserved,
                                 REFIID riid, LPVOID * ppvObj)
{
    return E_NOTIMPL;
}

HRESULT CTemplateFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    return E_NOTIMPL;
}


HRESULT CALLBACK DefViewCallback(LPSHELLVIEW psvOuter, LPSHELLFOLDER psf,
                                HWND hwndOwner, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // APPCOMPAT: DefView GPF if I don't pass the callback function!
    // APPCOMPAT: DefView GPF if it returns S_FALSE as the default!
    return E_FAIL; // S_FALSE;
}


HRESULT CTemplateFolder::CreateViewObject (HWND hwndOwner, REFIID riid, LPVOID * ppvOut)
{
    if (IsEqualIID(riid, IID_IShellView))
    {
        CSFV csfv = {
            SIZEOF(CSFV),       // cbSize
            this,               // pshf
            NULL,               // psvOuter
            NULL,               // pidl
            0,
            DefViewCallback,    // pfnCallback
            FVM_ICON,
        };
        return SHCreateShellFolderViewEx(&csfv, (LPSHELLVIEW *)ppvOut);
    }
    return E_NOINTERFACE;
}

HRESULT CTemplateFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl,
                                    ULONG * rgfInOut)
{
    UINT rgfOut = SFGAO_CANCOPY | SFGAO_HASPROPSHEET;
    *rgfInOut = rgfOut;
    return S_OK;
}

HRESULT CTemplateFolder::GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, LPVOID * ppvOut)
{
    HRESULT hres = E_INVALIDARG;
    if (cidl==1 && IsMyPidl(apidl[0]))
    {
        const CLSID* pclsid = (const CLSID*)&apidl[0]->mkid.abID;
        hres = CTemplateUIObj::Create(*pclsid, riid, ppvOut);
    }

    return hres;
}

HRESULT _KeyNameFromCLSID(REFCLSID rclsid, LPTSTR pszKey, UINT cchMax)
{
    LPWSTR pwszKey;
    HRESULT hres = StringFromCLSID(rclsid, &pwszKey);
    if (FAILED(hres)) {
        return E_INVALIDARG;
    }

    lstrcpyn(pszKey, TEXT("CLSID\\"), cchMax);
    WideCharToMultiByte(CP_ACP, 0, pwszKey, -1, pszKey+6, cchMax-6, NULL, NULL);

    // FEATURE: Use TASK ALLOCATOR!!!
    LocalFree(pwszKey);
    return S_OK;
}

HRESULT CTemplateFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName)
{
    if (!IsMyPidl(pidl)) {
        return E_INVALIDARG;
    }

    LPCLSID const pclsid = (LPCLSID)pidl->mkid.abID;
    TCHAR szKey[128];
    HRESULT hres = _KeyNameFromCLSID(*pclsid, szKey, ARRAYSIZE(szKey));
    if (FAILED(hres)) {
        return hres;
    }

    LONG dwSize = ARRAYSIZE(lpName->cStr);
    if (RegQueryValue(HKEY_CLASSES_ROOT, szKey, lpName->cStr, &dwSize) == ERROR_SUCCESS)
    {
        lpName->uType = STRRET_CSTR;
        return S_OK;
    }

    return E_FAIL;
}

HRESULT CTemplateFolder::SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl,
                                 LPCOLESTR lpszName, DWORD uFlags,
                                 LPITEMIDLIST * ppidlOut)
{
    return E_NOTIMPL;
}

HRESULT __stdcall CTemplateFolder::GetClassID(LPCLSID lpClassID)
{
    *lpClassID = CLSID_CTemplateFolder;
    return S_OK;
}

HRESULT __stdcall CTemplateFolder::Initialize(LPCITEMIDLIST pidl)
{
    return S_OK;
}

CEnumTemplate::CEnumTemplate() : _cRef(1), _iCur(0), _hkeyCLSID(NULL)
{
    g_cRefThisDll++;
}

CEnumTemplate::~CEnumTemplate()
{
    if (_hkeyCLSID) {
        RegCloseKey(_hkeyCLSID);
    }
    g_cRefThisDll--;
}

HRESULT CEnumTemplate::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IEnumIDList) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IEnumIDList*)this;
        _cRef++;
        return S_OK;
    }
    *ppvObj = NULL;

    return E_NOINTERFACE;
}

ULONG CEnumTemplate::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CEnumTemplate::Release()
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CEnumTemplate::Next(ULONG celt,
                      LPITEMIDLIST *rgelt,
                      ULONG *pceltFetched)
{
    // Assume error
    if (pceltFetched) {
        *pceltFetched = 0;
    }

    if (!_hkeyCLSID)
    {
        if (RegOpenKey(HKEY_CLASSES_ROOT, c_szCLSID, &_hkeyCLSID) != ERROR_SUCCESS)
        {
            return E_FAIL;
        }
    }

    TCHAR szKey[40];    // enough for {CLSID}
    while (RegEnumKey(_hkeyCLSID, _iCur++, szKey, ARRAYSIZE(szKey)) == ERROR_SUCCESS)
    {
        TCHAR szInsertable[128];        // enough for "{CLSID}/Insertable"
        wsprintf(szInsertable, TEXT("%s\\Insertable"), szKey);
        HKEY hkeyT;

        if (RegOpenKey(_hkeyCLSID, szInsertable, &hkeyT) == ERROR_SUCCESS)
        {
            RegCloseKey(hkeyT);

            CLSID clsid;
            WCHAR wszKey[40];
            MultiByteToWideChar(CP_ACP, 0, szKey, -1, wszKey, ARRAYSIZE(wszKey));
            HRESULT hres = CLSIDFromString(wszKey, &clsid);
            if (SUCCEEDED(hres))
            {
                _tidl.idl.mkid.cb = SIZEOF(_tidl.idl.mkid.cb) + SIZEOF(clsid);
                memcpy(_tidl.idl.mkid.abID, &clsid, SIZEOF(clsid));
                LPITEMIDLIST pidl = _ILNext(&_tidl.idl);
                pidl->mkid.cb = 0;      // Terminator
                rgelt[0] = ILClone(&_tidl.idl);
                *pceltFetched = 1;
                return S_OK;
            }
        }
    }

    return S_FALSE;     // no more element
}

HRESULT CEnumTemplate::Skip(ULONG celt)
{
    return E_NOTIMPL;
}

HRESULT CEnumTemplate::Reset()
{
    return E_NOTIMPL;
}

HRESULT CEnumTemplate::Clone(IEnumIDList **ppenum)
{
    return E_NOTIMPL;
}


//==========================================================================
// CTemplateUIObj members (IUnknown override)
//==========================================================================

HRESULT CTemplateUIObj::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IExtractIcon) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IExtractIcon*)this;
        _cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IDataObject))
    {
        *ppvObj = (IDataObject*)this;
        _cRef++;
        return S_OK;
    }
    *ppvObj = NULL;

    return E_NOINTERFACE;
}

ULONG CTemplateUIObj::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CTemplateUIObj::Release()
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

//
// NOTES: This logic MUST be identical to the one in the shell.
//
inline int _ParseIconLocation(LPTSTR pszIconFile)
{
    int iIndex = 0;
    LPTSTR pszComma = StrChr(pszIconFile, TEXT(','));

    if (pszComma) {
        *pszComma++ = 0;            // terminate the icon file name.
        iIndex = StrToInt(pszComma);
    }
    PathRemoveBlanks(pszIconFile);
    return iIndex;
}


//==========================================================================
// CTemplateUIObj members (IExtractIcon override)
//==========================================================================

HRESULT CTemplateUIObj::GetIconLocation(
                         UINT   uFlags, LPTSTR  szIconFile,
                         UINT   cchMax, int   * piIndex,
                         UINT  * pwFlags)
{
    TCHAR szKey[128];
    HRESULT hres = _KeyNameFromCLSID(_clsid, szKey, ARRAYSIZE(szKey));
    if (SUCCEEDED(hres))
    {
        lstrcat(szKey, TEXT("\\DefaultIcon"));  // FEATURE: lstrcatn?
        TCHAR szValue[MAX_PATH+40];
        LONG dwSize = ARRAYSIZE(szValue);
        if (RegQueryValue(HKEY_CLASSES_ROOT, szKey, szValue, &dwSize) == ERROR_SUCCESS)
        {
            *pwFlags = GIL_PERCLASS;
            *piIndex = _ParseIconLocation(szValue);
            lstrcpyn(szIconFile, szValue, cchMax);
            hres = S_OK;
        }
    }
    return hres;
}

HRESULT CTemplateUIObj::Extract(
                           LPCTSTR pszFile, UINT          nIconIndex,
                           HICON   *phiconLarge, HICON   *phiconSmall,
                           UINT    nIconSize)
{
    return S_FALSE;
}

HRESULT CTemplateUIObj::Create(REFCLSID rclsid, REFIID riid, LPVOID* ppvOut)
{
    CTemplateUIObj *pti = new CTemplateUIObj(rclsid);
    if (pti) {
        pti->QueryInterface(riid, ppvOut);
        pti->Release();
        return S_OK;
    }

    *ppvOut=NULL;
    return E_OUTOFMEMORY;
}

//==========================================================================
// CTemplateUIObj members (IDataObject override)
//==========================================================================

HRESULT CTemplateUIObj::_CreateInstance(IStorage* pstg)
{
    HRESULT hres;
    IPersistStorage* pps = NULL;
    hres = OleCreate(_clsid, IID_IPersistStorage, OLERENDER_DRAW,
                     NULL, NULL, pstg, (LPVOID*)&pps);
    DebugMsg(DM_TRACE, TEXT("so TR - TUO:CI OleCreate returned (%x)"), hres);

    if (SUCCEEDED(hres))
    {
        hres = OleSave(pps, pstg, TRUE);
        DebugMsg(DM_TRACE, TEXT("so TR - TUO:CI OleSave returned (%x)"), hres);
        pps->HandsOffStorage();
        pps->Release();

        if (SUCCEEDED(hres))
        {
            hres = pstg->Commit(STGC_OVERWRITE);
            DebugMsg(DM_TRACE, TEXT("so TR - TUO:CI pstg->Commit returned (%x)"), hres);
        }
    }

    return hres;
}

HRESULT CTemplateUIObj::GetData(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
    HRESULT hres = DATA_E_FORMATETC;

    pmedium->pUnkForRelease = NULL;
    pmedium->pstg = NULL;

    //
    // NOTES: We should avoid calling _OpenStorage if we don't support
    //  the format.
    //

    if (pformatetcIn->cfFormat == CF_EMBEDDEDOBJECT
        && pformatetcIn->tymed == TYMED_ISTORAGE)
    {
        IStorage* pstg = NULL;
        hres = StgCreateDocfile(NULL, STGM_DIRECT | STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, &pstg);
        DebugMsg(DM_TRACE, TEXT("so TR - TUO:GD StgCreateDocfile returned (%x)"), hres);
        if (SUCCEEDED(hres))
        {
            hres = _CreateInstance(pstg);
            if (SUCCEEDED(hres)) {
                pmedium->tymed = TYMED_ISTORAGE;
                pmedium->pstg = pstg;
            } else {
                pstg->Release();
            }
        }
    }
    return hres;
}

HRESULT CTemplateUIObj::GetDataHere(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
    HRESULT hres = DATA_E_FORMATETC;

    if (pformatetcIn->cfFormat == CF_EMBEDDEDOBJECT
        && pformatetcIn->tymed == TYMED_ISTORAGE && pmedium->tymed == TYMED_ISTORAGE)
    {
        hres = _CreateInstance(pmedium->pstg);
    }

    return hres;
}

HRESULT CTemplateUIObj::QueryGetData(LPFORMATETC pformatetcIn)
{
    if (pformatetcIn->cfFormat == CF_EMBEDDEDOBJECT
        && pformatetcIn->tymed == TYMED_ISTORAGE)
    {
        return S_OK;
    }
    return DATA_E_FORMATETC;
}

HRESULT CTemplateUIObj::GetCanonicalFormatEtc(LPFORMATETC pformatetc, LPFORMATETC pformatetcOut)
{
    //
    //  This is the simplest implemtation. It means we always return
    // the data in the format requested.
    //
    return ResultFromScode(DATA_S_SAMEFORMATETC);
}

HRESULT CTemplateUIObj::SetData(LPFORMATETC pformatetc, STGMEDIUM  * pmedium, BOOL fRelease)
{
    return E_FAIL;
}

HRESULT CTemplateUIObj::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC * ppenumFormatEtc)
{
    static FORMATETC s_afmt[] = { CF_EMBEDDEDOBJECT };
    return SHCreateStdEnumFmtEtc(ARRAYSIZE(s_afmt), s_afmt, ppenumFormatEtc);
}

HRESULT CTemplateUIObj::DAdvise(FORMATETC * pFormatetc, DWORD advf, LPADVISESINK pAdvSink, DWORD * pdwConnection)
{
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

HRESULT CTemplateUIObj::DUnadvise(DWORD dwConnection)
{
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

HRESULT CTemplateUIObj::EnumDAdvise(LPENUMSTATDATA * ppenumAdvise)
{
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\shole\scdata.c ===
#include "shole.h"
#include "ids.h"

#define INITGUID
#ifndef WINNT
#pragma data_seg(".text", "CODE")
#endif
#include <initguid.h>
#include "scguid.h"
#ifndef WINNT
#pragma data_seg()
#endif

// #define SAVE_OBJECTDESCRIPTOR
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

extern "C" const WCHAR c_wszDescriptor[];

UINT _GetClipboardFormat(UINT id)
{
    static UINT s_acf[CFID_MAX] = { 0, 0, 0, 0, 0 };
    static const TCHAR * const c_aszFormat[CFID_MAX] = {
            TEXT("Embedded Object"),
            TEXT("Object Descriptor"),
            TEXT("Link Source Descriptor"),
            TEXT("Rich Text Format"),
            TEXT("Shell Scrap Object")
            };
    if (!s_acf[id])
    {
        s_acf[id] = RegisterClipboardFormat(c_aszFormat[id]);
    }
    return s_acf[id];
}

//===========================================================================
// CScrapData : Class definition
//===========================================================================

class CScrapData : public IDataObject, public IPersistFile
{
public:
    CScrapData();
    ~CScrapData();

    // IUnKnown
    virtual HRESULT __stdcall QueryInterface(REFIID,void **);
    virtual ULONG   __stdcall AddRef(void);
    virtual ULONG   __stdcall Release(void);

    // IDataObject
    virtual HRESULT __stdcall GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);
    virtual HRESULT __stdcall GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium);
    virtual HRESULT __stdcall QueryGetData(FORMATETC *pformatetc);
    virtual HRESULT __stdcall GetCanonicalFormatEtc(FORMATETC *pformatectIn, FORMATETC *pformatetcOut);
    virtual HRESULT __stdcall SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease);
    virtual HRESULT __stdcall EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc);
    virtual HRESULT __stdcall DAdvise(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, DWORD *pdwConnection);
    virtual HRESULT __stdcall DUnadvise(DWORD dwConnection);
    virtual HRESULT __stdcall EnumDAdvise(IEnumSTATDATA **ppenumAdvise);
    virtual HRESULT __stdcall IsDirty(void);

    // IPersistFile
    virtual HRESULT __stdcall GetClassID(CLSID *pClassID);
    virtual HRESULT __stdcall Load(LPCOLESTR pszFileName, DWORD dwMode);
    virtual HRESULT __stdcall Save(LPCOLESTR pszFileName, BOOL fRemember);
    virtual HRESULT __stdcall SaveCompleted(LPCOLESTR pszFileName);
    virtual HRESULT __stdcall GetCurFile(LPOLESTR *ppszFileName);

protected:
    HRESULT _OpenStorage(void);
    void    _CloseStorage(BOOL fResetFlags);
    INT     _GetFormatIndex(UINT cf);
    void    _FillCFArray(void);
#ifdef FIX_ROUNDTRIP
    HRESULT _RunObject(void);
#endif // FIX_ROUNDTRIP

#ifdef SAVE_OBJECTDESCRIPTOR
    HRESULT _GetObjectDescriptor(LPSTGMEDIUM pmedium, BOOL fGetHere);
#endif // SAVE_OBJECTDESCRIPTOR

    UINT         _cRef;
    BOOL         _fDoc:1;
    BOOL         _fItem:1;
    BOOL         _fObjDesc:1;
#ifdef FIX_ROUNDTRIP
    BOOL         _fRunObjectAlreadyCalled:1;
    LPDATAOBJECT _pdtobjItem;
#endif // FIX_ROUNDTRIP
    LPSTORAGE    _pstgDoc;
    LPSTORAGE    _pstgItem;
    LPSTREAM     _pstmObjDesc;
    TCHAR        _szPath[MAX_PATH];
    INT          _ccf;          // number of clipboard format.
    INT          _icfCacheMax;  // Max cache format index
    DWORD        _acf[64];      // 64 must be enough!
};

//===========================================================================
// CScrapData : Constructor
//===========================================================================
CScrapData::CScrapData(void) : _cRef(1), _pstgDoc(NULL), _pstgItem(NULL),
                               _fDoc(FALSE), _fItem(FALSE), _fObjDesc(FALSE),
                               _ccf(0),
#ifdef FIX_ROUNDTRIP
                               _pdtobjItem(NULL), _fRunObjectAlreadyCalled(FALSE),
#endif // FIX_ROUNDTRIP
                               _pstmObjDesc(NULL)
{
    _szPath[0] = TEXT('\0');
    g_cRefThisDll++;
}

CScrapData::~CScrapData()
{
#ifdef FIX_ROUNDTRIP
    if (_pdtobjItem) {
        _pdtobjItem->Release();
    }
#endif // FIX_ROUNDTRIP
    _CloseStorage(FALSE);
    g_cRefThisDll--;
}
//===========================================================================
// CScrapData : Member functions (private)
//===========================================================================
//
// private member CScrapData::_OpenStorage
//
HRESULT CScrapData::_OpenStorage(void)
{
    if (_pstgItem) {
        return S_OK;
    }

    HRESULT hres;
    WCHAR wszFile[MAX_PATH];

#ifdef UNICODE
    lstrcpyn(wszFile, _szPath, ARRAYSIZE(wszFile));
#ifdef DEBUG
    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetStorage is called (%s)"), wszFile);
#endif
#else
    MultiByteToWideChar(CP_ACP, 0, _szPath, -1, wszFile, ARRAYSIZE(wszFile));

#ifdef DEBUG
    TCHAR szFile[MAX_PATH];
    WideCharToMultiByte(CP_ACP, 0, wszFile, -1, szFile, ARRAYSIZE(szFile), NULL, NULL);
    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetStorage is called (%s)"), szFile);
#endif
#endif

    hres = StgOpenStorage(wszFile, NULL,
                          STGM_READ | STGM_SHARE_DENY_WRITE,
                          NULL, 0, &_pstgDoc);
    if (SUCCEEDED(hres))
    {
        _fDoc = TRUE;
        hres = _pstgDoc->OpenStorage(c_wszContents, NULL,
                            STGM_READ | STGM_SHARE_EXCLUSIVE,
                            NULL, 0, &_pstgItem);
        if (SUCCEEDED(hres))
        {
            HRESULT hresT;
            _fItem = TRUE;
#ifdef SAVE_OBJECTDESCRIPTOR
            hresT = _pstgDoc->OpenStream(c_wszDescriptor, 0,
                                STGM_READ | STGM_SHARE_EXCLUSIVE,
                                0, &_pstmObjDesc);
            _fObjDesc = SUCCEEDED(hresT);
#endif // SAVE_OBJECTDESCRIPTOR
        }
        else
        {
            DebugMsg(DM_TRACE, TEXT("sc TR - CSD::_OpenStorage _pstgDoc->OpenStorage failed (%x)"), hres);
            _pstgDoc->Release();
            _pstgDoc = NULL;
        }
    }
    else
    {
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::_OpenStorage StgOpenStorage failed (%x)"), hres);
    }

    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::_OpenStorage _pstgDoc->OpenStorage returning (%x) %x"),
                hres, _pstmObjDesc);
    return hres;
}

void CScrapData::_CloseStorage(BOOL fResetFlags)
{
    if (_pstgItem) {
        _pstgItem->Release();
        _pstgItem = NULL;
    }
    if (_pstmObjDesc) {
        _pstmObjDesc->Release();
        _pstmObjDesc = NULL;
    }
    if (_pstgDoc) {
        _pstgDoc->Release();
        _pstgDoc = NULL;
    }

    if (fResetFlags) {
        _fItem = FALSE;
        _fObjDesc = FALSE;
        _fDoc = FALSE;
    }
}

INT CScrapData::_GetFormatIndex(UINT cf)
{
    for (INT i=0; i<_ccf; i++)
    {
        if (_acf[i] == cf)
        {
            return i;
        }
    }
    return -1;
}

#ifdef FIX_ROUNDTRIP
extern "C" const TCHAR c_szRenderFMT[] = TEXT("DataFormats\\DelayRenderFormats");
#endif // FIX_ROUNDTRIP

extern "C" const WCHAR c_wszFormatNames[];

//
//  This function filles the clipboard format array (_acf). Following
// clipboard format may be added.
//
// Step 1. CF_EMBEEDEDOBJECT
// Step 2. CF_OBJECTDESCRIPTOR
// Step 3. CF_SCRAPOBJECT
// Step 4. Cached clipboard formats (from a stream).
// Step 5. Delay Rendered clipbaord formats (from registry).
//
void CScrapData::_FillCFArray(void)
{
    _ccf=0;
    //
    // Step 1.
    //
    if (_fItem) {
        _acf[_ccf++] = CF_EMBEDDEDOBJECT;
    }

    //
    // Step 2.
    //
    if (_fObjDesc) {
        _acf[_ccf++] = CF_OBJECTDESCRIPTOR;
    }

    //
    // Step 3.
    //
    if (_fDoc)
    {
        _acf[_ccf++] = CF_SCRAPOBJECT;
    }

#ifdef FIX_ROUNDTRIP
    if (_pstgItem)
    {
        //
        // Step 3. Cached clipboard formats
        //
        //
        // Open the stream which contains the names of cached formats.
        //
        LPSTREAM pstm;
        HRESULT hres = _pstgDoc->OpenStream(c_wszFormatNames, NULL,
                                STGM_READ | STGM_SHARE_EXCLUSIVE,
                                NULL, &pstm);

        if (SUCCEEDED(hres))
        {
            //
            // For each cached format...
            //
            USHORT cb;
            DWORD cbRead;
            while(SUCCEEDED(pstm->Read(&cb, sizeof(cb), &cbRead)) && cbRead==sizeof(cb)
                  && cb && cb<128)
            {
                UINT cf = 0;

                //
                // Get the cached clipboard format name
                //
                CHAR szFormat[128];
                szFormat[cb] = '\0';
                hres = pstm->Read(szFormat, cb, &cbRead);
                if (SUCCEEDED(hres) && cbRead==cb && lstrlenA(szFormat)==cb)
                {
                    //
                    // Append it to the array.
                    //
#ifdef UNICODE
                    TCHAR wszFormat[128];
                    MultiByteToWideChar(CP_ACP, 0,
                                        szFormat, -1,
                                        wszFormat, ARRAYSIZE(wszFormat));
                    DebugMsg(DM_TRACE, TEXT("sc TR _FillCFA Found Cached Format %s"), wszFormat);
#else
                    DebugMsg(DM_TRACE, TEXT("sc TR _FillCFA Found Cached Format %s"), szFormat);
#endif
                    cf = RegisterClipboardFormatA(szFormat);

                    if (cf)
                    {
                        _acf[_ccf++] = cf;
                    }
                }
                else
                {
                    break;
                }
            }
            pstm->Release();
        }

        _icfCacheMax = _ccf;

        //
        // Step 4. Get the list of delay-rendered clipboard formats
        //
        LPPERSISTSTORAGE pps;
        hres = OleLoad(_pstgItem, IID_IPersistStorage, NULL, (LPVOID *)&pps);
        if (SUCCEEDED(hres))
        {
            //
            // Get the CLSID of embedding.
            //
            CLSID clsid;
            hres = pps->GetClassID(&clsid);
            if (SUCCEEDED(hres))
            {
                //
                // Open the key for delay-rendered format names.
                //
                extern HKEY _OpenCLSIDKey(REFCLSID rclsid, LPCTSTR pszSubKey);
                HKEY hkey = _OpenCLSIDKey(clsid, c_szRenderFMT);
                if (hkey)
                {
                    TCHAR szValueName[128];
                    //
                    // For each delay-rendered clipboard format...
                    //
                    for(int iValue=0; ;iValue++)
                    {
                        //
                        // Get the value name, which is the format name.
                        //
                        DWORD cchValueName = ARRAYSIZE(szValueName);
                        DWORD dwType;
                        if (RegEnumValue(hkey, iValue, szValueName, &cchValueName, NULL,
                                         &dwType, NULL, NULL)==ERROR_SUCCESS)
                        {
                            DebugMsg(DM_TRACE, TEXT("sc TR - CSD::_FillCFA RegEnumValue found %s, %x"), szValueName, dwType);
                            UINT cf = RegisterClipboardFormat(szValueName);

                            if (cf)
                            {
                                _acf[_ccf++] = cf;
                            }
                        }
                        else
                        {
                            break;
                        }
                    }

                    //
                    // HACK: NT 3.5's regedit does not support named value...
                    //
                    for(iValue=0; ;iValue++)
                    {
                        TCHAR szKeyName[128];
                        //
                        // Get the value name, which is the format name.
                        //
                        if (RegEnumKey(hkey, iValue, szKeyName, ARRAYSIZE(szKeyName))==ERROR_SUCCESS)
                        {
                            DebugMsg(DM_TRACE, TEXT("sc TR - CSD::_FillCFA RegEnumValue found %s"), szValueName);
                            LONG cbValue = ARRAYSIZE(szValueName);
                            if ((RegQueryValue(hkey, szKeyName, szValueName, &cbValue)==ERROR_SUCCESS) && cbValue)
                            {
                                UINT cf = RegisterClipboardFormat(szValueName);

                                if (cf)
                                {
                                    _acf[_ccf++] = cf;
                                }
                            }
                        }
                        else
                        {
                            break;
                        }
                    }
                    RegCloseKey(hkey);
                }
            }
            pps->Release();
        }
    }
#endif // FIX_ROUNDTRIP
}

#ifdef FIX_ROUNDTRIP
//
// private member CScrapData::_RunObject
//
HRESULT CScrapData::_RunObject(void)
{
    if (_pdtobjItem) {
        return S_OK;
    }

    if (_fRunObjectAlreadyCalled) {
        DebugMsg(DM_TRACE, TEXT("sc TR CSD::_RunObject returning E_FAIL"));
        return E_FAIL;
    }
    _fRunObjectAlreadyCalled = TRUE;

    HRESULT hres = _OpenStorage();

    DebugMsg(DM_TRACE, TEXT("sc TR CSD::_RunObject _OpenStorage returned %x"), hres);

    if (SUCCEEDED(hres) && _pstgItem)
    {
        LPOLEOBJECT pole;
        hres = OleLoad(_pstgItem, IID_IOleObject, NULL, (LPVOID *)&pole);
        DebugMsg(DM_TRACE, TEXT("sc TR CSD::_RunObject OleLoad returned %x"), hres);
        if (SUCCEEDED(hres))
        {
            DWORD dw=GetCurrentTime();
            hres = OleRun(pole);
            dw = GetCurrentTime()-dw;
            DebugMsg(DM_TRACE, TEXT("sc TR CSD::_RunObject OleRun returned %x (%d msec)"), hres, dw);
            if (SUCCEEDED(hres))
            {
                hres = pole->GetClipboardData(0, &_pdtobjItem);
                DebugMsg(DM_TRACE, TEXT("sc TR CSD::_RunObject GetClipboardData returned %x"), hres);
                if (FAILED(hres))
                {
                    hres = pole->QueryInterface(IID_IDataObject, (LPVOID*)&_pdtobjItem);
                    DebugMsg(DM_TRACE, TEXT("sc TR CSD::_RunObject QI(IID_IDataIbject) returned %x"), hres);
                }
            }
            pole->Release();
        }
    }

    return hres;
}
#endif // FIX_ROUNDTRIP

//===========================================================================
// CScrapData : Member functions (virtual IDataObject)
//===========================================================================
HRESULT CScrapData::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IDataObject) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (LPDATAOBJECT)this;
        _cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IPersistFile))
    {
        *ppvObj = (LPPERSISTFILE)this;
        _cRef++;
        return S_OK;
    }
    *ppvObj = NULL;

    return E_NOINTERFACE;
}

ULONG CScrapData::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CScrapData::Release()
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::Release deleting this object"));
    delete this;
    return 0;
}


#ifdef SAVE_OBJECTDESCRIPTOR
HRESULT CScrapData::_GetObjectDescriptor(LPSTGMEDIUM pmedium, BOOL fGetHere)
{
    if (!_pstmObjDesc)
        return DATA_E_FORMATETC;

    LARGE_INTEGER dlib = { 0, 0 };
    HRESULT hres = _pstmObjDesc->Seek(dlib, STREAM_SEEK_SET, NULL);
    if (FAILED(hres))
        return hres;

    OBJECTDESCRIPTOR ods;
    ULONG cbRead;
    hres = _pstmObjDesc->Read(&ods.cbSize, sizeof(ods.cbSize), &cbRead);
    if (SUCCEEDED(hres) && cbRead == sizeof(ods.cbSize))
    {
        if (fGetHere)
        {
            if (GlobalSize(pmedium->hGlobal)<ods.cbSize) {
                hres = STG_E_MEDIUMFULL;
            }
        }
        else
        {
            pmedium->tymed = TYMED_HGLOBAL;
            pmedium->hGlobal = GlobalAlloc(GMEM_MOVEABLE, ods.cbSize);
            hres = pmedium->hGlobal ? S_OK : E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hres))
        {
            LPOBJECTDESCRIPTOR pods = (LPOBJECTDESCRIPTOR)GlobalLock(pmedium->hGlobal);
            if (pods)
            {
                pods->cbSize = ods.cbSize;
                hres = _pstmObjDesc->Read(&pods->clsid, ods.cbSize-sizeof(ods.cbSize), NULL);
                GlobalUnlock(pmedium->hGlobal);
            }
            else
            {
                if (!fGetHere) {
                    GlobalFree(pmedium->hGlobal);
                    pmedium->hGlobal = NULL;
                }
                hres = E_OUTOFMEMORY;
            }
        }
    }

    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::_GetObjectDescriptor returning (%x)"), hres);
    return hres;
}
#endif // SAVE_OBJECTDESCRIPTOR


HRESULT CScrapData::GetData(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
#ifdef DEBUG
    if (pformatetcIn->cfFormat<CF_MAX) {
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetData called with %x,%x,%x"),
                             pformatetcIn->cfFormat, pformatetcIn->tymed, pmedium->tymed);
    } else {
        TCHAR szName[256];
        GetClipboardFormatName(pformatetcIn->cfFormat, szName, ARRAYSIZE(szName));
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetData called with %s,%x,%x"),
                             szName, pformatetcIn->tymed, pmedium->tymed);
    }
#endif

    HRESULT hres;

    pmedium->pUnkForRelease = NULL;
    pmedium->pstg = NULL;

    //
    // NOTES: We should avoid calling _OpenStorage if we don't support
    //  the format.
    //

    if (pformatetcIn->cfFormat == CF_EMBEDDEDOBJECT
        && pformatetcIn->tymed == TYMED_ISTORAGE && _fItem)
    {
        hres = _OpenStorage();
        if (SUCCEEDED(hres))
        {
            pmedium->tymed = TYMED_ISTORAGE;
            _pstgItem->AddRef();
            pmedium->pstg = _pstgItem;
        }
    }
    else if (pformatetcIn->cfFormat == CF_SCRAPOBJECT
        && pformatetcIn->tymed == TYMED_ISTORAGE && _fItem)
    {
        hres = _OpenStorage();
        if (SUCCEEDED(hres))
        {
            pmedium->tymed = TYMED_ISTORAGE;
            _pstgDoc->AddRef();
            pmedium->pstg = _pstgDoc;
        }
    }
#ifdef SAVE_OBJECTDESCRIPTOR
    else if (pformatetcIn->cfFormat == CF_OBJECTDESCRIPTOR
        && pformatetcIn->tymed == TYMED_HGLOBAL && _fObjDesc)
    {
        hres = _OpenStorage();
        if (SUCCEEDED(hres))
        {
            hres = _GetObjectDescriptor(pmedium, FALSE);
        }
    }
#endif // SAVE_OBJECTDESCRIPTOR
    else
    {
#ifdef FIX_ROUNDTRIP
        INT iFmt = _GetFormatIndex(pformatetcIn->cfFormat);

        if (iFmt != -1)
        {
            hres = _OpenStorage();
            if (FAILED(hres))
            {
                goto exit;
            }
        }

        if (iFmt>=_icfCacheMax)
        {
            //
            // Delayed Rendered format
            //
            if (SUCCEEDED(_RunObject()))
            {
                hres = _pdtobjItem->GetData(pformatetcIn, pmedium);
                DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetData called _pdtobjItem->GetData %x"), hres);
                return hres;
            }
        }
        else if (iFmt >= 0)
        {
            //
            // Cached Format
            //
            extern void _GetCacheStreamName(LPCTSTR pszFormat, LPWSTR wszStreamName, UINT cchMax);
            TCHAR szFormat[128];
            if (pformatetcIn->cfFormat<CF_MAX) {
                wsprintf(szFormat, TEXT("#%d"), pformatetcIn->cfFormat);
            } else {
                GetClipboardFormatName(pformatetcIn->cfFormat, szFormat, ARRAYSIZE(szFormat));
            }

            WCHAR wszStreamName[256];
            _GetCacheStreamName(szFormat, wszStreamName, ARRAYSIZE(wszStreamName));

            if (pformatetcIn->cfFormat==CF_METAFILEPICT
                || pformatetcIn->cfFormat==CF_ENHMETAFILE
                || pformatetcIn->cfFormat==CF_BITMAP
                || pformatetcIn->cfFormat==CF_PALETTE
                )
            {
                LPSTORAGE pstg;
                hres = _pstgDoc->OpenStorage(wszStreamName, NULL,
                                    STGM_READ | STGM_SHARE_EXCLUSIVE,
                                    NULL, 0, &pstg);
                DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetData OpenStorage returned (%x)"), hres);
                if (SUCCEEDED(hres))
                {
                    LPDATAOBJECT pdtobj;
#if 0
                    hres = OleLoad(pstg, IID_IDataObject, NULL, (LPVOID*)&pdtobj);
                    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetData OleLoad returned (%x)"), hres);
#else
                    const CLSID* pclsid = NULL;
                    switch(pformatetcIn->cfFormat)
                    {
                    case CF_METAFILEPICT:
                        pclsid = &CLSID_Picture_Metafile;
                        break;
                
                    case CF_ENHMETAFILE:
                        pclsid = &CLSID_Picture_EnhMetafile;
                        break;
                
                    case CF_PALETTE:
                    case CF_BITMAP:
                        pclsid = &CLSID_Picture_Dib;
                        break;
                    }

                    LPPERSISTSTORAGE ppstg;
                    hres = OleCreateDefaultHandler(*pclsid, NULL, IID_IPersistStorage, (LPVOID *)&ppstg);
                    DebugMsg(DM_TRACE, TEXT("sc TR Scrap_CacheOPF OleCreteDefHandler returned %x"), hres);
                    if (SUCCEEDED(hres))
                    {
                        hres = ppstg->Load(pstg);
                        DebugMsg(DM_TRACE, TEXT("sc TR Scrap_CacheOPF ppstg->Load returned %x"), hres);
                        if (SUCCEEDED(hres))
                        {
                            hres = ppstg->QueryInterface(IID_IDataObject, (LPVOID*)&pdtobj);
                        }
                        ppstg->HandsOffStorage();
                        ppstg->Release();
                    }
#endif
                    if (SUCCEEDED(hres))
                    {
                        hres = pdtobj->GetData(pformatetcIn, pmedium);
                        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetData pobj->GetData returned (%x)"), hres);
                        pdtobj->Release();
                    }
                    pstg->Release();
                    return hres;
                }
                // fall through
            }
            else // if (pformatetcIn->cfFormat==CF_...)
            {
                LPSTREAM pstm;
                hres = _pstgDoc->OpenStream(wszStreamName, NULL,
                                        STGM_READ | STGM_SHARE_EXCLUSIVE,
                                        0, &pstm);
                if (SUCCEEDED(hres))
                {
                    UINT cbData;
                    DWORD cbRead;
                    hres = pstm->Read(&cbData, sizeof(cbData), &cbRead);
                    if (SUCCEEDED(hres) && cbRead==sizeof(cbData))
                    {
                        LPBYTE pData = (LPBYTE)GlobalAlloc(GPTR, cbData);
                        if (pData)
                        {
                            hres = pstm->Read(pData, cbData, &cbRead);
                            if (SUCCEEDED(hres) && cbData==cbRead)
                            {
                                pmedium->tymed = TYMED_HGLOBAL;
                                pmedium->hGlobal = (HGLOBAL)pData;
                            }
                            else
                            {
                                hres = E_UNEXPECTED;
                                GlobalFree((HGLOBAL)pData);
                            }
                        }
                        else
                        {
                            hres = E_OUTOFMEMORY;
                        }
                    }
                    pstm->Release();

                    DebugMsg(DM_TRACE, TEXT("CSD::GetData(%s) returning %x"), szFormat, hres);
                    return hres;
                }
            }
        } // if (iFmt >= 0)
#endif // FIX_ROUNDTRIP
        hres = DATA_E_FORMATETC;
    }

exit:

#ifdef DEBUG
    TCHAR szFormat[256];
    GetClipboardFormatName(pformatetcIn->cfFormat,
                           szFormat, ARRAYSIZE(szFormat));

    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetData called with %x,%x,%s and returning %x"),
                             pformatetcIn->cfFormat,
                             pformatetcIn->tymed,
                             szFormat, hres);
#endif

    return hres;
}

HRESULT CScrapData::GetDataHere(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium )
{
    HRESULT hres;

#ifdef DEBUG
    if (pformatetcIn->cfFormat<CF_MAX) {
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetDataHere called with %x,%x,%x"),
                             pformatetcIn->cfFormat, pformatetcIn->tymed, pmedium->tymed);
    } else {
        TCHAR szName[256];
        GetClipboardFormatName(pformatetcIn->cfFormat, szName, ARRAYSIZE(szName));
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetDataHere called with %s,%x,%x"),
                             szName, pformatetcIn->tymed, pmedium->tymed);
    }
#endif

    hres = _OpenStorage();
    if (FAILED(hres)) {
        return hres;
    }

    if (pformatetcIn->cfFormat == CF_EMBEDDEDOBJECT
        && pformatetcIn->tymed == TYMED_ISTORAGE && pmedium->tymed == TYMED_ISTORAGE)
    {
        hres = _pstgItem->CopyTo(0, NULL, NULL, pmedium->pstg);
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetDataHere _pstgItem->CopyTo returned %x"), hres);
    }
    else if (pformatetcIn->cfFormat == CF_SCRAPOBJECT
        && pformatetcIn->tymed == TYMED_ISTORAGE && pmedium->tymed == TYMED_ISTORAGE)
    {
        hres = _pstgDoc->CopyTo(0, NULL, NULL, pmedium->pstg);
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetDataHere _pstgItem->CopyTo returned %x"), hres);
    }
#ifdef SAVE_OBJECTDESCRIPTOR
    else if ((pformatetcIn->cfFormat == CF_OBJECTDESCRIPTOR)
        && (pformatetcIn->tymed == TYMED_HGLOBAL) && _pstmObjDesc)
    {
        hres = _GetObjectDescriptor(pmedium, TRUE);
    }
#endif // SAVE_OBJECTDESCRIPTOR
    else
    {
#ifdef FIX_ROUNDTRIP
        if (_GetFormatIndex(pformatetcIn->cfFormat) >= 0 && SUCCEEDED(_RunObject()))
        {
            DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetDataHere calling _pdtobjItem->GetDataHere"));
            return _pdtobjItem->GetDataHere(pformatetcIn, pmedium);
        }
#endif // FIX_ROUNDTRIP
        hres = DATA_E_FORMATETC;
    }

    return hres;
}

HRESULT CScrapData::QueryGetData(LPFORMATETC pformatetcIn)
{
    HRESULT hres;
    if (_GetFormatIndex(pformatetcIn->cfFormat) >= 0) {
        hres = S_OK;
    } else {
        hres = DATA_E_FORMATETC;
    }

#ifdef DEBUG
    TCHAR szFormat[256] = TEXT("");
    GetClipboardFormatName(pformatetcIn->cfFormat, szFormat, ARRAYSIZE(szFormat));
    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::QueryGetData(%x,%s,%x) returning %x"),
                    pformatetcIn->cfFormat, szFormat, pformatetcIn->tymed, hres);
#endif

    return hres;
}

HRESULT CScrapData::GetCanonicalFormatEtc(LPFORMATETC pformatetc, LPFORMATETC pformatetcOut)
{
    //
    //  This is the simplest implemtation. It means we always return
    // the data in the format requested.
    //
    return ResultFromScode(DATA_S_SAMEFORMATETC);
}

HRESULT CScrapData::SetData(LPFORMATETC pformatetc, STGMEDIUM  * pmedium, BOOL fRelease)
{
    return E_FAIL;
}

HRESULT CScrapData::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC * ppenumFormatEtc)
{
    if (dwDirection!=DATADIR_GET) {
        return E_NOTIMPL; // Not supported (as documented)
    }

    if (_ccf==0) {
        return E_UNEXPECTED;
    }

    FORMATETC * pfmt = (FORMATETC*)LocalAlloc(LPTR, sizeof(FORMATETC)*_ccf);
    if (!pfmt) {
        return E_OUTOFMEMORY;
    }

    static const FORMATETC s_fmteInit =
    {
          0,
          (DVTARGETDEVICE __RPC_FAR *)NULL,
          DVASPECT_CONTENT,
          -1,
          TYMED_HGLOBAL         // HGLOBAL except CF_EMBEDDEDOBJECT/SCRAPOBJECT
     };

    //
    // Fills FORMATETC for each clipboard format.
    //
    for (INT i=0; i<_ccf; i++)
    {
        pfmt[i] = s_fmteInit;
        pfmt[i].cfFormat = (CLIPFORMAT)_acf[i];

        if (_acf[i]==CF_EMBEDDEDOBJECT || _acf[i]==CF_SCRAPOBJECT) {
            pfmt[i].tymed = TYMED_ISTORAGE;
        } else {
            switch(_acf[i])
            {
            case CF_METAFILEPICT:
                pfmt[i].tymed = TYMED_MFPICT;
                break;

            case CF_ENHMETAFILE:
                pfmt[i].tymed = TYMED_ENHMF;
                break;

            case CF_BITMAP:
            case CF_PALETTE:
                pfmt[i].tymed = TYMED_GDI;
                break;
            }
        }
    }

    HRESULT hres = SHCreateStdEnumFmtEtc(_ccf, pfmt, ppenumFormatEtc);
    LocalFree((HLOCAL)pfmt);

    return hres;
}

HRESULT CScrapData::DAdvise(FORMATETC * pFormatetc, DWORD advf, LPADVISESINK pAdvSink, DWORD * pdwConnection)
{
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

HRESULT CScrapData::DUnadvise(DWORD dwConnection)
{
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

HRESULT CScrapData::EnumDAdvise(LPENUMSTATDATA * ppenumAdvise)
{
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}


//===========================================================================
// CScrapData : Member functions (virtual IPersistFile)
//===========================================================================

HRESULT CScrapData::GetClassID(LPCLSID lpClassID)
{
    *lpClassID = CLSID_CScrapData;
    return S_OK;
}

HRESULT CScrapData::IsDirty(void)
{
    return S_FALSE;     // meaningless (read only)
}

HRESULT CScrapData::Load(LPCOLESTR pwszFile, DWORD grfMode)
{
    //
    // Close all the storage (if there is any) and reset flags.
    //
    _CloseStorage(TRUE);

    //
    // Copy the new file name and open storage to update the flags.
    //
#ifdef UNICODE
    lstrcpyn(_szPath, pwszFile, ARRAYSIZE(_szPath));
#else
    WideCharToMultiByte(CP_ACP, 0, pwszFile, -1, _szPath, ARRAYSIZE(_szPath), NULL, NULL);
#endif
    HRESULT hres = _OpenStorage();
    _FillCFArray();

    //
    // Close all the storage, so that we can move/delete.
    //
    _CloseStorage(FALSE);

    return hres;
}

HRESULT CScrapData::Save(LPCOLESTR pwszFile, BOOL fRemember)
{
    return E_FAIL;      // read only
}

HRESULT CScrapData::SaveCompleted(LPCOLESTR pwszFile)
{
    return S_OK;
}

HRESULT CScrapData::GetCurFile(LPOLESTR *lplpszFileName)
{
    return E_NOTIMPL;   // nobody needs it
}

HRESULT CScrapData_CreateInstance(LPUNKNOWN * ppunk)
{
//
//  This test code is unrelated to the scrap itself. It just verifies that
// CLSID_ShellLink is correctly registered.
//
#ifdef DEBUG
    LPUNKNOWN punk = NULL;
    HRESULT hres = CoCreateInstance(CLSID_ShellLink, NULL,
                    CLSCTX_INPROC, IID_IShellLink, (LPVOID*)&punk);
    DebugMsg(DM_TRACE, TEXT("###############################################"));
    DebugMsg(DM_TRACE, TEXT("CoCreateInstance returned %x"), hres);
    DebugMsg(DM_TRACE, TEXT("###############################################"));
    if (SUCCEEDED(hres)) {
        punk->Release();
    }
#endif

    CScrapData* pscd = new CScrapData();
    if (pscd) {
        *ppunk = (LPDATAOBJECT)pscd;
        return S_OK;
    }
    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\listdev\listdev.cpp ===
// ListDev.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "ListDev.h"
#include "devtree.h"
#include "ListDevDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CListDevApp

BEGIN_MESSAGE_MAP(CListDevApp, CWinApp)
	//{{AFX_MSG_MAP(CListDevApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CListDevApp construction

CListDevApp::CListDevApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CListDevApp object

CString     g_strStartupComputerName;
CListDevApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CListDevApp initialization

BOOL CListDevApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CMyCommandLineInfo  CmdLineInfo;
	ParseCommandLine(CmdLineInfo);
	if (CmdLineInfo.m_DisplayUsage)
	{
	    ::MessageBox(NULL, _T("Usage: ListDev [/computername <\\\\name>]"), _T("List Device"), MB_OK | MB_ICONINFORMATION);
	    return FALSE;
	}
	CListDevDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}


const TCHAR*	COMPUTERNAME = _T("ComputerName");

void
CMyCommandLineInfo::ParseParam(
    LPCTSTR lpszParam,
    BOOL bFlag,
    BOOL bLast
    )
{
    if (bFlag)
    {
	if (!lstrcmpi(lpszParam, COMPUTERNAME))
	    m_WaitForName = TRUE;
	else if (_T('?') == *lpszParam)
	{
	    m_DisplayUsage = TRUE;
	}
    }
    else if (m_WaitForName)
    {
	g_strStartupComputerName = lpszParam;
	TCHAR Dbg[MAX_PATH];
	wsprintf(Dbg, _T("ComputerName = %s\n"), lpszParam);
	OutputDebugString(Dbg);
	m_WaitForName = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\listdev\devtree.h ===
#ifndef _DEVTREE_H__
#define _DEVTREE_H__

extern "C" {
#include <cfgmgr32.h>
#include <setupapi.h>
#include <regstr.h>
}

#include <afxtempl.h>
#include "resource.h"

class CAttribute
{
public:
    CAttribute(LPCTSTR Type, LPCTSTR Value)
    {
	m_strType = Type;
	m_strValue = Value;
    }
    LPCTSTR GetType()
    {
	return m_strType.IsEmpty() ? NULL : (LPCTSTR)m_strType;
    }
    LPCTSTR GetValue()
    {
	return m_strValue.IsEmpty() ? NULL : (LPCTSTR)m_strValue;
    }
private:
    CString m_strType;
    CString m_strValue;
};

class CDevice
{
public:

    CDevice() : m_pParent(NULL), m_pSibling(NULL), m_pChild(NULL),
		m_ImageIndex(0)
    {
    }

    BOOL Create(HMACHINE hMachine, DEVNODE dn);

    ~CDevice();

    CDevice* GetSibling(void)
    {
	return m_pSibling;
    }
    CDevice* GetChild(void)
    {
	return m_pChild;
    }
    CDevice* GetParent(void)
    {
	return m_pParent;
    }
    void SetChild(CDevice* pChild)
    {
	m_pChild = pChild;
    }
    void SetSibling(CDevice* pSibling)
    {
	m_pSibling = pSibling;
    }
    void SetParent(CDevice* pParent)
    {
	m_pParent = pParent;
    }
    LPCTSTR GetDisplayName()
    {
	return (LPCTSTR)m_strDisplayName;
    }
    int NumberOfAttributes()
    {
	return m_listAttributes.GetCount();
    }
    void SetClassGuid(LPGUID pGuid)
    {
	m_ClassGuid = *pGuid;
    }
    void SetImageIndex(int Index)
    {
	m_ImageIndex = Index;
    }
    int GetImageIndex()
    {
	return m_ImageIndex;
    }
    BOOL EnumerateAttribute(int Index, CAttribute** ppAttribute);

protected:
    CString	m_strDisplayName;
private:
    CDevice*	m_pParent;
    CDevice*	m_pSibling;
    CDevice*	m_pChild;
    int 	m_ImageIndex;
    void GetProperty(HMACHINE hMachine, DEVNODE DevNode, ULONG Property, int IdType);
    GUID    m_ClassGuid;
    CList<CAttribute*, CAttribute*>	m_listAttributes;
};

class CComputer : public CDevice
{
public:
    CComputer() : m_hMachine(NULL)
    {}
    ~CComputer();
    BOOL Create(LPCTSTR ComputerName);

    operator HMACHINE()
    {
	return m_hMachine;
    }
private:
    BOOL	m_IsLocal;
    HMACHINE	m_hMachine;
};

class CDeviceTree
{
public:
    CDeviceTree() : m_pComputer(NULL)
    {
	m_ImageListData.cbSize = 0;
    }
    ~CDeviceTree()
    {
	if (m_pComputer)
	    delete m_pComputer;
	if (m_ImageListData.cbSize)
	    SetupDiDestroyClassImageList(&m_ImageListData);
    }
    BOOL Create(LPCTSTR MachineName);
    BOOL NewComputer(LPCTSTR MachineName);
    HIMAGELIST GetClassImageList()
    {
	if (m_ImageListData.cbSize)
	    return m_ImageListData.ImageList;
	else
	    return NULL;
    }
    CComputer* GetComputer()
    {
	return m_pComputer;
    }
private:
    BOOL    CreateSubtree(CDevice* pParent, CDevice* pSibling, DEVNODE dn);
    CComputer*	m_pComputer;
    SP_CLASSIMAGELIST_DATA m_ImageListData;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\listdev\computer.cpp ===
// computer.cpp : implementation file
//

#include "stdafx.h"
#include "ListDev.h"
#include "computer.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// computer dialog


computer::computer(CWnd* pParent /*=NULL*/)
	: CDialog(computer::IDD, pParent)
{
	//{{AFX_DATA_INIT(computer)
	m_strComputerName = _T("");
	//}}AFX_DATA_INIT
}


void computer::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(computer)
	DDX_Text(pDX, IDC_EDIT_COMPUTERNAME, m_strComputerName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(computer, CDialog)
	//{{AFX_MSG_MAP(computer)
	ON_BN_CLICKED(IDC_CANCEL, OnCancel)
	ON_BN_CLICKED(ID_OK, OnOk)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// computer message handlers

void computer::OnCancel() 
{
	// TODO: Add your control notification handler code here
	
}

void computer::OnOk() 
{
	// TODO: Add your control notification handler code here
	UpdateData(TRUE);
	EndDialog(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\listdev\listdev.h ===
// ListDev.h : main header file for the LISTDEV application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CListDevApp:
// See ListDev.cpp for the implementation of this class
//

extern CString g_strStartupComputerName;

class CListDevApp : public CWinApp
{
public:
	CListDevApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListDevApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CListDevApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};



class CMyCommandLineInfo : public CCommandLineInfo
{
public:
    CMyCommandLineInfo() : m_WaitForName(FALSE), m_DisplayUsage(FALSE)
	{}
    virtual void ParseParam(LPCTSTR lpszParam, BOOL bFlag, BOOL bLast);
    BOOL    m_DisplayUsage;
private:
    BOOL    m_WaitForName;
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\inc\tvintf.h ===
\

#ifndef __TVINTF_H_
#define __TVINTF_H_
/*++

Copyright (c) 1997-  Microsoft Corporation

Module Name:

    tvintf.h

Abstract:

    header file to define interfaces between Device Manager snapin
    and TreeView OCX.

Author:

    William Hsieh (williamh) created

Revision History:


--*/


// Interface designed for snapin to connect/disconnect, control, retreive
// information to/from the Tree view ocx.
class IDMTVOCX : public IUnknown
{
    public: virtual HTREEITEM InsertItem(LPTV_INSERTSTRUCT pis) = 0;
    public: virtual HRESULT DeleteItem(HTREEITEM hItem) = 0;
    public: virtual HRESULT DeleteAllItems() = 0;
    public: virtual HIMAGELIST SetImageList(INT iImage, HIMAGELIST himl) = 0;
    public: virtual HRESULT SetItem(TV_ITEM* pitem) = 0;
    public: virtual HRESULT Expand(UINT Flags, HTREEITEM htiem) = 0;
    public: virtual HRESULT SelectItem(UINT Flags, HTREEITEM hitem) = 0;
    public: virtual HRESULT SetStyle(DWORD dwStyle) = 0;
    public: virtual HWND    GetWindowHandle() = 0;
    public: virtual HRESULT GetItem(TV_ITEM* pti) = 0;
    public: virtual HTREEITEM GetNextItem(UINT Flags, HTREEITEM htiRef) = 0;
    public: virtual HRESULT SelectItem(HTREEITEM hti) = 0;
    public: virtual UINT    GetCount() = 0;
    public: virtual HTREEITEM GetSelectedItem() = 0;
    public: virtual HRESULT Connect(IComponent* pIComponent, MMC_COOKIE cookie) = 0;
    public: virtual HRESULT SetActiveConnection(MMC_COOKIE cookie) = 0;
    public: virtual MMC_COOKIE	  GetActiveConnection() = 0;
    public: virtual HRESULT SetRedraw(BOOL Redraw) = 0;
    public: virtual BOOL    EnsureVisible(HTREEITEM hitem) = 0;
};


typedef enum tagTvNotifyCode
{
    TV_NOTIFY_CODE_CLICK = 0,
    TV_NOTIFY_CODE_DBLCLK,
    TV_NOTIFY_CODE_RCLICK,
    TV_NOTIFY_CODE_RDBLCLK,
    TV_NOTIFY_CODE_KEYDOWN,
    TV_NOTIFY_CODE_CONTEXTMENU,
    TV_NOTIFY_CODE_EXPANDING,
    TV_NOTIFY_CODE_EXPANDED,
    TV_NOTIFY_CODE_SELCHANGING,
    TV_NOTIFY_CODE_SELCHANGED,
    TV_NOTIFY_CODE_GETDISPINFO,
    TV_NOTIFY_CODE_FOCUSCHANGED,
    TV_NOTIFY_CODE_UNKNOWN
} TV_NOTIFY_CODE, *PTV_NOTIFY_CODE;

// interface DECLSPEC_UUID("8e0ba98a-d161-11d0-8353-00a0c90640bf")
class ISnapinCallback : public IUnknown
{
public:
virtual HRESULT STDMETHODCALLTYPE tvNotify(HWND hwndTV, MMC_COOKIE cookie,
					   TV_NOTIFY_CODE Code,
					   LPARAM arg, LPARAM param) = 0;
};

extern const IID IID_ISnapinCallback;
extern const IID IID_IDMTVOCX;

template<class ISome>
class SafeInterfacePtr
{
public:
    SafeInterfacePtr(ISome* pInterface = NULL)
    {
	m_pISome = pInterface;
	if (m_pISome)
	    m_pISome->AddRef();
    }
    ~SafeInterfacePtr()
    {
	SafeRelease();
    }
    void SafeRelease()
    {
	if (m_pISome)
	{
	    m_pISome->Release();
	    m_pISome = NULL;
	}
    }
    void Attach(ISome* pInterface)
    {
	ASSERT(!m_pISome);
	ASSERT(pInterface);
	m_pISome = pInterface;
	m_pISome->AddRef();
    }
    void Detach()
    {
	ASSERT(m_pISome);
	m_pISome->Release();
	m_pISome = NULL;
    }
    ISome* operator->()
    {
	return m_pISome;
    }
    ISome& operator*()
    {
	return *m_pISome;
    }
    operator ISome*()
    {
	return m_pISome;
    }
    ISome ** operator&()
    {
	return &m_pISome;
    }

private:
    ISome*  m_pISome;
};

#endif	//__TVINTF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\listdev\devtree.cpp ===
#include "stdafx.h"
#include "devtree.h"
#include <objbase.h>
#include <initguid.h>
#include <devguid.h>
#include <rpc.h>
void
CDevice::GetProperty(
    HMACHINE hMachine,
    DEVNODE dn,
    ULONG Property,
    int IdType
    )
{
    CString strType;
    TCHAR Buffer[REGSTR_VAL_MAX_HCID_LEN];
    ULONG Type;
    ULONG Size = sizeof(Buffer);
    strType.LoadString(IdType);
    // preload default string
    strType.LoadString(IDS_UNKNOWN);
    lstrcpy(Buffer, (LPCTSTR)strType);
    strType.LoadString(IdType);
    if (CR_SUCCESS == CM_Get_DevNode_Registry_Property_Ex(dn, Property,
							  &Type,
							  Buffer,
							  &Size,
							  0, hMachine))
    {
	if (REG_DWORD == Type || REG_MULTI_SZ == Type || REG_SZ == Type)
	{
	    if (REG_DWORD == Type)
	    {
		DWORD Data = *((DWORD*)Buffer);
		wsprintf(Buffer, _T("%08x"), *((DWORD*)Buffer) );
	    }
	    else if (REG_MULTI_SZ == Type)
	    {
		LPTSTR p = Buffer;
		while (_T('\0') != *p)
		{
		    p += lstrlen(p);
		    if (_T('\0') != *p)
			*p++ = _T(',');
		}
	    }
	}
    }
    CAttribute* pAttr = new CAttribute(strType, Buffer);
    m_listAttributes.AddTail(pAttr);
}


// prepare device's attributes
BOOL
CDevice::Create(
    HMACHINE hMachine,
    DEVNODE  DevNode
    )
{
    CString	strType;
    CString	strValue;
    LPTSTR	Buffer;
    int  BufferSize = MAX_PATH + MAX_DEVICE_ID_LEN;
    ULONG  BufferLen = BufferSize * sizeof(TCHAR);
    m_pSibling = NULL;
    m_pParent = NULL;
    m_pChild = NULL;
    m_ImageIndex = 0;
    Buffer  = strValue.GetBuffer(BufferSize);
    if (CR_SUCCESS == CM_Get_DevNode_Registry_Property_Ex(DevNode,
					CM_DRP_FRIENDLYNAME, NULL,
					Buffer, &BufferLen, 0, hMachine))
    {
	m_strDisplayName = Buffer;
    }
    else
    {
	BufferLen = BufferSize * sizeof(TCHAR);
	if (CR_SUCCESS == CM_Get_DevNode_Registry_Property_Ex(DevNode,
					CM_DRP_DEVICEDESC, NULL,
					Buffer, &BufferLen, 0, hMachine))
	{
	    m_strDisplayName = Buffer;
	}
	else
	{
	    m_strDisplayName.LoadString(IDS_UNKNOWN);
	}
    }
    CAttribute* pAttr;
    // pepare device' attributes
    // do standard ones first;
    if (CR_SUCCESS == CM_Get_Device_ID_Ex(DevNode, Buffer, BufferSize, 0, hMachine))
    {
	strType.LoadString(IDS_DEVICEID);
	pAttr = new CAttribute(strType, Buffer);
	m_listAttributes.AddTail(pAttr);
    }
    ULONG Status, Problem;

    if (CR_SUCCESS == CM_Get_DevNode_Status_Ex(&Status, &Problem, DevNode, 0, hMachine))
    {
	strValue.Format(_T("%08x"), Status);
	strType.LoadString(IDS_STATUS);
	pAttr = new CAttribute(strType, strValue);
	m_listAttributes.AddTail(pAttr);
	strType.LoadString(IDS_PROBLEM);
	strValue.Format(_T("%08x"), Problem);
	pAttr = new CAttribute(strType, strValue);
	m_listAttributes.AddTail(pAttr);
    }
    GetProperty(hMachine, DevNode, CM_DRP_SERVICE, IDS_SERVICE);
    GetProperty(hMachine, DevNode, CM_DRP_CAPABILITIES, IDS_CAPABILITIES);
    GetProperty(hMachine, DevNode, CM_DRP_CONFIGFLAGS, IDS_CONFIGFLAGS);
    GetProperty(hMachine, DevNode, CM_DRP_MFG, IDS_MFG);
    GetProperty(hMachine, DevNode, CM_DRP_CLASS, IDS_CLASS);
    GetProperty(hMachine, DevNode, CM_DRP_HARDWAREID, IDS_HARDWAREID);
    GetProperty(hMachine, DevNode, CM_DRP_COMPATIBLEIDS, IDS_COMPATIBLEID);
    GetProperty(hMachine, DevNode, CM_DRP_CLASSGUID, IDS_CLASSGUID);
    GetProperty(hMachine, DevNode, CM_DRP_LOCATION_INFORMATION, IDS_LOCATION);
    GetProperty(hMachine, DevNode, CM_DRP_BUSNUMBER, IDS_BUSNUMBER);
    GetProperty(hMachine, DevNode, CM_DRP_ENUMERATOR_NAME, IDS_ENUMERATOR_NAME);
    GetProperty(hMachine, DevNode, CM_DRP_DEVICEDESC, IDS_DEVICEDESC);
    GetProperty(hMachine, DevNode, CM_DRP_FRIENDLYNAME, IDS_FRIENDLYNAME);
    GetProperty(hMachine, DevNode, CM_DRP_DRIVER, IDS_DRIVER);
    GetProperty(hMachine, DevNode, CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME, IDS_PHYSICAL_DEVPATH);
    GetProperty(hMachine, DevNode, CM_DRP_UI_NUMBER, IDS_UI_NUMBER);
    GetProperty(hMachine, DevNode, CM_DRP_UPPERFILTERS, IDS_UPPERFILTERS);
    GetProperty(hMachine, DevNode, CM_DRP_LOWERFILTERS, IDS_LOWERFILTERS);
    GetProperty(hMachine, DevNode, CM_DRP_BUSTYPEGUID, IDS_BUSTYPEGUID);
    GetProperty(hMachine, DevNode, CM_DRP_LEGACYBUSTYPE, IDS_LEGACYBUSTYPE);

    return TRUE;
}

BOOL
CDevice::EnumerateAttribute(
    int Index,
    CAttribute** ppAttr
    )
{
    if (m_listAttributes.IsEmpty() || Index >= m_listAttributes.GetCount())
	return FALSE;
    POSITION pos = m_listAttributes.FindIndex(Index);
    *ppAttr = m_listAttributes.GetAt(pos);
    return TRUE;
}

CDevice::~CDevice()
{
    if (!m_listAttributes.IsEmpty())
    {
	POSITION pos = m_listAttributes.GetHeadPosition();
	while (NULL != pos)
	{
	    delete (CAttribute*)m_listAttributes.GetNext(pos);
	}
	m_listAttributes.RemoveAll();
    }
    if (m_pChild)
	delete m_pChild;
    if (m_pSibling)
	delete m_pSibling;
}

BOOL
CComputer::Create(
    LPCTSTR ComputerName
    )
{
    TCHAR LocalComputer[MAX_PATH];
    DWORD Size = MAX_PATH - 2;
    GetComputerName(LocalComputer + 2, &Size);
    LocalComputer[0] = _T('\\');
    LocalComputer[1] = _T('\\');
    if (ComputerName && _T('\0') != *ComputerName &&
	_T('\\') == ComputerName[0] && _T('\\') == ComputerName[1])
    {
	m_strDisplayName = ComputerName + 2;
	m_IsLocal = (0 == lstrcmpi(ComputerName, LocalComputer));
	CONFIGRET cr;
	if (CR_SUCCESS != (cr = CM_Connect_Machine(ComputerName, &m_hMachine)))
	{
	    m_hMachine = NULL;
	    SetLastError(ERROR_INVALID_COMPUTERNAME);
	    OutputDebugString(_T("Connect computer failed\n"));
	    TCHAR Text[MAX_PATH];
	    wsprintf(Text, _T("Machine Connection failed, cr= %lx(hex)\n"), cr);
	    MessageBox(NULL, Text, _T("List Device"), MB_ICONSTOP | MB_OK);
	    return FALSE;
	}
    }
    else
    {
	m_strDisplayName = LocalComputer + 2;
	m_IsLocal = TRUE;
	m_hMachine = NULL;
    }
    return TRUE;
}

CComputer::~CComputer()
{
    CM_Disconnect_Machine(m_hMachine);
}

BOOL
CDeviceTree::Create(
    LPCTSTR ComputerName
    )
{
    if (m_pComputer)
    {
	delete m_pComputer;
	SetupDiDestroyClassImageList(&m_ImageListData);
	m_ImageListData.cbSize = 0;
	m_pComputer = NULL;
    }
    ASSERT(NULL == m_pComputer);

    m_pComputer = new CComputer;
    if (m_pComputer->Create(ComputerName))
    {
	m_ImageListData.cbSize = sizeof(m_ImageListData);
	SetupDiGetClassImageList(&m_ImageListData);
	int ImageIndex;
	SetupDiGetClassImageIndex(&m_ImageListData,  (LPGUID)&GUID_DEVCLASS_COMPUTER, &ImageIndex);
	m_pComputer->SetImageIndex(ImageIndex);
	DEVNODE dnRoot;
	CM_Locate_DevNode_Ex(&dnRoot, NULL, 0, *m_pComputer);
	DEVNODE dnFirst;
	CM_Get_Child_Ex(&dnFirst, dnRoot, 0, *m_pComputer);
	return CreateSubtree(m_pComputer, NULL, dnFirst);
    }
    else
    {
	delete m_pComputer;
	m_pComputer = NULL;
	return FALSE;
    }
}



BOOL
CDeviceTree::CreateSubtree(
    CDevice* pParent,
    CDevice* pSibling,
    DEVNODE  dn
    )
{
    CDevice* pDevice;
    DEVNODE dnSibling, dnChild;
    do
    {
	if (CR_SUCCESS != CM_Get_Sibling_Ex(&dnSibling, dn, 0, *m_pComputer))
	    dnSibling = NULL;
	pDevice = new CDevice;
	pDevice->Create(*m_pComputer, dn);
	pDevice->SetParent(pParent);
	if (pSibling)
	    pSibling->SetSibling(pDevice);
	else if (pParent)
	    pParent->SetChild(pDevice);

	TCHAR GuidString[MAX_GUID_STRING_LEN];
	ULONG Size = sizeof(GuidString);
	if (CR_SUCCESS == CM_Get_DevNode_Registry_Property_Ex(dn,
					CM_DRP_CLASSGUID, NULL,
					GuidString, &Size, 0,  *m_pComputer) &&
	    _T('{') == GuidString[0] && _T('}') == GuidString[MAX_GUID_STRING_LEN - 2])
	{
	    GUID Guid;
	    GuidString[MAX_GUID_STRING_LEN - 2] = _T('\0');
	    UuidFromString(&GuidString[1], &Guid);
	    pDevice->SetClassGuid(&Guid);
	    int Index;
	    if (SetupDiGetClassImageIndex(&m_ImageListData, &Guid, &Index))
		pDevice->SetImageIndex(Index);
	}
	if (CR_SUCCESS == CM_Get_Child_Ex(&dnChild, dn, 0, *m_pComputer))
	{
	    CreateSubtree(pDevice, NULL, dnChild);
	}
	dn = dnSibling;
	pSibling = pDevice;
    } while (NULL != dn);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\listdev\computer.h ===
// computer.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// computer dialog

class computer : public CDialog
{
// Construction
public:
	computer(CWnd* pParent = NULL);   // standard constructor

	LPCTSTR GetNewComputerName()
	{
	   return m_strComputerName.IsEmpty() ?	NULL : (LPCTSTR)m_strComputerName;

	}

// Dialog Data
	//{{AFX_DATA(computer)
	enum { IDD = IDD_NEW_COMPUTER };
	CString	m_strComputerName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(computer)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL


// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(computer)
	afx_msg void OnCancel();
	afx_msg void OnOk();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\listdev\listdevdlg.cpp ===
// ListDevDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ListDev.h"
#include "devtree.h"
#include "computer.h"
#include "ListDevDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CListDevDlg dialog

CListDevDlg::CListDevDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CListDevDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CListDevDlg)
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
}

void CListDevDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CListDevDlg)
	DDX_Control(pDX, IDC_DEVDATA, m_lbDevData);
	DDX_Control(pDX, IDC_DEVTREE, m_DevTree);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CListDevDlg, CDialog)
	//{{AFX_MSG_MAP(CListDevDlg)
	ON_WM_PAINT()
	ON_NOTIFY(TVN_SELCHANGED, IDC_DEVTREE, OnSelchanged)
	ON_BN_CLICKED(IDC_CHANGE_COMPUTERNAME, OnChangeComputername)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CListDevDlg message handlers

BOOL CListDevDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	RECT rc;
	m_lbDevData.GetClientRect(&rc);
	m_lbDevData.ClientToScreen(&rc);
	m_lbDevData.SetHorizontalExtent((rc.right - rc.left + 1) * 10);
	// TODO: Add extra initialization here
	InitializeDeviceTree(g_strStartupComputerName.IsEmpty() ? NULL :
			     (LPCTSTR)g_strStartupComputerName);
	return TRUE;  // return TRUE  unless you set the focus to a control
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CListDevDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}


void
CListDevDlg::InitializeDeviceTree(
    LPCTSTR ComputerName
    )
{
    m_lbDevData.ResetContent();
    m_DevTree.DeleteAllItems();

    OutputDebugString(_T("InitializeDeviceTree\n"));
    OutputDebugString(ComputerName);
    if (m_DeviceTree.Create(ComputerName))
    {
	CComputer* pComputer = m_DeviceTree.GetComputer();
	SetDlgItemText(IDC_COMPUTERNAME, pComputer->GetDisplayName());
	//m_ImageList.Detach();
	m_ImageList.Attach(m_DeviceTree.GetClassImageList());
	m_DevTree.SetImageList(&m_ImageList, TVSIL_NORMAL);
	// insert computer node as the root node
	TV_INSERTSTRUCT tis;
	tis.hParent = TVI_ROOT;
	tis.hInsertAfter = TVI_SORT;
	memset(&tis.item, 0, sizeof(tis.item));
	tis.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE;
	tis.item.pszText = (LPTSTR)pComputer->GetDisplayName();
	tis.item.lParam = (LPARAM)this;
	tis.item.iImage = pComputer->GetImageIndex();
	HTREEITEM hti = m_DevTree.InsertItem(&tis);
	InitializeSubtree(hti, pComputer->GetChild());
	m_DevTree.Expand(hti, TVE_EXPAND);
    }
}


void
CListDevDlg::InitializeSubtree(
    HTREEITEM htiParent,
    CDevice*  pDevice
    )
{
    CDevice* pChild;
    TV_INSERTSTRUCT tis;

    memset(&tis, 0, sizeof(tis));
    do
    {
	tis.hParent = htiParent;
	tis.hInsertAfter = TVI_SORT;
	tis.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE;
	tis.item.pszText = (LPTSTR)pDevice->GetDisplayName();
	tis.item.lParam = (LPARAM)pDevice;
	tis.item.iImage = pDevice->GetImageIndex();
	HTREEITEM hti = m_DevTree.InsertItem(&tis);
	pChild = pDevice->GetChild();
	if (pChild)
	{
	    InitializeSubtree(hti, pChild);
	}
	pDevice = pDevice->GetSibling();
    } while (pDevice);
}


typedef struct tagColumnInfo
{
    TCHAR*	Text;
    int 	Format;
    int 	Width;
}COLUMNINFO, *PCOLUMNINFO;


#define NUMBER_OF_COLUMNS	    2
const COLUMNINFO    g_ColumnInfo[2] =
{
    {_T("Data type"), LVCFMT_LEFT, 100},
    {_T("Value"), LVCFMT_LEFT, 200 }
};

void
CListDevDlg::InitializeDeviceData(
    CDevice* pDevice
    )
{
#if 0
    m_DevData.DeleteAllItems();
    LV_COLUMN lvc;
    int i;
    memset(&lvc, 0, sizeof(lvc));
    lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    for (i = 0; i < NUMBER_OF_COLUMNS; i++)
    {
	lvc.pszText = (LPTSTR)g_ColumnInfo[i].Text;
	lvc.fmt = g_ColumnInfo[i].Format;
	lvc.cx = g_ColumnInfo[i].Width;
	m_DevData.SetColumn(i, &lvc);
    }
    LV_ITEM lvi;
    memset(&lvi, 0, sizeof(lvi));
    lvi.state = 0;
    lvi.lParam = 0;
    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
    int Index  = 0;
    CAttribute* pAttr;
    while (pDevice->EnumerateAttribute(Index, &pAttr))
    {
	lvi.iItem = Index;
	lvi.pszText = (LPTSTR)pAttr->GetType();
	lvi.iSubItem = 0;
	m_DevData.InsertItem(&lvi);
	lvi.pszText = (LPTSTR)pAttr->GetValue();
	lvi.iSubItem = 1;
	m_DevData.InsertItem(&lvi);
	Index++;
    }
#else
	m_lbDevData.ResetContent();
	CAttribute* pAttr;
	int Index = 0;
	while (pDevice->EnumerateAttribute(Index, &pAttr))
	{
	    CString strText;
	    strText = pAttr->GetType();
	    strText += _T("   ");
	    strText += pAttr->GetValue();
	    m_lbDevData.AddString(strText);
	    Index++;

	}
#endif
}

void CListDevDlg::OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here
	CDevice* pDevice = (CDevice*) pNMTreeView->itemNew.lParam;
	OutputDebugString(_T("OnSelChanged\n"));
	InitializeDeviceData(pDevice);
	*pResult = 0;
}

void CListDevDlg::OnChangeComputername() 
{
	// TODO: Add your control notification handler code here
	computer NewComputer(this);
	NewComputer.DoModal();
	LPCTSTR NewComputerName = NewComputer.GetNewComputerName();
	if (NewComputerName)
	{
	    CString strComputerName;
	    if (_T('\\') != NewComputerName[0])
		strComputerName = _T("\\\\");
	    strComputerName += NewComputerName;
	    InitializeDeviceTree(strComputerName);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\listdev\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ListDev.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\listdev\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\ocx\ctv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ctv.h
//
//--------------------------------------------------------------------------

// ctv.h : main header file for CTV.DLL

#if !defined( __AFXCTL_H__ )
    #error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CCtvApp : See ctv.cpp for implementation.

class CCtvApp : public COleControlModule
{
public:
    BOOL InitInstance();
    int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\listdev\listdevdlg.h ===
// ListDevDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CListDevDlg dialog

class CListDevDlg : public CDialog
{
// Construction
public:
	CListDevDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CListDevDlg)
	enum { IDD = IDD_LISTDEV_DIALOG };
	CListBox	m_lbDevData;
	CTreeCtrl	m_DevTree;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListDevDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CListDevDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnChangeComputername();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
    void InitializeSubtree(HTREEITEM htiParent, CDevice* pDevice);
    void InitializeDeviceTree(LPCTSTR ComputerName);
    void InitializeDeviceData(CDevice* pDevice);
    CDeviceTree     m_DeviceTree;
    CImageList	    m_ImageList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\listdev\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ListDev.rc
//
#define IDS_DATA_TYPE                   1
#define IDS_VALUE                       2
#define IDS_UNKNOWN                     3
#define IDS_DEVICEID                    4
#define IDS_STATUS                      5
#define IDS_PROBLEM                     6
#define IDS_SERVICE                     7
#define IDS_CAPABILITIES                8
#define IDS_CONFIGFLAGS                 9
#define IDS_DEVNODE                     10
#define IDS_COMPATIBELID                11
#define IDS_CLASS                       12
#define IDS_INFOFILE                    13
#define IDS_MFG 			14
#define IDS_HARDWAREID			15
#define IDS_COMPATIBLEID		16
#define IDS_CLASSGUID			17
#define IDS_LOCATION			18
#define IDS_BUSNUMBER			19
#define IDS_ENUMERATOR_NAME		20
#define IDS_DEVICEDESC			21
#define IDS_FRIENDLYNAME		22
#define IDS_DRIVER			24
#define IDS_PHYSICAL_DEVPATH		25
#define IDS_UI_NUMBER			26
#define IDS_UPPERFILTERS		27
#define IDS_LOWERFILTERS		28
#define IDS_BUSTYPEGUID 		29
#define IDS_LEGACYBUSTYPE		30




#define IDD_LISTDEV_DIALOG              102
#define IDR_MAINFRAME                   128
#define IDD_NEW_COMPUTER                129
#define IDC_DEVTREE                     1019
#define IDC_CHANGE_COMPUTERNAME         1021
#define IDC_COMPUTERNAME                1023
#define IDC_DEVDATA                     1026
#define IDC_EDIT_COMPUTERNAME           1031
#define ID_OK                           1032
#define IDC_CANCEL                      1034

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1035
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\ocx\ctvctl.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    ctvctl.cpp

Abstract:

    This module implements TreeView OCX for Device Manager snapin

Author:

    William Hsieh (williamh) created

Revision History:


--*/
// CTVCtl.cpp : Implementation of the CTVCtrl OLE control class.
#include "stdafx.h"
#include <afxcmn.h>
#include "ctv.h"
#include "CTVCtl.h"
#include "resource.h"

#ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define GET_X_LPARAM(lParam) (int)(short)LOWORD(lParam)
#define GET_Y_LPARAM(lParam) (int)(short)HIWORD(lParam)

IMPLEMENT_DYNCREATE(CTVCtrl, COleControl)

BEGIN_INTERFACE_MAP(CTVCtrl, COleControl)
INTERFACE_PART(CTVCtrl, IID_IDMTVOCX, DMTVOCX)
END_INTERFACE_MAP()


const IID IID_IDMTVOCX = {0x142525f2,0x59d8,0x11d0,{0xab,0xf0,0x00,0x20,0xaf,0x6b,0x0b,0x7a}};
const IID IID_ISnapinCallback = {0x8e0ba98a,0xd161,0x11d0,{0x83,0x53,0x00,0xa0,0xc9,0x06,0x40,0xbf}};



ULONG EXPORT CTVCtrl::XDMTVOCX::AddRef()
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->ExternalAddRef();
}
ULONG EXPORT CTVCtrl::XDMTVOCX::Release()
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->ExternalRelease();
}

HRESULT EXPORT CTVCtrl::XDMTVOCX::QueryInterface(
                                                REFIID iid,
                                                void ** ppvObj
                                                )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->ExternalQueryInterface(&iid, ppvObj);
}

HTREEITEM EXPORT CTVCtrl::XDMTVOCX::InsertItem(
                                              LPTV_INSERTSTRUCT pis
                                              )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->InsertItem(pis);
}

HRESULT EXPORT CTVCtrl::XDMTVOCX::DeleteItem(
                                            HTREEITEM hitem
                                            )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->DeleteItem(hitem);
}

HRESULT EXPORT CTVCtrl::XDMTVOCX::DeleteAllItems(
                                                )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->DeleteAllItems();
}



HIMAGELIST EXPORT CTVCtrl::XDMTVOCX::SetImageList(
                                                 INT iImage,
                                                 HIMAGELIST himl
                                                 )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->SetImageList(iImage, himl);
}


HRESULT EXPORT CTVCtrl::XDMTVOCX::SetItem(
                                         TV_ITEM* pitem
                                         )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->SetItem(pitem);
}


HRESULT EXPORT CTVCtrl::XDMTVOCX::Expand(
                                        UINT Flags,
                                        HTREEITEM hitem
                                        )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->Expand(Flags, hitem);
}

HRESULT EXPORT CTVCtrl::XDMTVOCX::SelectItem(
                                            UINT Flags,
                                            HTREEITEM hitem
                                            )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->SelectItem(Flags, hitem);
}


HRESULT EXPORT CTVCtrl::XDMTVOCX::SetStyle(
                                          DWORD dwStyle
                                          )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->SetStyle(dwStyle);
}

HWND EXPORT CTVCtrl::XDMTVOCX::GetWindowHandle(
                                              )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->GetWindowHandle();
}


HRESULT EXPORT CTVCtrl::XDMTVOCX::GetItem(
                                         TV_ITEM* pti
                                         )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->GetItem(pti);
}

HTREEITEM EXPORT CTVCtrl::XDMTVOCX::GetNextItem(
                                               UINT Flags,
                                               HTREEITEM htiRef
                                               )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->GetNextItem(Flags, htiRef);
}



HRESULT EXPORT CTVCtrl::XDMTVOCX::SelectItem(
                                            HTREEITEM hti
                                            )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->SelectItem(hti);
}


UINT EXPORT CTVCtrl::XDMTVOCX::GetCount(
                                       )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->GetCount();
}

HTREEITEM EXPORT CTVCtrl::XDMTVOCX::GetSelectedItem(
                                                   )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->GetSelectedItem();
}

HRESULT EXPORT CTVCtrl::XDMTVOCX::Connect(
                                         IComponent* pIComponent,
                                         MMC_COOKIE  cookie
                                         )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->Connect(pIComponent, cookie);
}
HRESULT EXPORT CTVCtrl::XDMTVOCX::SetActiveConnection(
                                                     MMC_COOKIE cookie
                                                     )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->SetActiveConnection(cookie);
}
MMC_COOKIE EXPORT CTVCtrl::XDMTVOCX::GetActiveConnection()
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->GetActiveConnection();
}

long EXPORT CTVCtrl::XDMTVOCX::SetRedraw(BOOL Redraw)
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->SetRedraw(Redraw);
}

BOOL EXPORT CTVCtrl::XDMTVOCX::EnsureVisible(
                                            HTREEITEM hitem
                                            )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->EnsureVisible(hitem);
}



/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CTVCtrl, COleControl)
//{{AFX_MSG_MAP(CTVCtrl)
ON_WM_DESTROY()
ON_WM_CONTEXTMENU()
//}}AFX_MSG_MAP
ON_MESSAGE(OCM_COMMAND, OnOcmCommand)
ON_MESSAGE(OCM_NOTIFY, OnOcmNotify)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CTVCtrl, COleControl)
//{{AFX_DISPATCH_MAP(CTVCtrl)
//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CTVCtrl, COleControl)
//{{AFX_EVENT_MAP(CTVCtrl)
// NOTE - ClassWizard will add and remove event map entries
//    DO NOT EDIT what you see in these blocks of generated code !
//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CTVCtrl, "CTREEVIEW.CTreeViewCtrl.1",
                       0xcd6c7868, 0x5864, 0x11d0, 0xab, 0xf0, 0, 0x20, 0xaf, 0x6b, 0xb, 0x7a)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CTVCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DTV =
{ 0xcd6c7866, 0x5864, 0x11d0, { 0xab, 0xf0, 0, 0x20, 0xaf, 0x6b, 0xb, 0x7a}};
const IID BASED_CODE IID_DTVEvents =
{ 0xcd6c7867, 0x5864, 0x11d0, { 0xab, 0xf0, 0, 0x20, 0xaf, 0x6b, 0xb, 0x7a}};


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwTVOleMisc =
OLEMISC_ACTIVATEWHENVISIBLE |
OLEMISC_SETCLIENTSITEFIRST |
OLEMISC_INSIDEOUT |
OLEMISC_CANTLINKINSIDE |
OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CTVCtrl, IDS_TV, _dwTVOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CTVCtrl::CTVCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CTVCtrl

BOOL CTVCtrl::CTVCtrlFactory::UpdateRegistry(BOOL bRegister)
{
    // TODO: Verify that your control follows apartment-model threading rules.
    // Refer to MFC TechNote 64 for more information.
    // If your control does not conform to the apartment-model rules, then
    // you must modify the code below, changing the 6th parameter from
    // afxRegApartmentThreading to 0.

    if (bRegister)
        return AfxOleRegisterControlClass(
                                         AfxGetInstanceHandle(),
                                         m_clsid,
                                         m_lpszProgID,
                                         IDS_TV,
                                         IDB_TV,
                                         afxRegApartmentThreading,
                                         _dwTVOleMisc,
                                         _tlid,
                                         _wVerMajor,
                                         _wVerMinor);
    else
        return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CTVCtrl::CTVCtrl - Constructor

CTVCtrl::CTVCtrl()
{
    InitializeIIDs(&IID_DTV, &IID_DTVEvents);

    m_nConnections = 0;
    m_pIComponent =  NULL;
    m_pISnapinCallback = NULL;
    m_Destroyed = FALSE;
    // TODO: Initialize your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CTVCtrl::~CTVCtrl - Destructor

CTVCtrl::~CTVCtrl()
{
    // TODO: Cleanup your control's instance data here.

    if (m_pISnapinCallback)
        m_pISnapinCallback->Release();
    if (m_pIComponent)
        m_pIComponent->Release();

}


/////////////////////////////////////////////////////////////////////////////
// CTVCtrl::OnDraw - Drawing function

void CTVCtrl::OnDraw(
                    CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
    DoSuperclassPaint(pdc, rcBounds);
}


/////////////////////////////////////////////////////////////////////////////
// CTVCtrl::DoPropExchange - Persistence support

void CTVCtrl::DoPropExchange(CPropExchange* pPX)
{
    ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
    COleControl::DoPropExchange(pPX);

    // TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CTVCtrl::OnResetState - Reset control to default state

void CTVCtrl::OnResetState()
{
    COleControl::OnResetState();  // Resets defaults found in DoPropExchange

    // TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CTVCtrl::PreCreateWindow - Modify parameters for CreateWindowEx

BOOL CTVCtrl::PreCreateWindow(CREATESTRUCT& cs)
{
    cs.lpszClass = _T("SysTreeView32");
    // Turn off WS_EX_NOPARENTNOTIFY style bit so that our parents
    // receive mouse clicks on our window. I do not know why MFC
    // fundation class turns this on for an OCX.
    cs.dwExStyle &= ~(WS_EX_NOPARENTNOTIFY);
    return COleControl::PreCreateWindow(cs);
}


/////////////////////////////////////////////////////////////////////////////
// CTVCtrl::IsSubclassedControl - This is a subclassed control

BOOL CTVCtrl::IsSubclassedControl()
{
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CTVCtrl::OnOcmCommand - Handle command messages

LRESULT CTVCtrl::OnOcmCommand(WPARAM wParam, LPARAM lParam)
{
#ifdef _WIN32
    WORD wNotifyCode = HIWORD(wParam);
#else
    WORD wNotifyCode = HIWORD(lParam);
#endif

    // TODO: Switch on wNotifyCode here.

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTVCtrl message handlers



///////////////////////////////////////////////////////////////////////
///
/// Tree View functions
///

HRESULT
CTVCtrl::Connect(
                IComponent* pIComponent,
                MMC_COOKIE cookie
                )
{
    HRESULT hr = S_OK;

    if (0 == m_nConnections) {
        ASSERT(NULL == m_pIComponent);

        m_pIComponent  = pIComponent;
        m_pIComponent->AddRef();
        hr = m_pIComponent->QueryInterface(IID_ISnapinCallback,
                                           reinterpret_cast<void**>(&m_pISnapinCallback)
                                          );
    }

    // A single snapin may have multiple nodes that uses us as result pane
    // display media, therefore, we may be connected mutlple times.
    // However, we get created only when MMC creates a new snapin instance.
    // This means, every connection call must provide the same
    // pIComponent and pConsole.
    //
    ASSERT(m_pIComponent == pIComponent);


    if (SUCCEEDED(hr)) {
        m_nConnections++;
        hr = SetActiveConnection(cookie);
    }
    return hr;
}

HRESULT
CTVCtrl::SetActiveConnection(
                            MMC_COOKIE cookie
                            )
{
    m_ActiveCookie = cookie;
    return S_OK;
}
MMC_COOKIE
CTVCtrl::GetActiveConnection()
{
    return m_ActiveCookie;
}

HTREEITEM CTVCtrl::InsertItem(
                             LPTV_INSERTSTRUCT pis
                             )
{
    return(HTREEITEM)SendMessage(TVM_INSERTITEM, 0, (LPARAM)pis);
}

HRESULT CTVCtrl::DeleteItem(
                           HTREEITEM hitem
                           )
{
    if (SendMessage(TVM_DELETEITEM, 0, (LPARAM)hitem))
        return S_OK;
    else
        return E_UNEXPECTED;
}

HRESULT CTVCtrl::DeleteAllItems()
{
    return DeleteItem((HTREEITEM)TVI_ROOT);

}
HIMAGELIST CTVCtrl::SetImageList(
                                INT iImage,
                                HIMAGELIST hmil
                                )
{
    return(HIMAGELIST)SendMessage(TVM_SETIMAGELIST, (WPARAM)iImage, (LPARAM)hmil);
}

HRESULT CTVCtrl::SetItem(
                        TV_ITEM* pitem
                        )
{
    if (SendMessage(TVM_SETITEM, 0, (LPARAM)pitem))
        return S_OK;
    else
        return E_UNEXPECTED;
}

HRESULT CTVCtrl::Expand(
                       UINT Flags,
                       HTREEITEM hitem
                       )
{
    if (SendMessage(TVM_EXPAND, (WPARAM) Flags, (LPARAM)hitem))
        return S_OK;
    else
        return E_UNEXPECTED;
}

HRESULT CTVCtrl::SelectItem(
                           UINT Flags,
                           HTREEITEM hitem
                           )
{
    if (SendMessage(TVM_SELECTITEM, (WPARAM)Flags, (LPARAM)hitem))
        return S_OK;
    else
        return E_UNEXPECTED;
}

HRESULT CTVCtrl::SetStyle(
                         DWORD dwStyle
                         )
{
    if (ModifyStyle(0, dwStyle))
        return S_OK;
    else
        return E_UNEXPECTED;
}

HWND CTVCtrl::GetWindowHandle(
                             )
{
    return m_hWnd;
}


HRESULT CTVCtrl::GetItem(
                        TV_ITEM* pti
                        )
{
    if (SendMessage(TVM_GETITEM, 0, (LPARAM)pti))
        return S_OK;
    else
        return E_UNEXPECTED;

}

HTREEITEM CTVCtrl::GetNextItem(
                              UINT Flags,
                              HTREEITEM htiRef
                              )
{
    return(HTREEITEM) SendMessage(TVM_GETNEXTITEM, (WPARAM)Flags, (LPARAM)htiRef);
}

HRESULT CTVCtrl::SelectItem(
                           HTREEITEM hti
                           )
{
    if (SendMessage(TVM_SELECTITEM, 0, (LPARAM) hti))
        return S_OK;

    else
        return S_FALSE;
}
UINT CTVCtrl::GetCount(
                      )
{
    return(UINT)SendMessage(TVM_GETCOUNT, 0, 0);
}


HTREEITEM CTVCtrl::HitTest(
                          LONG x,
                          LONG y,
                          UINT* pFlags
                          )
{
    POINT pt;
    pt.x = x;
    pt.y = y;

    ScreenToClient(&pt);

    TV_HITTESTINFO tvhti;
    tvhti.pt = pt;

    HTREEITEM hti = (HTREEITEM)SendMessage(TVM_HITTEST, 0, (LPARAM)&tvhti);

    if (hti && pFlags)
        *pFlags = tvhti.flags;

    return hti;
}
HTREEITEM CTVCtrl::GetSelectedItem(
                                  )
{
    return(HTREEITEM)SendMessage(TVM_GETNEXTITEM, TVGN_CARET, 0);
}

HRESULT CTVCtrl::SetRedraw(
                          BOOL Redraw
                          )
{
    if (Redraw)
        Invalidate();
    return S_OK;
}

BOOL CTVCtrl::EnsureVisible(
                           HTREEITEM hitem
                           )
{
    return(BOOL)SendMessage(TVM_ENSUREVISIBLE, 0, (LPARAM)hitem);
}

LRESULT
CTVCtrl::OnOcmNotify(
                    WPARAM wParam,
                    LPARAM lParam
                    )
{

    LPARAM param, arg;
    MMC_COOKIE cookie = 0;

    HRESULT hr = S_FALSE;
    TV_NOTIFY_CODE NotifyCode;
    TV_ITEM TI;

    NotifyCode = TV_NOTIFY_CODE_UNKNOWN;
    
    switch (((NMHDR*)lParam)->code) {
    
    case NM_RCLICK:
    case NM_RDBLCLK:
    case NM_CLICK:
    case NM_DBLCLK:
        NotifyCode = DoMouseNotification(((NMHDR*)lParam)->code, &cookie,
                                         &arg, &param);
        break;
    
    case TVN_KEYDOWN:
        TI.hItem = GetSelectedItem();
        TI.mask = TVIF_PARAM;
        if (TI.hItem && SUCCEEDED(GetItem(&TI))) {
            cookie = (MMC_COOKIE)TI.lParam;
            NotifyCode = TV_NOTIFY_CODE_KEYDOWN;
            param = ((TV_KEYDOWN*)lParam)->wVKey;
            arg = (LPARAM)TI.hItem;
        }
        break;
    
    case NM_SETFOCUS:
        TI.hItem = GetSelectedItem();
        TI.mask = TVIF_PARAM;
        if (TI.hItem && SUCCEEDED(GetItem(&TI))) {
            cookie = (MMC_COOKIE)TI.lParam;
            NotifyCode = TV_NOTIFY_CODE_FOCUSCHANGED;
            param = 1;
            arg = (LPARAM)TI.hItem;
        }
        break;
#if 0

    case TVN_GETDISPINFOA:
    case TVN_GETDISPINFOW:
        TI.hItem = ((TV_DISPINFO*)lParam)->item.hItem;
        TI.mask = TVIF_PARAM;
        if (TI.hItem && SUCCEEDED(GetItem(&TI))) {
            NotifyCode = TV_NOTIFY_CODE_GETDISPINFO;
            arg = (LPARAM)TI.hItem;
            cookie = (MMC_COOKIE)TI.lParam;
            param = (LPARAM)&((TV_DISPINFO*)lParam)->item;
        }
        break;
    
    case TVN_SELCHANGINGA:
    case TVN_SELCHANGINGW:
        NotifyCode = TV_NOTIFY_CODE_SELCHANGING;
        arg = (LPARAM)((NM_TREEVIEW*)lParam)->itemNew.hItem;
        cookie = (MMC_COOKIE)((NM_TREEVIEW*)lParam)->itemNew.lParam;
        param = (LPARAM)((NM_TREEVIEW*)lParam)->action;
        break;


    case TVN_ITEMEXPANDINGA:
    case TVN_ITEMEXPANDINGW:
        NotifyCode = TV_NOTIFY_CODE_EXPANDING;
        arg = (LPARAM)((NM_TREEVIEW*)lParam)->itemNew.hItem;
        cookie = (MMC_COOKIE)((NM_TREEVIEW*)lParam)->itemNew.lParam;
        param = (LPARAM)((NM_TREEVIEW*)lParam)->action;
        break;
#endif

    case TVN_SELCHANGEDA:
    case TVN_SELCHANGEDW:
        NotifyCode = TV_NOTIFY_CODE_SELCHANGED;
        arg = (LPARAM)((NM_TREEVIEW*)lParam)->itemNew.hItem;
        cookie = (MMC_COOKIE)((NM_TREEVIEW*)lParam)->itemNew.lParam;
        param = (LPARAM)((NM_TREEVIEW*)lParam)->action;
        break;
    
    case TVN_ITEMEXPANDEDA:
    case TVN_ITEMEXPANDEDW:
        NotifyCode = TV_NOTIFY_CODE_EXPANDED;
        arg = (LPARAM)((NM_TREEVIEW*)lParam)->itemNew.hItem;
        cookie = (MMC_COOKIE)((NM_TREEVIEW*)lParam)->itemNew.lParam;
        param = (LPARAM)((NM_TREEVIEW*)lParam)->action;
        break;

    default:
        NotifyCode = TV_NOTIFY_CODE_UNKNOWN;
        break;
    }

    if (TV_NOTIFY_CODE_UNKNOWN != NotifyCode && m_pISnapinCallback) {
        
        hr = m_pISnapinCallback->tvNotify(*this, cookie, NotifyCode, arg, param);
        
        if (S_FALSE == hr) {
            //
            // Translate RCLICK to context menu
            //
            if (TV_NOTIFY_CODE_RCLICK == NotifyCode) {
                
                SendMessage(WM_CONTEXTMENU, (WPARAM)m_hWnd, GetMessagePos());
                hr = S_OK;
            }

            //
            // Translate Shift-F10 or VK_APPS to context menu 
            //
            else if (TV_NOTIFY_CODE_KEYDOWN == NotifyCode && 
                     (VK_F10 == param && GetKeyState(VK_SHIFT) < 0) ||
                     (VK_APPS == param)) {
                
                RECT rect;
                *((HTREEITEM*)&rect) = (HTREEITEM)arg;
                
                if (SendMessage(TVM_GETITEMRECT, TRUE, (LPARAM)&rect)) {
                    
                    POINT pt;
                    pt.x = (rect.left + rect.right) / 2;
                    pt.y = (rect.top + rect.bottom) / 2;
                    ClientToScreen(&pt);
                    SendMessage(WM_CONTEXTMENU, (WPARAM)m_hWnd, MAKELPARAM(pt.x, pt.y));
                    hr = S_OK;
                }
            }
        }
    }

    //
    // On a TVN_KEYDOWN we should always return 0, otherwise the treeview
    // control gets confused.
    //
    if (((NMHDR*)lParam)->code == TVN_KEYDOWN) {

        hr = S_FALSE;
    }

    ASSERT(S_OK == hr || S_FALSE == hr);

    if (S_OK == hr) {
        
        return 1;
    }

    return 0;
}

TV_NOTIFY_CODE
CTVCtrl::DoMouseNotification(
                            UINT Code,
                            MMC_COOKIE* pcookie,
                            LPARAM* parg,
                            LPARAM* pparam
                            )
{
    DWORD MsgPos;
    POINT point;

    ASSERT(pparam && parg && pcookie);
    *pparam = 0;
    *parg = 0;
    MsgPos = GetMessagePos();
    point.x = GET_X_LPARAM(MsgPos);
    point.y = GET_Y_LPARAM(MsgPos);
    UINT htFlags;
    HTREEITEM hti = HitTest(point.x, point.y, &htFlags);

    TV_NOTIFY_CODE NotifyCode = TV_NOTIFY_CODE_UNKNOWN;

    if (hti && (htFlags & TVHT_ONITEM)) {
        
        TV_ITEM TI;
        TI.hItem = hti;
        TI.mask = TVIF_PARAM;

        if (SUCCEEDED(GetItem(&TI))) {
            
            switch (Code) {
            
            case NM_RCLICK:
                NotifyCode = TV_NOTIFY_CODE_RCLICK;
                break;
            
            case NM_RDBLCLK:
                NotifyCode = TV_NOTIFY_CODE_RDBLCLK;
                break;
            
            case NM_CLICK:
                NotifyCode = TV_NOTIFY_CODE_CLICK;
                break;
            
            case NM_DBLCLK:
                NotifyCode = TV_NOTIFY_CODE_DBLCLK;
                break;
            
            default:
                NotifyCode = TV_NOTIFY_CODE_UNKNOWN;
                break;
            }

            if (TV_NOTIFY_CODE_UNKNOWN != NotifyCode) {
                
                *parg = (LPARAM)hti;
                *pparam = htFlags;
                *pcookie = (MMC_COOKIE)TI.lParam;
            }
        }
    }

    return NotifyCode;
}

// OnDestroy may be called on two occasions:
// (1). We are the current active result pane window and MMC
//      is destroying our parent window(MDI client). Note that
//      if we are not the active result pane window, this function
//      will not get called until (2).
// (2). our reference count has reached zero.
//
//  When (1) happens, the snapin may be still holding reference to us
//  thus, even though our window has been destroyed (2) still happens
//  (unless PostNcDestory is done which MFC reset m_hWnd)and we end up
//  destoying the window twice.
//  So, we keep an eye on OnDestroy and do nothing after it has been called.
//  We can not wait for PostNcDestroy because we have no idea when it would
//  come.
//
void CTVCtrl::OnDestroy()
{
    if (!m_Destroyed) {
        COleControl::OnDestroy();
        m_Destroyed = TRUE;
    }
}

void CTVCtrl::OnContextMenu(CWnd* pWnd, CPoint point)
{
    // TODO: Add your message handler code here
    POINT pt = point;
    UINT htFlags;
    HTREEITEM hti = HitTest(pt.x, pt.y, &htFlags);

    if (hti) {
        TV_ITEM TI;
        TI.hItem = hti;
        TI.mask = TVIF_PARAM;
        if (SUCCEEDED(GetItem(&TI))) {
            m_pISnapinCallback->tvNotify(*this, (MMC_COOKIE)TI.lParam,
                                         TV_NOTIFY_CODE_CONTEXTMENU,
                                         (LPARAM)hti, (LPARAM)&point );
        }
    }
}

// The upmost frame window may have its own accelerator table and may take
// away certain key combinations we really need.
BOOL CTVCtrl::PreTranslateMessage(MSG* pMsg)
{
    // TODO: Add your specialized code here and/or call the base class
    if (WM_KEYDOWN == pMsg->message &&
        (VK_DELETE == pMsg->wParam ||
         VK_RETURN == pMsg->wParam)) {
        OnKeyDown((UINT)pMsg->wParam, LOWORD(pMsg->lParam), HIWORD(pMsg->lParam));
        return TRUE;
    }

    else if (WM_SYSKEYDOWN == pMsg->message && VK_F10 == pMsg->wParam &&
             GetKeyState(VK_SHIFT) < 0) {
        // Shift-F10 will be translated to WM_CONTEXTMENU
        OnSysKeyDown((UINT)pMsg->wParam, LOWORD(pMsg->lParam), HIWORD(pMsg->lParam));
        return TRUE;
    }

    return COleControl::PreTranslateMessage(pMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\ocx\ctv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ctv.cpp
//
//--------------------------------------------------------------------------

// ctv.cpp : Implementation of CCtvApp and DLL registration.

#include "stdafx.h"
#include "ctv.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CCtvApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
        { 0xcd6c7865, 0x5864, 0x11d0, { 0xab, 0xf0, 0, 0x20, 0xaf, 0x6b, 0xb, 0x7a } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CCtvApp::InitInstance - DLL initialization

BOOL CCtvApp::InitInstance()
{
    BOOL bInit = COleControlModule::InitInstance();

    if (bInit)
    {
        // TODO: Add your own module initialization code here.
    }

    return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CCtvApp::ExitInstance - DLL termination

int CCtvApp::ExitInstance()
{
    // TODO: Add your own module termination code here.

    return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

    if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
        return ResultFromScode(SELFREG_E_TYPELIB);

    if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
        return ResultFromScode(SELFREG_E_CLASS);

    return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

    if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
        return ResultFromScode(SELFREG_E_TYPELIB);

    if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
        return ResultFromScode(SELFREG_E_CLASS);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\ocx\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for OLE Controls

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#ifndef _UNICODE
#include <afxdb.h>          // MFC database classes
#include <afxdao.h>         // MFC DAO database classes
#endif //_UNICODE

#include <mmc.h>

extern const IID IID_ITreeViewPrivate;
extern const IID IID_IMMCSnapin;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\ocx\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\about.h ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    about.h

Abstract:

    header file defines CDevMgrAbout class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#ifndef __ABOUT_H_
#define __ABOUT_H_


class CDevMgrAbout : public ISnapinAbout
{
public:
    CDevMgrAbout() :m_Ref(1)
    {}
// IUNKNOWN interface
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
// ISnapinAbout interface
    STDMETHOD(GetSnapinDescription)(LPOLESTR *ppDescription);
    STDMETHOD(GetProvider)(LPOLESTR* ppProvider);
    STDMETHOD(GetSnapinVersion)(LPOLESTR *ppVersion);
    STDMETHOD(GetSnapinImage)(HICON *phIcon);
    STDMETHOD(GetStaticFolderImage)(HBITMAP* phSmall,
                    HBITMAP* phSmallOpen,
                    HBITMAP* phLarge,
                    COLORREF* pcrMask);
private:
    HRESULT LoadResourceOleString(int StringId, LPOLESTR* ppString);
    ULONG           m_Ref;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\ocx\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ctv.rc
//
#define IDS_TV                          1
#define IDB_TV                          1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\ocx\ctvctl.h ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    ctvctl.h

Abstract:

    header file for ctvctl.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/
#include "..\inc\tvintf.h"

// CTVCtl.h : Declaration of the CTVCtrl OLE control class.


const int MAX_CONNECTIONS = 10;

/////////////////////////////////////////////////////////////////////////////
// CTVCtrl : See CTVCtl.cpp for implementation.

class CTVCtrl : public COleControl
{
        DECLARE_DYNCREATE(CTVCtrl)

// Constructor
public:
        CTVCtrl();

// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CTVCtrl)
        public:
        virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
        virtual void DoPropExchange(CPropExchange* pPX);
        virtual void OnResetState();
        virtual BOOL PreTranslateMessage(MSG* pMsg);
        //}}AFX_VIRTUAL

// Implementation
protected:
        ~CTVCtrl();

        DECLARE_OLECREATE_EX(CTVCtrl)    // Class factory and guid
        DECLARE_OLETYPELIB(CTVCtrl)      // GetTypeInfo
        DECLARE_OLECTLTYPE(CTVCtrl)             // Type name and misc status

        // Subclassed control support
        BOOL PreCreateWindow(CREATESTRUCT& cs);
        BOOL IsSubclassedControl();
        LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);

// Message maps
        //{{AFX_MSG(CTVCtrl)
        afx_msg void OnDestroy();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
        //}}AFX_MSG
        afx_msg LRESULT OnOcmNotify(WPARAM wParam, LPARAM lParam);
        DECLARE_MESSAGE_MAP()

// Dispatch maps
        //{{AFX_DISPATCH(CTVCtrl)
        //}}AFX_DISPATCH
        DECLARE_DISPATCH_MAP()

// Event maps
        //{{AFX_EVENT(CTVCtrl)
        //}}AFX_EVENT
        DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
        enum {
        //{{AFX_DISP_ID(CTVCtrl)
        //}}AFX_DISP_ID
        };

protected:
        DECLARE_INTERFACE_MAP()
        BEGIN_INTERFACE_PART(DMTVOCX, IDMTVOCX)
            public: virtual HTREEITEM InsertItem(LPTV_INSERTSTRUCT pis);
            public: virtual HRESULT DeleteItem(HTREEITEM hItem);
            public: virtual HRESULT DeleteAllItems();
            public: virtual HIMAGELIST SetImageList(INT iImage, HIMAGELIST himl);
            public: virtual HRESULT SetItem(TV_ITEM* pitem);
            public: virtual HRESULT Expand(UINT Flags, HTREEITEM htiem);
            public: virtual HRESULT SelectItem(UINT Flags, HTREEITEM hitem);
            public: virtual HRESULT SetStyle(DWORD dwStyle);
            public: virtual HWND    GetWindowHandle();
            public: virtual HRESULT GetItem(TV_ITEM* pti);
            public: virtual HTREEITEM GetNextItem(UINT Flags, HTREEITEM htiRef);
            public: virtual HRESULT SelectItem(HTREEITEM hti);
            public: virtual UINT    GetCount();
            public: virtual HTREEITEM GetSelectedItem();
            public: virtual HRESULT Connect(IComponent* pIComponent, MMC_COOKIE);
            public: virtual HRESULT SetActiveConnection(MMC_COOKIE cookie);
            public: virtual MMC_COOKIE    GetActiveConnection();
            public: virtual HRESULT SetRedraw(BOOL Redraw);
            public: virtual BOOL    EnsureVisible(HTREEITEM hitem);
        END_INTERFACE_PART(DMTVOCX)


private:
        HTREEITEM InsertItem(LPTV_INSERTSTRUCT pis);
        HRESULT DeleteItem(HTREEITEM hItem);
        HRESULT DeleteAllItems();
        HIMAGELIST SetImageList(INT iImage, HIMAGELIST himl);
        HRESULT SetItem(TV_ITEM* pitem);
        HRESULT Expand(UINT Flags, HTREEITEM htiem);
        HRESULT SelectItem(UINT Flags, HTREEITEM hitem);
        HRESULT SetStyle(DWORD dwStyle);
        HWND    GetWindowHandle();
        HRESULT GetItem(TV_ITEM* pti);
        HTREEITEM GetNextItem(UINT Flags, HTREEITEM htiRef);
        HRESULT SelectItem(HTREEITEM hti);
        UINT    GetCount();
        HTREEITEM HitTest(LONG x, LONG y, UINT* phtFlags);
        HTREEITEM GetSelectedItem();
        HRESULT Connect(IComponent* pIComponent, MMC_COOKIE cookie);
        HRESULT SetActiveConnection(MMC_COOKIE cookie);
        MMC_COOKIE      GetActiveConnection();
        HRESULT SetRedraw(BOOL Redraw);
        BOOL    EnsureVisible(HTREEITEM hitem);
        TV_NOTIFY_CODE DoMouseNotification(UINT code, MMC_COOKIE* pcookie,LPARAM* parg, LPARAM* param);
// private data
        MMC_COOKIE      m_ActiveCookie;
        int     m_nConnections;
        BOOL    m_HasFocus;
        IComponent* m_pIComponent;
        ISnapinCallback* m_pISnapinCallback;
        BOOL    m_Destroyed;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\about.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    about.cpp

Abstract:

    This module implemets ISnapinAbout inteface(CDevMgrAbout class).

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "about.h"

//
// IUnknown interface
//
ULONG
CDevMgrAbout::AddRef()
{
    ::InterlockedIncrement((LONG*)&m_Ref);
    
    return m_Ref;
}

ULONG
CDevMgrAbout::Release()
{
    ::InterlockedDecrement((LONG*)&m_Ref);
    
    if (!m_Ref)
    {
        delete this;
        return 0;
    }
    
    return m_Ref;
}

STDMETHODIMP
CDevMgrAbout::QueryInterface(
    REFIID  riid,
    void**  ppv
    )
{
    if (!ppv)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;


    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown*)this;
    }
    
    else if (IsEqualIID(riid, IID_ISnapinAbout))
    {
        *ppv = (ISnapinAbout*)this;
    }
    
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    
    if (SUCCEEDED(hr))
    {
        AddRef();
    }

    return hr;
}

// ISnapinAbout interface

STDMETHODIMP
CDevMgrAbout::GetSnapinDescription(
    LPOLESTR *ppDescription
    )
{
    return LoadResourceOleString(IDS_PROGRAM_ABOUT, ppDescription);
}

STDMETHODIMP
CDevMgrAbout::GetProvider(
    LPOLESTR *ppProvider
    )
{
    return LoadResourceOleString(IDS_PROGRAM_PROVIDER, ppProvider);
}

STDMETHODIMP
CDevMgrAbout::GetSnapinVersion(
    LPOLESTR *ppVersion
    )
{
    return LoadResourceOleString(IDS_PROGRAM_VERSION, ppVersion);
}

STDMETHODIMP
CDevMgrAbout::GetSnapinImage(
    HICON* phIcon
    )
{
    if (!phIcon)
    {
        return E_INVALIDARG;
    }

    *phIcon = ::LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_DEVMGR));
    
    if (!*phIcon)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

STDMETHODIMP
CDevMgrAbout::GetStaticFolderImage(
    HBITMAP* phSmall,
    HBITMAP* phSmallOpen,
    HBITMAP* phLarge,
    COLORREF* pcrMask
    )
{
    if (!phSmall || !phSmallOpen || !phLarge || !pcrMask)
    {
        return E_INVALIDARG;
    }

    *phSmall = ::LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_SYSDM16));
    *phSmallOpen = ::LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_SYSDM16));
    *phLarge =::LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_SYSDM32));
    *pcrMask = RGB(255, 0, 255);
    
    if (NULL == *phSmall || NULL == *phSmallOpen || NULL == *phLarge)
    {
        if (NULL != *phSmall)
        {
            ::DeleteObject(*phSmall);
            *phSmall = NULL;
        }
        
        if (NULL != *phSmallOpen)
        {
            ::DeleteObject(*phSmallOpen);
            *phSmallOpen = NULL;
        }

        if (NULL != *phLarge)
        {
            ::DeleteObject(*phLarge);
            *phLarge = NULL;
        }

        return E_OUTOFMEMORY;
    }
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// private routine to allocate ole task memory and load the given resource
// string(indicated by its string id) to the allocated memory.
// INPUT:
//  StringId -- the string resource id
//  LPOLESTR* -- place holder to hold the ole string pointer
// OUTPUT:
//  standard OLE HRESULT
HRESULT
CDevMgrAbout::LoadResourceOleString(
    int StringId,
    LPOLESTR* ppolestr
    )
{
    if (!ppolestr)
    {
        return E_INVALIDARG;
    }

    TCHAR Text[MAX_PATH];
    
    // get the string
    ::LoadString(g_hInstance, StringId, Text, ARRAYLEN(Text));
    
    try
    {
        *ppolestr = AllocOleTaskString(Text);
    }
    catch (CMemoryException* e)
    {
        e->Delete();

        if (*ppolestr)
        {
            FreeOleTaskString(*ppolestr);
            *ppolestr = NULL;
        }
    }

    if (!*ppolestr)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\api.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    api.cpp

Abstract:

    This module implements Device Manager exported APIs.

Author:

    William Hsieh (williamh) created

Revision History:


--*/
#include "devmgr.h"
#include "devgenpg.h"
#include "devdrvpg.h"
#include "devpopg.h"
#include "api.h"
#include "printer.h"
#include "tswizard.h"


STDAPI_(BOOL)
DeviceManager_ExecuteA(
    HWND      hwndStub,
    HINSTANCE hAppInstance,
    LPCWSTR   lpMachineName,
    int       nCmdShow
    )
{
    try
    {
        CTString tstrMachineName(lpMachineName);
        
        return DeviceManager_Execute(hwndStub, 
                                     hAppInstance,
                                     (LPCTSTR)tstrMachineName, 
                                     nCmdShow
                                     );
    }

    catch(CMemoryException* e)
    {
        e->Delete();
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return FALSE;
}

STDAPI_(BOOL)
DeviceManager_ExecuteW(
    HWND      hwndStub,
    HINSTANCE hAppInstance,
    LPCWSTR   lpMachineName,
    int       nCmdShow
    )
{
    try
    {
        CTString tstrMachineName(lpMachineName);
    
        return DeviceManager_Execute(hwndStub, 
                                     hAppInstance,
                                     (LPCTSTR)tstrMachineName, 
                                     nCmdShow
                                     );
    }

    catch(CMemoryException* e)
    {
        e->Delete();
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return FALSE;
}

BOOL
DeviceManager_Execute(
    HWND      hwndStub,
    HINSTANCE hAppInstance,
    LPCTSTR   lpMachineName,
    int       nCmdShow
    )
{
    SHELLEXECUTEINFO sei;
    TCHAR MachineOptions[MAX_PATH];
    TCHAR Parameters[MAX_PATH * 2];
    
    if (lpMachineName)
    {
        wsprintf(MachineOptions, DEVMGR_MACHINENAME_OPTION, lpMachineName);
    }

    else
    {
        MachineOptions[0] = _T('\0');
    }

    WCHAR* FilePart;
    DWORD Size;
    
    Size = SearchPath(NULL, DEVMGR_MSC_FILE, NULL, MAX_PATH, Parameters, &FilePart);
    
    if (!Size || Size >=MAX_PATH)
    {
        lstrcpy(Parameters, DEVMGR_MSC_FILE);
    }

    lstrcat(Parameters, MMC_COMMAND_LINE);
    lstrcat(Parameters, MachineOptions);

    memset(&sei, 0, sizeof(sei));
    sei.cbSize = sizeof(sei);
    sei.hwnd = hwndStub;
    sei.nShow = nCmdShow;
    sei.hInstApp = hAppInstance;
    sei.lpFile = MMC_FILE;
    sei.lpParameters = Parameters;
    
    return ShellExecuteEx(&sei);
}

STDAPI_(BOOL)
DeviceManagerPrintA(
    LPCSTR MachineName,
    LPCSTR FileName,
    int    ReportType,
    DWORD  ClassGuids,
    LPGUID ClassGuidList
    )
{
    BOOL Result;

    try
    {
        CTString strMachineName(MachineName);
        CTString strFileName(FileName);
    
        Result = DeviceManagerDoPrint(strMachineName, 
                                      strFileName, 
                                      ReportType,
                                      ClassGuids, 
                                      ClassGuidList
                                      );
    }

    catch (CMemoryException* e)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        Result = 0;
    }

    return Result;
}

STDAPI_(BOOL)
DeviceManagerPrintW(
    LPCWSTR MachineName,
    LPCWSTR FileName,
    int     ReportType,
    DWORD  ClassGuids,
    LPGUID ClassGuidList
    )
{
    BOOL Result;
    
    try
    {
        CTString strMachineName(MachineName);
        CTString strFileName(FileName);
    
        Result = DeviceManagerDoPrint(strMachineName, 
                                      strFileName, 
                                      ReportType,
                                      ClassGuids, 
                                      ClassGuidList
                                      );
    }

    catch (CMemoryException* e)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        Result = FALSE;
    }

    return Result;
}

BOOL
DeviceManagerDoPrint(
    LPCTSTR MachineName,
    LPCTSTR FileName,
    int     ReportType,
    DWORD ClassGuids,
    LPGUID ClassGuidList
    )
{
    int PrintStatus = 0;
    
    if (!FileName || _T('\0') == *FileName)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    TCHAR FullPathName[MAX_PATH + 1];
    LPTSTR FilePart;
    
    if (!GetFullPathName(FileName, ARRAYLEN(FullPathName), FullPathName, &FilePart)) 
    {
        return FALSE;
    }

    CMachine TheMachine(MachineName);
    
    if (TheMachine.Initialize())
    {
        CPrinter ThePrinter;
        
        if (ThePrinter.StartDoc(FullPathName))
        {
            if (0 == ReportType)
            {
                // print system and resource summary
                PrintStatus = ThePrinter.PrintResourceSummary(TheMachine);
            } else if (1 == ReportType)
            {
                // print selected classes
                CClass* pClass;
                
                for (DWORD i = 0; i < ClassGuids; i++)
                {
                    pClass = TheMachine.ClassGuidToClass(&ClassGuidList[i]);
                    
                    if (pClass)
                    {
                        PrintStatus = ThePrinter.PrintClass(pClass);
                    }
                }
            } else if (2 == ReportType)
            {
                // print resource/system summary and all device information
                PrintStatus = ThePrinter.PrintAll(TheMachine);
            }
        
            else
            {
                SetLastError(ERROR_INVALID_PARAMETER);
            }
            
            ThePrinter.EndDoc();
        }
    }

    return 0 != PrintStatus;
}

BOOL
AddPageCallback(
    HPROPSHEETPAGE hPage,
    LPARAM lParam
    )
{
    CPropSheetData* ppsData = (CPropSheetData*)lParam;
    
    ASSERT(ppsData);
    
    return ppsData->InsertPage(hPage);
}

void
ReportCmdLineError(
    HWND hwndParent,
    int ErrorStringID,
    LPCTSTR Caption
    )
{
    TCHAR Title[LINE_LEN + 1];
    TCHAR Msg[LINE_LEN + 1];
    
    ::LoadString(g_hInstance, ErrorStringID, Msg, ARRAYLEN(Msg));
    
    if (!Caption)
    {
        ::LoadString(g_hInstance, IDS_NAME_DEVMGR,
                   Title, ARRAYLEN(Title));

        Caption = Title;
    }

    MessageBox(hwndParent, Msg, Caption, MB_OK | MB_ICONERROR);
}

STDAPI_(void)
DeviceProperties_RunDLLA(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPSTR lpCmdLine,
    int   nCmdShow
    )
{

    try
    {
        CTString tstrCmdLine(lpCmdLine);
    
        DeviceProperties_RunDLL(hwndStub, 
                                hAppInstance,
                                (LPCTSTR)tstrCmdLine,   
                                nCmdShow
                                );
    }

    catch (CMemoryException* e)
    {
        e->ReportError();
        e->Delete();
    }
}

STDAPI_(void)
DeviceProperties_RunDLLW(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPWSTR lpCmdLine,
    int    nCmdShow
    )
{
    try
    {
        CTString tstrCmdLine(lpCmdLine);
    
        DeviceProperties_RunDLL(hwndStub, 
                                hAppInstance,
                                (LPCTSTR)tstrCmdLine, 
                                nCmdShow
                                );
    }

    catch (CMemoryException* e)
    {
        e->ReportError();
        e->Delete();
    }
}

void
DeviceProperties_RunDLL(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPCTSTR lpCmdLine,
    int    nCmdShow
    )
{
    try
    {
        CRunDLLCommandLine CmdLine;
        CmdLine.ParseCommandLine(lpCmdLine);
    
        if (NULL == CmdLine.GetDeviceID())
        {
            ReportCmdLineError(hwndStub, IDS_NO_DEVICEID);
            return;
        }
        
        DevicePropertiesEx(hwndStub, 
                           CmdLine.GetMachineName(), 
                           CmdLine.GetDeviceID(),
                           CmdLine.GetFlags(),
                           CmdLine.ToShowDeviceTree()
                           );
    }

    catch (CMemoryException* e)
    {
        e->ReportError();
        e->Delete();
        return;
    }
}

STDAPI_(int)
DevicePropertiesA(
    HWND hwndParent,
    LPCSTR MachineName,
    LPCSTR DeviceID,
    BOOL ShowDeviceTree
    )
{
    try
    {
        CTString tstrMachineName(MachineName);
        CTString tstrDeviceID(DeviceID);
        
        return DevicePropertiesEx(hwndParent, 
                                  (LPCTSTR)tstrMachineName,
                                  (LPCTSTR)tstrDeviceID, 
                                  DEVPROP_SHOW_RESOURCE_TAB,
                                  ShowDeviceTree
                                  );
    }
    
    catch (CMemoryException* e)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        e->Delete();
    }
    
    return 0;
}

STDAPI_(int)
DevicePropertiesW(
    HWND hwndParent,
    LPCWSTR MachineName,
    LPCWSTR DeviceID,
    BOOL ShowDeviceTree
    )
{
    try
    {
        CTString tstrMachineName(MachineName);
        CTString tstrDeviceID(DeviceID);
        
        return DevicePropertiesEx(hwndParent, 
                                  (LPCTSTR)tstrMachineName,
                                  (LPCTSTR)tstrDeviceID, 
                                  DEVPROP_SHOW_RESOURCE_TAB,
                                  ShowDeviceTree
                                  );
    }
    
    catch (CMemoryException* e)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        e->Delete();
    }
    
    return 0;
}

STDAPI_(int)
DevicePropertiesExA(
    HWND hwndParent,
    LPCSTR MachineName,
    LPCSTR DeviceID,
    DWORD Flags,
    BOOL ShowDeviceTree
    )
{
    try
    {
        CTString tstrMachineName(MachineName);
        CTString tstrDeviceID(DeviceID);
        
        return DevicePropertiesEx(hwndParent, 
                                  (LPCTSTR)tstrMachineName,
                                  (LPCTSTR)tstrDeviceID, 
                                  Flags,
                                  ShowDeviceTree
                                  );
    }
    
    catch (CMemoryException* e)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        e->Delete();
    }
    
    return 0;
}

STDAPI_(int)
DevicePropertiesExW(
    HWND hwndParent,
    LPCWSTR MachineName,
    LPCWSTR DeviceID,
    DWORD Flags,
    BOOL ShowDeviceTree
    )
{
    try
    {
        CTString tstrMachineName(MachineName);
        CTString tstrDeviceID(DeviceID);
        
        return DevicePropertiesEx(hwndParent, 
                                  (LPCTSTR)tstrMachineName,
                                  (LPCTSTR)tstrDeviceID, 
                                  Flags,
                                  ShowDeviceTree
                                  );
    }
    
    catch (CMemoryException* e)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        e->Delete();
    }
    
    return 0;
}

int
DevicePropertiesEx(
    HWND hwndParent,
    LPCTSTR MachineName,
    LPCTSTR DeviceID,
    DWORD Flags,
    BOOL ShowDeviceTree
    )
{
    HPROPSHEETPAGE hPage;
    DWORD DiFlags;
    DWORD DiFlagsEx;

    //
    // Verify that a DeviceID was passed in unless they want to show the 
    // whole device tree.
    //
    if ((!DeviceID || (TEXT('\0') == *DeviceID))  && !ShowDeviceTree) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return -1;
    }

    //
    // Verify that valid flags are passed in
    //
    if (Flags &~ DEVPROP_BITS) {
        
        SetLastError(ERROR_INVALID_FLAGS);
        return -1;
    }

    if (ShowDeviceTree) {

        return PropertyRunDeviceTree(hwndParent, MachineName, DeviceID);
    }

    int Result = -1;

    CDeviceGeneralPage* pGenPage = NULL;
    CDeviceDriverPage*  pDrvPage = NULL;
    CDevice* pDevice;
    PVOID Context;

    try {

        CMachine TheMachine(MachineName);

        // create the machine just for this device
        if (!TheMachine.Initialize(hwndParent, DeviceID)) {

            return -1;
        }

        if (!TheMachine.GetFirstDevice(&pDevice, Context)) {

            SetLastError(SPAPI_E_NO_SUCH_DEVINST);
            return -1;
        }

        //
        // If the troubleshooter should be launched then set the appropriate
        // BOOL inside of the pDevice class.
        //
        if (Flags & DEVPROP_LAUNCH_TROUBLESHOOTER) {
        
            pDevice->m_bLaunchTroubleShooter = TRUE;
        }
        
        CPropSheetData& psd = pDevice->m_psd;

        //
        // Initialize CPropSheetData without ConsoleHandle
        //
        if (psd.Create(g_hInstance, hwndParent, MAX_PROP_PAGES, 0l)) {

            psd.m_psh.pszCaption = pDevice->GetDisplayName();

            //
            // Add any class/device specific property pages.
            //
            TheMachine.DiGetClassDevPropertySheet(*pDevice, &psd.m_psh,
                                                  MAX_PROP_PAGES,
                                                  TheMachine.IsLocal() ? 
                                                        DIGCDP_FLAG_ADVANCED :
                                                        DIGCDP_FLAG_REMOTE_ADVANCED);

            //
            // Add the general tab
            //
            DiFlags = TheMachine.DiGetFlags(*pDevice);
            DiFlagsEx = TheMachine.DiGetExFlags(*pDevice);

            if (DiFlags & DI_GENERALPAGE_ADDED) {

                TCHAR szText[MAX_PATH];

                LoadResourceString(IDS_GENERAL_PAGE_WARNING, szText,
                    ARRAYLEN(szText));

                MessageBox(hwndParent, szText, pDevice->GetDisplayName(),
                    MB_ICONEXCLAMATION | MB_OK);

                //
                // fall through to create our general page.
                //
            }

            SafePtr<CDeviceGeneralPage> GenPagePtr;
            CDeviceGeneralPage* pGeneralPage = new CDeviceGeneralPage();
            GenPagePtr.Attach(pGeneralPage);

            hPage = pGeneralPage->Create(pDevice);

            if (hPage) {

                if (psd.InsertPage(hPage, 0)) {

                    GenPagePtr.Detach();
                }

                else {

                    ::DestroyPropertySheetPage(hPage);
                }
            }

            //
            // Add the driver tab
            //
            if (!(DiFlags & DI_DRIVERPAGE_ADDED)) {

                SafePtr<CDeviceDriverPage> DrvPagePtr;
                CDeviceDriverPage* pDriverPage = new CDeviceDriverPage();
                DrvPagePtr.Attach(pDriverPage);

                hPage = pDriverPage->Create(pDevice);

                if (hPage) {

                    if (psd.InsertPage(hPage)) {

                        DrvPagePtr.Detach();
                    }

                    else {

                        ::DestroyPropertySheetPage(hPage);
                    }
                }
            }

            //
            // Add the resource tab
            //
            if ((Flags & DEVPROP_SHOW_RESOURCE_TAB) &&
                pDevice->HasResources() && 
                !(DiFlags & DI_RESOURCEPAGE_ADDED)) {

                TheMachine.DiGetExtensionPropSheetPage(*pDevice,
                        AddPageCallback,
                        SPPSR_SELECT_DEVICE_RESOURCES,
                        (LPARAM)&psd
                        );
            }

#ifndef _WIN64
            //
            // Add the power tab if this is the local machine
            //
            if (TheMachine.IsLocal() && !(DiFlagsEx & DI_FLAGSEX_POWERPAGE_ADDED)) 
            {
                //
                // Check if the device support power management
                //
                CPowerShutdownEnable ShutdownEnable;
                CPowerWakeEnable WakeEnable;
    
                if (ShutdownEnable.Open(pDevice->GetDeviceID()) || WakeEnable.Open(pDevice->GetDeviceID())) {
    
                    ShutdownEnable.Close();
                    WakeEnable.Close();
    
                    SafePtr<CDevicePowerMgmtPage> PowerMgmtPagePtr;
    
                    CDevicePowerMgmtPage* pPowerPage = new CDevicePowerMgmtPage;
                    PowerMgmtPagePtr.Attach(pPowerPage);
                    hPage = pPowerPage->Create(pDevice);
    
                    if (hPage) {
    
                        if (psd.InsertPage(hPage)) {
    
                            PowerMgmtPagePtr.Detach();
                        }
    
                        else {
    
                            ::DestroyPropertySheetPage(hPage);
                        }
                    }
                }
            }
#endif

            //
            // Add any Bus property pages if this is the local machine
            //
            if (TheMachine.IsLocal()) 
            {
                CBusPropPageProvider* pBusPropPageProvider = new CBusPropPageProvider();
                SafePtr<CBusPropPageProvider> ProviderPtr;
                ProviderPtr.Attach(pBusPropPageProvider);
    
                if (pBusPropPageProvider->EnumPages(pDevice, &psd)) {
    
                    psd.AddProvider(pBusPropPageProvider);
                    ProviderPtr.Detach();
                }
            }

            Result = (int)psd.DoSheet();

            if (-1 != Result) {

                if (TheMachine.DiGetExFlags(*pDevice) & DI_FLAGSEX_PROPCHANGE_PENDING) {


                    //
                    // property change pending, issue a DICS_PROPERTYCHANGE
                    // to the class installer
                    //
                    SP_PROPCHANGE_PARAMS pcp;
                    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
                    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;

                    pcp.Scope = DICS_FLAG_GLOBAL;
                    pcp.StateChange = DICS_PROPCHANGE;

                    TheMachine.DiSetClassInstallParams(*pDevice,
                            &pcp.ClassInstallHeader,
                            sizeof(pcp)
                            );

                    TheMachine.DiCallClassInstaller(DIF_PROPERTYCHANGE, *pDevice);
                    TheMachine.DiTurnOnDiFlags(*pDevice, DI_PROPERTIES_CHANGE);
                    TheMachine.DiTurnOffDiExFlags(*pDevice, DI_FLAGSEX_PROPCHANGE_PENDING);
                }

                //
                // Merge restart/reboot flags
                //
                DiFlags = TheMachine.DiGetFlags(*pDevice);

                if (DI_NEEDREBOOT & DiFlags) {

                    Result |= ID_PSREBOOTSYSTEM;
                }

                if (DI_NEEDRESTART & DiFlags) {

                    Result |= ID_PSRESTARTWINDOWS;
                }
            }
        }
    }

    catch (CMemoryException* e) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        e->Delete();
    }
    return -1;
}

STDAPI_(UINT)
DeviceProblemTextA(
    HMACHINE hMachine,
    DEVNODE DevNode,
    ULONG ProblemNumber,
    LPSTR   Buffer,
    UINT    BufferSize
    )
{
#ifndef UNICODE
    return GetDeviceProblemText(hMachine, DevNode, ProblemNumber, Buffer, BufferSize);
#else
    WCHAR* wchBuffer = NULL;
    UINT RealSize = 0;

    if (BufferSize && !Buffer)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    if (BufferSize)
    {
        try
        {
            wchBuffer = new WCHAR[BufferSize];
        }

        catch (CMemoryException* e)
        {
            e->Delete();
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return 0;
        }
    }

    RealSize = GetDeviceProblemText(hMachine, DevNode, ProblemNumber,
                    wchBuffer, BufferSize);
    if (RealSize && BufferSize > RealSize)
    {
        ASSERT(wchBuffer);
        RealSize = WideCharToMultiByte(CP_ACP, 0, wchBuffer, RealSize,
                        Buffer, BufferSize, NULL, NULL);
        
        Buffer[RealSize] = '\0';
    }

    if (wchBuffer)
    {
        delete wchBuffer;
    }

    return RealSize;

#endif
}

STDAPI_(UINT)
DeviceProblemTextW(
    HMACHINE hMachine,
    DEVNODE DevNode,
    ULONG ProblemNumber,
    LPWSTR Buffer,
    UINT   BufferSize
    )
{
#ifdef UNICODE
    return GetDeviceProblemText(hMachine, DevNode, ProblemNumber,
                Buffer, BufferSize);
#else
    CHAR* chBuffer = NULL;
    UINT RealSize = 0;

    if (BufferSize && !Buffer)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    if (BufferSize)
    {
        try
        {
            chBuffer = new CHAR[BufferSize];
        }

        catch (CMemoryException* e)
        {
            e->Delete();
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return 0;
        }
    }

    RealSize = GetDeviceProblemText(hMachine, DevNode, ProblemNumber,
                    chBuffer, BufferSize);
    if (RealSize && BufferSize > RealSize)
    {
        ASSERT(chBuffer);
        RealSize = MultiByteToWideChar((CP_ACP, 0, chBuffer, RealSize,
                        Buffer, BufferSize);
        Buffer[RealSize] = UNICODE_NULL;
    }

    if (chBuffer)
    {
        delete chBuffer;
    }

    return RealSize;

#endif
}

int
PropertyRunDeviceTree(
    HWND hwndParent,
    LPCTSTR MachineName,
    LPCTSTR DeviceID
    )
{

    SHELLEXECUTEINFOW sei;
    TCHAR MachineOptions[MAX_PATH];
    TCHAR DeviceIdOptions[MAX_PATH*2];
    TCHAR CommandOptions[MAX_PATH];
    TCHAR Parameters[MAX_PATH * 3];
    TCHAR* FilePart;
    DWORD Size;
    
    Size = SearchPath(NULL, DEVMGR_MSC_FILE, NULL, MAX_PATH, Parameters, &FilePart);
    
    if (!Size || Size >=MAX_PATH)
    {
        lstrcpy(Parameters, DEVMGR_MSC_FILE);
    }

    lstrcat(Parameters, MMC_COMMAND_LINE);

    if (MachineName)
    {
        wsprintf(MachineOptions, DEVMGR_MACHINENAME_OPTION, MachineName);
            lstrcat(Parameters, MachineOptions);
    }

    if (DeviceID)
    {
        wsprintf(DeviceIdOptions, DEVMGR_DEVICEID_OPTION, DeviceID);
        wsprintf(CommandOptions, DEVMGR_COMMAND_OPTION, DEVMGR_CMD_PROPERTY);
        lstrcat(Parameters, DeviceIdOptions);
        lstrcat(Parameters, CommandOptions);
    }

    // no deviceid, no command.
    memset(&sei, 0, sizeof(sei));
    sei.cbSize = sizeof(sei);
    sei.hwnd = hwndParent;
    sei.nShow = SW_NORMAL;
    sei.hInstApp = g_hInstance;
    sei.lpFile = MMC_FILE;
    sei.fMask = SEE_MASK_NOCLOSEPROCESS;
    sei.lpParameters = Parameters;
    
    if (ShellExecuteEx(&sei) && sei.hProcess)
    {
        WaitForSingleObject(sei.hProcess, INFINITE);
        return 1;
    }

    return 0;
}

STDAPI_(void)
DeviceProblenWizard_RunDLLA(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPSTR lpCmdLine,
    int   nCmdShow
    )
{

    try
    {
        CTString tstrCmdLine(lpCmdLine);
    
        DeviceProblenWizard_RunDLL(hwndStub, 
                                   hAppInstance,
                                   (LPCTSTR)tstrCmdLine,   
                                   nCmdShow
                                   );
    }

    catch (CMemoryException* e)
    {
        e->ReportError();
        e->Delete();
    }
}

STDAPI_(void)
DeviceProblenWizard_RunDLLW(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPWSTR lpCmdLine,
    int    nCmdShow
    )
{
    try
    {
        CTString tstrCmdLine(lpCmdLine);
    
        DeviceProblenWizard_RunDLL(hwndStub, 
                                   hAppInstance,
                                   (LPCTSTR)tstrCmdLine, 
                                   nCmdShow
                                   );
    }

    catch (CMemoryException* e)
    {
        e->ReportError();
        e->Delete();
    }
}

void
DeviceProblenWizard_RunDLL(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPCTSTR lpCmdLine,
    int    nCmdShow
    )
{
    try
    {
        CRunDLLCommandLine CmdLine;
        CmdLine.ParseCommandLine(lpCmdLine);
    
        if (NULL == CmdLine.GetD