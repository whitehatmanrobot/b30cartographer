Cache;
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTSession::Create
//
//  Synopsis:   Static function used to create a Session object. This
//              will be called by EnumSessions::Next
//
//  Arguments:  [ppWinNTSession] -- Ptr to a ptr to a new Session object.
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12-11-95 RamV   Created.
//
//----------------------------------------------------------------------------


HRESULT
CWinNTSession::Create(LPTSTR pszServerADsPath,
                      LPTSTR pszClientName,
                      LPTSTR pszUserName,
                      DWORD  dwObject,
                      REFIID riid,
                      CWinNTCredentials& Credentials,
                      LPVOID * ppvoid
                      )

{

    CWinNTSession FAR * pCWinNTSession = NULL;
    HRESULT hr;
    TCHAR szSessionName[MAX_PATH];

    //
    // Create the Session Object
    //

    hr = AllocateSessionObject(pszServerADsPath,
                               pszClientName,
                               pszUserName,
                               &pCWinNTSession);

    BAIL_IF_ERROR(hr);

    ADsAssert(pCWinNTSession->_pDispMgr);


    wcscpy(szSessionName, pszUserName);
    wcscat(szSessionName, TEXT("\\"));
    wcscat(szSessionName, pszClientName);

    hr = pCWinNTSession->InitializeCoreObject(pszServerADsPath,
                                              szSessionName,
                                              SESSION_CLASS_NAME,
                                              SESSION_SCHEMA_NAME,
                                              CLSID_WinNTSession,
                                              dwObject);

    BAIL_IF_ERROR(hr);

    pCWinNTSession->_Credentials = Credentials;
    hr = pCWinNTSession->_Credentials.RefServer(
        pCWinNTSession->_pszServerName);
    BAIL_IF_ERROR(hr);

    if( pszUserName && *pszUserName ) {
        hr = SetLPTSTRPropertyInCache(pCWinNTSession->_pPropertyCache,
                                      TEXT("User"),
                                      pszUserName,
                                      TRUE
                                      );
        BAIL_IF_ERROR(hr);
    }

    hr = SetLPTSTRPropertyInCache(pCWinNTSession->_pPropertyCache,
                                  TEXT("Computer"),
                                  pCWinNTSession->_pszComputerName,
                                  TRUE
                                  );
    BAIL_IF_ERROR(hr);


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                SESSION_CLASS_NAME,
                (IADs *) pCWinNTSession,
                pCWinNTSession->_pDispMgr,
                Credentials,
                &pCWinNTSession->_pExtMgr
                );
    BAIL_IF_ERROR(hr);

    ADsAssert(pCWinNTSession->_pExtMgr);

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        // Session objects have "" as their ADsPath. Just set the class for
        // identification purposes.
        pCWinNTSession->_CompClasses[0] = L"Session";

        hr = pCWinNTSession->InitUmiObject(
                pCWinNTSession->_Credentials,
                SessionClass,
                gdwSessionTableSize,
                pCWinNTSession->_pPropertyCache,
                (IUnknown *)(INonDelegatingUnknown *) pCWinNTSession,
                pCWinNTSession->_pExtMgr,
                IID_IUnknown,
                ppvoid
                );

        BAIL_IF_ERROR(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pCWinNTSession->QueryInterface(riid,
                                        (void **)ppvoid);
    BAIL_IF_ERROR(hr);

    pCWinNTSession->Release();

cleanup:

    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }

    delete pCWinNTSession;
    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CWinNTSession::AllocateSessionObject(LPTSTR pszServerADsPath,
                                     LPTSTR pszClientName,
                                     LPTSTR pszUserName,
                                     CWinNTSession ** ppSession
                                     )
{
    CWinNTSession FAR * pCWinNTSession = NULL;
    HRESULT hr = S_OK;
    POBJECTINFO pServerObjectInfo = NULL;

    pCWinNTSession = new CWinNTSession();
    if (pCWinNTSession == NULL) {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCWinNTSession->_pDispMgr = new CAggregatorDispMgr;
    if (pCWinNTSession->_pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    hr = LoadTypeInfoEntry(pCWinNTSession->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsSession,
                           (IADsSession *)pCWinNTSession,
                           DISPID_REGULAR);
    BAIL_IF_ERROR(hr);

    pCWinNTSession->_pszServerADsPath
        = AllocADsStr(pszServerADsPath);

    if(!pCWinNTSession->_pszServerADsPath){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo);
    BAIL_IF_ERROR(hr);

    pCWinNTSession->_pszServerName =
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if(!pCWinNTSession->_pszServerADsPath){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    if(pszClientName){

        pCWinNTSession->_pszComputerName = AllocADsStr(pszClientName);
        if(!pCWinNTSession->_pszComputerName){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
    }

    if(pszUserName){
        pCWinNTSession->_pszUserName = AllocADsStr(pszUserName);
        if(!pCWinNTSession->_pszUserName){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
    }

    hr = CPropertyCache::createpropertycache(
             SessionClass,
             gdwSessionTableSize,
             (CCoreADsObject *)pCWinNTSession,
             &(pCWinNTSession->_pPropertyCache)
             );

    BAIL_IF_ERROR(hr);

    (pCWinNTSession->_pDispMgr)->RegisterPropertyCache(
                pCWinNTSession->_pPropertyCache
                );

    *ppSession = pCWinNTSession;


cleanup:

    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }

    if (!SUCCEEDED(hr)) {

        //
        // direct memeber assignement assignement at pt of creation, so
        // do NOT delete _pPropertyCache or _pDisMgr here to avoid attempt
        // of deletion again in pPrintJob destructor and AV
        //

        delete pCWinNTSession;
    }

    RRETURN(hr);

}




/* IUnknown methods for session object  */

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTSession::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTSession::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTSession::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTSession::NonDelegatingQueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hr = S_OK;

    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADs *) this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADs *)this;
    }
    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADs FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsSession))
    {
        *ppvObj = (IADsSession FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(riid, IID_IADsExtension) )
    {
        *ppvObj = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTSession::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsSession) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */


//+-----------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:   SetInfo on actual session
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    02/08/96    RamV  Created

//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTSession::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTSession::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{
    HRESULT hr;
    hr = GetLevel_1_Info(fExplicit);
    RRETURN_EXP_IF_ERR(hr);
}



STDMETHODIMP
CWinNTSession::GetInfo(THIS)
{

    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(1, TRUE));
}

STDMETHODIMP
CWinNTSession::ImplicitGetInfo(THIS)
{

    RRETURN(GetInfo(1, FALSE));
}

//
// helper functions for GetInfo
//

STDMETHODIMP
CWinNTSession::GetLevel_1_Info(THIS_ BOOL fExplicit)
{
    NET_API_STATUS nasStatus;
    LPSESSION_INFO_1 lpSessionInfo =NULL;
    HRESULT hr;
    TCHAR szUncServerName[MAX_PATH];
    TCHAR szUncClientName[MAX_PATH];

    //
    // Level 1 info
    //

    hr = MakeUncName(_pszServerName, szUncServerName);
    BAIL_IF_ERROR(hr);

    hr = MakeUncName(_pszComputerName, szUncClientName);
    BAIL_IF_ERROR(hr);

    nasStatus = NetSessionGetInfo(szUncServerName,
                                  szUncClientName,
                                  _pszUserName,
                                  1,
                                  (LPBYTE *)&lpSessionInfo);

    if (nasStatus != NERR_Success || !lpSessionInfo){
        hr = HRESULT_FROM_WIN32(nasStatus);
        goto cleanup;
    }

    //
    // unmarshall the info
    //

    ADsAssert(lpSessionInfo);



    if( _pszUserName && *_pszUserName ) {
        hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                      TEXT("User"),
                                      _pszUserName,
                                      fExplicit
                                      );
    }



    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Computer"),
                                  _pszComputerName,
                                  fExplicit
                                  );


    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                 TEXT("ConnectTime"),
                                 lpSessionInfo->sesi1_time,
                                 fExplicit
                                 );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                 TEXT("IdleTime"),
                                 lpSessionInfo->sesi1_idle_time,
                                 fExplicit
                                 );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );

    hr = S_OK;

cleanup:
    if(lpSessionInfo)
        NetApiBufferFree(lpSessionInfo);
    RRETURN(hr);

}

STDMETHODIMP
CWinNTSession::get_User(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    //
    // UserName is set once and never modified,
    //

    if(!retval){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }
    hr = ADsAllocString(_pszUserName, retval);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CWinNTSession::get_UserPath(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTSession::get_Computer(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    //
    // Computer name is set once and never modified,
    //
    if(!retval){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    hr = ADsAllocString(_pszComputerName, retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTSession::get_ComputerPath(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTSession::get_ConnectTime(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsSession *)this, ConnectTime);
}

STDMETHODIMP
CWinNTSession::get_IdleTime(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsSession *)this, IdleTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cuar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuar.cxx
//
//  Contents:  Account Restrictions Propset for the User object
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//
//        PROPERTY_RW(AccountDisabled, boolean, 1)              I
//        PROPERTY_RW(AccountExpirationDate, DATE, 2)           I
//        PROPERTY_RO(AccountCanExpire, boolean, 3)             I
//        PROPERTY_RO(PasswordCanExpire, boolean, 4)            I
//        PROPERTY_RW(GraceLoginsAllowed, long, 5)              NI
//        PROPERTY_RW(GraceLoginsRemaining, long, 6)            NI
//        PROPERTY_RW(IsAccountLocked, boolean, 7)              I
//        PROPERTY_RW(IsAdmin, boolean, 8)                      I
//        PROPERTY_RW(LoginHours, VARIANT, 9)                   I
//        PROPERTY_RW(LoginWorkstations, VARIANT, 10)           I
//        PROPERTY_RW(MaxLogins, long, 11)                      I
//        PROPERTY_RW(MaxStorage, long, 12)                     I
//        PROPERTY_RW(PasswordExpirationDate, DATE, 13)         I
//        PROPERTY_RW(PasswordRequired, boolean, 14)            I
//        PROPERTY_RW(RequireUniquePassword,boolean, 15)        I
//
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


//  Class CWinNTUser

STDMETHODIMP
CWinNTUser::get_AccountDisabled(THIS_ VARIANT_BOOL FAR* retval)
{
   HRESULT hr = S_OK;
   VARIANT var;

   VariantInit(&var);
   hr = Get(L"UserFlags", &var);
   BAIL_ON_FAILURE(hr);

   if (V_I4(&var) & UF_ACCOUNTDISABLE) {

       *retval = VARIANT_TRUE;
   }else {
       *retval = VARIANT_FALSE;
   }

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUser::put_AccountDisabled(THIS_ VARIANT_BOOL fAccountDisabled)
{
   HRESULT hr = S_OK;
   VARIANT var;

   VariantInit(&var);
   hr = Get(L"UserFlags", &var);
   BAIL_ON_FAILURE(hr);

   if (fAccountDisabled == VARIANT_TRUE) {

       V_I4(&var) |= UF_ACCOUNTDISABLE;
   } else if (fAccountDisabled == VARIANT_FALSE){

       V_I4(&var) &=  ~UF_ACCOUNTDISABLE;
   }else {
       BAIL_ON_FAILURE(hr = E_FAIL);
   }

   hr = Put(L"UserFlags", var);
   BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTUser::get_AccountExpirationDate(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, AccountExpirationDate);
}

STDMETHODIMP
CWinNTUser::put_AccountExpirationDate(THIS_ DATE daAccountExpirationDate)
{
    PUT_PROPERTY_DATE((IADsUser *)this, AccountExpirationDate);
}

STDMETHODIMP
CWinNTUser::get_GraceLoginsAllowed(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, GraceLoginsAllowed);
}


STDMETHODIMP
CWinNTUser::put_GraceLoginsAllowed(THIS_ long lGraceLoginsAllowed)
{
    PUT_PROPERTY_LONG((IADsUser *)this, GraceLoginsAllowed);
}

STDMETHODIMP
CWinNTUser::get_GraceLoginsRemaining(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, GraceLoginsRemaining);
}

STDMETHODIMP
CWinNTUser::put_GraceLoginsRemaining(THIS_ long lGraceLoginsRemaining)
{
    PUT_PROPERTY_LONG((IADsUser *)this, GraceLoginsRemaining);
}

STDMETHODIMP
CWinNTUser::get_IsAccountLocked(THIS_ VARIANT_BOOL FAR* retval)
{

   HRESULT hr = S_OK;
   DWORD dwUserFlags =  0;
   VARIANT var;

   if(_fUseCacheForAcctLocked) {
   // see comment on _fUseCacheForAcctLocked in cuser.hxx
       VariantInit(&var);
       hr = Get(L"UserFlags", &var);
       BAIL_ON_FAILURE(hr);

       if (V_I4(&var) & UF_LOCKOUT) {

           *retval = VARIANT_TRUE;
       }else {
           *retval = VARIANT_FALSE;
       }
    }
    else {
       hr = GetUserFlags(&dwUserFlags);
       BAIL_ON_FAILURE(hr);

       VariantInit(&var);
       hr = Get(L"UserFlags", &var);
       BAIL_ON_FAILURE(hr);

       if (dwUserFlags & UF_LOCKOUT) {
           V_I4(&var) |= UF_LOCKOUT;
           *retval = VARIANT_TRUE;
       } 
       else {
           V_I4(&var) &=  ~UF_LOCKOUT;
           *retval = VARIANT_FALSE;
       }

       hr = Put(L"UserFlags", var);
       BAIL_ON_FAILURE(hr);

       _fUseCacheForAcctLocked = TRUE;
    }

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUser::put_IsAccountLocked(THIS_ VARIANT_BOOL fIsAccountLocked)
{
   HRESULT hr = S_OK;
   VARIANT var;

   VariantInit(&var);
   hr = Get(L"UserFlags", &var);
   BAIL_ON_FAILURE(hr);

   if (fIsAccountLocked == VARIANT_TRUE) {
   // only the system can lockout an account. Can't do it using ADSI.
       BAIL_ON_FAILURE(hr = E_INVALIDARG);

   } else if (fIsAccountLocked == VARIANT_FALSE){

       V_I4(&var) &=  ~UF_LOCKOUT;
   }else {
       BAIL_ON_FAILURE(hr = E_FAIL);
   }

   hr = Put(L"UserFlags", var);
   BAIL_ON_FAILURE(hr);

   _fUseCacheForAcctLocked = TRUE;

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUser::get_LoginHours(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this,LoginHours);
}

STDMETHODIMP
CWinNTUser::put_LoginHours(THIS_ VARIANT vLoginHours)
{

    PUT_PROPERTY_VARIANT((IADsUser *)this,LoginHours);
}

STDMETHODIMP
CWinNTUser::get_LoginWorkstations(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this,LoginWorkstations);
}


STDMETHODIMP
CWinNTUser::put_LoginWorkstations(THIS_ VARIANT vLoginWorkstations)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this,LoginWorkstations);
}

STDMETHODIMP
CWinNTUser::get_MaxLogins(THIS_ long FAR* retval)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTUser::put_MaxLogins(THIS_ long lMaxLogins)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTUser::get_MaxStorage(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, MaxStorage);
}


STDMETHODIMP
CWinNTUser::put_MaxStorage(THIS_ long lMaxStorage)
{
    PUT_PROPERTY_LONG((IADsUser *)this, MaxStorage);
}

STDMETHODIMP
CWinNTUser::get_PasswordExpirationDate(THIS_ DATE FAR* retval)
{
   HRESULT hr = S_OK;
   VARIANT var;
   SYSTEMTIME SystemTime;
   SYSTEMTIME LocalTime;
   FILETIME FileTime;
   DWORD dwCurrentTime = 0L;
   DWORD dwLastMod = 0L;
   DWORD dwPasswordAge = 0L;
   DWORD dwMaxPasswordAge = 0L;
   DWORD dwPasswordExpDate = 0L;


   VariantInit(&var);
   hr = Get(L"PasswordAge", &var);
   BAIL_ON_FAILURE(hr);
   dwPasswordAge = V_I4(&var);

   VariantInit(&var);
   hr = Get(L"MaxPasswordAge", &var);
   BAIL_ON_FAILURE(hr);

   dwMaxPasswordAge = V_I4(&var);
   LARGE_INTEGER Time;


   GetSystemTime(&SystemTime);

   SystemTimeToFileTime(&SystemTime, &FileTime);

   memset(&Time, 0, sizeof(LARGE_INTEGER));

   Time.LowPart = FileTime.dwLowDateTime;
   Time.HighPart = FileTime.dwHighDateTime
   ;

   RtlTimeToSecondsSince1970 ((PLARGE_INTEGER)&Time, &dwCurrentTime);

   dwLastMod = dwCurrentTime - dwPasswordAge;

   if (dwMaxPasswordAge == TIMEQ_FOREVER) {
       BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
   }else {
       dwPasswordExpDate = dwLastMod + dwMaxPasswordAge;
   }

   hr = ConvertDWORDtoDATE( dwPasswordExpDate, retval);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUser::put_PasswordExpirationDate(THIS_ DATE daPasswordExpirationDate)
{
    PUT_PROPERTY_DATE((IADsUser *)this, PasswordExpirationDate);
}

STDMETHODIMP
CWinNTUser::get_PasswordRequired(THIS_ VARIANT_BOOL FAR* retval)
{
   HRESULT hr = S_OK;
   long lnUserFlags =  0L;
   VARIANT var;


   VariantInit(&var);
   hr = Get(L"UserFlags", &var);
   BAIL_ON_FAILURE(hr);

   if (V_I4(&var) & UF_PASSWD_NOTREQD) {

       *retval = VARIANT_FALSE;
   }else {
       *retval = VARIANT_TRUE;
   }

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUser::put_PasswordRequired(THIS_ VARIANT_BOOL fPasswordRequired)
{
   HRESULT hr = S_OK;
   VARIANT var;

   VariantInit(&var);
   hr = Get(L"UserFlags", &var);
   BAIL_ON_FAILURE(hr);

   if (fPasswordRequired == VARIANT_TRUE) {

       V_I4(&var) &= ~UF_PASSWD_NOTREQD;
   } else if (fPasswordRequired == VARIANT_FALSE){

       V_I4(&var) |= UF_PASSWD_NOTREQD;
   }else {
       BAIL_ON_FAILURE(hr = E_FAIL);
   }

   hr = Put(L"UserFlags", var);
   BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUser::get_PasswordMinimumLength(THIS_ LONG FAR* retval)
{

   HRESULT hr = S_OK;
   VARIANT varTemp;

   hr = Get(L"MinPasswordLength", &varTemp);
   BAIL_ON_FAILURE(hr);

   *retval = V_I4(&varTemp);

error:

  RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUser::put_PasswordMinimumLength(THIS_ LONG lPasswordMinimumLength)
{
    VARIANT varTemp;
    HRESULT hr;

    VariantInit(&varTemp);
    V_VT(&varTemp) = VT_I4;
    V_I4(&varTemp) = lPasswordMinimumLength;

    hr = Put(L"MinPasswordLength", varTemp);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUser::get_RequireUniquePassword(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, RequireUniquePassword);
}

STDMETHODIMP
CWinNTUser::put_RequireUniquePassword(THIS_ VARIANT_BOOL fRequireUniquePassword)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, RequireUniquePassword);
}


STDMETHODIMP
CWinNTUser::SetPassword(THIS_ BSTR NewPassword)
{
    NET_API_STATUS nasStatus;
    LPUSER_INFO_2 lpUserInfo2 = NULL;
    HRESULT hr;
    WCHAR szHostServerName[MAX_PATH];
    DWORD dwParmErr = 0;
    WCHAR szBuffer[MAX_PATH];

    //
    // objects associated with invalid SIDs have neither a
    // corresponding server nor domain
    //
    if ((!_DomainName) && (!_ServerName)) {
        BAIL_ON_FAILURE(hr = E_ADS_INVALID_USER_OBJECT);
    }


    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        // We want to set the password in this case
        // This is to allow the creation of users when there
        // is a restriction such as new user should have passwd.
        hr = setPrivatePassword(NewPassword);

        RRETURN(hr);
    }

    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = WinNTGetCachedDCName(
                        _DomainName,
                        szHostServerName,
                        _Credentials.GetFlags()
                        );
        BAIL_ON_FAILURE(hr);

    }else {
        hr = MakeUncName(
               _ServerName,
               szHostServerName
               );
        BAIL_ON_FAILURE(hr);

    }

    nasStatus = NetUserGetInfo(
                    szHostServerName,
                    _Name,
                    2,
                    (LPBYTE *)&lpUserInfo2
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

    lpUserInfo2->usri2_password = NewPassword;

    nasStatus = NetUserSetInfo(
                    szHostServerName,
                    _Name,
                    2,
                    (LPBYTE)lpUserInfo2,
                    &dwParmErr
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);


error:
    if (lpUserInfo2) {
        NetApiBufferFree(lpUserInfo2);
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUser::ChangePassword(THIS_ BSTR bstrOldPassword, BSTR bstrNewPassword)
{
    NET_API_STATUS nasStatus;
    LPBYTE lpBuffer = NULL;
    HRESULT hr;
    WCHAR szHostServerName[MAX_PATH];

    //
    // objects associated with invalid SIDs have neither a
    // corresponding server nor domain
    //
    if ((!_DomainName) && (!_ServerName)) {
        BAIL_ON_FAILURE(hr = E_ADS_INVALID_USER_OBJECT);
    }


    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = WinNTGetCachedDCName(
                    _DomainName,
                    szHostServerName,
                    _Credentials.GetFlags()
                    );
        BAIL_ON_FAILURE(hr);

    }else {

        hr = MakeUncName(
               _ServerName,
               szHostServerName
               );
        BAIL_ON_FAILURE(hr);
    }

    nasStatus = NetUserChangePassword(
                        szHostServerName,
                        _Name,
                        bstrOldPassword,
                        bstrNewPassword
                        );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);


error:

    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cschema.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cschema.cxx
//
//  Contents:  Windows NT 3.51
//
//
//  History:   01-09-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop



/******************************************************************/
/*  Class CWinNTSchema
/******************************************************************/

DEFINE_IDispatch_Delegating_Implementation(CWinNTSchema)
DEFINE_IADsExtension_Implementation(CWinNTSchema)
DEFINE_IADs_Implementation(CWinNTSchema)

CWinNTSchema::CWinNTSchema()
{
    VariantInit( &_vFilter );

    ENLIST_TRACKING(CWinNTSchema);
}

CWinNTSchema::~CWinNTSchema()
{
    VariantClear( &_vFilter );
    delete _pDispMgr;
}

HRESULT
CWinNTSchema::CreateSchema(
    BSTR   bstrParent,
    BSTR   bstrName,
    DWORD  dwObjectState,
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTSchema FAR *pSchema = NULL;
    HRESULT hr = S_OK;

    hr = AllocateSchemaObject( &pSchema );
    BAIL_ON_FAILURE(hr);

    hr = pSchema->InitializeCoreObject(
             bstrParent,
             bstrName,
             SCHEMA_CLASS_NAME,
             NO_SCHEMA,
             CLSID_WinNTSchema,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    pSchema->_Credentials = Credentials;

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(2 == pSchema->_dwNumComponents) {
            pSchema->_CompClasses[0] = L"Computer";
            pSchema->_CompClasses[1] = L"Schema";
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pSchema->InitUmiObject(
             pSchema->_Credentials,
             SchemaClass,
             g_dwSchemaClassTableSize,
             NULL,
             (IUnknown *) (INonDelegatingUnknown *) pSchema,
             NULL,
             IID_IUnknown,
             ppvObj
             );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pSchema->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pSchema->Release();

    RRETURN(hr);

error:

    delete pSchema;
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTSchema::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTSchema::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTSchema::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTSchema::NonDelegatingQueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *)this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *)this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(iid, IID_IADsExtension) )
    {
        *ppv = (IADsExtension *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTSchema::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CWinNTSchema::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTSchema::GetInfo(THIS)
{
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTSchema::ImplicitGetInfo(THIS)
{
    RRETURN(S_OK);
}

/* IADsContainer methods */

STDMETHODIMP
CWinNTSchema::get_Count(long FAR* retval)
{
    HRESULT hr;

    if ( !retval )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *retval = g_cWinNTClasses + g_cWinNTSyntax;
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTSchema::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    if ( !pVar )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    VariantInit( pVar );
    hr = VariantCopy( pVar, &_vFilter );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTSchema::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy( &_vFilter, &Var );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTSchema::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTSchema::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}

STDMETHODIMP
CWinNTSchema::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject)
{
    TCHAR szBuffer[MAX_PATH];
    DWORD dwLength = 0;
    HRESULT hr = S_OK;

    if (!RelativeName || !*RelativeName) {
        RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }

    //
    // Make sure we are not going to overflow the string buffer.
    // +2 for / and \0
    //
    dwLength = wcslen(_ADsPath) + wcslen(RelativeName) + 2;

    if (dwLength > MAX_PATH) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    wcscpy(szBuffer, _ADsPath);

    wcscat(szBuffer, L"/");
    wcscat(szBuffer, RelativeName);

    if (ClassName) {
        //
        // +1 for the ",".
        //
        dwLength += wcslen(ClassName) + 1;
        if (dwLength > MAX_PATH) {
            BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
        }
        wcscat(szBuffer,L",");
        wcscat(szBuffer, ClassName);
    }

    hr = ::GetObject(szBuffer, (LPVOID *)ppObject, _Credentials);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTSchema::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IEnumVARIANT *penum = NULL;

    if ( !retval )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *retval = NULL;

    //
    // Create new enumerator for items currently
    // in collection and QI for IUnknown
    //

    hr = CWinNTSchemaEnum::Create( (CWinNTSchemaEnum **)&penum,
                                   _ADsPath,
                                   _Name,
                                   _vFilter,
                                   _Credentials);
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface( IID_IUnknown, (VOID FAR* FAR*)retval );
    BAIL_ON_FAILURE(hr);

    if ( penum )
        penum->Release();

    RRETURN(hr);

error:

    if ( penum )
        delete penum;

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTSchema::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTSchema::Delete(THIS_ BSTR SourceName, BSTR Type)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTSchema::CopyHere(THIS_ BSTR SourceName,
                       BSTR NewName,
                       IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTSchema::MoveHere(THIS_ BSTR SourceName,
                       BSTR NewName,
                       IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CWinNTSchema::AllocateSchemaObject(CWinNTSchema FAR * FAR * ppSchema)
{
    CWinNTSchema FAR *pSchema = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSchema = new CWinNTSchema();
    if ( pSchema == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pSchema,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADsContainer,
                            (IADsContainer *) pSchema,
                            DISPID_NEWENUM );
    BAIL_ON_FAILURE(hr);

    pSchema->_pDispMgr = pDispMgr;
    *ppSchema = pSchema;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pSchema;

    RRETURN_EXP_IF_ERR(hr);

}


/******************************************************************/
/*  Class CWinNTClass
/******************************************************************/

DEFINE_IDispatch_Delegating_Implementation(CWinNTClass)
DEFINE_IADsExtension_Implementation(CWinNTClass)
DEFINE_IADs_Implementation(CWinNTClass)

CWinNTClass::CWinNTClass()
    : _pDispMgr( NULL ),
      _aPropertyInfo( NULL ),
      _cPropertyInfo( 0 ),
      _bstrCLSID( NULL ),
      _bstrOID( NULL ),
      _bstrPrimaryInterface( NULL ),
      _fAbstract( FALSE ),
      _fContainer( FALSE ),
      _bstrHelpFileName( NULL ),
      _lHelpFileContext( 0 )
{
    VariantInit( &_vMandatoryProperties );
    VariantInit( &_vOptionalProperties );
    VariantInit( &_vPossSuperiors );
    VariantInit( &_vContainment );
    VariantInit( &_vFilter );

    ENLIST_TRACKING(CWinNTClass);
}

CWinNTClass::~CWinNTClass()
{

    if ( _bstrCLSID ) {
        ADsFreeString( _bstrCLSID );
    }

    if ( _bstrOID ) {
        ADsFreeString( _bstrOID );
    }

    if ( _bstrPrimaryInterface ) {
        ADsFreeString( _bstrPrimaryInterface );
    }

    if ( _bstrHelpFileName ) {
        ADsFreeString( _bstrHelpFileName );
    }

    VariantClear( &_vMandatoryProperties );
    VariantClear( &_vOptionalProperties );
    VariantClear( &_vPossSuperiors );
    VariantClear( &_vContainment );
    VariantClear( &_vFilter );

    delete _pDispMgr;
}

HRESULT
CWinNTClass::CreateClass(
    BSTR   bstrParent,
    CLASSINFO *pClassInfo,
    DWORD  dwObjectState,
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTClass FAR *pClass = NULL;
    HRESULT hr = S_OK;
    BSTR bstrTmp = NULL;

    hr = AllocateClassObject( &pClass );
    BAIL_ON_FAILURE(hr);

    pClass->_aPropertyInfo = pClassInfo->aPropertyInfo;
    pClass->_cPropertyInfo = pClassInfo->cPropertyInfo;
    pClass->_lHelpFileContext = pClassInfo->lHelpFileContext;
    pClass->_fContainer = (VARIANT_BOOL)pClassInfo->fContainer;
    pClass->_fAbstract = (VARIANT_BOOL)pClassInfo->fAbstract;

    hr = StringFromCLSID( (REFCLSID) *(pClassInfo->pPrimaryInterfaceGUID),
                          &bstrTmp );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrTmp,
                           &pClass->_bstrPrimaryInterface);
    BAIL_ON_FAILURE(hr);

    CoTaskMemFree(bstrTmp);
    bstrTmp = NULL;

    hr = StringFromCLSID( (REFCLSID) *(pClassInfo->pCLSID),
                           &bstrTmp );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrTmp,
                           &pClass->_bstrCLSID );

    BAIL_ON_FAILURE(hr);

    CoTaskMemFree(bstrTmp);
    bstrTmp = NULL;

    hr = ADsAllocString( pClassInfo->bstrOID, &pClass->_bstrOID);
    BAIL_ON_FAILURE(hr);

    hr = MakeVariantFromStringList( pClassInfo->bstrMandatoryProperties,
                                    &(pClass->_vMandatoryProperties));
    BAIL_ON_FAILURE(hr);


    hr = MakeVariantFromStringList( pClassInfo->bstrOptionalProperties,
                                    &(pClass->_vOptionalProperties));
    BAIL_ON_FAILURE(hr);


    hr = MakeVariantFromStringList( pClassInfo->bstrPossSuperiors,
                                    &(pClass->_vPossSuperiors));
    BAIL_ON_FAILURE(hr);

    hr = MakeVariantFromStringList( pClassInfo->bstrContainment,
                                    &(pClass->_vContainment));
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( pClassInfo->bstrHelpFileName,
                           &pClass->_bstrHelpFileName);
    BAIL_ON_FAILURE(hr);

    hr = pClass->InitializeCoreObject(
             bstrParent,
             pClassInfo->bstrName,
             CLASS_CLASS_NAME,
             NO_SCHEMA,
             CLSID_WinNTClass,
             dwObjectState );

    BAIL_ON_FAILURE(hr);

    pClass->_Credentials = Credentials;

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(3 == pClass->_dwNumComponents) {
            pClass->_CompClasses[0] = L"Computer";
            pClass->_CompClasses[1] = L"Schema";
            pClass->_CompClasses[2] = L"Class";
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pClass->InitUmiObject(
             pClass->_Credentials,
             SchClassClass,
             g_dwSchClassClassTableSize,
             NULL,
             (IUnknown *)(INonDelegatingUnknown *) pClass,
             NULL,
             IID_IUnknown,
             ppvObj,
             pClassInfo
             );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }
 
    hr = pClass->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pClass->Release();

    RRETURN(hr);

error:
    if ( bstrTmp != NULL )
        CoTaskMemFree(bstrTmp);

    delete pClass;
    RRETURN_EXP_IF_ERR(hr);
}

// called by implicit GetInfo from property cache
STDMETHODIMP
CWinNTClass::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTClass::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTClass::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTClass::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTClass::NonDelegatingQueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsClass FAR * ) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *)this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsClass))
    {
        *ppv = (IADsClass FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(iid, IID_IADsExtension) )
    {
        *ppv = (IADsExtension *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTClass::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsClass)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CWinNTClass::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTClass::GetInfo(THIS)
{
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTClass::ImplicitGetInfo(THIS)
{
    RRETURN(S_OK);
}

/* IADsClass methods */

STDMETHODIMP
CWinNTClass::get_PrimaryInterface( THIS_ BSTR FAR *pbstrGUID )
{
    HRESULT hr;
    if ( !pbstrGUID )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrPrimaryInterface, pbstrGUID );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTClass::get_CLSID( THIS_ BSTR FAR *pbstrCLSID )
{
    HRESULT hr;
    if ( !pbstrCLSID )
        RRETURN(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrCLSID, pbstrCLSID );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTClass::put_CLSID( THIS_ BSTR bstrCLSID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::get_OID( THIS_ BSTR FAR *pbstrOID )
{
    HRESULT hr;
    if ( !pbstrOID )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrOID, pbstrOID );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTClass::put_OID( THIS_ BSTR bstrOID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::get_Abstract( THIS_ VARIANT_BOOL FAR *pfAbstract )
{
    if ( !pfAbstract )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *pfAbstract = _fAbstract? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTClass::put_Abstract( THIS_ VARIANT_BOOL fAbstract )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::get_Auxiliary( THIS_ VARIANT_BOOL FAR *pfAuxiliary)
{
    if ( !pfAuxiliary )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *pfAuxiliary = VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTClass::put_Auxiliary( THIS_ VARIANT_BOOL fAuxiliary )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::get_MandatoryProperties( THIS_ VARIANT FAR *pvMandatoryProperties )
{
    HRESULT hr;
    VariantInit( pvMandatoryProperties );
    hr = VariantCopy( pvMandatoryProperties, &_vMandatoryProperties );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTClass::put_MandatoryProperties( THIS_ VARIANT vMandatoryProperties )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::get_DerivedFrom( THIS_ VARIANT FAR *pvDerivedFrom )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::put_DerivedFrom( THIS_ VARIANT vDerivedFrom )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::get_AuxDerivedFrom( THIS_ VARIANT FAR *pvAuxDerivedFrom )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::put_AuxDerivedFrom( THIS_ VARIANT vAuxDerivedFrom )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::get_PossibleSuperiors( THIS_ VARIANT FAR *pvPossSuperiors )
{
    HRESULT hr;
    VariantInit( pvPossSuperiors );
    hr = VariantCopy( pvPossSuperiors, &_vPossSuperiors );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTClass::put_PossibleSuperiors( THIS_ VARIANT vPossSuperiors )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::get_Containment( THIS_ VARIANT FAR *pvContainment )
{
    HRESULT hr;
    VariantInit( pvContainment );
    hr = VariantCopy( pvContainment, &_vContainment );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTClass::put_Containment( THIS_ VARIANT vContainment )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::get_Container( THIS_ VARIANT_BOOL FAR *pfContainer )
{
    if ( !pfContainer )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *pfContainer = _fContainer? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTClass::put_Container( THIS_ VARIANT_BOOL fContainer )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::get_HelpFileName( THIS_ BSTR FAR *pbstrHelpFileName )
{
    HRESULT hr;
    if ( !pbstrHelpFileName )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrHelpFileName, pbstrHelpFileName );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTClass::put_HelpFileName( THIS_ BSTR bstrHelpFile )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::get_HelpFileContext( THIS_ long FAR *plHelpContext )
{
    if ( !plHelpContext )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plHelpContext = _lHelpFileContext;
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTClass::put_HelpFileContext( THIS_ long lHelpContext )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CWinNTClass::AllocateClassObject(CWinNTClass FAR * FAR * ppClass)
{

    CWinNTClass FAR  *pClass = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pClass = new CWinNTClass();
    if ( pClass == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pClass,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADsClass,
                            (IADsClass *) pClass,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    pClass->_pDispMgr = pDispMgr;
    *ppClass = pClass;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pClass;

    RRETURN(hr);

}


/******************************************************************/
/*  Class CWinNTProperty
/******************************************************************/

DEFINE_IDispatch_Delegating_Implementation(CWinNTProperty)
DEFINE_IADsExtension_Implementation(CWinNTProperty)
DEFINE_IADs_Implementation(CWinNTProperty)

CWinNTProperty::CWinNTProperty()
    : _pDispMgr( NULL ),
      _bstrOID( NULL ),
      _bstrSyntax( NULL ),
      _lMaxRange( 0 ),
      _lMinRange( 0 ),
      _fMultiValued( FALSE )
{

    ENLIST_TRACKING(CWinNTProperty);
}

CWinNTProperty::~CWinNTProperty()
{

    if ( _bstrOID ) {
        ADsFreeString( _bstrOID );
    }

    if ( _bstrSyntax ) {
        ADsFreeString( _bstrSyntax );
    }

    delete _pDispMgr;
}

HRESULT
CWinNTProperty::CreateProperty(
    BSTR   bstrParent,
    PROPERTYINFO *pPropertyInfo,
    DWORD  dwObjectState,
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTProperty FAR * pProperty = NULL;
    HRESULT hr = S_OK;

    hr = AllocatePropertyObject( &pProperty );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( pPropertyInfo->bstrOID, &pProperty->_bstrOID);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( pPropertyInfo->bstrSyntax, &pProperty->_bstrSyntax);
    BAIL_ON_FAILURE(hr);

    pProperty->_lMaxRange = pPropertyInfo->lMaxRange;
    pProperty->_lMinRange = pPropertyInfo->lMinRange;
    pProperty->_fMultiValued  = (VARIANT_BOOL)pPropertyInfo->fMultiValued;

    hr = pProperty->InitializeCoreObject(
             bstrParent,
             pPropertyInfo->szPropertyName,
             PROPERTY_CLASS_NAME,
             NO_SCHEMA,
             CLSID_WinNTProperty,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    pProperty->_Credentials = Credentials;

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(3 == pProperty->_dwNumComponents) {
            pProperty->_CompClasses[0] = L"Computer";
            pProperty->_CompClasses[1] = L"Schema";
            pProperty->_CompClasses[2] = L"Property";
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pProperty->InitUmiObject(
             pProperty->_Credentials,
             PropertyClass,
             g_dwPropertyClassTableSize,
             NULL,
             (IUnknown *)(INonDelegatingUnknown *) pProperty,
             NULL,
             IID_IUnknown,
             ppvObj
             );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pProperty->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pProperty->Release();

    RRETURN(hr);

error:

    delete pProperty;
    RRETURN_EXP_IF_ERR(hr);
}

// called by implicit GetInfo from property cache
STDMETHODIMP
CWinNTProperty::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTProperty::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTProperty::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTProperty::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTProperty::NonDelegatingQueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *)this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsProperty))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(iid, IID_IADsExtension) )
    {
        *ppv = (IADsExtension *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTProperty::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsProperty)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CWinNTProperty::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTProperty::GetInfo(THIS)
{
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTProperty::ImplicitGetInfo(THIS)
{
    RRETURN(S_OK);
}

/* IADsProperty methods */


STDMETHODIMP
CWinNTProperty::get_OID( THIS_ BSTR FAR *pbstrOID )
{
    HRESULT hr;
    if ( !pbstrOID )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrOID, pbstrOID );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTProperty::put_OID( THIS_ BSTR bstrOID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTProperty::get_Syntax( THIS_ BSTR FAR *pbstrSyntax )
{
    HRESULT hr;
    if ( !pbstrSyntax )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrSyntax, pbstrSyntax );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTProperty::put_Syntax( THIS_ BSTR bstrSyntax )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTProperty::get_MaxRange( THIS_ long FAR *plMaxRange )
{
    if ( !plMaxRange )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plMaxRange = _lMaxRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTProperty::put_MaxRange( THIS_ long lMaxRange )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTProperty::get_MinRange( THIS_ long FAR *plMinRange )
{
    if ( !plMinRange )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plMinRange = _lMinRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTProperty::put_MinRange( THIS_ long lMinRange )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTProperty::get_MultiValued( THIS_ VARIANT_BOOL FAR *pfMultiValued )
{
    if ( !pfMultiValued )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *pfMultiValued = _fMultiValued? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTProperty::put_MultiValued( THIS_ VARIANT_BOOL fMultiValued )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTProperty::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CWinNTProperty::AllocatePropertyObject(CWinNTProperty FAR * FAR * ppProperty)
{
    CWinNTProperty FAR *pProperty = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pProperty = new CWinNTProperty();
    if ( pProperty == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pProperty,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADsProperty,
                            (IADsProperty *) pProperty,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    pProperty->_pDispMgr = pDispMgr;
    *ppProperty = pProperty;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pProperty;

    RRETURN(hr);

}


/******************************************************************/
/*  Class CWinNTSyntax
/******************************************************************/

DEFINE_IDispatch_Delegating_Implementation(CWinNTSyntax)
DEFINE_IADsExtension_Implementation(CWinNTSyntax)
DEFINE_IADs_Implementation(CWinNTSyntax)

CWinNTSyntax::CWinNTSyntax()
{
    ENLIST_TRACKING(CWinNTSyntax);
}

CWinNTSyntax::~CWinNTSyntax()
{
    delete _pDispMgr;
}

HRESULT
CWinNTSyntax::CreateSyntax(
    BSTR   bstrParent,
    SYNTAXINFO *pSyntaxInfo,
    DWORD  dwObjectState,
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTSyntax FAR *pSyntax = NULL;
    HRESULT hr = S_OK;

    hr = AllocateSyntaxObject( &pSyntax );
    BAIL_ON_FAILURE(hr);

    hr = pSyntax->InitializeCoreObject(
             bstrParent,
             pSyntaxInfo->bstrName,
             SYNTAX_CLASS_NAME,
             NO_SCHEMA,
             CLSID_WinNTSyntax,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    pSyntax->_lOleAutoDataType = pSyntaxInfo->lOleAutoDataType;

    pSyntax->_Credentials = Credentials;

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(3 == pSyntax->_dwNumComponents) {
            pSyntax->_CompClasses[0] = L"Computer";
            pSyntax->_CompClasses[1] = L"Schema";
            pSyntax->_CompClasses[2] = L"Syntax";
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pSyntax->InitUmiObject(
             pSyntax->_Credentials,
             SyntaxClass,
             g_dwSyntaxTableSize,
             NULL,
             (IUnknown *)(INonDelegatingUnknown *) pSyntax,
             NULL,
             IID_IUnknown,
             ppvObj
             );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pSyntax->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pSyntax->Release();

    RRETURN(hr);

error:

    delete pSyntax;
    RRETURN_EXP_IF_ERR(hr);
}

// called by implicit GetInfo from property cache
STDMETHODIMP
CWinNTSyntax::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTSyntax::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTSyntax::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTSyntax::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTSyntax::NonDelegatingQueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsSyntax))
    {
        *ppv = (IADsSyntax FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(iid, IID_IADsExtension) )
    {
        *ppv = (IADsExtension *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTSyntax::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsSyntax)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CWinNTSyntax::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTSyntax::GetInfo(THIS)
{
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTSyntax::ImplicitGetInfo(THIS)
{
    RRETURN(S_OK);
}

HRESULT
CWinNTSyntax::AllocateSyntaxObject(CWinNTSyntax FAR * FAR * ppSyntax)
{
    CWinNTSyntax FAR *pSyntax = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSyntax = new CWinNTSyntax();
    if ( pSyntax == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADsSyntax,
                            (IADsSyntax *) pSyntax,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    pSyntax->_pDispMgr = pDispMgr;
    *ppSyntax = pSyntax;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pSyntax;

    RRETURN(hr);

}

STDMETHODIMP
CWinNTSyntax::get_OleAutoDataType( THIS_ long FAR *plOleAutoDataType )
{
    if ( !plOleAutoDataType )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plOleAutoDataType = _lOleAutoDataType;
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTSyntax::put_OleAutoDataType( THIS_ long lOleAutoDataType )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}


/******************************************************************/
/*  Misc Helpers
/******************************************************************/

HRESULT
MakeVariantFromStringList(
    BSTR bstrList,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    BSTR pszTempList = NULL;

    if ( bstrList != NULL )
    {
        long i = 0;
        long nCount = 1;
        TCHAR c;
        BSTR pszSrc;

        hr = ADsAllocString( bstrList, &pszTempList );
        BAIL_ON_FAILURE(hr);

        while ( c = pszTempList[i] )
        {
            if ( c == TEXT(','))
            {
                pszTempList[i] = 0;
                nCount++;
            }

            i++;
        }

        aBound.lLbound = 0;
        aBound.cElements = nCount;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pszSrc = pszTempList;

        for ( i = 0; i < nCount; i++ )
        {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;

            hr = ADsAllocString( pszSrc, &(V_BSTR(&v)));
            BAIL_ON_FAILURE(hr);

            hr = SafeArrayPutElement( aList,
                                      &i,
                                      &v );
            VariantClear(&v);
            BAIL_ON_FAILURE(hr);

            pszSrc += _tcslen( pszSrc ) + 1;
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;

        ADsFreeString( pszTempList );
        pszTempList = NULL;

    }
    else
    {
        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;
    }

    RRETURN(S_OK);

error:

    if ( pszTempList )
        ADsFreeString( pszTempList );

    if ( aList )
        SafeArrayDestroy( aList );

    return hr;
}


STDMETHODIMP
CWinNTClass::get_OptionalProperties( THIS_ VARIANT FAR *retval )
{
    HRESULT hr;
    VariantInit( retval );
    hr = VariantCopy( retval, &_vOptionalProperties );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTClass::put_OptionalProperties( THIS_ VARIANT vOptionalProperties )
{

    HRESULT hr = E_NOTIMPL;

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTClass::get_NamingProperties( THIS_ VARIANT FAR *retval )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTClass::put_NamingProperties( THIS_ VARIANT vNamingProperties )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cubi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cubi.cxx
//
//  Contents:
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//      PROPERTY_RW(Address, VARIANT, 1)                NI
//      PROPERTY_RW(Department, BSTR, 3)                NI
//      PROPERTY_RW(Division, BSTR, 5)                  NI
//      PROPERTY_RW(EmployeeID, BSTR, 6)                NI
//      PROPERTY_RW(FaxNumber, BSTR, 7)                 NI
//      PROPERTY_RW(FirstName, BSTR, 8)                 Implemented
//      PROPERTY_RW(FullName, BSTR, 9)                  NI
//      PROPERTY_RW(Initials, BSTR, 10)                 NI
//      PROPERTY_RW(LastName, BSTR, 11)                 NI
//      PROPERTY_RW(Manager, BSTR, 12)                  NI
//      PROPERTY_RW(NickName, BSTR, 13)                 NI
//      PROPERTY_RW(OfficeLocation, BSTR, 14)           NI
//      PROPERTY_RW(Picture, VARIANT, 51)               NI
//      PROPERTY_RW(TelephoneHome, VARIANT, 18)         NI
//      PROPERTY_RW(TelephoneMobile, VARIANT, 19)       NI
//      PROPERTY_RW(TelephoneNumber, VARIANT, 20)       NI
//      PROPERTY_RW(FaxNumber, VARIANT, 2)              NI
//      PROPERTY_RW(Title, BSTR, 19)
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


STDMETHODIMP
CWinNTUser::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Description);
}

STDMETHODIMP
CWinNTUser::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Description);
}

STDMETHODIMP
CWinNTUser::get_Department(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Department);
}

STDMETHODIMP
CWinNTUser::put_Department(THIS_ BSTR bstrDepartment)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Department);
}

STDMETHODIMP
CWinNTUser::get_Division(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Division);
}

STDMETHODIMP
CWinNTUser::put_Division(THIS_ BSTR bstrDivision)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Division);
}

STDMETHODIMP
CWinNTUser::get_EmployeeID(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, EmployeeID);
}

STDMETHODIMP
CWinNTUser::put_EmployeeID(THIS_ BSTR bstrEmployeeID)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, EmployeeID);
}


STDMETHODIMP
CWinNTUser::get_FirstName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, FirstName);
}

STDMETHODIMP
CWinNTUser::put_FirstName(THIS_ BSTR bstrFirstName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, FirstName);
}

STDMETHODIMP
CWinNTUser::get_FullName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, FullName);
}

STDMETHODIMP
CWinNTUser::put_FullName(THIS_ BSTR bstrFullName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, FullName);
}

STDMETHODIMP
CWinNTUser::get_LastName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, LastName);
}

STDMETHODIMP
CWinNTUser::put_LastName(THIS_ BSTR bstrLastName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, LastName);
}

STDMETHODIMP
CWinNTUser::get_Manager(THIS_ BSTR FAR* retval)
{
     GET_PROPERTY_BSTR((IADsUser *)this, Manager);
}

STDMETHODIMP
CWinNTUser::put_Manager(THIS_ BSTR bstrManager)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Manager);
}

STDMETHODIMP
CWinNTUser::get_OfficeLocations(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, OfficeLocation);
}

STDMETHODIMP
CWinNTUser::put_OfficeLocations(THIS_ VARIANT vOfficeLocation)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, OfficeLocation);
}

STDMETHODIMP
CWinNTUser::get_Picture(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, Picture);
}

STDMETHODIMP
CWinNTUser::put_Picture(THIS_ VARIANT vPicture)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, Picture);
}

STDMETHODIMP
CWinNTUser::get_PostalAddresses(THIS_ VARIANT FAR* retval)
{
   GET_PROPERTY_VARIANT((IADsUser *)this, PostalAddresses);
}

STDMETHODIMP
CWinNTUser::put_PostalAddresses(THIS_ VARIANT vPostalAddresses)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, PostalAddresses);
}

STDMETHODIMP
CWinNTUser::get_PostalCodes(THIS_ VARIANT FAR* retval)
{
   GET_PROPERTY_VARIANT((IADsUser *)this, PostalCodes);
}

STDMETHODIMP
CWinNTUser::put_PostalCodes(THIS_ VARIANT vPostalCodes)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, PostalCodes);
}

STDMETHODIMP
CWinNTUser::get_TelephoneNumber(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephoneNumber);
}

STDMETHODIMP
CWinNTUser::put_TelephoneNumber(THIS_ VARIANT vTelephoneNumber)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, TelephoneNumber);
}

STDMETHODIMP
CWinNTUser::get_TelephoneHome(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephoneHome);
}

STDMETHODIMP
CWinNTUser::put_TelephoneHome(THIS_ VARIANT vTelephoneHome)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, TelephoneHome);
}

STDMETHODIMP
CWinNTUser::get_TelephoneMobile(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephoneMobile);
}

STDMETHODIMP
CWinNTUser::put_TelephoneMobile(THIS_ VARIANT vTelephoneMobile)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, TelephoneMobile);
}

STDMETHODIMP
CWinNTUser::get_TelephonePager(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephonePager);
}

STDMETHODIMP
CWinNTUser::put_TelephonePager(THIS_ VARIANT vTelephonePager)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, TelephonePager);
}

STDMETHODIMP
CWinNTUser::get_FaxNumber(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, FaxNumber);
}

STDMETHODIMP
CWinNTUser::put_FaxNumber(THIS_ VARIANT vFaxNumber)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, FaxNumber);
}

STDMETHODIMP
CWinNTUser::get_Title(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Title);
}

STDMETHODIMP
CWinNTUser::put_Title(THIS_ BSTR bstrTitle)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Title);
}

STDMETHODIMP CWinNTUser::get_HomePage(THIS_ BSTR FAR* retval)
{

    GET_PROPERTY_BSTR((IADsUser *)this,HomePage);
}
STDMETHODIMP CWinNTUser::put_HomePage(THIS_ BSTR bstrHomePage)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, HomePage);
}

STDMETHODIMP CWinNTUser::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, SeeAlso);
}
STDMETHODIMP CWinNTUser::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{

    PUT_PROPERTY_VARIANT((IADsUser *)this, SeeAlso);
}

STDMETHODIMP CWinNTUser::get_NamePrefix(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, NamePrefix);
}
STDMETHODIMP CWinNTUser::put_NamePrefix(THIS_ BSTR bstrNamePrefix)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, NamePrefix);
}
STDMETHODIMP CWinNTUser::get_NameSuffix(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, NameSuffix);
}

STDMETHODIMP CWinNTUser::put_NameSuffix(THIS_ BSTR bstrNamePrefix)
{
    PUT_PROPERTY_BSTR((IADsUser *)this,NamePrefix);
}

STDMETHODIMP CWinNTUser::get_OtherName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, OtherName);
}
STDMETHODIMP CWinNTUser::put_OtherName(THIS_ BSTR bstrOtherName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, OtherName);
}

STDMETHODIMP
CWinNTUser::Groups(THIS_ IADsMembers FAR* FAR* ppGroups)
{
    HRESULT hr;
    WCHAR szHostServerName[MAX_PATH];

    //
    // objects associated with invalid SIDs have neither a
    // corresponding server nor domain
    //
    if ((!_DomainName) && (!_ServerName)) {
        BAIL_ON_FAILURE(hr = E_ADS_INVALID_USER_OBJECT);
    }


    if (_ParentType == WINNT_DOMAIN_ID) {
        hr = WinNTGetCachedDCName(
                    _DomainName,
                    szHostServerName,
                    _Credentials.GetFlags()  
                    );
        BAIL_ON_FAILURE(hr);
    }

    hr = CWinNTUserGroupsCollection::CreateUserGroupsCollection(
                    _ParentType,
                    _Parent,
                    _DomainName,

                    _ParentType == WINNT_DOMAIN_ID ?
                    (szHostServerName + 2) :
                    _ServerName,

                    _Name,
                    IID_IADsMembers,
                    _Credentials,
                    (void **)ppGroups
        );

error:

    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cuas.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuas.cxx
//
//  Contents:  User Object Account Statistics FunctionalSet
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//
//
//    PROPERTY_RO(AccountExpiration, DATE, 1)       Implemented
//    PROPERTY_RO(BadLoginAddress, BSTR, 2)         NI
//    PROPERTY_RO(BadLoginCount, long, 3)           NI
//    PROPERTY_RO(BadPasswordAttempts, long, 4)     Implemented
//    PROPERTY_RO(LastLogin, DATE, 5)               Implemented
//    PROPERTY_RO(LastLogoff, DATE, 6)              Implemented
//    PROPERTY_RO(LastFailedLogin, DATE, 7)         NI
//    PROPERTY_RO(PasswordLastChanged, DATE, 8)     Implemented
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


//  Class CWinNTUser

STDMETHODIMP CWinNTUser::get_BadLoginAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, BadLoginAddress);
}

STDMETHODIMP CWinNTUser::get_BadLoginCount(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, BadLoginCount);
}

STDMETHODIMP CWinNTUser::get_LastLogin(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, LastLogin);
}

STDMETHODIMP CWinNTUser::get_LastLogoff(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, LastLogoff);
}

STDMETHODIMP CWinNTUser::get_LastFailedLogin(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, LastFailedLogin);
}

STDMETHODIMP CWinNTUser::get_PasswordLastChanged(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, PasswordLastChanged);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cumiprop.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     cumiprop.cxx
//
//  Contents: Contains the property list implementation for UMI. This will
//            be used for both interface properties and object properties. 
//
//  History:  02-28-00    SivaramR  Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"

//----------------------------------------------------------------------------
// Function:   CUmiPropList 
//
// Synopsis:   Constructor. Stores off schema (list of available properties,
//             their types etc.) and the size of the schema. 
//
// Arguments:  Self explanatory
//
// Returns:    Nothing 
//
// Modifies:   Nothing 
//
//----------------------------------------------------------------------------
CUmiPropList::CUmiPropList(PPROPERTYINFO pSchema, DWORD dwSchemaSize)
{
    m_pSchema = pSchema;
    m_dwSchemaSize = dwSchemaSize;
    m_pPropCache = NULL;
    m_fIsIntfPropObj = TRUE; 
    m_ulErrorStatus = 0;
    m_pszSchema = NULL;
    m_pClassInfo = NULL;
    m_fIsNamespaceObj = FALSE;
    m_fIsClassObj = FALSE;
    m_fDisableWrites = FALSE;
    m_ppszUnImpl = NULL;
}

//----------------------------------------------------------------------------
// Function:   CUmiPropList
//
// Synopsis:   Constructor. Stores off schema (list of available properties,
//             their types etc.) and the size of the schema.
//
// Arguments:  Self explanatory
//
// Returns:    Nothing
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
CUmiPropList::~CUmiPropList(void)
{
    if( (m_pPropCache != NULL) && (TRUE == m_fIsIntfPropObj) )
        delete m_pPropCache;

    if(m_pszSchema != NULL)
        FreeADsStr(m_pszSchema);

    return;
}

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   Queries property list object for supported interfaces. Only
//             IUmiPropList is supported.
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(NULL == ppInterface)
        RRETURN(E_INVALIDARG);

    *ppInterface = NULL;

    if(IsEqualIID(iid, IID_IUnknown))
        *ppInterface = (IUmiPropList *) this;
    else if(IsEqualIID(iid, IID_IUmiPropList))
        *ppInterface = (IUmiPropList *) this;
    else
         RRETURN(E_NOINTERFACE);

    AddRef();
    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
// Function:   FInit
// 
// Synopsis:   Initializes the property list object. 
//
// Arguments:
//
// pPropCache  Pointer to the property cache object. This argument will be
//             NULL if this object is for interface properties. In this case,
//             a new property cache is allocated by this function. If this
//             object is for object properties, then this argument points
//             to the property cache of the WinNT object.
// ppszUnImpl  Array of standard property names that are not implemented.
//             This is used on an interface property object to return E_NOTIMPL
//             as the error code.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::FInit(CPropertyCache *pPropCache, LPWSTR *ppszUnImpl)
{
    HRESULT hr = UMI_S_NO_ERROR;

    if(NULL == pPropCache) {
        hr = CPropertyCache::createpropertycache(
                m_pSchema,
                m_dwSchemaSize,
                NULL,    // this will ensure that the WinNT property cache
                         // won't do implicit GetInfo for interface properties
                &m_pPropCache);

        BAIL_ON_FAILURE(hr);

        m_ppszUnImpl = ppszUnImpl; 
    }
    else {
        m_fIsIntfPropObj = FALSE;
        m_pPropCache = pPropCache;
    }
       
    RRETURN(UMI_S_NO_ERROR);

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   SetLastStatus
//
// Synopsis:   Sets the status of the last operation. 
//
// Arguments:
//
// ulStatus    Status to be set
//
// Returns:    Nothing
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
void CUmiPropList::SetLastStatus(ULONG ulStatus)
{
    m_ulErrorStatus = ulStatus;

    return;
}

//----------------------------------------------------------------------------
// Function:   GetLastStatus
//
// Synopsis:   Returns status or error code from the last operation. Currently
//             only numeric status is returned i.e, no error objects are
//             returned. 
//
// Arguments:
//
// uFlags           Reserved. Must be 0 for now.
// puSpecificStatus Returns status code
// riid             IID requested. Ignored currently.
// pStatusObj       Returns interface requested. Always returns NULL currently.
//
// Returns:         UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:        *puSpecificStatus to return status code.
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::GetLastStatus(
    ULONG uFlags,
    ULONG *puSpecificStatus,
    REFIID riid,
    LPVOID *pStatusObj
    )
{
    if(pStatusObj != NULL)
       *pStatusObj = NULL;

    if(puSpecificStatus != NULL)
        *puSpecificStatus = 0;

    if(uFlags != 0)
        RRETURN(UMI_E_INVALID_FLAGS);

    if(NULL == puSpecificStatus)
        RRETURN(UMI_E_INVALIDARG);

    *puSpecificStatus = m_ulErrorStatus;

    RRETURN(UMI_S_NO_ERROR);
}

//----------------------------------------------------------------------------
// Function:   Put 
//
// Synopsis:   Implements IUmiPropList::Put. Writes a property into the cache. 
//
// Arguments: 
//
// pszName     Name of the property
// uFlags      Flags for the Put operation. Unused currently.
// pProp       Pointer to the structure containing the value 
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise. 
//
// Modifies:   Nothing. 
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::Put( 
    LPCWSTR pszName,
    ULONG uFlags,
    UMI_PROPERTY_VALUES *pProp
    )
{
    HRESULT      hr = UMI_S_NO_ERROR;
    DWORD        dwSyntaxId  = 0, dwIndex = 0;
    UMI_PROPERTY *pPropArray = NULL;
    LPNTOBJECT   pNtObject = NULL;
    BOOL         fMarkAsClean = FALSE;

    SetLastStatus(0);

    // fail if we have disabled writes
    if( (TRUE == m_fDisableWrites) && (TRUE == m_fIsIntfPropObj) )
        BAIL_ON_FAILURE(hr = UMI_E_READ_ONLY); 

    // check args
    hr = ValidatePutArgs(
            pszName,
            uFlags,
            pProp
            );
    BAIL_ON_FAILURE(hr);

    // is this a standard interface property that's not implemented?
    if(m_ppszUnImpl != NULL) {
        while(m_ppszUnImpl[dwIndex] != NULL) {
            if(0 == _wcsicmp(m_ppszUnImpl[dwIndex], pszName)) {
                BAIL_ON_FAILURE(hr = UMI_E_NOTIMPL);
            }
            dwIndex++;
        }
    }

    // check if the property is in the schema
    hr = ValidatePropertyinSchemaClass(
            m_pSchema,
            m_dwSchemaSize,
            (LPWSTR) pszName,
            &dwSyntaxId
            );
    BAIL_ON_FAILURE(hr);
    
    // check if the property is writeable. Do this only if the flags are not
    // set to UMI_INTERNAL_FLAG_MARK_AS_CLEAN. Otherwise, the call is from
    // Clone() and we want read-only attributes to be succesfully copied
    // into the cloned object's cache. This requires that the check below
    // for writeable properties should be skipped.
    if(uFlags != UMI_INTERNAL_FLAG_MARK_AS_CLEAN) {
        hr = ValidateIfWriteableProperty(
            m_pSchema,
            m_dwSchemaSize,
            (LPWSTR) pszName
            );
        BAIL_ON_FAILURE(hr);
    }

    pPropArray = pProp->pPropArray; 

    // convert UMI data into format that can be stored in the cache
    hr = UmiToWinNTType(
            dwSyntaxId,
            pPropArray,
            &pNtObject
            );
    BAIL_ON_FAILURE(hr);

    // Find the property in the cache. If it doesn't exist, add it.
    hr = m_pPropCache->findproperty((LPWSTR) pszName, &dwIndex);
    if(FAILED(hr))
    {
        hr = m_pPropCache->addproperty(
                 (LPWSTR) pszName,
                 dwSyntaxId,
                 pPropArray->uCount,
                 pNtObject
                 );
        BAIL_ON_FAILURE(hr);
    }

    if(UMI_INTERNAL_FLAG_MARK_AS_CLEAN == uFlags)
        fMarkAsClean = TRUE;

    // Update property in cache
    hr = m_pPropCache->putproperty(
                 (LPWSTR) pszName,
                 dwSyntaxId,
                 pPropArray->uCount,
                 pNtObject,
                 fMarkAsClean
                 );
    BAIL_ON_FAILURE(hr);

error:

    if(pNtObject)
        NTTypeFreeNTObjects(pNtObject, pPropArray->uCount);

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}
    
//----------------------------------------------------------------------------
// Function:   ValidatePutArgs
//
// Synopsis:   Checks if the arguments to Put() are well-formed.
//
// Arguments:
//
// pszName     Name of the property
// uFlags      Flags for the Put operation. Unused currently.
// pProp       Pointer to the structure containing the value
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::ValidatePutArgs( 
    LPCWSTR pszName,
    ULONG uFlags,
    UMI_PROPERTY_VALUES *pProp
    )
{
    UMI_PROPERTY *pPropArray = NULL;

    if( (NULL == pszName) || (NULL == pProp) )
        RRETURN(UMI_E_INVALIDARG);

    if( (uFlags != 0) && (uFlags != UMI_INTERNAL_FLAG_MARK_AS_CLEAN) )
        RRETURN(UMI_E_INVALID_FLAGS);

    if(pProp->uCount != 1)    // cannot update multiple properties using Put()
        RRETURN(UMI_E_INVALIDARG);

    pPropArray = pProp->pPropArray;
    if(NULL == pPropArray)
        RRETURN(UMI_E_INVALIDARG);

    // WinNT provider supports only property update. Cannot append, clear etc.
    if(pPropArray->uOperationType != UMI_OPERATION_UPDATE)
        RRETURN(UMI_E_UNSUPPORTED_OPERATION);

    if(pPropArray->pszPropertyName &&
            _wcsicmp(pPropArray->pszPropertyName, pszName))
        RRETURN(UMI_E_INVALID_PROPERTY);

    if(NULL == pPropArray->pUmiValue)
        RRETURN(UMI_E_INVALIDARG);

    // all is well
    RRETURN(UMI_S_NO_ERROR);
}

//----------------------------------------------------------------------------
// Function:   Get
//
// Synopsis:   Implements IUmiPropList::Get. Reads a property from the cache.
//             Since the WinNT provider does not support incremental updates
//             using PutEx, Get() will never return
//             UMI_E_SYNCHRONIZATION_REQUIRED. If a property is modified in
//             cache, Get() returns the modified value from the cache, without
//             any error.
//
// Arguments:
//
// pszName     Name of the property
// uFlags      Flags for the Get operation. Unused currently.
// ppProp      Returns pointer to the structure containing the value
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *ppProp to return the address of UMI_PROPERT_VALUES structure.
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::Get(
    LPCWSTR pszName,
    ULONG uFlags,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    RRETURN( GetHelper(
                pszName,
                uFlags,
                ppProp,
                UMI_TYPE_NULL, // no-op
                FALSE          // not an internal call to GetHelper()
                ));
}

//----------------------------------------------------------------------------
// Function:   GetAs
//
// Synopsis:   Implements IUmiPropList::GetAs. Reads a property from the cache.
//             The data is converted to the type requested by the caller.
//             Since the WinNT provider does not support incremental updates
//             using PutEx, GetAs() will never return
//             UMI_E_SYNCHRONIZATION_REQUIRED. If a property is modified in
//             cache, GetAs() returns the modified value from the cache, without
//             any error. This method is not supported for interface properties.
//
// Update:     This method will not be supported on WinNT provider.
//
// Arguments:
//
// pszName       Name of the property
// uFlags        Flags for the GetAs operation. Unused currently.
// uCoercionType UMI type to convert the data to.
// ppProp        Returns pointer to the structure containing the value
//
// Returns:      UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:     *ppProp to return the address of UMI_PROPERT_VALUES structure.
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::GetAs(
    LPCWSTR pszName,
    ULONG uFlags,
    ULONG uCoercionType,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    SetLastStatus(UMI_E_NOTIMPL);
    RRETURN(UMI_E_NOTIMPL);

    SetLastStatus(0);

    if(TRUE == m_fIsIntfPropObj) 
    // GetAs is only supported for object properties

        RRETURN(UMI_E_UNSUPPORTED_OPERATION);

    RRETURN( GetHelper(
                pszName,
                uFlags,
                ppProp,
                (UMI_TYPE) uCoercionType,
                FALSE,     // not an internal call to GetHelper()
                TRUE 
                ));
}

//----------------------------------------------------------------------------
// Function:   GetHelper
//
// Synopsis:   Implements  a helper function for Get() and GetAs().
//             Since the WinNT provider does not support incremental updates
//             using PutEx, Get()/GetAs() will never return 
//             UMI_E_SYNCHRONIZATION_REQUIRED. If a property is modified in
//             cache, Get()/GetAs() returns the modified value from the cache,
//             wthout any error.
//
// Arguments:
//
// pszName     Name of the property
// uFlags      Flags for the Get operation.
// ppProp      Returns pointer to the structure containing the value
// UmiDstType  UMI type to convert the NT value to. Used only by GetAs()
// fInternal   Flag to indicate if the call is through Get()/GetAs() or if it
//             is an internal call to this function from UMI.  Difference is
//             that internal calls can read passwords from the cache.
// fIsGetAs    Flag to indicate if the caller is GetAs (in which case
//             UmiType is used). FALSE by default.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *ppProp to return the address of UMI_PROPERT_VALUES structure. 
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::GetHelper(
    LPCWSTR pszName,
    ULONG uFlags,
    UMI_PROPERTY_VALUES **ppProp,
    UMI_TYPE UmiDstType,
    BOOL fInternal,
    BOOL fIsGetAs
    )
{
    HRESULT    hr = UMI_S_NO_ERROR;
    DWORD      dwSyntaxId = 0, dwNumValues = 0, dwIndex = 0;
    LPNTOBJECT pNtObject = NULL;
    UMI_TYPE   UmiType = UMI_TYPE_NULL;
    UMI_PROPERTY_VALUES *pProp = NULL;
    BOOL       fModified = FALSE;

    SetLastStatus(0);

    hr = ValidateGetArgs(
            pszName,
            uFlags,
            ppProp
            );
    BAIL_ON_FAILURE(hr);

    if(UMI_FLAG_PROPERTY_ORIGIN == uFlags) {
        hr = GetPropertyOrigin(pszName, ppProp);
        if(FAILED(hr))
            goto error;
        else
            RRETURN(UMI_S_NO_ERROR);
    }

    // is this a standard interface property that's not implemented?
    if(m_ppszUnImpl != NULL) {
        while(m_ppszUnImpl[dwIndex] != NULL) {
            if(0 == _wcsicmp(m_ppszUnImpl[dwIndex], pszName)) {
                BAIL_ON_FAILURE(hr = UMI_E_NOTIMPL);
            }
            dwIndex++;
        }
    }

    *ppProp = NULL;

    // __SCHEMA should return a IUmiObject pointer. This property is treated as
    // a special case since it is not actually retrieved from the property 
    // cache. This property will be requested only on an interface property 
    // object.
    if( (TRUE == m_fIsIntfPropObj) && 
        (0 == _wcsicmp((LPWSTR) pszName, TEXT(UMIOBJ_INTF_PROP_SCHEMA))) ) {
            hr = GetSchemaObject((LPWSTR) pszName, ppProp);
            BAIL_ON_FAILURE(hr);

            RRETURN(hr);
    }

    // make sure that passwords cannot be read by a user
    if( (TRUE == m_fIsIntfPropObj) && (FALSE == fInternal) && 
        (0 == _wcsicmp((LPWSTR) pszName, TEXT(CONN_INTF_PROP_PASSWORD))) )
 
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    // retrieve property from cache. This might result in an implicit GetInfo()
    // if this is for object properties. For, interface properties, there is
    // no implicit GetInfo().
    hr = m_pPropCache->getproperty(
            (LPWSTR) pszName,
            &dwSyntaxId,
            &dwNumValues,
            &pNtObject,
            &fModified
            ); 

    BAIL_ON_FAILURE(hr);

    // map the NT type to a UMI type
    if(dwSyntaxId >= g_dwNumNTTypes)
        BAIL_ON_FAILURE(hr = UMI_E_FAIL); // shouldn't happen

    if(FALSE == fIsGetAs) 
    // get the UMI type corresponding to this NT type
        UmiType = g_mapNTTypeToUmiType[dwSyntaxId];
    else
    // try to convert to the type specified by the caller
        UmiType = UmiDstType;

    // allocate structure to return values
    pProp = (UMI_PROPERTY_VALUES *) AllocADsMem(sizeof(UMI_PROPERTY_VALUES));
    if(NULL == pProp)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY); 
    memset(pProp, 0, sizeof(UMI_PROPERTY_VALUES));

    pProp->pPropArray = (UMI_PROPERTY *) AllocADsMem(sizeof(UMI_PROPERTY));
    if(NULL == pProp->pPropArray)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    memset(pProp->pPropArray, 0, sizeof(UMI_PROPERTY));

    hr = WinNTTypeToUmi(
            pNtObject,
            dwNumValues,
            pProp->pPropArray,
            NULL,   // provider should allocate memory
            0,
            UmiType
            );
    BAIL_ON_FAILURE(hr);

    // Get fetches only one property at a time
    pProp->uCount = 1;

    // Fill in remaining fields of UMI_PROPERTY
    if(TRUE == fModified) {
    // WinNT only allows updates
        if( (uFlags != UMI_FLAG_PROVIDER_CACHE) && 
            (FALSE == m_fIsIntfPropObj) ) {
        // need to return error since cache is dirty
            FreeMemory(0, pProp); // ignore error return
            pProp = NULL;
            BAIL_ON_FAILURE(hr = UMI_E_SYNCHRONIZATION_REQUIRED);
        }

        pProp->pPropArray->uOperationType = UMI_OPERATION_UPDATE;
    }
    else
        pProp->pPropArray->uOperationType = 0;

    // not critical if this memory allocation fails. Property name doesn't
    // have to be returned to the caller.
    pProp->pPropArray->pszPropertyName = AllocADsStr(pszName); 
   
    *ppProp = pProp;
 
error:

    if(pNtObject)
        NTTypeFreeNTObjects(pNtObject, dwNumValues);

    if(FAILED(hr)) {
        if(pProp != NULL) {
            if(pProp->pPropArray != NULL)
                FreeADsMem(pProp->pPropArray);

            FreeADsMem(pProp);
        }

        SetLastStatus(hr);
    }

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   ValidateGetArgs
//
// Synopsis:   Checks if the arguments to Get() are well-formed.
//
// Arguments:
//
// pszName     Name of the property
// uFlags      Flags for the Put operation. 
// ppProp      Returns pointer to the structure containing the value
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::ValidateGetArgs(
    LPCWSTR pszName,
    ULONG uFlags,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    if( (NULL == pszName) || (NULL == ppProp) )
        RRETURN(UMI_E_INVALIDARG);

    // cannot combine UMI_FLAG_PROVIDER_CACHE and UMI_FLAG_PROPERTY_ORIGIN
    // since they are on the object property list and interface property list
    // respectively. So, don't need to AND with bitmasks to see if those flags
    // are set.
    if( (uFlags != 0) && (uFlags != UMI_FLAG_PROVIDER_CACHE) && 
        (uFlags != UMI_FLAG_PROPERTY_ORIGIN) )
        RRETURN(UMI_E_INVALID_FLAGS);

    if( (UMI_FLAG_PROVIDER_CACHE == uFlags) && (TRUE == m_fIsIntfPropObj) )
        RRETURN(UMI_E_INVALID_FLAGS);

    if(UMI_FLAG_PROPERTY_ORIGIN == uFlags) { 
    // can set this flag only on the interface property object of a class 
    // object.
        if( (FALSE == m_fIsIntfPropObj) || (NULL == m_pClassInfo) )
            RRETURN(UMI_E_INVALID_FLAGS);
    }

    // all is well
    RRETURN(UMI_S_NO_ERROR);
}

//----------------------------------------------------------------------------
// Function:   FreeMemory 
//
// Synopsis:   Implements IUmiPropList::FreeMemory. Frees a UMI_PROPERTY_VALUES
//             structure previously returned to the user. 
//
// Arguments:
//
// uReserved   Unused currently. 
// pMem        Pointer to UMI_PROPERTY_VALUES structure to be freed.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   Nothing
//
//---------------------------------------------------------------------------- 
HRESULT CUmiPropList::FreeMemory(
    ULONG uReserved,
    LPVOID pMem
    )
{
    UMI_PROPERTY_VALUES *pUmiPropVal = NULL;
    UMI_PROPERTY       *pPropArray = NULL;
    ULONG              i;
    LPWSTR             *pStrArray = NULL;
    UMI_OCTET_STRING   *pOctetStrArray = NULL;
    PUMI_COM_OBJECT    pUmiComObj = NULL;

    SetLastStatus(0);

    if( (NULL == pMem) || (uReserved != 0) ) {
        SetLastStatus(UMI_E_INVALIDARG);
        RRETURN(UMI_E_INVALIDARG);
    }

    // enclose in try/except to handle bad pointers sent in by caller
    __try {
        pUmiPropVal = (UMI_PROPERTY_VALUES *) pMem;

        for(i = 0; i < pUmiPropVal->uCount; i++) {
            pPropArray = pUmiPropVal->pPropArray + i;

            if(NULL == pPropArray)
                RRETURN(UMI_E_INVALID_POINTER);

            // GetProps returns a UMI_PROPERTY structure with just the
            // property name filled in and all other fields 0, when asked
            // for only property names.
            if(pPropArray->pszPropertyName != NULL)
            {
                FreeADsStr(pPropArray->pszPropertyName);
                pPropArray->pszPropertyName = NULL;
            }

            if(0 == pPropArray->uCount)
                continue;

            if(NULL == pPropArray->pUmiValue)
                RRETURN(UMI_E_INVALID_POINTER);
      
            // Free individual string values 
            if(UMI_TYPE_LPWSTR == pPropArray->uType) {
                pStrArray = pPropArray->pUmiValue->pszStrValue;
                for(i = 0; i < pPropArray->uCount; i++) {
                    if(pStrArray[i] != NULL) {
                        FreeADsStr(pStrArray[i]);                
                        pStrArray[i] = NULL;
                    }
                }
            }
            else if(UMI_TYPE_OCTETSTRING ==  pPropArray->uType) {
                pOctetStrArray = pPropArray->pUmiValue->octetStr;
                for(i = 0; i < pPropArray->uCount; i++) {
                    if(pOctetStrArray[i].lpValue != NULL) {
                        FreeADsMem(pOctetStrArray[i].lpValue);
                        pOctetStrArray[i].lpValue = NULL;
                    }
                }
            }
            else if(UMI_TYPE_IUNKNOWN == pPropArray->uType) {
                pUmiComObj = pPropArray->pUmiValue->comObject;
                for(i = 0; i < pPropArray->uCount; i++) {
                    if(pUmiComObj[i].priid != NULL) {
                        FreeADsMem(pUmiComObj[i].priid);
                        pUmiComObj[i].priid = NULL;
                    }
                    if(pUmiComObj[i].pInterface != NULL){
                        ((IUnknown *) pUmiComObj[i].pInterface)->Release();
                        pUmiComObj[i].pInterface = NULL;
                    }
                }
            }

            // Now free the UMI_VALUE structure
            FreeADsMem(pPropArray->pUmiValue);
            pPropArray->pUmiValue = NULL;
        } // for

        if(pUmiPropVal->pPropArray != NULL)
            FreeADsMem(pUmiPropVal->pPropArray);
        pUmiPropVal->pPropArray = NULL;

        FreeADsMem(pUmiPropVal);

    } __except( EXCEPTION_EXECUTE_HANDLER ) 

    {
        SetLastStatus(UMI_E_INTERNAL_EXCEPTION);

        RRETURN(UMI_E_INTERNAL_EXCEPTION);
    }

    RRETURN(UMI_S_NO_ERROR);
}

//----------------------------------------------------------------------------
// Function:   GetInterfacePropNames
//
// Synopsis:   Returns the names of all interface properties supported. 
//
// Arguments:
//
// pProps      Returns the names of the properties, without any data
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pProps to return the property names 
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::GetInterfacePropNames(
    UMI_PROPERTY_VALUES **pProps
    )
{
    UMI_PROPERTY_VALUES *pUmiPropVals = NULL;
    UMI_PROPERTY        *pUmiProps = NULL;
    HRESULT             hr = UMI_S_NO_ERROR;
    ULONG               ulIndex = 0, ulCount = 0;

    ADsAssert(pProps != NULL);
    ADsAssert(TRUE == m_fIsIntfPropObj);

    pUmiPropVals = (UMI_PROPERTY_VALUES *) AllocADsMem(
                          sizeof(UMI_PROPERTY_VALUES));
    if(NULL == pUmiPropVals)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    memset(pUmiPropVals, 0, sizeof(UMI_PROPERTY_VALUES));

    if(0 == m_dwSchemaSize) {
    // no properties in cache
        *pProps = pUmiPropVals;
        RRETURN(UMI_S_NO_ERROR);
    }

    pUmiProps = (UMI_PROPERTY *) AllocADsMem(
                          m_dwSchemaSize * sizeof(UMI_PROPERTY));
    if(NULL == pUmiProps)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    memset(pUmiProps, 0, m_dwSchemaSize * sizeof(UMI_PROPERTY));

    for(ulIndex = 0; ulIndex < m_dwSchemaSize; ulIndex++) {
        if( (0 == _wcsicmp((LPWSTR) m_pSchema[ulIndex].szPropertyName, 
                         TEXT(UMIOBJ_INTF_PROP_SCHEMA))) ||
            (0 == _wcsicmp((LPWSTR) m_pSchema[ulIndex].szPropertyName,
                         TEXT(UMIOBJ_INTF_PROP_SCHEMAPATH))) ) {
            if(NULL == m_pszSchema)
            // must be a schema object, so don't return __SCHEMA and
            // __PADS_SCHEMA_CONTAINER_PATH.
                continue;
        }

        if(0 == _wcsicmp((LPWSTR) m_pSchema[ulIndex].szPropertyName,
                          TEXT(UMIOBJ_INTF_PROP_SUPERCLASS))) {
            if(FALSE == m_fIsClassObj)
            // not a class object. Hence __SUPERCLASS is not exposed.
                continue;
        } 

        if( (0 == _wcsicmp((LPWSTR) m_pSchema[ulIndex].szPropertyName,
                          TEXT(UMIOBJ_INTF_PROP_KEY))) ||
            (0 == _wcsicmp((LPWSTR) m_pSchema[ulIndex].szPropertyName,
                          TEXT(UMIOBJ_INTF_PROP_PARENT))) )
            if(TRUE == m_fIsNamespaceObj)
            // namespace objects have no key and parent
                continue;
        
        pUmiProps[ulCount].pszPropertyName = 
            (LPWSTR) AllocADsStr(m_pSchema[ulIndex].szPropertyName);
        if(NULL == pUmiProps[ulCount].pszPropertyName)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
        ulCount++;
    }

    pUmiPropVals->uCount = ulCount;
    pUmiPropVals->pPropArray = pUmiProps;

    *pProps = pUmiPropVals; 

    RRETURN(UMI_S_NO_ERROR);

error:

    if(pUmiProps != NULL) { 
        for(ulIndex = 0; ulIndex < m_dwSchemaSize; ulIndex++)
            if(pUmiProps[ulIndex].pszPropertyName != NULL)
                FreeADsStr(pUmiProps[ulIndex].pszPropertyName);

        FreeADsMem(pUmiProps);
    }

    if(pUmiPropVals != NULL)
        FreeADsMem(pUmiPropVals);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   GetObjectPropNames
//
// Synopsis:   Returns the names of all object properties in the cache. 
//
// Arguments:
//
// pProps      Returns the names of the properties, without any data
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pProps to return the property names
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::GetObjectPropNames(
    UMI_PROPERTY_VALUES **pProps
    )
{
    ADsAssert(pProps != NULL);
    ADsAssert(FALSE == m_fIsIntfPropObj);

    RRETURN(m_pPropCache->GetPropNames(pProps));
}
         
//----------------------------------------------------------------------------
// Function:   GetProps 
//
// Synopsis:   Implements IUmiPropList::GetProps. Gets multiple properties.
//             This method will currently only support retrieving the names
//             of the properties supported. For interface property objects,
//             the names of all interface properties will be returned. For
//             object properties, the names of all properties in the cache will
//             be returned.
//             This method also supports retrieving class information if
//             the underlying object is a class object (in which case
//             m_pClassInfo will be non-NULL). This is supported only on an
//             interface property object. 
//
// Arguments:
//
// pszNames    Names of properties to retrieve. Should be NULL if only names
//             are requested.
// uNameCount  Number of properties in pszNames. Should be 0 if only names
//             are requested.
// uFlags      Should be UMI_FLAG_GETPROPS_NAMES to retrieve names of properties
//             and UMI_FLAG_GETPROPS_SCHEMA to get class information.
// pProps      Returns the names of the properties, without any data
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pProps to return the property names 
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::GetProps(
    LPCWSTR *pszNames,
    ULONG uNameCount,
    ULONG uFlags,
    UMI_PROPERTY_VALUES **pProps
    )
{
    HRESULT hr = UMI_S_NO_ERROR;

    SetLastStatus(0);

    if( (uFlags != ((ULONG) UMI_FLAG_GETPROPS_NAMES)) && 
        (uFlags != ((ULONG) UMI_FLAG_GETPROPS_SCHEMA)) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if( (pszNames != NULL) || (uNameCount != 0) || (NULL == pProps) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    *pProps = NULL;

    if( ((ULONG) UMI_FLAG_GETPROPS_SCHEMA) == uFlags ) {
        if(NULL == m_pClassInfo) {
        // this is not a class object. This operation is not supported.
            BAIL_ON_FAILURE(hr = UMI_E_UNSUPPORTED_FLAGS);
        }
        else
            hr = GetClassInfo(pProps);
    }
    else {
        if(TRUE == m_fIsIntfPropObj)
            hr = GetInterfacePropNames(pProps);
        else
            hr = GetObjectPropNames(pProps);
    }

error:
 
    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//---------------------------------------------------------------------------
// Methods of IUmiPropList that are currently not implemented. 
//
//---------------------------------------------------------------------------
HRESULT CUmiPropList::GetAt(
    LPCWSTR pszName,
    ULONG uFlags,
    ULONG uBufferLength,
    LPVOID pExistingMem
    )
{
    SetLastStatus(UMI_E_NOTIMPL);

    RRETURN(UMI_E_NOTIMPL);
}

HRESULT CUmiPropList::PutProps(
    LPCWSTR *pszNames,
    ULONG uNameCount,
    ULONG uFlags,
    UMI_PROPERTY_VALUES *pProps
    )
{
    SetLastStatus(UMI_E_NOTIMPL);

    RRETURN(UMI_E_NOTIMPL);
}

HRESULT CUmiPropList::PutFrom(
    LPCWSTR pszName,
    ULONG uFlags,
    ULONG uBufferLength,
    LPVOID pExistingMem
    )
{
    SetLastStatus(UMI_E_NOTIMPL);

    RRETURN(UMI_E_NOTIMPL);
}

HRESULT CUmiPropList::Delete(
    LPCWSTR pszName,
    ULONG uFlags
    )
{
    SetLastStatus(UMI_E_NOTIMPL);

    RRETURN(UMI_E_NOTIMPL);
}

//----------------------------------------------------------------------------
// Function:   SetStandardProperties
//
// Synopsis:   Sets standard interface properties supported by all UMI objects
//             in the cache.
//
// Arguments:
//
// pIADs       Pointer to IADs interface on object
// pCoreObj    Pointer to core object for this WinNT object
//
// Returns:    S_OK on success. Error code otherwise. 
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::SetStandardProperties(
    IADs *pIADs,
    CCoreADsObject *pCoreObj
    )
{
    HRESULT    hr = S_OK;
    DWORD      dwIndex = 0;
    IDispatch  *pDispatch = NULL;
    DISPID     DispId;
    DISPPARAMS DispParams = {NULL, NULL, 0, 0};
    VARIANT    var;
    BSTR       bstrADsPath = NULL, bstrClass = NULL;
    LPWSTR     pFullUmiPath = NULL, pShortUmiPath = NULL, pRelUmiPath = NULL;
    LPWSTR     pFullRelUmiPath = NULL, pFullParentPath = NULL;
    DWORD      dwGenus = 0;
    BSTR       bstrName = NULL, bstrParent = NULL;
    WCHAR      *pSlash = NULL;
    LPWSTR     Classes[] = {NULL, L"Schema"};
    LPWSTR     pUmiSchemaPath = NULL;
    OBJECTINFO ObjectInfo;

    ADsAssert( (pIADs != NULL) && (TRUE == m_fIsIntfPropObj) );

    hr = pIADs->QueryInterface(
        IID_IDispatch,
        (void **) &pDispatch
        );
    BAIL_ON_FAILURE(hr);

    // First, set all properties supported on IADs. The names of these UMI
    // properties are not necessarily the same as the IADs properties, so
    // map the names appropriately.
    for(dwIndex = 0; dwIndex < g_dwIADsProperties; dwIndex++) {
        hr = pDispatch->GetIDsOfNames(
                IID_NULL,
                &g_IADsProps[dwIndex].IADsPropertyName,
                1,
                LOCALE_SYSTEM_DEFAULT,
                &DispId
                );
        BAIL_ON_FAILURE(hr);

        hr = pDispatch->Invoke(
                DispId,
                IID_NULL,
                LOCALE_SYSTEM_DEFAULT,
                DISPATCH_PROPERTYGET,
                &DispParams,
                &var,
                NULL,
                NULL
                );

        if(0 == _wcsicmp(g_IADsProps[dwIndex].IADsPropertyName, L"Schema")) {
            if(FAILED(hr))
            // Not a catastrophic failure. Can't get this property from the
            // cache. Only scenario where this should happen is when calling 
            // get_Schema on a schema/namespace object.
                continue;
            else {
            // store native path to schema in member variable
                m_pszSchema = AllocADsStr(V_BSTR(&var));
                VariantClear(&var);

                if(NULL == m_pszSchema)
                    BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

                // walk path backwards and get rid of last '/'
                pSlash = wcsrchr(m_pszSchema, L'/');
                if(NULL == pSlash) 
                // bad schema path
                    BAIL_ON_FAILURE(UMI_E_FAIL);

                *pSlash = L'\0';

                Classes[0] = pCoreObj->_CompClasses[0];
                ObjectInfo.DisplayComponentArray[0] = 
                          pCoreObj->_ObjectInfo.DisplayComponentArray[0];
                ObjectInfo.DisplayComponentArray[1] = SCHEMA_NAME;
                hr = ADsToUmiPath(
                        m_pszSchema,
                        &ObjectInfo,
                        Classes,
                        2,
                        FULL_UMI_PATH,
                        &pUmiSchemaPath
                        );

                *pSlash = L'/';

                BAIL_ON_FAILURE(hr);

                hr = SetLPTSTRPropertyInCache(
                        m_pPropCache,
                        TEXT(UMIOBJ_INTF_PROP_SCHEMAPATH),
                        pUmiSchemaPath,
                        TRUE
                        );
                BAIL_ON_FAILURE(hr);                

                continue;
            } // else 
        } // if(_wcsicmp...)

        BAIL_ON_FAILURE(hr); // if Invoke failed

        if(0 == _wcsicmp(g_IADsProps[dwIndex].IADsPropertyName, L"Parent")) {
        // convert the parent to a full UMI path
            if(0 == pCoreObj->_dwNumComponents) {
            // namespace object has no parent
                VariantClear(&var);
                continue;
            }
            else {
                bstrParent = V_BSTR(&var);

                hr = ADsToUmiPath(
                        bstrParent,
                        pCoreObj->_pObjectInfo,
                        pCoreObj->_CompClasses,
                        pCoreObj->_dwNumComponents - 1,
                        FULL_UMI_PATH,
                        &pFullParentPath
                        );
                VariantClear(&var);

                BAIL_ON_FAILURE(hr);

                hr = SetLPTSTRPropertyInCache(
                        m_pPropCache,
                        TEXT(UMIOBJ_INTF_PROP_PARENT),
                        pFullParentPath,
                        TRUE
                        );
                BAIL_ON_FAILURE(hr);

                continue;
            } // else
        } // if(0 ==

        hr = GenericPutPropertyManager(
                m_pPropCache,
                m_pSchema,
                m_dwSchemaSize,
                g_IADsProps[dwIndex].UMIPropertyName,
                var,
                FALSE
                );
        VariantClear(&var);

        BAIL_ON_FAILURE(hr);
    }
        
    // Now, set the remaining standard interface properties
    hr = pIADs->get_ADsPath(&bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsToUmiPath(
            bstrADsPath, 
            pCoreObj->_pObjectInfo,
            pCoreObj->_CompClasses, 
            pCoreObj->_dwNumComponents,
            FULL_UMI_PATH, 
            &pFullUmiPath
            );
    BAIL_ON_FAILURE(hr);

    hr = ADsToUmiPath(
            bstrADsPath,
            pCoreObj->_pObjectInfo, 
            pCoreObj->_CompClasses,
            pCoreObj->_dwNumComponents, 
            SHORT_UMI_PATH, 
            &pShortUmiPath
            );
    BAIL_ON_FAILURE(hr);

    hr = ADsToUmiPath(
            bstrADsPath,
            pCoreObj->_pObjectInfo, 
            pCoreObj->_CompClasses,
            pCoreObj->_dwNumComponents,
            RELATIVE_UMI_PATH, 
            &pRelUmiPath
            );
    BAIL_ON_FAILURE(hr);

    hr = ADsToUmiPath(
            bstrADsPath,
            pCoreObj->_pObjectInfo,
            pCoreObj->_CompClasses,
            pCoreObj->_dwNumComponents,
            FULL_RELATIVE_UMI_PATH,
            &pFullRelUmiPath
            );
    BAIL_ON_FAILURE(hr);

    hr = SetLPTSTRPropertyInCache(
            m_pPropCache,
            TEXT(UMIOBJ_INTF_PROP_FULLURL),
            pFullUmiPath,
            TRUE
            );
    BAIL_ON_FAILURE(hr);

    hr = SetLPTSTRPropertyInCache(
            m_pPropCache,
            TEXT(UMIOBJ_INTF_PROP_URL), 
            pShortUmiPath,
            TRUE
            );
    BAIL_ON_FAILURE(hr);

    hr = SetLPTSTRPropertyInCache(
            m_pPropCache,
            TEXT(UMIOBJ_INTF_PROP_RELURL),
            pRelUmiPath,
            TRUE
            );
    BAIL_ON_FAILURE(hr);

    hr = SetLPTSTRPropertyInCache(
            m_pPropCache,
            TEXT(UMIOBJ_INTF_PROP_FULLRELURL),
            pFullRelUmiPath,
            TRUE
            );
    BAIL_ON_FAILURE(hr);

    // Relpath is the same as the full relative URL
    hr = SetLPTSTRPropertyInCache(
            m_pPropCache,
            TEXT(UMIOBJ_INTF_PROP_RELPATH),
            pFullRelUmiPath,
            TRUE
            );
    BAIL_ON_FAILURE(hr);

    // set the genus based on the class of the object
    hr = pIADs->get_Class(&bstrClass);
    BAIL_ON_FAILURE(hr);

    if(IsSchemaObject(bstrClass)) {
        dwGenus = UMI_GENUS_CLASS;

        // WMI requires that the value of __CLASS be the same on instances
        // and classes. Thus, on class objects, the value of __CLASS should
        // be "user" instead of "class". __SUPERCLASS is exposed only on
        // class objects. Its value is always NULL in the WinNT provider 
        // since there is no class hierarchy.

        if(IsClassObj(bstrClass)) {
            hr = pIADs->get_Name(&bstrName);
            BAIL_ON_FAILURE(hr);

            // overwrite the value of __CLASS already stored in cache above
            hr = SetLPTSTRPropertyInCache(
                m_pPropCache,
                TEXT(UMIOBJ_INTF_PROP_CLASS),
                bstrName,
                TRUE
                );
            BAIL_ON_FAILURE(hr);

            hr = SetLPTSTRPropertyInCache(
                m_pPropCache,
                TEXT(UMIOBJ_INTF_PROP_SUPERCLASS),
                NULL,
                TRUE
                );

            m_fIsClassObj = TRUE;

            BAIL_ON_FAILURE(hr);
        } // if(IsClassObj...)
    }
    else
        dwGenus = UMI_GENUS_INSTANCE;

    hr = SetDWORDPropertyInCache(
            m_pPropCache,
            TEXT(UMIOBJ_INTF_PROP_GENUS),
            dwGenus,
            TRUE
            );
    BAIL_ON_FAILURE(hr);

    // set the key property. For WinNT, it will always be "Name" except that
    // namespace objects have no key (since the UMI path to a namespace object
    // is just umi:///winnt - there is no component of the form class.key=val.
    if(!IsNamespaceObj(bstrClass)) {
        hr = SetLPTSTRPropertyInCache(
                m_pPropCache,
                TEXT(UMIOBJ_INTF_PROP_KEY),
                WINNT_KEY_NAME,
                TRUE 
                );

        BAIL_ON_FAILURE(hr);
    }
    else {
        m_fIsNamespaceObj = TRUE;
    }

    // Mark all properties as "not modified", since the client really hasn't
    // updated the cache, though we have.
    m_pPropCache->ClearModifiedFlags();

error:
    if(pDispatch != NULL)
        pDispatch->Release();

    if(bstrADsPath != NULL)
        SysFreeString(bstrADsPath);

    if(bstrClass != NULL)
        SysFreeString(bstrClass);

    if(pFullUmiPath != NULL)
        FreeADsStr(pFullUmiPath);

    if(pRelUmiPath != NULL)
        FreeADsStr(pRelUmiPath);

    if(pFullRelUmiPath != NULL)
        FreeADsStr(pFullRelUmiPath);

    if(pShortUmiPath != NULL)
        FreeADsStr(pShortUmiPath);

    if(pFullParentPath != NULL)
        FreeADsStr(pFullParentPath);

    if(bstrName != NULL)
        SysFreeString(bstrName);

    if(pUmiSchemaPath != NULL)
        FreeADsStr(pUmiSchemaPath);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   IsSchemaObject 
//
// Synopsis:   Returns whether an object of a specified class is a schema
//             object or not. 
//
// Arguments:
//
// bstrClass   Class of object
//
// Returns:    TRUE if it is a schema object. FALSE otherwise. 
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
BOOL CUmiPropList::IsSchemaObject(
    BSTR bstrClass
    )
{
    ADsAssert(bstrClass != NULL);

    if( (!_wcsicmp(bstrClass, L"Schema")) ||
        (!_wcsicmp(bstrClass, L"Class")) ||
        (!_wcsicmp(bstrClass, L"Property")) ||
        (!_wcsicmp(bstrClass, L"Syntax")) ||
        (!_wcsicmp(bstrClass, L"Namespace")) )
        RRETURN(TRUE);

    RRETURN(FALSE);
}

//----------------------------------------------------------------------------
// Function:   GetSchemaObject
//
// Synopsis:   Returns a IUmiObject pointer pointing to the schema class object
//             corresponding to this WinNT object. If there is no class object,
//             returns error. 
//
// Arguments:
//
// pszName     Name of the schema property
// ppProp      Returns pointer to the structure containing the IUmiObject
//             pointer. 
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise. 
//
// Modifies:   *ppProp to return the address of UMI_PROPERTY_VALUES structure. 
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::GetSchemaObject(
    LPWSTR pszName,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    HRESULT    hr = UMI_S_NO_ERROR;
    IUnknown   *pUnknown = NULL;
    IUmiObject *pUmiObj = NULL;
    UMI_PROPERTY_VALUES *pProp = NULL;

    PUMI_COM_OBJECT pUmiComObj = NULL;
    // use ADS_AUTH_RESERVED since the call is from UMI
    CWinNTCredentials Credentials(NULL, NULL, ADS_AUTH_RESERVED);

    ADsAssert( (ppProp != NULL) && (TRUE == m_fIsIntfPropObj) );

    *ppProp = NULL;

    if(NULL == m_pszSchema)
    // schema objects don't support __SCHEMA
        RRETURN(UMI_E_PROPERTY_NOT_FOUND);

    hr = GetObject(
            m_pszSchema,
            (LPVOID *) &pUnknown,
            Credentials
            ); 
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(IID_IUmiObject, (LPVOID *) &pUmiObj);
    BAIL_ON_FAILURE(hr);

    pUmiComObj = (PUMI_COM_OBJECT) AllocADsMem(sizeof(UMI_COM_OBJECT));
    if(NULL == pUmiComObj)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    memset(pUmiComObj, 0, sizeof(UMI_COM_OBJECT));

    pUmiComObj->priid = (IID *) AllocADsMem(sizeof(IID));
    if(NULL == pUmiComObj->priid)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    memcpy(pUmiComObj->priid, &IID_IUmiObject, sizeof(IID));
    pUmiComObj->pInterface = (LPVOID) pUmiObj;

    // allocate structure to return values
    pProp = (UMI_PROPERTY_VALUES *) AllocADsMem(sizeof(UMI_PROPERTY_VALUES));
    if(NULL == pProp)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    memset(pProp, 0, sizeof(UMI_PROPERTY_VALUES));

    pProp->pPropArray = (UMI_PROPERTY *) AllocADsMem(sizeof(UMI_PROPERTY));
    if(NULL == pProp->pPropArray)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    memset(pProp->pPropArray, 0, sizeof(UMI_PROPERTY));

    pProp->pPropArray->pUmiValue = (UMI_VALUE *) pUmiComObj;

    // Get fetches only one property at a time
    pProp->uCount = 1;

    // Fill in remaining fields of UMI_PROPERTY
    pProp->pPropArray->uOperationType = 0;
    pProp->pPropArray->uType = UMI_TYPE_IUNKNOWN;
    pProp->pPropArray->uCount = 1;

    // not critical if this memory allocation fails. Property name doesn't
    // have to be returned to the caller.
    pProp->pPropArray->pszPropertyName = AllocADsStr(pszName);

    *ppProp = pProp;

error:

    if(pUnknown != NULL)
        pUnknown->Release();

    if(FAILED(hr)) {
        if(pUmiObj != NULL)
            pUmiObj->Release();

        if(pUmiComObj != NULL) {
            if(pUmiComObj->priid != NULL)
                FreeADsMem(pUmiComObj->priid);

            FreeADsMem(pUmiComObj);
        }

        if(pProp != NULL) {
            if(pProp->pPropArray != NULL) {
                if(pProp->pPropArray->pszPropertyName != NULL)
                    FreeADsStr(pProp->pPropArray->pszPropertyName);
                FreeADsMem(pProp->pPropArray);
            }

            FreeADsMem(pProp);
        }
    } // if(FAILED(hr)) 

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   SetClassInfo 
//
// Synopsis:   Initializes class info for this object. Class info will be
//             stored only for class schema objects.  
//
// Arguments:
//
// pClassInfo  Class info for the object (NULL if not a class object)
//
// Returns:    Nothing 
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
void CUmiPropList::SetClassInfo(
    CLASSINFO *pClassInfo 
    )
{
    m_pClassInfo = pClassInfo;
    return;
} 
     
//----------------------------------------------------------------------------
// Function:   GetClassInfo
//
// Synopsis:   Returns the name and UMI type of all attributes in a given
//             WinNT class. This method will only be called on the interface
//             property object of a class object.
//
// Arguments:
//
// pProps      Returns the names and types of the attributes, without any data
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pProps to return the property names 
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::GetClassInfo(
    UMI_PROPERTY_VALUES **pProps
    )
{
    UMI_PROPERTY_VALUES *pUmiPropVals = NULL;
    UMI_PROPERTY        *pUmiProps = NULL;
    HRESULT             hr = UMI_S_NO_ERROR;
    ULONG               ulIndex = 0;
    PPROPERTYINFO       pClassSchema = NULL;
    DWORD               dwClassSchemaSize = 0;

    ADsAssert(pProps != NULL);
    ADsAssert(TRUE == m_fIsIntfPropObj);
    ADsAssert(m_pClassInfo != NULL);

    pUmiPropVals = (UMI_PROPERTY_VALUES *) AllocADsMem(
                          sizeof(UMI_PROPERTY_VALUES));
    if(NULL == pUmiPropVals)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    memset(pUmiPropVals, 0, sizeof(UMI_PROPERTY_VALUES));

    pClassSchema = m_pClassInfo->aPropertyInfo;
    dwClassSchemaSize = m_pClassInfo->cPropertyInfo;

    if(0 == dwClassSchemaSize) {
    // no properties in class
        *pProps = pUmiPropVals;
        RRETURN(UMI_S_NO_ERROR);
    }

    pUmiProps = (UMI_PROPERTY *) AllocADsMem(
                          dwClassSchemaSize * sizeof(UMI_PROPERTY));
    if(NULL == pUmiProps)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    memset(pUmiProps, 0, dwClassSchemaSize * sizeof(UMI_PROPERTY));

    for(ulIndex = 0; ulIndex < dwClassSchemaSize; ulIndex++) {
        pUmiProps[ulIndex].pszPropertyName = 
            (LPWSTR) AllocADsStr(pClassSchema[ulIndex].szPropertyName);
        if(NULL == pUmiProps[ulIndex].pszPropertyName)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

        // map the NT type to a UMI type
        if(pClassSchema[ulIndex].dwSyntaxId >= g_dwNumNTTypes)
            BAIL_ON_FAILURE(hr = UMI_E_FAIL); // shouldn't happen

        pUmiProps[ulIndex].uType = 
            g_mapNTTypeToUmiType[pClassSchema[ulIndex].dwSyntaxId];
    }

    pUmiPropVals->uCount = dwClassSchemaSize;
    pUmiPropVals->pPropArray = pUmiProps;

    *pProps = pUmiPropVals; 

    RRETURN(UMI_S_NO_ERROR);

error:

    if(pUmiProps != NULL) { 
        for(ulIndex = 0; ulIndex < dwClassSchemaSize; ulIndex++)
            if(pUmiProps[ulIndex].pszPropertyName != NULL)
                FreeADsStr(pUmiProps[ulIndex].pszPropertyName);

        FreeADsMem(pUmiProps);
    }

    if(pUmiPropVals != NULL)
        FreeADsMem(pUmiPropVals);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   IsNamespaceObj
//
// Synopsis:   Returns whether an object of a specified class is a namespace 
//             object or not.
//
// Arguments:
//
// bstrClass   Class of object
//
// Returns:    TRUE if it is a namespace object. FALSE otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
BOOL CUmiPropList::IsNamespaceObj(
    BSTR bstrClass
    )
{
    ADsAssert(bstrClass != NULL);

    if(!_wcsicmp(bstrClass, L"Namespace"))
        RRETURN(TRUE);

    RRETURN(FALSE);
}

//----------------------------------------------------------------------------
// Function:   IsClassObj
//
// Synopsis:   Returns whether an object of a specified class is a class 
//             object or not.
//
// Arguments:
//
// bstrClass   Class of object
//
// Returns:    TRUE if it is a class object. FALSE otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
BOOL CUmiPropList::IsClassObj(
    BSTR bstrClass
    )
{
    ADsAssert(bstrClass != NULL);

    if(!_wcsicmp(bstrClass, L"Class"))
        RRETURN(TRUE);

    RRETURN(FALSE);
}

//----------------------------------------------------------------------------
// Function:   DisableWrites 
//
// Synopsis:   Disables writes on an interface property object. Used to disable
//             modification of connection interface properties after the
//             connection is opened. 
//
// Arguments:
//
// None
//
// Returns:    Nothing 
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
void CUmiPropList::DisableWrites(void)
{
    ADsAssert(TRUE == m_fIsIntfPropObj);

    m_fDisableWrites = TRUE;
}

//----------------------------------------------------------------------------
// Function:   SetDefaultConnProps 
//
// Synopsis:   Sets the default connection interface properties on the
//             interface property object of a connection. 
//
// Arguments:
//
// None
//
// Returns:    S_OK on success. Error code otherwise. 
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::SetDefaultConnProps(void)
{
    HRESULT hr = S_OK;

    ADsAssert(TRUE == m_fIsIntfPropObj);

    hr = SetLPTSTRPropertyInCache(
            m_pPropCache,
            TEXT(CONN_INTF_PROP_USERNAME),
            CONN_INTF_PROP_DEFAULT_USERNAME,
            TRUE
            );
    BAIL_ON_FAILURE(hr);

    hr = SetLPTSTRPropertyInCache(
            m_pPropCache,
            TEXT(CONN_INTF_PROP_PASSWORD),
            CONN_INTF_PROP_DEFAULT_PASSWORD,
            TRUE
            );
    BAIL_ON_FAILURE(hr);

    hr = SetBOOLPropertyInCache(
            m_pPropCache,
            TEXT(CONN_INTF_PROP_SECURE_AUTH),
            CONN_INTF_PROP_DEFAULT_SECURE_AUTH,
            TRUE
            );
    BAIL_ON_FAILURE(hr);

    hr = SetBOOLPropertyInCache(
            m_pPropCache,
            TEXT(CONN_INTF_PROP_READONLY_SERVER),
            CONN_INTF_PROP_DEFAULT_READONLY_SERVER,
            TRUE
            );
    BAIL_ON_FAILURE(hr);

    RRETURN(S_OK);

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   SetPropertyCount
//
// Synopsis:   Sets the property count in the interface property object's
//             cache. The property count is the number of properties in the
//             schema class object. It is exposed on both schema objects and
//             instances. 
//
// Arguments:
//
// dwPropCount Property count 
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::SetPropertyCount(DWORD dwPropCount)
{
    HRESULT hr = S_OK;

    hr = SetDWORDPropertyInCache(
            m_pPropCache,
            TEXT(UMIOBJ_INTF_PROP_PROPERTY_COUNT),
            dwPropCount,
            TRUE
            );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   GetPropertyOrigin
//
// Synopsis:   Returns the class in the hierarchy that introduced a
//             property. Since WinNT does not have a class hierarchy, this
//             will always be the class on which this method is called. If
//             the property is not in the class, an error is returned. 
//
// Arguments:
//
// pszName     Name of the schema property
// ppProp      Returns pointer to the structure containing the class name 
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *ppProp to return the address of UMI_PROPERTY_VALUES structure.
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::GetPropertyOrigin(
    LPCWSTR pszName,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    HRESULT       hr = UMI_S_NO_ERROR;
    DWORD         dwIndex = 0;
    PPROPERTYINFO pClassSchema = NULL;
    DWORD         dwClassSchemaSize = 0;
    UMI_PROPERTY_VALUES *pProp = NULL;
    LPWSTR        *ppszClassArray = NULL;

    ADsAssert( (pszName != NULL) && (ppProp != NULL) && 
               (TRUE == m_fIsIntfPropObj) && (m_pClassInfo != NULL) );

    *ppProp = NULL;

    pClassSchema = m_pClassInfo->aPropertyInfo;
    dwClassSchemaSize = m_pClassInfo->cPropertyInfo;

    if(0 == dwClassSchemaSize) 
    // no properties in class
        BAIL_ON_FAILURE(hr = UMI_E_PROPERTY_NOT_FOUND);

    for(dwIndex = 0; dwIndex < dwClassSchemaSize; dwIndex++) {
        if(0 == _wcsicmp(pszName, pClassSchema[dwIndex].szPropertyName))
        // found the property
            break;
    }

    if(dwIndex == dwClassSchemaSize)
        BAIL_ON_FAILURE(hr = UMI_E_PROPERTY_NOT_FOUND);

    // allocate structure to return class name 
    pProp = (UMI_PROPERTY_VALUES *) AllocADsMem(sizeof(UMI_PROPERTY_VALUES));
    if(NULL == pProp)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    memset(pProp, 0, sizeof(UMI_PROPERTY_VALUES));

    pProp->pPropArray = (UMI_PROPERTY *) AllocADsMem(sizeof(UMI_PROPERTY));
    if(NULL == pProp->pPropArray)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    memset(pProp->pPropArray, 0, sizeof(UMI_PROPERTY));

    ppszClassArray = (LPWSTR *) AllocADsMem(sizeof(LPWSTR *));
    if(NULL == pProp->pPropArray)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    memset(ppszClassArray, 0, sizeof(LPWSTR *));

    ppszClassArray[0] = AllocADsStr(m_pClassInfo->bstrName);
    if(NULL == ppszClassArray[0])
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    pProp->pPropArray->pUmiValue = (UMI_VALUE *) ppszClassArray;

    // Get fetches only one property at a time
    pProp->uCount = 1;

    // Fill in remaining fields of UMI_PROPERTY
    pProp->pPropArray->uOperationType = 0;
    pProp->pPropArray->uType = UMI_TYPE_LPWSTR;
    pProp->pPropArray->uCount = 1;

    // not critical if this memory allocation fails. Property name doesn't
    // have to be returned to the caller.
    pProp->pPropArray->pszPropertyName = AllocADsStr(pszName);

    *ppProp = pProp;

error:

    if(FAILED(hr)) {
        if(pProp != NULL) {
            if(pProp->pPropArray != NULL) {
                if(pProp->pPropArray->pszPropertyName != NULL)
                    FreeADsStr(pProp->pPropArray->pszPropertyName);
                FreeADsMem(pProp->pPropArray);
            }

            FreeADsMem(pProp);
        }

        if(ppszClassArray != NULL) {
            if(ppszClassArray[0] != NULL)
                FreeADsStr(ppszClassArray[0]);

            FreeADsMem(ppszClassArray);
        }

    } // if(FAILED(hr))

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cumiconn.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     cumiconn.cxx
//
//  Contents: Contains the UMI connection object implementation 
//
//  History:  03-02-00    SivaramR  Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"

//----------------------------------------------------------------------------
// Function:   CreateConnection
//
// Synopsis:   Creates a connection object. Called by class factory.
//
// Arguments:
//
// iid         Interface requested. Only interface supported is IUmiConnection.
// ppInterface Returns pointer to interface requested
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return a pointer to the interface requested
//
//----------------------------------------------------------------------------
HRESULT CUmiConnection::CreateConnection(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    CUmiConnection *pConn = NULL;
    HRESULT         hr = S_OK;

    ADsAssert(ppInterface);

    pConn = new CUmiConnection();
    if(NULL == pConn)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    // initialize connection object
    hr = pConn->FInit();
    BAIL_ON_FAILURE(hr);

    hr = pConn->QueryInterface(iid, ppInterface);
    BAIL_ON_FAILURE(hr);

    pConn->Release();

    RRETURN(S_OK);

error:

    if(pConn != NULL)
        delete pConn;

    RRETURN(hr);
}
   
//----------------------------------------------------------------------------
// Function:   CUmiConnection
//
// Synopsis:   Constructor. Initializes all member variables
//
// Arguments:
//
// None
//
// Returns:    Nothing. 
//
// Modifies:   Nothing. 
//
//---------------------------------------------------------------------------- 
CUmiConnection::CUmiConnection(void)
{
    m_pIUmiPropList = NULL;
    m_pCUmiPropList = NULL;
    m_ulErrorStatus = 0;
    m_pIADsOpenDSObj = NULL;
    m_fAlreadyOpened = FALSE;
    m_pszComputerName = NULL;
    m_pszDomainName = NULL;
}

//----------------------------------------------------------------------------
// Function:   ~CUmiConnection
//
// Synopsis:   Destructor. Frees member variables
//
// Arguments:
//
// None
//
// Returns:    Nothing.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
CUmiConnection::~CUmiConnection(void)
{
    if(m_pIUmiPropList != NULL)
        m_pIUmiPropList->Release();

    if(m_pszComputerName != NULL)
        FreeADsStr(m_pszComputerName);

    if(m_pszDomainName != NULL)
        FreeADsStr(m_pszDomainName);

    if(m_pIADsOpenDSObj != NULL)
        m_pIADsOpenDSObj->Release();

    // m_pCUmiPropList does not have to be deleted since the Release() above
    // has already done it.
}

//----------------------------------------------------------------------------
// Function:   FInit 
//
// Synopsis:   Initializes connection object. 
//
// Arguments:
//
// None
//
// Returns:    S_OK on success. Error code otherwise. 
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
HRESULT CUmiConnection::FInit(void)
{
    HRESULT      hr = S_OK;
    CUmiPropList *pPropList = NULL;

    pPropList = new CUmiPropList(ConnectionClass, g_dwConnectionTableSize);
    if(NULL == pPropList)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    hr = pPropList->FInit(NULL, g_UmiConUnImplProps);
    BAIL_ON_FAILURE(hr);

    hr = pPropList->QueryInterface(
                IID_IUmiPropList,
                (void **) &m_pIUmiPropList
                );
    BAIL_ON_FAILURE(hr);

    // DECLARE_STD_REFCOUNTING initializes the refcount to 1. Call Release()
    // on the created object, so that releasing the interface pointer will
    // free the object.
    pPropList->Release(); 

    m_pCUmiPropList = pPropList;

    hr = m_pCUmiPropList->SetDefaultConnProps();
    BAIL_ON_FAILURE(hr);

    RRETURN(S_OK);

error:

    if(m_pIUmiPropList != NULL) {
        m_pIUmiPropList->Release();
        m_pIUmiPropList = NULL;
        m_pCUmiPropList = NULL;
    }
    else if(pPropList != NULL)
        delete pPropList;

    RRETURN(hr);
} 

//----------------------------------------------------------------------------
// Function:   QueryInterface 
//
// Synopsis:   Queries connection object for supported interfaces. Only 
//             IUmiConnection is supported. 
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer 
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiConnection::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(NULL == ppInterface)
        RRETURN(E_INVALIDARG);

    *ppInterface = NULL;

    if(IsEqualIID(iid, IID_IUnknown))
        *ppInterface = (IUmiConnection *) this;
    else if(IsEqualIID(iid, IID_IUmiConnection))
        *ppInterface = (IUmiConnection *) this;
    else if(IsEqualIID(iid, IID_IUmiBaseObject))
        *ppInterface = (IUmiBaseObject *) this;
    else if(IsEqualIID(iid, IID_IUmiPropList))
        *ppInterface = (IUmiPropList *) this;
    else
         RRETURN(E_NOINTERFACE);

    AddRef();
    RRETURN(S_OK);
}
     
//----------------------------------------------------------------------------
// Function:   GetLastStatus 
//
// Synopsis:   Returns status or error code from the last operation. Currently
//             only numeric status is returned i.e, no error objects are
//             returned. Implements IUmiBaseObject::GetLastStatus().
//
// Arguments:
//
// uFlags           Reserved. Must be 0 for now.
// puSpecificStatus Returns status code 
// riid             IID requested. Ignored currently.
// pStatusObj       Returns interface requested. Always returns NULL currently. 
//
// Returns:         UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:        *puSpecificStatus to return status code. 
//
//---------------------------------------------------------------------------- 
STDMETHODIMP CUmiConnection::GetLastStatus(
    ULONG uFlags,
    ULONG *puSpecificStatus,
    REFIID riid,
    LPVOID *pStatusObj
    )
{
    if(pStatusObj != NULL)
       *pStatusObj = NULL;

    if(puSpecificStatus != NULL)
        *puSpecificStatus = 0;

    if(uFlags != 0)
        RRETURN(UMI_E_INVALID_FLAGS);

    if(NULL == puSpecificStatus)
        RRETURN(UMI_E_INVALIDARG);

    *puSpecificStatus = m_ulErrorStatus;

    RRETURN(UMI_S_NO_ERROR);
}

//----------------------------------------------------------------------------
// Function:   GetInterfacePropList
//
// Synopsis:   Returns a pointer to the interface property list implementation
//             for the connection object. Implements 
//             IUmiBaseObject::GetInterfacePropList().
//
// Arguments:
//
// uFlags      Reserved. Must be 0 for now.
// pPropList   Returns pointer to IUmiPropertyList interface
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pPropList to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiConnection::GetInterfacePropList(
    ULONG uFlags,
    IUmiPropList **pPropList
    )
{
    HRESULT hr = UMI_S_NO_ERROR;

    SetLastStatus(0);

    if(uFlags != 0)
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if(NULL == pPropList)
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    ADsAssert(m_pIUmiPropList != NULL);

    hr = m_pIUmiPropList->QueryInterface(IID_IUmiPropList, (void **)pPropList);

error:

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   SetLastStatus 
//
// Synopsis:   Sets the status of the last operation. 
//
// Arguments:
//
// ulStatus    Status to be set
//
// Returns:    Nothing 
//
// Modifies:   Nothing 
//
//----------------------------------------------------------------------------
void CUmiConnection::SetLastStatus(ULONG ulStatus)
{
    m_ulErrorStatus = ulStatus;

    return;
} 

//----------------------------------------------------------------------------
// Function:   Open 
//
// Synopsis:   Opens the object specified by a URL and gets the interface 
//             requested on this object. Implements IUmiConnection::Open(). 
//
// Arguments:
//
// pURL        Pointer to an IUmiURL interface
// uFlags      Reserved. Must be 0 for now.
// TargetIID   Interface requested
// ppInterface Returns pointer to interface requested
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiConnection::Open(
    IUmiURL *pURL,
    ULONG   uFlags,
    REFIID  TargetIID,
    LPVOID  *ppInterface
    )
{
    HRESULT  hr = UMI_S_NO_ERROR;
    LPWSTR   pszUserName = NULL, pszPassword = NULL;
    DWORD    dwBindFlags = 0, dwNumComponents = 0, dwIndex = 0;
    LPWSTR   *ppszClasses = NULL;
    WCHAR    pszUrl[MAX_URL+1];
    WCHAR    *pszLongUrl = pszUrl;
    ULONG    ulUrlLen = MAX_URL;
    IUnknown *pIUnknown = NULL;
    CWinNTNamespaceCF tmpNamCF;
    ULONGLONG PathType = 0;
    BOOL     fPrevAlreadyOpened = FALSE;
    LPWSTR   pszPrevComputer = NULL, pszPrevDomain = NULL;

    SetLastStatus(0);

    if(uFlags != 0)
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
 
    if( (NULL == pURL) || (NULL == ppInterface) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    *ppInterface = NULL;

    // Check if the user specified any interface properties for authentication
    hr = GetUserName(&pszUserName);
    BAIL_ON_FAILURE(hr);

    hr = GetPassword(&pszPassword);
    BAIL_ON_FAILURE(hr);

    hr = GetBindFlags(&dwBindFlags);
    BAIL_ON_FAILURE(hr);

    // check if this is a native path or UMI path
    hr = pURL->GetPathInfo(0, &PathType);
    BAIL_ON_FAILURE(hr);

    if(PathType & UMIPATH_INFO_NATIVE_STRING) {
    // Get the native path from the URL
        hr = pURL->Get(0, &ulUrlLen, pszUrl);

        if(WBEM_E_BUFFER_TOO_SMALL == hr) {
        // need to allocate more memory for URL
            pszLongUrl = (WCHAR *) AllocADsMem(ulUrlLen * sizeof(WCHAR));
            if(NULL == pszLongUrl)
                BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

            hr = pURL->Get(0, &ulUrlLen, pszLongUrl);
        }
        BAIL_ON_FAILURE(hr); 
    }
    else {
    // assume UMI path if not native
        hr = UmiToWinNTPath(
                pURL, 
                &pszLongUrl,
                &dwNumComponents,
                &ppszClasses
                );
        BAIL_ON_FAILURE(hr);
    }

    hr = tmpNamCF.CreateInstance(
                NULL,
                IID_IADsOpenDSObject,
                (void **) &m_pIADsOpenDSObj
                );
    BAIL_ON_FAILURE(hr);

    //
    // we need a way to distinguish between calls to OpenDSObject from UMI
    // vs ADSI. We use the bind flags for this purpose. If ADS_AUTH_RESERVED
    // is set, then the call is from UMI. ADSI clients are not allowed to use
    // this flag - OLEDB relies on this.
    // 

    hr = m_pIADsOpenDSObj->OpenDSObject(
                pszLongUrl,
                pszUserName,
                pszPassword,
                dwBindFlags | ADS_AUTH_RESERVED,
                (IDispatch **) &pIUnknown
                ); 
     BAIL_ON_FAILURE(hr);

     // save off state in case we need to restore it later
     fPrevAlreadyOpened = m_fAlreadyOpened;
     pszPrevComputer = m_pszComputerName;
     pszPrevDomain = m_pszDomainName;

     // ensure that the returned object is what the user requested and that the 
     // object is on the same domain/server that this connection is for
     hr = CheckObject(
             pIUnknown, 
             dwNumComponents, 
             ppszClasses
             );
     BAIL_ON_FAILURE(hr);

     hr = pIUnknown->QueryInterface(
                TargetIID,
                ppInterface
                );
     if(FAILED(hr)) {
         // restore state of connection
         m_fAlreadyOpened = fPrevAlreadyOpened;

         if(m_pszComputerName != pszPrevComputer) {
             if(m_pszComputerName != NULL)
                 FreeADsStr(m_pszComputerName);
             m_pszComputerName = pszPrevComputer;
         }
         if(m_pszDomainName != pszPrevDomain) {
             if(m_pszDomainName != NULL)
                 FreeADsStr(m_pszDomainName);
             m_pszDomainName = pszPrevDomain;
         }

         goto error;
     }

     // make interface properties read-only
     m_pCUmiPropList->DisableWrites();

error:

     if(pszUserName != NULL)
         FreeADsMem(pszUserName);

     if(pszPassword != NULL)
         FreeADsMem(pszPassword);

     if(pIUnknown != NULL)
         pIUnknown->Release();

     if( (pszLongUrl != NULL) && (pszLongUrl != pszUrl) )
         FreeADsMem(pszLongUrl);

     if(ppszClasses != NULL) {
         for(dwIndex = 0; dwIndex < dwNumComponents; dwIndex++) {
             if(ppszClasses[dwIndex] != NULL)
                 FreeADsStr(ppszClasses[dwIndex]);
         }
         FreeADsMem(ppszClasses);
     }

     if(FAILED(hr)) {
         SetLastStatus(hr);
         
         if(m_pIADsOpenDSObj != NULL) {
             m_pIADsOpenDSObj->Release();
             m_pIADsOpenDSObj = NULL;
         }
     }
     
     RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   GetUserName 
//
// Synopsis:   Gets the username from the interface property cache. If the
//             interface property was not set, the default username is 
//             returned. 
//
// Arguments:
//
// ppszUserName Returns pointer to the username 
//
// Returns:     UMI_S_NO_ERROR on success.  Error code otherwise.
//
// Modifies:    *ppszUserName to return the username. 
//
//----------------------------------------------------------------------------
HRESULT CUmiConnection::GetUserName(LPWSTR *ppszUserName)
{
    HRESULT             hr = UMI_S_NO_ERROR;
    UMI_PROPERTY_VALUES *pUmiProp = NULL;
    LPWSTR              pszUserName = NULL;

    ADsAssert(ppszUserName != NULL);

    *ppszUserName = NULL;

    hr = m_pIUmiPropList->Get(
                TEXT(CONN_INTF_PROP_USERNAME),
                0,
                &pUmiProp
                );

    if(FAILED(hr)) {
    // shouldn't happen
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);
    }

    ADsAssert(UMI_TYPE_LPWSTR == pUmiProp->pPropArray->uType);
    ADsAssert(pUmiProp->pPropArray->pUmiValue != NULL);

    pszUserName = pUmiProp->pPropArray->pUmiValue->pszStrValue[0];

    if(pszUserName != NULL) {
        *ppszUserName = AllocADsStr(pszUserName);
        if(NULL == *ppszUserName)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    }
    else
        *ppszUserName = NULL;

error:

    if(pUmiProp != NULL)
        m_pIUmiPropList->FreeMemory(0, pUmiProp); // ignore error return

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   GetPassword
//
// Synopsis:   Gets the password from the interface property cache. If the
//             interface property was not set, the default password is 
//             returned. 
//
// Arguments:
//
// ppszPassword Returns pointer to the password 
//
// Returns:     UMI_S_NO_ERROR on success.  Error code otherwise.
//
// Modifies:    *ppszPassword to return the password. 
//
//----------------------------------------------------------------------------
HRESULT CUmiConnection::GetPassword(LPWSTR *ppszPassword)
{
    HRESULT             hr = UMI_S_NO_ERROR;
    UMI_PROPERTY_VALUES *pUmiProp = NULL;
    LPWSTR              pszPassword = NULL;

    ADsAssert(ppszPassword != NULL);

    *ppszPassword = NULL;

    hr = m_pCUmiPropList->GetHelper(
                TEXT(CONN_INTF_PROP_PASSWORD),
                0,
                &pUmiProp,
                UMI_TYPE_NULL, // no-op
                TRUE           // this is an internal call to GetHelper
                );

    if(FAILED(hr)) {
    // shouldn't happen
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);
    }

    ADsAssert(UMI_TYPE_LPWSTR == pUmiProp->pPropArray->uType);
    ADsAssert(pUmiProp->pPropArray->pUmiValue != NULL);

    pszPassword = pUmiProp->pPropArray->pUmiValue->pszStrValue[0];

    if(pszPassword != NULL) { 
        *ppszPassword = AllocADsStr(pszPassword);
        if(NULL == *ppszPassword)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    }
    else
        *ppszPassword = NULL;

error:

    if(pUmiProp != NULL)
        m_pCUmiPropList->FreeMemory(0, pUmiProp); // ignore error return

    RRETURN(hr);
}
    

//----------------------------------------------------------------------------
// Function:   GetBindFlags
//
// Synopsis:   Gets the bind flags from the interface property cache. If the
//             interface properties were not set, the default bind flags are
//             returned.
//
// Arguments:
//
// pdwBindFlags Returns the bind flags. 
//
// Returns:     UMI_S_NO_ERROR on success.  Error code otherwise.
//
// Modifies:    *pdwBindFlags to return the bind flags. 
//
//----------------------------------------------------------------------------
HRESULT CUmiConnection::GetBindFlags(DWORD *pdwBindFlags)
{   
    HRESULT             hr = UMI_S_NO_ERROR;
    UMI_PROPERTY_VALUES *pUmiProp = NULL;
    DWORD               dwUmiBindFlags = 0;

    ADsAssert(pdwBindFlags != NULL);

    hr = m_pIUmiPropList->Get(
                TEXT(CONN_INTF_PROP_SECURE_AUTH),
                0,
                &pUmiProp
                );

    if(SUCCEEDED(hr)) {
        ADsAssert(UMI_TYPE_BOOL == pUmiProp->pPropArray->uType);
        ADsAssert(pUmiProp->pPropArray->pUmiValue != NULL);

        if(TRUE == pUmiProp->pPropArray->pUmiValue->bValue[0])
            dwUmiBindFlags |= ADS_SECURE_AUTHENTICATION;

        m_pIUmiPropList->FreeMemory(0, pUmiProp); // ignore error return
        pUmiProp = NULL;
    }
    else 
    // shouldn't happen 
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);    

    hr = m_pIUmiPropList->Get(
                TEXT(CONN_INTF_PROP_READONLY_SERVER),
                0,
                &pUmiProp
                );

    if(SUCCEEDED(hr)) {
        ADsAssert(UMI_TYPE_BOOL == pUmiProp->pPropArray->uType);
        ADsAssert(pUmiProp->pPropArray->pUmiValue != NULL);

        if(TRUE == pUmiProp->pPropArray->pUmiValue->bValue[0])
            dwUmiBindFlags |= ADS_READONLY_SERVER;

        m_pIUmiPropList->FreeMemory(0, pUmiProp); // ignore error return
        pUmiProp = NULL;
    }
    else 
    // shouldn't happen 
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);     

    *pdwBindFlags = dwUmiBindFlags;

error:

    if(pUmiProp != NULL)
        m_pIUmiPropList->FreeMemory(0, pUmiProp); // ignore error return

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   CheckObject 
//
// Synopsis:   Checks that the returned object is the same as what the user
//             requested, if the user passed in a UMI path i.e the classes 
//             of the components in the UMI path to the  object retrieved
//             should be the same as what the user requested. 
//             This function also checks to make sure that subsequent calls to
//             Open(), after the first call, specify the same server/domain
//             as the first call. If the path used in the first call to Open()
//             specifies only a domain name, then all subsequent Open() calls
//             should also specify only a domain name and no computer name.
//             If the first call to Open() specified only a computer name, then
//             all subsequent calls should specify the same computer name. If
//             the first call to Open specified the WinNT namespace path
//             (umi:///winnt or WinNT:), then subsequent Open() calls can 
//             connect to any domain/computer. Also, the namespace object can
//             be opened successfully even if we already connected to a 
//             computer/domain.
//
// Arguments:
//
// pUnknown    Pointer to the IUnknown of object retrieved
// dwNumComps  Number of components if the path is a UMI path. 0 otherwise.
// ppszClasses Array containing the class of each component, if the path is
//             a UMI path to an object other than the namespace obejct. 
//             NULL otherwise. 
//
// Returns:    S_OK on success.  Error code otherwise.
//
// Modifies:   Nothing 
//
//----------------------------------------------------------------------------
HRESULT CUmiConnection::CheckObject(
    IUnknown   *pUnknown,
    DWORD      dwNumComps,
    LPWSTR     *ppszClasses
    )
{
    HRESULT         hr = S_OK;
    IUmiADSIPrivate *pUmiPrivate = NULL;
    CCoreADsObject  *pCoreObj = NULL;
    LPWSTR          pszComputerName = NULL, pszDomainName = NULL;
    DWORD           dwIndex = 0, dwCoreIndex = 0;

    ADsAssert(pUnknown != NULL);

    hr = pUnknown->QueryInterface(
            IID_IUmiADSIPrivate,
            (LPVOID *) &pUmiPrivate
            );
    BAIL_ON_FAILURE(hr);

    hr = pUmiPrivate->GetCoreObject((void **) &pCoreObj);
    BAIL_ON_FAILURE(hr);

    if(ppszClasses != NULL) {
    // user specified a UMI path and it was not umi:///winnt. Make sure the 
    // classes are the same, as mentioned above.

        // walk the list of classes in reverse order. Reason for reverse order
        // is that the WinNT provider may tack on an additional component to
        // the ADsPath stored in the core object. For example, 
        // Open("WinNT://ntdsdc1") would return an ADsPath of 
        // "WinNT://ntdev/ntdsdc1".

        dwCoreIndex = pCoreObj->_dwNumComponents - 1;
        for(dwIndex = dwNumComps - 1; ((long) dwIndex) >= 0; dwIndex--) {
            if( _wcsicmp(
                  ppszClasses[dwIndex], 
                  pCoreObj->_CompClasses[dwCoreIndex]) ) {
                
                if( (0 == dwIndex) && (dwNumComps > 1) ) {

                    if(0 == _wcsicmp(pCoreObj->_CompClasses[1], 
                                     SCHEMA_CLASS_NAME)) {
                    // if the first component of a schema path doesn't match,
                    // make sure it is "Domain". Need this special case because
                    // of a bug in the WinNT provider. First component of a
                    // schema path is ignored and hence the UMI path always
                    // returns "Computer" as the class for this component. This
                    // special case allows binding using a path like 
                    // umi://winnt/domain=ntdev/schema=schema.
                        if(0 == _wcsicmp(ppszClasses[dwIndex], 
                                         DOMAIN_CLASS_NAME)) {
                            dwCoreIndex--;
                            continue;
                        }
                    }
                } 

                BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);
            }

            dwCoreIndex--;
        }
    } // if(ppszClasses...)
                        
    // get the domain/computer name specified in the path
    if(pCoreObj->_dwNumComponents > 0) {
        for(dwIndex = pCoreObj->_dwNumComponents - 1; ((long) dwIndex) >= 0; 
                      dwIndex--) {
            if(0 == (_wcsicmp(
                    pCoreObj->_CompClasses[dwIndex],
                    SCHEMA_CLASS_NAME)) ) {
            // schema container is a special case. We can connect to the
            // schema on any computer/domain irrespective of where we are
            // connected currently. This is to allow for CIMOM to connect to
            // the schema container for a computer. Currently, the WinNT
            // provider returns WinNT://ntdev/schema as the schema path on the
            // object WinNT://ntdsdc1. Hence we need to allow CIMOM to connect
            // to ntdev even after connecting to ntdsdc1. 

                break; // pszComputerName and pszDomainName are both NULL
            }

            if(0 == (_wcsicmp(
                    pCoreObj->_CompClasses[dwIndex],
                    COMPUTER_CLASS_NAME)) ) {
                pszComputerName = 
                    pCoreObj->_ObjectInfo.DisplayComponentArray[dwIndex];
                break;
            }
            else if(0 == (_wcsicmp(
                    pCoreObj->_CompClasses[dwIndex],
                    DOMAIN_CLASS_NAME)) ) {
                pszDomainName = 
                    pCoreObj->_ObjectInfo.DisplayComponentArray[dwIndex];
                break;
            }
        } // for(..)
    } // if(pCoreObj...)

    if(FALSE == m_fAlreadyOpened) {
    // first call to Open()
        if(pszComputerName != NULL) {
            m_pszComputerName = AllocADsStr(pszComputerName);
            if(NULL == m_pszComputerName) {
                BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
            }
        }
        else if(pszDomainName != NULL) {
            m_pszDomainName = AllocADsStr(pszDomainName);
            if(NULL == m_pszDomainName) {
                BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
            }
        }

        m_fAlreadyOpened = TRUE;
    }
    else if( (pszComputerName != NULL) || (pszDomainName != NULL) ) {
    // Already opened connection and this is not the namespace object.
    // Make sure that the domain/computer is same as before.

        if(m_pszComputerName != NULL) {
            if( (NULL == pszComputerName) ||
                    (_wcsicmp(m_pszComputerName, pszComputerName)) ) {
                BAIL_ON_FAILURE(hr = UMI_E_MISMATCHED_SERVER);
            }
        }
        else if(m_pszDomainName != NULL) {
            if( (NULL == pszDomainName) ||
                    (_wcsicmp(m_pszDomainName, pszDomainName)) ) {
                BAIL_ON_FAILURE(hr = UMI_E_MISMATCHED_DOMAIN);
            }
        }
        else {
        // both m_pszComputerName and m_pszDomainName are NULL. Previous 
        // open() must have been for a namespace object.
            if(pszComputerName != NULL) {
                m_pszComputerName = AllocADsStr(pszComputerName);
                if(NULL == m_pszComputerName) {
                    BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
                }
            }
            else if(pszDomainName != NULL) {
                m_pszDomainName = AllocADsStr(pszDomainName);
                if(NULL == m_pszDomainName) {
                    BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
                }
            }
        } // else {

    } // else if(pszComputer...)

error:

    if(pUmiPrivate != NULL)
        pUmiPrivate->Release();

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cuoi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuas.cxx
//
//  Contents:  User Object Account Statistics FunctionalSet
//
//  History:   11-1-95     krishnag    Created.
//
//
//    PROPERTY_RO(AccountExpiration, DATE, 1)       Implemented
//    PROPERTY_RO(BadLoginAddress, BSTR, 2)         NI
//    PROPERTY_RO(BadLoginCount, long, 3)           NI
//    PROPERTY_RO(BadPasswordAttempts, long, 4)     Implemented
//    PROPERTY_RO(LastLogin, DATE, 5)               Implemented
//    PROPERTY_RO(LastLogoff, DATE, 6)              Implemented
//    PROPERTY_RO(LastFailedLogin, DATE, 7)         NI
//    PROPERTY_RO(PasswordLastChanged, DATE, 8)     Implemented
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


//  Class CWinNTUser


STDMETHODIMP CWinNTUser::get_EmailAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, EmailAddress);
}

STDMETHODIMP CWinNTUser::put_EmailAddress(THIS_ BSTR bstrEmailAddress)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, EmailAddress);
}

STDMETHODIMP CWinNTUser::get_HomeDirectory(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, HomeDirectory);

}

STDMETHODIMP CWinNTUser::put_HomeDirectory(THIS_ BSTR bstrHomeDirectory)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, HomeDirectory);
}


STDMETHODIMP CWinNTUser::get_Languages(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, Languages);

}

STDMETHODIMP CWinNTUser::put_Languages(THIS_ VARIANT vLanguages)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, Languages);
}

STDMETHODIMP CWinNTUser::get_Profile(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Profile);

}

STDMETHODIMP CWinNTUser::put_Profile(THIS_ BSTR bstrProfile)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Profile);
}

STDMETHODIMP CWinNTUser::get_LoginScript(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, LoginScript);

}

STDMETHODIMP CWinNTUser::put_LoginScript(THIS_ BSTR bstrLoginScript)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, LoginScript);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cumicurs.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     cumicurs.cxx
//
//  Contents: Contains the UMI cursor object implementation
//
//  History:  03-16-00    SivaramR  Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"

//----------------------------------------------------------------------------
// Function:   CreateCursor
//
// Synopsis:   Creates a cursor object. Called by IUmiContainer::CreateEnum(). 
//
// Arguments:
//
// pCredentials Credentials of the UMI object creating the cursor
// pCont       Pointer to container on which CreateEnum was called
// iid         Interface requested. Only interface supported is IUmiCursor.
// ppInterface Returns pointer to interface requested
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return a pointer to the interface requested
//
//----------------------------------------------------------------------------
HRESULT CUmiCursor::CreateCursor(
    CWinNTCredentials *pCredentials,
    IUnknown *pCont,
    REFIID iid,
    LPVOID *ppInterface
    )
{
    CUmiCursor *pCursor = NULL;
    HRESULT    hr = S_OK;

    ADsAssert(ppInterface != NULL);
    ADsAssert(pCont != NULL);

    pCursor = new CUmiCursor();
    if(NULL == pCursor)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    // initialize cursor object
    hr = pCursor->FInit(pCont, pCredentials);
    BAIL_ON_FAILURE(hr);

    hr = pCursor->QueryInterface(iid, ppInterface);
    BAIL_ON_FAILURE(hr);

    pCursor->Release();

    RRETURN(S_OK);

error:

    if(pCursor != NULL)
        delete pCursor;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   CUmiCursor
//
// Synopsis:   Constructor. Initializes all member variables
//
// Arguments:
//
// None
//
// Returns:    Nothing.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
CUmiCursor::CUmiCursor(void)
{
    m_pIUmiPropList = NULL;
    m_ulErrorStatus = 0;
    m_pUnkInner = NULL;
    m_pIID = NULL;
    m_pEnumerator = NULL;
}

//----------------------------------------------------------------------------
// Function:   ~CUmiCursor
//
// Synopsis:   Destructor. Frees member variables
//
// Arguments:
//
// None
//
// Returns:    Nothing.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
CUmiCursor::~CUmiCursor(void)
{
    if(m_pIUmiPropList != NULL)
        m_pIUmiPropList->Release();

    if(m_pUnkInner != NULL)
        m_pUnkInner->Release();

    if(m_pIID != NULL)
        FreeADsMem(m_pIID);

    if(m_pEnumerator != NULL)
        m_pEnumerator->Release();
}

//----------------------------------------------------------------------------
// Function:   FInit
//
// Synopsis:   Initializes cursor object.
//
// Arguments:
//
// pCont       Pointer to UMI container that created this cursor. 
// pCredentials Credentials of UMI object creating the cursor
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
HRESULT CUmiCursor::FInit(
    IUnknown *pCont,
    CWinNTCredentials *pCredentials
    )
{
    HRESULT      hr = S_OK;
    CUmiPropList *pPropList = NULL;

    ADsAssert(pCont != NULL);

    pPropList = new CUmiPropList(CursorClass, g_dwCursorTableSize);
    if(NULL == pPropList)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    hr = pPropList->FInit(NULL, NULL);
    BAIL_ON_FAILURE(hr);

    hr = pPropList->QueryInterface(
                IID_IUmiPropList,
                (void **) &m_pIUmiPropList
                );
    BAIL_ON_FAILURE(hr);

    // DECLARE_STD_REFCOUNTING initializes the refcount to 1. Call Release()
    // on the created object, so that releasing the interface pointer will
    // free the object.
    pPropList->Release();

    m_pUnkInner = pCont;
    pCont->AddRef();

    m_pCreds = pCredentials;

    RRETURN(S_OK);

error:

    if(m_pIUmiPropList != NULL) {
        m_pIUmiPropList->Release();
        m_pIUmiPropList = NULL;
    }

    if(pPropList != NULL)
        delete pPropList;
    
    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   Queries cursor object for supported interfaces. Only
//             IUmiCursor is supported.
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiCursor::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(NULL == ppInterface)
        RRETURN(E_INVALIDARG);

    *ppInterface = NULL;

    if(IsEqualIID(iid, IID_IUnknown))
        *ppInterface = (IUmiCursor *) this;
    else if(IsEqualIID(iid, IID_IUmiCursor))
        *ppInterface = (IUmiCursor *) this;
    else if(IsEqualIID(iid, IID_IUmiBaseObject))
        *ppInterface = (IUmiBaseObject *) this;
    else if(IsEqualIID(iid, IID_IUmiPropList))
        *ppInterface = (IUmiPropList *) this;
    else
         RRETURN(E_NOINTERFACE);

    AddRef();
    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
// Function:   GetLastStatus
//
// Synopsis:   Returns status or error code from the last operation. Currently
//             only numeric status is returned i.e, no error objects are
//             returned. Implements IUmiBaseObject::GetLastStatus().
//
// Arguments:
//
// uFlags           Reserved. Must be 0 for now.
// puSpecificStatus Returns status code
// riid             IID requested. Ignored currently.
// pStatusObj       Returns interface requested. Always returns NULL currently.
//
// Returns:         UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:        *puSpecificStatus to return status code.
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiCursor::GetLastStatus(
    ULONG uFlags,
    ULONG *puSpecificStatus,
    REFIID riid,
    LPVOID *pStatusObj
    )
{
    if(pStatusObj != NULL)
       *pStatusObj = NULL;

   if(puSpecificStatus != NULL)
       *puSpecificStatus = 0;

   if(uFlags != 0)
       RRETURN(UMI_E_INVALID_FLAGS);

    if(NULL == puSpecificStatus)
        RRETURN(UMI_E_INVALIDARG);

    *puSpecificStatus = m_ulErrorStatus;

    RRETURN(UMI_S_NO_ERROR);
}

//----------------------------------------------------------------------------
// Function:   GetInterfacePropList
//
// Synopsis:   Returns a pointer to the interface property list implementation
//             for the connection object. Implements
//             IUmiBaseObject::GetInterfacePropList().
//
// Arguments:
//
// uFlags      Reserved. Must be 0 for now.
// pPropList   Returns pointer to IUmiPropertyList interface
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pPropList to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiCursor::GetInterfacePropList(
    ULONG uFlags,
    IUmiPropList **pPropList
    )
{
    HRESULT hr = UMI_S_NO_ERROR;

    SetLastStatus(0);

    if(uFlags != 0)
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if(NULL == pPropList)
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    ADsAssert(m_pIUmiPropList != NULL);

    hr = m_pIUmiPropList->QueryInterface(IID_IUmiPropList, (void **)pPropList);

error:

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   SetLastStatus
//
// Synopsis:   Sets the status of the last operation.
//
// Arguments:
//
// ulStatus    Status to be set
//
// Returns:    Nothing
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
void CUmiCursor::SetLastStatus(ULONG ulStatus)
{
    m_ulErrorStatus = ulStatus;

    return;
}

//----------------------------------------------------------------------------
// Function:   SetIID 
//
// Synopsis:   Sets the interface to be requested off each item returned by
//             the enumerator. Default is IID_IUmiObject. 
//
// Arguments:
//
// riid        IID of interface to request
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   Nothing. 
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiCursor::SetIID(
    REFIID riid
    )
{
    SetLastStatus(0);

    if(NULL == m_pIID)
    {
       m_pIID = (IID *) AllocADsMem(sizeof(IID));
       if(NULL == m_pIID) {
           SetLastStatus(UMI_E_OUT_OF_MEMORY);
           RRETURN(UMI_E_OUT_OF_MEMORY);
       }
    }

    memcpy(m_pIID, &riid, sizeof(IID));

    RRETURN(UMI_S_NO_ERROR);
}

//----------------------------------------------------------------------------
// Function:   Reset 
//
// Synopsis:   Resets the enumerator to start from the beginning 
//
// Arguments:
//
// None
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiCursor::Reset(void)
{
    HRESULT hr = UMI_S_NO_ERROR;

    SetLastStatus(0);

    // WinNT doesn't support Reset(). Keep the code below in case WinNT
    // Reset() gets implemented in the future. 
    BAIL_ON_FAILURE(hr = UMI_E_NOTIMPL); 

    // it is possible that m_pEnumerator may be NULL here if the user
    // called Reset before calling Next()
    if(NULL == m_pEnumerator)
        RRETURN(UMI_S_NO_ERROR);

    hr = m_pEnumerator->Reset();
    BAIL_ON_FAILURE(hr);

    RRETURN(UMI_S_NO_ERROR);

error:

    SetLastStatus(hr);
    
    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   GetFilter
//
// Synopsis:   Gets the filter from the interface property cache. If the
//             interface property was not set, an emty variant is returned. 
//
// Arguments:
//
// pvFilter    Returns variant containing the filter 
//
// Returns:    UMI_S_NO_ERROR on success.  Error code otherwise.
//
// Modifies:   *pvFilter to return the filter. 
//
//----------------------------------------------------------------------------
HRESULT CUmiCursor::GetFilter(VARIANT *pvFilter)
{
    HRESULT             hr = UMI_S_NO_ERROR;
    UMI_PROPERTY_VALUES *pUmiProp = NULL;
    LPWSTR              *ppszFilters = NULL;
    DWORD               dwNumFilters = 0;

    ADsAssert(pvFilter != NULL);

    VariantInit(pvFilter);

    hr = m_pIUmiPropList->Get(
                TEXT(CURSOR_INTF_PROP_FILTER),
                0,
                &pUmiProp
                );

    if(UMI_E_PROPERTY_NOT_FOUND == hr) 
    // interface property was not set. Return empty variant. 
        RRETURN(UMI_S_NO_ERROR);

    // check if there was some other error on Get()
    BAIL_ON_FAILURE(hr);

    ADsAssert(UMI_TYPE_LPWSTR == pUmiProp->pPropArray->uType);
    ADsAssert(pUmiProp->pPropArray->pUmiValue != NULL);

    ppszFilters = pUmiProp->pPropArray->pUmiValue->pszStrValue;
    dwNumFilters = pUmiProp->pPropArray->uCount;

    hr = ADsBuildVarArrayStr(ppszFilters, dwNumFilters, pvFilter);
    BAIL_ON_FAILURE(hr);

error:

    if(pUmiProp != NULL)
        m_pIUmiPropList->FreeMemory(0, pUmiProp); // ignore error return
   
    RRETURN(hr);
} 

//----------------------------------------------------------------------------
// Function:   Next 
//
// Synopsis:   Returns the next item(s) in the enumeration sequence.
//
// Arguments:
//
// uNumRequested Number of items requested
// pNumReturned  Returns actual number of objects returned
// ppObjects     Array of interface pointers of size *pNumReturned
//
// None
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pNumReturned to return the number of objects returned
//             *ppObjects to return the interface pointers 
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiCursor::Next(
    ULONG uNumRequested,
    ULONG *puNumReturned,
    LPVOID *ppObjects
    )
{
    HRESULT   hr = UMI_S_NO_ERROR;
    VARIANT   vFilter, *pvResults = NULL;
    ULONG     ulIndex = 0, uNumReturned = 0, uNumResults = 0;
    IDispatch *pDisp = NULL;
    IUnknown  **pUnkArr = NULL, *pTmpUnk = NULL;
    IADsContainer *pIADsContainer = NULL;

    SetLastStatus(0);

    if( (NULL == puNumReturned) || (NULL == ppObjects) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    *puNumReturned = 0;
    *ppObjects = NULL;

    VariantInit(&vFilter);

    if(NULL == m_pEnumerator) {
    // first call to Next()

        ADsAssert(m_pUnkInner != NULL);

        hr = m_pUnkInner->QueryInterface(
                             IID_IADsContainer,
                             (void **) &pIADsContainer
                             );
        BAIL_ON_FAILURE(hr);

        // check if the user set a filter on the cursor 
        hr = GetFilter(&vFilter);
        BAIL_ON_FAILURE(hr);

        hr = pIADsContainer->put_Filter(vFilter);
        BAIL_ON_FAILURE(hr);

        m_pCreds->SetUmiFlag();

        hr = pIADsContainer->get__NewEnum((IUnknown **) &m_pEnumerator);

        m_pCreds->ResetUmiFlag();

        BAIL_ON_FAILURE(hr);
    }

    // allocate memory for variants to return objects
    pvResults = (VARIANT *) AllocADsMem(uNumRequested * sizeof(VARIANT));
    if(NULL == pvResults)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    hr = m_pEnumerator->Next(
        uNumRequested,
        pvResults,
        &uNumReturned
        );
    BAIL_ON_FAILURE(hr);

    // allocate memory for array of interface pointers to return
    pUnkArr = (IUnknown **) AllocADsMem(uNumReturned * sizeof(IUnknown *));
    if(NULL == pUnkArr)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    // convert the V_DISPATCH variants to the requested interface properties
    for(ulIndex = 0; ulIndex < uNumReturned; ulIndex++) {

        pDisp = V_DISPATCH(&pvResults[ulIndex]);
        ADsAssert(pDisp != NULL);

        if(m_pIID != NULL)
            hr = pDisp->QueryInterface(*m_pIID, (void **) &pTmpUnk);
        else
            hr = pDisp->QueryInterface(IID_IUmiObject, (void **) &pTmpUnk);

        if(FAILED(hr))
            continue;

        pUnkArr[uNumResults] = pTmpUnk;
        uNumResults++;
    }

    *puNumReturned = uNumResults;
    if(uNumResults > 0)
        *ppObjects = pUnkArr;
    else
        FreeADsMem(pUnkArr);
       
error:

    VariantClear(&vFilter);

    if(pvResults != NULL) {
        for(ulIndex = 0; ulIndex < uNumReturned; ulIndex++) 
            VariantClear(&pvResults[ulIndex]);

        FreeADsMem(pvResults);
    }

    if(pIADsContainer != NULL)
        pIADsContainer->Release();
            
    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}    

//----------------------------------------------------------------------------
// Function:   Count 
//
// Synopsis:   Counts the number of results returned by the enumerator.
//             Not implemented currently.
//
// Arguments:
//
// None
//
// Returns:    UMI_E_NOTIMPL for now.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiCursor::Count(
    ULONG *puNumObjects
    )
{
    SetLastStatus(UMI_E_NOTIMPL);

    RRETURN(UMI_E_NOTIMPL);
}       

//----------------------------------------------------------------------------
// Function:   Previous 
//
// Synopsis:   Returnss the previous object returned by the enumerator.
//             Not implemented currently.
//
// Arguments:
//
// None
//
// Returns:    UMI_E_NOTIMPL for now.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiCursor::Previous(
    ULONG uFlags,
    LPVOID *pObj 
    )
{
    SetLastStatus(UMI_E_NOTIMPL);

    RRETURN(UMI_E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cusers.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:  cusers.cxx
//
//  Contents:  User Groups collection
//
//  History:   08-08-96     t-danal    Created from cgroups.cxx
//
//----------------------------------------------------------------------------

#include "procs.hxx"
#pragma hdrstop
#include "winnt.hxx"

//  Class CWinNTUserGroupsCollection

DEFINE_IDispatch_Implementation(CWinNTUserGroupsCollection)


CWinNTUserGroupsCollection::CWinNTUserGroupsCollection():
        _ParentType(0),
        _ParentADsPath(NULL),
        _DomainName(NULL),
        _ServerName(NULL),
        _UserName(NULL),
        _pDispMgr(NULL)
{
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CWinNTUserGroupsCollection);
}

CWinNTUserGroupsCollection::~CWinNTUserGroupsCollection( )
{
    if (_ParentADsPath)
        ADsFreeString(_ParentADsPath);
    if (_DomainName)
        ADsFreeString(_DomainName);
    if (_ServerName)
        ADsFreeString(_ServerName);
    if (_UserName)
        ADsFreeString(_UserName);
    VariantClear(&_vFilter);
    delete _pDispMgr;
}

HRESULT
CWinNTUserGroupsCollection::CreateUserGroupsCollection(
    ULONG ParentType,
    BSTR ParentADsPath,
    BSTR DomainName,
    BSTR ServerName,
    BSTR UserName,
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTUserGroupsCollection FAR * pUserGroups = NULL;
    HRESULT hr = S_OK;

    hr = AllocateUserGroupsCollectionObject(&pUserGroups);
    BAIL_ON_FAILURE(hr);

    ADsAssert(pUserGroups);

    pUserGroups->_ParentType = ParentType;

    hr = ADsAllocString( ParentADsPath, &pUserGroups->_ParentADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(DomainName, &pUserGroups->_DomainName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ServerName , &pUserGroups->_ServerName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(UserName, &pUserGroups->_UserName);
    BAIL_ON_FAILURE(hr);
    
    pUserGroups->_Credentials = Credentials;
    hr = pUserGroups->_Credentials.Ref(ServerName, DomainName, ParentType);
    BAIL_ON_FAILURE(hr);


    hr = pUserGroups->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pUserGroups->Release();
    RRETURN(hr);

error:
    delete pUserGroups;

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTUserGroupsCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsMembers))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTUserGroupsCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsMembers)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP
CWinNTUserGroupsCollection::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTUserGroupsCollection::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CWinNTUserGroupsCollection::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr = VariantClear(&_vFilter);
    if (FAILED(hr))
        RRETURN_EXP_IF_ERR(hr);
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUserGroupsCollection::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;

    *retval = NULL;

    hr = CWinNTUserGroupsCollectionEnum::Create(
                (CWinNTUserGroupsCollectionEnum **)&penum,
                _ParentType,
                _ParentADsPath,
                _DomainName,
                _ServerName,
                _UserName,
                _vFilter,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:
    if (penum) {
        delete penum;
    }
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTUserGroupsCollection::AllocateUserGroupsCollectionObject(
    CWinNTUserGroupsCollection ** ppUserGroups
    )
{
    CWinNTUserGroupsCollection FAR * pUserGroups = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pUserGroups = new CWinNTUserGroupsCollection();
    if (pUserGroups == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsMembers,
                           (IADsMembers *)pUserGroups,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pUserGroups->_pDispMgr = pDispMgr;
    *ppUserGroups = pUserGroups;

    RRETURN(hr);

error:
    delete  pDispMgr;
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cumiobj.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     cumiobj.cxx
//
//  Contents: Contains the implementation of IUmiObject. The methods are
//            encapsulated in one object. This object holds a pointer to 
//            the inner unknown of the corresponding WinNT object. 
//            The methods of IUmiContainer are also implemented on this 
//            same object, but will only be used if the underlying WinNT
//            object is a container. 
//
//  History:  03-06-00    SivaramR  Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"

//----------------------------------------------------------------------------
// Function:   CUmiObject
//
// Synopsis:   Constructor. Initializes member variable. 
//
// Arguments:  None 
//
// Returns:    Nothing
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
CUmiObject::CUmiObject(void)
{
    m_pIntfProps = NULL;
    m_pObjProps = NULL;
    m_pUnkInner = NULL;
    m_pIADs = NULL;
    m_pIADsContainer = NULL;
    m_ulErrorStatus = 0;
    m_pCoreObj = NULL;
    m_pExtMgr = NULL;
    m_fOuterUnkSet = FALSE;
    m_pPropCache = NULL;
    m_fRefreshDone = FALSE;
}

//----------------------------------------------------------------------------
// Function:   ~CUmiObject
//
// Synopsis:   Destructor. Frees member variables. 
//
// Arguments:  None
//
// Returns:    Nothing
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
CUmiObject::~CUmiObject(void)
{
    if(m_pIntfProps != NULL)
        m_pIntfProps->Release();

    if(m_pObjProps != NULL)
        delete m_pObjProps;

    if(m_pUnkInner != NULL)
        m_pUnkInner->Release(); 

    //
    // m_pIADs and m_pIADsContainer may now delegate to an outer unknown if
    // if the ADSI object has been aggregated in GetObjectByCLSID
    // subsequent to creation. Hence, we should not call Release() on either
    // of these pointers. Instead, call Release() on m_pUnkInner since this
    // is guaranteed to be a pointer to the non-delegating IUnknown.
    //
    if(m_pIADsContainer != NULL)
        m_pUnkInner->Release();

    if(m_pIADs != NULL)
        m_pUnkInner->Release();

    if(m_pPropCache != NULL)
        delete m_pPropCache;
}

//----------------------------------------------------------------------------
// Function:   FInit
//
// Synopsis:   Initializes UMI object. 
//
// Arguments: 
//
// Credentials  Credentials stored in the underlying WinNT object
// pSchema      Pointer to schema for this object
// dwSchemaSize Size of schema array 
// pPropCache   Pointer to property cache for this object
// pUnkInner    Pointer to inner unknown of underlying WinNT object
// pExtMgr      Pointer to extension manager of underlying WinNT object
// pCoreObj     Pointer to the core object of underlying WinNT object
// pClassInfo   Pointer to class information if this object is a class object.
//              NULL otherwise.
//
// Returns:     S_OK on success. Error code otherwise. 
//
// Modifies:    Nothing
//
//----------------------------------------------------------------------------
HRESULT CUmiObject::FInit(
    CWinNTCredentials& Credentials,
    PPROPERTYINFO pSchema,
    DWORD dwSchemaSize,
    CPropertyCache *pPropertyCache,
    IUnknown *pUnkInner,
    CADsExtMgr *pExtMgr,
    CCoreADsObject *pCoreObj,
    CLASSINFO *pClassInfo
    )
{
    HRESULT      hr = S_OK;
    CUmiPropList *pIntfProps = NULL;

    ADsAssert(pCoreObj != NULL); // extension manager may be NULL for some 
                                 // WinNT objects

    if(pPropertyCache != NULL) {
    // some WinNT objects don't have a property cache associated with them.
    // Namespace and schema objects are examples. For these, we might 
    // create a proeprty cache in the 'else' clause below. Otherwise, we 
    // return UMI_E_NOTIMPL from IUmiPropList methods since m_pObjProps will be
    // NULL for these objects. 
        ADsAssert( (pSchema != NULL) && (dwSchemaSize > 0) && 
               (pUnkInner != NULL) );

        // Initialize property list for object properties 
        m_pObjProps = new CUmiPropList(pSchema, dwSchemaSize);
        if(NULL == m_pObjProps)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        hr = m_pObjProps->FInit(pPropertyCache, NULL);
        BAIL_ON_FAILURE(hr);
    }
    else if(pSchema != NULL) {
    // Property, class, schema and syntax objects do not have a cache 
    // associated with them. But, they support a number of properties through
    // IDispatch. We want to expose these through UMI. So create a property
    // cache and populate it with these read-only properties. Thus,
    // m_pObjProps will be NULL only for namespace objects.

        ADsAssert( (pUnkInner != NULL) && (dwSchemaSize > 0) ); 

        hr = CreateObjectProperties(
                pSchema, 
                dwSchemaSize, 
                pUnkInner,
                pCoreObj
                );
        BAIL_ON_FAILURE(hr);
    }

    // Initialize property list for interface properties
    pIntfProps = new CUmiPropList(ObjClass, g_dwObjClassSize);
    if(NULL == pIntfProps)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    hr = pIntfProps->FInit(NULL, g_UmiObjUnImplProps);
    BAIL_ON_FAILURE(hr); 

    hr = pIntfProps->QueryInterface(
                IID_IUmiPropList,
                (void **) &m_pIntfProps
                );
    BAIL_ON_FAILURE(hr);

    // DECLARE_STD_REFCOUNTING initializes the refcount to 1. Call Release()
    // on the created object, so that releasing the interface pointer will
    // free the object.
    pIntfProps->Release();

    m_pUnkInner = pUnkInner;

    // Get pointers to IADs and IADsContainer interfaces on WinNT object
    hr = m_pUnkInner->QueryInterface(
                   IID_IADsContainer,
                   (void **) &m_pIADsContainer
                   );

    if(FAILED(hr))
        m_pIADsContainer = NULL;

    hr = m_pUnkInner->QueryInterface(
                   IID_IADs,
                   (void **) &m_pIADs
                   );

    if(FAILED(hr))
        m_pIADs = NULL;
    else {
        hr = pIntfProps->SetStandardProperties(m_pIADs, pCoreObj);
        BAIL_ON_FAILURE(hr);
    }

    pIntfProps->SetClassInfo(pClassInfo);

    // set the property count in the interface property cache
    hr = pIntfProps->SetPropertyCount(dwSchemaSize);
    BAIL_ON_FAILURE(hr);

    m_pExtMgr = pExtMgr;
    m_pCoreObj = pCoreObj;
    m_pCreds = &Credentials;

    RRETURN(S_OK);

error:

    if(m_pObjProps != NULL)
        delete m_pObjProps;

    if(m_pIntfProps != NULL)
        m_pIntfProps->Release();
    else if(pIntfProps != NULL)
        delete pIntfProps;        

    if(m_pIADsContainer != NULL)
        m_pIADsContainer->Release();

    if(m_pIADs != NULL)
        m_pIADs->Release();

    // make sure destructor doesn't free these again
    m_pObjProps = NULL;
    m_pIntfProps = NULL;
    m_pIADsContainer = NULL;
    m_pIADs = NULL;
    m_pUnkInner = NULL;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   CreateObjectProperties 
//
// Synopsis:   Creates a property cache and populates it with the properties
//             supported on the WinNT object's IDispatch interface. This is
//             used to expose properties on property, class and syntax objects
//             through UMI.  
//
// Arguments:
//
// pSchema      Pointer to schema for this object
// dwSchemaSize Size of schema array
// pUnkInner    Pointer to inner unknown of underlying WinNT object
// pCoreObj     Pointer to the core object of the WinNT object
//
// Returns:     S_OK on success. Error code otherwise.
//
// Modifies:    Nothing
//
//----------------------------------------------------------------------------
HRESULT CUmiObject::CreateObjectProperties(
    PPROPERTYINFO pSchema,
    DWORD dwSchemaSize,
    IUnknown *pUnkInner,
    CCoreADsObject *pCoreObj
    )
{
    HRESULT    hr = S_OK;
    IDispatch  *pDispatch = NULL;
    DWORD      dwIndex = 0; 
    DISPID     DispId;
    DISPPARAMS DispParams = {NULL, NULL, 0, 0};
    VARIANT    var;
    CPropertyCache *pPropCache = NULL;

    ADsAssert( (pSchema != NULL) && (dwSchemaSize > 0) && 
               (pUnkInner != NULL) && (pCoreObj != NULL) );
   
    hr = CPropertyCache::createpropertycache(
            pSchema,
            dwSchemaSize,
            pCoreObj,
            &pPropCache);
    BAIL_ON_FAILURE(hr);

    hr = pUnkInner->QueryInterface(
        IID_IDispatch,
        (void **) &pDispatch
        );
    BAIL_ON_FAILURE(hr);

    for(dwIndex = 0; dwIndex < dwSchemaSize; dwIndex++) {
        hr = pDispatch->GetIDsOfNames(
                IID_NULL,
                &pSchema[dwIndex].szPropertyName,
                1,
                LOCALE_SYSTEM_DEFAULT,
                &DispId
                );
        BAIL_ON_FAILURE(hr);

        hr = pDispatch->Invoke(
                DispId,
                IID_NULL,
                LOCALE_SYSTEM_DEFAULT,
                DISPATCH_PROPERTYGET,
                &DispParams,
                &var,
                NULL,
                NULL
                );
        BAIL_ON_FAILURE(hr);

        hr = GenericPutPropertyManager(
                pPropCache,
                pSchema,
                dwSchemaSize,
                pSchema[dwIndex].szPropertyName,
                var,
                FALSE
                );

        VariantClear(&var);

        // If there is a multivalued ADSI interface property that has no values
        // (such as MandatoryProperties/Containment on a schema object), the 
        // call to Invoke above returns a variant which has a safearray with 
        // 0 elements in it. The call to GenericPutPropertyManager will fail
        // with E_ADS_BAD_PARAMETER in this case. In this case, don't store
        // anything in the property cache for this property. Trying to fetch
        // it later will return UMI_E_NOT_FOUND. 
 
        if(hr != E_ADS_BAD_PARAMETER)
            BAIL_ON_FAILURE(hr);
    }

    // Mark all properties as "not modified", since the client really hasn't
    // updated the cache, though we have.
    pPropCache->ClearModifiedFlags();
     
    // Initialize property list for object properties
    m_pObjProps = new CUmiPropList(pSchema, dwSchemaSize);
    if(NULL == m_pObjProps)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    hr = m_pObjProps->FInit(pPropCache, NULL);
    BAIL_ON_FAILURE(hr);
   
    m_pPropCache = pPropCache; 
    pDispatch->Release();
 
    RRETURN(S_OK);

error:

    if(pPropCache != NULL)
        delete pPropCache;

    if(pDispatch != NULL)
        pDispatch->Release();

    if(m_pObjProps != NULL) {
        delete m_pObjProps;
        m_pObjProps = NULL;
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   QueryInterface 
//
// Synopsis:   Implements QI for the UMI object.  
//
// Arguments
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    HRESULT  hr = S_OK;
    IUnknown *pTmpIntfPtr = NULL;

    if(NULL == ppInterface)
        RRETURN(E_INVALIDARG); 

    *ppInterface = NULL;

    if(IsEqualIID(iid, IID_IUnknown))
        *ppInterface = (IUmiObject *) this;
    else if(IsEqualIID(iid, IID_IUmiObject))
        *ppInterface = (IUmiObject *) this;
    else if(IsEqualIID(iid, IID_IUmiContainer)) {
   // check if underlying WinNT object is a container
        if(m_pIADsContainer != NULL)
            *ppInterface = (IUmiContainer *) this;
        else
            RRETURN(E_NOINTERFACE);
    }
    else if(IsEqualIID(iid, IID_IUmiBaseObject))
        *ppInterface = (IUmiBaseObject *) this;
    else if(IsEqualIID(iid, IID_IUmiPropList))
        *ppInterface = (IUmiPropList *) this;
    else if(IsEqualIID(iid, IID_IUmiCustomInterfaceFactory)) 
        *ppInterface = (IUmiCustomInterfaceFactory *) this;
    else if(IsEqualIID(iid, IID_IUmiADSIPrivate))
        *ppInterface = (IUmiADSIPrivate *) this;
    else
        RRETURN(E_NOINTERFACE);

    AddRef();
    RRETURN(S_OK);
}
        
//----------------------------------------------------------------------------
// Function:   Clone 
//
// Synopsis:   Implements IUmiObject::Clone. Creates a new uncommitted object
//             and copies over all properties from the source to destination.
//             The source may be Refresh()ed if necessary.  
//
// Arguments
//
// uFlags      Flags for Clone(). Must be 0 for now.
// riid        Interface ID requested on the cloned object
// pCopy       Returns interface pointer requested 
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise. 
//
// Modifies:   *pCopy to return the interface requested. 
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::Clone(
    ULONG uFlags,
    REFIID riid,
    LPVOID *pCopy
    )
{
    HRESULT       hr = UMI_S_NO_ERROR;
    BSTR          bstrADsPath = NULL, bstrParent = NULL;
    BSTR          bstrClass = NULL, bstrName = NULL;
    IUnknown      *pUnknown = NULL, *pUnkParent = NULL;
    IDispatch     *pDispatch = NULL;
    IADsContainer *pIADsCont = NULL;
    IUmiObject    *pUmiObj = NULL;
    IUmiADSIPrivate *pUmiPrivate = NULL;

    SetLastStatus(0);

    if(uFlags != 0)
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if(NULL == pCopy)
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    if( (NULL == m_pCoreObj) || (NULL == m_pIADs) )
    // shouldn't happen, but just being paranoid
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    *pCopy = NULL;

    if(ADS_OBJECT_BOUND == m_pCoreObj->GetObjectState()) {
    // object exists on server
        if(FALSE == m_fRefreshDone) {
            hr = m_pCoreObj->ImplicitGetInfo();
            BAIL_ON_FAILURE(hr);
        }

        hr = m_pIADs->get_ADsPath(&bstrADsPath);
        BAIL_ON_FAILURE(hr);

        m_pCreds->SetUmiFlag();

        hr = GetObject(
                bstrADsPath,
                (LPVOID *) &pUnknown,
                *m_pCreds 
                );

        m_pCreds->ResetUmiFlag();

        BAIL_ON_FAILURE(hr);

        hr = pUnknown->QueryInterface(IID_IUmiObject, (LPVOID *) &pUmiObj);
        BAIL_ON_FAILURE(hr);
    }
    else if(ADS_OBJECT_UNBOUND == m_pCoreObj->GetObjectState()) {
    // object not yet committed to server. We don't have to refresh the
    // cache since the object is not yet committed. Get the parent container 
    // and call Create() on it.

        hr = m_pIADs->get_Parent(&bstrParent);
        BAIL_ON_FAILURE(hr);

        m_pCreds->SetUmiFlag();

        hr = GetObject(
                bstrParent,    
                (LPVOID *) &pUnkParent,
                *m_pCreds 
                );
        m_pCreds->ResetUmiFlag();

        BAIL_ON_FAILURE(hr);

        hr = pUnkParent->QueryInterface(
                IID_IUmiADSIPrivate, 
                (LPVOID *) &pUmiPrivate
                );
        BAIL_ON_FAILURE(hr);

        hr = pUmiPrivate->GetContainer((void **) &pIADsCont);
        BAIL_ON_FAILURE(hr);

        ADsAssert(pIADsCont != NULL);

        // get the class and name of this object
        hr = m_pIADs->get_Class(&bstrClass);
        BAIL_ON_FAILURE(hr);

        hr = m_pIADs->get_Name(&bstrName);
        BAIL_ON_FAILURE(hr);

        pUmiPrivate->SetUmiFlag();

        // now Create() the cloned object
        hr = pIADsCont->Create(
                bstrClass,
                bstrName,
                &pDispatch
                );

        pUmiPrivate->ResetUmiFlag();

        BAIL_ON_FAILURE(hr);

        hr = pDispatch->QueryInterface(IID_IUmiObject, (LPVOID *) &pUmiObj);
        BAIL_ON_FAILURE(hr);
    }
    else // unknown state, shouldn't happen.
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    // copy over the attributes in the property cache
    hr = CopyPropCache(pUmiObj, (IUmiObject *) this);
    BAIL_ON_FAILURE(hr);

    hr = pUmiObj->QueryInterface(riid, pCopy);
    BAIL_ON_FAILURE(hr);

error:

    if(bstrADsPath  != NULL)
        SysFreeString(bstrADsPath);

    if(bstrParent != NULL)
        SysFreeString(bstrParent);

    if(bstrClass != NULL)
        SysFreeString(bstrClass);
  
    if(bstrName != NULL)
        SysFreeString(bstrName);

    if(pUnknown != NULL)
        pUnknown->Release();

    if(pUnkParent != NULL)
        pUnkParent->Release();

    if(pDispatch != NULL)
        pDispatch->Release();

    if(pIADsCont != NULL)
        pIADsCont->Release();

    if(pUmiObj != NULL)
        pUmiObj->Release();

    if(pUmiPrivate != NULL)
        pUmiPrivate->Release();

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   CopyPropCache 
//
// Synopsis:   Copies the cache of one IUmiObject to another IUmiObject. 
//
// Arguments
//
// pDest       IUmiObject interface pointer of destination
// pSrc        IUmiObject interface pointer of source
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CUmiObject::CopyPropCache(
    IUmiObject *pDest,
    IUmiObject *pSrc
    )
{
    HRESULT hr = UMI_S_NO_ERROR;
    ULONG   ulIndex = 0, ulPutFlag = 0;
    LPWSTR  pszPropName = NULL;
    UMI_PROPERTY_VALUES *pUmiPropNames = NULL, *pUmiProp = NULL;

    ADsAssert( (pDest != NULL) && (pSrc != NULL) );

    // get the names of the properties in cache.
    hr = pSrc->GetProps(
                NULL,
                0,
                UMI_FLAG_GETPROPS_NAMES,
                &pUmiPropNames
                );
    BAIL_ON_FAILURE(hr);

    // copy over each property
    for(ulIndex = 0; ulIndex < pUmiPropNames->uCount; ulIndex++) {
        pszPropName = pUmiPropNames->pPropArray[ulIndex].pszPropertyName;

        if(NULL == pszPropName)
        // shouldn't happen, just being paranoid.
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pSrc->Get(
                pszPropName,
                UMI_FLAG_PROVIDER_CACHE,
                &pUmiProp
                );

        BAIL_ON_FAILURE(hr);

        // if the property was updated in cache, we need to mark it as updated 
        // in the destination object's cache also. Otherwise, mark the
        // property as clean in the destination object's cache.
        if(UMI_OPERATION_UPDATE == pUmiProp->pPropArray->uOperationType)
            ulPutFlag = 0;
        else
            ulPutFlag = UMI_INTERNAL_FLAG_MARK_AS_CLEAN;

        pUmiProp->pPropArray->uOperationType = UMI_OPERATION_UPDATE;

        hr = pDest->Put(
                pszPropName,
                ulPutFlag, 
                pUmiProp
                );
        BAIL_ON_FAILURE(hr);

        pSrc->FreeMemory(0, pUmiProp);
        pUmiProp = NULL;
    }

    pSrc->FreeMemory(0, pUmiPropNames);
         
error:

    if(FAILED(hr)) {
        if(pUmiProp != NULL)
            pSrc->FreeMemory(0, pUmiProp);
        if(pUmiPropNames != NULL)
            pSrc->FreeMemory(0, pUmiPropNames);
    }

    RRETURN(hr);
}                    

//----------------------------------------------------------------------------
// Function:   Refresh 
//
// Synopsis:   Implements IUmiObject::Refresh. Calls GetInfo on WinNT
//             object to refresh the cache. GetInfoEx is implemented by
//             just calling  GetInfo in the WinNT provider.
//
// Arguments
//
// uFlags      Flags for Refresh. Must be 0 for now.
// uNameCount  Number of attributes to refresh
// pszNames    Names of attributes to refresh
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CUmiObject::Refresh(
    ULONG uFlags,
    ULONG uNameCount,
    LPWSTR *pszNames
    )
{
    ULONG   i = 0;
    HRESULT hr = UMI_S_NO_ERROR;

    SetLastStatus(0);

    if( (uFlags != UMI_FLAG_REFRESH_ALL) && 
                    (uFlags != UMI_FLAG_REFRESH_PARTIAL) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if( ((NULL == pszNames) && (uNameCount != 0)) || 
                         ((pszNames != NULL) && (0 == uNameCount)) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    // ensure all attributes are valid
    for(i = 0; i < uNameCount; i++)
        if(NULL == pszNames[i])
            BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    if(UMI_FLAG_REFRESH_PARTIAL == uFlags) {
    // do an implicit GetInfo on the WinNT object
        if(NULL == m_pCoreObj)
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        if(uNameCount != 0) {
        // can't specify UMI_FLAG_REFRESH_PARTIAL and attribute names
            BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);
        }

        hr = m_pCoreObj->ImplicitGetInfo();
        BAIL_ON_FAILURE(hr);
    }
    else {
        if(NULL == m_pIADs) 
        // shouldn't happen, but just being paranoid
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = m_pIADs->GetInfo();

        BAIL_ON_FAILURE(hr);
    }

    m_fRefreshDone = TRUE;

error:

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   Commit 
//
// Synopsis:   Implements IUmiObject::Commit. Calls SetInfo on WinNT
//             object to commit changes made to the cache. 
//
// Arguments
//
// uFlags      Flags for Refresh.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CUmiObject::Commit(ULONG uFlags)
{
    HRESULT hr = UMI_S_NO_ERROR;

    SetLastStatus(0);

    // CIMOM always calls with UMI_DONT_COMMIT_SECURITY_DESCRIPTOR set. Ignore
    // this flag as it is not meaningful on WinNT.
    if( (uFlags != 0) && (uFlags != UMI_DONT_COMMIT_SECURITY_DESCRIPTOR) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if(NULL == m_pIADs)
    // shouldn't happen, but just being paranoid
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    hr = m_pIADs->SetInfo();
    BAIL_ON_FAILURE(hr);

error:

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}   

//----------------------------------------------------------------------------
// IUmiPropList methods
//
// These are implemented by invoking the corresponding method in the
// CUmiPropList object that implements object properties. For a description
// of these methods, refer to cumiprop.cxx
//
//----------------------------------------------------------------------------
HRESULT CUmiObject::Put(
    LPCWSTR pszName,
    ULONG uFlags,
    UMI_PROPERTY_VALUES *pProp
    )
{
    HRESULT hr = UMI_S_NO_ERROR;
    ULONG   ulStatus = 0;
    IID     iid;

    SetLastStatus(0);

    if(NULL == m_pObjProps) {
        SetLastStatus(UMI_E_NOTIMPL);
        RRETURN(UMI_E_NOTIMPL);
    }

    hr = m_pObjProps->Put(
                pszName,
                uFlags,
                pProp
                );

    if(FAILED(hr)) {
         m_pObjProps->GetLastStatus(  // ignore error return
                0,
                &ulStatus,
                iid,
                NULL
                ); 
           
         SetLastStatus(ulStatus);
    }
 
    RRETURN(MapHrToUmiError(hr));
}

HRESULT CUmiObject::Get(
    LPCWSTR pszName,
    ULONG uFlags,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    HRESULT hr = UMI_S_NO_ERROR;
    ULONG   ulStatus = 0;
    IID     iid;

    SetLastStatus(0);

    if(NULL == m_pObjProps) {
        SetLastStatus(UMI_E_NOTIMPL);
        RRETURN(UMI_E_NOTIMPL);
    }

    hr = m_pObjProps->Get(
                pszName,
                uFlags,
                ppProp
                );

    if(FAILED(hr)) {
         m_pObjProps->GetLastStatus( // ignore error return
                0,
                &ulStatus,
                iid,
                NULL
                );

         SetLastStatus(ulStatus);
    }

    RRETURN(MapHrToUmiError(hr));
}

HRESULT CUmiObject::GetAs(
    LPCWSTR pszName,
    ULONG uFlags,
    ULONG uCoercionType,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    HRESULT hr = UMI_S_NO_ERROR;
    ULONG   ulStatus = 0;
    IID     iid;

    SetLastStatus(0);

    if(NULL == m_pObjProps) {
        SetLastStatus(UMI_E_NOTIMPL);
        RRETURN(UMI_E_NOTIMPL);
    }

    hr = m_pObjProps->GetAs(
                pszName,
                uFlags,
                uCoercionType,
                ppProp
                );

    if(FAILED(hr)) {
         m_pObjProps->GetLastStatus( // ignore error return
                0,
                &ulStatus,
                iid,
                NULL
                );

         SetLastStatus(ulStatus);
    }

    RRETURN(MapHrToUmiError(hr));
}

HRESULT CUmiObject::FreeMemory(
    ULONG uReserved,
    LPVOID pMem
    )
{
    HRESULT hr = UMI_S_NO_ERROR;
    ULONG   ulStatus = 0;
    IID     iid;

    SetLastStatus(0);

    if(NULL == m_pObjProps) {
        SetLastStatus(UMI_E_NOTIMPL);
        RRETURN(UMI_E_NOTIMPL);
    }

    hr = m_pObjProps->FreeMemory(
                uReserved,
                pMem
                );

    if(FAILED(hr)) {
         m_pObjProps->GetLastStatus( // ignore error return
                0,
                &ulStatus,
                iid,
                NULL
                );

         SetLastStatus(ulStatus);
    }

    RRETURN(MapHrToUmiError(hr));
}

HRESULT CUmiObject::GetAt(
    LPCWSTR pszName,
    ULONG uFlags,
    ULONG uBufferLength,
    LPVOID pExistingMem 
    )
{
    HRESULT hr = UMI_S_NO_ERROR;
    ULONG   ulStatus = 0;
    IID     iid;

    SetLastStatus(0);

    if(NULL == m_pObjProps) {
        SetLastStatus(UMI_E_NOTIMPL);
        RRETURN(UMI_E_NOTIMPL);
    }

    hr = m_pObjProps->GetAt(
                pszName,
                uFlags,
                uBufferLength,
                pExistingMem
                );

    if(FAILED(hr)) {
         m_pObjProps->GetLastStatus( // ignore error return
                0,
                &ulStatus,
                iid,
                NULL
                );

         SetLastStatus(ulStatus);
    }

    RRETURN(MapHrToUmiError(hr));
}

HRESULT CUmiObject::GetProps(
    LPCWSTR *pszNames,
    ULONG uNameCount,
    ULONG uFlags,
    UMI_PROPERTY_VALUES **pProps
    )
{
    HRESULT hr = UMI_S_NO_ERROR;
    ULONG   ulStatus = 0;
    IID     iid;

    SetLastStatus(0);

    if(NULL == m_pObjProps) {
        SetLastStatus(UMI_E_NOTIMPL);
        RRETURN(UMI_E_NOTIMPL);
    }

    hr = m_pObjProps->GetProps(
                pszNames,
                uNameCount,
                uFlags,
                pProps
                );

    if(FAILED(hr)) {
         m_pObjProps->GetLastStatus( // ignore error return
                0,
                &ulStatus,
                iid,
                NULL
                );

         SetLastStatus(ulStatus);
    }

    RRETURN(MapHrToUmiError(hr));
}

HRESULT CUmiObject::PutProps(
    LPCWSTR *pszNames,
    ULONG uNameCount,
    ULONG uFlags,
    UMI_PROPERTY_VALUES *pProps
    )
{
    HRESULT hr = UMI_S_NO_ERROR;
    ULONG   ulStatus = 0;
    IID     iid;

    SetLastStatus(0);

    if(NULL == m_pObjProps) {
        SetLastStatus(UMI_E_NOTIMPL);
        RRETURN(UMI_E_NOTIMPL);
    }

    hr = m_pObjProps->PutProps(
                pszNames,
                uNameCount,
                uFlags,
                pProps
                );

    if(FAILED(hr)) {
         m_pObjProps->GetLastStatus( // ignore error return
                0,
                &ulStatus,
                iid,
                NULL
                );

         SetLastStatus(ulStatus);
    }

    RRETURN(MapHrToUmiError(hr));
}

HRESULT CUmiObject::PutFrom(
    LPCWSTR pszName,
    ULONG uFlags,
    ULONG uBufferLength,
    LPVOID pExistingMem
    )
{
    HRESULT hr = UMI_S_NO_ERROR;
    ULONG   ulStatus = 0;
    IID     iid;

    SetLastStatus(0);

    if(NULL == m_pObjProps) {
        SetLastStatus(UMI_E_NOTIMPL);
        RRETURN(UMI_E_NOTIMPL);
    }

    hr = m_pObjProps->PutFrom(
                pszName,
                uFlags,
                uBufferLength,
                pExistingMem
                );

    if(FAILED(hr)) {
         m_pObjProps->GetLastStatus( // ignore error return
                0,
                &ulStatus,
                iid,
                NULL
                );

         SetLastStatus(ulStatus);
    }

    RRETURN(MapHrToUmiError(hr));
}

HRESULT CUmiObject::Delete(
    LPCWSTR pszName,
    ULONG uFlags
    )
{
    HRESULT hr = UMI_S_NO_ERROR;
    ULONG   ulStatus = 0;
    IID     iid;

    SetLastStatus(0);

    if(NULL == m_pObjProps) {
        SetLastStatus(UMI_E_NOTIMPL);
        RRETURN(UMI_E_NOTIMPL);
    }

    hr = m_pObjProps->Delete(
                pszName,
                uFlags
                );

    if(FAILED(hr)) {
         m_pObjProps->GetLastStatus( // ignore error return
                0,
                &ulStatus,
                iid,
                NULL
                );

         SetLastStatus(ulStatus);
    }

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   GetLastStatus
//
// Synopsis:   Returns status or error code from the last operation. Currently
//             only numeric status is returned i.e, no error objects are
//             returned. Implements IUmiBaseObject::GetLastStatus().
//
// Arguments:
//
// uFlags           Reserved. Must be 0 for now.
// puSpecificStatus Returns status code
// riid             IID requested. Ignored currently.
// pStatusObj       Returns interface requested. Always returns NULL currently.
//
// Returns:         UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:        *puSpecificStatus to return status code.
//
//----------------------------------------------------------------------------
HRESULT CUmiObject::GetLastStatus(
    ULONG uFlags,
    ULONG *puSpecificStatus,
    REFIID riid,
    LPVOID *pStatusObj
    )
{
    if(pStatusObj != NULL)
       *pStatusObj = NULL;

    if(puSpecificStatus != NULL)
        *puSpecificStatus = 0;

    if(uFlags != 0)
        RRETURN(UMI_E_INVALID_FLAGS);

    if(NULL == puSpecificStatus)
        RRETURN(UMI_E_INVALIDARG);

    *puSpecificStatus = m_ulErrorStatus;

    RRETURN(UMI_S_NO_ERROR);
}

//----------------------------------------------------------------------------
// Function:   SetLastStatus
//
// Synopsis:   Sets the status of the last operation. 
//
// Arguments:
//
// ulStatus    Status to be set
//
// Returns:    Nothing
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
void CUmiObject::SetLastStatus(ULONG ulStatus)
{
    m_ulErrorStatus = ulStatus;

    return;
}

//----------------------------------------------------------------------------
// Function:   GetInterfacePropList
//
// Synopsis:   Returns a pointer to the interface property list implementation
//             for the connection object. Implements
//             IUmiBaseObject::GetInterfacePropList().
//
// Arguments:
//
// uFlags      Reserved. Must be 0 for now.
// pPropList   Returns pointer to IUmiPropertyList interface
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pPropList to return interface pointer
//
//----------------------------------------------------------------------------
HRESULT CUmiObject::GetInterfacePropList(
    ULONG uFlags,
    IUmiPropList **pPropList
    )
{
    HRESULT hr = UMI_S_NO_ERROR;

    SetLastStatus(0);

    if(uFlags != 0)
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if(NULL == pPropList)
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    ADsAssert(m_pIntfProps != NULL);

    hr = m_pIntfProps->QueryInterface(IID_IUmiPropList, (void **) pPropList);

error:

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   IsRelativePath 
//
// Synopsis:   Checks if a path is relative or absolute 
//
// Arguments:
//
// pURL        IUmiURL interface containing the path
//
// Returns:    TRUE if the path is relative, FALSE otherwise 
//
// Modifies:   Nothing 
//
//----------------------------------------------------------------------------
BOOL CUmiObject::IsRelativePath(IUmiURL *pURL)
{
    HRESULT hr = S_OK;
    ULONGLONG PathType = 0;

    ADsAssert(pURL != NULL);

    hr = pURL->GetPathInfo(
        0,
        &PathType
        );
    BAIL_ON_FAILURE(hr);

    if(PathType & UMIPATH_INFO_RELATIVE_PATH)
        RRETURN(TRUE);
    else
        RRETURN(FALSE);

error:

    RRETURN(FALSE);
}

//----------------------------------------------------------------------------
// Function:   GetClassAndPath 
//
// Synopsis:   Obtains the class name and path from a relative UMI path. 
//             The class name and value are mandatory. The key is optional.
//
// Arguments:
//
// pszPath     String containing the path
// ppszClass   Returns string containing the class name
// ppszPath    Returns string containing the path
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise. 
//
// Modifies:   *ppszClass and *ppszPath 
//
//----------------------------------------------------------------------------
HRESULT CUmiObject::GetClassAndPath(
    LPWSTR pszPath,
    LPWSTR *ppszClass,
    LPWSTR *ppszPath
    )
{
    HRESULT hr = UMI_S_NO_ERROR;
    WCHAR   *pSeparator = NULL, *pValSeparator = NULL;

    ADsAssert( (pszPath != NULL) && (ppszClass != NULL) && 
                                                (ppszPath != NULL) );

    *ppszClass = NULL;
    *ppszPath = NULL;

    // look for the '=' in the relative path
    if(NULL == (pValSeparator = wcschr(pszPath, VALUE_SEPARATOR)))
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);

    *pValSeparator = L'\0';
    *ppszPath = AllocADsStr(pValSeparator+1);
    if(NULL == *ppszPath)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY); 
        
    if(NULL == (pSeparator = wcschr(pszPath, CLASS_SEPARATOR))) {
    // path does not have a key in it
        *ppszClass = AllocADsStr(pszPath);
        if(NULL == *ppszClass)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    }
    else {
    // path has a key. Make sure it is "Name". 
        *pSeparator = L'\0';
       
        if(_wcsicmp(pSeparator+1, WINNT_KEY_NAME))
            BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);
 
        *ppszClass = AllocADsStr(pszPath);
        if(NULL == *ppszClass)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    }

    RRETURN(UMI_S_NO_ERROR);

error:

    if(*ppszPath != NULL)
        FreeADsStr(*ppszPath);

    if(*ppszClass != NULL)
        FreeADsStr(*ppszClass);

    *ppszPath = *ppszClass = NULL;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   Open 
//
// Synopsis:   Opens the object specified by a URL. URL has to be a relative 
//             UMI path. Implements IUmiContainer::Open().
//
// Arguments:
//
// pURL        Pointer to an IUmiURL interface
// uFlags      Reserved. Must be 0 for now.
// TargetIID   Interface requested
// ppInterface Returns pointer to interface requested
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::Open(
    IUmiURL *pURL,
    ULONG   uFlags,
    REFIID  TargetIID,
    LPVOID  *ppInterface
    )
{
    BOOL      fIsRelPath = FALSE;
    HRESULT   hr = UMI_S_NO_ERROR;
    WCHAR     pszUrl[MAX_URL+1];
    WCHAR     *pszLongUrl = pszUrl;
    ULONG     ulUrlLen = MAX_URL;
    WCHAR     *pszClass = NULL, *pszPath = NULL;
    IDispatch *pIDispatch = NULL;

    SetLastStatus(0);

    if(uFlags != 0)
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if( (NULL == pURL) || (NULL == ppInterface) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    if(NULL == m_pIADsContainer)
    // shouldn't happen, but just in case...
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    // Get the path from the URL
    hr = pURL->Get(0, &ulUrlLen, pszUrl);

    if(WBEM_E_BUFFER_TOO_SMALL == hr) {
    // need to allocate more memory for URL
        pszLongUrl = (WCHAR *) AllocADsMem(ulUrlLen * sizeof(WCHAR));
        if(NULL == pszLongUrl)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

        hr = pURL->Get(0, &ulUrlLen, pszLongUrl);
    }
    BAIL_ON_FAILURE(hr);

    // Check if the path is relative or absolute
    fIsRelPath = IsRelativePath(pURL);
    
    if(TRUE == fIsRelPath) {
        // check if the caller specified the class as part of the path 
        hr = GetClassAndPath(pszLongUrl, &pszClass, &pszPath);
        BAIL_ON_FAILURE(hr);

        m_pCreds->SetUmiFlag();

        hr = m_pIADsContainer->GetObject(
                    pszClass,
                    pszPath,
                    &pIDispatch
                    );

        m_pCreds->ResetUmiFlag();

        BAIL_ON_FAILURE(hr);

        hr = pIDispatch->QueryInterface(
                    TargetIID,
                    ppInterface
                    );
        BAIL_ON_FAILURE(hr); 
    } // if(TRUE == fIsRelPath
    else {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);
    }

error:
 
    if(pIDispatch != NULL)
        pIDispatch->Release();

    if(pszClass != NULL)
        FreeADsMem(pszClass);

    if(pszPath != NULL)
        FreeADsMem(pszPath);

     if(pszLongUrl != pszUrl)
         FreeADsMem(pszLongUrl);

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}         
    

//----------------------------------------------------------------------------
// Function:   PutObject 
//
// Synopsis:   Commits an object into the container. Not implemented currently. 
//             Implements IUmiContainer::Put().
//
// Arguments:
//
// uFlags      Reserved. Must be 0 for now.
// TargetIID   IID of nterface pointer sent in
// pInterface  Interface pointer sent in 
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::PutObject(
    ULONG   uFlags,
    REFIID  TargetIID,
    LPVOID  pInterface
    )   
{
    SetLastStatus(UMI_E_NOTIMPL);

    RRETURN(UMI_E_NOTIMPL);
}

//----------------------------------------------------------------------------
// Function:   DeleteObject 
//
// Synopsis:   Deletes the object specified by the relative UMI path. 
//             Implements IUmiContainer::Delete(). 
//
// Arguments:
//
// pURL        Pointer to an IUmiURL interface
// uFlags      Reserved. Must be 0 for now.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   Nothing 
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::DeleteObject(
    IUmiURL *pURL,
    ULONG   uFlags
    )
{
    ULONG    ulUrlLen = MAX_URL;
    WCHAR    pszUrl[MAX_URL+1], *pszClass = NULL, *pszPath = NULL;
    WCHAR    *pszLongUrl = pszUrl;
    BOOL     fIsRelPath = FALSE;
    HRESULT  hr = UMI_S_NO_ERROR;

    SetLastStatus(0);

    if(uFlags != 0)
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if(NULL == pURL)
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    if(NULL == m_pIADsContainer)
    // shouldn't happen, but just in case...
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    // Get the path from the URL
    hr = pURL->Get(0, &ulUrlLen, pszUrl);

    if(WBEM_E_BUFFER_TOO_SMALL == hr) {
    // need to allocate more memory for URL
        pszLongUrl = (WCHAR *) AllocADsMem(ulUrlLen * sizeof(WCHAR));
        if(NULL == pszLongUrl)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

        hr = pURL->Get(0, &ulUrlLen, pszLongUrl);
    }
    BAIL_ON_FAILURE(hr);

    // Check if the path is relative or absolute
    fIsRelPath = IsRelativePath(pURL);

    if(TRUE == fIsRelPath) {
        // check if the caller specified the class as part of the path
        hr = GetClassAndPath(pszLongUrl, &pszClass, &pszPath);
        BAIL_ON_FAILURE(hr);

        m_pCreds->SetUmiFlag();

        hr = m_pIADsContainer->Delete(
                    pszClass,
                    pszPath
                    );

        m_pCreds->ResetUmiFlag();

        BAIL_ON_FAILURE(hr);
    } // if(TRUE == fIsRelPath
    else {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);
    }   

error:

    if(pszClass != NULL)
        FreeADsMem(pszClass);

    if(pszPath != NULL)
        FreeADsMem(pszPath);

    if(pszLongUrl != pszUrl)
        FreeADsMem(pszLongUrl);

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   Create
//
// Synopsis:   Creates the object specified by the relative UMI path. 
//             Implements IUmiContainer::Create().
//
// Arguments:
//
// pURL        Pointer to an IUmiURL interface
// uFlags      Reserved. Must be 0 for now.
// ppNewObj    Returns pointer to IUmiObject interface on new object
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pNewObject to return the IUmiObject interface 
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::Create(
    IUmiURL *pURL,
    ULONG   uFlags,
    IUmiObject **ppNewObj
    )
{
    ULONG     ulUrlLen = MAX_URL;
    WCHAR     pszUrl[MAX_URL+1], *pszClass = NULL, *pszPath = NULL;
    WCHAR     *pszLongUrl = pszUrl;
    BOOL      fIsRelPath = FALSE;
    HRESULT   hr = UMI_S_NO_ERROR;
    IDispatch *pIDispatch = NULL;

    SetLastStatus(0);

    if(uFlags != 0)
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if( (NULL == pURL) || (NULL == ppNewObj) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    if(NULL == m_pIADsContainer)
    // shouldn't happen, but just in case...
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    // Get the path from the URL
    hr = pURL->Get(0, &ulUrlLen, pszUrl);

    if(WBEM_E_BUFFER_TOO_SMALL == hr) {
    // need to allocate more memory for URL
        pszLongUrl = (WCHAR *) AllocADsMem(ulUrlLen * sizeof(WCHAR));
        if(NULL == pszLongUrl)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

        hr = pURL->Get(0, &ulUrlLen, pszLongUrl);
    }
    BAIL_ON_FAILURE(hr);

    // Check if the path is relative or absolute
    fIsRelPath = IsRelativePath(pURL);

    if(TRUE == fIsRelPath) {
        // check if the caller specified the class as part of the path
        hr = GetClassAndPath(pszLongUrl, &pszClass, &pszPath);
        BAIL_ON_FAILURE(hr);

        m_pCreds->SetUmiFlag();

        hr = m_pIADsContainer->Create(
                    pszClass,
                    pszPath,
                    &pIDispatch
                    );

        m_pCreds->ResetUmiFlag();

        BAIL_ON_FAILURE(hr);

        hr = pIDispatch->QueryInterface(
                    IID_IUmiObject,
                    (void **) ppNewObj 
                    );
        BAIL_ON_FAILURE(hr);
    } // if(TRUE == fIsRelPath
    else {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);
    }

error:
 
    if(pIDispatch != NULL)
        pIDispatch->Release();

    if(pszClass != NULL)
        FreeADsMem(pszClass);

    if(pszPath != NULL)
        FreeADsMem(pszPath);

    if(pszLongUrl != pszUrl)
        FreeADsMem(pszLongUrl);

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   Move 
//
// Synopsis:   Moves a specified object into the container. Implements
//             IUmiContainer::Move().
//
// Arguments:
//
// uFlags      Reserved. Must be 0 for now.
// pOldURL     URL of the object to be moved
// pNewURL     New URL of the object within the container. If NULL, the new
//             name will be the same as the old one.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   Nothing 
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::Move(
    ULONG   uFlags,
    IUmiURL *pOldURL,
    IUmiURL *pNewURL
    )
{
    ULONG     ulUrlLen = MAX_URL;
    WCHAR     pszNewUrl[MAX_URL+1], pszOldUrl[MAX_URL+1];
    WCHAR     *pszLongNewUrl = pszNewUrl, *pszLongOldUrl = pszOldUrl;
    WCHAR     *pszDstPath = NULL, *pszTmpStr = NULL;
    WCHAR     *pszClass = NULL;
    BOOL      fIsRelPath = FALSE;
    IDispatch *pIDispatch = NULL;
    HRESULT   hr = UMI_S_NO_ERROR;
    ULONGLONG PathType = 0;
    WCHAR     *pSeparator = NULL;
    DWORD     dwNumComponents = 0, dwIndex = 0;
    LPWSTR    *ppszClasses = NULL;

    SetLastStatus(0);

    if(uFlags != 0)
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if(NULL == pOldURL)
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    if(NULL == m_pIADsContainer)
    // shouldn't happen, but just in case...
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    // Get the path from the URL
    if(pNewURL != NULL) {
        hr = pNewURL->Get(0, &ulUrlLen, pszNewUrl);

        if(WBEM_E_BUFFER_TOO_SMALL == hr) {
        // need to allocate more memory for URL
            pszLongNewUrl = (WCHAR *) AllocADsMem(ulUrlLen * sizeof(WCHAR));
            if(NULL == pszLongNewUrl)
                BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

            hr = pNewURL->Get(0, &ulUrlLen, pszLongNewUrl);
        }
        BAIL_ON_FAILURE(hr);

        // Check if the path is relative or absolute
        fIsRelPath = IsRelativePath(pNewURL);
    }
    else {
        fIsRelPath = TRUE;
        pszDstPath = NULL;
    }

    // check if old path is native or UMI path
    hr = pOldURL->GetPathInfo(0, &PathType);
    BAIL_ON_FAILURE(hr);

    if(PathType & UMIPATH_INFO_NATIVE_STRING) {
    // Get the native path from the URL
        ulUrlLen = MAX_URL;
        hr = pOldURL->Get(0, &ulUrlLen, pszOldUrl);

        if(WBEM_E_BUFFER_TOO_SMALL == hr) {
        // need to allocate more memory for URL
            pszLongOldUrl = (WCHAR *) AllocADsMem(ulUrlLen * sizeof(WCHAR));
            if(NULL == pszLongOldUrl)
                BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

            hr = pOldURL->Get(0, &ulUrlLen, pszLongOldUrl);
        }
        BAIL_ON_FAILURE(hr);
    }
    else {
    // assume UMI path if not native
        hr = UmiToWinNTPath(
                pOldURL, 
                &pszLongOldUrl,
                &dwNumComponents,
                &ppszClasses
                );
        BAIL_ON_FAILURE(hr);

        // check to ensure that the UMI path had the expected object classes
        hr = CheckClasses(dwNumComponents, ppszClasses);
        BAIL_ON_FAILURE(hr);
    }

    if(TRUE == fIsRelPath) {
        if(pNewURL != NULL) {
            hr = GetClassAndPath(pszLongNewUrl, &pszClass, &pszDstPath);
            BAIL_ON_FAILURE(hr);

            // Make sure that if the old path had a class specified in the path,
            // then the new path also if of the same class
            if(NULL == (pSeparator = wcschr(pszLongOldUrl, 
                                        NATIVE_CLASS_SEPARATOR))) { 
            // no class specified in the old path. Must have been a native path.
            // Append class to old path.     
                pszTmpStr = (WCHAR *) AllocADsMem( 
                                         (wcslen(pszLongOldUrl)+MAX_CLASS) *
                                         sizeof(WCHAR) );
                if(NULL == pszTmpStr)
                    BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

                wcscpy(pszTmpStr, pszLongOldUrl);
                wcscat(pszTmpStr, L",");
                wcscat(pszTmpStr, pszClass);

                if(pszLongOldUrl != pszOldUrl)
                    FreeADsMem(pszLongOldUrl);

                pszLongOldUrl = pszTmpStr;
            }
            else {
            // old path already had a class in it
                if(_wcsicmp(pSeparator+1, pszClass))
                    BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);
            }
        } // if(pNewUrl != NULL)

        m_pCreds->SetUmiFlag();
            
        hr = m_pIADsContainer->MoveHere(
                    pszLongOldUrl,
                    pszDstPath,
                    &pIDispatch
                    );

        m_pCreds->ResetUmiFlag();

        BAIL_ON_FAILURE(hr);
    } // if(TRUE == fIsRelPath)
    else {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);
    }

error:

    if(pIDispatch != NULL)
        pIDispatch->Release();

    if(pszLongOldUrl != pszOldUrl)
        FreeADsMem(pszLongOldUrl);

    if(pszLongNewUrl != pszNewUrl)
        FreeADsMem(pszLongNewUrl);

    if(pszClass != NULL)
        FreeADsStr(pszClass);

    if(pszDstPath != NULL)
        FreeADsStr(pszDstPath);

    if(ppszClasses != NULL) {
        for(dwIndex = 0; dwIndex < dwNumComponents; dwIndex++) {
            if(ppszClasses[dwIndex] != NULL)
                FreeADsStr(ppszClasses[dwIndex]);
        }
        FreeADsMem(ppszClasses);
    }

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   CreateEnum 
//
// Synopsis:   Creates an enumerator within a container. The enumerator is
//             a IUmiCursor interface pointer. The caller can optionally set
//             a filter on the cursor and then enumerate the contents of the
//             container. The actual enumeration of the container does
//             not happen in this function. It is deferred to the point
//             when the cursor is used to enumerate the results.
//
// Arguments:
//
// pszEnumContext Not used. Must be NULL.
// uFlags         Reserved. Must be 0 for now.
// TargetIID      Interface requested. Has to be IUmiCursor.
// ppInterface    Returns the IUmiCursor interface pointer
//
// Returns:       UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:      *ppInterface to return the IUmiCursor interface 
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::CreateEnum(
    IUmiURL *pszEnumContext,
    ULONG   uFlags,
    REFIID  TargetIID,
    LPVOID  *ppInterface
    )
{
    HRESULT  hr = UMI_S_NO_ERROR;
    IUnknown *pEnumerator = NULL;

    SetLastStatus(0);

    if(uFlags != 0)
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if( (pszEnumContext != NULL) || (NULL == ppInterface) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    if(!IsEqualIID(IID_IUmiCursor, TargetIID))
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    *ppInterface = NULL;

    if(NULL == m_pIADsContainer)
    // shouldn't happen, but just in case...
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    hr = CUmiCursor::CreateCursor(m_pCreds, m_pUnkInner, TargetIID, 
                                  ppInterface);
    BAIL_ON_FAILURE(hr);

error:

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   ExecQuery 
//
// Synopsis:   Executes a query in a container. Not implemented on WinNT. 
//             Implements IUmiContainer::ExecQuery().
//
// Arguments:
//
// pQuery      IUmiQuery interface containing the query
// uFlags      Reserved. Must be 0 for now.
// TargetIID   Interface requested
// ppInterface Returns pointer to interface requested
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::ExecQuery(
    IUmiQuery *pQuery,
    ULONG   uFlags,
    REFIID  TargetIID,
    LPVOID  *ppInterface
    )
{
    SetLastStatus(UMI_E_NOTIMPL);

    RRETURN(UMI_E_NOTIMPL);
}

//----------------------------------------------------------------------------
// Function:   GetCLSIDForIID 
//
// Synopsis:   Returns the CLSID corresponding to a given interface IID. If
//             the interface is one of the interfaces implemented by the
//             underlying WinNT object, then CLSID_WinNTObject is returned.
//             If the IID is one of the interfaces implemented by an 
//             extension object, then the extension's CLSID is returned. 
//             Implements IUmiCustomInterfaceFactory::GetCLSIDForIID.
//
// Arguments:
//
// riid        Interface ID for which we want to find the CLSID 
// lFlags      Reserved. Must be 0.
// pCLSID      Returns the CLSID corresponding to the IID.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pCLSID to return CLSID.
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::GetCLSIDForIID(
    REFIID riid,
    long lFlags,
    CLSID *pCLSID
    )
{
    HRESULT  hr = S_OK;
    IUnknown *pUnknown = NULL;

    SetLastStatus(0);

    if( (lFlags != 0) || (NULL == pCLSID) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    if(m_pExtMgr != NULL) {
    // check if there is any extension which supports this IID
        hr = m_pExtMgr->GetCLSIDForIID(
                riid,
                lFlags,
                pCLSID
                );
        if(SUCCEEDED(hr))
            RRETURN(UMI_S_NO_ERROR);
    }

    // check if the underlying WinNT object supports this IID
    hr = m_pUnkInner->QueryInterface(riid, (void **) &pUnknown);
    if(SUCCEEDED(hr)) {
        pUnknown->Release();
        memcpy(pCLSID, &CLSID_WinNTObject, sizeof(GUID));

        RRETURN(UMI_S_NO_ERROR);
    }

error:

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}
     
//----------------------------------------------------------------------------
// Function:   GetObjectByCLSID
//
// Synopsis:   Returns a pointer to a requested interface on the object 
//             specified by a CLSID. The object specified by the CLSID is
//             aggregated by the specified outer unknown. The interface
//             returned is a non-delegating interface on the object.
//             Implements IUmiCustomInterfaceFactory::GetObjectByCLSID.
//
// Arguments:
//
// clsid       CLSID of object on which interface should be obtained
// pUnkOuter   Aggregating outer unknown. 
// dwClsContext Context for running executable code. 
// riid        Interface requested. Has to be IID_IUnknown.
// lFlags      Reserved. Must be 0.
// ppInterface Returns requested interface
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *ppInterface to return requested interface
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::GetObjectByCLSID(
    CLSID clsid,
    IUnknown *pUnkOuter,
    DWORD dwClsContext,
    REFIID riid,
    long lFlags,
    void **ppInterface
    )
{
    HRESULT  hr = S_OK;
    IUnknown *pCurOuterUnk = NULL;

    SetLastStatus(0);

    if( (lFlags != 0) || (NULL == pUnkOuter) || (NULL == ppInterface) ||
                         (dwClsContext != CLSCTX_INPROC_SERVER) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    // ensure outer unknown specified is same as what is on the WinNT object
    if(TRUE == m_fOuterUnkSet) {
        pCurOuterUnk = m_pCoreObj->GetOuterUnknown();

        if(pCurOuterUnk != pUnkOuter)
            BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);
    }

    // Interface requested has to be IID_IUnknown if there is an outer unknown
    if (!IsEqualIID(riid, IID_IUnknown)) 
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    if(!IsEqualCLSID(clsid, CLSID_WinNTObject)) {
    // has to be a CLSID of an extension object
        if(m_pExtMgr != NULL) {

            hr = m_pExtMgr->GetObjectByCLSID(
                clsid,
                pUnkOuter,
                riid,
                ppInterface
                );
            BAIL_ON_FAILURE(hr);

            // successfully got the interface
            m_pCoreObj->SetOuterUnknown(pUnkOuter); 
            m_fOuterUnkSet = TRUE;

            RRETURN(UMI_S_NO_ERROR);
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG); // bad CLSID
    }

    // CLSID == CLSID_WinNTObject. This has to be an interface on the
    // underlying WinNT object. 

    m_pCoreObj->SetOuterUnknown(pUnkOuter);
    m_fOuterUnkSet = TRUE;

    *ppInterface = m_pUnkInner;
    m_pUnkInner->AddRef();

    RRETURN(UMI_S_NO_ERROR);

error:

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   GetCLSIDForNames
//
// Synopsis:   Returns the CLSID of the object that supports a specified
//             method/property. Also returns DISPIDs for the property/method.
//             Implements IUmiCustomInterfaceFactory::GetCLSIDForNames.
//
// Arguments:
//
// rgszNames   Names to be mapped
// cNames      Number of names to be mapped
// lcid        Locale in which to interpret the names
// rgDispId    Returns DISPID
// lFlags      Reserved. Must be 0.
// pCLSID      Returns CLSID of object which supports this property/method.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pCLSID to return the CLSID.
//             *rgDispId to return the DISPIDs.
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::GetCLSIDForNames(
    LPOLESTR *rgszNames,
    UINT cNames,
    LCID lcid,
    DISPID *rgDispId,
    long lFlags,
    CLSID *pCLSID
    )
{
    HRESULT   hr = S_OK;
    IDispatch *pDispatch = NULL;

    SetLastStatus(0);

    if( (lFlags != 0) || (NULL == pCLSID) ) 
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    if(0 == cNames)
        RRETURN(UMI_S_NO_ERROR);

    if( (NULL == rgszNames) || (NULL == rgDispId) )
        RRETURN(UMI_S_NO_ERROR);

    if(m_pExtMgr != NULL) {
    // check if there is any extension which supports this IID
        hr = m_pExtMgr->GetCLSIDForNames(
                rgszNames,
                cNames,
                lcid,
                rgDispId,
                lFlags,
                pCLSID
                );
        if(SUCCEEDED(hr))
        // successfully got the CLSID and DISPIDs
            RRETURN(UMI_S_NO_ERROR);
    }

    // check if the underlying WinNT object supports this name 
    hr = m_pUnkInner->QueryInterface(IID_IDispatch, (void **) &pDispatch);
    if(FAILED(hr))
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    hr = pDispatch->GetIDsOfNames(
                 IID_NULL,
                 rgszNames,
                 cNames,
                 lcid,
                 rgDispId
                 );
    if(SUCCEEDED(hr)) {
        pDispatch->Release();
        memcpy(pCLSID, &CLSID_WinNTObject, sizeof(GUID));

        RRETURN(UMI_S_NO_ERROR);
    }


error:

    if(pDispatch != NULL)
        pDispatch->Release();

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}     

//----------------------------------------------------------------------------
// Function:   GetContainer
//
// Synopsis:   Returns a pointer to the IADsContainer interface of the 
//             underlying WinNT object. Used as a backdoor to get access to
//             the WinNT object from a UMI object. Implements
//             IUmiADSIPrivate::GetContainer(). 
//
// Arguments:
//
// ppContainer Returns pointer to IADsContainer interface on WinNT object
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppContainer to return the IADsContainer interface pointer. 
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::GetContainer(void **ppContainer)
{
    if(NULL == ppContainer)
        RRETURN(UMI_E_INVALIDARG);

    *ppContainer = (void *) m_pIADsContainer;
    if(m_pIADsContainer != NULL)
        m_pIADsContainer->AddRef();

    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
// Function:   CopyTo 
//
// Synopsis:   Creates an uncommitted copy of an object at the location 
//             specified by a URL. This is the same as Clone except that
//             the new object has a different path than the old one. If the
//             cache is dirty in teh source object, then the destination will
//             also end up with a dirty cache. 
//
// Update:     This method will not be supported for now.
//
// Arguments:
//
// uFlags      Flags for CopyTo. Must be 0 for now.
// pURL        Destination path (native or UMI)
// riid        Interface requested from new object
// pCopy       Returns interface requested 
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pCopy to return requested interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::CopyTo(
    ULONG uFlags,
    IUmiURL *pURL,
    REFIID riid,
    LPVOID *pCopy
    )
{
    HRESULT       hr = UMI_S_NO_ERROR;
    ULONGLONG     PathType = 0;
    WCHAR         pszUrl[MAX_URL+1];
    WCHAR         *pszLongUrl = pszUrl;
    ULONG         ulUrlLen = MAX_URL;
    LPWSTR        RelName = NULL;
    BSTR          bstrClass = NULL;
    IUnknown      *pUnkParent = NULL;
    IADsContainer *pIADsCont = NULL;
    IDispatch     *pDispatch = NULL;
    IUmiObject    *pUmiObj = NULL;
    IUmiADSIPrivate *pUmiPrivate = NULL;
    OBJECTINFO    ObjectInfo;
    POBJECTINFO   pObjectInfo = NULL;
    CLexer        Lexer(NULL);
    DWORD         dwNumComponents = 0, dwIndex = 0, dwCoreIndex = 0;
    LPWSTR        *ppszClasses = NULL;
    CCoreADsObject *pCoreObj = NULL;

    SetLastStatus(UMI_E_NOTIMPL);
    RRETURN(UMI_E_NOTIMPL);

    SetLastStatus(0);

    if(uFlags != 0)
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if( (NULL == pCopy) || (NULL == pURL) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    if( (NULL == m_pCoreObj) || (NULL == m_pIADs) )
    // shouldn't happen, but just being paranoid
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    *pCopy = NULL;

    // check if this is a native path or UMI path
    hr = pURL->GetPathInfo(0, &PathType);
    BAIL_ON_FAILURE(hr);

    if(PathType & UMIPATH_INFO_NATIVE_STRING) {
    // Get the native path from the URL
        hr = pURL->Get(0, &ulUrlLen, pszUrl);

        if(WBEM_E_BUFFER_TOO_SMALL == hr) {
        // need to allocate more memory for URL
            pszLongUrl = (WCHAR *) AllocADsMem(ulUrlLen * sizeof(WCHAR));
            if(NULL == pszLongUrl)
                BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

            hr = pURL->Get(0, &ulUrlLen, pszLongUrl);
        }
        BAIL_ON_FAILURE(hr);
    }
    else {
    // assume UMI path if not native
        hr = UmiToWinNTPath(
                pURL, 
                &pszLongUrl,
                &dwNumComponents,
                &ppszClasses
                );
        BAIL_ON_FAILURE(hr);
    }

    // get the native path of the parent and the relative name of new object
 
    Lexer.SetBuffer(pszLongUrl);
    pObjectInfo = &ObjectInfo;
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    if(FAILED(hr)) {
        pObjectInfo = NULL; // so we don't attempt to free object info later
        goto error;
    }

    hr = BuildParent(pObjectInfo, pszLongUrl);
    BAIL_ON_FAILURE(hr);

    if(pObjectInfo->NumComponents != 0)
        RelName = 
          pObjectInfo->DisplayComponentArray[pObjectInfo->NumComponents - 1];
    else
    // can't have a parent for such a path
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    // Decrement number of components since we are dealing with the parent
    dwNumComponents--;

    hr = GetObject(
            pszLongUrl,
            (LPVOID *) &pUnkParent,
            *m_pCreds
            );
    BAIL_ON_FAILURE(hr);

    hr = pUnkParent->QueryInterface(
            IID_IUmiADSIPrivate,
            (LPVOID *) &pUmiPrivate
            );
    BAIL_ON_FAILURE(hr);

    hr = pUmiPrivate->GetCoreObject((void **) &pCoreObj);
    BAIL_ON_FAILURE(hr);

    // walk the list of classes in reverse order. Reason for reverse order
    // is that the WinNT provider may tack on an additional component to
    // the ADsPath stored in the core object. For example,
    // Open("WinNT://ntdsdc1") would return an ADsPath of
    // "WinNT://ntdev/ntdsdc1".

    if(dwNumComponents > 0) {
        dwCoreIndex = pCoreObj->_dwNumComponents - 1;
        for(dwIndex = dwNumComponents - 1; ((long) dwIndex) >= 0; dwIndex--) {
            if( _wcsicmp(
                  ppszClasses[dwIndex],
                  pCoreObj->_CompClasses[dwCoreIndex]) ) {

                BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);
            }

            dwCoreIndex--;
        }
    }

    hr = pUmiPrivate->GetContainer((void **) &pIADsCont);
    BAIL_ON_FAILURE(hr);

    if(NULL == pIADsCont)
    // parent object is not a container
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    // get the class of this object
    hr = m_pIADs->get_Class(&bstrClass);
    BAIL_ON_FAILURE(hr);

    // make sure that the destination path mentioned the same class
    if(_wcsicmp(bstrClass, ppszClasses[dwNumComponents]))
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH); 
   
    // now Create() the new object
    hr = pIADsCont->Create(
            bstrClass,
            RelName,
            &pDispatch
            );
    if(E_NOTIMPL == hr) // parent is namespace object
        hr = UMI_E_FAIL;
    BAIL_ON_FAILURE(hr);

    hr = pDispatch->QueryInterface(IID_IUmiObject, (LPVOID *) &pUmiObj);
    BAIL_ON_FAILURE(hr); 

    // if the source object is bound, refresh it if required
    if(ADS_OBJECT_BOUND == m_pCoreObj->GetObjectState()) {
    // object exists on server
        if(FALSE == m_fRefreshDone) {
            hr = m_pCoreObj->ImplicitGetInfo();
            BAIL_ON_FAILURE(hr);
        }
    }

    // copy over the attributes in the property cache
    hr = CopyPropCache(pUmiObj, (IUmiObject *) this);
    BAIL_ON_FAILURE(hr);

    hr = pUmiObj->QueryInterface(riid, pCopy);
    BAIL_ON_FAILURE(hr);

error:

    if( (pszLongUrl != NULL) && (pszLongUrl != pszUrl) )
        FreeADsMem(pszLongUrl);

    if(bstrClass != NULL)
        SysFreeString(bstrClass);

    if(pUnkParent != NULL)
        pUnkParent->Release();

    if(pIADsCont != NULL)
        pIADsCont->Release();

    if(pUmiObj != NULL)
        pUmiObj->Release();

    if(pUmiPrivate != NULL)
        pUmiPrivate->Release();

    if(pDispatch != NULL)
        pDispatch->Release();

    if(pObjectInfo != NULL)
        FreeObjectInfo(&ObjectInfo, TRUE);

    if(ppszClasses != NULL) {
        for(dwIndex = 0; dwIndex < dwNumComponents; dwIndex++) {
            if(ppszClasses[dwIndex] != NULL)
                FreeADsStr(ppszClasses[dwIndex]);
        }
        FreeADsMem(ppszClasses);
    }

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   GetCoreObject
//
// Synopsis:   Returns a pointer to the core object of the
//             underlying WinNT object. Used as a backdoor to get access to
//             the WinNT core object from a UMI object. Implements
//             IUmiADSIPrivate::GetCoreObject().
//
// Arguments:
//
// ppCoreObj   Returns pointer to core object of WinNT object
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppCoreObj to return the core object pointer.
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::GetCoreObject(void **ppCoreObj)
{
    if(NULL == ppCoreObj)
        RRETURN(UMI_E_INVALIDARG);

    *ppCoreObj = NULL;

    if(NULL == m_pCoreObj)
    // shouldn't happen. Just being paranoid.
        RRETURN(UMI_E_FAIL);

    *ppCoreObj = (void *) m_pCoreObj;

    RRETURN(S_OK);
}
       
//----------------------------------------------------------------------------
// Function:   CheckClasses 
//
// Synopsis:   Checks that the classes specified in the UMI path passed to
//             Move are valid. Need a separate function for this because UMI
//             doesn't actually retrieve the object that is to be moved - it
//             is handled internally within ADSI. So, we need to check the 
//             classes before calling into ADSI. We make use of the fact that
//             the WinNT provider only supports moving user and group objects. 
//
// Arguments:
//
// dwNumComponents Number of components in the UMI path
// ppszClasses     Class of each component
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   Nothing 
//
//----------------------------------------------------------------------------
HRESULT CUmiObject::CheckClasses(
    DWORD dwNumComponents,
    LPWSTR *ppszClasses
    )
{
    if(NULL == ppszClasses)
        RRETURN(UMI_E_INVALIDARG);

    if( (dwNumComponents != 2) && (dwNumComponents != 3) )
        RRETURN(UMI_E_INVALIDARG);

    // can only move users or groups
    if( _wcsicmp(ppszClasses[dwNumComponents - 1], USER_CLASS_NAME) &&
        _wcsicmp(ppszClasses[dwNumComponents - 1], GROUP_CLASS_NAME) )
        RRETURN(UMI_E_INVALIDARG);

    if(2 == dwNumComponents) {
        if( _wcsicmp(ppszClasses[0], DOMAIN_CLASS_NAME) &&
            _wcsicmp(ppszClasses[0], COMPUTER_CLASS_NAME) )
            RRETURN(UMI_E_INVALIDARG);
    } 

    if(3 == dwNumComponents) {
        if( _wcsicmp(ppszClasses[0], DOMAIN_CLASS_NAME) ||
            _wcsicmp(ppszClasses[1], COMPUTER_CLASS_NAME) )
            RRETURN(UMI_E_INVALIDARG);
    }

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\extension.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for ADs.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop


LPCWSTR lpszTopLevel = L"SOFTWARE\\Microsoft\\ADs\\Providers\\WinNT";
LPCWSTR lpszExtensions = L"Extensions";

PCLASS_ENTRY gpClassHead = NULL;


PCLASS_ENTRY
BuildClassesList()
{
    HKEY hTopLevelKey = NULL;
    HKEY hExtensionKey = NULL;
    HKEY hExtensionRootKey = NULL;

    HKEY hClassKey = NULL;

    DWORD dwIndex = 0;
    WCHAR lpszClassName[MAX_PATH];
    DWORD dwchClassName = 0;
    PCLASS_ENTRY pClassHead = NULL;
    PCLASS_ENTRY pClassEntry = NULL;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     lpszTopLevel,
                     0,
                     KEY_READ,
                     &hTopLevelKey
                     ) != ERROR_SUCCESS)
    {
        goto CleanupAndExit;
    }

    if (RegOpenKeyEx(hTopLevelKey,
                     lpszExtensions,
                     0,
                     KEY_READ,
                     &hExtensionRootKey
                     ) != ERROR_SUCCESS)

    {
        goto CleanupAndExit;

    }

    memset(lpszClassName, 0, sizeof(lpszClassName));
    dwchClassName = sizeof(lpszClassName)/sizeof(WCHAR);

    while(RegEnumKeyEx(hExtensionRootKey,
                     dwIndex,
                     lpszClassName,
                     &dwchClassName,
                     NULL,
                     NULL,
                     NULL,
                     NULL
                     ) == ERROR_SUCCESS)
    {
        //
        // Read namespace
        //

        if (RegOpenKeyEx(hExtensionRootKey,
                         lpszClassName,
                         0,
                         KEY_READ,
                         &hClassKey
                         ) != ERROR_SUCCESS){
            goto CleanupAndExit;
        }

        pClassEntry  = BuildClassEntry(
                                lpszClassName,
                                hClassKey
                                );

        if (pClassEntry) {

            pClassEntry->pNext = pClassHead;
            pClassHead = pClassEntry;
        }

        if (hClassKey) {
            CloseHandle(hClassKey);
        }

        memset(lpszClassName, 0, sizeof(lpszClassName));
        dwchClassName = sizeof(lpszClassName)/sizeof(WCHAR);
        dwIndex++;
    }

CleanupAndExit:

    if (hExtensionRootKey) {
        RegCloseKey(hExtensionRootKey);
    }

    if (hTopLevelKey) {
        RegCloseKey(hTopLevelKey);
    }

    return(pClassHead);
}


VOID
FreeClassesList(
    PCLASS_ENTRY pClassHead
    )
{
    PCLASS_ENTRY pDelete;

    while (pClassHead) {

        pDelete = pClassHead;
        pClassHead = pClassHead->pNext;

        FreeClassEntry(pDelete);
    }

    return;
}


PCLASS_ENTRY
BuildClassEntry(
    LPWSTR lpszClassName,
    HKEY hClassKey
    )
{
    HKEY hTopLevelKey = NULL;
    HKEY hExtensionKey = NULL;

    DWORD dwIndex = 0;
    DWORD dwchExtensionCLSID = 0;
    WCHAR lpszExtensionCLSID[MAX_PATH];
    PCLASS_ENTRY pClassEntry = NULL;
    PEXTENSION_ENTRY pExtensionHead = NULL;
    PEXTENSION_ENTRY pExtensionEntry = NULL;

    pClassEntry =  (PCLASS_ENTRY)AllocADsMem(sizeof(CLASS_ENTRY));

    if (!pClassEntry) {

        goto CleanupAndExit;
    }

    wcscpy(pClassEntry->szClassName, lpszClassName);

    memset(lpszExtensionCLSID, 0, sizeof(lpszExtensionCLSID));
    dwchExtensionCLSID = sizeof(lpszExtensionCLSID)/sizeof(WCHAR);

    while(RegEnumKeyEx(hClassKey,
                     dwIndex,
                     lpszExtensionCLSID,
                     &dwchExtensionCLSID,
                     NULL,
                     NULL,
                     NULL,
                     NULL
                     ) == ERROR_SUCCESS)
    {
        //
        // Read namespace
        //

        if (RegOpenKeyEx(hClassKey,
                         lpszExtensionCLSID,
                         0,
                         KEY_READ,
                         &hExtensionKey
                         ) != ERROR_SUCCESS){
            goto CleanupAndExit;
        }

        //
        // Read the Interfaces that this Extension supports
        //

        pExtensionEntry = BuildExtensionEntry(
                                lpszExtensionCLSID,
                                hExtensionKey
                                );

        if (pExtensionEntry) {

            wcscpy(pExtensionEntry->szExtensionCLSID, lpszExtensionCLSID);

            pExtensionEntry->pNext = pExtensionHead;
            pExtensionHead = pExtensionEntry;
        }


        if (hExtensionKey) {

            CloseHandle(hExtensionKey);
        }

        memset(lpszExtensionCLSID, 0, sizeof(lpszExtensionCLSID));
        dwchExtensionCLSID = sizeof(lpszExtensionCLSID)/sizeof(WCHAR);
        dwIndex++;

    }

    pClassEntry->pExtensionHead = pExtensionHead;




CleanupAndExit:

    return(pClassEntry);
}


PEXTENSION_ENTRY
BuildExtensionEntry(
    LPWSTR lpszExtensionCLSID,
    HKEY hExtensionKey
    )
{
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    PINTERFACE_ENTRY pInterfaceEntry = NULL;
    PINTERFACE_ENTRY pInterfaceHead = NULL;
    WCHAR lpszInterfaces[MAX_PATH];
    DWORD dwchInterfaces = 0;
    LPWSTR psz = NULL;
    WCHAR Interface[MAX_PATH];
    HRESULT hr = S_OK;


    pExtensionEntry =  (PEXTENSION_ENTRY)AllocADsMem(sizeof(EXTENSION_ENTRY));

    if (!pExtensionEntry) {

        goto CleanupAndExit;
    }

    memset(lpszInterfaces, 0, sizeof(lpszInterfaces));
    dwchInterfaces = sizeof(lpszInterfaces);

    RegQueryValueEx(
            hExtensionKey,
            L"Interfaces",
            NULL,
            NULL,
            (LPBYTE) lpszInterfaces,
            &dwchInterfaces
            );

    psz = lpszInterfaces;

    while (psz && *psz) {

       wcscpy(Interface, psz);

       // skip (length) + 1
       // lstrlen returns length sans '\0'


       pInterfaceEntry = (PINTERFACE_ENTRY)AllocADsMem(sizeof(INTERFACE_ENTRY));

       if (pInterfaceEntry) {

           wcscpy(pInterfaceEntry->szInterfaceIID, Interface);
           hr = IIDFromString(Interface, &(pInterfaceEntry->iid));

           pInterfaceEntry->pNext = pInterfaceHead;
           pInterfaceHead = pInterfaceEntry;

       }

       psz = psz + lstrlen(psz) + 1;

    }

    wcscpy(pExtensionEntry->szExtensionCLSID, lpszExtensionCLSID);
    hr = CLSIDFromString(lpszExtensionCLSID, &(pExtensionEntry->ExtCLSID));

    pExtensionEntry->pIID = pInterfaceHead;

CleanupAndExit:

    return(pExtensionEntry);
}


void
FreeInterfaceEntry(
    PINTERFACE_ENTRY pInterfaceEntry
    )
{
    if (pInterfaceEntry) {

        FreeADsMem(pInterfaceEntry);
    }
}


void
FreeExtensionEntry(
    PEXTENSION_ENTRY pExtensionEntry
    )
{
    PINTERFACE_ENTRY pInterfaceEntry = NULL;
    PINTERFACE_ENTRY pTemp = NULL;

    if (pExtensionEntry) {

        pInterfaceEntry = pExtensionEntry->pIID;

        while (pInterfaceEntry) {

            pTemp = pInterfaceEntry->pNext;

            if (pInterfaceEntry) {

                FreeInterfaceEntry(pInterfaceEntry);
            }

            pInterfaceEntry = pTemp;

        }

        //
        // Now unload the Extension Object
        //

        if (pExtensionEntry->pUnknown) {

            //
            // Call non-delegating Release to release ref. count on innner
            // object (for pUnkown) -> inner object self destroy
            //
            (pExtensionEntry->pUnknown)->Release();

        }


        FreeADsMem(pExtensionEntry);
    }

    return;
}

void
FreeClassEntry(
    PCLASS_ENTRY pClassEntry
    )
{

    PEXTENSION_ENTRY pExtensionEntry = NULL;
    PEXTENSION_ENTRY pTemp = NULL;

    if (pClassEntry) {

        pExtensionEntry = pClassEntry->pExtensionHead;

        while (pExtensionEntry) {

            pTemp = pExtensionEntry->pNext;

            if (pExtensionEntry) {

                FreeExtensionEntry(pExtensionEntry);
            }

            pExtensionEntry = pTemp;

        }

        FreeADsMem(pClassEntry);
    }

    return;
}


PINTERFACE_ENTRY
MakeCopyofInterfaceEntry(
    PINTERFACE_ENTRY pInterfaceEntry
    )
{
    PINTERFACE_ENTRY pNewInterfaceEntry = NULL;

    pNewInterfaceEntry = (PINTERFACE_ENTRY)AllocADsMem(sizeof(INTERFACE_ENTRY));

    if (pNewInterfaceEntry) {

        wcscpy(pNewInterfaceEntry->szInterfaceIID, pInterfaceEntry->szInterfaceIID);
        memcpy(&(pNewInterfaceEntry->iid), &(pInterfaceEntry->iid), sizeof(GUID));
    }

    return(pNewInterfaceEntry);
}



PEXTENSION_ENTRY
MakeCopyofExtensionEntry(
    PEXTENSION_ENTRY pExtensionEntry
    )
{
    PEXTENSION_ENTRY pNewExtensionEntry = NULL;

    PINTERFACE_ENTRY pInterfaceEntry = NULL;

    PINTERFACE_ENTRY pNewInterfaceEntry = NULL;

    PINTERFACE_ENTRY pNewInterfaceHead = NULL;


    pInterfaceEntry = pExtensionEntry->pIID;

    while (pInterfaceEntry) {

        pNewInterfaceEntry = MakeCopyofInterfaceEntry(pInterfaceEntry);

        if (pNewInterfaceEntry) {

            pNewInterfaceEntry->pNext = pNewInterfaceHead;
            pNewInterfaceHead = pNewInterfaceEntry;
        }

        pInterfaceEntry = pInterfaceEntry->pNext;

    }

    pNewExtensionEntry = (PEXTENSION_ENTRY)AllocADsMem(sizeof(EXTENSION_ENTRY));

    if (pNewExtensionEntry) {

        wcscpy(
            pNewExtensionEntry->szExtensionCLSID,
            pExtensionEntry->szExtensionCLSID
            );

        memcpy(
            &(pNewExtensionEntry->ExtCLSID),
            &(pExtensionEntry->ExtCLSID),
            sizeof(GUID)
            );

        pNewExtensionEntry->pIID = pNewInterfaceHead;


        //
        // Initialize fields we won't know the values of until an instacne of
        // the extension is created and aggregated (loaded).
        //

        pNewExtensionEntry->pUnknown=NULL;
        pNewExtensionEntry->pPrivDisp=NULL;
        pNewExtensionEntry->pADsExt=NULL;
        pNewExtensionEntry->fDisp=FALSE;
        pNewExtensionEntry->dwExtensionID = (DWORD) -1; //invalid dwExtensionID

        //
        // let class entry handle pNext
        //
    }

    return(pNewExtensionEntry);
}


PCLASS_ENTRY
MakeCopyofClassEntry(
    PCLASS_ENTRY pClassEntry
    )
{
    PCLASS_ENTRY pNewClassEntry = NULL;

    PEXTENSION_ENTRY pExtensionEntry = NULL;

    PEXTENSION_ENTRY pNewExtensionEntry = NULL;

    PEXTENSION_ENTRY pNewExtensionHead = NULL;


    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {

        pNewExtensionEntry = MakeCopyofExtensionEntry(pExtensionEntry);

        if (pNewExtensionEntry) {

            pNewExtensionEntry->pNext = pNewExtensionHead;
            pNewExtensionHead = pNewExtensionEntry;
        }

        pExtensionEntry = pExtensionEntry->pNext;

    }

    pNewClassEntry = (PCLASS_ENTRY)AllocADsMem(sizeof(CLASS_ENTRY));

    if (pNewClassEntry) {

        wcscpy(pNewClassEntry->szClassName, pClassEntry->szClassName);

        pNewClassEntry->pExtensionHead = pNewExtensionHead;

    }

    return(pNewClassEntry);
}


CRITICAL_SECTION g_ExtCritSect;

#define ENTER_EXTENSION_CRITSECT()  EnterCriticalSection(&g_ExtCritSect)
#define LEAVE_EXTENSION_CRITSECT()  LeaveCriticalSection(&g_ExtCritSect)

HRESULT
ADSIGetExtensionList(
    LPWSTR pszClassName,
    PCLASS_ENTRY * ppClassEntry
    )
{

    PCLASS_ENTRY pTempClassEntry = NULL;
    PCLASS_ENTRY pClassEntry = NULL;
    ENTER_EXTENSION_CRITSECT();

    pTempClassEntry = gpClassHead;

    while (pTempClassEntry) {


        if (!_wcsicmp(pTempClassEntry->szClassName, pszClassName)) {

            //
            // Make a copy of this entire extension and
            // hand it over to the calling entity.
            //

            pClassEntry = MakeCopyofClassEntry(pTempClassEntry);

            *ppClassEntry = pClassEntry;

            LEAVE_EXTENSION_CRITSECT();

            RRETURN(S_OK);

        }

        pTempClassEntry = pTempClassEntry->pNext;

   }


   *ppClassEntry = NULL;

   LEAVE_EXTENSION_CRITSECT();

   RRETURN(S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cuser.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuser.cxx
//
//  Contents:  Host user object code
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop


//  Class CWinNTUser

DEFINE_IDispatch_ExtMgr_Implementation(CWinNTUser)
DEFINE_IADsExtension_ExtMgr_Implementation(CWinNTUser)
DEFINE_IADs_TempImplementation(CWinNTUser)
DEFINE_IADs_PutGetImplementation(CWinNTUser,UserClass,gdwUserTableSize)
DEFINE_IADsPropertyList_Implementation(CWinNTUser,UserClass,gdwUserTableSize)

CWinNTUser::CWinNTUser():
        _pDispMgr(NULL),
        _pExtMgr(NULL),
        _pPropertyCache(NULL),
        _ParentType(0),
        _DomainName(NULL),
        _ServerName(NULL),
        _fPasswordSet(FALSE),
        _dwRasPermissions(0),
        _pCCredentialsPwdHolder(NULL),
        _fUseCacheForAcctLocked(TRUE),
        _fComputerAcct(FALSE)
{
    ENLIST_TRACKING(CWinNTUser);
}

HRESULT
CWinNTUser::CreateUser(
    BSTR Parent,
    ULONG ParentType,
    BSTR DomainName,
    BSTR ServerName,
    BSTR UserName,
    DWORD dwObjectState,
    DWORD *pdwUserFlags,    // OPTIONAL
    LPWSTR szFullName,      // OPTIONAL
    LPWSTR szDescription,   // OPTIONAL
    PSID pSid,              // OPTIONAL
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTUser FAR * pUser = NULL;
    HRESULT hr = S_OK;

    hr = AllocateUserObject(&pUser);
    BAIL_ON_FAILURE(hr);

    ADsAssert(pUser->_pDispMgr);


    hr = pUser->InitializeCoreObject(
                Parent,
                UserName,
                USER_CLASS_NAME,
                USER_SCHEMA_NAME,
                CLSID_WinNTUser,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);


    pUser->_Credentials = Credentials;

    //
    // The server name will be NULL only when we create a user
    // by SID - WinNT://S-1-321-231-231. In this case we should
    // not ref the server. Parent type is used as an extra check.
    //
    if (!((ParentType == WINNT_COMPUTER_ID)
          && !ServerName)) {

        hr = pUser->_Credentials.Ref(ServerName, DomainName, ParentType);
        if (hr == HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS)) {
            //
            // We had a rebind error.
            // This will happen in the case where the credentials
            // ref the current server which is a bdc, the users is
            // a member of a global group we are going through and
            // we end up trying to ref the PDC when we already have
            // a connection to this comp.
            hr = S_OK;
        }
    }

    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(DomainName, &pUser->_DomainName);

    BAIL_ON_FAILURE(hr);

    if (ParentType == WINNT_DOMAIN_ID)
    {
        pUser->_ParentType = WINNT_DOMAIN_ID;

        ADsAssert(DomainName && DomainName[0]!=L'\0');
    }
    else
    {
        pUser->_ParentType = WINNT_COMPUTER_ID;
        hr = ADsAllocString(ServerName, &pUser->_ServerName);

        BAIL_ON_FAILURE(hr);
    }


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                USER_CLASS_NAME,
                (IADsUser *) pUser,
                pUser->_pDispMgr,
                Credentials,
                &pUser->_pExtMgr
                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pUser->_pExtMgr);

    //
    // Prepopulate the object
    //
    hr = pUser->Prepopulate(TRUE,
                            pdwUserFlags,
                            szFullName,
                            szDescription,
                            pSid);
    BAIL_ON_FAILURE(hr);

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where 
    // riid passed into this function is defaulted to IID_IDispatch - 
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI 
    // will QI for the appropriate interface.
    //
        if(3 == pUser->_dwNumComponents) {
            pUser->_CompClasses[0] = L"Domain";
            pUser->_CompClasses[1] = L"Computer";
            pUser->_CompClasses[2] = L"User";
        }
        else if(2 == pUser->_dwNumComponents) {
            if(NULL == DomainName) {
                pUser->_CompClasses[0] = L"Computer";
                pUser->_CompClasses[1] = L"User";
            }
            else if(NULL == ServerName) {
                pUser->_CompClasses[0] = L"Domain";
                pUser->_CompClasses[1] = L"User";
            }
            else
                BAIL_ON_FAILURE(hr = UMI_E_FAIL);
       }
       else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);
         
        hr = pUser->InitUmiObject(   
                pUser->_Credentials,
                UserClass,
                gdwUserTableSize,
                pUser->_pPropertyCache,
                (IUnknown *) (INonDelegatingUnknown *) pUser,
                pUser->_pExtMgr,
                IID_IUnknown,
                ppvObj
                );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr); 
    }
 
    hr = pUser->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pUser->Release();

    RRETURN(hr);

error:
    delete pUser;

    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CWinNTUser::CreateUser(
   BSTR Parent,
   ULONG ParentType,
   BSTR DomainName,
   BSTR ServerName,
   BSTR UserName,
   DWORD dwObjectState,
   REFIID riid,
   CWinNTCredentials& Credentials,
   void **ppvObj
   )
{
    HRESULT hr = S_OK;

    hr = CWinNTUser::CreateUser(
                           Parent,
                           ParentType,
                           DomainName,
                           ServerName,
                           UserName,
                           dwObjectState,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           riid,
                           Credentials,
                           ppvObj
                           );

    RRETURN_EXP_IF_ERR(hr);
}


CWinNTUser::~CWinNTUser( )
{
    ADsFreeString(_DomainName);
    ADsFreeString(_ServerName);

    delete _pExtMgr;                // created last, destroyed first

    delete _pDispMgr;

    delete _pPropertyCache;

    if (_pCCredentialsPwdHolder) {
        delete _pCCredentialsPwdHolder;
    }
}

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTUser::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTUser::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTUser::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTUser::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsUser))
    {
        *ppv = (IADsUser FAR *) this;
    }

    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }

    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(iid, IID_IADsExtension) )
    {
        *ppv = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN(_pExtMgr->QueryInterface(iid,ppv));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTUser::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsPropertyList) ||
        IsEqualIID(riid, IID_IADsUser)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CWinNTUser::SetInfo(THIS)
{
    HRESULT hr = S_OK;
    NET_API_STATUS nasStatus;
    WCHAR szPDCName[MAX_PATH];
    WCHAR *pszPassword = NULL;
    WCHAR *pszServerName = _ServerName;

    //
    // objects associated with invalid SIDs have neither a
    // corresponding server nor domain
    //
    if ((!_DomainName) && (!_ServerName)) {
        BAIL_ON_FAILURE(hr = E_ADS_INVALID_USER_OBJECT);
    }


    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        if (_ParentType == WINNT_DOMAIN_ID) {

            hr = WinNTGetCachedDCName(
                           _DomainName,
                           szPDCName,
                           _Credentials.GetFlags()
                            );
            BAIL_ON_FAILURE(hr);

            //
            // + 2 skips the backslashes when calling create
            //
            pszServerName = szPDCName + 2;
        }


        if (!_fPasswordSet) {


            hr = WinNTCreateUser(
                     pszServerName,
                     _Name
                     );

        } else {

            hr = getPrivatePassword(&pszPassword);
            BAIL_ON_FAILURE(hr);

            hr = WinNTCreateUser(
                     pszServerName,
                     _Name,
                     pszPassword
                     );
        }

        BAIL_ON_FAILURE(hr);


        SetObjectState(ADS_OBJECT_BOUND);
    }


    hr = SetInfo(3);

    if(SUCCEEDED(hr))
        _pPropertyCache->ClearModifiedFlags();

error:

    if (pszPassword) {
        FreeADsStr(pszPassword);
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUser::GetInfo(THIS)
{
    HRESULT hr;

    _pPropertyCache->flushpropcache();

    // USER_INFO
    //

    hr = GetInfo(
                3,
                TRUE
                );

    BAIL_ON_FAILURE(hr);

    //
    // USER_MODAL_INFO0
    //

    hr =  GetInfo(
                10,
                TRUE
                );
    BAIL_ON_FAILURE(hr);

    //
    // USER_MODAL_INFO3
    //

    hr = GetInfo(
                13,
                TRUE
                );
    BAIL_ON_FAILURE(hr);

    if(FALSE == _fComputerAcct) {

#ifndef WIN95

        //
        // Get the RAS permissions. Do this only for user accounts and
        // not for machine accounts.
        //
        //
        hr = GetInfo(21, TRUE);
        BAIL_ON_FAILURE(hr);
#endif
    }

    //
    // objectSid. LookupAccountName fails for machine accounts on NT4, but
    // works on Win2K. In order for an explicit GetInfo to succeed against NT4
    // systems we do not check the error code returned below. If this call 
    // fails, a subsequent Get("ObjectSid") will return 
    // E_ADS_PROPERTY_NOT_FOUND. 
    //

    GetInfo(
        20,
        TRUE
        );

error :

    RRETURN(hr);
}

STDMETHODIMP
CWinNTUser::ImplicitGetInfo(THIS)
{
    HRESULT hr;

#ifndef WIN95

    //
    // Get the RAS permissions first
    //
    //
    hr = GetInfo(21, FALSE);
    BAIL_ON_FAILURE(hr);
#endif

    // USER_INFO
    //

    hr = GetInfo(
                3,
                FALSE
                );

    BAIL_ON_FAILURE(hr);

    //
    // USER_MODAL_INFO0
    //

    hr =  GetInfo(
                10,
                FALSE
                );
    BAIL_ON_FAILURE(hr);

    //
    // USER_MODAL_INFO3
    //

    hr = GetInfo(
                13,
                FALSE
                );
    BAIL_ON_FAILURE(hr);

    //
    // objectSid
    //

    hr = GetInfo(
                20,
                FALSE
                );

error :

    RRETURN(hr);
}


HRESULT
CWinNTUser::AllocateUserObject(
    CWinNTUser ** ppUser
    )
{
    CWinNTUser FAR * pUser = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pUser = new CWinNTUser();
    if (pUser == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsUser,
                (IADsUser *)pUser,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pUser,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
             UserClass,
             gdwUserTableSize,
             (CCoreADsObject *)pUser,
             &pPropertyCache
             );
    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(
                pPropertyCache
                );


    pUser->_pPropertyCache = pPropertyCache;
    pUser->_pDispMgr = pDispMgr;
    *ppUser = pUser;

    RRETURN(hr);

error:

    delete  pDispMgr;
    delete  pPropertyCache;
    delete  pUser;

    RRETURN(hr);
}


//
// For current implementation in clocgroup:
// If this function is called as a public function (ie. by another
// modual/class), fExplicit must be FALSE since the cache is NOT
// flushed in this function.
//
// External functions should ONLY call GetInfo(no param) for explicit
// GetInfo. This will flush the cache properly.
//

STDMETHODIMP
CWinNTUser::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    switch (dwApiLevel) {

    // GetInfo(1 or 2, fExplicit) in ADSI codes should be modified
    // to GetInfo(3, fExplicit) to minimize calls on wire.

    case 3:
        hr = GetStandardInfo(3, fExplicit);
        RRETURN_EXP_IF_ERR(hr);

    case 10:
        hr = GetModalInfo(0, fExplicit);
        RRETURN_EXP_IF_ERR(hr);

    case 13:
        hr = GetModalInfo(3, fExplicit);
        RRETURN_EXP_IF_ERR(hr);

    case 20:
        hr = GetSidInfo(fExplicit);
        RRETURN_EXP_IF_ERR(hr);

#ifndef WIN95
    case 21:
        hr = GetRasInfo(fExplicit);
        RRETURN_EXP_IF_ERR(hr);
#endif

    default:
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    }

}



HRESULT
CWinNTUser::GetStandardInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    NET_API_STATUS nasStatus;
    LPBYTE lpBuffer = NULL;
    HRESULT hr;
    WCHAR szHostServerName[MAX_PATH];


    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);
    }

    //
    // objects associated with invalid SIDs have neither a
    // corresponding server nor domain
    //
    if ((!_DomainName) && (!_ServerName)) {
        BAIL_ON_FAILURE(hr = E_ADS_INVALID_USER_OBJECT);
    }


    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = WinNTGetCachedDCName(
                    _DomainName,
                    szHostServerName,
                    _Credentials.GetFlags()
                    );
        BAIL_ON_FAILURE(hr);

    }else {

       hr = MakeUncName(
                _ServerName,
                szHostServerName
                );
    }

    nasStatus = NetUserGetInfo(
                    szHostServerName,
                    _Name,
                    dwApiLevel,
                    &lpBuffer
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

    hr = UnMarshall(
            lpBuffer,
            dwApiLevel,
            fExplicit
            );
    BAIL_ON_FAILURE(hr);

error:
    if (lpBuffer) {
        NetApiBufferFree(lpBuffer);
    }

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CWinNTUser::UnMarshall(
    LPBYTE lpBuffer,
    DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    VARIANT_BOOL fBool;
    BSTR bstrData = NULL;
    LONG lnData = 0L;
    VARIANT vaData;
    DATE daDate = 0;

    ADsAssert(lpBuffer);
    switch (dwApiLevel) {

    // GetStandardInfo currently only be called with dwApiLevel=3. If
    // dwApiLevel = 1 or 2 is used, modify ADSI codes to 3.

    case 3:
        RRETURN(UnMarshall_Level3(fExplicit, (LPUSER_INFO_3)lpBuffer));
        break;

    default:
        RRETURN(E_FAIL);

    }
}


HRESULT
CWinNTUser::UnMarshall_Level3(
    BOOL fExplicit,
    LPUSER_INFO_3 pUserInfo3
    )
{
    HRESULT hr = S_OK;

    //
    // Begin Account Restrictions Properties
    //

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("UserFlags"),
                pUserInfo3->usri3_flags,
                fExplicit
                );

    if(SUCCEEDED(hr)) {
        _fUseCacheForAcctLocked = TRUE;
    }

    if( (pUserInfo3->usri3_flags & UF_WORKSTATION_TRUST_ACCOUNT) || 
        (pUserInfo3->usri3_flags & UF_SERVER_TRUST_ACCOUNT) ||
        (pUserInfo3->usri3_flags & UF_INTERDOMAIN_TRUST_ACCOUNT) ) {
            _fComputerAcct = TRUE;
    }


    //
    // If usri3_acct_expires == TIMEQ_FOREVER, it means we need
    // to ignore the acct expiration date, the account
    // can never expire.
    //

    if (pUserInfo3->usri3_acct_expires != TIMEQ_FOREVER) {

        hr = SetDATE70PropertyInCache(
                    _pPropertyCache,
                    TEXT("AccountExpirationDate"),
                    pUserInfo3->usri3_acct_expires,
                    fExplicit
                    );

    }

    hr = SetDelimitedStringPropertyInCache(
                _pPropertyCache,
                TEXT("LoginWorkstations"),
                pUserInfo3->usri3_workstations,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("MaxStorage"),
                pUserInfo3->usri3_max_storage,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("PasswordAge"),
                pUserInfo3->usri3_password_age,
                fExplicit
                );


    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("PasswordExpired"),
                pUserInfo3->usri3_password_expired,
                fExplicit
                );

    hr = SetOctetPropertyInCache(
                _pPropertyCache,
                TEXT("LoginHours"),
                pUserInfo3->usri3_logon_hours,
                21,
                fExplicit
                );



    //
    // Begin Business Info Properties
    //

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("FullName"),
                pUserInfo3->usri3_full_name,
                fExplicit
                );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Description"),
                pUserInfo3->usri3_comment,
                fExplicit
                );

    //
    // Begin Account Statistics Properties
    //

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("BadPasswordAttempts"),
                pUserInfo3->usri3_bad_pw_count,
                fExplicit
                );

    //
    // lasg_logon/off == 0 means user never logon/off or logon/off time unknown.
    //

    if (pUserInfo3->usri3_last_logon!=0) {

        hr = SetDATE70PropertyInCache(
                _pPropertyCache,
                TEXT("LastLogin"),
                pUserInfo3->usri3_last_logon,
                fExplicit
                );
    }


    if (pUserInfo3->usri3_last_logoff!=0) {

        hr = SetDATE70PropertyInCache(
                _pPropertyCache,
                TEXT("LastLogoff"),
                pUserInfo3->usri3_last_logoff,
                fExplicit
                );
    }


    //
    // Begin Other Info Properties
    //

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("HomeDirectory"),
                pUserInfo3->usri3_home_dir,
                fExplicit
                );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("LoginScript"),
                pUserInfo3->usri3_script_path,
                fExplicit
                );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Profile"),
                pUserInfo3->usri3_profile,
                fExplicit
                );


    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("HomeDirDrive"),
                pUserInfo3->usri3_home_dir_drive,
                fExplicit
                );


    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Parameters"),
                pUserInfo3->usri3_parms,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("PrimaryGroupID"),
                pUserInfo3->usri3_primary_group_id,
                fExplicit
                );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );

    RRETURN(S_OK);
}


HRESULT
CWinNTUser::Prepopulate(
    BOOL fExplicit,
    DWORD *pdwUserFlags,    // OPTIONAL
    LPWSTR szFullName,      // OPTIONAL
    LPWSTR szDescription,   // OPTIONAL
    PSID pSid               // OPTIONAL
    )
{
    HRESULT hr = S_OK;

    DWORD dwErr = 0;
    DWORD dwSidLength = 0;
    
    //
    // Prepopulate the object with supplied info,
    // if available
    //
    if (pdwUserFlags) {
        hr = SetDWORDPropertyInCache(
                    _pPropertyCache,
                    TEXT("UserFlags"),
                    *pdwUserFlags,
                    TRUE
                    );                        
        BAIL_ON_FAILURE(hr);

        //
        // see comment on _fUseCacheForAcctLocked in cuser.hxx
        //
        _fUseCacheForAcctLocked = FALSE;
    }


    if (szFullName) {
        hr = SetLPTSTRPropertyInCache(
                    _pPropertyCache,
                    TEXT("FullName"),
                    szFullName,
                    TRUE
                    );                        
        BAIL_ON_FAILURE(hr);
    }


    if (szDescription) {
        hr = SetLPTSTRPropertyInCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    szDescription,
                    TRUE
                    );                        
        BAIL_ON_FAILURE(hr);
    }

    if (pSid) {

        //
        // On NT4 for some reason GetLengthSID does not set lasterror to 0
        //
        SetLastError(NO_ERROR);

        dwSidLength = GetLengthSid(pSid);

        //
        // This is an extra check to make sure that we have the
        // correct length.
        //
        dwErr = GetLastError();
        if (dwErr != NO_ERROR) {
            hr = HRESULT_FROM_WIN32(dwErr);
            BAIL_ON_FAILURE(hr);
        }
    
        hr = SetOctetPropertyInCache(
                    _pPropertyCache,
                    TEXT("objectSid"),
                    (PBYTE) pSid,
                    dwSidLength,
                    TRUE
                    );
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);

}

HRESULT
CWinNTUser::GetSidInfo(
    IN BOOL fExplicit
    )
{
    HRESULT hr = E_FAIL;
    WCHAR szHostServerName[MAX_PATH];

    //
    // objects associated with invalid SIDs have neither a
    // corresponding server nor domain
    //
    if ((!_DomainName) && (!_ServerName)) {
        BAIL_ON_FAILURE(hr = E_ADS_INVALID_USER_OBJECT);
    }


    //
    // Get Server Name
    //

    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = WinNTGetCachedDCName(
                    _DomainName,
                    szHostServerName,
                    _Credentials.GetFlags()
                    );
        BAIL_ON_FAILURE(hr);

    }else {

       hr = MakeUncName(
                _ServerName,
                szHostServerName
                );
    }

    //
    // Get Sid of this user account and store in cache if fExplicit.
    //

    hr = GetSidIntoCache(
            szHostServerName,
            _Name,
            _pPropertyCache,
            fExplicit
            );
    BAIL_ON_FAILURE(hr);


error:

    RRETURN(hr);
}





HRESULT
CWinNTUser::GetRasInfo(
    IN BOOL fExplicit
    )
{
#ifdef WIN95
    RRETURN(E_NOTIMPL);
#else
    HRESULT hr = E_FAIL;
    WCHAR szHostServerName[MAX_PATH];
    RAS_USER_0 RasUser0;
    DWORD nasStatus = 0;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);
    }

    //
    // objects associated with invalid SIDs have neither a
    // corresponding server nor domain
    //
    if ((!_DomainName) && (!_ServerName)) {
        BAIL_ON_FAILURE(hr = E_ADS_INVALID_USER_OBJECT);
    }


    //
    // Get Server Name
    //

    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = WinNTGetCachedDCName(
                    _DomainName,
                    szHostServerName,
                    _Credentials.GetFlags()
                    );
        BAIL_ON_FAILURE(hr);

    }else {

       hr = MakeUncName(
                _ServerName,
                szHostServerName
                );
    }


    //
    // Make Ras call to get permissions.
    //
    nasStatus = RasAdminUserGetInfo(
                    szHostServerName,
                    _Name,
                    &RasUser0
                    );
    if (nasStatus) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(nasStatus));
    }

    _dwRasPermissions = RasUser0.bfPrivilege;

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("RasPermissions"),
                RasUser0.bfPrivilege,
                fExplicit
                );

error:

    RRETURN(hr);
#endif
}

HRESULT
CWinNTUser::SetInfo(THIS_ DWORD dwApiLevel)
{
    NET_API_STATUS nasStatus;
    HRESULT hr;
    LPBYTE lpBuffer = NULL;
    DWORD dwParamErr = 0;
    WCHAR szHostServerName[MAX_PATH];
#ifndef WIN95
    RAS_USER_0 RasUser0;
    DWORD dwRasPerms = 0;
#endif

    //
    // objects associated with invalid SIDs have neither a
    // corresponding server nor domain
    //
    if ((!_DomainName) && (!_ServerName)) {
        BAIL_ON_FAILURE(hr = E_ADS_INVALID_USER_OBJECT);
    }


    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = WinNTGetCachedDCName(
                    _DomainName,
                    szHostServerName,
                    _Credentials.GetFlags()
                    );
        BAIL_ON_FAILURE(hr);

    }else {
        hr = MakeUncName(
                 _ServerName,
                 szHostServerName
                 );
        BAIL_ON_FAILURE(hr);

    }

#ifndef WIN95
    //
    // Since Ras stuff is the new addition do this first.
    // There is a chance that we may fail after creating the
    // user but I do not see anyway to avoid this.
    // Check to see if the value is set in the cace and only
    // if it is set and is different from the value we have
    // do we try and change it.
    //
    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("RasPermissions"),
                    &dwRasPerms
                    );

    if (SUCCEEDED(hr) && (dwRasPerms != _dwRasPermissions)) {
        //
        // Get the permissions and then set privelege as we
        // do not want to change the callback number param.
        //
        nasStatus = RasAdminUserGetInfo(
                        szHostServerName,
                        _Name,
                        &RasUser0
                        );
        if (nasStatus) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(nasStatus));
        }

        RasUser0.bfPrivilege = (BYTE) dwRasPerms;

        nasStatus = RasAdminUserSetInfo(
                        szHostServerName,
                        _Name,
                        &RasUser0
                        );
        if (nasStatus) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(nasStatus));
        }
    } // Ras info.

#endif

    nasStatus = NetUserGetInfo(
                    szHostServerName,
                    _Name,
                    dwApiLevel,
                    &lpBuffer
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);


     hr = MarshallAndSet(szHostServerName, lpBuffer, dwApiLevel);
     BAIL_ON_FAILURE(hr);

error:

     if (lpBuffer) {
         NetApiBufferFree(lpBuffer);
     }


     RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTUser::MarshallAndSet(
    LPWSTR szHostServerName,
    LPBYTE lpBuffer,
    DWORD  dwApiLevel
    )
{
    ADsAssert(lpBuffer);
    switch (dwApiLevel) {

    //
    // dwApiLevel = 1 or 2 should change to 3 in caller codes to min
    // calls on wire

    case 3:
        RRETURN(Marshall_Set_Level3(szHostServerName, (LPUSER_INFO_3)lpBuffer));
        break;

    //
    // caae 10:
    // case 13:
    // USER_MODAL_INFO should be set at domain level,
    // Not at user level
    //

    //
    // case 20:
    // objectSid not writable
    //

    default:
        RRETURN(E_FAIL);

    }
}


HRESULT
CWinNTUser::Marshall_Set_Level3(
    LPWSTR szHostServerName,
    LPUSER_INFO_3 pUserInfo3
    )
{
    HRESULT hr;

    DWORD dwFlags = 0;
    DWORD dwAcctExpDate = 0;
    LPWSTR pszDescription = NULL;
    LPWSTR pszFullName = NULL;
    DWORD dwBadPwCount = 0;
    DWORD dwLastLogin = 0;
    DWORD dwLastLogoff = 0;
    LPWSTR pszHomeDir = NULL;
    LPWSTR pszScript = NULL;
    LPWSTR pszProfile = NULL;
    LPWSTR pszLoginWorkstations = NULL;
    DWORD dwMaxStorage = 0;
    LPWSTR pszHomeDirDrive = NULL;
    LPWSTR pszParameters = NULL;
    DWORD dwPrimaryGroupId = 0;
    DWORD dwPasswordExpired = 0;
	OctetString octetString;


    DWORD dwParmErr = 0;
    NET_API_STATUS nasStatus;

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("UserFlags"),
                    &dwFlags
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_flags = dwFlags;
    }

    hr = GetDATE70PropertyFromCache(
                    _pPropertyCache,
                    TEXT("AccountExpirationDate"),
                    &dwAcctExpDate
                    );
    if(SUCCEEDED(hr)){

        //
        // Pick an easy to remeber date to represent "account never expires" :
        // 1/1/70 at 0:00. (Range <= 86400 and >= 0xffffffff-86400 is +/- one
        // day from 1/1/70 at 0:00 to take time localization into account.)
        //

        if (dwAcctExpDate <=  86400 || dwAcctExpDate >= (0xffffffff-86400)) {
            pUserInfo3->usri3_acct_expires = TIMEQ_FOREVER;
        }
        else {
            pUserInfo3->usri3_acct_expires = dwAcctExpDate;
        }
    }

    hr = GetDWORDPropertyFromCache(
                   _pPropertyCache,
                   TEXT("PasswordExpired"),
                   &dwPasswordExpired
                   );
    if(SUCCEEDED(hr)){
       pUserInfo3->usri3_password_expired = dwPasswordExpired;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("MaxStorage"),
                    &dwMaxStorage
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_max_storage = dwMaxStorage;
    }

    hr = GetDelimitedStringPropertyFromCache(
                    _pPropertyCache,
                    TEXT("LoginWorkstations"),
                    &pszLoginWorkstations
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_workstations = pszLoginWorkstations;
    }

    //
    // Begin Business Information Properties
    //

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    &pszDescription
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_comment = pszDescription;
    }


    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("FullName"),
                    &pszFullName
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_full_name = pszFullName;
    }

    hr = GetOctetPropertyFromCache(
                    _pPropertyCache,
                    TEXT("LoginHours"),
                    &octetString
                    );
    if(SUCCEEDED(hr)){
        memcpy(pUserInfo3->usri3_logon_hours,
               octetString.pByte,
               octetString.dwSize);
        FreeADsMem(octetString.pByte);
    }


    /*
    //
    // Begin Account Statistics Properties - should not be writable.
    //

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("BadPasswordAttempts"),
                    &dwBadPwCount
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_bad_pw_count = dwBadPwCount;
    }

    hr = GetDATE70PropertyFromCache(
                    _pPropertyCache,
                    TEXT("LastLogin"),
                    &dwLastLogin
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_last_logon = dwLastLogin;
    }

    hr = GetDATE70PropertyFromCache(
                    _pPropertyCache,
                    TEXT("LastLogoff"),
                    &dwLastLogoff
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_last_logoff = dwLastLogoff;
    }
    */

    //
    // Begin Other Info Properties
    //


    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("HomeDirectory"),
                    &pszHomeDir
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_home_dir = pszHomeDir;
    }


    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("LoginScript"),
                    &pszScript
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_script_path = pszScript;
    }

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Profile"),
                    &pszProfile
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_profile = pszProfile;
    }


    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("HomeDirDrive"),
                    &pszHomeDirDrive
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_home_dir_drive = pszHomeDirDrive;
    }


    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Parameters"),
                    &pszParameters
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_parms = pszParameters;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PrimaryGroupID"),
                    &dwPrimaryGroupId
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_primary_group_id = dwPrimaryGroupId;
    }

    //
    // Now perform the Set call.
    //

    nasStatus = NetUserSetInfo(
                        szHostServerName,
                        _Name,
                        3,
                        (LPBYTE)pUserInfo3,
                        &dwParmErr
                        );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

error:

    if (pszDescription) {
        FreeADsStr(pszDescription);
    }

    if (pszFullName) {
        FreeADsStr(pszFullName);
    }

    if (pszHomeDir) {
        FreeADsStr(pszHomeDir);
    }

    if (pszScript) {
        FreeADsStr(pszScript);
    }

    if (pszProfile) {
        FreeADsStr(pszProfile);
    }

    if (pszLoginWorkstations) {
        FreeADsStr(pszLoginWorkstations);
    }

    if (pszParameters) {
        FreeADsStr(pszParameters);
    }

    if (pszHomeDirDrive) {
        FreeADsStr(pszHomeDirDrive);
    }



    RRETURN(hr);
}


HRESULT
CWinNTUser::Marshall_Create_Level1(
    LPWSTR szHostServerName,
    LPUSER_INFO_1 pUserInfo1
    )
{
    HRESULT hr = S_OK;
    NET_API_STATUS nasStatus;
    DWORD dwParmErr;

    pUserInfo1->usri1_name =  _Name;
    pUserInfo1->usri1_password = NULL;
    pUserInfo1->usri1_password_age = DEF_MAX_PWAGE;
    pUserInfo1->usri1_priv = 1;
    pUserInfo1->usri1_home_dir = NULL;
    pUserInfo1->usri1_comment = NULL;
    pUserInfo1->usri1_flags = 0x00000201;
    pUserInfo1->usri1_script_path = NULL;

    nasStatus = NetUserAdd(
                    szHostServerName,
                    1,
                    (LPBYTE)pUserInfo1,
                    &dwParmErr
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);

    RRETURN(hr);
}





HRESULT
CWinNTUser::GetModalInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    NET_API_STATUS nasStatus;
    LPBYTE lpBuffer = NULL;
    HRESULT hr;
    WCHAR szPDCName[MAX_PATH];

    //
    // objects associated with invalid SIDs have neither a
    // corresponding server nor domain
    //
    if ((!_DomainName) && (!_ServerName)) {
        BAIL_ON_FAILURE(hr = E_ADS_INVALID_USER_OBJECT);
    }


    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = WinNTGetCachedDCName(
                    _DomainName,
                    szPDCName,
                    _Credentials.GetFlags()
                    );
        BAIL_ON_FAILURE(hr);

    }else {

        hr = MakeUncName(
                 _ServerName,
                 szPDCName
                );
        BAIL_ON_FAILURE(hr);
    }

    nasStatus = NetUserModalsGet(
                    szPDCName,
                    dwApiLevel,
                    &lpBuffer
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

    hr = UnMarshallModalInfo(lpBuffer, dwApiLevel, fExplicit);
    BAIL_ON_FAILURE(hr);

error:
    if (lpBuffer) {
        NetApiBufferFree(lpBuffer);
    }

    RRETURN(hr);
}


HRESULT
CWinNTUser::UnMarshallModalInfo(
    LPBYTE lpBuffer,
    DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    ADsAssert(lpBuffer);
    switch (dwApiLevel) {
    case 0:
        RRETURN(UnMarshall_ModalLevel0(fExplicit, (LPUSER_MODALS_INFO_0)lpBuffer));
        break;

    case 2:
        RRETURN(UnMarshall_ModalLevel2(fExplicit, (LPUSER_MODALS_INFO_2)lpBuffer));
        break;


    case 3:
        RRETURN(UnMarshall_ModalLevel3(fExplicit, (LPUSER_MODALS_INFO_3)lpBuffer));
        break;

    default:
        RRETURN(E_FAIL);

    }
}



HRESULT
CWinNTUser::UnMarshall_ModalLevel0(
    BOOL fExplicit,
    LPUSER_MODALS_INFO_0 pUserInfo0
    )
{

    HRESULT hr = S_OK;

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("MinPasswordLength"),
                pUserInfo0->usrmod0_min_passwd_len,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("MaxPasswordAge"),
                pUserInfo0->usrmod0_max_passwd_age,
                fExplicit
                );


    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("MinPasswordAge"),
                pUserInfo0->usrmod0_min_passwd_age,
                fExplicit
                );


    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("PasswordHistoryLength"),
                pUserInfo0->usrmod0_password_hist_len,
                fExplicit
                );

    RRETURN(S_OK);
}



HRESULT
CWinNTUser::UnMarshall_ModalLevel2(
    BOOL fExplicit,
    LPUSER_MODALS_INFO_2 pUserInfo2
    )
{
    RRETURN(S_OK);
}


HRESULT
CWinNTUser::UnMarshall_ModalLevel3(
    BOOL fExplicit,
    LPUSER_MODALS_INFO_3 pUserInfo3
    )
{
    HRESULT hr = S_OK;

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("AutoUnlockInterval"),
                pUserInfo3->usrmod3_lockout_duration,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("LockoutObservationInterval"),
                pUserInfo3->usrmod3_lockout_observation_window,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("MaxBadPasswordsAllowed"),
                pUserInfo3->usrmod3_lockout_threshold,
                fExplicit
                );

    RRETURN(S_OK);
}


//
// This method is meant to set the password, so that new users
// can be created, their password set and then SetInfo can be
// called. This is necessary to allow creation of users when there
// are restrictions such as passwd should be present.
//
HRESULT
CWinNTUser::setPrivatePassword(
    PWSTR pszNewPassword
    )
{
    HRESULT hr = S_OK;

    // CCred safely stores password for us
    if (_pCCredentialsPwdHolder) {

        hr = _pCCredentialsPwdHolder->SetPassword(pszNewPassword);
        BAIL_ON_FAILURE(hr);

    } else
        _pCCredentialsPwdHolder = new CCredentials(NULL, pszNewPassword, 0);

    if (!_pCCredentialsPwdHolder) {
        hr = E_OUTOFMEMORY;
    } else
        _fPasswordSet = TRUE;

error:


    RRETURN(hr);
}

//
// This method is meant to set the password, so that new users
// can be created, their password set and then SetInfo can be
// called. This is necessary to allow creation of users when there
// are restrictions such as passwd should be present.
//
HRESULT
CWinNTUser::getPrivatePassword(
    PWSTR * ppszPassword
    )
{
    HRESULT hr = S_OK;

    if (_pCCredentialsPwdHolder && _fPasswordSet) {
        hr = _pCCredentialsPwdHolder->GetPassword(ppszPassword);
    } else
        hr = E_FAIL;

    RRETURN(hr);
}

HRESULT
CWinNTUser::GetUserFlags(
    DWORD *pdwUserFlags
    )
{
    HRESULT hr = S_OK;
    NET_API_STATUS nasStatus;
    LPBYTE lpBuffer = NULL;
    WCHAR szHostServerName[MAX_PATH];

    ADsAssert(pdwUserFlags != NULL);

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);
    }

    //
    // objects associated with invalid SIDs have neither a
    // corresponding server nor domain
    //
    if ((!_DomainName) && (!_ServerName)) {
        BAIL_ON_FAILURE(hr = E_ADS_INVALID_USER_OBJECT);
    }

    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = WinNTGetCachedDCName(
                    _DomainName,
                    szHostServerName,
                    _Credentials.GetFlags()
                    );
        BAIL_ON_FAILURE(hr);

    }else {

       hr = MakeUncName(
                _ServerName,
                szHostServerName
                );
    }

    nasStatus = NetUserGetInfo(
                    szHostServerName,
                    _Name,
                    3,
                    &lpBuffer
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

    *pdwUserFlags = ((LPUSER_INFO_3)lpBuffer)->usri3_flags;

error:
    if (lpBuffer) {
        NetApiBufferFree(lpBuffer);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\fsmacro.h ===
#define PUT_PROPERTY_LONG(this, Property) \
                HRESULT tmphr; \
                tmphr = put_LONG_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        l##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_LONG(this, Property) \
                HRESULT tmphr; \
                tmphr = get_LONG_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define PUT_PROPERTY_BSTR(this, Property) \
                HRESULT tmphr; \
                tmphr = put_BSTR_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        bstr##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_BSTR(this, Property) \
                HRESULT tmphr; \
                tmphr = get_BSTR_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define PUT_PROPERTY_VARIANT_BOOL(this, Property) \
                HRESULT tmphr; \
                tmphr = put_VARIANT_BOOL_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        f##Property\
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_VARIANT_BOOL(this, Property) \
                HRESULT tmphr; \
                tmphr = get_VARIANT_BOOL_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define PUT_PROPERTY_DATE(this, Property) \
                HRESULT tmphr; \
                tmphr = put_DATE_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        da##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_DATE(this, Property) \
                HRESULT tmphr; \
                tmphr = get_DATE_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define PUT_PROPERTY_VARIANT(this, Property) \
                HRESULT tmphr; \
                tmphr = put_VARIANT_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        v##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_VARIANT(this, Property) \
                HRESULT tmphr; \
                tmphr = get_VARIANT_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\globals.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       globals.cxx
//
//  Contents:   Global Variables for WinNT
//
//  Functions:
//
//  History:    25-March-96   KrishnaG   Created.
//  Updated:    4-May-2000    sivaramr  Added a property called Name to all
//              classes in order to support keys in UMI.
//              13-Aug-2000   AjayR Added support to dynamically load
//              functions that are not on earlier NT versions.        
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop

//
// Global variabled needed to keep track of dynamically
// loaded libs.
//
HANDLE g_hDllNetapi32;
HANDLE g_hDllAdvapi32;
CRITICAL_SECTION g_csLoadLibs;
BOOL g_fDllsLoaded;
FRTLENCRYPTMEMORY g_pRtlEncryptMemory = NULL;
FRTLDECRYPTMEMORY g_pRtlDecryptMemory = NULL;

WCHAR *szProviderName = TEXT("WinNT");

#define MAX_LONG    (0x7FFFFFFF)
#define MIN_LONG    (0x80000000)
#define MAX_BOOLEAN 1
#define MAX_STRLEN  (256)

PROPERTYINFO DomainClass[] =
    { { TEXT("MinPasswordLength"),  // FSDomainPassword
        TEXT(""), TEXT("Integer"), LM20_PWLEN+1, 0, FALSE,
        PROPERTY_RW, 0, NT_SYNTAX_ID_DWORD },
      { TEXT("MinPasswordAge"),
        TEXT(""), TEXT("Interval"), TIMEQ_FOREVER, 0, FALSE,
        PROPERTY_RW, 0, NT_SYNTAX_ID_DWORD },
      { TEXT("MaxPasswordAge"),
        TEXT(""),TEXT("Interval"), TIMEQ_FOREVER, ONE_DAY, FALSE,
        PROPERTY_RW, 0, NT_SYNTAX_ID_DWORD },
      { TEXT("MaxBadPasswordsAllowed"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },
      //
      // NetAPI state DEF_MAX_PWHIST (8), but NetAPI devlpr confirm
      // current is 1024. Ignore Net Account - UNIQUEPWD limit.
      // Use DEF_MAX_PWHIST to be safe for now
      //
      { TEXT("PasswordHistoryLength"),
        TEXT(""), TEXT("Integer"), DEF_MAX_PWHIST, 0, FALSE,
        PROPERTY_RW, 0, NT_SYNTAX_ID_DWORD},
      { TEXT("AutoUnlockInterval"),
        TEXT(""), TEXT("Interval"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },
      { TEXT("LockoutObservationInterval"),
        TEXT(""), TEXT("Interval"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },
      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwDomainTableSize = sizeof(DomainClass)/sizeof(PROPERTYINFO);

PROPERTYINFO ComputerClass[] =
    { { TEXT("Owner"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Division"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR },
      { TEXT("OperatingSystem"), // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR},
      { TEXT("OperatingSystemVersion"), // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR},
      { TEXT("Processor"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ProcessorCount"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Name"), 
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 4, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwComputerTableSize = sizeof(ComputerClass)/sizeof(PROPERTYINFO);

PROPERTYINFO UserClass[] =
    { // USER_INFO3
      { TEXT("Description"), // FSUserBusinessInfo
        TEXT(""), TEXT("String"), MAXCOMMENTSZ+1, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR },
      { TEXT("FullName"),
        TEXT(""), TEXT("String"), MAXCOMMENTSZ+1, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR},
      { TEXT("AccountExpirationDate"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DATE_1970},
      { TEXT("PasswordAge"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD},
      { TEXT("UserFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD},
      { TEXT("LoginWorkstations"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, TRUE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DelimitedString },
      { TEXT("BadPasswordAttempts"),   // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 3, NT_SYNTAX_ID_DWORD },
      { TEXT("MaxLogins"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },
      { TEXT("MaxStorage"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },
                                                  // USER_MAX_STORAGE_UNLIMITED
      { TEXT("PasswordExpired"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },

      { TEXT("PasswordExpirationDate"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DATE_1970 },

      { TEXT("LastLogin"),          // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, 3, NT_SYNTAX_ID_DATE_1970 },
      { TEXT("LastLogoff"),         // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, 3, NT_SYNTAX_ID_DATE_1970 },
      { TEXT("HomeDirectory"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Profile"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR},
      { TEXT("Parameters"),
        TEXT(""), TEXT("String"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR},
      { TEXT("HomeDirDrive"),
        TEXT(""), TEXT("String"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR},
      { TEXT("LoginScript"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR },
     { TEXT("LoginHours"),
       TEXT(""), TEXT("OctetString"), 0, 0, FALSE,
       PROPERTY_RW, 3, NT_SYNTAX_ID_OCTETSTRING},
      { TEXT("PrimaryGroupID"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },


      //
      // USER_MODAL_INFO0
      // NOTE!! - user_modal_info0 CANNOT (!!) be changed in USER class
      //          since they are meant for the entire domain.
      //        - user_modal_info0 CAN (!!) be changed in DOMAIN class
      //          only. Ref NetApi.
      //

      { TEXT("MinPasswordLength"),  // FSDomainPassword
        TEXT(""), TEXT("Integer"), LM20_PWLEN+1, 0, FALSE,
        PROPERTY_READABLE, 10, NT_SYNTAX_ID_DWORD },
      { TEXT("MinPasswordAge"),
        TEXT(""), TEXT("Interval"), TIMEQ_FOREVER, 0, FALSE,
        PROPERTY_READABLE, 10, NT_SYNTAX_ID_DWORD },
      { TEXT("MaxPasswordAge"),
        TEXT(""),TEXT("Interval"), TIMEQ_FOREVER, ONE_DAY, FALSE,
        PROPERTY_READABLE, 10, NT_SYNTAX_ID_DWORD },
      //
      // NetAPI state DEF_MAX_PWHIST (8), but NetAPI devlpr confirm
      // current is 1024. Ignore Net Account - UNIQUEPWD limit.
      // Use DEF_MAX_PWHIST to be safe for now
      //
      { TEXT("PasswordHistoryLength"),
        TEXT(""), TEXT("Integer"), DEF_MAX_PWHIST, 0, FALSE,
        PROPERTY_READABLE, 10, NT_SYNTAX_ID_DWORD},


      //
      // USER_MODAL_INFO3
      // NOTE!! - user_modal_info3 CANNOT (!!) be changed in USER class
      //          since they are meant for the entire domain.
      //        - user_modal_info3 CAN (!!) be changed in DOMAIN class
      //          only. Ref NetApi.
      //

      { TEXT("MaxBadPasswordsAllowed"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 13, NT_SYNTAX_ID_DWORD },
      { TEXT("AutoUnlockInterval"),
        TEXT(""), TEXT("Interval"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 13, NT_SYNTAX_ID_DWORD },
      { TEXT("LockoutObservationInterval"),
        TEXT(""), TEXT("Interval"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 13, NT_SYNTAX_ID_DWORD },


     //
     // Not for USER_INFO or USER_MODAL_INFO
     //

     { TEXT("objectSid"),
       TEXT(""), TEXT("OctetString"), 0, 0, FALSE,
       PROPERTY_READABLE, 20, NT_SYNTAX_ID_OCTETSTRING},

#ifndef WIN95
     { TEXT("RasPermissions"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROPERTY_RW, 21, NT_SYNTAX_ID_DWORD },
#endif
      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 3, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwUserTableSize = sizeof(UserClass)/sizeof(PROPERTYINFO);


PROPERTYINFO GroupClass[] =
    {
      { TEXT("Description"),            // FSGroupGeneralInfo
        TEXT(""), TEXT("String"), MAXCOMMENTSZ+1, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },

     { TEXT("objectSid"),
       TEXT(""), TEXT("OctetString"), 0, 0, FALSE,
       PROPERTY_READABLE, 20, NT_SYNTAX_ID_OCTETSTRING},

     { TEXT("groupType"),
       TEXT(""), TEXT("Integer"), 0, 0, FALSE,
       PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD},

     { TEXT("Name"),
       TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
       PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR }
    };


DWORD gdwGroupTableSize = sizeof(GroupClass)/sizeof(PROPERTYINFO);


PROPERTYINFO ServiceClass[] =
    { { TEXT("HostComputer"),          // FSServiceConfiguration
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("DisplayName"),
        TEXT(""), TEXT("String"), 256, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ServiceType"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD},
      { TEXT("StartType"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("Path"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ErrorControl"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("LoadOrderGroup"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ServiceAccountName"),
        TEXT(""), TEXT("String"), DNLEN+UNLEN+2, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR},
      { TEXT("Dependencies"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, TRUE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_NulledString},
      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwServiceTableSize = sizeof(ServiceClass)/sizeof(PROPERTYINFO);


PROPERTYINFO FileServiceClass[] =
    { { TEXT("HostComputer"),          // FSServiceConfiguration
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("DisplayName"),
        TEXT(""), TEXT("String"), 256, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Version"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ServiceType"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD},
      { TEXT("StartType"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("Path"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ErrorControl"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("LoadOrderGroup"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ServiceAccountName"),
        TEXT(""), TEXT("String"), DNLEN+UNLEN+2, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR},
      { TEXT("Dependencies"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, TRUE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_NulledString},
      { TEXT("Description"),            // FSFileServiceGeneralInfo
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("MaxUserCount"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwFileServiceTableSize = sizeof(FileServiceClass)/sizeof(PROPERTYINFO);

PROPERTYINFO SessionClass[] =
    { { TEXT("User"), // ro, FSSessionGeneralInfo
        TEXT(""), TEXT("String"), UNLEN+1, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Computer"), // ro
        TEXT(""), TEXT("String"), UNCLEN+1, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR},
      { TEXT("ConnectTime"),   // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_DATE },
      { TEXT("IdleTime"),      // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_DATE},
      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwSessionTableSize = sizeof(SessionClass)/sizeof(PROPERTYINFO);

PROPERTYINFO ResourceClass[] =
    { { TEXT("User"), // ro, FSResourceGeneralInfo
        TEXT(""), TEXT("String"), UNLEN+1, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Path"),     // ro
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("LockCount"), // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_DWORD},
      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwResourceTableSize = sizeof(ResourceClass)/sizeof(PROPERTYINFO);


PROPERTYINFO FileShareClass[] =
    { { TEXT("CurrentUserCount"), // ro, FSFileShareGeneralInfo
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("Description"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("HostComputer"),
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Path"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("MaxUserCount"),
        TEXT(""), TEXT("Integer"), MAX_LONG, -1, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwFileShareTableSize = sizeof(FileShareClass)/sizeof(PROPERTYINFO);

PROPERTYINFO FPNWFileServiceClass[] =
    { { TEXT("HostComputer"),          // FSServiceConfiguration
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("DisplayName"),
        TEXT(""), TEXT("String"), 256, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Version"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ServiceType"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD},
      { TEXT("StartType"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("Path"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ErrorControl"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("LoadOrderGroup"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ServiceAccountName"),
        TEXT(""), TEXT("String"), DNLEN+UNLEN+2, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR},
      { TEXT("Dependencies"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, TRUE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_NulledString},
      { TEXT("Description"),            // FSFileServiceGeneralInfo
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("MaxUserCount"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwFPNWFileServiceTableSize = sizeof(FPNWFileServiceClass)/sizeof(PROPERTYINFO);

PROPERTYINFO FPNWSessionClass[] =
    { { TEXT("User"), // ro, FSSessionGeneralInfo
        TEXT(""), TEXT("String"), UNLEN+1, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Computer"), // ro
        TEXT(""), TEXT("String"), UNCLEN+1, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR},
      { TEXT("ConnectTime"),   // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_DATE },
      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR }
    };


DWORD gdwFPNWSessionTableSize = sizeof(FPNWSessionClass)/sizeof(PROPERTYINFO);

PROPERTYINFO FPNWResourceClass[] =
    { { TEXT("User"), // ro, FSResourceGeneralInfo
        TEXT(""), TEXT("String"), UNLEN+1, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Path"),     // ro
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("LockCount"), // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_DWORD},
      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwFPNWResourceTableSize = sizeof(FPNWResourceClass)/sizeof(PROPERTYINFO);

PROPERTYINFO FPNWFileShareClass[] =
    { { TEXT("CurrentUserCount"), // ro, FSFileShareGeneralInfo
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("HostComputer"),
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Path"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("MaxUserCount"),
        TEXT(""), TEXT("Integer"), MAX_LONG, -1, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwFPNWFileShareTableSize = sizeof(FPNWFileShareClass)/sizeof(PROPERTYINFO);

PROPERTYINFO PrintQueueClass[] =
    { { TEXT("PrinterPath"),    // FSPrintQueueGeneralInfo
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PrinterName"),    // friendly name
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Model"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Datatype"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PrintProcessor"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Description"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Location"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("StartTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("UntilTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("DefaultJobPriority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD},
      { TEXT("JobCount"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD},
      { TEXT("Priority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("Attributes"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD},
      { TEXT("BannerPage"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PrintDevices"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, TRUE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DelimitedString } ,


      { TEXT("ObjectGUID"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 7, NT_SYNTAX_ID_LPTSTR },

      { TEXT("Action"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 7, NT_SYNTAX_ID_DWORD },

      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwPrinterTableSize = sizeof(PrintQueueClass)/sizeof(PROPERTYINFO);

PROPERTYINFO PrintJobClass[] =
    { { TEXT("HostPrintQueue"),     // ro, FSPrintJobGeneralInfo
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("User"),               // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("TimeSubmitted"),      // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_SYSTEMTIME },
      { TEXT("TotalPages"),         // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("Size"),               // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD},
      { TEXT("Description"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Priority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD},
      { TEXT("StartTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("UntilTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("Notify"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("TimeElapsed"),        // ro
        TEXT(""), TEXT("Interval"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2,  NT_SYNTAX_ID_DWORD },
      { TEXT("PagesPrinted"),       // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("Position"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },

      { TEXT("ObjectGUID"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 7, NT_SYNTAX_ID_LPTSTR },

      { TEXT("Action"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 7, NT_SYNTAX_ID_DWORD },

      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwJobTableSize = sizeof(PrintJobClass)/sizeof(PROPERTYINFO);


CLASSINFO g_aWinNTClasses[] =
{

  // Domain
  { DOMAIN_SCHEMA_NAME, &CLSID_WinNTDomain, &IID_IADsDomain,
    TEXT(""), FALSE,

    NULL,

    TEXT("MinPasswordLength,MinPasswordAge,MaxPasswordAge,MaxBadPasswordsAllowed,")
    TEXT("PasswordHistoryLength,AutoUnlockInterval,LockoutObservationInterval,Name"),

    NULL, TEXT("Computer,User,Group"),TRUE,
    TEXT(""), 0,
    DomainClass, sizeof(DomainClass)/sizeof(PROPERTYINFO) },


  // Computer
  { COMPUTER_SCHEMA_NAME, &CLSID_WinNTComputer, &IID_IADsComputer,
    TEXT(""), FALSE,

    NULL,

    TEXT("Owner,Division,OperatingSystem,OperatingSystemVersion,")
    TEXT("Processor,ProcessorCount,Name"),

    TEXT("Domain"), TEXT("User,Group,Service,FileService,PrintQueue"), TRUE,
    TEXT(""), 0,
    ComputerClass, sizeof(ComputerClass)/sizeof(PROPERTYINFO) },


  // User
  { USER_SCHEMA_NAME, &CLSID_WinNTUser, &IID_IADsUser,
    TEXT(""), FALSE,

    NULL,

    TEXT("Description,FullName,AccountExpirationDate,")
    TEXT("BadPasswordAttempts,HomeDirDrive,HomeDirectory,")
    TEXT("LastLogin,LastLogoff,LoginHours,LoginScript,LoginWorkstations,")
    TEXT("MaxLogins,MaxPasswordAge,MaxStorage,")
    TEXT("MinPasswordAge,MinPasswordLength,objectSid,")
    TEXT("Parameters,PasswordAge,PasswordExpired,")
    TEXT("PasswordHistoryLength,PrimaryGroupID,Profile,UserFlags,")
    TEXT("RasPermissions,Name"),

    TEXT("Domain,Computer"), NULL, FALSE,
    TEXT(""), 0,
    UserClass, sizeof(UserClass)/sizeof(PROPERTYINFO) },


  // Group
  { GROUP_SCHEMA_NAME, &CLSID_WinNTGroup, &IID_IADsGroup,
    TEXT(""), FALSE,


    TEXT("groupType"),

    TEXT("Description,objectSid,Name"),

    TEXT("Domain,Computer"), NULL, FALSE,
    TEXT(""), 0,
    GroupClass, sizeof(GroupClass)/sizeof(PROPERTYINFO) },


  { SERVICE_SCHEMA_NAME, &CLSID_WinNTService, &IID_IADsService,
    TEXT(""), FALSE,

    TEXT("StartType,ServiceType,")
    TEXT("DisplayName,Path,ErrorControl"),


    TEXT("HostComputer,")
    TEXT("LoadOrderGroup,ServiceAccountName,")
    TEXT("Dependencies,Name"),


    TEXT("Computer"), NULL, FALSE,
    TEXT(""), 0,
    ServiceClass, sizeof(ServiceClass)/sizeof(PROPERTYINFO) },

  { FILESERVICE_SCHEMA_NAME, &CLSID_WinNTFileService, &IID_IADsFileService,
    TEXT(""), FALSE,


    NULL,


    TEXT("HostComputer,DisplayName,Version,ServiceType,StartType,")
    TEXT("ErrorControl,LoadOrderGroup,ServiceAccountName,Dependencies,")
    TEXT("Description,MaxUserCount,Name"),


    TEXT("Computer"), TEXT("FileShare"), TRUE,
    TEXT(""), 0,
    FileServiceClass, sizeof(FileServiceClass)/sizeof(PROPERTYINFO) },

  { SESSION_SCHEMA_NAME, &CLSID_WinNTSession, &IID_IADsSession,
    TEXT(""), FALSE,


    NULL,


    TEXT("User,Computer,ConnectTime,IdleTime,Name"),


    NULL, NULL, FALSE,
    TEXT(""), 0,
    SessionClass, sizeof(SessionClass)/sizeof(PROPERTYINFO) },

  { RESOURCE_SCHEMA_NAME, &CLSID_WinNTResource, &IID_IADsResource,
    TEXT(""), FALSE,



    NULL,


    TEXT("User,Path,LockCount,Name"),


    NULL, NULL, FALSE,
    TEXT(""), 0,
    ResourceClass, sizeof(ResourceClass)/sizeof(PROPERTYINFO) },

  { FILESHARE_SCHEMA_NAME,  &CLSID_WinNTFileShare,  &IID_IADsFileShare,
    TEXT(""), FALSE,

    TEXT("Path,MaxUserCount"),


    TEXT("CurrentUserCount,Description,HostComputer,Name"),


    TEXT("FileService"),
    NULL, FALSE,
    TEXT(""), 0,
    FileShareClass, sizeof(FileShareClass)/sizeof(PROPERTYINFO) },

  { FPNW_FILESERVICE_SCHEMA_NAME, &CLSID_WinNTFileService, &IID_IADsFileService,
    TEXT(""), FALSE,


    NULL,


    TEXT("HostComputer,DisplayName,Version,ServiceType,")
    TEXT("StartType,Path,ErrorControl,LoadOrderGroup,")
    TEXT("Description,MaxUserCount,Name"),


    TEXT("Computer"), TEXT("FileShare"), TRUE,
    TEXT(""), 0,
    FileServiceClass, sizeof(FileServiceClass)/sizeof(PROPERTYINFO) },

  { FPNW_SESSION_SCHEMA_NAME, &CLSID_WinNTSession, &IID_IADsSession,
    TEXT(""), FALSE,


    NULL,


    TEXT("User,Computer,ConnectTime,Name"),


    NULL, NULL, FALSE,
    TEXT(""), 0,
    SessionClass, sizeof(SessionClass)/sizeof(PROPERTYINFO) },

  { FPNW_RESOURCE_SCHEMA_NAME, &CLSID_WinNTResource, &IID_IADsResource,
    TEXT(""), FALSE,



    NULL,


    TEXT("User,Path,LockCount,Name"),


    NULL, NULL, FALSE,
    TEXT(""), 0,
    ResourceClass, sizeof(ResourceClass)/sizeof(PROPERTYINFO) },

  { FPNW_FILESHARE_SCHEMA_NAME,  &CLSID_WinNTFileShare,  &IID_IADsFileShare,
    TEXT(""), FALSE,


    TEXT("Path,MaxUserCount"),


    TEXT("CurrentUserCount,HostComputer,Name"),


    TEXT("FileService"),

    NULL, FALSE,
    TEXT(""), 0,
    FileShareClass, sizeof(FileShareClass)/sizeof(PROPERTYINFO) },

  { PRINTER_SCHEMA_NAME, &CLSID_WinNTPrintQueue, &IID_IADsPrintQueue,
    TEXT(""), FALSE,

    TEXT("PrinterName,Model,Datatype,")
    TEXT("PrintProcessor,PrintDevices"),

    TEXT("HostComputer,Description,")
    TEXT("Location,StartTime,UntilTime,DefaultJobPriority,JobCount,Priority,")
    TEXT("Attributes,BannerPage,ObjectGUID,Action,Name"),


    TEXT("Computer"), NULL, FALSE,
    TEXT(""), 0,
    PrintQueueClass, sizeof(PrintQueueClass)/sizeof(PROPERTYINFO) },

  { PRINTJOB_SCHEMA_NAME, &CLSID_WinNTPrintJob, &IID_IADsPrintJob,
    TEXT(""), FALSE,


    NULL,


    TEXT("HostPrintQueue,User,TimeSubmitted,TotalPages,Size,Description,")
    TEXT("Priority,StartTime,UntilTime,Notify,TimeElapsed,PagesPrinted,")
    TEXT("Position,Name"),


    NULL, NULL, FALSE,
    TEXT(""), 0,
    PrintJobClass, sizeof(PrintJobClass)/sizeof(PROPERTYINFO) }
};

SYNTAXINFO g_aWinNTSyntax[] =
{ {  TEXT("Boolean"),       VT_BOOL },
  {  TEXT("Counter"),       VT_I4 },
  {  TEXT("ADsPath"),     VT_BSTR },
  {  TEXT("EmailAddress"),  VT_BSTR },
  {  TEXT("FaxNumber"),     VT_BSTR },
  {  TEXT("Integer"),       VT_I4 },
  {  TEXT("Interval"),      VT_I4 },
  {  TEXT("List"),          VT_VARIANT },  // VT_BSTR | VT_ARRAY
  {  TEXT("NetAddress"),    VT_BSTR },
  {  TEXT("OctetString"),   VT_VARIANT },  // VT_UI1| VT_ARRAY
  {  TEXT("Path"),          VT_BSTR },
  {  TEXT("PhoneNumber"),   VT_BSTR },
  {  TEXT("PostalAddress"), VT_BSTR },
  {  TEXT("SmallInterval"), VT_I4 },
  {  TEXT("String"),        VT_BSTR },
  {  TEXT("Time"),          VT_DATE }
};

DWORD g_cWinNTClasses = (sizeof(g_aWinNTClasses)/sizeof(g_aWinNTClasses[0]));
DWORD g_cWinNTSyntax = (sizeof(g_aWinNTSyntax)/sizeof(g_aWinNTSyntax[0]));


CObjNameCache *  pgPDCNameCache = NULL;


PROPERTYINFO g_aWinNTProperties[] =
//
// domain properties
//
    { { TEXT("MinPasswordLength"),  // FSDomainPassword
        TEXT(""), TEXT("Integer"), LM20_PWLEN+1, 0, FALSE,
        PROPERTY_RW, 0, NT_SYNTAX_ID_DWORD },
      { TEXT("MinPasswordAge"),
        TEXT(""), TEXT("Interval"), TIMEQ_FOREVER, 0, FALSE,
        PROPERTY_RW, 0, NT_SYNTAX_ID_DWORD },
      { TEXT("MaxPasswordAge"),
        TEXT(""),TEXT("Interval"), TIMEQ_FOREVER, ONE_DAY, FALSE,
        PROPERTY_RW, 0, NT_SYNTAX_ID_DWORD },
      { TEXT("MaxBadPasswordsAllowed"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },

      //
      // NetAPI state DEF_MAX_PWHIST (8), but NetAPI devlpr confirm
      // current is 1024. Ignore Net Account - UNIQUEPWD limit.
      // User DEF_MAX_PWHIST to be safe for now.
      // not repeated for user ??
      //
      { TEXT("PasswordHistoryLength"),
        TEXT(""), TEXT("Integer"), DEF_MAX_PWHIST, 0, FALSE,
        PROPERTY_RW, 0, NT_SYNTAX_ID_DWORD},

      { TEXT("AutoUnlockInterval"),
        TEXT(""), TEXT("Interval"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },
      { TEXT("LockoutObservationInterval"),
        TEXT(""), TEXT("Interval"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },

    // Computer Properties

      { TEXT("Owner"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Division"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR },
      { TEXT("OperatingSystem"), // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR},
      { TEXT("OperatingSystemVersion"), // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR},
      { TEXT("Processor"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ProcessorCount"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR },


    // User Properties

     { TEXT("Description"), // FSUserBusinessInfo
        TEXT(""), TEXT("String"), MAXCOMMENTSZ+1, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR },
      { TEXT("FullName"),
        TEXT(""), TEXT("String"), MAXCOMMENTSZ+1, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR},
      { TEXT("AccountExpirationDate"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DATE_1970},
      { TEXT("PasswordAge"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DATE_1970},
      { TEXT("UserFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD},
      { TEXT("LoginWorkstations"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, TRUE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DelimitedString },
      { TEXT("BadPasswordAttempts"),    //ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 3, NT_SYNTAX_ID_DWORD },
      { TEXT("MaxLogins"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },
      { TEXT("MaxStorage"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },
                                                  // USER_MAX_STORAGE_UNLIMITED
      { TEXT("PasswordExpired"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },


      { TEXT("PasswordExpirationDate"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DATE_1970 },

      { TEXT("LastLogin"),          // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, 3, NT_SYNTAX_ID_DATE_1970 },
      { TEXT("LastLogoff"),         // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, 3, NT_SYNTAX_ID_DATE_1970 },
      { TEXT("HomeDirectory"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Profile"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR},
      { TEXT("Parameters"),
        TEXT(""), TEXT("String"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR},
      { TEXT("HomeDirDrive"),
        TEXT(""), TEXT("String"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR},
      { TEXT("LoginScript"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR },
      { TEXT("LoginHours"),
       TEXT(""), TEXT("OctetString"), 0, 0, FALSE,
       PROPERTY_RW, 3, NT_SYNTAX_ID_OCTETSTRING},
      { TEXT("PrimaryGroupID"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },
     { TEXT("objectSid"),
       TEXT(""), TEXT("OctetString"), 0, 0, FALSE,
       PROPERTY_READABLE, 20, NT_SYNTAX_ID_OCTETSTRING},

#ifndef WIN95
     { TEXT("RasPermissions"),
       TEXT(""), TEXT("Integer"), 0, 0, FALSE,
       PROPERTY_RW, 21, NT_SYNTAX_ID_DWORD},
#endif

    // Group Properties

     { TEXT("groupType"),
       TEXT(""), TEXT("Integer"), 0, 0, FALSE,
       PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD },

       //
      // Description (User)
      //

    // Service Properties

     { TEXT("HostComputer"),          // FSServiceConfiguration
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("DisplayName"),
        TEXT(""), TEXT("String"), 256, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ServiceType"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD},
      { TEXT("StartType"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("Path"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ErrorControl"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("LoadOrderGroup"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ServiceAccountName"),
        TEXT(""), TEXT("String"), DNLEN+UNLEN+2, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR},
      { TEXT("Dependencies"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, TRUE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_NulledString},

    // File Service Properties
      //
      // HostComputer(Service
      //
      //
      // DisplayName (Service)
      //
      { TEXT("Version"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      //
      // ServiceType (service)
      //
      // StartType (service)
      //
      //
      // Path (Service)
      //
      //
      // ErrorControl (service)
      //
      //
      // LoadOrderGroup(service)
      //
      //
      // ServiceAccountName (service)
      //
      //
      // Dependencies (Service)
      //
      // Description (user)
      //
      { TEXT("MaxUserCount"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD },

    // Session Properties

     { TEXT("User"), // ro, FSSessionGeneralInfo
        TEXT(""), TEXT("String"), UNLEN+1, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Computer"), // ro
        TEXT(""), TEXT("String"), UNCLEN+1, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR},
      { TEXT("ConnectTime"),   // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_DATE },
      { TEXT("IdleTime"),      // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_DATE},


    // Resource Properties
      //
      // User (session)
      //
      // Path (service)
      //
      { TEXT("LockCount"), // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_DWORD},



    // FileShareClass

     { TEXT("CurrentUserCount"), // ro, FSFileShareGeneralInfo
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD },

      //
      // Description (User)
      //
      //
      // HostComputer(Service)
      //
      //
      // Path (service)
      //
      //
      // MaxUserCount(FileService)
      //

     // FPNWFileServiceClass

      //
      // HostComputer (Service)
      //
      //
      // DisplayName (Service)
      //
      // Version (FileService)
      //
      //
      // ServiceType (service)
      //
      // StartType (service)
      //
      //
      // Path (Service)
      //
      //
      // ErrorControl (Service)
      //
      //
      // LoadOrderGroup (Service)
      //
      //
      // ServiceAccountName (service)
      //
      //
      // Dependencies (service)
      //
      //
      // Description (User)
      //
      //
      // MaxUserCount(FileService)
      //

    // FPNWSession Class
      //
      // User (Session)
      //
      //
      // Computer (session)
      //
      // ConnectTime (session)

    // FPNWResourceClass

      //
      // User (Session)
      //
      //
      // Path (Service)
      //
      //
      // LockCount (resource)
      //

    // FPNWFileShareClass

      // CurrentUserCount (FileShare)

      //
      // HostComputer(Service)
      //
      //
      // Path (service)
      //
      //
      // MaxUserCount (FileService)
      //

    // PrintQueueClass

     { TEXT("PrinterPath"), // FSPrintQueueGeneralInfo
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_LPTSTR },
     { TEXT("PrinterName"), // friendly name
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Model"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Datatype"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PrintProcessor"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },

      { TEXT("ObjectGUID"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 7, NT_SYNTAX_ID_LPTSTR },

      { TEXT("Action"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 7, NT_SYNTAX_ID_DWORD },



      //
      // Description (user)
      //
      { TEXT("Location"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("StartTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("UntilTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("DefaultJobPriority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD},
      { TEXT("JobCount"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD},
      { TEXT("Priority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("Attributes"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("BannerPage"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PrintDevices"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, TRUE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DelimitedString },

    // PrintJobClass

      { TEXT("HostPrintQueue"),     // ro, FSPrintJobGeneralInfo
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("TimeSubmitted"),      // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_SYSTEMTIME },
      { TEXT("TotalPages"),         // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("Size"),               // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD},
      //
      // Description (User)
      //
      //
      // Priority (PrintQueue)
      //
      // StartTime (PrintQueue)
      //
      // UntilTime (PrintQueue)
      //
      { TEXT("Notify"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("TimeElapsed"),        // ro
        TEXT(""), TEXT("Interval"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2,  NT_SYNTAX_ID_DWORD },
      { TEXT("PagesPrinted"),       // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("Position"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },

      // Name is common to all classes. Add one entry here for it.
      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR }

    };

DWORD g_cWinNTProperties = sizeof(g_aWinNTProperties)/sizeof(PROPERTYINFO);

//
// Support routines for dynamically loading entry points.
//
void BindToDlls()
{
    DWORD dwErr = 0;

    if (!g_fDllsLoaded) {
        EnterCriticalSection(&g_csLoadLibs);
        if (!g_fDllsLoaded) {
            g_hDllNetapi32 = LoadLibrary(L"NETAPI32.DLL");
            if (!g_hDllNetapi32) {
                dwErr = GetLastError();
            }

            if (g_hDllAdvapi32 = LoadLibrary(L"ADVAPI32.DLL")) {
                if (dwErr) {
                    //
                    // Set the last error for whatever it is worth.
                    // This does not really matter cause any dll we
                    // cannot load, we will not get functions on that
                    // dll. If secur32 load failed, then that call
                    // would have set a relevant last error.
                    //
                    SetLastError(dwErr);
                }
            }

            g_fDllsLoaded = TRUE;
            LeaveCriticalSection(&g_csLoadLibs);
        }
    }
}

//
// Locates entry points in NetApi32.
//
PVOID LoadNetApi32Function(CHAR *function)
{
    if (!g_fDllsLoaded) {
        BindToDlls();
    }

    if (g_hDllNetapi32) {
        return((PVOID*) GetProcAddress((HMODULE) g_hDllNetapi32, function));
    }

    return NULL;
}

//
// Locates entry points in advapi32
//
PVOID LoadAdvapi32Function(CHAR *function)
{
    if (!g_fDllsLoaded) {
        BindToDlls();
    }

    if (g_hDllAdvapi32) {
        return((PVOID*) GetProcAddress((HMODULE) g_hDllAdvapi32, function));
    }

    return NULL;
}

//
// DsUnquoteRdnValueWrapper
//
BOOL ConvertStringSidToSidWrapper(
    IN LPCWSTR   StringSid,
    OUT PSID   *Sid
    )
{
    static PF_ConvertStringSidToSid pfConvertStringSidToSid = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfConvertStringSidToSid == NULL) {
        pfConvertStringSidToSid
            = (PF_ConvertStringSidToSid)
                    LoadAdvapi32Function(CONVERT_STRING_TO_SID_API);

        f_LoadAttempted = TRUE;
    }

    if (pfConvertStringSidToSid != NULL) {
        return ((*pfConvertStringSidToSid)(
                      StringSid,
                      Sid
                      )
                );
    }
    else {
        SetLastError(ERROR_GEN_FAILURE);
        return (FALSE);
    }
}

BOOL ConvertSidToStringSidWrapper(
    IN  PSID     Sid,
    OUT LPWSTR  *StringSid
    )
{
    static PF_ConvertSidToStringSid pfConvertSidToSidString = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfConvertSidToSidString == NULL) {
        pfConvertSidToSidString =
            (PF_ConvertSidToStringSid)
                LoadAdvapi32Function(CONVERT_SID_TO_STRING_API);
        f_LoadAttempted = TRUE;
    }

    if (pfConvertSidToSidString != NULL) {
        return ((*pfConvertSidToSidString)(
                      Sid,
                      StringSid
                      )
                );
    }
    else {
        SetLastError(ERROR_GEN_FAILURE);
        return (FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\grput2.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumGroupCollection.cxx
//
//  Contents:  Windows NT 3.5 GroupCollection Enumeration Code
//
//
//
//
//
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

DOMAIN_GROUP_MEMBER DomMember;

//
// This assumes that addr is an LPBYTE type.
//
#define WORD_ALIGN_DOWN(addr) \
        addr = ((LPBYTE)((DWORD_PTR)addr & ~1))

DWORD DomainGrpMemberStrings[]=

                             {
                             FIELD_OFFSET(DOMAIN_GROUP_MEMBER, Parent),
                             FIELD_OFFSET(DOMAIN_GROUP_MEMBER, Computer),
                             FIELD_OFFSET(DOMAIN_GROUP_MEMBER, Domain),
                             FIELD_OFFSET(DOMAIN_GROUP_MEMBER, Name),
                             0xFFFFFFFF
                             };

BOOL
WinNTGlobalGroupOpen(
    LPWSTR szDomainName,
    LPWSTR szComputerName,
    LPWSTR szGroupName,
    PHANDLE phGroup
    )
{

    WCHAR szTempBuffer[MAX_PATH];
    PINI_DOM_GROUP pIniDomGrp;
    HRESULT hr;


    if (!phGroup) {
        return(FALSE);
    }
    pIniDomGrp = (PINI_DOM_GROUP)AllocADsMem(
                                        sizeof(INI_DOM_GROUP)
                                        );
    if (!pIniDomGrp) {
        return(FALSE);
    }

    hr = MakeUncName(
            szComputerName,
            szTempBuffer
            );
    BAIL_ON_FAILURE(hr);

    if (!(pIniDomGrp->szUncCompName =  AllocADsStr(szTempBuffer))){
        goto error;
    }

    if (!(pIniDomGrp->szDomainName = AllocADsStr(szDomainName))) {
        goto error;

    }

    if (!(pIniDomGrp->szComputerName =  AllocADsStr(szComputerName))){
        goto error;
    }

    if (!(pIniDomGrp->szGroupName = AllocADsStr(szGroupName))){
        goto error;
    }


    *phGroup =  (HANDLE)pIniDomGrp;

    return(TRUE);


error:
    if (pIniDomGrp) {
        FreeIniDomGroup(pIniDomGrp);
    }

    *phGroup = NULL;

    return(FALSE);

}


BOOL
WinNTGlobalGroupEnum(
    HANDLE hGroup,
    DWORD  dwRequested,
    LPBYTE * ppBuffer,
    PDWORD pdwReturned
    )
{

    LPDOMAIN_GROUP_MEMBER * ppGroupMembers = NULL;
    DWORD i = 0;
    BOOL dwRet = FALSE;
    DWORD dwReturned = 0;
    DWORD dwSize = 0;
    LPDOMAIN_GROUP_MEMBER pBuffer = NULL;
    LPBYTE pEnd = NULL;
    DWORD dwError = 0;
    BOOL retVal = FALSE;

    ppGroupMembers = (LPDOMAIN_GROUP_MEMBER *)AllocADsMem(
                                sizeof(LPDOMAIN_GROUP_MEMBER)* dwRequested
                                );
    if (!ppGroupMembers) {
        return(FALSE);
    }

    for (i = 0; i < dwRequested; i++) {

        dwRet = WinNTGlobalGroupGetObject(
                        hGroup,
                        &ppGroupMembers[dwReturned]
                        );

        if (!dwRet) {

            dwError = GetLastError();
            if (dwError == ERROR_INVALID_SID) {
                continue;
            }

            //
            // it was not because of a bad sid
            // so break out, nothing more can be done
            //

            break;


        }

        dwReturned++;

    }

    dwRet = ComputeGlobalGroupDataSize(
                    ppGroupMembers,
                    dwReturned,
                    &dwSize
                    );

    pBuffer = (LPDOMAIN_GROUP_MEMBER)AllocADsMem(
                        dwSize
                        );

    if (pBuffer) {

        retVal = TRUE;
        pEnd = (LPBYTE)((LPBYTE)(pBuffer) + dwSize);

        for (i = 0; i < dwReturned; i++) {

            pEnd = CopyIniDomGroupToDomGroup(
                            ppGroupMembers[i],
                            (LPBYTE)(pBuffer + i),
                            pEnd
                            );
        }
    }

    for (i = 0; i < dwReturned; i++ ) {
        FreeIntDomGroup(*(ppGroupMembers + i));
    }

    FreeADsMem(ppGroupMembers);

    //
    // This will be NULL if pBuffer alloc failed.
    //
    *ppBuffer = (LPBYTE)pBuffer;

    *pdwReturned  = retVal ? dwReturned : 0;

    if (!retVal) {
        return(FALSE);
    }

    if (dwReturned == dwRequested){
        return(TRUE);
    }else {
        return(FALSE);
    }
}

BOOL
WinNTGlobalGroupGetObject(
    HANDLE hGroup,
    LPDOMAIN_GROUP_MEMBER * ppGroupMember
    )
{

    BOOL dwRet = FALSE;
    PINI_DOM_GROUP pIniDomGrp = (PINI_DOM_GROUP)hGroup;
    NET_API_STATUS nasStatus = 0;

    if ((!pIniDomGrp->_pBuffer) ||
        (pIniDomGrp->_dwCurrentObject == pIniDomGrp->_dwObjectReturned)) {

        if (pIniDomGrp->_bNoMore) {

            //
            // No more objects to return
            //
            return(FALSE);
        }

        if (pIniDomGrp->_pBuffer) {
            NetApiBufferFree(pIniDomGrp->_pBuffer);
            pIniDomGrp->_pBuffer = NULL;
        }

        pIniDomGrp->_dwObjectReturned = 0;
        pIniDomGrp->_dwCurrentObject = 0;
        pIniDomGrp->_dwTotalObjects = 0;

        nasStatus = NetGroupGetUsers(
                        pIniDomGrp->szUncCompName,
                        pIniDomGrp->szGroupName,
                        0,
                        &pIniDomGrp->_pBuffer,
                        MAX_PREFERRED_LENGTH,
                        &pIniDomGrp->_dwObjectReturned,
                        &pIniDomGrp->_dwTotalObjects,
                        &pIniDomGrp->_dwResumeHandle
                        );

        if ((nasStatus != ERROR_SUCCESS) && (nasStatus != ERROR_MORE_DATA)){
            SetLastError(nasStatus);
            return(FALSE);
        }

        if (nasStatus != ERROR_MORE_DATA) {
            pIniDomGrp->_bNoMore = TRUE;
        }

        //
        // If there are no more objects to return,
        // return FALSE
        //
        if (!pIniDomGrp->_dwObjectReturned) {
            return(FALSE);
        }


    }

    dwRet = BuildGlobalGroupMember(
                hGroup,
                (LPBYTE)((LPGROUP_USERS_INFO_0)pIniDomGrp->_pBuffer + pIniDomGrp->_dwCurrentObject),
                ppGroupMember
                );
    if (!dwRet) {

        SetLastError(ERROR_INVALID_SID);
        goto error;
    }

    pIniDomGrp->_dwCurrentObject++;

    return(TRUE);

error:

    return(FALSE);
}


BOOL
WinNTGlobalGroupClose(
    HANDLE hGroup
    )
{

    PINI_DOM_GROUP pIniDomGrp = (PINI_DOM_GROUP)hGroup;

    if (pIniDomGrp) {
        FreeIniDomGroup(pIniDomGrp);
    }
    return(TRUE);
}

void
FreeIniDomGroup(
    PINI_DOM_GROUP pIniDomGrp
    )
{
    if (pIniDomGrp->szDomainName) {

        FreeADsStr(pIniDomGrp->szDomainName);
    }

    if (pIniDomGrp->szComputerName) {

        FreeADsStr(pIniDomGrp->szComputerName);
    }


    if (pIniDomGrp->szGroupName) {

        FreeADsStr(pIniDomGrp->szGroupName);
    }

    if (pIniDomGrp->szUncCompName) {

        FreeADsStr(pIniDomGrp->szUncCompName);
    }


    if (pIniDomGrp->_pBuffer) {

        NetApiBufferFree(pIniDomGrp->_pBuffer);
    }


    if (pIniDomGrp) {

       FreeADsMem(pIniDomGrp);
    }

   return;
}

void
FreeIntDomGroup(
    LPDOMAIN_GROUP_MEMBER pCompGroupMember
    )
{
    if (pCompGroupMember->Parent) {

        FreeADsMem(pCompGroupMember->Parent);

    }


    if (pCompGroupMember->Computer) {

        FreeADsStr(pCompGroupMember->Computer);
    }


    if (pCompGroupMember->Domain) {

        FreeADsStr(pCompGroupMember->Domain);

    }


    if (pCompGroupMember->Name) {

        FreeADsStr(pCompGroupMember->Name);
    }


    FreeADsMem(pCompGroupMember);

}



BOOL
ComputeGlobalGroupDataSize(
        LPDOMAIN_GROUP_MEMBER * ppGroupMembers,
        DWORD  dwReturned,
        PDWORD pdwSize
        )
{

    DWORD i = 0;
    DWORD cb = 0;
    LPDOMAIN_GROUP_MEMBER pMember = NULL;

    for (i = 0; i < dwReturned; i++) {

        pMember = *(ppGroupMembers + i);

        cb += sizeof(DOMAIN_GROUP_MEMBER);

        if (pMember->Parent) {
            cb += wcslen(pMember->Parent)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Computer) {
            cb += wcslen(pMember->Computer)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Domain) {
            cb += wcslen(pMember->Domain)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Name) {
            cb += wcslen(pMember->Name)*sizeof(WCHAR) + sizeof(WCHAR);
        }
    }

    *pdwSize = cb;
    return(TRUE);
}


LPBYTE
CopyIniDomGroupToDomGroup(
    LPDOMAIN_GROUP_MEMBER  pIntDomGrp,
    LPBYTE  pExtDomGrp,
    LPBYTE  pEnd
    )
{
    LPWSTR   SourceStrings[sizeof(DOMAIN_GROUP_MEMBER)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings=SourceStrings;
    LPDOMAIN_GROUP_MEMBER pDomGrpMember = (LPDOMAIN_GROUP_MEMBER)pExtDomGrp;

    memset(SourceStrings, 0, sizeof(DOMAIN_GROUP_MEMBER));
    *pSourceStrings++ = pIntDomGrp->Parent;
    *pSourceStrings++ = pIntDomGrp->Computer;
    *pSourceStrings++ = pIntDomGrp->Domain;
    *pSourceStrings++ = pIntDomGrp->Name;

    pEnd = PackStrings(
                SourceStrings,
                pExtDomGrp,
                DomainGrpMemberStrings,
                pEnd
                );

    pDomGrpMember->Type = pIntDomGrp->Type;

    return pEnd;
}


BOOL
BuildGlobalGroupMember(
    HANDLE hGroup,
    LPBYTE lpBuffer,
    LPDOMAIN_GROUP_MEMBER * ppGroupMember
    )
{
    LPINI_DOM_GROUP pGroup = (LPINI_DOM_GROUP)hGroup;
    LPDOMAIN_GROUP_MEMBER pGroupMember = NULL;
    LPGROUP_USERS_INFO_0 pGrpMem = (LPGROUP_USERS_INFO_0)lpBuffer;
    WCHAR szADsParent[MAX_PATH];
    LPWSTR pMemberName = NULL;
    DWORD cblen = 0;

    pGroupMember = (LPDOMAIN_GROUP_MEMBER)AllocADsMem(
                                       sizeof(DOMAIN_GROUP_MEMBER)
                                       );
    if (!pGroupMember) {

        goto error;
    }

    pGroupMember->Name = AllocADsStr(pGrpMem->grui0_name);
    pGroupMember->Computer = AllocADsStr(pGroup->szComputerName);
    pGroupMember->Domain = AllocADsStr(pGroup->szDomainName);

    wsprintf(
        szADsParent,
        L"%s://%s",
        szProviderName,
        pGroup->szDomainName
        );
    pGroupMember->Parent = AllocADsStr(szADsParent);
    pGroupMember->ParentType = WINNT_DOMAIN_ID;
    pGroupMember->Type = WINNT_USER_ID;

    *ppGroupMember =  pGroupMember;
    return(TRUE);

error:

    if (pGroupMember) {
        FreeIntDomGroup(pGroupMember);
    }

    *ppGroupMember = NULL;

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\fpnwutil.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fpnwutil.cxx

Abstract:

    Contains functions that are used by all ADS FPNW APIs

Author:

    Ram Viswanathan (ramv)     14-May-1996
    
    
Environment:

    User Mode -Win32

Notes:

    Much of it cloned off private\windows\mpr

Revision History:


--*/

#include "winnt.hxx"
#pragma hdrstop
#define INITGUID


//
// global defines
//

#define FPNW_DLL_NAME TEXT("fpnwclnt.dll")

HMODULE  vhFpnwDll = NULL;
extern HANDLE FpnwLoadLibSemaphore;

PF_NwApiBufferFree   pfNwApiBufferFree = NULL; 
PF_NwServerGetInfo   pfNwServerGetInfo = NULL;
PF_NwServerSetInfo   pfNwServerSetInfo = NULL;
PF_NwVolumeAdd       pfNwVolumeAdd = NULL;
PF_NwVolumeDel       pfNwVolumeDel = NULL;
PF_NwVolumeEnum      pfNwVolumeEnum = NULL;
PF_NwVolumeGetInfo   pfNwVolumeGetInfo = NULL; 
PF_NwVolumeSetInfo   pfNwVolumeSetInfo = NULL;
PF_NwConnectionEnum  pfNwConnectionEnum = NULL;
PF_NwConnectionDel   pfNwConnectionDel = NULL;
PF_NwFileEnum      pfNwFileEnum = NULL;


//
// global functions
//

BOOL   MakeSureFpnwDllIsLoaded (VOID);
DWORD  FpnwEnterLoadLibCritSect (VOID);
DWORD  FpnwLeaveLoadLibCritSect (VOID);


DWORD ADsNwApiBufferFree (
    LPVOID pBuffer
    )
{
    DWORD err ;

    // enter critical section to for global data
    err = FpnwEnterLoadLibCritSect();
    if (0 != err)
    {
        return err;
    }

    // if function has not been used before, get its address.
    if (pfNwApiBufferFree == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureFpnwDllIsLoaded())
        {
            (void) FpnwLeaveLoadLibCritSect() ;
            return(GetLastError()) ;
        }

        pfNwApiBufferFree = (PF_NwApiBufferFree)
                            GetProcAddress(vhFpnwDll, "NwApiBufferFree");
    }

    // if cannot get address, return error
    if (pfNwApiBufferFree == NULL)
    {
        (void) FpnwLeaveLoadLibCritSect() ;
        return(GetLastError()) ;
    }

    // else call it
    (void) FpnwLeaveLoadLibCritSect() ;
    return (*pfNwApiBufferFree)(pBuffer);
}



                             

DWORD ADsNwServerGetInfo (
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    OUT PNWSERVERINFO *ppServerInfo
)
{
    DWORD err ;

    // enter critical section to for global data
    err = FpnwEnterLoadLibCritSect();
    if (0 != err)
    {
        return err;
    }

    // if function has not been used before, get its address.
    if (pfNwServerGetInfo == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureFpnwDllIsLoaded())
        {
            (void) FpnwLeaveLoadLibCritSect() ;
            return(GetLastError()) ;
        }

        pfNwServerGetInfo = (PF_NwServerGetInfo)
                            GetProcAddress(vhFpnwDll, "NwServerGetInfo");
    }

    // if cannot get address, return error
    if (pfNwServerGetInfo == NULL)
    {
        (void) FpnwLeaveLoadLibCritSect() ;
        return(GetLastError()) ;
    }

    // else call it
    (void) FpnwLeaveLoadLibCritSect() ;
    return (*pfNwServerGetInfo)(pServerName,
                                dwLevel,
                                ppServerInfo);
}



DWORD ADsNwServerSetInfo (
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    IN  PNWSERVERINFO pServerInfo
)
{
    DWORD err ;

    // enter critical section to for global data
    err = FpnwEnterLoadLibCritSect();
    if (0 != err)
    {
        return err;
    }

    // if function has not been used before, get its address.
    if (pfNwServerSetInfo == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureFpnwDllIsLoaded())
        {
            (void) FpnwLeaveLoadLibCritSect() ;
            return(GetLastError()) ;
        }

        pfNwServerSetInfo = (PF_NwServerSetInfo)
                            GetProcAddress(vhFpnwDll, "NwServerSetInfo");
    }

    // if cannot get address, return error
    if (pfNwServerSetInfo == NULL)
    {
        (void) FpnwLeaveLoadLibCritSect() ;
        return(GetLastError()) ;
    }

    // else call it
    (void) FpnwLeaveLoadLibCritSect() ;
    return (*pfNwServerSetInfo)(pServerName,
                                dwLevel,
                                pServerInfo);

}

DWORD ADsNwVolumeAdd (
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    IN  PNWVOLUMEINFO pVolumeInfo
)
{
    DWORD err ;

    // enter critical section to for global data
    err = FpnwEnterLoadLibCritSect();
    if (0 != err)
    {
        return err;
    }

    // if function has not been used before, get its address.
    if (pfNwVolumeAdd == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureFpnwDllIsLoaded())
        {
            (void) FpnwLeaveLoadLibCritSect() ;
            return(GetLastError()) ;
        }

        pfNwVolumeAdd = (PF_NwVolumeAdd)
                            GetProcAddress(vhFpnwDll, "NwVolumeAdd");
    }

    // if cannot get address, return error
    if (pfNwVolumeAdd == NULL)
    {
        (void) FpnwLeaveLoadLibCritSect() ;
        return(GetLastError()) ;
    }

    // else call it
    (void) FpnwLeaveLoadLibCritSect() ;
    return (*pfNwVolumeAdd)(pServerName,
                            dwLevel,
                            pVolumeInfo);

}


DWORD ADsNwVolumeDel (
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName
)
{ 
    DWORD err ;

    // enter critical section to for global data
    err = FpnwEnterLoadLibCritSect();
    if (0 != err)
    {
        return err;
    }

    // if function has not been used before, get its address.
    if (pfNwVolumeDel == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureFpnwDllIsLoaded())
        {
            (void) FpnwLeaveLoadLibCritSect() ;
            return(GetLastError()) ;
        }

        pfNwVolumeDel = (PF_NwVolumeDel)
                        GetProcAddress(vhFpnwDll, "NwVolumeDel");
    }

    // if cannot get address, return error
    if (pfNwVolumeDel == NULL)
    {
        (void) FpnwLeaveLoadLibCritSect() ;
        return(GetLastError()) ;
    }

    // else call it
    (void) FpnwLeaveLoadLibCritSect() ;
    return (*pfNwVolumeDel)(pServerName,
                            pVolumeName);

}

DWORD ADsNwVolumeEnum (
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    OUT PNWVOLUMEINFO *ppVolumeInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
)
{
    DWORD err ;

    // enter critical section to for global data
    err = FpnwEnterLoadLibCritSect();
    if (0 != err)
    {
        return err;
    }

    // if function has not been used before, get its address.
    if (pfNwVolumeEnum == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureFpnwDllIsLoaded())
        {
            (void) FpnwLeaveLoadLibCritSect() ;
            return(GetLastError()) ;
        }

        pfNwVolumeEnum = (PF_NwVolumeEnum)
                        GetProcAddress(vhFpnwDll, "NwVolumeEnum");
    }

    // if cannot get address, return error
    if (pfNwVolumeEnum == NULL)
    {
        (void) FpnwLeaveLoadLibCritSect() ;
        return(GetLastError()) ;
    }

    // else call it
    (void) FpnwLeaveLoadLibCritSect() ;
    return (*pfNwVolumeEnum)(pServerName ,
                             dwLevel,
                             ppVolumeInfo,
                             pEntriesRead,
                             resumeHandle );
}



DWORD ADsNwVolumeGetInfo (
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    OUT PNWVOLUMEINFO *ppVolumeInfo
)
{
    DWORD err ;

    // enter critical section to for global data
    err = FpnwEnterLoadLibCritSect();
    if (0 != err)
    {
        return err;
    }

    // if function has not been used before, get its address.
    if (pfNwVolumeGetInfo == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureFpnwDllIsLoaded())
        {
            (void) FpnwLeaveLoadLibCritSect() ;
            return(GetLastError()) ;
        }

        pfNwVolumeGetInfo = (PF_NwVolumeGetInfo)
                        GetProcAddress(vhFpnwDll, "NwVolumeGetInfo");
    }

    // if cannot get address, return error
    if (pfNwVolumeGetInfo == NULL)
    {
        (void) FpnwLeaveLoadLibCritSect() ;
        return(GetLastError()) ;
    }

    // else call it
    (void) FpnwLeaveLoadLibCritSect() ;
    return (*pfNwVolumeGetInfo)(pServerName ,
                                pVolumeName,
                                dwLevel,
                                ppVolumeInfo );
}



DWORD ADsNwVolumeSetInfo (
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    IN  PNWVOLUMEINFO pVolumeInfo
)
{
    DWORD err ;

    // enter critical section to for global data
    err = FpnwEnterLoadLibCritSect();
    if (0 != err)
    {
        return err;
    }

    // if function has not been used before, get its address.
    if (pfNwVolumeSetInfo == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureFpnwDllIsLoaded())
        {
            (void) FpnwLeaveLoadLibCritSect() ;
            return(GetLastError()) ;
        }

        pfNwVolumeSetInfo = (PF_NwVolumeSetInfo)
                        GetProcAddress(vhFpnwDll, "NwVolumeSetInfo");
    }

    // if cannot get address, return error
    if (pfNwVolumeSetInfo == NULL)
    {
        (void) FpnwLeaveLoadLibCritSect() ;
        return(GetLastError()) ;
    }

    // else call it
    (void) FpnwLeaveLoadLibCritSect() ;
    return (*pfNwVolumeSetInfo)(pServerName ,
                                pVolumeName,
                                dwLevel,
                                pVolumeInfo );
}    

DWORD ADsNwConnectionEnum (
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwLevel,
    OUT PNWCONNECTIONINFO *ppConnectionInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
)
{ 
    DWORD err ;

    // enter critical section to for global data
    err = FpnwEnterLoadLibCritSect();
    if (0 != err)
    {
        return err;
    }

    // if function has not been used before, get its address.
    if (pfNwConnectionEnum == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureFpnwDllIsLoaded())
        {
            (void) FpnwLeaveLoadLibCritSect() ;
            return(GetLastError()) ;
        }

        pfNwConnectionEnum = (PF_NwConnectionEnum)
                        GetProcAddress(vhFpnwDll, "NwConnectionEnum");
    }

    // if cannot get address, return error
    if (pfNwConnectionEnum == NULL)
    {
        (void) FpnwLeaveLoadLibCritSect() ;
        return(GetLastError()) ;
    }

    // else call it
    (void) FpnwLeaveLoadLibCritSect() ;
    return (*pfNwConnectionEnum)(pServerName ,
                                 dwLevel,
                                 ppConnectionInfo,
                                 pEntriesRead,
                                 resumeHandle );
}


DWORD ADsNwConnectionDel (
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwConnectionId
) 
{ 
    DWORD err ;

    // enter critical section to for global data
    err = FpnwEnterLoadLibCritSect();
    if (0 != err)
    {
        return err;
    }

    // if function has not been used before, get its address.
    if (pfNwConnectionDel == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureFpnwDllIsLoaded())
        {
            (void) FpnwLeaveLoadLibCritSect() ;
            return(GetLastError()) ;
        }

        pfNwConnectionDel = (PF_NwConnectionDel)
                        GetProcAddress(vhFpnwDll, "NwConnectionDel");
    }

    // if cannot get address, return error
    if (pfNwConnectionDel == NULL)
    {
        (void) FpnwLeaveLoadLibCritSect() ;
        return(GetLastError()) ;
    }

    // else call it
    (void) FpnwLeaveLoadLibCritSect() ;
    return (*pfNwConnectionDel)(pServerName,
                                dwConnectionId);

}



DWORD ADsNwFileEnum (
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwLevel,
    IN LPWSTR pPathName OPTIONAL,
    OUT PNWFILEINFO *ppFileInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
)
{ 
    DWORD err ;

    // enter critical section to for global data
    err = FpnwEnterLoadLibCritSect();
    if (0 != err)
    {
        return err;
    }

    // if function has not been used before, get its address.
    if (pfNwFileEnum == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureFpnwDllIsLoaded())
        {
            (void) FpnwLeaveLoadLibCritSect() ;
            return(GetLastError()) ;
        }

        pfNwFileEnum = (PF_NwFileEnum)
                        GetProcAddress(vhFpnwDll, "NwFileEnum");
    }

    // if cannot get address, return error
    if (pfNwFileEnum == NULL)
    {
        (void) FpnwLeaveLoadLibCritSect() ;
        return(GetLastError()) ;
    }

    // else call it
    (void) FpnwLeaveLoadLibCritSect() ;
    return (*pfNwFileEnum)(pServerName ,
                           dwLevel,
                           pPathName,
                           ppFileInfo,
                           pEntriesRead,
                           resumeHandle );
}


DWORD
FpnwEnterLoadLibCritSect (
    VOID
    )
/*++

Routine Description:

    This function enters the critical section defined by
    FpnwLoadLibrarySemaphore.

Arguments:

    none

Return Value:

    0 - The operation was successful.

    error code otherwise.

--*/

#define LOADLIBRARY_TIMEOUT 10000L
{
    switch( WaitForSingleObject( FpnwLoadLibSemaphore, LOADLIBRARY_TIMEOUT ))
    {
    case 0:
        return 0 ;

    case WAIT_TIMEOUT:
        return WN_FUNCTION_BUSY ;

    case 0xFFFFFFFF:
        return (GetLastError()) ;

    default:
        return WN_WINDOWS_ERROR ;
    }
}

DWORD
FpnwLeaveLoadLibCritSect (
    VOID
    )
/*++

Routine Description:

    This function leaves the critical section defined by
    FpnwLoadLibrarySemaphore.

Arguments:

    none

Return Value:

    0 - The operation was successful.

    error code otherwise.

--*/
{
    if (!ReleaseSemaphore( FpnwLoadLibSemaphore, 1, NULL ))
        return (GetLastError()) ;
    return 0 ;
}

/*******************************************************************

    NAME:   MakeSureFpnwDllIsLoaded

    SYNOPSIS:   loads the FPNWClnt dll if need.

    EXIT:   returns TRUE if dll already loaded, or loads
        successfully. Returns false otherwise. Caller
        should call GetLastError() to determine error.

    NOTES:      it is up to the caller to call FpnwEnterLoadLibCritSect
        before he calls this.

    HISTORY:
    chuckc  29-Jul-1992    Created
    ramv    14-May-1996    Cloned off windows\mpr\mprui.cxx
********************************************************************/

BOOL MakeSureFpnwDllIsLoaded(void)
{
    HMODULE handle ;

    // if already load, just return TRUE
    if (vhFpnwDll != NULL)
    return TRUE ;

    // load the library. if it fails, it would have done a SetLastError.
    if (!(handle = LoadLibrary(FPNW_DLL_NAME)))
       return FALSE ;

    // we are cool.
    vhFpnwDll = handle ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\grput3.cxx ===
#include "winnt.hxx"
#pragma hdrstop



WINNT_GROUP WinNTGroup;

//
// This assumes that addr is an LPBYTE type.
//
#define WORD_ALIGN_DOWN(addr) \
        addr = ((LPBYTE)((DWORD_PTR)addr & ~1))

DWORD WinNTGroupStrings[]=

                    {
                    FIELD_OFFSET(WINNT_GROUP, Parent),
                    FIELD_OFFSET(WINNT_GROUP, Computer),
                    FIELD_OFFSET(WINNT_GROUP, Domain),
                    FIELD_OFFSET(WINNT_GROUP, Name),
                    0xFFFFFFFF
                    };


BOOL
WinNTComputerOpen(
    LPWSTR szDomainName,
    LPWSTR szComputerName,
    ULONG  uGroupParent,
    PHANDLE phComputer
    )
{
    WCHAR szTempBuffer[MAX_PATH];
    PINICOMPUTER pIniComputer;
    HRESULT hr;


    if (!phComputer || (szComputerName == NULL) ) {
        return(FALSE);
    }

    pIniComputer = (PINICOMPUTER)AllocADsMem(
                                        sizeof(INICOMPUTER)
                                        );
    if (!pIniComputer) {
        return(FALSE);
    }

    hr = MakeUncName(
            szComputerName,
            szTempBuffer
            );
    BAIL_ON_FAILURE(hr);

    if (!(pIniComputer->szUncCompName =  AllocADsStr(szTempBuffer))){
        goto error;
    }

    if (szDomainName != NULL) {
        if (!(pIniComputer->szDomainName = AllocADsStr(szDomainName))) {
            goto error;
        }
    }

    if (!(pIniComputer->szComputerName =  AllocADsStr(szComputerName))){
        goto error;
    }

    pIniComputer->uGroupParent = uGroupParent;

    *phComputer =  (HANDLE)pIniComputer;

    return(TRUE);


error:
    if (pIniComputer) {
        FreeIniComputer(pIniComputer);
    }

    *phComputer = NULL;

    return(FALSE);

}



BOOL
WinNTEnumGlobalGroups(
    HANDLE hComputer,
    DWORD  dwRequested,
    LPBYTE * ppBuffer,
    PDWORD pdwReturned
    )
{

    LPWINNT_GROUP * ppGroup = NULL;
    DWORD i = 0;
    BOOL dwRet = FALSE;
    DWORD dwReturned = 0;
    DWORD dwSize = 0;
    LPWINNT_GROUP pBuffer = NULL;
    LPBYTE pEnd = NULL;
    BOOL retVal = FALSE;

    ppGroup = (LPWINNT_GROUP *)AllocADsMem(
                                sizeof(LPWINNT_GROUP)* dwRequested
                                );
    if (!ppGroup) {
        return(FALSE);
    }

    for (i = 0; i < dwRequested; i++) {

        dwRet = WinNTComputerGetGlobalGroup(
                        hComputer,
                        &ppGroup[i]
                        );
        if (!dwRet) {
            break;
        }

    }

    dwReturned = i;

    dwRet = ComputeWinNTGroupDataSize(
                    ppGroup,
                    dwReturned,
                    &dwSize
                    );

    pBuffer = (LPWINNT_GROUP)AllocADsMem(
                        dwSize
                        );
    if (pBuffer) {

        retVal = TRUE;

        pEnd = (LPBYTE)((LPBYTE)(pBuffer) + dwSize);

        for (i = 0; i < dwReturned; i++) {

            pEnd = CopyIniWinNTGroupToWinNTGroup(
                            ppGroup[i],
                            (LPBYTE)(pBuffer + i),
                            pEnd
                            );
        }
    }

    for (i = 0; i < dwReturned; i++ ) {
        FreeIntWinNTGroup(*(ppGroup + i));
    }

    FreeADsMem(ppGroup);

    //
    // Will assign to NULL correctly if alloc failed.
    //
    *ppBuffer = (LPBYTE)pBuffer;
    *pdwReturned  = retVal ? dwReturned : 0;

    if (!retVal) {
        return(FALSE);
    }

    if (dwReturned == dwRequested){
        return(TRUE);
    }else {
        return(FALSE);
    }
}

BOOL
WinNTComputerGetGlobalGroup(
    HANDLE hComputer,
    LPWINNT_GROUP * ppGroup
    )
{
    BOOL dwRet = FALSE;
    PINICOMPUTER pIniComp = (PINICOMPUTER)hComputer;
    NET_API_STATUS nasStatus = 0;
    GROUP_INFO_2 *pGroupInfo2 = NULL;
    LPSERVER_INFO_101 lpServerInfo =NULL;
    HRESULT hr = S_OK;

    if ((!pIniComp->_pBuffer) ||
        (pIniComp->_dwCurrentObject == pIniComp->_dwObjectReturned)) {

        if (pIniComp->_bNoMore) {

            //
            // No more objects to return
            //
            return(FALSE);
        }

        if (pIniComp->_pBuffer) {
            NetApiBufferFree(pIniComp->_pBuffer);
            pIniComp->_pBuffer = NULL;
        }

        pIniComp->_dwObjectReturned = 0;
        pIniComp->_dwCurrentObject = 0;
        pIniComp->_dwTotalObjects = 0;

        nasStatus = NetGroupEnum(
                            pIniComp->szUncCompName,
                            2,
                            &pIniComp->_pBuffer,
                            MAX_PREFERRED_LENGTH,
                            &pIniComp->_dwObjectReturned,
                            &pIniComp->_dwTotalObjects,
                            &pIniComp->_dwResumeHandle
                            );
        if ((nasStatus != ERROR_SUCCESS) && (nasStatus != ERROR_MORE_DATA)){
            SetLastError(nasStatus);
            return(FALSE);
        }

        if (nasStatus != ERROR_MORE_DATA) {
            pIniComp->_bNoMore = TRUE;
        }

        pGroupInfo2 = (PGROUP_INFO_2) pIniComp->_pBuffer;

        if ( (!pIniComp->_dwObjectReturned)) {

            //
            // We get success code (ERROR_SUCCESS) but the buffer was NULL:
            // -> no global group was enumerated from the svr
            //

            return(FALSE);

        } else if ( (1 == pIniComp->_dwTotalObjects) &&
                    (DOMAIN_GROUP_RID_USERS == pGroupInfo2->grpi2_group_id) ) {
        // check if this is the none group. Only returned by non-DCs.

            nasStatus = NetServerGetInfo(
                pIniComp->szUncCompName,
                101,
                (LPBYTE *)&lpServerInfo
                );
            hr = HRESULT_FROM_WIN32(nasStatus);
            BAIL_ON_FAILURE(hr);

            if(!( (lpServerInfo->sv101_type & SV_TYPE_DOMAIN_CTRL) ||
                (lpServerInfo->sv101_type & SV_TYPE_DOMAIN_BAKCTRL) ) ) {

                    NetApiBufferFree(lpServerInfo);
                    (pIniComp->_dwCurrentObject)++;
                    return (FALSE);
            }
            else // it is a DC. Fall through.
                ;
        }
    }

    dwRet = BuildWinNTGroupFromGlobalGroup(
                hComputer,
                (LPBYTE)((PGROUP_INFO_2) pIniComp->_pBuffer + pIniComp->_dwCurrentObject),
                ppGroup
                );
    if (!dwRet) {
        goto error;
    }

    pIniComp->_dwCurrentObject++;

    if(lpServerInfo)
        NetApiBufferFree(lpServerInfo);

    return(TRUE);

error:

    if(lpServerInfo)
        NetApiBufferFree(lpServerInfo);

    return(FALSE);
}

BOOL
WinNTEnumLocalGroups(
    HANDLE hComputer,
    DWORD  dwRequested,
    LPBYTE * ppBuffer,
    PDWORD pdwReturned
    )
{

    LPWINNT_GROUP * ppGroup = NULL;
    DWORD i = 0;
    BOOL dwRet = FALSE;
    DWORD dwReturned = 0;
    DWORD dwSize = 0;
    LPWINNT_GROUP pBuffer = NULL;
    LPBYTE pEnd = NULL;
    BOOL fretVal = FALSE;


    ppGroup = (LPWINNT_GROUP *)AllocADsMem(
                                sizeof(LPWINNT_GROUP)* dwRequested
                                );
    if (!ppGroup) {
        return(FALSE);
    }

    for (i = 0; i < dwRequested; i++) {

        dwRet = WinNTComputerGetLocalGroup(
                        hComputer,
                        &ppGroup[i]
                        );
        if (!dwRet) {
            break;
        }

    }

    dwReturned = i;

    dwRet = ComputeWinNTGroupDataSize(
                    ppGroup,
                    dwReturned,
                    &dwSize
                    );

    pBuffer = (LPWINNT_GROUP)AllocADsMem(
                        dwSize
                        );

    if (pBuffer) {

        fretVal = TRUE;
        pEnd = (LPBYTE)((LPBYTE)(pBuffer) + dwSize);

        for (i = 0; i < dwReturned; i++) {

            pEnd = CopyIniWinNTGroupToWinNTGroup(
                            ppGroup[i],
                            (LPBYTE)(pBuffer + i),
                            pEnd
                            );
        }
    }

    for (i = 0; i < dwReturned; i++ ) {
        FreeIntWinNTGroup(*(ppGroup + i));
    }

    FreeADsMem(ppGroup);

    //
    // Will correctly assign to NULL if alloc failed.
    //
    *ppBuffer = (LPBYTE)pBuffer;
    *pdwReturned  = fretVal ? dwReturned : 0;

    if (!fretVal) {
        return(FALSE);
    }

    if (dwReturned == dwRequested){
        return(TRUE);
    }else {
        return(FALSE);
    }
}


BOOL
WinNTComputerGetLocalGroup(
    HANDLE hComputer,
    LPWINNT_GROUP * ppGroup
    )
{
    BOOL dwRet = FALSE;
    PINICOMPUTER pIniComp = (PINICOMPUTER)hComputer;
    NET_API_STATUS nasStatus = 0;
    LPGROUP_INFO_0 pGroupInfo0 = NULL;

    if ((!pIniComp->_pBuffer) ||
        (pIniComp->_dwCurrentObject == pIniComp->_dwObjectReturned)) {

        if (pIniComp->_bNoMore) {

            //
            // No more objects to return
            //
            return(FALSE);
        }

        if (pIniComp->_pBuffer) {
            NetApiBufferFree(pIniComp->_pBuffer);
            pIniComp->_pBuffer = NULL;
        }

        pIniComp->_dwObjectReturned = 0;
        pIniComp->_dwCurrentObject = 0;
        pIniComp->_dwTotalObjects = 0;

        nasStatus = NetLocalGroupEnum(
                            pIniComp->szUncCompName,
                            0,
                            &pIniComp->_pBuffer,
                            MAX_PREFERRED_LENGTH,
                            &pIniComp->_dwObjectReturned,
                            &pIniComp->_dwTotalObjects,
                            &pIniComp->_dwResumeHandle
                            );
        if ((nasStatus != ERROR_SUCCESS) && (nasStatus != ERROR_MORE_DATA)){
            SetLastError(nasStatus);
            return(FALSE);
        }

        if (nasStatus != ERROR_MORE_DATA) {
            pIniComp->_bNoMore = TRUE;
        }


        pGroupInfo0 = (LPGROUP_INFO_0) pIniComp->_pBuffer;

        if ( (!pIniComp->_dwObjectReturned)) {

            //
            // We get success code (ERROR_SUCCESS) but the buffer was NULL:
            // -> no global group was enumerated from the svr
            //

            return(FALSE);
        }

        // we will never get none group as a local group

    }

    dwRet = BuildWinNTGroupFromLocalGroup(
                hComputer,
                (LPBYTE)((LPLOCALGROUP_INFO_0)pIniComp->_pBuffer + pIniComp->_dwCurrentObject),
                ppGroup
                );
    if (!dwRet) {
        goto error;
    }

    pIniComp->_dwCurrentObject++;

    return(TRUE);

error:

    return(FALSE);
}


LPBYTE
CopyIniWinNTGroupToWinNTGroup(
    LPWINNT_GROUP  pIntGrp,
    LPBYTE  pExtGrp,
    LPBYTE  pEnd
    )
{
    LPWSTR   SourceStrings[sizeof(WINNT_GROUP)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings=SourceStrings;
    LPWINNT_GROUP pWinNTGrp = (LPWINNT_GROUP)pExtGrp;

    memset(SourceStrings, 0, sizeof(WINNT_GROUP));
    *pSourceStrings++ = pIntGrp->Parent;
    *pSourceStrings++ = pIntGrp->Computer;
    *pSourceStrings++ = pIntGrp->Domain;
    *pSourceStrings++ = pIntGrp->Name;

    pEnd = PackStrings(
                SourceStrings,
                pExtGrp,
                WinNTGroupStrings,
                pEnd
                );

    pWinNTGrp->Type = pIntGrp->Type;

    return pEnd;
}

BOOL
BuildWinNTGroupFromGlobalGroup(
    HANDLE hComputer,
    LPBYTE lpBuffer,
    LPWINNT_GROUP * ppGroup
    )
{
    LPINICOMPUTER pComputer = (LPINICOMPUTER)hComputer;
    LPWINNT_GROUP pGroup = NULL;
    PGROUP_INFO_2 pGrp = (PGROUP_INFO_2)lpBuffer;
    WCHAR szADsParent[MAX_PATH];
    LPWSTR pMemberName = NULL;
    DWORD cblen = 0;

    pGroup = (LPWINNT_GROUP)AllocADsMem(
                                       sizeof(WINNT_GROUP)
                                       );
    if (!pGroup) {
        return(FALSE);
    }

    //
    // Begin Global Group -> WinNT Group Mapping
    //

    pGroup->Name = AllocADsStr(pGrp->grpi2_name);
    pGroup->Computer = AllocADsStr(pComputer->szComputerName);
    pGroup->Domain = AllocADsStr(pComputer->szDomainName);

    if (pComputer->uGroupParent == WINNT_DOMAIN_ID) {
        wsprintf(
            szADsParent,
            L"%s://%s",
            szProviderName,
            pComputer->szDomainName
            );

    }else {
        wsprintf(
            szADsParent,
            L"%s://%s/%s",
            szProviderName,
            pComputer->szDomainName,
            pComputer->szComputerName
            );
    }
    pGroup->Parent = AllocADsStr(szADsParent);
    pGroup->Type = WINNT_GROUP_GLOBAL;


    //
    //  End Global Group -> WinNT Group Mapping
    //

    *ppGroup =  pGroup;
    return(TRUE);

// error:

    return(FALSE);

}


BOOL
BuildWinNTGroupFromLocalGroup(
    HANDLE hComputer,
    LPBYTE lpBuffer,
    LPWINNT_GROUP * ppGroup
    )
{
    LPINICOMPUTER pComputer = (LPINICOMPUTER)hComputer;
    LPWINNT_GROUP pGroup = NULL;
    LPLOCALGROUP_INFO_0 pGrp = (LPLOCALGROUP_INFO_0)lpBuffer;
    WCHAR szADsParent[MAX_PATH];
    LPWSTR pMemberName = NULL;
    DWORD cblen = 0;

    pGroup = (LPWINNT_GROUP)AllocADsMem(
                                       sizeof(WINNT_GROUP)
                                       );
    if (!pGroup) {
        return(FALSE);
    }


    //
    // Begin Local Group -> WinNT Group Mapping
    //

    pGroup->Name = AllocADsStr(pGrp->lgrpi0_name);
    pGroup->Computer = AllocADsStr(pComputer->szComputerName);
    pGroup->Domain = AllocADsStr(pComputer->szDomainName);

    if (pComputer->uGroupParent == WINNT_DOMAIN_ID) {
        wsprintf(
            szADsParent,
            L"%s://%s",
            szProviderName,
            pComputer->szDomainName
            );

    }else {
        if (pComputer->szDomainName !=NULL) {

            wsprintf(
                szADsParent,
                L"%s://%s/%s",
                szProviderName,
                pComputer->szDomainName,
                pComputer->szComputerName
                );
        } else {
            // This is a case where domain is null, the
            // workstation service has not been started
            wsprintf(
                szADsParent,
                L"%s://%s",
                szProviderName,
                pComputer->szComputerName
                );
        }
    }
    pGroup->Parent = AllocADsStr(szADsParent);
    pGroup->Type = WINNT_GROUP_LOCAL;


    //
    //  End Local Group -> WinNT Group Mapping
    //


    *ppGroup =  pGroup;
    return(TRUE);


// error:

    return(FALSE);

}


BOOL
ComputeWinNTGroupDataSize(
    LPWINNT_GROUP * ppGroups,
    DWORD  dwReturned,
    PDWORD pdwSize
    )
{

    DWORD i = 0;
    DWORD cb = 0;
    LPWINNT_GROUP pGroup = NULL;

    for (i = 0; i < dwReturned; i++) {

        pGroup = *(ppGroups + i);

        cb += sizeof(WINNT_GROUP);

        if (pGroup->Parent) {
            cb += wcslen(pGroup->Parent)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pGroup->Computer) {
            cb += wcslen(pGroup->Computer)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pGroup->Domain) {
            cb += wcslen(pGroup->Domain)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pGroup->Name) {
            cb += wcslen(pGroup->Name)*sizeof(WCHAR) + sizeof(WCHAR);
        }
    }

    *pdwSize = cb;
    return(TRUE);
}



BOOL
WinNTCloseComputer(
    HANDLE hComputer
    )
{
    PINICOMPUTER pIniComputer = (PINICOMPUTER)hComputer;

    if (pIniComputer) {
        FreeIniComputer(pIniComputer);
    }
    return(TRUE);
}


void
FreeIniComputer(
    PINICOMPUTER pIniComputer
    )
{

    if (pIniComputer->szDomainName) {

        FreeADsStr(pIniComputer->szDomainName);
    }

    if (pIniComputer->szDomainName) {

        FreeADsStr(pIniComputer->szComputerName);
    }


    if (pIniComputer->szUncCompName) {

        FreeADsStr(pIniComputer->szUncCompName);
    }


    if (pIniComputer->_pBuffer) {
        NetApiBufferFree(pIniComputer->_pBuffer);
    }

    FreeADsMem(pIniComputer);

    return;
}

void
FreeIntWinNTGroup(
    LPWINNT_GROUP pGroup
    )
{
    if (pGroup->Parent) {

        FreeADsStr(pGroup->Parent);
    }

    if (pGroup->Computer) {

        FreeADsStr(pGroup->Computer);
    }


    if (pGroup->Domain) {

        FreeADsStr(pGroup->Domain);
    }


    if (pGroup->Name) {

        FreeADsStr(pGroup->Name);
    }


    if (pGroup) {

        FreeADsMem(pGroup);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\getobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  getobj.cxx
//
//  Contents:  Windows NT 3.5 GetObject functionality
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

extern WCHAR * szWinNTPrefix;

//+---------------------------------------------------------------------------
//  Function:  GetObject
//
//  Synopsis:  Called by ResolvePathName to return an object
//
//  Arguments:  [LPWSTR szBuffer]
//              [LPVOID *ppObject]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetObject(
    LPWSTR szBuffer,
    LPVOID *ppObject,
    CWinNTCredentials& Credentials
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szBuffer);
    HRESULT hr;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = ValidateProvider(pObjectInfo);
    BAIL_IF_ERROR(hr);

    switch (pObjectInfo->ObjectType) {
    case TOKEN_DOMAIN:
        hr = GetDomainObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_USER:
        hr = GetUserObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_COMPUTER:
        hr = GetComputerObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_PRINTER:
        hr = GetPrinterObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_SERVICE:
        hr = GetServiceObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_FILESERVICE:
        hr = GetFileServiceObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_GROUP:
        hr = GetGroupObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_LOCALGROUP:
        hr = E_ADS_BAD_PATHNAME;
        //hr = GetLocalGroupObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_GLOBALGROUP:
        hr = E_ADS_BAD_PATHNAME;
        //hr = GetGlobalGroupObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_FILESHARE:
        hr = GetFileShareObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_SCHEMA:
        hr = GetSchemaObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_CLASS:
        hr = GetClassObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_PROPERTY:
        hr = GetPropertyObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_SYNTAX:
        hr = GetSyntaxObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_WORKGROUP:
        hr = GetWorkGroupObject(pObjectInfo, ppObject, Credentials);
        break;

    default:
        hr = HeuristicGetObject(pObjectInfo, ppObject, Credentials);
        break;
    }

cleanup:

    FreeObjectInfo( &ObjectInfo, TRUE );
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:    GetDomainObject
//
// Synopsis:    called by GetObject
//
// Arguments:   [POBJECTINFO pObjectInfo]
//              [LPVOID * ppObject]
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetNamespaceObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr;

    hr = ValidateNamespaceObject(
                pObjectInfo
                );
    BAIL_ON_FAILURE(hr);

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
        hr = CWinNTNamespace::CreateNamespace(
                L"ADs:",
                L"WinNT:",
                ADS_OBJECT_BOUND,
                IID_IUnknown,
                Credentials,
                ppObject
                );
    }
    else { // came in through ADSI
        hr = CoCreateInstance(CLSID_WinNTNamespace,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IUnknown,
                          (void **)ppObject );
    }

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:    GetDomainObject
//
// Synopsis:    called by GetObject
//
// Arguments:   [POBJECTINFO pObjectInfo]
//              [LPVOID * ppObject]
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetDomainObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr;
    IUnknown *pUnknown = NULL;
    IADs *pADs = NULL;
    NET_API_STATUS nasStatus;
    WCHAR szHostServerName[MAX_PATH];
    WCHAR ADsParent[MAX_ADS_PATH];
    WCHAR szSAMName[MAX_ADS_PATH];

    szSAMName[0] = L'\0';

    *ppObject = NULL;

    if (pObjectInfo->NumComponents != 1) {
        RRETURN(E_ADS_INVALID_DOMAIN_OBJECT);
    }

    //
    // Verify that this object is really a domain
    //

    // We can try and ref the domain here but it will
    // anyway end up in WinNTGetCachedDCName call in
    // CWinNTCredentials::RefDomain, so there is no point in
    // doing that

    hr = WinNTGetCachedDCName(
                pObjectInfo->ComponentArray[0],
                szHostServerName,
                Credentials.GetFlags()
                );
    BAIL_ON_FAILURE(hr);

    if (szSAMName[0] != L'\0') {
        if (pObjectInfo->ComponentArray[0]) {
            FreeADsStr(pObjectInfo->ComponentArray[0]);
        }

        pObjectInfo->ComponentArray[0] = AllocADsStr(szSAMName);
        if (!pObjectInfo) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }


    hr = BuildParent(
            pObjectInfo,
            ADsParent
            );
    BAIL_ON_FAILURE(hr);


    hr = CWinNTDomain::CreateDomain(
                ADsParent,
                pObjectInfo->ComponentArray[0],
                ADS_OBJECT_BOUND,
                IID_IUnknown,
                Credentials,
                (void **)&pUnknown
                );
    BAIL_ON_FAILURE(hr);


    *ppObject = pUnknown;

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:    GetWorkgroupObject
//
// Synopsis:    called by GetObject.
//              Note: We really don't have a workgroup object. But we
//              need to support a syntax such as @WinNT!workstation to
//              allow for IADsContainer interface methods. There is
//              no authentication that needs to done.
//
// Arguments:   [POBJECTINFO pObjectInfo]
//              [LPVOID * ppObject]
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    05-23-96  RamV  Created.
//
//----------------------------------------------------------------------------
HRESULT
GetWorkGroupObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{


    HRESULT hr;
    IUnknown *pUnknown = NULL;
    IADs *pADs = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    WCHAR szName[MAX_PATH];

    *ppObject = NULL;

    if (pObjectInfo->NumComponents != 1) {
        RRETURN(E_ADS_INVALID_DOMAIN_OBJECT);
    }

    //
    // any single component oleds path can be validated as a workgroup
    //

    hr = BuildParent(
            pObjectInfo,
            ADsParent
            );
    BAIL_ON_FAILURE(hr);


    hr = CWinNTDomain::CreateDomain(
                ADsParent,
                pObjectInfo->ComponentArray[0],
                ADS_OBJECT_BOUND,
                IID_IUnknown,
                Credentials,
                (void **)&pUnknown
                );

    BAIL_ON_FAILURE(hr);


    *ppObject = pUnknown;

error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetUserObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//              8-8-96   ramv         Modified.
//
//----------------------------------------------------------------------------
HRESULT
GetUserObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPWSTR szServerName = NULL;
    LPWSTR szDomainName = NULL;
    LPWSTR szUserName = NULL;
    DWORD  dwParentId = 0;
    WCHAR  szComputerParent[MAX_PATH];
    POBJECTINFO pUserObjectInfo = NULL;


    hr = ValidateUserObject(
                pObjectInfo,
                &dwParentId,
                Credentials
                );
    BAIL_ON_FAILURE(hr);

    switch (pObjectInfo->NumComponents) {
    case 2:
        //
        // could be user in computer or user in domain
        //
        if(dwParentId == WINNT_DOMAIN_ID){

            szDomainName = pObjectInfo->ComponentArray[0];
            szUserName = pObjectInfo->ComponentArray[1];
            szServerName = NULL;

            hr = BuildParent(pObjectInfo, ADsParent);
            BAIL_ON_FAILURE(hr);

        } else {

            //
            // user in a computer
            //

            hr = ConstructFullObjectInfo(pObjectInfo,
                                         &pUserObjectInfo,
                                         Credentials );
            if (SUCCEEDED(hr)) {

                hr = BuildParent(pUserObjectInfo, ADsParent);

                BAIL_ON_FAILURE(hr);

                szDomainName =  pUserObjectInfo->ComponentArray[0];
                szServerName =  pUserObjectInfo->ComponentArray[1];
                szUserName   =  pUserObjectInfo->ComponentArray[2];

            }
            else if (hr == HRESULT_FROM_WIN32(NERR_WkstaNotStarted)) {

                // We alread know that the object is valid,
                // So we should set appropriate values and proceed to
                // create the object
                hr = BuildParent(pObjectInfo, ADsParent);

                BAIL_ON_FAILURE(hr);

                szDomainName = NULL;
                szServerName = pObjectInfo->ComponentArray[0];
                szUserName   = pObjectInfo->ComponentArray[1];

            }

        }

        break;


    case 3:
        szDomainName = pObjectInfo->ComponentArray[0];
        szServerName = pObjectInfo->ComponentArray[1];
        szUserName = pObjectInfo->ComponentArray[2];

        hr = BuildParent(pObjectInfo, ADsParent);
        BAIL_ON_FAILURE(hr);
        break;
    }

    hr = CWinNTUser::CreateUser(ADsParent,
                            dwParentId,
                            szDomainName,
                            szServerName,
                            szUserName,
                            ADS_OBJECT_BOUND,
                            IID_IUnknown,
                            Credentials,
                            (void **)&pUnknown
                            );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    FreeObjectInfo(pUserObjectInfo);
    RRETURN(hr);

error:

    if (pUnknown) {
        pUnknown->Release();
    }
    *ppObject = NULL;

    FreeObjectInfo(pUserObjectInfo);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetUserObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    8-8-96   ramv    Created.
//
//----------------------------------------------------------------------------
HRESULT
GetUserObjectInDomain(
    LPWSTR pszHostServerName,
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPWSTR szServerName = NULL;
    LPWSTR szDomainName = NULL;
    LPWSTR szUserName = NULL;
    DWORD  dwParentId = WINNT_DOMAIN_ID;
    LPUSER_INFO_20 lpUI = NULL;
    NET_API_STATUS nasStatus;
    BOOL fRefAdded = FALSE;
    LPUSER_INFO_0 lpUI_0 = NULL;
    DWORD dwLevelUsed = 20;

    // At this point a \\ has been prepended to the host
    // we need to get rid of it.
    hr = Credentials.RefServer(pszHostServerName+2);
    if (SUCCEEDED(hr)) {
        fRefAdded = TRUE;
    }

    nasStatus = NetUserGetInfo(pszHostServerName,
                               pObjectInfo->ComponentArray[1],
                               20,
                               (LPBYTE *)&lpUI);

    if (nasStatus == ERROR_ACCESS_DENIED) {
        // try and drop down to level 0 as that may work

        dwLevelUsed = 0;
        nasStatus = NetUserGetInfo(
                        pszHostServerName,
                        pObjectInfo->ComponentArray[1],
                        0,
                        (LPBYTE *)&lpUI_0
                        );
    }

    // deref if necessary, note no error recovery possible
    if (fRefAdded) {
        Credentials.DeRefServer();
        fRefAdded = FALSE;
    }

    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

    // Need to use the name returned by the call as opposed
    // to the name given in the ADsPath
    if (dwLevelUsed == 20) {
        if (pObjectInfo->ComponentArray[1] && lpUI->usri20_name) {
            FreeADsStr(pObjectInfo->ComponentArray[1]);
            pObjectInfo->ComponentArray[1] = AllocADsStr(lpUI->usri20_name);
        }

        if (!pObjectInfo->ComponentArray[1])
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    // if it is not a level 20 call then we will just use
    // whatever the user gave us
    szDomainName = pObjectInfo->ComponentArray[0];
    szUserName = pObjectInfo->ComponentArray[1];
    szServerName = NULL;
    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);

    hr = CWinNTUser::CreateUser(ADsParent,
                            dwParentId,
                            szDomainName,
                            szServerName,
                            szUserName,
                            ADS_OBJECT_BOUND,
                            IID_IUnknown,
                            Credentials,
                            (void **)&pUnknown
                            );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;


error:
    if (FAILED(hr) && pUnknown) {
        pUnknown->Release();
        *ppObject = NULL;
    }

    if (lpUI)
        NetApiBufferFree((LPBYTE)lpUI);

    if (lpUI_0) {
        NetApiBufferFree((LPBYTE)lpUI_0);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   GetUserObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//              8-8-96   ramv         Modified.
//
//----------------------------------------------------------------------------

HRESULT
GetUserObjectInComputer(
    LPWSTR pszHostServerName, // pdc name
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPWSTR szServerName = NULL;
    LPWSTR szDomainName = NULL;
    LPWSTR szUserName = NULL;
    DWORD  dwParentId = WINNT_COMPUTER_ID;
    WCHAR  szComputerParent[MAX_PATH];
    POBJECTINFO pUserObjectInfo = NULL;
    WCHAR lpszUncName[MAX_PATH];
    NET_API_STATUS nasStatus;
    LPBYTE lpUI = NULL;
    BOOL fRefAdded = FALSE;

    switch (pObjectInfo->NumComponents) {
    case 2:
        //
        // could be user in computer
        //
        //
        // first validate user
        //

        hr = Credentials.RefServer(pObjectInfo->ComponentArray[0]);
        if (SUCCEEDED(hr)) {
            fRefAdded = TRUE;
        }

        MakeUncName(pObjectInfo->ComponentArray[0],
                    lpszUncName);

        nasStatus = NetUserGetInfo(lpszUncName,
                                   pObjectInfo->ComponentArray[1],
                                   20,
                                   &lpUI);

        if (fRefAdded) {
            Credentials.DeRefServer();
            fRefAdded = FALSE;
        }

        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);

        // Need to use the name returned by the call as opposed
        // to the name given in the ADsPath
        if (pObjectInfo->ComponentArray[1]
            && ((LPUSER_INFO_20)lpUI)->usri20_name) {

            FreeADsStr(pObjectInfo->ComponentArray[1]);
            pObjectInfo->ComponentArray[1]
                = AllocADsStr(((LPUSER_INFO_20)lpUI)->usri20_name);
        }

        if (!pObjectInfo->ComponentArray[1])
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        // This call will add the domain information to the
        // objectInfo blob, so that the ComponentArray[2] is valid

        hr = ConstructFullObjectInfo(pObjectInfo,
                                     &pUserObjectInfo,
                                     Credentials );
        BAIL_ON_FAILURE(hr);

        hr = BuildParent(pUserObjectInfo, ADsParent);
        BAIL_ON_FAILURE(hr);

        szDomainName =  pUserObjectInfo->ComponentArray[0];
        szServerName =  pUserObjectInfo->ComponentArray[1];
        szUserName   =  pUserObjectInfo->ComponentArray[2];

        break;


    case 3:

        //
        // ValidateComputerParent  and validate user in computer
        //

        hr = ValidateComputerParent(pObjectInfo->ComponentArray[0],
                                    pObjectInfo->ComponentArray[1],
                                    Credentials);
        BAIL_ON_FAILURE(hr);

        hr = Credentials.RefServer(pObjectInfo->ComponentArray[1]);
        if (SUCCEEDED(hr)) {
            fRefAdded = TRUE;
        }

        MakeUncName(pObjectInfo->ComponentArray[1],
                    lpszUncName);

        nasStatus = NetUserGetInfo(lpszUncName,
                                   pObjectInfo->ComponentArray[2],
                                   20,
                                   (LPBYTE *)&lpUI);

        if (fRefAdded) {
            Credentials.DeRefServer();
            fRefAdded = FALSE;
        }

        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);

        // Need to use the name returned by the call as opposed
        // to the name given in the ADsPath
        if (pObjectInfo->ComponentArray[2]
            && ((LPUSER_INFO_20)lpUI)->usri20_name) {

            FreeADsStr(pObjectInfo->ComponentArray[2]);
            pObjectInfo->ComponentArray[2]
                = AllocADsStr(((LPUSER_INFO_20)lpUI)->usri20_name);
        }

        if (!pObjectInfo->ComponentArray[2])
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        hr = BuildParent(pObjectInfo, ADsParent);
        BAIL_ON_FAILURE(hr);

        szDomainName = pObjectInfo->ComponentArray[0];
        szServerName = pObjectInfo->ComponentArray[1];
        szUserName = pObjectInfo->ComponentArray[2];
        break;
    }
    hr = CWinNTUser::CreateUser(ADsParent,
                            dwParentId,
                            szDomainName,
                            szServerName,
                            szUserName,
                            ADS_OBJECT_BOUND,
                            IID_IUnknown,
                            Credentials,
                            (void **)&pUnknown
                            );
error:
    if (FAILED(hr)) {
        if (pUnknown) {
            pUnknown->Release();
        }
        *ppObject = NULL;
    }
    else {
        *ppObject = pUnknown;
    }

    if (lpUI) {
        NetApiBufferFree(lpUI);
    }

    FreeObjectInfo(pUserObjectInfo);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   GetComputerObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetComputerObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    WCHAR ADsParent[MAX_ADS_PATH];
    TCHAR  szUncName[MAX_PATH];
    NET_API_STATUS nasStatus;
    POBJECTINFO pComputerObjectInfo = NULL;
    BOOL fNoWksta = FALSE;
    WCHAR szCompName[MAX_PATH];
    DWORD dwSize = MAX_PATH;

    //
    // The following function call merely checks to see if the domain is
    // correct. If not, we can assume that the computer does not belong to
    // a domain.
    //

    hr = ValidateComputerObject(pObjectInfo, Credentials);

    if (hr == HRESULT_FROM_WIN32(NERR_WkstaNotStarted))
        fNoWksta = TRUE;
    else
        BAIL_ON_FAILURE(hr);

    // Normall we can expect that the workstation service will
    // be started. This will not be the case for minimum installs

    if (!fNoWksta) {

        if(pObjectInfo->NumComponents == 1){

            //
            // we need to supply the workgroup name for this computer
            // This is needed because EnumLocalGroups requires the
            // workgroup name to function properly
            //

            hr = ConstructFullObjectInfo(pObjectInfo,
                                         &pComputerObjectInfo,
                                         Credentials );

            BAIL_ON_FAILURE(hr);

            hr = BuildParent(pComputerObjectInfo, ADsParent);
            BAIL_ON_FAILURE(hr);

            hr = CWinNTComputer::CreateComputer(
                                ADsParent,
                                pComputerObjectInfo->ComponentArray[0],
                                pComputerObjectInfo->ComponentArray[1],
                                ADS_OBJECT_BOUND,
                                IID_IUnknown,
                                Credentials,
                                ppObject
                                );

        } else if(pObjectInfo->NumComponents == 2) {

            hr = BuildParent(pObjectInfo, ADsParent);
            BAIL_ON_FAILURE(hr);

            hr = CWinNTComputer::CreateComputer(
                                ADsParent,
                                pObjectInfo->ComponentArray[0],
                                pObjectInfo->ComponentArray[1],
                                ADS_OBJECT_BOUND,
                                IID_IUnknown,
                                Credentials,
                                ppObject);

        }
    } else {

        // Else clause for if(!fWksta)
        // This means that workstation services were not
        // started, we need to verify that the host computer
        // is the one they are interested in.

        if ((pObjectInfo->NumComponents != 1) || (!GetComputerName(szCompName, &dwSize))) {
            // We cannot get the computer name so bail
            BAIL_ON_FAILURE(hr);
        }

        // Compare the names before we continue
#ifdef WIN95
        if (_wcsicmp(szCompName, pObjectInfo->ComponentArray[0])) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                szCompName,
                -1,
                pObjectInfo->ComponentArray[0],
                -1
                )  != CSTR_EQUAL ) {
#endif
            // names do not match
            BAIL_ON_FAILURE(hr);
        }

        hr = CWinNTComputer::CreateComputer(
                                 L"WinNT:",
                                 NULL,
                                 pObjectInfo->ComponentArray[0],
                                 ADS_OBJECT_BOUND,
                                 IID_IUnknown,
                                 Credentials,
                                 ppObject
                                 );
        BAIL_ON_FAILURE(hr);

    }

error:

    if(pComputerObjectInfo){
        FreeObjectInfo(pComputerObjectInfo);
    }
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   GetPrinterObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    01/03/96 Ramv  Created.
//
//----------------------------------------------------------------------------
HRESULT
GetPrinterObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR szADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPWSTR szDomainName = NULL;
    LPWSTR szServerName = NULL;
    LPWSTR szPrinterName = NULL;
    DWORD  dwParentId = 0;
    LPWSTR szComputerParent[MAX_PATH];
    POBJECTINFO pPrinterObjectInfo = NULL;

    if (!(pObjectInfo->NumComponents == 3 ||pObjectInfo->NumComponents == 2)){

        RRETURN(E_ADS_BAD_PATHNAME);
    }

    // check to see that the printer is a valid one

    hr = ValidatePrinterObject(pObjectInfo, Credentials);

    BAIL_ON_FAILURE(hr);

    dwParentId = WINNT_COMPUTER_ID;

    if(pObjectInfo->NumComponents == 3) {

        hr = BuildParent(pObjectInfo, szADsParent);
        BAIL_ON_FAILURE(hr);

        szDomainName = pObjectInfo->ComponentArray[0];
        szServerName = pObjectInfo->ComponentArray[1];
        szPrinterName= pObjectInfo->ComponentArray[2];

    } else if (pObjectInfo->NumComponents == 2){

        hr = ConstructFullObjectInfo(pObjectInfo,
                                     &pPrinterObjectInfo,
                                     Credentials );

        BAIL_ON_FAILURE(hr);

        hr = BuildParent(pPrinterObjectInfo, szADsParent);
        BAIL_ON_FAILURE(hr);

        szDomainName = pPrinterObjectInfo->ComponentArray[0];
        szServerName = pPrinterObjectInfo->ComponentArray[1];
        szPrinterName= pPrinterObjectInfo->ComponentArray[2];
    }
    hr = CWinNTPrintQueue::CreatePrintQueue(
                               szADsParent,
                               dwParentId,
                               szDomainName,
                               szServerName,
                               szPrinterName,
                               ADS_OBJECT_BOUND,
                               IID_IUnknown,
                               Credentials,
                               (void **)&pUnknown
                               );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    FreeObjectInfo(pPrinterObjectInfo);
    RRETURN(hr);

error:
    if (pUnknown) {
        pUnknown->Release();
    }
    *ppObject = NULL;

    FreeObjectInfo(pPrinterObjectInfo);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   GetServiceObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    01/03/96 Ramv  Created.
//
//----------------------------------------------------------------------------
HRESULT
GetServiceObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR szADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPWSTR szDomainName = NULL;
    LPWSTR szServerName = NULL;
    LPWSTR szServiceName = NULL;
    DWORD  dwParentId = 0;
    POBJECTINFO pServiceObjectInfo = NULL;

    //
    // check to see that the printer is in a valid server(computer) object
    //

    if(!(pObjectInfo->NumComponents == 3 ||
         pObjectInfo->NumComponents == 2))
    {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = ValidateServiceObject(pObjectInfo, Credentials);
    BAIL_ON_FAILURE(hr);

    dwParentId = WINNT_COMPUTER_ID;

    if(pObjectInfo->NumComponents == 3) {

        hr = BuildParent(pObjectInfo, szADsParent);
        BAIL_ON_FAILURE(hr);

        szDomainName = pObjectInfo->ComponentArray[0];
        szServerName = pObjectInfo->ComponentArray[1];
        szServiceName= pObjectInfo->ComponentArray[2];

        hr = CWinNTService::Create(szADsParent,
                                   szDomainName,
                                   szServerName,
                                   szServiceName,
                                   ADS_OBJECT_BOUND,
                                   IID_IUnknown,
                                   Credentials,
                                   (void **)&pUnknown);
        BAIL_ON_FAILURE(hr);

    }  else if (pObjectInfo->NumComponents == 2) {

        hr = ConstructFullObjectInfo(pObjectInfo,
                                     &pServiceObjectInfo,
                                     Credentials );

        BAIL_ON_FAILURE(hr);

        hr = BuildParent(pServiceObjectInfo, szADsParent);
        BAIL_ON_FAILURE(hr);

        szServerName = pServiceObjectInfo->ComponentArray[1];
        szServiceName= pServiceObjectInfo->ComponentArray[2];

        hr = CWinNTService::Create(szADsParent,
                                   pServiceObjectInfo->ComponentArray[0],
                                   szServerName,
                                   szServiceName,
                                   ADS_OBJECT_BOUND,
                                   IID_IUnknown,
                                   Credentials,
                                   (void **)&pUnknown);
        BAIL_ON_FAILURE(hr);

    }

    *ppObject = pUnknown;
    if(pServiceObjectInfo){
        FreeObjectInfo(pServiceObjectInfo);
    }
    RRETURN(hr);

error:

    if(pServiceObjectInfo){
        FreeObjectInfo(pServiceObjectInfo);
    }
    if (pUnknown) {
        pUnknown->Release();
    }
    *ppObject = NULL;

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   GetFileServiceObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    01/15/96 Ramv  Created.
//
//----------------------------------------------------------------------------

HRESULT
GetFileServiceObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR szADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPWSTR szDomainName = NULL;
    LPWSTR szServerName = NULL;
    LPWSTR szFileServiceName = NULL;
    DWORD  dwParentId = 0;
    POBJECTINFO pFileServiceObjectInfo = NULL;
    //
    // check to see that the service is in a valid server(computer) object
    //

    if (!(pObjectInfo->NumComponents == 3 || pObjectInfo->NumComponents == 2))
       RRETURN(E_ADS_BAD_PATHNAME);

    hr = ValidateFileServiceObject(pObjectInfo, Credentials);
    BAIL_ON_FAILURE(hr);

    if (pObjectInfo->NumComponents == 3){
        szDomainName = pObjectInfo->ComponentArray[0];
        szServerName = pObjectInfo->ComponentArray[1];
        szFileServiceName= pObjectInfo->ComponentArray[2];

        hr = BuildParent(pObjectInfo, szADsParent);
        BAIL_ON_FAILURE(hr);

    }

    if (pObjectInfo->NumComponents == 2){

        hr = ConstructFullObjectInfo(pObjectInfo,
                                     &pFileServiceObjectInfo,
                                     Credentials );

        BAIL_ON_FAILURE(hr);

        hr = BuildParent(pFileServiceObjectInfo, szADsParent);
        BAIL_ON_FAILURE(hr);

        szDomainName = pFileServiceObjectInfo->ComponentArray[0];
        szServerName = pFileServiceObjectInfo->ComponentArray[1];
        szFileServiceName= pFileServiceObjectInfo->ComponentArray[2];
    }

    dwParentId = WINNT_COMPUTER_ID;

    if(_tcsicmp(szFileServiceName,TEXT("LanmanServer")) == 0) {
        hr = CWinNTFileService::CreateFileService(szADsParent,
                                                  dwParentId,
                                                  szDomainName,
                                                  szServerName,
                                                  szFileServiceName,
                                                  ADS_OBJECT_BOUND,
                                                  IID_IUnknown,
                                                  Credentials,
                                                  (void **)&pUnknown);
        BAIL_ON_FAILURE(hr);

    }
    else if(_tcsicmp(szFileServiceName,TEXT("FPNW")) == 0) {

        hr = CFPNWFileService::CreateFileService(szADsParent,
                                                 dwParentId,
                                                 szDomainName,
                                                 szServerName,
                                                 szFileServiceName,
                                                 ADS_OBJECT_BOUND,
                                                 IID_IUnknown,
                                                 Credentials,
                                                 (void **)&pUnknown);
        BAIL_ON_FAILURE(hr);
    }

    *ppObject = pUnknown;

    if(pFileServiceObjectInfo){
        FreeObjectInfo(pFileServiceObjectInfo);
    }

    RRETURN(hr);

error:

    if(pFileServiceObjectInfo){
        FreeObjectInfo(pFileServiceObjectInfo);
    }

    if (pUnknown) {
        pUnknown->Release();
    }
    *ppObject = NULL;

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetFileShareObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    01/15/96 Ramv  Created.
//
//----------------------------------------------------------------------------

HRESULT
GetFileShareObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR szADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPTSTR szDomainName = NULL;
    LPTSTR szServerName = NULL;
    LPTSTR szFileServiceName = NULL;
    LPTSTR szFileShareName = NULL;
    DWORD  dwParentId = 0;
    POBJECTINFO pFileShareObjectInfo = NULL;
    WCHAR lpszUncName[MAX_PATH];
    BOOL fRefAdded = FALSE;

    //
    // check to see that the share is in a valid fileservice
    //

    if (!(pObjectInfo->NumComponents == 4 ||
          pObjectInfo->NumComponents == 3)) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    // The server is ref'ed in this routine.
    hr = ValidateFileShareObject(pObjectInfo, Credentials);
    BAIL_ON_FAILURE(hr);

    dwParentId = WINNT_SERVICE_ID;

    if(pObjectInfo->NumComponents == 4){

        hr = BuildParent(pObjectInfo, szADsParent);
        BAIL_ON_FAILURE(hr);

        szServerName = pObjectInfo->ComponentArray[1];
        szFileServiceName= pObjectInfo->ComponentArray[2];
        szFileShareName  = pObjectInfo ->ComponentArray[3];

    } else if (pObjectInfo->NumComponents == 3){

        hr = ConstructFullObjectInfo(pObjectInfo,
                                     &pFileShareObjectInfo,
                                     Credentials );

        BAIL_ON_FAILURE(hr);

        hr = BuildParent(pFileShareObjectInfo, szADsParent);
        BAIL_ON_FAILURE(hr);


        szServerName = pObjectInfo->ComponentArray[0];
        szFileServiceName= pObjectInfo->ComponentArray[1];
        szFileShareName  = pObjectInfo ->ComponentArray[2];
    }


    if(_tcsicmp(szFileServiceName,TEXT("LanmanServer")) == 0){

        hr = CWinNTFileShare::Create(szADsParent,
                                     szServerName,
                                     szFileServiceName,
                                     szFileShareName,
                                     ADS_OBJECT_BOUND,
                                     IID_IUnknown,
                                     Credentials,
                                     (void **)&pUnknown);
        BAIL_ON_FAILURE(hr);
    }
    else {
        //
        // we have validated it already, it *has* to be an FPNW server
        //
        hr = CFPNWFileShare::Create(szADsParent,
                                    szServerName,
                                    szFileServiceName,
                                    szFileShareName,
                                    ADS_OBJECT_BOUND,
                                    IID_IUnknown,
                                    Credentials,
                                    (void **)&pUnknown);
        BAIL_ON_FAILURE(hr);
    }

    *ppObject = pUnknown;

    if(pFileShareObjectInfo){
        FreeObjectInfo(pFileShareObjectInfo);
    }

    RRETURN(hr);

error:
    if (pUnknown) {
        pUnknown->Release();
    }

    if(pFileShareObjectInfo){
        FreeObjectInfo(pFileShareObjectInfo);
    }

    *ppObject = NULL;

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
// Function:   GetGroupObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetGroupObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPWSTR szServerName = NULL;
    LPWSTR szDomainName = NULL;
    LPWSTR szGroupName = NULL;
    DWORD  dwParentId = 0;
    ULONG uGroupType = 0;
    POBJECTINFO pGroupObjectInfo = NULL;

    hr = ValidateGroupObject(
                pObjectInfo,
                &uGroupType,
                &dwParentId,
                Credentials
                );
    BAIL_ON_FAILURE(hr);

    switch (pObjectInfo->NumComponents) {
    case 2:
        //
        // could be group in computer or group in domain
        //
        if(dwParentId == WINNT_DOMAIN_ID){

            szDomainName = pObjectInfo->ComponentArray[0];
            szGroupName = pObjectInfo->ComponentArray[1];
            szServerName = NULL;
            hr = BuildParent(pObjectInfo, ADsParent);
            BAIL_ON_FAILURE(hr);

        } else {

            //
            // group in a computer
            //

            hr = ConstructFullObjectInfo(pObjectInfo,
                                         &pGroupObjectInfo,
                                         Credentials );


            if (SUCCEEDED(hr)) {
                hr = BuildParent(pGroupObjectInfo, ADsParent);

                BAIL_ON_FAILURE(hr);

                szDomainName =  pGroupObjectInfo->ComponentArray[0];
                szServerName =  pGroupObjectInfo->ComponentArray[1];
                szGroupName   =  pGroupObjectInfo->ComponentArray[2];

            }
            else if (hr == HRESULT_FROM_WIN32(NERR_WkstaNotStarted)) {
                //
                // We will build the info without the parent
                //
                hr = BuildParent(pObjectInfo, ADsParent);

                BAIL_ON_FAILURE(hr);

                szDomainName =  NULL;
                szServerName =  pObjectInfo->ComponentArray[0];
                szGroupName   = pObjectInfo->ComponentArray[1];

            }

            BAIL_ON_FAILURE(hr);

        }

        break;

    case 3:

        hr = BuildParent(pObjectInfo, ADsParent);
        BAIL_ON_FAILURE(hr);

        szDomainName = pObjectInfo->ComponentArray[0];
        szServerName = pObjectInfo->ComponentArray[1];
        szGroupName = pObjectInfo->ComponentArray[2];
        break;

    }

    hr = CWinNTGroup::CreateGroup(
                          ADsParent,
                          dwParentId,
                          szDomainName,
                          szServerName,
                          szGroupName,
                          uGroupType,
                          ADS_OBJECT_BOUND,
                          IID_IUnknown,
                          Credentials,
                          (void **)&pUnknown
                          );

    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    if(pGroupObjectInfo){
        FreeObjectInfo(pGroupObjectInfo);
    }

    RRETURN(hr);

error:
    if (pUnknown) {
        pUnknown->Release();
    }

    if(pGroupObjectInfo){
        FreeObjectInfo(pGroupObjectInfo);
    }

    *ppObject = NULL;

    RRETURN(hr);
}




//+---------------------------------------------------------------------------
// Function:   GetGroupObjectInComputer
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   ramv     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetGroupObjectInComputer(
    LPWSTR pszHostServerName, // pdc name
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials)
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPWSTR szServerName = NULL;
    LPWSTR szDomainName = NULL;
    LPWSTR szGroupName = NULL;
    DWORD  dwParentId = WINNT_COMPUTER_ID;
    ULONG uGroupType = 0;
    POBJECTINFO pGroupObjectInfo = NULL;
    WCHAR lpszUncName[MAX_PATH];


    switch (pObjectInfo->NumComponents) {
    case 2:
        //
        // group in a computer
        //

        MakeUncName(pObjectInfo->ComponentArray[0],
                    lpszUncName);

        hr = ValidateGlobalGroupObject(
                 lpszUncName,
                 &(pObjectInfo->ComponentArray[1]),
                 Credentials
                 );

        if (SUCCEEDED(hr)) {
            uGroupType = WINNT_GROUP_GLOBAL;

        }else{
            hr = ValidateLocalGroupObject(
                     lpszUncName,
                     &(pObjectInfo->ComponentArray[1]),
                     Credentials
                     );

            BAIL_ON_FAILURE(hr);
            uGroupType = WINNT_GROUP_LOCAL;
        }

        hr = ConstructFullObjectInfo(pObjectInfo,
                                     &pGroupObjectInfo,
                                     Credentials );
        BAIL_ON_FAILURE(hr);

        hr = BuildParent(pGroupObjectInfo, ADsParent);
        BAIL_ON_FAILURE(hr);

        szDomainName =  pGroupObjectInfo->ComponentArray[0];
        szServerName =  pGroupObjectInfo->ComponentArray[1];
        szGroupName   =  pGroupObjectInfo->ComponentArray[2];

        break;

    case 3:

        hr = ValidateComputerParent(pObjectInfo->ComponentArray[0],
                                    pObjectInfo->ComponentArray[1],
                                    Credentials);

        BAIL_ON_FAILURE(hr);

        MakeUncName(
                pObjectInfo->ComponentArray[1],
                lpszUncName
                );

        hr = ValidateGlobalGroupObject(
                        lpszUncName,
                        &(pObjectInfo->ComponentArray[2]),
                        Credentials
                        );

        if (SUCCEEDED(hr)) {
            uGroupType = WINNT_GROUP_GLOBAL;
        } else {
            hr = ValidateLocalGroupObject(
                           lpszUncName,
                           &(pObjectInfo->ComponentArray[2]),
                           Credentials
                           );

            BAIL_ON_FAILURE(hr);
            uGroupType = WINNT_GROUP_LOCAL;
        }

        hr = BuildParent(pObjectInfo, ADsParent);
        BAIL_ON_FAILURE(hr);

        szDomainName = pObjectInfo->ComponentArray[0];
        szServerName = pObjectInfo->ComponentArray[1];
        szGroupName = pObjectInfo->ComponentArray[2];
        break;
    }

    if (uGroupType == WINNT_GROUP_LOCAL) {

        hr = CWinNTGroup::CreateGroup(ADsParent,
                                dwParentId,
                                szDomainName,
                                szServerName,
                                szGroupName,
                                uGroupType,
                                ADS_OBJECT_BOUND,
                                IID_IUnknown,
                                Credentials,
                                (void **)&pUnknown
                                );


    }else {

        hr = CWinNTGroup::CreateGroup(ADsParent,
                                dwParentId,
                                szDomainName,
                                szServerName,
                                szGroupName,
                                uGroupType,
                                ADS_OBJECT_BOUND,
                                IID_IUnknown,
                                Credentials,
                                (void **)&pUnknown
                                );


    }

    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    if(pGroupObjectInfo){
        FreeObjectInfo(pGroupObjectInfo);
    }

    RRETURN(hr);

error:
    if (pUnknown) {
        pUnknown->Release();
    }

    if(pGroupObjectInfo){
        FreeObjectInfo(pGroupObjectInfo);
    }

    *ppObject = NULL;

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   GetGroupObjectInDomain
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    8-8-96 Ramv     Created.
//
//----------------------------------------------------------------------------

HRESULT
GetGroupObjectInDomain(
    LPWSTR pszHostServerName,
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPWSTR szServerName = NULL;
    LPWSTR szDomainName = NULL;
    LPWSTR szGroupName = NULL;
    DWORD  dwParentId = WINNT_DOMAIN_ID;
    ULONG uGroupType = 0;
    BOOL fRefAdded = FALSE;

    // At this point the host server name has a \\ prepended
    // so we need to get rid of it.
    hr = Credentials.RefServer(pszHostServerName+2);
    if (SUCCEEDED(hr)) {
        fRefAdded = TRUE;
    }

    hr = ValidateGlobalGroupObject(
             pszHostServerName,
             &(pObjectInfo->ComponentArray[1]),
             Credentials
             );

    if (FAILED(hr)) {
        hr = ValidateLocalGroupObject(
                    pszHostServerName,
                    &(pObjectInfo->ComponentArray[1]),
                    Credentials
                    );

        // DeRef if ref added, no recovery possible on failed deref
        if (fRefAdded) {
            Credentials.DeRefServer();
            fRefAdded = FALSE;
        }

        BAIL_ON_FAILURE(hr);
        uGroupType = WINNT_GROUP_LOCAL;
    }else {

        uGroupType = WINNT_GROUP_GLOBAL;
    }

    // DeRef if ref added, no recovery possible on failed deref
    if (fRefAdded) {
        Credentials.DeRefServer();
        fRefAdded = FALSE;
    }

    szDomainName = pObjectInfo->ComponentArray[0];
    szGroupName = pObjectInfo->ComponentArray[1];
    szServerName = NULL;
    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);

    if (uGroupType==WINNT_GROUP_LOCAL) {

        hr = CWinNTGroup::CreateGroup(
                            ADsParent,
                            dwParentId,
                            szDomainName,
                            szServerName,
                            szGroupName,
                            uGroupType,
                            ADS_OBJECT_BOUND,
                            IID_IUnknown,
                            Credentials,
                            (void **)&pUnknown
                            );
    } else {

        hr = CWinNTGroup::CreateGroup(ADsParent,
                            dwParentId,
                            szDomainName,
                            szServerName,
                            szGroupName,
                            uGroupType,
                            ADS_OBJECT_BOUND,
                            IID_IUnknown,
                            Credentials,
                            (void **)&pUnknown
                            );
    }
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown) {
        pUnknown->Release();
    }

    *ppObject = NULL;

    RRETURN(hr);
}




//+---------------------------------------------------------------------------
// Function:   GetSchemaObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    1-17-96   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetSchemaObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;

    if (pObjectInfo->NumComponents != 2)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) != 0 )
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);

    hr = CWinNTSchema::CreateSchema( ADsParent,
                                     pObjectInfo->ComponentArray[1],
                                     ADS_OBJECT_BOUND,
                                     IID_IUnknown,
                                     Credentials,
                                     (void **)&pUnknown );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}







//+---------------------------------------------------------------------------
// Function:   GetClassObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    1-17-96   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetClassObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    DWORD i;

    if (pObjectInfo->NumComponents != 3)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) != 0 )
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Look for the given class name
    //

    for ( i = 0; i < g_cWinNTClasses; i++ )
    {
         if ( _wcsicmp( g_aWinNTClasses[i].bstrName,
                        pObjectInfo->ComponentArray[2] ) == 0 )
             break;
    }

    if ( i == g_cWinNTClasses )
    {
        // Class name not found, return error

        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Class name found, create and return the object
    //

    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);

    hr = CWinNTClass::CreateClass( ADsParent,
                                   &g_aWinNTClasses[i],
                                   ADS_OBJECT_BOUND,
                                   IID_IUnknown,
                                   Credentials,
                                   (void **)&pUnknown );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetSyntaxObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    1-17-96   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetSyntaxObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    DWORD i;

    if (pObjectInfo->NumComponents != 3)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) != 0 )
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Look for the given syntax name
    //

    for ( i = 0; i < g_cWinNTSyntax; i++ )
    {
         if ( _wcsicmp( g_aWinNTSyntax[i].bstrName,
                        pObjectInfo->ComponentArray[2] ) == 0 )
             break;
    }

    if ( i == g_cWinNTSyntax )
    {
        // Syntax name not found, return error

        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Syntax name found, create and return the object
    //

    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);

    hr = CWinNTSyntax::CreateSyntax( ADsParent,
                                     &(g_aWinNTSyntax[i]),
                                     ADS_OBJECT_BOUND,
                                     IID_IUnknown,
                                     Credentials,
                                     (void **)&pUnknown );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetPropertyObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    1-17-96   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetPropertyObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials 
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    WCHAR ADsGrandParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    DWORD nClass, nProp;

    if (pObjectInfo->NumComponents != 3)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) != 0 )
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We found the specified functional set, now see if we can locate
    // the given property name
    //

    for ( nProp = 0; nProp < g_cWinNTProperties; nProp++ )
    {
         if ( _wcsicmp(g_aWinNTProperties[nProp].szPropertyName,
                        pObjectInfo->ComponentArray[2] ) == 0 )
             break;
    }

    if ( nProp == g_cWinNTProperties )
    {
        // Return error because the given property name is not found

        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }


    //
    // Property name is found, so create and return the object
    //

    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);


    hr = CWinNTProperty::CreateProperty(
                             ADsParent,
                             &(g_aWinNTProperties[nProp]),
                             ADS_OBJECT_BOUND,
                             IID_IUnknown,
                             Credentials,
                             (void **)&pUnknown );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
HeuristicGetObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    WCHAR szHostServerName[MAX_PATH];
    DWORD dwElementType;
    WCHAR szName[MAX_PATH];
    WCHAR szSAMName[MAX_ADS_PATH];
    WCHAR lpszUncName[MAX_PATH];

    szSAMName[0] = L'\0';
    //
    // Case 0: Zero components - must be a namespace object
    //

    if (pObjectInfo->NumComponents == 0) {
        RRETURN(GetNamespaceObject(pObjectInfo, ppObject, Credentials));
    }

    //
    // Case 1: Single component - must be a domain object or
    // computer object
    //

    if (pObjectInfo->NumComponents == 1) {

        //
        // hr = WinNTGetCachedObject(type, hit/miss, pdcname/domain name)
        //
        // if (succeeded...
        // switch(type) .... call the appropriate
        // GetDomain or GetWorkGroup or GetComputer
        //

        hr = WinNTGetCachedName(
                 pObjectInfo->ComponentArray[0],
                 &dwElementType,
                 szHostServerName,
                 szSAMName,
                 Credentials
                 );

        BAIL_IF_ERROR(hr);

        // update the name to the one on SAM
        if (szSAMName[0] != L'\0') {
            FreeADsStr(pObjectInfo->ComponentArray[0]);
            pObjectInfo->ComponentArray[0] = AllocADsStr(szSAMName);
        }

        if (!pObjectInfo->ComponentArray[0]) {
            BAIL_IF_ERROR(hr = E_OUTOFMEMORY);
        }

        switch(dwElementType) {

        case DOMAIN_ENTRY_TYPE:
            hr = GetDomainObject(pObjectInfo, ppObject, Credentials);
            break;

        case COMPUTER_ENTRY_TYPE:
            hr = GetComputerObject(pObjectInfo, ppObject, Credentials);
            break;

        default:
            hr = GetWorkGroupObject(pObjectInfo, ppObject, Credentials);
            break;

        }
        goto cleanup;

    }

    //
    // Case 2: Two components - could be user, group, computer,
    // or any one of the computer's sub-objects.
    //


    if (pObjectInfo->NumComponents == 2) {

        hr = GetSchemaObject(pObjectInfo, ppObject, Credentials);

        if(SUCCEEDED(hr)){
            goto cleanup;
        }
        if(FAILED(hr)) {
            //
            // try doing a WinNTGetCachedDCName first
            // and if it goes through, then we have objects such as
            // user,group,computer in domain, otherwise it is the
            // computer case or workgroup case
            //

            // WinNtGetCachedObject will directly tell us to proceed or
            // not

            hr = WinNTGetCachedName(pObjectInfo->ComponentArray[0],
                                    &dwElementType,
                                    szHostServerName,
                                    szSAMName,
                                    Credentials );

            BAIL_IF_ERROR(hr);

            // Again we do not have to worry about the case of the
            // object name, it is handled by the GetObject calls

            switch(dwElementType) {

            case DOMAIN_ENTRY_TYPE:

                hr = GetUserObjectInDomain(szHostServerName,
                                           pObjectInfo,
                                           ppObject,
                                           Credentials);

                if (FAILED(hr)) {
                    hr = GetGroupObjectInDomain(szHostServerName,
                                                pObjectInfo,
                                                ppObject,
                                                Credentials);
                }

                if (FAILED(hr)) {
                    hr = GetComputerObject(pObjectInfo, ppObject, Credentials);
                }

                goto cleanup;

            case COMPUTER_ENTRY_TYPE:

                hr = GetPrinterObject(pObjectInfo, ppObject, Credentials);
                if (FAILED(hr)) {
                    hr = GetFileServiceObject(
                        pObjectInfo,
                        ppObject,
                        Credentials
                        );
                }
                if (FAILED(hr)) {
                    hr = GetServiceObject(pObjectInfo, ppObject, Credentials);
                }
                if(FAILED(hr)){
                    hr = GetUserObjectInComputer(
                             pObjectInfo->ComponentArray[0],
                             pObjectInfo,
                             ppObject,
                             Credentials
                             );
                }
                if (FAILED(hr)) {
                    hr = GetGroupObjectInComputer(
                             pObjectInfo->ComponentArray[0],
                             pObjectInfo,
                             ppObject,
                             Credentials
                             );
                }
                goto cleanup;

            case WORKGROUP_ENTRY_TYPE:

                hr = GetComputerObject(pObjectInfo, ppObject, Credentials);
                if (FAILED(hr)) {
                    if (hr == HRESULT_FROM_WIN32(NERR_BadTransactConfig)) {
                        // In this case I want to mask the error
                        // as it means it could not find the object
                        hr = E_ADS_UNKNOWN_OBJECT;
                    }
                }
                goto cleanup;

            default:
                hr = E_ADS_UNKNOWN_OBJECT;
                goto cleanup;

            }

        }
    } /* NumComponents == 2 */

    //
    // Case 3: Three components - could be user, group, printer,  fileservice
    // or service or fileshare for computer in a workgroup environment.
    //


    if (pObjectInfo->NumComponents == 3) {

        if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) == 0 ){
            hr = GetClassObject(pObjectInfo, ppObject, Credentials);

            if (FAILED(hr)) {

                hr = GetPropertyObject(pObjectInfo, ppObject, Credentials);
            }

            if (FAILED(hr)) {
                hr = GetSyntaxObject(pObjectInfo, ppObject, Credentials);
            }
        }
        else{
            hr = GetUserObjectInComputer(pObjectInfo->ComponentArray[1],
                                         pObjectInfo,
                                         ppObject,
                                         Credentials);

            if (FAILED(hr)) {
                hr = GetGroupObjectInComputer(pObjectInfo->ComponentArray[1],
                                              pObjectInfo,
                                              ppObject,
                                              Credentials);
            }

            if(FAILED(hr)){
                hr = GetPrinterObject(pObjectInfo, ppObject, Credentials);
            }

            if (FAILED(hr)) {
                hr = GetFileServiceObject(pObjectInfo, ppObject, Credentials);
            }

            if (FAILED(hr)) {
                hr = GetServiceObject(pObjectInfo, ppObject, Credentials);
            }

            if (FAILED(hr)) {
                hr = GetFileShareObject(pObjectInfo, ppObject, Credentials);
            }

        }
        if(FAILED(hr) ){
            RRETURN(hr);
        }
        else{
            RRETURN(S_OK);
        }
    }

    if (pObjectInfo->NumComponents == 4) {

        hr = GetFileShareObject(pObjectInfo, ppObject, Credentials);

        if(FAILED(hr)){
            RRETURN(hr);
        }
        else{
            RRETURN(S_OK);
        }

    }
    RRETURN (E_ADS_UNKNOWN_OBJECT);

cleanup:

    if (hr == HRESULT_FROM_WIN32(NERR_WkstaNotStarted)) {

        //
        // There is a very good chance that this is a case
        // where they are trying to work on the local machine
        // when there are no workstation services. Note that this
        // means that a fully qualified name was not given.
        //
        hr = HeuristicGetObjectNoWksta(
                 pObjectInfo,
                 ppObject,
                 Credentials
                 );

    }

    //
    // Propagate the error code which we have rather than
    // mask it and return information of little value
    //
    if (FAILED(hr)) {

        // the error code NERR_BadTransactConfig means that the
        // object did not exist, we want to mask just that ecode
        if (hr == HRESULT_FROM_WIN32(NERR_BadTransactConfig)) {
            hr = E_ADS_UNKNOWN_OBJECT;
        }

        RRETURN(hr);

    } else {
        RRETURN(S_OK);
    }
}




//+---------------------------------------------------------------------------
// Function: HeuristicGetObjectNoWksta
//
// Synopsis: Tries to locate the object on local machine when there are no
//          workstation services. This will happen in a minimum install of NT.
//
// Arguments: POBJECTINFO -> data about object being located.
//            LPVOID      -> Object to be returned in this arg.
//            Credentials -> Credentials blob.
//
// Returns: Either S_OK or HR_From_Win32(NERR_WkstaNotStarted)
//
// Modifies:
//
// History:    08-03-98   AjayR     Created.
//
//----------------------------------------------------------------------------
HRESULT
HeuristicGetObjectNoWksta(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    HRESULT hrNoWksta = HRESULT_FROM_WIN32(NERR_WkstaNotStarted);
    WCHAR szHostServerName[MAX_PATH];
    DWORD dwElementType;
    WCHAR szName[MAX_PATH];
    WCHAR szSAMName[MAX_ADS_PATH];
    WCHAR lpszUncName[MAX_PATH];

    szSAMName[0] = L'\0';

    //
    // Case 0: Zero components - Should no be hit here.
    //

    if (pObjectInfo->NumComponents == 0) {
        RRETURN(hrNoWksta);
    }

    //
    // Case 1: Single component - Can only be a computer object
    //

    if (pObjectInfo->NumComponents == 1) {

        hr = GetComputerObject(pObjectInfo, ppObject, Credentials);
        goto cleanup;

    }

    //
    // Case 2: Two components - could be user or group for now.
    // Other possible objects - TBD.
    //


    if (pObjectInfo->NumComponents == 2) {


        hr = GetPrinterObject(pObjectInfo, ppObject, Credentials);

        if (FAILED(hr)) {
            hr = GetFileServiceObject(
                     pObjectInfo,
                     ppObject,
                     Credentials
                     );
                }

        if (FAILED(hr)) {
            hr = GetServiceObject(pObjectInfo, ppObject, Credentials);
        }

        if(FAILED(hr)){
            hr = GetUserObject(
                     pObjectInfo,
                     ppObject,
                     Credentials
                     );
        }
        if (FAILED(hr)) {
            hr = GetLocalGroupObject(
                     pObjectInfo,
                     ppObject,
                     Credentials
                     );
        }
        goto cleanup;

    } /* NumComponents == 2 */

    //
    // Case 3 or more : Three or more components - not possible
    //


    if (pObjectInfo->NumComponents > 2) {

        RRETURN(hrNoWksta);

    }

    RRETURN (E_ADS_UNKNOWN_OBJECT);

cleanup:
    //
    // Propagate the error code which we have rather than
    // mask it and return information of little value
    //
    if (FAILED(hr)) {
        // the error code NERR_BadTransactConfig means that the
        // object did not exist, we want to mask just that ecode
        if (hr == HRESULT_FROM_WIN32(NERR_BadTransactConfig)) {
            hr = E_ADS_UNKNOWN_OBJECT;
        }

        RRETURN(hr);

    } else {
        RRETURN(S_OK);
    }
}



HRESULT
BuildParent(
    POBJECTINFO pObjectInfo,
    LPWSTR szBuffer
    )
{
    DWORD i = 0;
    DWORD dwLen = 0;


    if (!pObjectInfo->ProviderName) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    wsprintf(szBuffer, L"%s:", pObjectInfo->ProviderName);

    if (pObjectInfo->NumComponents - 1) {

        dwLen = wcslen(pObjectInfo->ProviderName) + 3 + 
                wcslen(pObjectInfo->DisplayComponentArray[0]);
        if(dwLen >= MAX_ADS_PATH) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

        wcscat(szBuffer, L"//");
        wcscat(szBuffer, pObjectInfo->DisplayComponentArray[0]);

        for (i = 1; i < (pObjectInfo->NumComponents - 1); i++) {
            dwLen += (1 + wcslen(pObjectInfo->DisplayComponentArray[i]));
            if(dwLen >= MAX_ADS_PATH) {
                RRETURN(E_ADS_BAD_PATHNAME);
            }

            wcscat(szBuffer, L"/");
            wcscat(szBuffer, pObjectInfo->DisplayComponentArray[i]);
        }
    }
    RRETURN(S_OK);
}

HRESULT
BuildGrandParent(
    POBJECTINFO pObjectInfo,
    LPWSTR szBuffer
    )
{
    DWORD i = 0;

    if (!pObjectInfo->ProviderName) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    wsprintf(szBuffer, L"%s:", pObjectInfo->ProviderName);

    if (pObjectInfo->NumComponents - 2) {

        wcscat(szBuffer, L"//");
        wcscat(szBuffer, pObjectInfo->ComponentArray[0]);

        for (i = 1; i < (pObjectInfo->NumComponents - 2); i++) {
            wcscat(szBuffer, L"/");
            wcscat(szBuffer, pObjectInfo->ComponentArray[i]);
        }
    }

    RRETURN(S_OK);
}


HRESULT
BuildADsPath(
    POBJECTINFO pObjectInfo,
    LPWSTR szBuffer
    )
{
    DWORD i = 0;

    if (!pObjectInfo->ProviderName) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    wsprintf(szBuffer, L"%s:", pObjectInfo->ProviderName);

    if (pObjectInfo->NumComponents) {

        wcscat(szBuffer, L"//");
        wcscat(szBuffer, pObjectInfo->DisplayComponentArray[0]);

        for (i = 1; i < (pObjectInfo->NumComponents); i++) {
            wcscat(szBuffer, L"/");
            wcscat(szBuffer, pObjectInfo->DisplayComponentArray[i]);
        }
    }
    RRETURN(S_OK);
}



HRESULT
ValidateUserObject(
    POBJECTINFO pObjectInfo,
    PDWORD  pdwParentId,
    CWinNTCredentials& Credentials
    )
{
    WCHAR szHostServerName[MAX_PATH];
    LPUSER_INFO_20 lpUI = NULL;
    HRESULT hr;
    WCHAR lpszUncName[MAX_PATH];
    NET_API_STATUS nasStatus;
    WCHAR szSAMName[MAX_PATH];
    BOOL fRefAdded = FALSE;
    LPUSER_INFO_0 lpUI_0 = NULL;
    DWORD dwLevelUsed = 20;
    WCHAR szCompName[MAX_PATH];
    DWORD dwSize = MAX_PATH;

    szSAMName[0] = L'\0';

    switch (pObjectInfo->NumComponents) {
    case 2:

        //
        // if 2 components then either it is user in computer
        // or user in domain.

        hr = WinNTGetCachedDCName(
                        pObjectInfo->ComponentArray[0],
                        szHostServerName,
                        Credentials.GetFlags()
                        );


        if(SUCCEEDED(hr)){

            // Need to ref the server, note that RefServer
            // checks if the credentials are non null
            // We are not concerned about any error as we may
            // still succeed with default credentials.
            // The +2 is to skip the \\ at the head.
            hr = Credentials.RefServer(szHostServerName+2);
            if (SUCCEEDED(hr)) {
                fRefAdded = TRUE;
            }

            nasStatus = NetUserGetInfo(szHostServerName,
                                       pObjectInfo->ComponentArray[1],
                                       20,
                                       (LPBYTE *)&lpUI);
            //
            // This code is here because Level 20 reads the flags
            // and if you accessed WinNT://ntdev/foo with Redmond\foo
            // credentials, it will fail. This allow a bind but the
            // GetInfo will fail.
            //
            if (nasStatus == ERROR_ACCESS_DENIED) {
                // try and drop down to level 0 as that may work

                dwLevelUsed = 0;
                nasStatus = NetUserGetInfo(
                                szHostServerName,
                                pObjectInfo->ComponentArray[1],
                                0,
                                (LPBYTE *)&lpUI_0
                                );
            }

            // DeRef if ref added, no recovery possible on failed deref
            if (fRefAdded) {
                Credentials.DeRefServer();
                fRefAdded = FALSE;
            }

            hr = HRESULT_FROM_WIN32(nasStatus);

            BAIL_ON_FAILURE(hr);

            // Need to use the name returned by the call as opposed
            // to the name given in the ADsPath
            if (dwLevelUsed == 20 ) {
                if (pObjectInfo->ComponentArray[1] && lpUI->usri20_name) {
                    FreeADsStr(pObjectInfo->ComponentArray[1]);
                    pObjectInfo->ComponentArray[1]
                        = AllocADsStr(lpUI->usri20_name);
                }

                if (!pObjectInfo->ComponentArray[1])
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            *pdwParentId = WINNT_DOMAIN_ID;
        }

        //
        // if we are here with hr != S_OK it could be that we have
        // user in a  computer.
        //

        if(FAILED(hr)){
            hr = ValidateComputerParent(
                     NULL,
                     pObjectInfo->ComponentArray[0],
                     Credentials
                     );

            if (SUCCEEDED(hr)) {

                // Need to ref the server on which the object lives
                // Note that RefServer checks if Credentials are null.
                // Again, we are not concerned about any errors as we
                // will drop down to default credentials automatically.

                hr = Credentials.RefServer(pObjectInfo->ComponentArray[0]);
                if (SUCCEEDED(hr)) {
                    fRefAdded = TRUE;
                }

                MakeUncName(pObjectInfo->ComponentArray[0],
                            lpszUncName);

                nasStatus = NetUserGetInfo(lpszUncName,
                                           pObjectInfo->ComponentArray[1],
                                           20,
                                           (LPBYTE *)&lpUI);

                // DeRef if ref added, no recovery possible on failed deref
                if (fRefAdded) {
                    Credentials.DeRefServer();
                    fRefAdded = FALSE;
                }
                hr = HRESULT_FROM_WIN32(nasStatus);
                BAIL_ON_FAILURE(hr);

                // Need to use the name returned by the call as opposed
                // to the name given in the ADsPath
                if (pObjectInfo->ComponentArray[1] && lpUI->usri20_name) {
                    FreeADsStr(pObjectInfo->ComponentArray[1]);
                    pObjectInfo->ComponentArray[1]
                        = AllocADsStr(lpUI->usri20_name);
                }

                if (!pObjectInfo->ComponentArray[1])
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

                *pdwParentId = WINNT_COMPUTER_ID;
            }
            else if (hr == HRESULT_FROM_WIN32(NERR_WkstaNotStarted)) {

                //
                // Need to see if the problem was not workstation
                // services in which case we need to still try and
                // locate user if the comptuer name matches.
                //

                if (!GetComputerName(szCompName, &dwSize)) {
                    //
                    // We could not get the computer name so bail
                    //
                    BAIL_ON_FAILURE(hr);
                }

                //
                // Test the name before continuing.
                //
#ifdef WIN95
                if (_wcsicmp(szCompName, pObjectInfo->ComponentArray[0])) {
#else
                if (CompareStringW(
                        LOCALE_SYSTEM_DEFAULT,
                        NORM_IGNORECASE,
                        szCompName,
                        -1,
                        pObjectInfo->ComponentArray[0],
                        -1
                        ) != CSTR_EQUAL ) {
#endif
                    // names do not match
                    BAIL_ON_FAILURE(hr);
                }

                //
                // Valid computer name, so we can try and check for user
                //

                MakeUncName(pObjectInfo->ComponentArray[0], lpszUncName);

                nasStatus = NetUserGetInfo(
                                lpszUncName,
                                pObjectInfo->ComponentArray[1],
                                20,
                                (LPBYTE *)&lpUI
                                );

                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(nasStatus));

                *pdwParentId = WINNT_COMPUTER_ID;

            }
        }

        BAIL_ON_FAILURE(hr);

        break;

    case 3:

        //
        // user in domain\computer or user in workgroup\computer
        //



        hr = ValidateComputerParent(
                 pObjectInfo->ComponentArray[0],
                 pObjectInfo->ComponentArray[1],
                 Credentials
                 );
        BAIL_ON_FAILURE(hr);

        // Again we need to ref the server

        hr = Credentials.RefServer(pObjectInfo->ComponentArray[1]);
        if (SUCCEEDED(hr)) {
            fRefAdded = TRUE;
        }

        MakeUncName(pObjectInfo->ComponentArray[1],
                    lpszUncName);

        nasStatus = NetUserGetInfo(lpszUncName,
                                   pObjectInfo->ComponentArray[2],
                                   20,
                                   (LPBYTE *)&lpUI);

        // DeRef if ref added, no recovery possible on failed deref
        if (fRefAdded) {
            Credentials.DeRefServer();
            fRefAdded = FALSE;
        }
        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);

        // Need to use the name returned by the call as opposed
        // to the name given in the ADsPath
        if (pObjectInfo->ComponentArray[2] && lpUI->usri20_name) {
            FreeADsStr(pObjectInfo->ComponentArray[2]);
            pObjectInfo->ComponentArray[2]
                = AllocADsStr(lpUI->usri20_name);
        }

        if (!pObjectInfo->ComponentArray[2])
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        *pdwParentId = WINNT_COMPUTER_ID;
        break;


    default:
        RRETURN(E_ADS_BAD_PATHNAME);
    }


  error:
    if (lpUI) {
        NetApiBufferFree((LPBYTE)lpUI);
    }

    if (lpUI_0) {
        NetApiBufferFree((LPBYTE)lpUI_0);
    }

    RRETURN(hr);

}



HRESULT
ValidateComputerParent(
    LPWSTR pszDomainName,
    LPWSTR pszComputerName,
    CWinNTCredentials& Credentials
    )

{
    HRESULT hr;
    NET_API_STATUS nasStatus;
    WCHAR szName[MAX_PATH];
    WCHAR szSAMName[MAX_PATH];
    WCHAR szCompName[MAX_PATH];
    DWORD dwSize = MAX_PATH;

    szSAMName[0] = L'\0';

    hr = WinNTGetCachedComputerName(
             pszComputerName,
             szName,
             szSAMName,
             Credentials
             );

    if (hr == HRESULT_FROM_WIN32(NERR_WkstaNotStarted)) {

        //
        // We want to see if the computer being validated is
        // the current host.
        //
        if (!GetComputerName(szCompName, &dwSize)
#ifdef WIN95
            || (_wcsicmp(szCompName, pszComputerName))
#else
            || (CompareStringW(
                    LOCALE_SYSTEM_DEFAULT,
                    NORM_IGNORECASE,
                    szCompName,
                    -1,
                    pszComputerName,
                    -1
                    ) != CSTR_EQUAL )
#endif
            )
            BAIL_ON_FAILURE(hr);

        hr = S_OK;

    }
    BAIL_ON_FAILURE(hr);


    if(pszDomainName == NULL){
        //
        // we are dealing with a case where we aren't supplied the
        // computer's parent. Just validate the computer
        //
        hr = S_OK;
        goto error;

    } else {

#ifdef WIN95


        //
        // No NetpNameCompare for Win9x
        //
        if (!_wcsicmp(pszDomainName, szName)) {
#else
        if ((CompareStringW(
                 LOCALE_SYSTEM_DEFAULT,
                 NORM_IGNORECASE,
                 pszDomainName,
                 -1,
                 szName,
                 -1
                 ) == CSTR_EQUAL )
             || (NetpNameCompare(
                     NULL,
                     pszDomainName,
                     szName,
                     NAMETYPE_DOMAIN,
                     0
                     ) == 0 )
            ) {
#endif
            hr = S_OK;
        }else {
            hr = E_ADS_BAD_PATHNAME;
        }
    }

error:
    RRETURN(hr);
}

// Overloaded ValidateComputerParent function.
// This is used when the case of pszComputerName on the SAM
// databsae is needed.
HRESULT
ValidateComputerParent(
    LPWSTR pszDomainName,
    LPWSTR pszComputerName,
    LPWSTR pszSAMName,
    CWinNTCredentials& Credentials
    )

{
    HRESULT hr;
    NET_API_STATUS nasStatus;
    WCHAR szName[MAX_PATH];
    WCHAR szSAMName[MAX_PATH];

    szSAMName[0] = L'\0';

    hr = WinNTGetCachedComputerName(
             pszComputerName,
             szName,
             szSAMName,
             Credentials
             );

    BAIL_ON_FAILURE(hr);

    if (szSAMName[0] != L'\0') {
        wcscpy(pszSAMName, szSAMName);
    }


    if(pszDomainName == NULL){
        //
        // we are dealing with a case where we aren't supplied the
        // computer's parent. Just validate the computer
        //
        hr = S_OK;
        goto error;

    } else {


#ifdef WIN95
        //
        // No NetpNameCompare for Win9x
        //
        if (!_wcsicmp(pszDomainName, szName)) {
#else
        if ((CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                pszDomainName,
                -1,
                szName,
                -1
                ) == CSTR_EQUAL ) 
            || (NetpNameCompare(
                     NULL,
                     pszDomainName,
                     szName,
                     NAMETYPE_DOMAIN,
                     0
                     ) == 0 )
            ) {
#endif

            hr = S_OK;
        }else {

            hr = E_FAIL;
        }
    }

error:
    RRETURN(hr);
}


HRESULT
ValidateGroupObject(
    POBJECTINFO pObjectInfo,
    PULONG puGroupType,
    PDWORD pdwParentId,
    CWinNTCredentials& Credentials
    )
{
    WCHAR szHostServerName[MAX_PATH];
    LPGROUP_INFO_0 lpGI = NULL;
    HRESULT hr;
    WCHAR lpszUncName[MAX_PATH];
    NET_API_STATUS nasStatus;
    ULONG uGroupType = 0L;
    WCHAR szSAMName[MAX_PATH];

    szSAMName[0] = L'\0';

    switch (pObjectInfo->NumComponents) {
    case 2:
        //
        // if 2 components then either it is a group in computer
        // or group in domain.
        //

        hr = WinNTGetCachedDCName(
                    pObjectInfo->ComponentArray[0],
                    szHostServerName,
                    Credentials.GetFlags()
                    );

        if(SUCCEEDED(hr)){
            //
            // must be a group in a domain
            //
            *pdwParentId = WINNT_DOMAIN_ID;

            hr = ValidateGlobalGroupObject(
                     szHostServerName,
                     &(pObjectInfo->ComponentArray[1]),
                     Credentials
                     );

            if (FAILED(hr)) {
                hr = ValidateLocalGroupObject(
                         szHostServerName,
                         &(pObjectInfo->ComponentArray[1]),
                         Credentials
                         );

                if(SUCCEEDED(hr)){
                    uGroupType = WINNT_GROUP_LOCAL;
                }

            }else{
                uGroupType = WINNT_GROUP_GLOBAL;
            }
        }

        if(FAILED(hr)){
            //
            // potentially a group in a computer
            //

            hr = ValidateComputerParent(NULL,
                                        pObjectInfo->ComponentArray[0],
                                        Credentials);
            BAIL_ON_FAILURE(hr);

            //
            // group in a computer
            //
            *pdwParentId = WINNT_COMPUTER_ID;

            MakeUncName(pObjectInfo->ComponentArray[0],
                        lpszUncName);

            hr = ValidateGlobalGroupObject(
                     lpszUncName,
                     &(pObjectInfo->ComponentArray[1]),
                     Credentials
                     );

            if (FAILED(hr)) {

                hr = ValidateLocalGroupObject(
                         lpszUncName,
                         &(pObjectInfo->ComponentArray[1]),
                         Credentials
                         );

                BAIL_ON_FAILURE(hr);
                uGroupType = WINNT_GROUP_LOCAL;

            }else{
                uGroupType = WINNT_GROUP_GLOBAL;
            }
        }
        break;

        case 3:

        //
        // if there are 3 components then we must have parentid
        // WINNT_COMPUTER_ID
        //
        *pdwParentId = WINNT_COMPUTER_ID;

        hr = ValidateComputerParent(pObjectInfo->ComponentArray[0],
                                    pObjectInfo->ComponentArray[1],
                                    Credentials);

        BAIL_ON_FAILURE(hr);

        MakeUncName(
                pObjectInfo->ComponentArray[1],
                lpszUncName
                );

        hr = ValidateGlobalGroupObject(
                        lpszUncName,
                        &(pObjectInfo->ComponentArray[2]),
                        Credentials
                        );

        if (FAILED(hr)) {

            hr = ValidateLocalGroupObject(
                           lpszUncName,
                           &(pObjectInfo->ComponentArray[2]),
                           Credentials
                           );

            BAIL_ON_FAILURE(hr);
            uGroupType = WINNT_GROUP_LOCAL;

        }else{
            uGroupType = WINNT_GROUP_GLOBAL;
        }
        break;


    default:
        RRETURN(E_ADS_BAD_PATHNAME);
    }


error:
    if (lpGI) {
        NetApiBufferFree((LPBYTE)lpGI);
    }

    *puGroupType = uGroupType;
    RRETURN(hr);

}



HRESULT
ValidatePrinterObject(
    POBJECTINFO pObjectInfo,
    CWinNTCredentials& Credentials
    )
{
    LPTSTR szDomainName = NULL;
    LPTSTR szServerName = NULL;
    LPTSTR szPrinterName = NULL;
    WCHAR szPrintObjectName[MAX_PATH];
    HRESULT hr = E_ADS_UNKNOWN_OBJECT;
    BOOL fStatus = FALSE;
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE};

    if (!(pObjectInfo->NumComponents == 3 ||pObjectInfo->NumComponents == 2)){

        RRETURN(E_ADS_BAD_PATHNAME);
    }

    if(pObjectInfo->NumComponents == 3){
        //
        // printer in domain\computer or workgroup\computer
        //
        szDomainName = pObjectInfo->ComponentArray[0];
        szServerName = pObjectInfo->ComponentArray[1];
        szPrinterName = pObjectInfo->ComponentArray[2];

        hr = ValidateComputerParent(szDomainName,
                                    szServerName,
                                    Credentials);
        BAIL_IF_ERROR(hr);

    } else if ( pObjectInfo-> NumComponents == 2 ){

        szServerName = pObjectInfo->ComponentArray[0];
        szPrinterName = pObjectInfo->ComponentArray[1];
    }

    MakeUncName(szServerName, szPrintObjectName);
    wcscat(szPrintObjectName, TEXT("\\"));
    wcscat(szPrintObjectName, szPrinterName);


    //
    // validate the printer in computer now
    //

    fStatus = OpenPrinter(szPrintObjectName,
                          &hPrinter,
                          &PrinterDefaults);

    if(!fStatus){
        hr = HRESULT_FROM_WIN32(GetLastError());
    } else {
        hr = S_OK;
    }



cleanup:
    if(hPrinter){
        ClosePrinter(hPrinter);
    }
    RRETURN(hr);

}


HRESULT
ValidateServiceObject(
    POBJECTINFO pObjectInfo,
    CWinNTCredentials& Credentials
    )
{
    LPTSTR szDomainName = NULL;
    LPTSTR szServerName = NULL;
    LPTSTR szServiceName = NULL;
    SC_HANDLE schSCMHandle=NULL;
    SC_HANDLE schServiceHandle=NULL;
    HRESULT hr = S_OK;
    BOOLEAN fRefAdded = FALSE;

    if(!(pObjectInfo->NumComponents == 3 ||
         pObjectInfo->NumComponents == 2))
    {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    if(pObjectInfo->NumComponents == 3){

        szDomainName = pObjectInfo->ComponentArray[0];
        szServerName = pObjectInfo->ComponentArray[1];
        szServiceName = pObjectInfo->ComponentArray[2];

        //
        // First check to see if the computer is in the right domain
        //

        hr = ValidateComputerParent(
                 szDomainName,
                 szServerName,
                 Credentials
                 );
        BAIL_ON_FAILURE(hr);

    } else if (pObjectInfo->NumComponents == 2){
        szServerName = pObjectInfo->ComponentArray[0];
        szServiceName = pObjectInfo->ComponentArray[1];
    }

    //
    // check to see if the service is valid by opening the active services
    // database on the server
    //
    hr = Credentials.RefServer(szServerName);

    if (SUCCEEDED(hr)) {
        fRefAdded = TRUE;
    }

    //
    // Open the Service Control Manager.
    //

    schSCMHandle = OpenSCManager(szServerName,
                                 NULL,
                                 GENERIC_READ);

    if (schSCMHandle == NULL)  {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    //
    // Need to ref the server before opening the service
    //

    //
    // try to open the service
    //

    schServiceHandle = OpenService(schSCMHandle,
                                   szServiceName,
                                   GENERIC_READ);

    if(schServiceHandle == NULL)  {

        CloseServiceHandle(schSCMHandle);
        schSCMHandle = NULL;
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    CloseServiceHandle(schServiceHandle);
    CloseServiceHandle(schSCMHandle);

error:

    if (fRefAdded) {
        Credentials.DeRefServer();
        fRefAdded = FALSE;
    }
    RRETURN(hr);
}

HRESULT GetPrinterFromPath(LPTSTR *pszPrinter, LPWSTR szPathName)
{
    //
    // If passed an empty string, it returns an empty string
    //

    LPTSTR szRetval;

    *pszPrinter = NULL;
    szRetval = szPathName;

    ADsAssert(szPathName);

    while(!(*szRetval==L'\0' || *szRetval==L'\\')){
        szRetval++;
    }

    if(*szRetval != L'\\'){
        RRETURN(E_FAIL);
    }
    szRetval++;
    *pszPrinter = szRetval;
    RRETURN(S_OK);
}

HRESULT
ValidateComputerObject(
    POBJECTINFO pObjectInfo,
    CWinNTCredentials& Credentials)
{
    HRESULT hr;
    WCHAR szSAMName[MAX_PATH];

    szSAMName[0] = L'\0';

    if(!(pObjectInfo->NumComponents == 2 ||
         pObjectInfo->NumComponents == 1)){

        RRETURN(E_ADS_UNKNOWN_OBJECT);
    }

    if(pObjectInfo->NumComponents == 2){

        hr = ValidateComputerParent(
                 pObjectInfo->ComponentArray[0],
                 pObjectInfo->ComponentArray[1],
                 szSAMName,
                 Credentials
                 );
        BAIL_ON_FAILURE(hr);

        if (szSAMName[0] != L'\0') {
            FreeADsStr(pObjectInfo->ComponentArray[1]);
            pObjectInfo->ComponentArray[1] = AllocADsStr(szSAMName);
            if (!pObjectInfo->ComponentArray[1]) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }


    } else {

        hr = ValidateComputerParent(
                 NULL,
                 pObjectInfo->ComponentArray[0],
                 szSAMName,
                 Credentials
                 );
        BAIL_ON_FAILURE(hr);

        if (szSAMName[0] != L'\0') {
            FreeADsStr(pObjectInfo->ComponentArray[0]);
            pObjectInfo->ComponentArray[0] = AllocADsStr(szSAMName);
            if (!pObjectInfo->ComponentArray[0]) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }

    }

error:
    RRETURN(hr);

}


HRESULT
ValidateFileServiceObject(
    POBJECTINFO pObjectInfo,
    CWinNTCredentials& Credentials
    )
{

    HRESULT hr = S_OK;

    //
    // check to see if it is a valid service
    //

    if(!(pObjectInfo->NumComponents == 3 ||
         pObjectInfo->NumComponents == 2))
    {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = ValidateServiceObject(pObjectInfo, Credentials);

    if(FAILED(hr))
      RRETURN(hr);

    //
    // check to see if it is the LanmanServer or FPNW service
    //

    if (pObjectInfo->NumComponents ==3){

        if(!(_wcsicmp(pObjectInfo->ComponentArray[2],
                      TEXT("LanmanServer"))== 0
             || _wcsicmp(pObjectInfo->ComponentArray[2],TEXT("FPNW"))==0)){
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else if(pObjectInfo->NumComponents == 2) {

        if(!(_wcsicmp(pObjectInfo->ComponentArray[1],
                      TEXT("LanmanServer"))== 0
             || _wcsicmp(pObjectInfo->ComponentArray[1],TEXT("FPNW"))==0)){

            RRETURN(E_ADS_BAD_PATHNAME);
        }
    }

    RRETURN(hr);
}


HRESULT
ValidateFileShareObject(
    POBJECTINFO pObjectInfo,
    CWinNTCredentials& Credentials
    )
{

    NET_API_STATUS nasStatus;
    LPSHARE_INFO_1 lpShareInfo1 = NULL;
    PNWVOLUMEINFO  pVolumeInfo = NULL;
    LPTSTR         pszDomainName = NULL;
    LPTSTR         pszServerName = NULL;
    LPTSTR         pszShareName = NULL;
    LPTSTR         pszServerType = NULL;
    HRESULT        hr = S_OK;
    DWORD dwSharePos = 3;
    BOOL fRefAdded = FALSE;
    //
    // check to see if it is a valid file share
    //

    if (pObjectInfo->NumComponents == 4 ){
        pszDomainName = pObjectInfo->ComponentArray[0];
        pszServerName = pObjectInfo->ComponentArray[1];
        pszServerType = pObjectInfo->ComponentArray[2];
        pszShareName  = pObjectInfo->ComponentArray[3];
        dwSharePos = 3;

        hr = ValidateComputerParent(pszDomainName,
                                    pszServerName,
                                    Credentials);
        BAIL_ON_FAILURE(hr);

    }
    else if (pObjectInfo->NumComponents == 3 ){
        pszServerName = pObjectInfo->ComponentArray[0];
        pszServerType = pObjectInfo->ComponentArray[1];
        pszShareName  = pObjectInfo->ComponentArray[2];
        dwSharePos = 2;
    }
    else {
        hr = E_ADS_UNKNOWN_OBJECT;
        goto error;
    }

    if(_tcsicmp(pszServerType,TEXT("LanmanServer")) == 0){

        // Need to ref this server before we do the NetShareGetInfo
        // so that we can authenticate against the server.

        hr = Credentials.RefServer(pszServerName);
        if (SUCCEEDED(hr)) {
            fRefAdded = TRUE;
        }

        nasStatus = NetShareGetInfo(pszServerName,
                                    pszShareName,
                                    1,
                                    (LPBYTE*)&lpShareInfo1);

        // DeRef if ref added, no recovery possible on failed deref
        if (fRefAdded) {
            hr = Credentials.DeRefServer();
            fRefAdded = FALSE;
        }

        if(nasStatus != NERR_Success){
                hr = HRESULT_FROM_WIN32(nasStatus);
            goto error;
        }
        else {
            // Need to use the name returned by the call as opposed
            // to the name given in the ADsPath
            if (pObjectInfo->ComponentArray[dwSharePos]
                && lpShareInfo1->shi1_netname) {

                FreeADsStr(pObjectInfo->ComponentArray[dwSharePos]);
                pObjectInfo->ComponentArray[dwSharePos]
                    = AllocADsStr(lpShareInfo1->shi1_netname);
            }

            if (!pObjectInfo->ComponentArray[dwSharePos])
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            hr = S_OK;
            goto error;
        }
    }
    else if(_tcsicmp(pszServerType,TEXT("FPNW")) == 0){

        hr = Credentials.RefServer(pszServerName);
        if (SUCCEEDED(hr)) {
            fRefAdded = TRUE;
        }

        nasStatus = ADsNwVolumeGetInfo(pszServerName,
                                         pszShareName,
                                         1,
                                         &pVolumeInfo);

        // need to deref, nothing we can do if deref fails
        if (fRefAdded) {
            hr = Credentials.DeRefServer();
            fRefAdded = FALSE;
        }

        if(nasStatus != NERR_Success){
                hr = HRESULT_FROM_WIN32(nasStatus);
            goto error;
        }
        else{
            // Need to use the name returned by the call as opposed
            // to the name given in the ADsPath
            if (pObjectInfo->ComponentArray[dwSharePos]
                && pVolumeInfo->lpPath) {

                FreeADsStr(pObjectInfo->ComponentArray[dwSharePos]);
                pObjectInfo->ComponentArray[dwSharePos]
                    = AllocADsStr(pVolumeInfo->lpPath);
            }

            if (!pObjectInfo->ComponentArray[dwSharePos])
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            hr = S_OK;
            goto error;
        }
    } else {
        hr = E_ADS_UNKNOWN_OBJECT ;
    }

error:
    if(pVolumeInfo){
        ADsNwApiBufferFree(pVolumeInfo);
    }

    if(lpShareInfo1){
        NetApiBufferFree(lpShareInfo1);
    }

    RRETURN(hr);
}



HRESULT
ValidateNamespaceObject(
    POBJECTINFO pObjectInfo
    )
{
    if (!_wcsicmp(pObjectInfo->ProviderName, szProviderName)) {
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}


HRESULT
ValidateLocalGroupObject(
    LPWSTR szServerName,
    LPWSTR *pszGroupName,
    CWinNTCredentials& Credentials
    )

{
    NET_API_STATUS nasStatus;
    LPLOCALGROUP_INFO_1 lpGI = NULL;
    HRESULT hr = S_OK;
    BOOL fRefAdded = FALSE;

    // At this point the host server name has a \\ prepended
    // so we need to get rid of it.
    hr = Credentials.RefServer(szServerName+2);

    if (SUCCEEDED(hr)) {
        fRefAdded = TRUE;
    }

    nasStatus = NetLocalGroupGetInfo(
                    szServerName,
                    *pszGroupName,
                    1,
                    (LPBYTE*)(&lpGI)
                    );

    //
    // if a ref has been added we need to delete if before
    // checking the error status.
    //
    if (fRefAdded) {
        hr = Credentials.DeRefServer();
        // even if we fail, we have no recovery path
        fRefAdded = FALSE;
    }

    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

    // Need to use the name returned by the call as opposed
    // to the name given in the ADsPath
    if ((*pszGroupName) && lpGI->lgrpi1_name) {
        FreeADsStr(*pszGroupName);
        *pszGroupName = AllocADsStr(lpGI->lgrpi1_name);
    }

    if (!(*pszGroupName))
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

error:

    if (lpGI) {
        NetApiBufferFree(lpGI);
    }

    RRETURN(hr);
}


HRESULT
ValidateGlobalGroupObject(
    LPWSTR szServerName,
    LPWSTR *pszGroupName,
    CWinNTCredentials& Credentials
    )

{
    NET_API_STATUS nasStatus;
    LPGROUP_INFO_1 lpGI = NULL;
    HRESULT hr = S_OK;
    BOOL fRefAdded = FALSE;

    // At this point the host server name has a \\ prepended
    // so we need to get rid of it.
    hr = Credentials.RefServer(szServerName+2);

    if (SUCCEEDED(hr)) {
        fRefAdded = TRUE;
    }

    nasStatus = NetGroupGetInfo(
                    szServerName,
                    *pszGroupName,
                    1,
                    (LPBYTE*)(&lpGI)
                    );

    //
    // if a ref has been added we need to delete if before
    // checking the error status.
    //
    if (fRefAdded) {
        hr = Credentials.DeRefServer();
        // even if we fail, we have no recovery path
        fRefAdded = FALSE;
    }

    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

    // Need to use the name returned by the call as opposed
    // to the name given in the ADsPath
    if ((*pszGroupName) && lpGI->grpi1_name) {
        FreeADsStr(*pszGroupName);
        *pszGroupName = AllocADsStr(lpGI->grpi1_name);
    }

    if (!(*pszGroupName))
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

error:

    if (lpGI) {
        NetApiBufferFree(lpGI);
    }

    RRETURN(hr);
}


HRESULT
GetComputerParent(
    LPTSTR pszComputerName,
    LPTSTR *ppszComputerParentName,
    CWinNTCredentials& Credentials
    )

{
    //
    // This function returns the computer parent irrespective of whether
    // the computer belongs to a domain or to a workgroup
    //

    HRESULT hr = S_OK;
    LPTSTR pszComputerParentName = NULL;
    WCHAR szDomainName[MAX_PATH];
    WCHAR szSAMName[MAX_PATH];

    szSAMName[0] = L'\0';


    hr = WinNTGetCachedComputerName(pszComputerName,
                                    szDomainName,
                                    szSAMName,
                                    Credentials );

    BAIL_ON_FAILURE(hr);

    pszComputerParentName = AllocADsStr(szDomainName);

    if(!pszComputerParentName){
        hr = E_OUTOFMEMORY;
    }
    *ppszComputerParentName = pszComputerParentName;

error:
    RRETURN(hr);
}


HRESULT
ConstructFullObjectInfo(
    POBJECTINFO pObjectInfo,
    POBJECTINFO *ppFullObjectInfo,
    CWinNTCredentials& Credentials
    )
{

    //
    // used in the case where the domain name is not specified.
    // Here the assumption is that an objectinfo structure with
    // domain name not filled in is passed down. We create a new
    // object info structure with the domain/workgroup name filled
    // in


    HRESULT hr = S_OK;
    POBJECTINFO pTempObjectInfo = NULL;
    DWORD i;
    LPWSTR pszComputerParent = NULL;

    pTempObjectInfo = (POBJECTINFO)AllocADsMem(sizeof(OBJECTINFO));

    if (!pTempObjectInfo) {
        RRETURN(hr = E_OUTOFMEMORY);
    }

    memset(pTempObjectInfo, 0, sizeof(OBJECTINFO));

    if(!pObjectInfo){
        RRETURN(E_OUTOFMEMORY);
    }

    pTempObjectInfo->ProviderName = AllocADsStr(pObjectInfo->ProviderName);
        if(!pTempObjectInfo->ProviderName){
                hr = E_OUTOFMEMORY;
                goto error;
        }
    pTempObjectInfo->ObjectType = pObjectInfo->ObjectType;
    pTempObjectInfo->NumComponents = pObjectInfo->NumComponents +1;

    for(i=0; i<MAXCOMPONENTS-1; i++){
        if(pObjectInfo->ComponentArray[i]) {
            pTempObjectInfo->ComponentArray[i+1] =
                AllocADsStr(pObjectInfo->ComponentArray[i]);

            if(!pTempObjectInfo->ComponentArray[i+1]){
                hr = E_OUTOFMEMORY;
                goto error;
            }
        }
        if(pObjectInfo->DisplayComponentArray[i]) {
            pTempObjectInfo->DisplayComponentArray[i+1] =
                AllocADsStr(pObjectInfo->DisplayComponentArray[i]);

            if(!pTempObjectInfo->DisplayComponentArray[i+1]){
                hr = E_OUTOFMEMORY;
                goto error;
            }
        }
    }

    hr = GetComputerParent(pObjectInfo->ComponentArray[0],
                           &(pTempObjectInfo->ComponentArray[0]),
                           Credentials );

    BAIL_ON_FAILURE(hr);

    hr = GetDisplayName(pTempObjectInfo->ComponentArray[0],
                        &(pTempObjectInfo->DisplayComponentArray[0]) );

    *ppFullObjectInfo = pTempObjectInfo ;

    RRETURN(S_OK);

error:

    FreeObjectInfo( pTempObjectInfo );
    *ppFullObjectInfo = NULL;
    RRETURN(hr);

}



//+---------------------------------------------------------------------------
// Function:   GetGroupObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetLocalGroupObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPWSTR szServerName = NULL;
    LPWSTR szDomainName = NULL;
    LPWSTR szGroupName = NULL;
    DWORD  dwParentId = 0;
    ULONG uGroupType = 0;
    POBJECTINFO pGroupObjectInfo = NULL;

    hr = ValidateGroupObject(
                pObjectInfo,
                &uGroupType,
                &dwParentId,
                Credentials
                );
    BAIL_ON_FAILURE(hr);

    if (uGroupType !=  WINNT_GROUP_LOCAL) {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);

    }



    switch (pObjectInfo->NumComponents) {
    case 2:
        //
        // could be group in computer or group in domain
        //
        if(dwParentId == WINNT_DOMAIN_ID){

            szDomainName = pObjectInfo->ComponentArray[0];
            szGroupName = pObjectInfo->ComponentArray[1];
            szServerName = NULL;
            hr = BuildParent(pObjectInfo, ADsParent);
            BAIL_ON_FAILURE(hr);

        } else {

            //
            // group in a computer
            //

            hr = ConstructFullObjectInfo(pObjectInfo,
                                         &pGroupObjectInfo,
                                         Credentials );

            if (hr == HRESULT_FROM_WIN32(NERR_WkstaNotStarted)) {

                //
                // Case when there are no workstation services.
                //

                hr = BuildParent(pObjectInfo, ADsParent);
                BAIL_ON_FAILURE(hr);

                szDomainName = NULL;
                szServerName = pObjectInfo->ComponentArray[0];
                szGroupName = pObjectInfo->ComponentArray[1];

            } else {

                BAIL_ON_FAILURE(hr);

                hr = BuildParent(pGroupObjectInfo, ADsParent);
                BAIL_ON_FAILURE(hr);

                szDomainName =  pGroupObjectInfo->ComponentArray[0];
                szServerName =  pGroupObjectInfo->ComponentArray[1];
                szGroupName   =  pGroupObjectInfo->ComponentArray[2];

            }
        }

        break;

    case 3:

        hr = BuildParent(pObjectInfo, ADsParent);
        BAIL_ON_FAILURE(hr);

        szDomainName = pObjectInfo->ComponentArray[0];
        szServerName = pObjectInfo->ComponentArray[1];
        szGroupName = pObjectInfo->ComponentArray[2];
        break;

    }
    hr = CWinNTGroup::CreateGroup(ADsParent,
                            dwParentId,
                            szDomainName,
                            szServerName,
                            szGroupName,
                            uGroupType,
                            ADS_OBJECT_BOUND,
                            IID_IUnknown,
                            Credentials,
                            (void **)&pUnknown
                            );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    if(pGroupObjectInfo){
        FreeObjectInfo(pGroupObjectInfo);
    }

    RRETURN(hr);

error:
    if (pUnknown) {
        pUnknown->Release();
    }

    if(pGroupObjectInfo){
        FreeObjectInfo(pGroupObjectInfo);
    }

    *ppObject = NULL;

    RRETURN(hr);
}





//+---------------------------------------------------------------------------
// Function:   GetGroupObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetGlobalGroupObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPWSTR szServerName = NULL;
    LPWSTR szDomainName = NULL;
    LPWSTR szGroupName = NULL;
    DWORD  dwParentId = 0;
    ULONG uGroupType = 0;
    POBJECTINFO pGroupObjectInfo = NULL;

    hr = ValidateGroupObject(
                pObjectInfo,
                &uGroupType,
                &dwParentId,
                Credentials
                );
    BAIL_ON_FAILURE(hr);

    if (uGroupType != WINNT_GROUP_GLOBAL) {

        hr  = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }


    switch (pObjectInfo->NumComponents) {
    case 2:
        //
        // could be group in computer or group in domain
        //
        if(dwParentId == WINNT_DOMAIN_ID){

            szDomainName = pObjectInfo->ComponentArray[0];
            szGroupName = pObjectInfo->ComponentArray[1];
            szServerName = NULL;
            hr = BuildParent(pObjectInfo, ADsParent);
            BAIL_ON_FAILURE(hr);

        } else {

            //
            // group in a computer
            //

            hr = ConstructFullObjectInfo(pObjectInfo,
                                         &pGroupObjectInfo,
                                         Credentials );
            BAIL_ON_FAILURE(hr);

            hr = BuildParent(pGroupObjectInfo, ADsParent);
            BAIL_ON_FAILURE(hr);

            szDomainName =  pGroupObjectInfo->ComponentArray[0];
            szServerName =  pGroupObjectInfo->ComponentArray[1];
            szGroupName   =  pGroupObjectInfo->ComponentArray[2];

        }
        break;

    case 3:

        hr = BuildParent(pObjectInfo, ADsParent);
        BAIL_ON_FAILURE(hr);

        szDomainName = pObjectInfo->ComponentArray[0];
        szServerName = pObjectInfo->ComponentArray[1];
        szGroupName = pObjectInfo->ComponentArray[2];
        break;

    }
    hr = CWinNTGroup::CreateGroup(ADsParent,
                            dwParentId,
                            szDomainName,
                            szServerName,
                            szGroupName,
                            uGroupType,
                            ADS_OBJECT_BOUND,
                            IID_IUnknown,
                            Credentials,
                            (void **)&pUnknown
                            );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    if(pGroupObjectInfo){
        FreeObjectInfo(pGroupObjectInfo);
    }

    RRETURN(hr);

error:
    if (pUnknown) {
        pUnknown->Release();
    }

    if(pGroupObjectInfo){
        FreeObjectInfo(pGroupObjectInfo);
    }

    *ppObject = NULL;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\guid.c ===
#define INITGUID


#include <ole2.h>

//--------------------------------------------------------------------------
//
//  WinNT CLSIDs
//
//--------------------------------------------------------------------------

DEFINE_GUID(CLSID_WinNTNamespace,0x250E91A0L,0x0367,0x11CF,0xAB,0xC4,0x02,0x60,0x8C,0x9E,0x75,0x53);

DEFINE_GUID(CLSID_WinNTDomain,0x01544ED0L,0xFD16,0x11CE,0xAB,0xC4,0x02,0x60,0x8C,0x9E,0x75,0x53);

DEFINE_GUID(CLSID_WinNTProvider,0x8b20cd60L, 0x0f29, 0x11cf,0xAB,0xC4,0x02,0x60,0x8C,0x9E,0x75,0x53);

DEFINE_GUID(CLSID_WinNTUser,0xD83F1060L,0x1E71,0x11CF,0xB1,0xF3,0x02,0x60,0x8C,0x9E,0x75,0x53);

DEFINE_GUID(CLSID_WinNTGroup,0xD9C1AAD0L,0x1E71,0x11CF,0xB1,0xF3,0x02,0x60,0x8C,0x9E,0x75,0x53);

DEFINE_GUID(CLSID_WinNTComputer,0xDA438DC0L,0x1E71,0x11CF,0xB1,0xF3,0x02,0x60,0x8C,0x9E,0x75,0x53);

//------------------------------------------------------------------------
//  GUIDS that come out of winnt.tlb.
//------------------------------------------------------------------------

DEFINE_GUID(CLSID_WinNTFSPrintQueueGenInfo,0x0D1E2F60L,0x122B,0x11CF,0xA9,0x85,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(CLSID_WinNTFSPrintQueueDriverInfo,0x27BD67A0L,0x122B,0x11CF,0xA9,0x85,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(CLSID_WinNTPrintQueue,0xA6226AF0L,0x122B,0x11CF,0xA9,0x85,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(CLSID_WinNTFSPrintQueueOperation,0xA6227AF0L,0x122B,0x11CF,0xA9,0x85,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(CLSID_WinNTPrintJob, 0x06b7c9e0L, 0x5b4f, 0x11cf, 0xa9, 0x98, 0x00, 0xaa, 0x00, 0x6b, 0xc1, 0x49);

DEFINE_GUID(CLSID_WinNTService,0xC3968E50L,0x4C66,0x11CF,0xA9,0x95,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(CLSID_WinNTFileService,0xA75397A0L,0x4C81,0x11CF,0xA9,0x95,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(CLSID_WinNTSchema,0x6dc32210,0x4d19,0x11cf,0x9e,0x74,0x00,0xaa,0x00,0x4a,0x56,0x91);

DEFINE_GUID(CLSID_WinNTClass,0x6dc32211,0x4d19,0x11cf,0x9e,0x74,0x00,0xaa,0x00,0x4a,0x56,0x91);

DEFINE_GUID(CLSID_WinNTProperty,0x6dc32214,0x4d19,0x11cf,0x9e,0x74,0x00,0xaa,0x00,0x4a,0x56,0x91);

DEFINE_GUID(CLSID_WinNTSyntax,0x6dc32215,0x4d19,0x11cf,0x9e,0x74,0x00,0xaa,0x00,0x4a,0x56,0x91);

DEFINE_GUID(CLSID_WinNTSession,0x6dc32216,0x4d19,0x11cf,0x9e,0x74,0x00,0xaa,0x00,0x4a,0x56,0x91);

DEFINE_GUID(CLSID_WinNTResource,0x6dc32217,0x4d19,0x11cf,0x9e,0x74,0x00,0xaa,0x00,0x4a,0x56,0x91);

DEFINE_GUID(CLSID_WinNTFileShare,0x6dc32218,0x4d19,0x11cf,0x9e,0x74,0x00,0xaa,0x00,0x4a,0x56,0x91);

DEFINE_GUID(CLSID_FPNWFileService,0xA117D530L,0xA1EB,0x11CF,0xA9,0xA5,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(CLSID_FPNWSession,0xA819CB50L,0xA1EB,0x11CF,0xA9,0xA5,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(CLSID_FPNWFileShare,0xADF040B0L,0xA1EB,0x11CF,0xA9,0xA5,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(CLSID_FPNWResource,0xB381F2A0L,0xA1EB,0x11CF,0xA9,0xA5,0x00,0xAA,0x00,0x6B,0xC1,0x49);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\grputils.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumGroupCollection.cxx
//
//  Contents:  Windows NT 3.5 GroupCollection Enumeration Code
//
//
//
//
//
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

COMPUTER_GROUP_MEMBER CompMember;

//
// This assumes that addr is an LPBYTE type.
//
#define WORD_ALIGN_DOWN(addr) \
        addr = ((LPBYTE)((DWORD_PTR)addr & ~1))

DWORD ComputerGrpMemberStrings[]=

                             {
                             FIELD_OFFSET(COMPUTER_GROUP_MEMBER, Parent),
                             FIELD_OFFSET(COMPUTER_GROUP_MEMBER, Computer),
                             FIELD_OFFSET(COMPUTER_GROUP_MEMBER, Domain),
                             FIELD_OFFSET(COMPUTER_GROUP_MEMBER, Name),
                             0xFFFFFFFF
                             };


DECLARE_INFOLEVEL(GrpUt)
DECLARE_DEBUG(GrpUt)
#define GrpUtDebugOut(x) GrpUtInlineDebugOut x


BOOL
WinNTLocalGroupOpen(
    LPWSTR szDomainName,
    LPWSTR szComputerName,
    LPWSTR szGroupName,
    PHANDLE phGroup
    )
{

    WCHAR szTempBuffer[MAX_PATH];
    PINI_COMP_GROUP pIniCompGrp;
    HRESULT hr;


    if (!phGroup) {
        return(FALSE);
    }
    pIniCompGrp = (PINI_COMP_GROUP)AllocADsMem(
                                        sizeof(INI_COMP_GROUP)
                                        );
    if (!pIniCompGrp) {
        return(FALSE);
    }

    hr = MakeUncName(
            szComputerName,
            szTempBuffer
            );
    BAIL_ON_FAILURE(hr);

    if (!(pIniCompGrp->szUncCompName =  AllocADsStr(szTempBuffer))){
        goto error;
    }

    // to guard against the case of domainName == NULL for no
    // workstation services
    if (szDomainName != NULL) {
        if (!(pIniCompGrp->szDomainName = AllocADsStr(szDomainName))) {
            goto error;
        }
    }

    if (!(pIniCompGrp->szComputerName =  AllocADsStr(szComputerName))){
        goto error;
    }

    if (!(pIniCompGrp->szGroupName = AllocADsStr(szGroupName))){
        goto error;
    }


    *phGroup =  (HANDLE)pIniCompGrp;

    return(TRUE);


error:
    if (pIniCompGrp) {
        FreeIniCompGroup(pIniCompGrp);
    }

    *phGroup = NULL;

    return(FALSE);

}


BOOL
WinNTLocalGroupEnum(
    HANDLE hGroup,
    DWORD  dwRequested,
    LPBYTE * ppBuffer,
    PDWORD pdwReturned
    )
{

    LPCOMPUTER_GROUP_MEMBER * ppGroupMembers = NULL;
    DWORD i = 0;
    BOOL dwRet = FALSE;
    DWORD dwReturned = 0;
    DWORD dwSize = 0;
    LPCOMPUTER_GROUP_MEMBER pBuffer = NULL;
    LPBYTE pEnd = NULL;
    DWORD dwError;
    BOOL fretVal = FALSE;


    ppGroupMembers = (LPCOMPUTER_GROUP_MEMBER *)AllocADsMem(
                                sizeof(LPCOMPUTER_GROUP_MEMBER)* dwRequested
                                );
    if (!ppGroupMembers) {
        return(FALSE);
    }

    for (i = 0; i < dwRequested; i++) {

        dwRet = WinNTLocalGroupGetObject(
                        hGroup,
                        &ppGroupMembers[dwReturned]
                        );
        if (!dwRet) {

            dwError = GetLastError();
            if (dwError == ERROR_INVALID_SID) {
                continue;
            }

            //
            // it was not because of a bad sid
            // so break out, nothing more can be done
            //

            break;


        }

        dwReturned++;

    }

    dwRet = ComputeLocalGroupDataSize(
                    ppGroupMembers,
                    dwReturned,
                    &dwSize
                    );

    pBuffer = (LPCOMPUTER_GROUP_MEMBER)AllocADsMem(
                        dwSize
                        );

    if (pBuffer) {

        fretVal = TRUE;

        pEnd = (LPBYTE)((LPBYTE)(pBuffer) + dwSize);

        for (i = 0; i < dwReturned; i++) {

            pEnd = CopyIniCompGroupToCompGroup(
                            ppGroupMembers[i],
                            (LPBYTE)(pBuffer + i),
                            pEnd
                            );
        }
    }

    for (i = 0; i < dwReturned; i++ ) {
        FreeIntCompGroup(*(ppGroupMembers + i));
    }

    FreeADsMem(ppGroupMembers);

    //
    // Will correctl set to NULL if alloc failed.
    //
    *ppBuffer = (LPBYTE)pBuffer;
    *pdwReturned  = fretVal ? dwReturned : 0;

    if (!fretVal) {
        return(FALSE);
    }

    if (dwReturned == dwRequested){
        return(TRUE);
    }else {
        return(FALSE);
    }
}

BOOL
WinNTLocalGroupGetObject(
    HANDLE hGroup,
    LPCOMPUTER_GROUP_MEMBER * ppGroupMember
    )
{

    BOOL dwRet = FALSE;
    PINI_COMP_GROUP pIniCompGrp = (PINI_COMP_GROUP)hGroup;
    NET_API_STATUS nasStatus = 0;

    if ((!pIniCompGrp->_pBuffer) ||
        (pIniCompGrp->_dwCurrentObject == pIniCompGrp->_dwObjectReturned)) {

        if (pIniCompGrp->_bNoMore) {

            //
            // No more objects to return
            //
            return(FALSE);
        }

        if (pIniCompGrp->_pBuffer) {
            NetApiBufferFree(pIniCompGrp->_pBuffer);
            pIniCompGrp->_pBuffer = NULL;
        }

        pIniCompGrp->_dwObjectReturned = 0;
        pIniCompGrp->_dwCurrentObject = 0;
        pIniCompGrp->_dwTotalObjects = 0;

        nasStatus = NetLocalGroupGetMembers(
                            pIniCompGrp->szUncCompName,
                            pIniCompGrp->szGroupName,
                            2,
                            &pIniCompGrp->_pBuffer,
                            MAX_PREFERRED_LENGTH,
                            &pIniCompGrp->_dwObjectReturned,
                            &pIniCompGrp->_dwTotalObjects,
                            &pIniCompGrp->_dwResumeHandle
                            );
        if ((nasStatus != ERROR_SUCCESS) && (nasStatus != ERROR_MORE_DATA)){
            SetLastError(nasStatus);
            return(FALSE);
        }

        if (nasStatus != ERROR_MORE_DATA) {
            pIniCompGrp->_bNoMore = TRUE;
        }

        //
        // If there are no more objects to return,
        // return FALSE
        //
        if (!pIniCompGrp->_dwObjectReturned) {
            return(FALSE);
        }

    }

    while ( dwRet != TRUE &&
            (pIniCompGrp->_dwCurrentObject < pIniCompGrp->_dwTotalObjects))
     {

       dwRet = BuildLocalGroupMember(
                hGroup,
                (LPBYTE)((LPLOCALGROUP_MEMBERS_INFO_2)pIniCompGrp->_pBuffer
                                           + pIniCompGrp->_dwCurrentObject),
                 ppGroupMember
                );

       if (dwRet == FALSE) {
         if (GetLastError() == ERROR_INVALID_SID) {
           pIniCompGrp->_dwCurrentObject++;
           continue;
           //
           // proceed to the top of the while loop
           //
         }
         else
           goto error;
       }
    }
    //
    // the while loop
    //
    if (dwRet == FALSE)
       goto error;

    pIniCompGrp->_dwCurrentObject++;

    return(TRUE);

error:

    return(FALSE);
}


BOOL
WinNTLocalGroupClose(
    HANDLE hGroup
    )
{

    PINI_COMP_GROUP pIniCompGrp = (PINI_COMP_GROUP)hGroup;

    if (pIniCompGrp) {
        FreeIniCompGroup(pIniCompGrp);
    }
    return(TRUE);
}

void
FreeIniCompGroup(
    PINI_COMP_GROUP pIniCompGrp
    )
{
    if (pIniCompGrp->szDomainName) {

        FreeADsStr(pIniCompGrp->szDomainName);
    }

    if (pIniCompGrp->szComputerName) {

        FreeADsStr(pIniCompGrp->szComputerName);
    }


    if (pIniCompGrp->szGroupName) {

        FreeADsStr(pIniCompGrp->szGroupName);
    }

    if (pIniCompGrp->szUncCompName) {

        FreeADsStr(pIniCompGrp->szUncCompName);
    }


    if (pIniCompGrp->_pBuffer) {

        NetApiBufferFree(pIniCompGrp->_pBuffer);
    }


    if (pIniCompGrp) {

       FreeADsMem(pIniCompGrp);
    }

   return;
}

void
FreeIntCompGroup(
    LPCOMPUTER_GROUP_MEMBER pCompGroupMember
    )
{
    if (pCompGroupMember->Parent) {

        FreeADsMem(pCompGroupMember->Parent);

    }


    if (pCompGroupMember->Computer) {

        FreeADsStr(pCompGroupMember->Computer);
    }


    if (pCompGroupMember->Domain) {

        FreeADsStr(pCompGroupMember->Domain);

    }


    if (pCompGroupMember->Name) {

        FreeADsStr(pCompGroupMember->Name);
    }


    if (pCompGroupMember->Sid) {

        FreeADsMem(pCompGroupMember->Sid);
    }


    FreeADsMem(pCompGroupMember);


}



BOOL
ComputeLocalGroupDataSize(
        LPCOMPUTER_GROUP_MEMBER * ppGroupMembers,
        DWORD  dwReturned,
        PDWORD pdwSize
        )
{

    DWORD i = 0;
    DWORD cb = 0;
    LPCOMPUTER_GROUP_MEMBER pMember = NULL;

    for (i = 0; i < dwReturned; i++) {

        pMember = *(ppGroupMembers + i);

        cb += sizeof(COMPUTER_GROUP_MEMBER);

        if (pMember->Parent) {
            cb += wcslen(pMember->Parent)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Computer) {
            cb += wcslen(pMember->Computer)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Domain) {
            cb += wcslen(pMember->Domain)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Name) {
            cb += wcslen(pMember->Name)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Sid) {
            cb += GetLengthSid(pMember->Sid);
        }
    }

    *pdwSize = cb;
    return(TRUE);
}


LPBYTE
CopyIniCompGroupToCompGroup(
    LPCOMPUTER_GROUP_MEMBER  pIntCompGrp,
    LPBYTE  pExtCompGrp,
    LPBYTE  pEnd
    )
{
    LPWSTR   SourceStrings[sizeof(COMPUTER_GROUP_MEMBER)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings=SourceStrings;
    LPCOMPUTER_GROUP_MEMBER pCompGrpMember = (LPCOMPUTER_GROUP_MEMBER)pExtCompGrp;
    DWORD dwSidLength = 0;

    memset(SourceStrings, 0, sizeof(COMPUTER_GROUP_MEMBER));
    *pSourceStrings++ = pIntCompGrp->Parent;
    *pSourceStrings++ = pIntCompGrp->Computer;
    *pSourceStrings++ = pIntCompGrp->Domain;
    *pSourceStrings++ = pIntCompGrp->Name;

    pEnd = PackStrings(
                SourceStrings,
                pExtCompGrp,
                ComputerGrpMemberStrings,
                pEnd
                );

    pCompGrpMember->Type = pIntCompGrp->Type;
    pCompGrpMember->ParentType = pIntCompGrp->ParentType;

    if (pIntCompGrp->Sid) {
        dwSidLength = GetLengthSid(pIntCompGrp->Sid);

        pEnd -= dwSidLength;

        memcpy(pEnd,
               pIntCompGrp->Sid,
               dwSidLength
               );
               
        pCompGrpMember->Sid = pEnd;
               
    }

    return pEnd;
}


BOOL
BuildLocalGroupMember(
    HANDLE hGroup,
    LPBYTE lpBuffer,
    LPCOMPUTER_GROUP_MEMBER * ppGroupMember
    )
{
    LPINI_COMP_GROUP pGroup = (LPINI_COMP_GROUP)hGroup;
    LPCOMPUTER_GROUP_MEMBER pGroupMember = NULL;
    LPLOCALGROUP_MEMBERS_INFO_2 pGrpMem = (LPLOCALGROUP_MEMBERS_INFO_2)lpBuffer;
    WCHAR szADsParent[MAX_PATH];
    LPWSTR pMemberName = NULL;
    LPWSTR pszSIDName = NULL;
    DWORD cblen = 0, dwLen = 0, dwLenDomAndName = 0;
    DWORD dwSidType = 0;
    DWORD dwSidLength = 0;
    BOOL fRet = FALSE;
    BOOL fError = FALSE;

    pGroupMember = (LPCOMPUTER_GROUP_MEMBER)AllocADsMem(
                                       sizeof(COMPUTER_GROUP_MEMBER)
                                       );
    if (!pGroupMember) {

        goto error;
    }

    dwSidType = pGrpMem->lgrmi2_sidusage;

    pMemberName = wcschr(pGrpMem->lgrmi2_domainandname, L'\\');

    cblen = wcslen(pGroup->szComputerName);

    //
    // Check to see if the lengthe of the domain name component in
    // lgrmi2_domainandname and the comptuername are the same if not
    // it cannot be a computer member object. We do this to catch the case
    // where foo.foodom is computer name. foodom\user will incorrectly
    // be identified as a local user rather than domain user
    //
    if (pMemberName) {
        *pMemberName = L'\0';
        dwLenDomAndName = wcslen(pGrpMem->lgrmi2_domainandname);
        *pMemberName = L'\\';
    }
    else {
        dwLenDomAndName = cblen;
    }


    if ((dwLenDomAndName == cblen) && !_wcsnicmp(pGroup->szComputerName, pGrpMem->lgrmi2_domainandname, cblen)) {

        //
        // This is the local user case
        //

      if (pMemberName) {

            pMemberName++;
        }
        else {

            pMemberName = pGrpMem->lgrmi2_domainandname ;
        }

        pGroupMember->Name = AllocADsStr(pMemberName);
        pGroupMember->Computer = AllocADsStr(pGroup->szComputerName);
        pGroupMember->Domain = AllocADsStr(pGroup->szDomainName);

        if (pGroupMember->Domain != NULL) {

            wsprintf(
                szADsParent,
                L"%s://%s/%s",
                szProviderName,
                pGroup->szDomainName,
                pGroup->szComputerName
                );

        } else {

            // Again we may have a null domain name for the case
            // where there are no workstations services
            wsprintf(
                szADsParent,
                L"%s://%s",
                szProviderName,
                pGroup->szComputerName
                );
        }

        pGroupMember->Parent = AllocADsStr(szADsParent);
        pGroupMember->ParentType = WINNT_COMPUTER_ID;
        //
        // Need to look at SID to see if this is a local group
        // in which case the sid will be alias.
        //

        if (dwSidType == SidTypeAlias) {
            pGroupMember->Type = WINNT_LOCALGROUP_ID;
        }
        else if (dwSidType == SidTypeUser) {
            pGroupMember->Type = WINNT_USER_ID;
        } else  {
            //
            // Unknown ??
            //
            SetLastError(ERROR_INVALID_SID);
            BAIL_ON_FAILURE(E_FAIL);

        }


    }else {

        //
        // This is the domain user, domain group case
        //

        pMemberName = wcschr(pGrpMem->lgrmi2_domainandname, L'\\');

        if (pMemberName) {

                *pMemberName = L'\0';
                pMemberName++;
                pGroupMember->Domain = AllocADsStr(pGrpMem->lgrmi2_domainandname);
                pGroupMember->Computer = NULL;


                wsprintf(
                    szADsParent,
                    L"%s://%s",
                    szProviderName,
                    pGrpMem->lgrmi2_domainandname
                    );
        }
        else {

            //
            // if name is well name like 'EveryOne' without the domain prefix,
            // we end up with using the local computer name
            //
            pMemberName = pGrpMem->lgrmi2_domainandname ;
            pGroupMember->Domain = NULL;
            pGroupMember->Computer = AllocADsStr(L"") ;

            wsprintf(
                szADsParent,
                L"WinNT:"
                );
        }

        pGroupMember->Name = AllocADsStr(pMemberName);


        pGroupMember->Parent = AllocADsStr(szADsParent);

        switch (dwSidType) {
        case SidTypeUser:
            pGroupMember->Type = WINNT_USER_ID;
            break;

        case SidTypeGroup:
        case SidTypeWellKnownGroup :
        case SidTypeAlias :
            pGroupMember->Type = WINNT_GROUP_ID;
            break;

        case SidTypeUnknown:
        case SidTypeDeletedAccount:

#if !defined(WIN95)
            //
            // In this case we want to use the stringized SID.
            // We use functions in sddl.h.
            //
            fRet = ConvertSidToStringSidWrapper(
                        pGrpMem->lgrmi2_sid,
                        &pszSIDName
                        );

            if (!fRet || !pszSIDName) {
                //
                // Not much we can do here
                //
                SetLastError(ERROR_INVALID_SID);
                fError = TRUE;
            } else {
                //
                // We are always going to return just the SID.
                //
                if (pGroupMember->Name) {
                    FreeADsStr(pGroupMember->Name);
                    pGroupMember->Name = NULL;
                }

                if (pGroupMember->Parent) {
                    FreeADsStr(pGroupMember->Parent);
                    pGroupMember->Parent = NULL;
                }

                if (pGroupMember->Domain) {
                    FreeADsStr(pGroupMember->Domain);
                    pGroupMember->Domain = NULL;
                }

                //
                // Got be either user so default to user.
                //
                pGroupMember->Type = WINNT_USER_ID;

                pGroupMember->Name = AllocADsStr(pszSIDName);
                pGroupMember->Parent = AllocADsStr(L"WinNT:");
                if (!pGroupMember->Name || ! pGroupMember->Parent) {
                    //
                    // Not enough mem - rather than ignore like we do
                    // in the rest of the places in this fn, will
                    // set the last error and hope we recover.
                    //
                    SetLastError(ERROR_INVALID_SID);
                    fError = TRUE;
                }
            }
#else
            SetLastError(ERROR_INVALID_SID);
            fError = TRUE;
#endif
            if (pszSIDName) {
                LocalFree(pszSIDName);
            }
            if (fError)
                goto error;
            break;

        default:
            SetLastError(ERROR_INVALID_SID);
            goto error;
            break;

        }

        //
        // Need to special case this as we cannot have a domain
        // name that is NULL.
        //
        if (dwSidType == SidTypeDeletedAccount
            || dwSidType == SidTypeUnknown) {
            pGroupMember->ParentType = WINNT_COMPUTER_ID;
        }
        else {
            pGroupMember->ParentType = WINNT_DOMAIN_ID;
        }

    }

    //
    // Copy the SID
    //
    if (pGrpMem->lgrmi2_sid) {

        //
        // On NT4 for some reason GetLengthSID does not set lasterror to 0
        //
        SetLastError(NO_ERROR);

        dwSidLength = GetLengthSid(pGrpMem->lgrmi2_sid);

        //
        // This is an extra check to make sure that we have the
        // correct length.
        //
        if (GetLastError() != NO_ERROR) {
            SetLastError(ERROR_INVALID_SID);
            BAIL_ON_FAILURE(E_FAIL);        
        }

        pGroupMember->Sid = AllocADsMem(dwSidLength);
        if (!pGroupMember->Sid) {
            SetLastError(ERROR_OUTOFMEMORY);
            BAIL_ON_FAILURE(E_OUTOFMEMORY);
        }

        memcpy(pGroupMember->Sid, pGrpMem->lgrmi2_sid, dwSidLength);
    }

    *ppGroupMember =  pGroupMember;
    return(TRUE);

error:

    if (pGroupMember) {

        FreeIntCompGroup(pGroupMember);
    }

    *ppGroupMember = NULL;
    return(FALSE);

}


LPBYTE
PackStrings(
    LPWSTR *pSource,
    LPBYTE pDest,
    DWORD *DestOffsets,
    LPBYTE pEnd
    )
{
    DWORD cbStr;
    WORD_ALIGN_DOWN(pEnd);

    while (*DestOffsets != -1) {
        if (*pSource) {
            cbStr = wcslen(*pSource)*sizeof(WCHAR) + sizeof(WCHAR);
            pEnd -= cbStr;
            CopyMemory( pEnd, *pSource, cbStr);
            *(LPWSTR *)(pDest+*DestOffsets) = (LPWSTR)pEnd;
        } else {
            *(LPWSTR *)(pDest+*DestOffsets)=0;
        }
        pSource++;
        DestOffsets++;
    }
    return pEnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\macro.h ===
#define BAIL_IF_ERROR(hr) \
        if (FAILED(hr)) {       \
                goto cleanup;   \
        }\

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\


#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}




#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                    \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                          \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)    \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(GetInfo());                                               \
}





#define DEFINE_IADs_TempImplementation(cls)                           \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(GetInfo());                                               \
}





#define DEFINE_IADs_PutGetImplementation(cls, SchemaClassTable, dwTableSize)                   \
STDMETHODIMP                                                          \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                    \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = GenericGetPropertyManager(                                   \
                _pPropertyCache,                                      \
                bstrName,                                             \
                pvProp                                                \
                );                                                    \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                          \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = GenericPutPropertyManager(                                   \
                _pPropertyCache,                                      \
                SchemaClassTable,                                     \
                dwTableSize,                                          \
                bstrName,                                             \
                vProp                                                 \
                );                                                    \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                  \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = GenericGetExPropertyManager(                                 \
                GetObjectState(),                                     \
                _pPropertyCache,                                      \
                bstrName,                                             \
                pvProp                                                \
                );                                                    \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)    \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = GenericPutExPropertyManager(                                 \
                _pPropertyCache,                                      \
                SchemaClassTable,                                     \
                dwTableSize,                                          \
                bstrName,                                             \
                vProp                                                 \
                );                                                    \
                                                                      \
    RRETURN(hr);                                                      \
}

#define DEFINE_IADsPropertyList_Implementation(cls, SchemaClassTable, dwTableSize)                 \
STDMETHODIMP                                                                                       \
cls::get_PropertyCount(THIS_ long  FAR * plCount)                                                  \
{                                                                                                  \
    HRESULT hr = E_FAIL;                                                                           \
                                                                                                   \
    hr = GenericPropCountPropertyManager(                                                          \
                _pPropertyCache,                                                                   \
                plCount                                                                            \
                );                                                                                 \
                                                                                                   \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
                                                                                                   \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::Next(THIS_ VARIANT FAR *pVariant)                                                             \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericNextPropertyManager(                                                               \
                    _pPropertyCache,                                                               \
                    pVariant                                                                       \
                    );                                                                             \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
                                                                                                   \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::Skip(THIS_ long cElements)                                                                   \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
                                                                                                   \
    hr = GenericSkipPropertyManager(                                                               \
                    _pPropertyCache,                                                               \
                    cElements                                                                      \
                    );                                                                             \
                                                                                                   \
    RRETURN(hr);                                                                                   \
                                                                                                   \
}                                                                                                  \
                                                                                                   \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::Reset()                                                                                       \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericResetPropertyManager(                                                              \
                _pPropertyCache                                                                    \
                );                                                                                 \
                                                                                                   \
    RRETURN(hr);                                                                                   \
                                                                                                   \
}                                                                                                  \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::ResetPropertyItem(THIS_ VARIANT varEntry)                                                                \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericDeletePropertyManager(                                                             \
                    _pPropertyCache,                                                               \
                    varEntry                                                                       \
                    );                                                                             \
                                                                                                   \
    RRETURN(hr);                                                                                   \
                                                                                                   \
}                                                                                                  \
STDMETHODIMP                                                                                       \
cls::GetPropertyItem(THIS_ BSTR bstrName, LONG lnADsType, VARIANT * pVariant)                      \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericGetPropItemPropertyManager(                                                        \
                _pPropertyCache,                                                                   \
                GetObjectState(),                                                                  \
                bstrName,                                                                          \
                lnADsType,                                                                         \
                pVariant                                                                           \
                );                                                                                 \
                                                                                                   \
                                                                                                   \
    RRETURN(hr);                                                                                   \
                                                                                                   \
}                                                                                                  \
STDMETHODIMP                                                                                       \
cls::PutPropertyItem(VARIANT varData)                     \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericPutPropItemPropertyManager(                                                        \
                _pPropertyCache,                                                                   \
                SchemaClassTable,                                                                  \
                dwTableSize,                                                                       \
                varData                                                                            \
                );                                                                                 \
                                                                                                   \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::PurgePropertyList(THIS_)                                                                      \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericPurgePropertyManager(                                                              \
                _pPropertyCache                                                                    \
                );                                                                                 \
                                                                                                   \
                                                                                                   \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
STDMETHODIMP                                                                                       \
cls::Item(THIS_ VARIANT varIndex, VARIANT * pVariant)                                              \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericItemPropertyManager(                                                               \
                _pPropertyCache,                                                                   \
                GetObjectState(),                                                                  \
                varIndex,                                                                          \
                pVariant                                                                           \
                );                                                                                 \
                                                                                                   \
                                                                                                   \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
                                                                                                   \



#define DEFINE_IDispatch_ExtMgr_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        if(_pDispatch != NULL) {                                      \
            RRETURN(_pDispatch->GetTypeInfoCount(pctinfo));           \
        }                                                             \
        RRETURN(_pExtMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        if(_pDispatch != NULL) {                                      \
            RRETURN(_pDispatch->GetTypeInfo(itinfo,                   \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
        }                                                             \
        RRETURN(_pExtMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        if(_pDispatch != NULL) {                                      \
            RRETURN(_pDispatch->GetIDsOfNames(iid,                    \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
        }                                                             \
        RRETURN(_pExtMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        if(_pDispatch != NULL) {                                      \
            RRETURN(_pDispatch->Invoke(dispidMember,                  \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
        }                                                             \
        RRETURN (_pExtMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}

#define DEFINE_IADsExtension_ExtMgr_Implementation(cls)               \
HRESULT STDMETHODCALLTYPE                                             \
cls::Operate(                                                         \
    DWORD dwCode, VARIANT varData1, VARIANT varData2,                 \
    VARIANT varData3)                                                 \
{                                                                     \
    RRETURN(S_OK);                                                    \
}                                                                     \
                                                                      \
HRESULT STDMETHODCALLTYPE                                             \
cls::PrivateGetIDsOfNames(                                            \
    REFIID riid, OLECHAR FAR* FAR* rgszNames, unsigned int cNames,    \
    LCID lcid, DISPID FAR* rgdispid)                                  \
{                                                                     \
        RRETURN(_pExtMgr->GetIDsOfNames(riid,                        \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
HRESULT STDMETHODCALLTYPE                                             \
cls::PrivateInvoke(                                                   \
    DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,         \
    DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult,             \
    EXCEPINFO FAR* pexcepinfo, unsigned int FAR* puArgErr)            \
{                                                                     \
        RRETURN (_pExtMgr->Invoke(dispidMember,                      \
                                   riid,                              \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}


#define DEFINE_IADsExtension_Implementation(cls)                      \
HRESULT STDMETHODCALLTYPE                                             \
cls::Operate(                                                         \
    DWORD dwCode, VARIANT varData1, VARIANT varData2,                 \
    VARIANT varData3)                                                 \
{                                                                     \
    RRETURN(S_OK);                                                    \
}                                                                     \
                                                                      \
HRESULT STDMETHODCALLTYPE                                             \
cls::PrivateGetIDsOfNames(                                            \
    REFIID riid, OLECHAR FAR* FAR* rgszNames, unsigned int cNames,    \
    LCID lcid, DISPID FAR* rgdispid)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(riid,                        \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
HRESULT STDMETHODCALLTYPE                                             \
cls::PrivateInvoke(                                                   \
    DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,         \
    DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult,             \
    EXCEPINFO FAR* pexcepinfo, unsigned int FAR* puArgErr)            \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   riid,                              \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}    


#define DEFINE_IDispatch_Delegating_Implementation(cls)               \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        if(_pDispatch != NULL) {                                      \
            RRETURN(_pDispatch->GetTypeInfoCount(pctinfo));           \
        }                                                             \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        if(_pDispatch != NULL) {                                      \
            RRETURN(_pDispatch->GetTypeInfo(itinfo,                   \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
        }                                                             \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        if(_pDispatch != NULL) {                                      \
            RRETURN(_pDispatch->GetIDsOfNames(iid,                    \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
        }                                                             \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        if(_pDispatch != NULL) {                                      \
            RRETURN(_pDispatch->Invoke(dispidMember,                  \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
        }                                                             \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\guid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       guid.h
//
//  Contents:   extern references for WinNT guids
//
//  History:    16-Jan-95   KrishnaG
//
//
//----------------------------------------------------------------------------

#ifndef __GUID_H__
#define __GUID_H__

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------
//
// WinNTOle CLSIDs
//
//-------------------------------------------


//
// WinNTOle objects
//

extern const CLSID CLSID_WinNTPrinter;

// uuids from winnt.tlb

extern const CLSID CLSID_WinNTDomain;

extern const CLSID CLSID_WinNTProvider;

extern const CLSID CLSID_WinNTNamespace;

extern const CLSID CLSID_WinNTUser;

extern const CLSID CLSID_WinNTComputer;

extern const CLSID CLSID_WinNTGroup;

extern const GUID LIBID_ADs;

extern const GUID CLSID_WinNTPrintQueue;

extern const GUID CLSID_WinNTPrintJob;

extern const GUID CLSID_WinNTService;
extern const GUID CLSID_WinNTFileService;

extern const GUID CLSID_WinNTSession;
extern const GUID CLSID_WinNTResource;
extern const GUID CLSID_WinNTFileShare;

extern const GUID CLSID_FPNWFileService;
extern const GUID CLSID_FPNWSession;
extern const GUID CLSID_FPNWResource;
extern const GUID CLSID_FPNWFileShare;

extern const GUID CLSID_WinNTSchema;
extern const GUID CLSID_WinNTClass;
extern const GUID CLSID_WinNTProperty;
extern const GUID CLSID_WinNTSyntax;

extern const GUID ADS_LIBIID_ADs;

// uuids from netole.tlb

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\nt2ods.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       nw2ods.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma  hdrstop


HRESULT
NTTypeToAdsTypeCopyString(
    PNTOBJECT lpNtSrcObject,
    PADSVALUE lpAdsDestValue
    )

{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_CASE_IGNORE_STRING;

    lpAdsDestValue->DNString  =
                        AllocADsStr(
                                lpNtSrcObject->NTValue.pszValue
                                );
    RRETURN(hr);
}



HRESULT
NTTypeToAdsTypeCopyBoolean(
    PNTOBJECT lpNtSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_BOOLEAN;

    lpAdsDestValue->Boolean =
                        lpNtSrcObject->NTValue.fValue;

    RRETURN(hr);
}


HRESULT
NTTypeToAdsTypeCopyInteger(
    PNTOBJECT lpNtSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_INTEGER;

    lpAdsDestValue->Integer =
                        lpNtSrcObject->NTValue.dwValue;

    RRETURN(hr);

}


HRESULT
NTTypeToAdsTypeCopyOctetString(
    PNTOBJECT lpNtSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwLen = 0;

    lpAdsDestValue->dwType = ADSTYPE_OCTET_STRING;

    dwLen = lpNtSrcObject->NTValue.octetstring.dwSize;

    lpAdsDestValue->OctetString.dwLength = dwLen;

    if (lpNtSrcObject->NTValue.octetstring.pByte) {

        lpAdsDestValue->OctetString.lpValue = (LPBYTE) AllocADsMem(dwLen);

        if (!lpAdsDestValue->OctetString.lpValue) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        memcpy(
            lpAdsDestValue->OctetString.lpValue,
            lpNtSrcObject->NTValue.octetstring.pByte,
            dwLen
            );
    }
    else {
        lpAdsDestValue->OctetString.lpValue = NULL;
    }

error:

    RRETURN(hr);

}

HRESULT
NTTypeToAdsTypeCopy(
    PNTOBJECT lpNtSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    switch (lpNtSrcObject->NTType) {

    case NT_SYNTAX_ID_BOOL:
        hr = NTTypeToAdsTypeCopyBoolean(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;

    case NT_SYNTAX_ID_DWORD:
        hr = NTTypeToAdsTypeCopyInteger(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;

    case NT_SYNTAX_ID_LPTSTR:
        hr = NTTypeToAdsTypeCopyString(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;
        
    case NT_SYNTAX_ID_DelimitedString:
        hr = NTTypeToAdsTypeCopyString(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;

    case NT_SYNTAX_ID_OCTETSTRING:
        hr = NTTypeToAdsTypeCopyOctetString(
                 lpNtSrcObject,
                 lpAdsDestValue
                 );
        break;
    /*
    case NT_SYNTAX_ID_SYSTEMTIME:
    case NT_SYNTAX_ID_DATE:
    case NT_SYNTAX_ID_NW312TIME:
        hr = NTTypeToAdsTypeCopyNDSSynId4(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;

    case NT_SYNTAX_ID_NulledString:
        hr = NTTypeToAdsTypeCopyNDSSynId5(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;
    */

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
NTTypeToAdsTypeCopyConstruct(
    LPNTOBJECT pNtSrcObjects,
    DWORD dwNumObjects,
    LPADSVALUE * ppAdsDestValues
    )
{

    DWORD i = 0;
    LPADSVALUE pAdsDestValues = NULL;
    HRESULT hr = S_OK;

    if (!dwNumObjects) {
        *ppAdsDestValues = NULL;
        RRETURN(S_OK);
    }

    pAdsDestValues = (LPADSVALUE)AllocADsMem(
                                    dwNumObjects * sizeof(ADSVALUE)
                                    );

    if (!pAdsDestValues) {
        RRETURN(E_OUTOFMEMORY);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = NTTypeToAdsTypeCopy(
                    pNtSrcObjects + i,
                    pAdsDestValues + i
                    );
         BAIL_ON_FAILURE(hr);

     }

     *ppAdsDestValues = pAdsDestValues;

     RRETURN(S_OK);

error:

     if (pAdsDestValues) {
        AdsFreeAdsValues(
            pAdsDestValues,
            dwNumObjects
            );
        FreeADsMem(pAdsDestValues);
     }

     *ppAdsDestValues = NULL;

     RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\nt2umi.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     nt2umi.cxx
//
//  Contents: Contains the routines to convert from NT objects to
//            UMI_PROPERTY structures.
//
//  History:  02-29-00    SivaramR  Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"

//----------------------------------------------------------------------------
// Function:   WinNTTypeToUmiIntegers
//
// Synopsis:   Converts from NT object to UMI_PROPERTY structure containing
//             one of the signed/unsigned integers (1, 2, 4 or 8 bytes each).
//
// Arguments:
//
// pNtObject     Pointer to NT object
// dwNumValues   Number of values in pNtObject
// pPropArray    Pointer to UMI_PROPERTY that returns the converted values
// pExistingMem  If non-NULL, the provider does not allocate memory. Instead,
//               the memory pointed to by this argument is used.
// dwMemSize     Number of bytes of memory pointed to by pExistingMem
// UmiType       UMI type to convert the NT object to
//
// Returns:      UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:     *pExistingMem if pExistingMem is non-NULL
//               *pPropArray otherwise
//
//----------------------------------------------------------------------------
HRESULT WinNTTypeToUmiIntegers(
    LPNTOBJECT pNtObject,
    DWORD dwNumValues,
    UMI_PROPERTY *pPropArray,
    LPVOID pExistingMem,
    DWORD dwMemSize,
    UMI_TYPE UmiType
    )
{
    DWORD   dwSize = 0, dwMemRequired = 0, dwNtValue = 0, i = 0;
    void    *pIntArray = NULL;
    HRESULT hr = UMI_S_NO_ERROR;

    // Check if the NT type can be converted to the requested UMI type
    if(pNtObject->NTType != NT_SYNTAX_ID_DWORD)
        BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

    switch(UmiType) {

        case UMI_TYPE_I1:
        case UMI_TYPE_UI1:
            dwSize = 1;
            break;

        case UMI_TYPE_I2:
        case UMI_TYPE_UI2:
            dwSize = 2;
            break;

        case UMI_TYPE_I4:
        case UMI_TYPE_UI4:
            dwSize = 4;
            break;

        case UMI_TYPE_I8:
        case UMI_TYPE_UI8:
            dwSize = 8;
            break;

        default:
            BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);
    }

    dwMemRequired = dwNumValues * dwSize;

    if(NULL == pExistingMem) {
    // provider has to allocate memory
        pIntArray = (void *) AllocADsMem(dwMemRequired);
        if(NULL == pIntArray)
            BAIL_ON_FAILURE(UMI_E_OUT_OF_MEMORY);
    }
    else {
    // user provided memory to return data
        if(dwMemSize < dwMemRequired)
            BAIL_ON_FAILURE(hr = UMI_E_INSUFFICIENT_MEMORY);

        pIntArray = pExistingMem;
    }

    for(i = 0; i < dwNumValues; i++) {
        dwNtValue = pNtObject[i].NTValue.dwValue;

        switch(UmiType) {

            case UMI_TYPE_I1:
            case UMI_TYPE_UI1:
                *((CHAR *)(pIntArray) + i) = (CHAR) dwNtValue;
                break;

            case UMI_TYPE_I2:
            case UMI_TYPE_UI2:
                *((WCHAR *)(pIntArray) + i) = (WCHAR) dwNtValue;
                break;

            case UMI_TYPE_I4:
            case UMI_TYPE_UI4:
                *((DWORD *)(pIntArray) + i) = dwNtValue;
                break;

            case UMI_TYPE_I8:
            case UMI_TYPE_UI8:
                *((__int64 *)(pIntArray) + i) = (__int64) dwNtValue;
                break;

            default:
                BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);
        } // switch
    } // for

    if(pPropArray != NULL)
        pPropArray->pUmiValue = (UMI_VALUE *) pIntArray;

    RRETURN(hr);

error:
   
    if( (pIntArray != NULL) && (NULL == pExistingMem) )
        FreeADsMem(pIntArray);

    RRETURN(hr);
} 

//----------------------------------------------------------------------------
// Function:   WinNTTypeToUmiFileTimes
//
// Synopsis:   Converts from NT object to UMI_PROPERTY structure containing
//             a filetime.
//
// Arguments:
//
// pNtObject     Pointer to NT object
// dwNumValues   Number of values in pNtObject
// pPropArray    Pointer to UMI_PROPERTY that returns the converted values
// pExistingMem  If non-NULL, the provider does not allocate memory. Instead,
//               the memory pointed to by this argument is used.
// dwMemSize     Number of bytes of memory pointed to by pExistingMem
//
// Returns:      UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:     *pExistingMem if pExistingMem is non-NULL
//               *pPropArray otherwise
//
//----------------------------------------------------------------------------
HRESULT WinNTTypeToUmiFileTimes(
    LPNTOBJECT pNtObject,
    DWORD dwNumValues,
    UMI_PROPERTY *pPropArray,
    LPVOID pExistingMem,
    DWORD dwMemSize
    )
{
    DWORD      dwMemRequired = 0, i = 0;
    void       *pFileTimeArray = NULL;
    HRESULT    hr = UMI_S_NO_ERROR;
    BOOL       fRetVal = FALSE;
    SYSTEMTIME LocalTime, SystemTime;
    FILETIME   LocalFileTime, FileTime;
    LARGE_INTEGER tmpTime;

    // Check if the NT type can be converted to the requested UMI type
    if(pNtObject->NTType != NT_SYNTAX_ID_SYSTEMTIME)
        BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

    dwMemRequired = dwNumValues * sizeof(FILETIME);

    if(NULL == pExistingMem) {
    // provider has to allocate memory
        pFileTimeArray = (void *) AllocADsMem(dwMemRequired);
        if(NULL == pFileTimeArray)
            BAIL_ON_FAILURE(UMI_E_OUT_OF_MEMORY);
    }
    else {
    // user provided memory to return data
        if(dwMemSize < dwMemRequired)
            BAIL_ON_FAILURE(hr = UMI_E_INSUFFICIENT_MEMORY);     

        pFileTimeArray = pExistingMem;
    }

    for(i = 0; i < dwNumValues; i++) {
       if(NT_SYNTAX_ID_SYSTEMTIME == pNtObject->NTType) {
            // convert from UTC to local time
            fRetVal = SystemTimeToTzSpecificLocalTime(
                          NULL,
                          &(pNtObject[i].NTValue.stSystemTimeValue),
                          &LocalTime
                          );

            if(FALSE == fRetVal)
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));

            fRetVal = SystemTimeToFileTime(
                          &LocalTime,
                          &LocalFileTime
                          );

            if(FALSE == fRetVal)
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }
        else if(NT_SYNTAX_ID_DATE == pNtObject->NTType) {
            GetSystemTime(&SystemTime);

            // only the hours and minutes are valid. Rest is no-op.
            SystemTime.wHour = (WORD) ((pNtObject[i].NTValue.dwValue)/60);    
            SystemTime.wMinute = (WORD) ((pNtObject[i].NTValue.dwValue)%60);
            SystemTime.wSecond =0;
            SystemTime.wMilliseconds = 0;

            // now convert UTC To local time
            fRetVal = SystemTimeToTzSpecificLocalTime(
                          NULL,
                          &SystemTime,
                          &LocalTime
                          );
 
            if(FALSE == fRetVal)
               BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));

            fRetVal = SystemTimeToFileTime(
                          &LocalTime,
                          &LocalFileTime
                          );

            if(FALSE == fRetVal)
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }
        else if(NT_SYNTAX_ID_DATE_1970 == pNtObject->NTType) {
            memset(&FileTime, 0, sizeof(FILETIME));
            RtlSecondsSince1970ToTime(
                pNtObject[i].NTValue.dwSeconds1970,
                &tmpTime
                );

            FileTime.dwLowDateTime = tmpTime.LowPart;
            FileTime.dwHighDateTime = tmpTime.HighPart;

            fRetVal = FileTimeToLocalFileTime(
                          &FileTime,
                          &LocalFileTime
                          );
            if(FALSE == fRetVal)
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }
     
        *((FILETIME *)pFileTimeArray + i) = LocalFileTime;
    }

    if(pPropArray != NULL)
        pPropArray->pUmiValue = (UMI_VALUE *) pFileTimeArray;

    RRETURN(hr);

error:

    if( (pFileTimeArray != NULL) && (NULL == pExistingMem) )
        FreeADsMem(pFileTimeArray);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   WinNTTypeToUmiSystemTimes
//
// Synopsis:   Converts from NT object to UMI_PROPERTY structure containing
//             a systemtime.
//
// Arguments:
//
// pNtObject     Pointer to NT object
// dwNumValues   Number of values in pNtObject
// pPropArray    Pointer to UMI_PROPERTY that returns the converted values
// pExistingMem  If non-NULL, the provider does not allocate memory. Instead,
//               the memory pointed to by this argument is used.
// dwMemSize     Number of bytes of memory pointed to by pExistingMem
//
// Returns:      UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:     *pExistingMem if pExistingMem is non-NULL
//               *pPropArray otherwise
//
//----------------------------------------------------------------------------
HRESULT WinNTTypeToUmiSystemTimes(
    LPNTOBJECT pNtObject,
    DWORD dwNumValues,
    UMI_PROPERTY *pPropArray,
    LPVOID pExistingMem,
    DWORD dwMemSize
    )
{
    DWORD      dwMemRequired = 0, i = 0;
    void       *pSysTimeArray = NULL;
    HRESULT    hr = UMI_S_NO_ERROR;
    SYSTEMTIME LocalTime, SystemTime;
    BOOL       fRetVal = FALSE;
    FILETIME   FileTime, LocalFileTime;
    LARGE_INTEGER tmpTime;

    // Check if the NT type can be converted to the requested UMI type
    if( (pNtObject->NTType != NT_SYNTAX_ID_SYSTEMTIME) &&
        (pNtObject->NTType != NT_SYNTAX_ID_DATE) &&
        (pNtObject->NTType != NT_SYNTAX_ID_DATE_1970) ) 
        BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

    dwMemRequired = dwNumValues * sizeof(SYSTEMTIME);

    if(NULL == pExistingMem) {
    // provider has to allocate memory
        pSysTimeArray = (void *) AllocADsMem(dwMemRequired);
        if(NULL == pSysTimeArray)
            BAIL_ON_FAILURE(UMI_E_OUT_OF_MEMORY);
    }
    else {
    // user provided memory to return data
        if(dwMemSize < dwMemRequired)
            BAIL_ON_FAILURE(hr = UMI_E_INSUFFICIENT_MEMORY);     

        pSysTimeArray = pExistingMem;
    }

    for(i = 0; i < dwNumValues; i++) {
        if(NT_SYNTAX_ID_SYSTEMTIME == pNtObject->NTType) {
            // convert from UTC to local time
            fRetVal = SystemTimeToTzSpecificLocalTime(
                          NULL,
                          &pNtObject[i].NTValue.stSystemTimeValue,
                          &LocalTime
                          );

            if(FALSE == fRetVal)
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }
        else if(NT_SYNTAX_ID_DATE == pNtObject->NTType) {
            GetSystemTime(&SystemTime);

            // only the hours and minutes are valid. Rest is no-op.
            SystemTime.wHour = (WORD) ((pNtObject[i].NTValue.dwValue)/60);    
            SystemTime.wMinute = (WORD) ((pNtObject[i].NTValue.dwValue)%60);
            SystemTime.wSecond =0;
            SystemTime.wMilliseconds = 0;

            // now convert UTC To local time
            fRetVal = SystemTimeToTzSpecificLocalTime(
                          NULL,
                          &SystemTime,
                          &LocalTime
                          );
 
            if(FALSE == fRetVal)
               BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }
        else if(NT_SYNTAX_ID_DATE_1970 == pNtObject->NTType) {
            memset(&FileTime, 0, sizeof(FILETIME));
            RtlSecondsSince1970ToTime(
                pNtObject[i].NTValue.dwSeconds1970,
                &tmpTime
                );

            FileTime.dwLowDateTime = tmpTime.LowPart;
            FileTime.dwHighDateTime = tmpTime.HighPart;

            fRetVal = FileTimeToLocalFileTime(
                          &FileTime,
                          &LocalFileTime
                          );
            if(FALSE == fRetVal)
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));

            fRetVal = FileTimeToSystemTime(
                          &LocalFileTime,
                          &LocalTime
                          );

            if(FALSE == fRetVal)
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));

        }
   
        *((SYSTEMTIME *)pSysTimeArray + i) = LocalTime;
    }

    if(pPropArray != NULL)
        pPropArray->pUmiValue = (UMI_VALUE *) pSysTimeArray;

    RRETURN(hr);

error:

    if( (pSysTimeArray != NULL) && (NULL == pExistingMem) )
        FreeADsMem(pSysTimeArray);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   WinNTTypeToUmiBools
//
// Synopsis:   Converts from NT object to UMI_PROPERTY structure containing
//             a boolean
//
// Arguments:
//
// pNtObject     Pointer to NT object
// dwNumValues   Number of values in pNtObject
// pPropArray    Pointer to UMI_PROPERTY that returns the converted values
// pExistingMem  If non-NULL, the provider does not allocate memory. Instead,
//               the memory pointed to by this argument is used.
// dwMemSize     Number of bytes of memory pointed to by pExistingMem
//
// Returns:      UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:     *pExistingMem if pExistingMem is non-NULL
//               *pPropArray otherwise
//
//----------------------------------------------------------------------------
HRESULT WinNTTypeToUmiBools(
    LPNTOBJECT pNtObject,
    DWORD dwNumValues,
    UMI_PROPERTY *pPropArray,
    LPVOID pExistingMem,
    DWORD dwMemSize
    )
{
    DWORD   dwMemRequired = 0, i = 0;
    void    *pBoolArray = NULL;
    HRESULT hr = UMI_S_NO_ERROR;

    // Check if the NT type can be converted to the requested UMI type
    if(pNtObject->NTType != NT_SYNTAX_ID_BOOL)
        BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA); 

    dwMemRequired = dwNumValues * sizeof(BOOL);

    if(NULL == pExistingMem) {
    // provider has to allocate memory
        pBoolArray = (void *) AllocADsMem(dwMemRequired);
        if(NULL == pBoolArray)
            BAIL_ON_FAILURE(UMI_E_OUT_OF_MEMORY);
    }
    else {
    // user provided memory to return data
        if(dwMemSize < dwMemRequired)
            BAIL_ON_FAILURE(hr = UMI_E_INSUFFICIENT_MEMORY);

        pBoolArray = pExistingMem;
    }

    for(i = 0; i < dwNumValues; i++) {
        if(pNtObject[i].NTValue.fValue)
            *((BOOL *)pBoolArray + i) = TRUE;
        else
            *((BOOL *)pBoolArray + i) = FALSE;
    }
     
    if(pPropArray != NULL)
        pPropArray->pUmiValue = (UMI_VALUE *) pBoolArray;

    RRETURN(hr);

error:

    if( (pBoolArray != NULL) && (NULL == pExistingMem) )
        FreeADsMem(pBoolArray);

    RRETURN(hr);
}
    
//----------------------------------------------------------------------------
// Function:   WinNTTypeToUmiLPWSTRs
//
// Synopsis:   Converts from NT object to UMI_PROPERTY structure containing
//             a string 
//
// Arguments:
//
// pNtObject     Pointer to NT object
// dwNumValues   Number of values in pNtObject
// pPropArray    Pointer to UMI_PROPERTY that returns the converted values
// pExistingMem  If non-NULL, the provider does not allocate memory. Instead,
//               the memory pointed to by this argument is used.
// dwMemSize     Number of bytes of memory pointed to by pExistingMem
//
// Returns:      UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:     *pExistingMem if pExistingMem is non-NULL
//               *pPropArray otherwise
//
//----------------------------------------------------------------------------
HRESULT WinNTTypeToUmiLPWSTRs(
    LPNTOBJECT pNtObject,
    DWORD dwNumValues,
    UMI_PROPERTY *pPropArray,
    LPVOID pExistingMem,
    DWORD dwMemSize
    )
{
    DWORD   dwMemRequired = 0, i = 0;
    void    *pStrArray = NULL;
    HRESULT hr = UMI_S_NO_ERROR;
    LPWSTR  pszTmpStr = NULL;
    UCHAR   Seed = UMI_ENCODE_SEED3;
    UNICODE_STRING Password;

    // Check if the NT type can be converted to the requested UMI type
    if( (pNtObject->NTType != NT_SYNTAX_ID_LPTSTR) &&
        (pNtObject->NTType != NT_SYNTAX_ID_DelimitedString) &&
        (pNtObject->NTType != NT_SYNTAX_ID_NulledString) &&
        (pNtObject->NTType != NT_SYNTAX_ID_EncryptedString) )
        BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA); 

    dwMemRequired = dwNumValues * sizeof(LPWSTR);

    if(NULL == pExistingMem) {
    // provider has to allocate memory
        pStrArray = (void *) AllocADsMem(dwMemRequired);
        if(NULL == pStrArray)
            BAIL_ON_FAILURE(UMI_E_OUT_OF_MEMORY);
    }
    else {
    // user provided memory to return data. GetAs() will call this function
    // only if the property is single-valued. Copy the string into the
    // memory supplied y the caller.
    //
        ADsAssert(1 == dwNumValues);
        dwMemRequired = (wcslen(pNtObject->NTValue.pszValue) + 1) * 
                                                             sizeof(WCHAR);
        if(dwMemSize < dwMemRequired)
            BAIL_ON_FAILURE(hr = UMI_E_INSUFFICIENT_MEMORY);

        wcscpy((WCHAR *) pExistingMem, pNtObject->NTValue.pszValue);

        if(NT_SYNTAX_ID_EncryptedString == pNtObject->NTType) {
        // decrypt the string (typically password)

            RtlInitUnicodeString(&Password, (WCHAR *) pExistingMem);
            RtlRunDecodeUnicodeString(Seed, &Password);
        }

        RRETURN(UMI_S_NO_ERROR);
    }

    memset(pStrArray, 0, dwMemRequired);

    for(i = 0; i < dwNumValues; i++) {
        if(pNtObject[i].NTValue.pszValue != NULL) {
            pszTmpStr = AllocADsStr(pNtObject[i].NTValue.pszValue); 
            if(NULL == pszTmpStr)
                BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
        
            if(NT_SYNTAX_ID_EncryptedString == pNtObject->NTType) {
            // decrypt the string (typically password)
 
                RtlInitUnicodeString(&Password, pszTmpStr);
                RtlRunDecodeUnicodeString(Seed, &Password);
            }
        }

        *((LPWSTR *)pStrArray + i) = pszTmpStr;
    }
     
    if(pPropArray != NULL)
        pPropArray->pUmiValue = (UMI_VALUE *) pStrArray;

    RRETURN(hr);

error:

    if(pStrArray != NULL) {
        // free any strings allocated
        for(i = 0; i < dwNumValues; i++)
            if(((LPWSTR *) pStrArray)[i] != NULL)
                FreeADsStr(((LPWSTR *) pStrArray)[i]);

        if(NULL == pExistingMem)
        // provider allocated memory
            FreeADsMem(pStrArray);
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   WinNTTypeToUmiOctetStrings
//
// Synopsis:   Converts from NT object to UMI_PROPERTY structure containing
//             an octet string 
//
// Arguments:
//
// pNtObject     Pointer to NT object
// dwNumValues   Number of values in pNtObject
// pPropArray    Pointer to UMI_PROPERTY that returns the converted values
// pExistingMem  If non-NULL, the provider does not allocate memory. Instead,
//               the memory pointed to by this argument is used.
// dwMemSize     Number of bytes of memory pointed to by pExistingMem
//
// Returns:      UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:     *pExistingMem if pExistingMem is non-NULL
//               *pPropArray otherwise
//
//----------------------------------------------------------------------------
HRESULT WinNTTypeToUmiOctetStrings(
    LPNTOBJECT pNtObject,
    DWORD dwNumValues,
    UMI_PROPERTY *pPropArray,
    LPVOID pExistingMem,
    DWORD dwMemSize
    )
{
    DWORD   dwMemRequired = 0, i = 0;
    void    *pOctetStrArray = NULL;
    HRESULT hr = UMI_S_NO_ERROR;
    LPWSTR  pTmpOctetStr = NULL;

    // Check if the NT type can be converted to the requested UMI type
    if(pNtObject->NTType != NT_SYNTAX_ID_OCTETSTRING) 
        BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA); 

    dwMemRequired = dwNumValues * sizeof(UMI_OCTET_STRING);

    if(NULL == pExistingMem) {
    // provider has to allocate memory
        pOctetStrArray = (void *) AllocADsMem(dwMemRequired);
        if(NULL == pOctetStrArray)
            BAIL_ON_FAILURE(UMI_E_OUT_OF_MEMORY);
    }
    else {
    // user provided memory to return data
        if(dwMemSize < dwMemRequired)
            BAIL_ON_FAILURE(hr = UMI_E_INSUFFICIENT_MEMORY);

        pOctetStrArray = pExistingMem;
    }

    memset(pOctetStrArray, 0, dwMemRequired);

    for(i = 0; i < dwNumValues; i++) {
        pTmpOctetStr = (LPWSTR) 
                         AllocADsMem(pNtObject[i].NTValue.octetstring.dwSize); 
        if(NULL == pTmpOctetStr)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
        
        memcpy(
           pTmpOctetStr, 
           pNtObject[i].NTValue.octetstring.pByte,
           pNtObject[i].NTValue.octetstring.dwSize
           );
 
        ((UMI_OCTET_STRING *)pOctetStrArray + i)->uLength =
                            pNtObject[i].NTValue.octetstring.dwSize;
        ((UMI_OCTET_STRING *)pOctetStrArray + i)->lpValue = 
                            (BYTE *) pTmpOctetStr;
    }
     
    if(pPropArray != NULL)
        pPropArray->pUmiValue = (UMI_VALUE *) pOctetStrArray;

    RRETURN(hr);

error:

    if(pOctetStrArray != NULL) {
        // free any strings allocated
        for(i = 0; i < dwNumValues; i++)
            if(((UMI_OCTET_STRING *) pOctetStrArray)[i].lpValue != NULL)
                FreeADsMem(((UMI_OCTET_STRING *) pOctetStrArray)[i].lpValue);

        if(NULL == pExistingMem)
        // provider allocated memory
            FreeADsMem(pOctetStrArray);
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   WinNTTypeToUmi
//
// Synopsis:   Converts from NT object to UMI_PROPERTY structure.
//
// Arguments:
//
// pNtObject     Pointer to NT object
// dwNumValues   Number of values in pNtObject
// pPropArray    Pointer to UMI_PROPERTY that returns the converted values
// pExistingMem  If non-NULL, the provider does not allocate memory. Instead,
//               the memory pointed to by this argument is used.
// dwMemSize     Number of bytes of memory pointed to by pExistingMem
// UmiType       UMI type to convert the NT object to
//
// Returns:      UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:     *pExistingMem if pExistingMem is non-NULL
//               *pPropArray otherwise
//
//----------------------------------------------------------------------------
HRESULT WinNTTypeToUmi(
    LPNTOBJECT pNtObject,
    DWORD dwNumValues,
    UMI_PROPERTY *pPropArray,
    LPVOID pExistingMem,
    DWORD dwMemSize,
    UMI_TYPE UmiType
    )
{
    HRESULT hr = UMI_S_NO_ERROR;

    ADsAssert( (pNtObject != NULL) &&
              ((pPropArray != NULL) || (pExistingMem != NULL)) );
    // only one of pPropArray and pExistingMem can be non-NULL
    ADsAssert( (NULL == pPropArray) || (NULL == pExistingMem) );

    // Enclose code in try/except to catch AVs caused by the user passing in
    // a bad pointer in pExistingMem
    __try {

    switch(UmiType) {

        case UMI_TYPE_NULL:
            BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

        case UMI_TYPE_I1:
        case UMI_TYPE_I2:
        case UMI_TYPE_I4:
        case UMI_TYPE_I8:
        case UMI_TYPE_UI1:
        case UMI_TYPE_UI2:
        case UMI_TYPE_UI4:
        case UMI_TYPE_UI8:
            hr = WinNTTypeToUmiIntegers(
                   pNtObject,
                   dwNumValues,
                   pPropArray,
                   pExistingMem,
                   dwMemSize,
                   UmiType
                   );
            break;

        case UMI_TYPE_R4:
        case UMI_TYPE_R8:
            BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

        case UMI_TYPE_FILETIME:
            hr = WinNTTypeToUmiFileTimes(
                   pNtObject,
                   dwNumValues,
                   pPropArray,
                   pExistingMem,
                   dwMemSize
                   );
            break;

        case UMI_TYPE_SYSTEMTIME:
            hr = WinNTTypeToUmiSystemTimes(
                   pNtObject,
                   dwNumValues,
                   pPropArray,
                   pExistingMem,
                   dwMemSize
                   );
            break;

        case UMI_TYPE_BOOL:
            hr = WinNTTypeToUmiBools(
                   pNtObject,
                   dwNumValues,
                   pPropArray,
                   pExistingMem,
                   dwMemSize
                   );
            break;

        case UMI_TYPE_IDISPATCH:
        case UMI_TYPE_IUNKNOWN:
        case UMI_TYPE_VARIANT: // TODO later
            BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

        case UMI_TYPE_LPWSTR:
            hr = WinNTTypeToUmiLPWSTRs(
                   pNtObject,
                   dwNumValues,
                   pPropArray,
                   pExistingMem,
                   dwMemSize
                   );
            break;

        case UMI_TYPE_OCTETSTRING:
            hr = WinNTTypeToUmiOctetStrings(
                   pNtObject,
                   dwNumValues,
                   pPropArray,
                   pExistingMem,
                   dwMemSize
                   );
            break;

        case UMI_TYPE_UMIARRAY:
        case UMI_TYPE_DISCOVERY:
        case UMI_TYPE_UNDEFINED:
        case UMI_TYPE_DEFAULT:
            BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

        default:
            BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);
    } // switch

    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        if(pExistingMem != NULL) {
        // assume this is the cause of the exception
            BAIL_ON_FAILURE(hr = UMI_E_INTERNAL_EXCEPTION);
        }
        else
        // don't mask bugs in provider
            throw;
    }

    if(pPropArray != NULL) {
        pPropArray->uType = UmiType;
        pPropArray->uCount = dwNumValues;
    }

error:    

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\jobhlp.cxx ===
/*++
  Copyright (c) 1995-1996  Microsoft Corporation

  Module Name:

  jobhlp.cxx

  Abstract:
  Helper functions for Job Object

  Author:

  Ram Viswanathan (ramv) 11-18-95

  Revision History:

  --*/

#include "winnt.hxx"
#pragma hdrstop
#define INITGUID


//
// mapping WinNT Status Codes to ADs Status Codes and vice versa
//

typedef struct _JobStatusList {
    DWORD  dwWinNTJobStatus;
    DWORD dwADsJobStatus;
} JOB_STATUS_LIST, *PJOB_STATUS_LIST;


JOB_STATUS_LIST JobStatusList[] =
{
{JOB_STATUS_PAUSED, ADS_JOB_PAUSED },
{JOB_STATUS_ERROR, ADS_JOB_ERROR},
{JOB_STATUS_DELETING, ADS_JOB_DELETING},
{JOB_STATUS_SPOOLING, ADS_JOB_SPOOLING},
{JOB_STATUS_PRINTING, ADS_JOB_PRINTING},
{JOB_STATUS_OFFLINE, ADS_JOB_OFFLINE},
{JOB_STATUS_PAPEROUT, ADS_JOB_PAPEROUT},
{JOB_STATUS_PRINTED, ADS_JOB_PRINTED}
};

BOOL JobStatusWinNTToADs( DWORD dwWinNTStatus,
DWORD *pdwADsStatus)
{
    BOOL found = FALSE;
    int i;

    for (i=0;i<8;i++){

        if(dwWinNTStatus == JobStatusList[i].dwWinNTJobStatus){
            *pdwADsStatus = JobStatusList[i].dwADsJobStatus;
            found = TRUE;
            break;
        }
    }
    return (found);
}

BOOL JobStatusADsToWinNT( DWORD dwADsStatus,
                           DWORD *pdwWinNTStatus)

{
    BOOL found = FALSE;
    int i;

    for (i=0;i<8;i++){

        if(dwADsStatus == JobStatusList[i].dwADsJobStatus){
            *pdwWinNTStatus = JobStatusList[i].dwWinNTJobStatus;
            found = TRUE;
            break;
        }
    }
    return (found);

}




//+---------------------------------------------------------------------------
//
//  Function:   MarshallAndSet
//
//  Synopsis:   Marshalls information from a Print Job  object to a
//              JOB_INFO_2 structure and sets it
//
//  Arguments:  [lpJobInfo2] -- Pointer to a JOB_INFO_2 struct.
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    11/09/95  RamV  Created
//
//-----------------------------------------------------------------

HRESULT
CWinNTPrintJob::MarshallAndSet(
    LPJOB_INFO_2 lpJobInfo2,
    BSTR bstrPrinterName,
    LONG lJobId
    )

{
    HRESULT hr =S_OK;
    LPTSTR pszUserName = NULL;
    LPTSTR pszDescription = NULL;
    LPTSTR pszNotify = NULL;
    LPTSTR pszDocument = NULL;
    DWORD dwPriority;
    DWORD dwPosition;
    DWORD dwStartTime;
    DWORD dwUntilTime;
    DWORD dwTotalPages;
    DWORD dwSize;
    DWORD dwPagesPrinted;
    SYSTEMTIME stTimeSubmitted;


    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("User"),
                    &pszUserName
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->pUserName = pszUserName;
    }


    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    &pszDocument
                    );
    if(SUCCEEDED(hr)){
        lpJobInfo2->pDocument = pszDocument;
    }

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Notify"),
                    &pszNotify
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->pNotifyName = pszNotify;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Priority"),
                    &dwPriority
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->Priority = dwPriority;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Position"),
                    &dwPosition
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->Position = dwPosition;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("TotalPages"),
                    &dwTotalPages
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->TotalPages = dwTotalPages;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Size"),
                    &dwSize
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->Size = dwSize;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PagesPrinted"),
                    &dwPagesPrinted
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->PagesPrinted = dwPagesPrinted;
    }

   hr = GetDATEPropertyFromCache(
                    _pPropertyCache,
                    TEXT("StartTime"),
                    &dwStartTime
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->StartTime = dwStartTime;
    }

   hr = GetDATEPropertyFromCache(
                    _pPropertyCache,
                    TEXT("UntilTime"),
                    &dwUntilTime
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->UntilTime = dwUntilTime;
    }

   hr = GetSYSTEMTIMEPropertyFromCache(
                    _pPropertyCache,
                    TEXT("TimeSubmitted"),
                    &stTimeSubmitted
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->Submitted = stTimeSubmitted;
    }

    //
    // set the relevant information
    //

    hr = Set(lpJobInfo2,
             bstrPrinterName,
             lJobId);

    if(pszUserName){
        FreeADsStr(pszUserName);
    }
    if(pszDescription){
        FreeADsStr(pszDescription);
    }
    if(pszNotify){
        FreeADsStr(pszNotify);
    }
    if(pszDocument){
        FreeADsStr(pszDocument);
    }

    RRETURN(hr);
}


//+----------------------------------------------------------------
//
//  Function:   UnmarshallLevel2
//
//  Synopsis:   Unmarshalls information from a JOB_INFO_2 to a
//              WinNT Print JOB  object.
//
//  Arguments:  [lpJobInfo2] -- Pointer to a JOB_INFO_2 struct
//
//  Returns:    HRESULT
//
//  Modifies:   GeneralInfo and Operation Functional sets
//
//  History:    11/08/95  RamV   Created
//
//----------------------------------------------------------------------------

HRESULT
CWinNTPrintJob::UnMarshallLevel2(
    LPJOB_INFO_2 lpJobInfo2,
    BOOL fExplicit
    )

{
    HRESULT hr S_OK;

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                TEXT("TimeElapsed"),
                                lpJobInfo2->Time,
                                fExplicit
                                );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                TEXT("PagesPrinted"),
                                lpJobInfo2->PagesPrinted,
                                fExplicit
                                );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                TEXT("Position"),
                                lpJobInfo2->Position,
                                fExplicit
                                );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("HostPrintQueue"),
                                  _pszPrinterPath,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("User"),
                                  lpJobInfo2->pUserName,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Description"),
                                  lpJobInfo2->pDocument,
                                  fExplicit
                                  );

   hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Notify"),
                                  lpJobInfo2->pNotifyName,
                                  fExplicit
                                  );

   hr = SetDWORDPropertyInCache(_pPropertyCache,
                                TEXT("Priority"),
                                lpJobInfo2->Priority,
                                fExplicit
                                );

   hr = SetDATEPropertyInCache(_pPropertyCache,
                               TEXT("StartTime"),
                               lpJobInfo2->StartTime,
                               fExplicit
                               );

   hr = SetDATEPropertyInCache(_pPropertyCache,
                               TEXT("UntilTime"),
                               lpJobInfo2-> UntilTime,
                               fExplicit
                               );

   hr = SetSYSTEMTIMEPropertyInCache(_pPropertyCache,
                                     TEXT("TimeSubmitted"),
                                     lpJobInfo2->Submitted,
                                     fExplicit
                                     );

   hr = SetDWORDPropertyInCache(_pPropertyCache,
                                TEXT("TotalPages"),
                                lpJobInfo2->TotalPages,
                                fExplicit
                                );

   hr = SetDWORDPropertyInCache(_pPropertyCache,
                                TEXT("Size"),
                                lpJobInfo2->Size,
                                fExplicit
                                );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );

    RRETURN(S_OK);

}

HRESULT
CWinNTPrintJob::UnMarshallLevel1(
    LPJOB_INFO_1 lpJobInfo1,
    BOOL fExplicit
    )

{
    HRESULT hr;

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                TEXT("PagesPrinted"),
                                lpJobInfo1->PagesPrinted,
                                fExplicit
                                );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                TEXT("Position"),
                                lpJobInfo1->Position,
                                fExplicit
                                );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("User"),
                                  lpJobInfo1->pUserName,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Description"),
                                  lpJobInfo1->pDocument,
                                  fExplicit
                                  );


    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("Priority"),
                                  lpJobInfo1->Priority,
                                  fExplicit
                                  );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("TotalPages"),
                                  lpJobInfo1->TotalPages,
                                  fExplicit
                                  );

    hr = SetSYSTEMTIMEPropertyInCache(_pPropertyCache,
                                      TEXT("TimeSubmitted"),
                                      lpJobInfo1->Submitted,
                                      fExplicit
                                      );

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   Set
//
//  Synopsis:   Helper function called by CADsPrintJob:SetInfo
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11-08-95 RamV  Created
//
//----------------------------------------------------------------------------

HRESULT
Set(
    LPJOB_INFO_2 lpJobInfo2,
    BSTR         bstrPrinterName,
    LONG         lJobId
    )
{

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ALL_ACCESS};
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;
    DWORD LastError = 0;

    ADsAssert(bstrPrinterName);

    fStatus = OpenPrinter((LPTSTR)bstrPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );


    if (!fStatus) {
        goto error;
    }

    fStatus = SetJob(hPrinter,
                     lJobId,
                     2,
                     (LPBYTE)lpJobInfo2,
                     0
                     );

    if (!fStatus) {
        goto error;
    }

    RRETURN(S_OK);

error:
    hr =HRESULT_FROM_WIN32(GetLastError());
    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN(hr);

}


HRESULT
GetJobInfo( DWORD dwLevel,
           LPBYTE *ppJobInfo,
           LPWSTR      pszPrinterName,
           LONG        lJobId)

{
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE |
                                            READ_CONTROL};
    BOOL fStatus = FALSE;
    DWORD dwPassed = 0, dwNeeded = 0;
    DWORD LastError = 0;
    HANDLE hPrinter = NULL;
    LPBYTE pMem = NULL;
    HRESULT hr = S_OK;


    ADsAssert(dwLevel ==1 || dwLevel == 2);

    fStatus = OpenPrinter(pszPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );
    if (!fStatus) {
        LastError = GetLastError();
        switch (LastError) {

        case ERROR_ACCESS_DENIED:
        {
            PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE};
            fStatus = OpenPrinter(pszPrinterName,
                                  &hPrinter,
                                  &PrinterDefaults
                                  );
            if (fStatus) {
                break;
            }
        }
        default:
            RRETURN(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    pMem = (LPBYTE)AllocADsMem(dwPassed);

    if (!pMem) {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    fStatus = GetJob(hPrinter,
                     lJobId,
                     dwLevel,
                     (LPBYTE)pMem,
                     dwPassed,
                     &dwNeeded
                     );
    if (!fStatus) {
        LastError = GetLastError();
        switch (LastError) {
        case ERROR_INSUFFICIENT_BUFFER:
            if(pMem){
                FreeADsMem(pMem);
            }
            dwPassed = dwNeeded;
            pMem = (LPBYTE)AllocADsMem(dwPassed);

            if (!pMem) {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }

            fStatus = GetJob(hPrinter,
                             lJobId,
                             dwLevel,
                             (LPBYTE)pMem,
                             dwPassed,
                             &dwNeeded
                             );
            if (!fStatus) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto cleanup;
            }
            break;

        default:
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto cleanup;

        }
    }

    *ppJobInfo = pMem;

cleanup:
    if(hPrinter)
        ClosePrinter(hPrinter);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\nt2var.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       winnt2var.cxx
//
//  Contents:   WinNT Object to Variant Copy Routines
//
//  Functions:
//
//  History:      06/12/96   RamV   Created.
//                cloned off NDS conversion code.
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//----------------------------------------------------------------------------

//
// NTType objects copy code
//

#include "winnt.hxx"
#pragma  hdrstop
#define INITGUID

void
VarTypeFreeVarObjects(
    PVARIANT pVarObject,
    DWORD dwNumValues
    )
{
    DWORD i = 0;

    if( !pVarObject){
        return;
    }

    for (i = 0; i < dwNumValues; i++ ) {
         VariantClear(pVarObject + i);
    }

    FreeADsMem(pVarObject);

    return;
}

HRESULT
NTTypeToVarTypeCopyOctetString(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    hr = BinaryToVariant(
                (pNTSrcValue->NTValue).octetstring.dwSize,
                (pNTSrcValue->NTValue).octetstring.pByte,
                lpVarDestObject
    );

    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopyBOOL(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_BOOL;

    if((pNTSrcValue->NTValue).fValue){
        lpVarDestObject->boolVal = VARIANT_TRUE;  // notation for TRUE in V_BOOL
    } else {
        lpVarDestObject->boolVal = VARIANT_FALSE;
    }

    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopySYSTEMTIME(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr;

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

   lpVarDestObject->vt = VT_DATE;

    hr = ConvertSystemTimeToDATE (pNTSrcValue->NTValue.stSystemTimeValue,
                                  &lpVarDestObject->date );


    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopyDWORD(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    //
    // we cast the DWORD  to a LONG
    //

    HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_I4;

    lpVarDestObject->lVal = (LONG)(pNTSrcValue->NTValue).dwValue;

    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopyDATE70(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    //
    // we cast the DWORD  to a LONG
    //

    HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_DATE;

    hr = ConvertDWORDtoDATE(
                (pNTSrcValue->NTValue).dwSeconds1970,
                &(lpVarDestObject->date)
                );

    RRETURN(hr);
}


HRESULT
NTTypeToVarTypeCopyDATE(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{

    HRESULT hr = S_OK;
    SYSTEMTIME stSystemTime;
    SYSTEMTIME LocalTime;
    DATE    date;
    BOOL       fRetval;

    GetSystemTime( &stSystemTime);

    fRetval = SystemTimeToTzSpecificLocalTime(
                  NULL,
                  &stSystemTime,
                  &LocalTime
                  );
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    stSystemTime.wHour = (WORD)(pNTSrcValue->NTValue.dwValue)/60;
    stSystemTime.wMinute = (WORD)(pNTSrcValue->NTValue.dwValue)%60;
    stSystemTime.wSecond =0;
    stSystemTime.wMilliseconds = 0;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_DATE;

    hr = ConvertSystemTimeToDATE (stSystemTime,
                                  &date );
    BAIL_ON_FAILURE(hr);

    // We are casting date to DWORD and then subtracting it from date, which is double,
    // so that we only keep hours and minutes related info from the source DATE
    lpVarDestObject->date = date - (DWORD)date;


error:

    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopyLPTSTR(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_BSTR;

    if(!(pNTSrcValue->NTValue).pszValue){
        lpVarDestObject->bstrVal = NULL;
        hr = S_OK;
        goto error;
    }


    if(!pNTSrcValue){
        lpVarDestObject->bstrVal = NULL;
    } else {
        hr =  ADsAllocString((pNTSrcValue->NTValue).pszValue,
                               &(lpVarDestObject->bstrVal));
    }

error:
    RRETURN(hr);
}


HRESULT
NtTypeToVarTypeCopy(
    PNTOBJECT lpNtSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpNtSrcObject->NTType) {
    case NT_SYNTAX_ID_BOOL:
        hr = NTTypeToVarTypeCopyBOOL(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:
        hr = NTTypeToVarTypeCopySYSTEMTIME(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;


    case NT_SYNTAX_ID_DWORD:
        hr = NTTypeToVarTypeCopyDWORD(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_DATE:
        hr = NTTypeToVarTypeCopyDATE(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_LPTSTR:
        hr = NTTypeToVarTypeCopyLPTSTR(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_DelimitedString:

        hr = NTTypeToVarTypeCopyLPTSTR(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_NulledString :
        hr = NTTypeToVarTypeCopyLPTSTR(
                lpNtSrcObject,
                lpVarDestObject
                );

        break;


    case NT_SYNTAX_ID_DATE_1970:
        hr = NTTypeToVarTypeCopyDATE70(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;
    case NT_SYNTAX_ID_OCTETSTRING :
        hr = NTTypeToVarTypeCopyOctetString(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
NtTypeToVarTypeCopyConstruct(
    LPNTOBJECT pNtSrcObjects,
    DWORD dwNumObjects,
    PVARIANT pVarDestObjects
    )
{

    long i = 0;
    HRESULT hr = S_OK;

    VariantInit( pVarDestObjects );

    //
    // The following are for handling are multi-value properties
    //

    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;

    aBound.lLbound = 0;
    aBound.cElements = dwNumObjects;

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) dwNumObjects; i++ )
    {
        VARIANT v;

        VariantInit(&v);
        hr = NtTypeToVarTypeCopy( pNtSrcObjects + i,
                                  &v );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &v );
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);
    }

    V_VT(pVarDestObjects) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pVarDestObjects) = aList;

    RRETURN(S_OK);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\libmain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for oleds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


HINSTANCE g_hInst = NULL;
extern HMODULE   g_hActiveDs;
WCHAR * szWinNTPrefix = L"@WinNT!";
HANDLE   FpnwLoadLibSemaphore = NULL;

//
// Strings that are loaded depending on locality
//
WCHAR g_szBuiltin[100];
WCHAR g_szNT_Authority[100];
WCHAR g_szEveryone[100];
BOOL g_fStringsLoaded = FALSE;

//
// 3rd party extension
//
extern PCLASS_ENTRY gpClassHead;
extern CRITICAL_SECTION g_ExtCritSect;

extern CRITICAL_SECTION g_TypeInfoCritSect;

//
// Disabled as it causes link warnings
// extern CRITICAL_SECTION  g_DispTypeInfoCritSect;
//

//---------------------------------------------------------------------------
// ADs debug print, mem leak and object tracking-related stuff
//---------------------------------------------------------------------------

DECLARE_INFOLEVEL(ADs)

//+---------------------------------------------------------------------------
//
//  Function:   ShutDown
//
//  Synopsis:   Function to handle printing out heap debugging display
//
//----------------------------------------------------------------------------
inline VOID ShutDown()
{
#if DBG==1
#ifndef MSVC
     DUMP_TRACKING_INFO_DELETE();
     DeleteCriticalSection(&g_csOT);
#endif  // ifndef MSVC
     DeleteCriticalSection(&g_csDP);
#endif
}

extern "C" DWORD heapInfoLevel;
extern "C" DWORD OtInfoLevel;
extern "C" DWORD ADsInfoLevel;

//+---------------------------------------------------------------------------
//
//  Function:   GetINIHeapInfoLevel
//
//  Synopsis:   Gets various infolevel values from win.ini
//
//----------------------------------------------------------------------------
inline VOID GetINIHeapInfoLevel()
{
#if DBG==1
    const INT MAXINFOLEN=11;
    WCHAR  awcs[MAXINFOLEN];

#ifndef MSVC
    if (GetProfileString(L"winnt",L"heapInfoLevel", L"00000003", awcs,MAXINFOLEN))
        heapInfoLevel = wcstoul(awcs, NULL, 16);

    if (GetProfileString(L"winnt",L"Ot", L"00000003", awcs, MAXINFOLEN))
        OtInfoLevel = wcstoul(awcs, NULL, 16);

#endif  // MSVC

    if (GetProfileString(L"winnt",L"ADsInfoLevel", L"00000003", awcs,MAXINFOLEN))
        ADsInfoLevel = wcstoul(awcs, NULL, 16);
#endif
}

//  Globals


ULONG  g_ulObjCount = 0;  // Number of objects alive in oleds.dll


//+------------------------------------------------------------------------
//
//  Macro that calculates the number of elements in a statically-defined
//  array.
//
//  Note - I swiped this from ADsary.cxx - A type-safe array class. Remember
//  to swipe the whole thing as required.
//-------------------------------------------------------------------------
#define ARRAY_SIZE(_a)  (sizeof(_a) / sizeof(_a[0]))

CWinNTProviderCF g_cfProvider;
CWinNTNamespaceCF g_cfNamespace;
CWinNTSystemInfoCF g_cfWinNTSystemInfo;
CUmiConnectionCF g_cfWinNTUmiConn;
//CWinNTDomainCF g_cfDomain;


//+------------------------------------------------------------------------
//
//  oleds class factories
//
//-------------------------------------------------------------------------

struct CLSCACHE
{
    const CLSID *   pclsid;
    IClassFactory * pCF;
};



CLSCACHE g_aclscache[] =
{
    &CLSID_WinNTProvider,                        &g_cfProvider,
    &CLSID_WinNTNamespace,                       &g_cfNamespace, 
    &CLSID_WinNTSystemInfo,                      &g_cfWinNTSystemInfo,
    &CLSID_WinNTConnectionObject,                &g_cfWinNTUmiConn 
};


//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr;
    size_t          i;

    for (i = 0; i < ARRAY_SIZE(g_aclscache); i++)
    {
        if (IsEqualCLSID(clsid, *g_aclscache[i].pclsid))
        {
            hr = g_aclscache[i].pCF->QueryInterface(iid, ppv);
            RRETURN(hr);
        }
    }

    *ppv = NULL;

    //
    // Add Debugging Code to indicate that the oleds.DllGetClassObject has been called with an unknown CLSID.
    //

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
//---------------------------------------------------------------

STDAPI
DllCanUnloadNow(void)
{
    HRESULT hr;

    hr = S_FALSE;

    if (AggregatorDllCanUnload() ) {
        hr = S_OK;
    }

    return hr;
}


void LoadLocalizedStrings()
{
    if (g_fStringsLoaded) {
        return;
    }

    if (!LoadStringW(
             g_hInst,
             ADS_WINNT_BUILTIN,
             g_szBuiltin,
             sizeof( g_szBuiltin ) / sizeof( WCHAR )
             )
        ) {
        wcscpy(g_szBuiltin, L"BUILTIN");
    }

    if (!LoadStringW(
             g_hInst,
             ADS_WINNT_NT_AUTHORITY,
             g_szNT_Authority,
             sizeof( g_szNT_Authority ) / sizeof( WCHAR )
             )
        ) {
        wcscpy(g_szNT_Authority, L"NT AUTHORITY");
    }

    if (!LoadStringW(
             g_hInst,
             ADS_WINNT_EVERYONE,
             g_szEveryone,
             sizeof( g_szEveryone ) / sizeof( WCHAR )
             )
        ) {
        wcscpy(g_szEveryone, L"Everyone");
    }

}
//+---------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//---------------------------------------------------------------

EXTERN_C BOOL __cdecl
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    HRESULT     hr;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // Catch case of init crit sect failing.
        //
        __try {

            DisableThreadLibraryCalls(hInst);

            g_hInst = hInst;

            g_hActiveDs = GetModuleHandle(TEXT("activeds.dll"));

#if DBG==1
#ifndef MSVC
            InitializeCriticalSection(&g_csOT);
            InitializeCriticalSection(&g_csMem);
#endif
            InitializeCriticalSection(&g_csDP);
#endif

            InitializeCriticalSection(&g_TypeInfoCritSect);
            //
            // Disabled to avoid linker warnings
            // InitializeCriticalSection(&g_DispTypeInfoCritSect);
            //

            //
            // for 3rd party extension
            //

            InitializeCriticalSection(&g_ExtCritSect);

            //
            // Initialize the loadlibs critsect.
            //
            InitializeCriticalSection(&g_csLoadLibs);

            //
            // Load up localized strings.
            //
            LoadLocalizedStrings();

            gpClassHead = BuildClassesList();

            //
            // Build the global object class cache
            //

            hr = CObjNameCache::CreateClassCache(
                            &pgPDCNameCache
                            );
            if (FAILED(hr)) {
                return(FALSE);
            }

            //
            // create semaphore used to protect global data (DLL handles and
            // function pointers.
            //

            if ((FpnwLoadLibSemaphore = CreateSemaphore( NULL,1,1,NULL ))
                 == NULL)
            {
                return FALSE ;
            }

            g_pRtlEncryptMemory = (FRTLENCRYPTMEMORY) LoadAdvapi32Function(
                                      STRINGIZE(RtlEncryptMemory));
            g_pRtlDecryptMemory = (FRTLDECRYPTMEMORY) LoadAdvapi32Function(
                                      STRINGIZE(RtlDecryptMemory));

            if( (NULL == g_pRtlEncryptMemory) || (NULL == g_pRtlDecryptMemory) )
                g_pRtlEncryptMemory = g_pRtlDecryptMemory = NULL;                
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Critical failure
            //
            return FALSE;
        }

        break;


    case DLL_PROCESS_DETACH:

        //
        // Release semaphor if applicable.
        //
        if (FpnwLoadLibSemaphore) {
            CloseHandle(FpnwLoadLibSemaphore);
            FpnwLoadLibSemaphore = NULL;
        }
        //
        // Del the name cache - delte should handle NULL btw.
        //
        delete pgPDCNameCache;
        //
        // free global list of class entries for 3rd party ext
        //

        FreeClassesList(gpClassHead);

        //
        // Delete the critical sections
        //
#if DBG==1
#ifndef MSVC
        DeleteCriticalSection(&g_csOT);
        DeleteCriticalSection(&g_csMem);
#endif
        DeleteCriticalSection(&g_csDP);
#endif

        DeleteCriticalSection(&g_TypeInfoCritSect);
        //
        // Causes link warnings if enabled
        // DeleteCriticalSection(&g_DispTypeInfoCritSect);
        //
        DeleteCriticalSection(&g_ExtCritSect);

        DeleteCriticalSection(&g_csLoadLibs);

        //
        // Free libs we may have loaded dynamically.
        //
        if (g_hDllNetapi32) {
            FreeLibrary((HMODULE) g_hDllNetapi32);
            g_hDllNetapi32 = NULL;
        }

        if (g_hDllAdvapi32) {
            FreeLibrary((HMODULE) g_hDllAdvapi32);
        }

        break;


    default:
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT - post .546
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}


//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsidIndex
//
//  Synopsis:   Returns the index of the given CLSID in the cache, or
//              -1 if the CLSID is not present in the cache
//
//  Arguments:  [clsid]
//
//  Returns:    int
//
//-------------------------------------------------------------------------

int
GetCachedClsidIndex(REFCLSID clsid)
{
    int             i;
    CLSCACHE *      pclscache;

    for (i = 0, pclscache = g_aclscache;
         i < ARRAY_SIZE(g_aclscache);
         i ++, pclscache++)
    {
        if (IsEqualCLSID(*pclscache->pclsid, clsid))
            return i;
    }

    return -1;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClassFactory
//
//  Synopsis:   Returns the cached class factory with the given index.
//              The pointer returned has been AddRef'd.
//
//  Arguments:  [iclsid]
//
//  Returns:    IClassFactory *
//
//-------------------------------------------------------------------------

IClassFactory *
GetCachedClassFactory(int iclsid)
{
    IClassFactory * pCF;

    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    pCF = g_aclscache[iclsid].pCF;
    pCF->AddRef();

    return pCF;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsid
//
//  Synopsis:   Returns the CLSID corresponding to the given index.
//              Normally, code should call GetCachedClassFactory to get
//              the class factory directly.
//
//  Arguments:  [iclsid]    --  Clsid index
//              [pclsid]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------

void
GetCachedClsid(int iclsid, CLSID * pclsid)
{
    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    *pclsid = *g_aclscache[iclsid].pclsid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\ntcopy.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ntcopy.cxx
//
//  Contents:   NT Object Copy Routines
//
//  Functions:
//
//  History:      17-June-96   RamV   Created.
//                cloned off NDS copy code.
//
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//
//
//----------------------------------------------------------------------------

//
// NtType objects copy code
//

#include "winnt.hxx"
#pragma  hdrstop
#define INITGUID


HRESULT
NtTypeCopy(
    PNTOBJECT lpNtSrcObject,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpNtSrcObject->NTType) {

    case NT_SYNTAX_ID_BOOL:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_BOOL;
        (lpNtDestObject->NTValue).fValue =  (lpNtSrcObject->NTValue).fValue;
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_SYSTEMTIME;
        (lpNtDestObject->NTValue).stSystemTimeValue =
            (lpNtSrcObject->NTValue).stSystemTimeValue;
        break;


    case NT_SYNTAX_ID_DATE_1970:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_DATE_1970;
        (lpNtDestObject->NTValue).dwSeconds1970 =
            (lpNtSrcObject->NTValue).dwSeconds1970;
        break;



    case NT_SYNTAX_ID_DWORD:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_DWORD;
        (lpNtDestObject->NTValue).dwValue =
            (lpNtSrcObject->NTValue).dwValue;
        break;

    case NT_SYNTAX_ID_DATE:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_DATE;
        (lpNtDestObject->NTValue).dwValue =
            (lpNtSrcObject->NTValue).dwValue;
        break;

    case NT_SYNTAX_ID_LPTSTR:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_LPTSTR;

        if(!(lpNtSrcObject->NTValue).pszValue){
            (lpNtDestObject->NTValue).pszValue = NULL;
            hr = S_OK;
            goto error;
        }

        (lpNtDestObject->NTValue).pszValue =
            AllocADsStr((lpNtSrcObject->NTValue).pszValue);

        hr =((lpNtDestObject->NTValue).pszValue == NULL)
            ? E_OUTOFMEMORY :S_OK;

        break;

    case NT_SYNTAX_ID_DelimitedString:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_DelimitedString;

        if(!(lpNtSrcObject->NTValue).pszValue){
            (lpNtDestObject->NTValue).pszValue = NULL;
            hr = S_OK;
            goto error;
        }

        (lpNtDestObject->NTValue).pszValue =
            AllocADsStr((lpNtSrcObject->NTValue).pszValue);

        hr =((lpNtDestObject->NTValue).pszValue == NULL)
            ? E_OUTOFMEMORY :S_OK;

        break;

    case NT_SYNTAX_ID_NulledString:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_NulledString;

        if(!(lpNtSrcObject->NTValue).pszValue){
            (lpNtDestObject->NTValue).pszValue = NULL;
            hr = S_OK;
            goto error;
        }



        (lpNtDestObject->NTValue).pszValue =
            AllocADsStr((lpNtSrcObject->NTValue).pszValue);

        hr =((lpNtDestObject->NTValue).pszValue == NULL)
            ? E_OUTOFMEMORY :S_OK;

        break;

    case NT_SYNTAX_ID_EncryptedString:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_EncryptedString;

        if(!(lpNtSrcObject->NTValue).pszValue){
            (lpNtDestObject->NTValue).pszValue = NULL;
            hr = S_OK;
            goto error;
        }

        (lpNtDestObject->NTValue).pszValue =
            AllocADsStr((lpNtSrcObject->NTValue).pszValue);

        hr =((lpNtDestObject->NTValue).pszValue == NULL)
            ? E_OUTOFMEMORY :S_OK;

        break;

    case NT_SYNTAX_ID_OCTETSTRING:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_OCTETSTRING;
        (lpNtDestObject->NTValue).octetstring.dwSize = 
                        (lpNtSrcObject->NTValue).octetstring.dwSize;
                if ((lpNtSrcObject->NTValue).octetstring.dwSize == 0) {
                        (lpNtDestObject->NTValue).octetstring.pByte = NULL;
                }
                else {
                        (lpNtDestObject->NTValue).octetstring.pByte = 
                                        (BYTE*)AllocADsMem(sizeof(BYTE)*(lpNtSrcObject->NTValue).octetstring.dwSize);
                        if (!(lpNtDestObject->NTValue).octetstring.pByte) {
                                RRETURN(E_OUTOFMEMORY);
                        }
                        memcpy((lpNtDestObject->NTValue).octetstring.pByte, 
                                   (lpNtSrcObject->NTValue).octetstring.pByte,
                                   (lpNtSrcObject->NTValue).octetstring.dwSize);
                }

        break;

    default:
        hr = E_FAIL;
        break;
    }

error:

    RRETURN(hr);
}



HRESULT
NtTypeCopyConstruct(
    LPNTOBJECT pNtSrcObjects,
    DWORD dwNumObjects,
    LPNTOBJECT * ppNtDestObjects
    )
{

    DWORD i = 0;
    LPNTOBJECT pNtDestObjects = NULL;
    HRESULT hr = S_OK;

    pNtDestObjects = (LPNTOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NTOBJECT)
                                    );

    if (!pNtDestObjects) {
        RRETURN(E_FAIL);
    }

    //
    // Zero out so we can clear the memory on an error
    //

    memset(pNtDestObjects, 0, dwNumObjects * sizeof(NTOBJECT));

    for (i = 0; i < dwNumObjects; i++ ) {
        hr = NtTypeCopy(pNtSrcObjects + i, pNtDestObjects + i);
        BAIL_ON_FAILURE(hr);
    }

    *ppNtDestObjects = pNtDestObjects;
    
    RRETURN(S_OK);

error:

    NTTypeFreeNTObjects(pNtDestObjects, dwNumObjects);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\ntumrshl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ntumrshl.cxx
//
//  Contents:
//
//  Functions:
//
//
//  History:      17-June-1996   RamV   Created.
//
//
//  Notes :  Need to add functionality to do NulledString to NTTYPE
//           conversions
//
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma  hdrstop
#define INITGUID

HRESULT
NTTypeInit(
    PNTOBJECT pNtType
    )
{
    memset(pNtType, 0, sizeof(NTOBJECT));

    RRETURN(S_OK);
}


HRESULT
NTTypeClear(
    PNTOBJECT pNtObject
    )
{
   if(!pNtObject)
        RRETURN(S_OK);

    switch (pNtObject->NTType) {
    case NT_SYNTAX_ID_LPTSTR:
    case NT_SYNTAX_ID_DelimitedString:
    case NT_SYNTAX_ID_EncryptedString:
        FreeADsStr((pNtObject->NTValue).pszValue);
        break;
    case NT_SYNTAX_ID_NulledString:
        FreeADsMem((pNtObject->NTValue).pszValue);
        break;
    case NT_SYNTAX_ID_OCTETSTRING:
        FreeADsMem((pNtObject->NTValue).octetstring.pByte);
        break;
    default:
        break;
    }
    RRETURN(S_OK);
}


void
NTTypeFreeNTObjects(
    PNTOBJECT pNtObject,
    DWORD dwNumValues
    )
{
    DWORD i = 0;

    if (!pNtObject)     // just in case
        return;

    for (i = 0; i < dwNumValues; i++ ) {
         NTTypeClear(pNtObject + i);
    }

    FreeADsMem(pNtObject);
    pNtObject = NULL;

    return;
}


HRESULT
CopyOctetToNTOBJECT(
    PBYTE   pOctetString,
    PNTOBJECT lpNtObject
    )
{

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    lpNtObject->NTType = NT_SYNTAX_ID_OCTETSTRING;

    if(!pOctetString){
        (lpNtObject->NTValue).octetstring.dwSize = 0;
        (lpNtObject->NTValue).octetstring.pByte = NULL;
    } else {
        OctetString *pOctString = (OctetString*)pOctetString;
        (lpNtObject->NTValue).octetstring.dwSize = pOctString->dwSize;
        (lpNtObject->NTValue).octetstring.pByte = (BYTE*)AllocADsMem(sizeof(BYTE)*pOctString->dwSize);
        if (!(lpNtObject->NTValue).octetstring.pByte) {
            RRETURN(E_OUTOFMEMORY);
        }
        memcpy((lpNtObject->NTValue).octetstring.pByte, pOctString->pByte,pOctString->dwSize);
    }

    RRETURN(S_OK);
}

HRESULT
CopyDWORDToNTOBJECT(
    PDWORD pdwSrcValue,
    PNTOBJECT lpNtDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpNtDestValue){
        RRETURN(E_POINTER);
    }

    lpNtDestValue->NTType = NT_SYNTAX_ID_DWORD;
    (lpNtDestValue->NTValue).dwValue = *pdwSrcValue;

    RRETURN(hr);

}

HRESULT
CopyDATEToNTOBJECT(
    PDWORD pdwSrcValue,
    PNTOBJECT lpNtDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpNtDestValue){
        RRETURN(E_POINTER);
    }

    lpNtDestValue->NTType = NT_SYNTAX_ID_DATE;
    (lpNtDestValue->NTValue).dwValue = *pdwSrcValue;

    RRETURN(hr);

}

HRESULT
CopyBOOLToNTOBJECT(
    PBOOL pfSrcValue,
    PNTOBJECT lpNtObject
    )
{

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }


    lpNtObject->NTType = NT_SYNTAX_ID_BOOL;

    (lpNtObject->NTValue).fValue = *pfSrcValue;

    RRETURN(S_OK);

}


HRESULT
CopySYSTEMTIMEToNTOBJECT(
    PSYSTEMTIME pSysTime,
    PNTOBJECT lpNtObject
    )
{

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    (lpNtObject->NTValue).stSystemTimeValue = *pSysTime;
    lpNtObject->NTType = NT_SYNTAX_ID_SYSTEMTIME;

    RRETURN(S_OK);
}

HRESULT
CopyLPTSTRToNTOBJECT(
    LPTSTR   pszSrcValue,
    PNTOBJECT lpNtObject
    )
{
    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    lpNtObject->NTType = NT_SYNTAX_ID_LPTSTR;

    if(!pszSrcValue){
        (lpNtObject->NTValue). pszValue = NULL;
    } else {

        (lpNtObject->NTValue). pszValue = AllocADsStr(pszSrcValue);
        
        if (!((lpNtObject->NTValue). pszValue)){
            RRETURN(E_OUTOFMEMORY);
        }
    }
    RRETURN(S_OK);
}


HRESULT
CopyDelimitedStringToNTOBJECT(
    LPTSTR   pszSrcValue,
    PNTOBJECT lpNtObject,
    DWORD   dwElements
    )
{

    LPTSTR pszCurrPos = NULL;
    LONG i;
    WCHAR Delimiter = L',';
    HRESULT hr = S_OK;

    if(!pszSrcValue){
        RRETURN(E_POINTER);
    }

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    //
    // scan string  and put the appropriate pointers
    //

    pszCurrPos = pszSrcValue;

    //
    // Fill up the NtObject structure
    //

    lpNtObject[0].NTType = NT_SYNTAX_ID_DelimitedString;
    (lpNtObject[0].NTValue).pszValue = AllocADsStr(pszCurrPos);
    
    if (!(lpNtObject[0].NTValue). pszValue){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    i = 1;

    while(i < (LONG)dwElements){

        if(*pszCurrPos == TEXT('\0')){

            lpNtObject[i].NTType = NT_SYNTAX_ID_DelimitedString;
            (lpNtObject[i].NTValue).pszValue = AllocADsStr(++pszCurrPos);
            
            if (!(lpNtObject[i].NTValue).pszValue){
                hr = E_OUTOFMEMORY;
                goto error;
            }
            i++;
        }

        pszCurrPos++;
    }

error:

    RRETURN(hr);
}


HRESULT
CopyNulledStringToNTOBJECT(
    LPTSTR   pszSrcValue,
    PNTOBJECT lpNtObject,
    DWORD   dwElements
    )
{

    LPTSTR pszCurrPos = NULL;
    LONG i;
    HRESULT hr = S_OK;

    if(!pszSrcValue){
        RRETURN(E_POINTER);
    }

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    //
    // scan string  and put the appropriate pointers
    //

    pszCurrPos = pszSrcValue;

    //
    // Fill up the NtObject structure
    //

    lpNtObject[0].NTType = NT_SYNTAX_ID_NulledString;
    (lpNtObject[0].NTValue).pszValue = AllocADsStr(pszCurrPos);
    
    if (!(lpNtObject[0].NTValue). pszValue){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    i = 1;

    while(i < (LONG)dwElements){

        if(*pszCurrPos == TEXT('\0')){

            lpNtObject[i].NTType = NT_SYNTAX_ID_NulledString;
            (lpNtObject[i].NTValue).pszValue = AllocADsStr(++pszCurrPos);
            
            if (!(lpNtObject[i].NTValue).pszValue){
                hr = E_OUTOFMEMORY;
                goto error;
            }
            i++;
        }

        pszCurrPos++;
    }

error:

    RRETURN(hr);
}


HRESULT
CopySeconds70ToNTOBJECT(
    PDWORD pdwSrcValue,
    PNTOBJECT lpNtDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpNtDestValue){
        RRETURN(E_POINTER);
    }

    lpNtDestValue->NTType = NT_SYNTAX_ID_DATE_1970;
    (lpNtDestValue->NTValue).dwSeconds1970 = *pdwSrcValue;

    RRETURN(hr);

}


HRESULT
CopyNTToNTSynId(
    DWORD dwSyntaxId,
    LPBYTE lpByte,
    PNTOBJECT lpNTObject,
    DWORD dwNumValues
    )
{
    HRESULT hr = S_OK;

    switch (dwSyntaxId) {
    case NT_SYNTAX_ID_BOOL:

        hr = CopyBOOLToNTOBJECT(
                         (PBOOL)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:
        hr = CopySYSTEMTIMEToNTOBJECT(
                         (PSYSTEMTIME)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_DWORD:
        hr = CopyDWORDToNTOBJECT(
                         (PDWORD)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_DelimitedString:
        hr = CopyDelimitedStringToNTOBJECT(
                         (LPTSTR)lpByte,
                         lpNTObject,
                         dwNumValues
                         );
        break;

    case NT_SYNTAX_ID_NulledString:
        hr = CopyNulledStringToNTOBJECT(
                         (LPTSTR)lpByte,
                         lpNTObject,
                         dwNumValues
                         );
        break;

    case NT_SYNTAX_ID_LPTSTR:
        hr = CopyLPTSTRToNTOBJECT(
                         (LPTSTR)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_DATE_1970:
        hr = CopySeconds70ToNTOBJECT(
                         (PDWORD)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_DATE :
        hr = CopyDATEToNTOBJECT(
                         (PDWORD)lpByte,
                         lpNTObject
                         );                         
        break;

    case NT_SYNTAX_ID_OCTETSTRING:
        hr = CopyOctetToNTOBJECT(
                         lpByte,
                         lpNTObject
                         );
        break;

    default:
        break;

    }

    RRETURN(hr);
}



//
//  NT is single-valued except for Delimited and Nulled Strings
//

HRESULT
UnMarshallNTToNTSynId(
    DWORD dwSyntaxId,
    DWORD dwNumValues,
    LPBYTE lpValue,
    PNTOBJECT * ppNTObject
    )
{
    LPBYTE lpByte = lpValue;
    DWORD  i = 0;
    PNTOBJECT pNTObject = NULL;
    HRESULT hr = S_OK;

    pNTObject = (PNTOBJECT)AllocADsMem(
                            sizeof(NTOBJECT)*dwNumValues
                            );

    if (!pNTObject) {
        RRETURN(E_FAIL);
    }

    hr = CopyNTToNTSynId(
                     dwSyntaxId,
                     lpByte,
                     pNTObject,
                     dwNumValues
                     );
    BAIL_ON_FAILURE(hr);


    *ppNTObject = pNTObject;
    
    RRETURN(hr);
error:
    if(pNTObject){
        NTTypeFreeNTObjects(pNTObject, dwNumValues);
    }
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\object.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  object.cxx
//
//  Contents:  Windows NT 3.5 Enumerator Code
//
//  History:
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop

HRESULT
BuildObjectArray(
    VARIANT var,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    );

HRESULT
BuildDefaultObjectArray(
    PFILTERS  pFilters,
    DWORD dwMaxFilters,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    );


ObjectTypeList::ObjectTypeList()
{
    _pObjList = NULL;
    _dwCurrentIndex = 0;
    _dwMaxElements = 0;
    _dwUBound  = 0;
    _dwLBound = 0;

}


HRESULT
ObjectTypeList::CreateObjectTypeList(
    VARIANT vFilter,
    ObjectTypeList ** ppObjectTypeList
    )
{
    ObjectTypeList * pObjectTypeList = NULL;
    HRESULT hr = S_OK;

    pObjectTypeList = new ObjectTypeList;

    if (!pObjectTypeList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildObjectArray(
            vFilter,
            &pObjectTypeList->_pObjList,
            &pObjectTypeList->_dwMaxElements
            );

    if (FAILED(hr)) {

        hr = BuildDefaultObjectArray(
                gpFilters,
                gdwMaxFilters,
                &pObjectTypeList->_pObjList,
                &pObjectTypeList->_dwMaxElements
                );

        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetUBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwUBound
                );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetLBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwLBound
                );
    BAIL_ON_FAILURE(hr);

    pObjectTypeList->_dwCurrentIndex = pObjectTypeList->_dwLBound;

    *ppObjectTypeList = pObjectTypeList;

    RRETURN(S_OK);


error:
    if (pObjectTypeList) {
        delete pObjectTypeList;
    }
    RRETURN_EXP_IF_ERR(hr);

}


ObjectTypeList::~ObjectTypeList()
{
    HRESULT hr = S_OK;
    if (_pObjList) {
        hr = SafeArrayDestroy(_pObjList);
    }
}


HRESULT
ObjectTypeList::GetCurrentObject(
    PDWORD pdwObject
    )
{
    HRESULT hr = S_OK;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    hr = SafeArrayGetElement(
                    _pObjList,
                    (long FAR *)&_dwCurrentIndex,
                    (void *)pdwObject
                    );
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
ObjectTypeList::Next()
{
    HRESULT hr = S_OK;

    _dwCurrentIndex++;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    RRETURN_EXP_IF_ERR(hr);
}



HRESULT
ObjectTypeList::Reset()
{
    HRESULT hr = S_OK;

    _dwCurrentIndex = _dwLBound;

    return(hr);

}


HRESULT
IsValidFilter(
    LPWSTR ObjectName,
    DWORD *pdwFilterId,
    PFILTERS pFilters,
    DWORD dwMaxFilters
    )
{

    DWORD i = 0;

    for (i = 0; i < dwMaxFilters; i++) {

#ifdef WIN95
        if (!_wcsicmp(ObjectName, (pFilters + i)->szObjectName)) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                ObjectName,
                -1,
                (pFilters +i)->szObjectName,
                -1
                ) == CSTR_EQUAL ) {
#endif
            *pdwFilterId = (pFilters + i)->dwFilterId;
            RRETURN(S_OK);
        }

    }
    *pdwFilterId = 0;
    RRETURN(E_FAIL);
}



HRESULT
BuildDefaultObjectArray(
    PFILTERS  pFilters,
    DWORD dwMaxFilters,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    DWORD i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;

    sabNewArray.cElements = dwMaxFilters;
    sabNewArray.lLbound =  0;

    pFilter =   SafeArrayCreate(
                        VT_I4,
                        1,
                        &sabNewArray
                        );
    if (!pFilter){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < dwMaxFilters; i++) {

        hr = SafeArrayPutElement(
                pFilter,
                (long *)&i,
                (void *)&((pFilters + i)->dwFilterId)
            );
        BAIL_ON_FAILURE(hr);
    }

    *ppFilter = pFilter;
    *pdwNumElements = dwMaxFilters;

    RRETURN(S_OK);

error:
    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}



HRESULT
BuildObjectArray(
    VARIANT var,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    LONG uDestCount = 0;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    VARIANT varDest;
    LONG i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    DWORD dwFilterId;
    SAFEARRAY * pFilter = NULL;

    if (!(V_VT(&var) == (VT_VARIANT|VT_ARRAY))) {
        RRETURN(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    sabNewArray.cElements = dwSUBound - dwSLBound + 1;
    sabNewArray.lLbound = dwSLBound;

    pFilter = SafeArrayCreate(
                    VT_I4,
                    1,
                    &sabNewArray
                    );


    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        if (FAILED(hr)) {
            continue;
        }


        hr = IsValidFilter(
                V_BSTR(&v),
                &dwFilterId,
                gpFilters,
                gdwMaxFilters
                );

        if (FAILED(hr)) {

            VariantClear(&v);
            continue;
        }

        VariantClear(&v);

        hr = SafeArrayPutElement(
                pFilter,
                (long*)&uDestCount,
                (void *)&dwFilterId
                );

        if(FAILED(hr)){
            continue;
        }

        uDestCount++;

    }

    //
    // There was nothing of value that could be retrieved from the
    // filter.
    //

    if ( !uDestCount) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    *pdwNumElements  = uDestCount;
    *ppFilter = pFilter;

    RRETURN(S_OK);

error:

    if (pFilter) {

        SafeArrayDestroy(pFilter);
    }
    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\ods2nt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ods2nw.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop



HRESULT
AdsTypeToNTTypeCopyCaseIgnoreString(
    PADSVALUE lpAdsSrcValue,
    PNTOBJECT lpNtDestObject
    )

{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_IGNORE_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNtDestObject->NTType = NT_SYNTAX_ID_LPTSTR;

    lpNtDestObject->NTValue.pszValue =
                        AllocADsStr(
                            lpAdsSrcValue->CaseIgnoreString
                        );

    RRETURN(hr);

}


HRESULT
AdsTypeToNTTypeCopyBoolean(
    PADSVALUE lpAdsSrcValue,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_BOOLEAN){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNtDestObject->NTType = NT_SYNTAX_ID_BOOL;

    lpNtDestObject->NTValue.fValue =
                        lpAdsSrcValue->Boolean;

    RRETURN(hr);
}


HRESULT
AdsTypeToNTTypeCopyInteger(
    PADSVALUE lpAdsSrcValue,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_INTEGER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNtDestObject->NTType = NT_SYNTAX_ID_DWORD;

    lpNtDestObject->NTValue.dwValue =
                                lpAdsSrcValue->Integer;

    RRETURN(hr);
}

HRESULT
AdsTypeToNTTypeCopy(
    PADSVALUE lpAdsSrcValue,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpAdsSrcValue->dwType){

    case ADSTYPE_CASE_IGNORE_STRING:
        hr = AdsTypeToNTTypeCopyCaseIgnoreString(
                lpAdsSrcValue,
                lpNtDestObject
                );
        break;

    case ADSTYPE_BOOLEAN:
        hr = AdsTypeToNTTypeCopyBoolean(
                lpAdsSrcValue,
                lpNtDestObject
                );
        break;

    case ADSTYPE_INTEGER:
        hr = AdsTypeToNTTypeCopyInteger(
                lpAdsSrcValue,
                lpNtDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
AdsTypeToNTTypeCopyConstruct(
    LPADSVALUE pAdsSrcValues,
    DWORD dwNumObjects,
    LPNTOBJECT * ppNtDestObjects,
    PDWORD pdwNumNdsObjects,
    PDWORD pdwNdsSyntaxId
    )
{

    DWORD i = 0;
    LPNTOBJECT pNtDestObjects = NULL;
    HRESULT hr = S_OK;

    pNtDestObjects = (LPNTOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NTOBJECT)
                                    );

    if (!pNtDestObjects) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = AdsTypeToNTTypeCopy(
                    pAdsSrcValues + i,
                    pNtDestObjects + i
                    );
         BAIL_ON_FAILURE(hr);

     }

     *ppNtDestObjects = pNtDestObjects;
     *pdwNumNdsObjects = dwNumObjects;
     *pdwNdsSyntaxId = pNtDestObjects->NTType;
     RRETURN(S_OK);

error:

     NTTypeFreeNTObjects(
                pNtDestObjects,
                dwNumObjects
                );

     *ppNtDestObjects = NULL;
     *pdwNumNdsObjects = 0;

     RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\ntmrshl.cxx ===
//-------------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ntmrshl.cxx
//
//  Contents:
//
//  Functions:
//
//  History:      17-June-1996   RamV   Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma  hdrstop
#define INITGUID

HRESULT
CopyNTOBJECTToOctet(
    PNTOBJECT pNtSrcObject,
    OctetString *pOctet
    )
{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_OCTETSTRING)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    pOctet->dwSize = (pNtSrcObject->NTValue).octetstring.dwSize;
    pOctet->pByte = (BYTE*)AllocADsMem(sizeof(BYTE) * (pNtSrcObject->NTValue).octetstring.dwSize);
    if (!pOctet->pByte) {
        RRETURN(E_OUTOFMEMORY);
    }
    memcpy(pOctet->pByte, 
           (pNtSrcObject->NTValue).octetstring.pByte, 
           (pNtSrcObject->NTValue).octetstring.dwSize);
    RRETURN(S_OK);

}

HRESULT
CopyNTOBJECTToDWORD(
    PNTOBJECT pNtSrcObject,
    PDWORD   pdwRetval
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }
    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_DWORD)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pdwRetval = (pNtSrcObject->NTValue).dwValue;

    RRETURN(S_OK);

}

HRESULT
CopyNTOBJECTToDATE(
    PNTOBJECT pNtSrcObject,
    PDWORD   pdwRetval
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }
    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_DATE)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pdwRetval = (pNtSrcObject->NTValue).dwValue;

    RRETURN(S_OK);

}

HRESULT
CopyNTOBJECTToDATE70(
    PNTOBJECT pNtSrcObject,
    PDWORD   pdwRetval
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }
    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_DATE_1970)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pdwRetval = (pNtSrcObject->NTValue).dwSeconds1970;

    RRETURN(S_OK);

}


HRESULT
CopyNTOBJECTToBOOL(
    PNTOBJECT pNtSrcObject,
    PBOOL   pfRetval
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_BOOL)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pfRetval = (pNtSrcObject->NTValue).fValue;

    RRETURN(S_OK);

}


HRESULT
CopyNTOBJECTToSYSTEMTIME(
    PNTOBJECT pNtSrcObject,
    SYSTEMTIME *pstRetVal
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_SYSTEMTIME)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pstRetVal = (pNtSrcObject->NTValue).stSystemTimeValue;

    RRETURN(S_OK);

}

HRESULT
CopyNTOBJECTToLPTSTR(
    PNTOBJECT pNtSrcObject,
    LPTSTR  *ppszRetval
    )
{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_LPTSTR)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *ppszRetval = AllocADsStr((pNtSrcObject->NTValue).pszValue);

    if (! *ppszRetval && ((pNtSrcObject->NTValue).pszValue)){
        RRETURN(E_OUTOFMEMORY);
    }
    RRETURN(S_OK);

}

HRESULT
CopyNTOBJECTToDelimitedString(
    PNTOBJECT pNtSrcObject,
    DWORD   dwNumValues,
    LPTSTR  *ppszRetval
    )
{

    DWORD i= 0;
    HRESULT hr = S_OK;
    WCHAR szDelimStr[MAX_PATH];
    LPWSTR Delimiter = TEXT(",");

    if (!dwNumValues){
        *ppszRetval = NULL;
        RRETURN(S_OK);
    }

    wcscpy(szDelimStr, TEXT("")); // empty contents

    if(!pNtSrcObject){
        hr = E_POINTER;
        goto error;
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_DelimitedString)){
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        goto error;
    }

    for(i=0; i<dwNumValues; i++){
        
        if(i>0){
            wcscat(szDelimStr, Delimiter);
        }
        wcscat(szDelimStr, pNtSrcObject[i].NTValue.pszValue);
        
    }

    
    *ppszRetval = AllocADsStr(szDelimStr);

    if(*ppszRetval == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }

error:
    RRETURN(hr);
}

HRESULT
CopyNTOBJECTToNulledString(
    PNTOBJECT pNtSrcObject,
    DWORD   dwNumValues,
    LPTSTR  *ppszRetval
    )
{

    DWORD i= 0;
    HRESULT hr = S_OK;
    LPWSTR pszNullStr = 0;
    WORD   wStrLen = 0;

    if (!dwNumValues){
        *ppszRetval = NULL;
        RRETURN(S_OK);
    }

    pszNullStr = (LPWSTR)AllocADsMem(MAX_PATH); //max length of nulled string

    if(!pszNullStr){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    wcscpy(pszNullStr, TEXT("")); // empty contents

    if(!pNtSrcObject){
        hr = E_POINTER;
        goto error;
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_NulledString)){
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        goto error;
    }

    for(i=0; i<dwNumValues; i++){
        
        wcscpy(pszNullStr+wStrLen, pNtSrcObject[i].NTValue.pszValue);
        wStrLen += wcslen(pszNullStr+wStrLen) + 1;
    }

    wcscpy(pszNullStr + wStrLen, TEXT(""));
    
    *ppszRetval = pszNullStr;

error:
    RRETURN(hr);
}




/* Delete after new implementation works fully 

HRESULT
CopyNTOBJECTToNulledString(
    PNTOBJECT pNtSrcObject,
    LPTSTR  *ppszRetval
    )
{
    HRESULT hr = S_OK;

    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_NulledString)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = CopyNulledString((pNtSrcObject->NTValue).pszValue,
                          ppszRetval );

    if ( FAILED (hr)){
        RRETURN(hr);
    }
    RRETURN(S_OK);
}


*/


HRESULT
CopyNTOBJECTToNT(
    DWORD dwSyntaxId,
    PNTOBJECT lpNTObject,
    LPBYTE lpByte
    )
{

    HRESULT hr = S_OK;

    switch (dwSyntaxId) {
    case NT_SYNTAX_ID_BOOL:
        hr = CopyNTOBJECTToBOOL(
                         lpNTObject,
                         (PBOOL)lpByte
                         );
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:
        hr = CopyNTOBJECTToSYSTEMTIME(
                         lpNTObject,
                         (PSYSTEMTIME)lpByte
                         );
        break;

    case NT_SYNTAX_ID_DWORD:
        hr = CopyNTOBJECTToDWORD(
                         lpNTObject,
                         (PDWORD)lpByte
                         );
        break;

    case NT_SYNTAX_ID_DATE:
        hr = CopyNTOBJECTToDATE(
                         lpNTObject,
                         (PDWORD)lpByte
                         );
        break;


    case NT_SYNTAX_ID_DATE_1970:
        hr = CopyNTOBJECTToDATE70(
                         lpNTObject,
                         (PDWORD)lpByte
                         );
        break;

    case NT_SYNTAX_ID_LPTSTR:
        hr = CopyNTOBJECTToLPTSTR(
                         lpNTObject,
                         (LPTSTR *)lpByte
                         );
        break;

    case NT_SYNTAX_ID_OCTETSTRING:
        hr = CopyNTOBJECTToOctet(
                         lpNTObject,
                         (OctetString *)lpByte
                         );
        break;

    default:
        break;

    }

    RRETURN(hr);
}


HRESULT
MarshallNTSynIdToNT(
    DWORD dwSyntaxId,
    PNTOBJECT pNTObject,
    DWORD dwNumValues,
    LPBYTE lpValue
    )
{

    HRESULT hr = S_OK;
    DWORD  i = 0;

    //
    // Loop below does not really handle case other than 1 value
    //

    //
    // For handling multivalued cases, the loop is unnecessary
    //

    if(dwSyntaxId == NT_SYNTAX_ID_DelimitedString)  {
        hr = CopyNTOBJECTToDelimitedString (
                 pNTObject,
                 dwNumValues,
                 (LPWSTR *)lpValue
                 );

    } else if (dwSyntaxId == NT_SYNTAX_ID_NulledString) {
        hr = CopyNTOBJECTToNulledString(
                pNTObject,
                dwNumValues,
                (LPWSTR *) lpValue
                );

    } else {
        for (i = 0; i < dwNumValues; i++) {
            
            hr  = CopyNTOBJECTToNT(
                     dwSyntaxId,
                     (pNTObject + i) ,
                     lpValue
                     );

        }
    }

        RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\parse.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  parse.cxx
//
//  Contents:  Windows NT 3.5 GetObject functionality
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

KWDLIST KeywordList[MAX_KEYWORDS] =
{
    { TOKEN_DOMAIN, L"domain"},
    { TOKEN_USER, L"user"},
    { TOKEN_GROUP, L"group"},
    { TOKEN_LOCALGROUP, L"localgroup"},
    { TOKEN_GLOBALGROUP, L"globalgroup"},
    { TOKEN_COMPUTER, L"computer"},
    { TOKEN_PRINTER, L"printqueue"},
    { TOKEN_SERVICE, L"service"},
    { TOKEN_FILESERVICE, L"fileservice"},
    { TOKEN_SCHEMA, L"schema"},
    { TOKEN_CLASS, L"class"},
    { TOKEN_PROPERTY, L"property"},
    { TOKEN_SYNTAX, L"syntax"},
    { TOKEN_FILESHARE, L"fileshare"},
    { TOKEN_NAMESPACE, L"namespace"},
    { TOKEN_WORKGROUP, L"workgroup"}
};


// Object -> PathName, Type, eos
// Object -> PathName, eos

//+---------------------------------------------------------------------------
//  Function:
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
Object(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = ProviderName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    switch (dwToken) {
    case TOKEN_END:
        RRETURN(S_OK);

    case TOKEN_COMMA:
        hr = Type(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);
        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);
        if (dwToken == TOKEN_END) {
            RRETURN(S_OK);
        }else {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    default:
        hr = pTokenizer->PushBackToken();


        hr = DsPathName(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        switch (dwToken) {
        case TOKEN_END:
            RRETURN(S_OK);

        case TOKEN_COMMA:
            hr = Type(pTokenizer, pObjectInfo);
            BAIL_IF_ERROR(hr);
            hr = pTokenizer->GetNextToken(szToken, &dwToken);
            BAIL_IF_ERROR(hr);
            if (dwToken == TOKEN_END) {
                RRETURN(S_OK);
            }else {
                RRETURN(E_ADS_BAD_PATHNAME);
            }

        default:
            RRETURN(E_FAIL);

        }

    }

cleanup:
    RRETURN(hr);
}






HRESULT
ProviderName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_ATSIGN) {

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        if (dwToken != TOKEN_IDENTIFIER) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_EXCLAMATION) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else if (dwToken == TOKEN_IDENTIFIER) {

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_COLON) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // You can now disable the processing for "@" and "!" treat them
    // as ordinary characters.
    //

    pTokenizer->SetAtDisabler(TRUE);

    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}


// PathName -> Component \\ PathName
// PathName -> Component


HRESULT
DsPathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_FSLASH) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_FSLASH) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = PathName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}




//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
PathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    HRESULT hr;
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;

    hr = Component(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = pTokenizer->GetNextToken(szToken, &dwToken);

    if (dwToken == TOKEN_FSLASH) {
        RRETURN (PathName(pTokenizer, pObjectInfo));
    }else {
        hr = pTokenizer->PushBackToken();
        RRETURN (S_OK);
    }
cleanup:
    RRETURN(hr);
}

// Component -> <identifier>





//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
Component(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    WCHAR szDisplayToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, szDisplayToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken != TOKEN_IDENTIFIER) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = AddComponent(pObjectInfo, szToken, szDisplayToken);
    BAIL_IF_ERROR(hr);

    RRETURN(S_OK);
cleanup:
    RRETURN(hr);
}

// Type -> "user", "group","printer","service", "fileservice"

//+---------------------------------------------------------------------------
// Function:    Type
//
// Synopsis:    Parses Type-> "user" | "group" etc
//
// Arguments:   [CLexer * pTokenizer]
//              [POBJECTINFo pObjectInfo]
//
// Returns:     HRESULT
//
// Modifies:    -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------


HRESULT
Type(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_PATH];
    DWORD dwToken;
    HRESULT hr;
    WCHAR *pszToken = szToken;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_IDENTIFIER ) {

        while (*pszToken == L' ') {
            //
            // remove leading spaces
            //
            pszToken++;
        }
    
        if (pTokenizer->IsKeyword(pszToken, &dwToken)) {
            hr = SetType(pObjectInfo, dwToken);
            RRETURN(hr);
        }
    }

    RRETURN(E_ADS_BAD_PATHNAME);

cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CLexer::CLexer(LPWSTR szBuffer):
                _ptr(NULL),
                _Buffer(NULL),
                _dwLastTokenLength(0),
                _dwLastToken(0),
                _dwEndofString(0),
                _bAtDisabled(FALSE)
{
    if (!szBuffer || !*szBuffer) {
        return;
    }
    _Buffer = AllocADsStr(szBuffer);
    _ptr = _Buffer;
}

HRESULT CLexer::SetBuffer(LPWSTR szBuffer)
{
    if (!szBuffer || !*szBuffer) {
        return E_INVALIDARG;
    }
    _Buffer = AllocADsStr(szBuffer);
    if(NULL == _Buffer)
        return E_OUTOFMEMORY;

    _ptr = _Buffer;
    return S_OK;
}    

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    08-12-96   t-danal     Created.
//
//----------------------------------------------------------------------------
CLexer::~CLexer()
{
    if(_Buffer != NULL)
        FreeADsStr(_Buffer);
}



//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::GetNextToken(LPWSTR szToken, LPWSTR szDisplayToken, LPDWORD pdwToken)
{
    WCHAR c;
    DWORD state = 0;
    LPWSTR pch = szToken;
    LPWSTR pDisplayCh = szDisplayToken;
    BOOL fEscapeOn = FALSE, fQuotingOn = FALSE;

    memset(szToken, 0, sizeof(WCHAR) * MAX_TOKEN_LENGTH);

    if (szDisplayToken) {
        memset(szDisplayToken, 0, sizeof(TCHAR) * MAX_TOKEN_LENGTH);
    }

    _dwLastTokenLength = 0;
    while (1) {
        
        //
        // if _dwLastTokenLength is greater than MAX_TOKEN_LENGTH-1,
        // then we are already at the buffer end, so return E_ADS_BAD_PARAMETER
        //

        if (_dwLastTokenLength > MAX_TOKEN_LENGTH -1 ) {
            RRETURN(E_ADS_BAD_PARAMETER);
        }
        
        c = NextChar();
        switch (state) {
        case  0:
            *pch++ = c;
            _dwLastTokenLength++;

            if (c == TEXT('"')) {
                //
                // Quoting;
                //

                fQuotingOn = TRUE;

                pch--;
                state = 1;

            }else if (c == TEXT('\\')) {
                //
                // Escaping; Ignore the '\' in the token and check to make
                // sure that the next character exists
                //
                pch--;

                fEscapeOn = TRUE;

                state = 1;

            }else if (c == L'/') {
                *pdwToken = TOKEN_FSLASH;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L',') {
                *pdwToken = TOKEN_COMMA;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L':'){
                if (!_bAtDisabled) {
                    *pdwToken = TOKEN_COLON;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);
                }else {
                    state = 1;
                }
            }else if (c == TEXT('<')) {
                RRETURN(E_FAIL);
            }else if (c == TEXT('>')) {
                RRETURN(E_FAIL);
            }else if (c == L'\0'){
                *pdwToken = TOKEN_END;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'@') {

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_ATSIGN;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {
                    state = 1;
                }

            }else if (c == L'!'){

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_EXCLAMATION;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {
                    state = 1;
                }

            }else {

                state = 1;
            }
            break;

        case 1:

            if ((fEscapeOn || fQuotingOn) && c == TEXT('\0') ) {
                RRETURN(E_FAIL);
            }
            else if (fEscapeOn) {
                fEscapeOn = FALSE;
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            }
            else if (fQuotingOn) {
                if (c == TEXT('"')) {
                    fQuotingOn = FALSE;
                }
                else {
                    *pch++ = c;
                }
                _dwLastTokenLength++;
                break;
            }
            else if (c == TEXT('\\') ) {
                fEscapeOn = TRUE;
                _dwLastTokenLength++;

                break;

            }
            else if (c == TEXT('"')) {
                fQuotingOn = TRUE;
                _dwLastTokenLength++;
                break;
            }
            if (c == L'\0' || c == L',' ||
                    c == L'/') {
                PushbackChar();

                *pdwToken = TOKEN_IDENTIFIER;
                _dwLastToken = *pdwToken;
                RRETURN (S_OK);
            }else if (c == L'@' || c == L'!' || c == TEXT(':')) {

                if (!_bAtDisabled) {

                    PushbackChar();

                    *pdwToken = TOKEN_IDENTIFIER;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {

                    *pch++ = c;
                    _dwLastTokenLength++;
                    state = 1;
                    break;

                }

            }else {
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            }
        default:
            RRETURN(E_FAIL);
        }

        if (pDisplayCh) {
            *pDisplayCh++ = c;
        }

    }
}

HRESULT
CLexer::GetNextToken(LPWSTR szToken, LPDWORD pdwToken)
{
    RRETURN (GetNextToken(szToken, NULL, pdwToken));
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
WCHAR
CLexer::NextChar()
{
    if (_ptr == NULL || *_ptr == L'\0') {
        _dwEndofString = TRUE;
        return(L'\0');
    }
    return(*_ptr++);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::PushBackToken()
{
    if (_dwLastToken == TOKEN_END) {
        RRETURN(S_OK);
    }
    _ptr -= _dwLastTokenLength;

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
void
CLexer::PushbackChar()
{
    if (_dwEndofString) {
        return;
    }
    _ptr--;

}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
BOOL
CLexer::IsKeyword(LPWSTR szToken, LPDWORD pdwToken)
{
    DWORD i = 0;

    for (i = 0; i < MAX_KEYWORDS; i++) {
        if (!_wcsicmp(szToken, KeywordList[i].Keyword)) {
            *pdwToken = KeywordList[i].dwTokenId;
            return(TRUE);
        }
    }
    *pdwToken = 0;
    return(FALSE);
}


//+---------------------------------------------------------------------------
//Function:
//
//Synopsis:
//
//Arguments:
//
//Returns:
//
//Modifies:
//
//History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
AddComponent(POBJECTINFO pObjectInfo, LPWSTR szToken, LPWSTR szDisplayToken)
{
    if (!szToken || !*szToken || !szDisplayToken || !*szDisplayToken) {
    }
    pObjectInfo->ComponentArray[pObjectInfo->NumComponents] =
                    AllocADsStr(szToken);

    pObjectInfo->DisplayComponentArray[pObjectInfo->NumComponents] =
                    AllocADsStr(szToken);

    pObjectInfo->NumComponents++;

    RRETURN(S_OK);

}

HRESULT
AddProviderName(POBJECTINFO pObjectInfo, LPWSTR szToken)
{
    if (!szToken || !*szToken) {
        RRETURN(E_FAIL);
    }

    pObjectInfo->ProviderName = AllocADsStr(szToken);

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
SetType(POBJECTINFO pObjectInfo, DWORD dwToken)
{
    pObjectInfo->ObjectType = dwToken;
    RRETURN(S_OK);
}


void
CLexer::SetAtDisabler(
    BOOL bFlag
    )
{
    _bAtDisabled = bFlag;
}

BOOL
CLexer::GetAtDisabler()
{
    return(_bAtDisabled);
}


HRESULT
GetDisplayName(
    LPWSTR szName,
    LPWSTR *ppszDisplayName
    )
{

    HRESULT hr = S_OK;
    DWORD len = 0;
    LPWSTR pch = szName;
    LPWSTR pszDisplayCh = NULL, pszDisplay = NULL;
    BOOL fQuotingOn = FALSE;

    if (!ppszDisplayName ) {
        RRETURN (E_INVALIDARG);
    }

    *ppszDisplayName = NULL;

    if (!szName) {
        RRETURN (S_OK);
    }

    pch = szName;
    fQuotingOn = FALSE;

    for (len=0; *pch; pch++, len++) {
        if ((!(pch > szName && *(pch-1) == '\\')) &&
            (*pch == L'"') ) {
            fQuotingOn = ~fQuotingOn;
        }
        else if (!fQuotingOn && (!(pch > szName && *(pch-1) == '\\')) &&
            (*pch == L'/' || *pch == L'<' || *pch == L'>') ) {
            len++;
        }
    }

    pszDisplay = (LPWSTR) AllocADsMem((len+1) * sizeof(WCHAR));

    if (!pszDisplay) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pch = szName;
    pszDisplayCh = pszDisplay;
    fQuotingOn = FALSE;

    for (; *pch; pch++, pszDisplayCh++) {
        if ((!(pch > szName && *(pch-1) == '\\')) &&
            (*pch == L'"') ) {
            fQuotingOn = ~fQuotingOn;
        }
        else if (!fQuotingOn && (!(pch > szName && *(pch-1) == '\\')) &&
            (*pch == L'/' || *pch == L'<' || *pch == L'>') ) {
            *pszDisplayCh++ = L'\\';
        }
        *pszDisplayCh = *pch;
    }

    *pszDisplayCh = L'\0';

    *ppszDisplayName = pszDisplay;

error:

    RRETURN(hr);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\nttypes.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       nttypes.h
//
//  Contents:    Types for generic Get and Put
//
//  Functions:
//
//
//  History:      14-June-1996   RamV   Cloned off nds code.
//
//----------------------------------------------------------------------------

//
// various values of NT types
//

#define NT_SYNTAX_ID_BOOL                     1
#define NT_SYNTAX_ID_SYSTEMTIME               2
#define NT_SYNTAX_ID_DWORD                    3
#define NT_SYNTAX_ID_LPTSTR                   4
#define NT_SYNTAX_ID_DelimitedString          5
#define NT_SYNTAX_ID_NulledString             6
#define NT_SYNTAX_ID_DATE                     7 // internally treated as DWORD
#define NT_SYNTAX_ID_DATE_1970                8
#define NT_SYNTAX_ID_OCTETSTRING              9
#define NT_SYNTAX_ID_EncryptedString          10

typedef struct _octetstring {
    DWORD dwSize;
    BYTE *pByte;
} OctetString;

typedef struct _nttype{
    DWORD NTType;
    union {
        DWORD dwValue;
        LPTSTR pszValue;
        SYSTEMTIME stSystemTimeValue;
        BOOL       fValue;
        DWORD   dwSeconds1970;
        OctetString octetstring;
    }NTValue;

    //
    // for both Delimited and Nulled Strings we use pszValue
    //
}NTOBJECT, *PNTOBJECT, *LPNTOBJECT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\printhlp.cxx ===
/*++

  Copyright (c) 1996  Microsoft Corporation

  Module Name:

  printhlp.cxx

  Abstract:
  Helper functions for printer object

  Author:

  Ram Viswanathan ( ramv)
  Revision History:


  --*/



#include "winnt.hxx"
#pragma hdrstop

/*+------------------------------------------------------------------------
 *           Helper functions follow
 *-------------------------------------------------------------------------
 */

//
// mapping WinNT Status Codes to ADs Status Codes and vice versa
//

typedef struct _PrintStatusList {
    DWORD  dwWinNTPrintStatus;
    DWORD dwADsPrintStatus;
} PRINT_STATUS_LIST, *PPRINT_STATUS_LIST;


PRINT_STATUS_LIST PrintStatusList[] =
{
{PRINTER_STATUS_PAUSED, ADS_PRINTER_PAUSED},
{PRINTER_STATUS_PENDING_DELETION, ADS_PRINTER_PENDING_DELETION}
};

BOOL PrinterStatusWinNTToADs( DWORD dwWinNTStatus,
DWORD *pdwADsStatus)

{
    BOOL found = FALSE;
    int i;

    for (i=0;i<2;i++){

        if(dwWinNTStatus == PrintStatusList[i].dwWinNTPrintStatus){
            *pdwADsStatus = PrintStatusList[i].dwADsPrintStatus;
            found = TRUE;
            break;
        }
    }
    return (found);
}


BOOL PrinterStatusADsToWinNT( DWORD dwADsStatus,
                               DWORD *pdwWinNTStatus)
{
    BOOL found = FALSE;
    int i;

    for (i=0;i<2;i++){

        if(dwADsStatus == PrintStatusList[i].dwADsPrintStatus){
            *pdwWinNTStatus = PrintStatusList[i].dwWinNTPrintStatus;
            found = TRUE;
            break;
        }
    }
    return (found);

}






BOOL
WinNTEnumPrinters(
                  DWORD  dwType,
                  LPTSTR lpszName,
                  DWORD  dwLevel,
                  LPBYTE *lplpbPrinters,
                  LPDWORD lpdwReturned
                  )
{

    BOOL    bStatus = FALSE;
    DWORD   dwPassed = 1024;
    DWORD   dwNeeded = 0;
    DWORD   dwError = 0;
    LPBYTE  pMem = NULL;


    pMem =  (LPBYTE)AllocADsMem(dwPassed);
    if (!pMem) {
        goto error;
    }

    bStatus = EnumPrinters(dwType,
                           lpszName,
                           dwLevel,
                           pMem,
                           dwPassed,
                           &dwNeeded,
                           lpdwReturned);


    if (!bStatus) {
        if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER) {
            goto error;

        }

        if (pMem) {
            FreeADsMem(pMem);
        }

        pMem = (LPBYTE)AllocADsMem(dwNeeded);

        if (!pMem) {
            goto error;
        }

        dwPassed = dwNeeded;

        bStatus = EnumPrinters(dwType,
                               lpszName,
                               dwLevel,
                               pMem,
                               dwPassed,
                               &dwNeeded,
                               lpdwReturned);

        if (!bStatus) {
            goto error;
        }
    }

    *lplpbPrinters = pMem;

    return(TRUE);


error:

    if (pMem) {
        FreeADsMem(pMem);
    }

    return(FALSE);

}


BOOL
WinNTGetPrinter(HANDLE hPrinter,
                DWORD  dwLevel,
                LPBYTE *lplpbPrinters)
{

    BOOL    bStatus = FALSE;
    DWORD   dwPassed = 1024;
    DWORD   dwNeeded = 0;
    DWORD   dwError = 0;
    LPBYTE  pMem = NULL;


    pMem =  (LPBYTE)AllocADsMem(dwPassed);
    if (!pMem) {
        goto error;
    }

    bStatus = GetPrinter(hPrinter,
                         dwLevel,
                         pMem,
                         dwPassed,
                         &dwNeeded);

    if (!bStatus) {
        if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER) {
            goto error;

        }

        if (pMem) {
            FreeADsMem(pMem);
        }

        pMem = (LPBYTE)AllocADsMem(dwNeeded);

        if (!pMem) {
            goto error;
        }

        dwPassed = dwNeeded;

        bStatus = GetPrinter(hPrinter,
                             dwLevel,
                             pMem,
                             dwPassed,
                             &dwNeeded);

        if (!bStatus) {
            goto error;
        }
    }

    *lplpbPrinters = pMem;

    return(TRUE);


error:

    if (pMem) {
        FreeADsMem(pMem);
    }

    return(FALSE);

}


HRESULT
GetPrinterInfo(
    THIS_ LPPRINTER_INFO_2 *lplpPrinterInfo2,
    LPWSTR  pszPrinterName
    )
{

    //
    // Do a GetPrinter call to pszPrinterName
    //

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE |
                                            READ_CONTROL};
    DWORD LastError = 0;
    HANDLE hPrinter = NULL;
    LPBYTE pMem = NULL;
    HRESULT hr = S_OK;

    ADsAssert(pszPrinterName);
    fStatus = OpenPrinter(pszPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );

    if (!fStatus) {
        LastError = GetLastError();
        switch (LastError) {

        case ERROR_ACCESS_DENIED:
        {
            PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE};
            fStatus = OpenPrinter(pszPrinterName,
                                  &hPrinter,
                                  &PrinterDefaults
                                  );
            if (fStatus) {
                break;
            }
        }

        default:
            RRETURN(HRESULT_FROM_WIN32(GetLastError()));

    }
    }

    fStatus = WinNTGetPrinter(hPrinter,
                              2,
                              (LPBYTE *)&pMem
                              );
    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    *lplpPrinterInfo2 = (LPPRINTER_INFO_2)pMem;

cleanup:

    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   Set
//
//  Synopsis:   Helper function called by CADsPrintQueue:SetInfo
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11-08-95 RamV  Created
//
//----------------------------------------------------------------------------

HRESULT
Set(
    LPPRINTER_INFO_2 lpPrinterInfo2,
    LPTSTR   pszPrinterName
    )
{

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ALL_ACCESS};
    HANDLE hPrinter = NULL;
    HRESULT hr;

    ADsAssert(pszPrinterName);

    fStatus = OpenPrinter(pszPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );

    if (!fStatus) {
        goto error;
    }

    fStatus = SetPrinter(hPrinter,
                         2,
                         (LPBYTE)lpPrinterInfo2,
                         0
                         );
    if (!fStatus) {
        goto error;
    }

    fStatus = ClosePrinter(hPrinter);

    RRETURN(S_OK);

error:
    hr = HRESULT_FROM_WIN32(GetLastError());
    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN(hr);

}


//+---------------------------------------------------------------------------
//
//  Function:   Unmarshall
//
//  Synopsis:   Unmarshalls information from a PRINTER_INFO_2 to a
//              WinNT Printer object.Frees PRINTER_INFO_2 object.
//
//  Arguments:  [lpPrinterInfo2] -- Pointer to a PRINTER_INFO_2 struct
//
//  Returns:    HRESULT
//
//  Modifies:   GeneralInfo and Operation Functional sets
//
//  History:    11/08/95  RamV   Created
//
//----------------------------------------------------------------------------

HRESULT
CWinNTPrintQueue::UnMarshall(
    LPPRINTER_INFO_2 lpPrinterInfo2,
    BOOL fExplicit
    )
{
    HRESULT hr;
    VARIANT vPortNames;
    PNTOBJECT pNtObject;

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("PrinterName"),
                                  lpPrinterInfo2->pPrinterName,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Model"),
                                  lpPrinterInfo2->pDriverName,
                                  fExplicit
                                  );


    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("PrintProcessor"),
                                  lpPrinterInfo2->pPrintProcessor,
                                  fExplicit
                                  );


    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Location"),
                                  lpPrinterInfo2->pLocation,
                                  fExplicit
                                  );


    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Datatype"),
                                  lpPrinterInfo2->pDatatype,
                                  fExplicit
                                  );


    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("BannerPage"),
                                  lpPrinterInfo2->pSepFile,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Description"),
                                  lpPrinterInfo2->pComment,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("PrinterPath"),
                                  lpPrinterInfo2->pPrinterName,
                                  fExplicit
                                  );


    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("Priority"),
                                  lpPrinterInfo2->Priority,
                                  fExplicit
                                  );


    hr = SetDelimitedStringPropertyInCache(_pPropertyCache,
                                           TEXT("PrintDevices"),
                                           lpPrinterInfo2->pPortName,
                                           fExplicit
                                           );


    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("DefaultJobPriority"),
                                  lpPrinterInfo2->DefaultPriority,
                                  fExplicit
                                  );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("JobCount"),
                                  lpPrinterInfo2->cJobs,
                                  fExplicit
                                  );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("Attributes"),
                                  lpPrinterInfo2->Attributes,
                                  fExplicit
                                  );

    hr = SetDATEPropertyInCache(_pPropertyCache,
                                  TEXT("StartTime"),
                                  lpPrinterInfo2->StartTime,
                                  fExplicit
                                  );

    hr = SetDATEPropertyInCache(_pPropertyCache,
                                  TEXT("UntilTime"),
                                  lpPrinterInfo2->UntilTime,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );


    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   MarshallAndSet
//
//  Synopsis:   Marshalls information from a Printer object to a
//              PRINTER_INFO_2 structure
//
//  Arguments:  [lpPrinterInfo2] -- Pointer to a PRINTER_INFO_2 struct.
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    11/09/95  RamV  Created
//
//----------------------------------------------------------------------------

HRESULT
CWinNTPrintQueue::MarshallAndSet(
    LPPRINTER_INFO_2 lpPrinterInfo2
    )

{
    HRESULT hr =S_OK;
    DWORD dwPriority;
    LPTSTR   pszPrinterName = NULL;
    LPTSTR   pszDriverName = NULL;
    LPTSTR   pszComment = NULL;
    LPTSTR   pszLocation = NULL;
    LPTSTR   pszDatatype = NULL;
    LPTSTR   pszPrintProcessor = NULL;
    LPTSTR   pszBannerPage = NULL;
    VARIANT vPortNames;
    PNTOBJECT  pNtObject = NULL;
    LPTSTR pszPorts = NULL;
    DWORD dwSyntaxId;
    DWORD dwTimeValue;
    DWORD dwNumValues = 0;
    DWORD dwAttributes;
    DWORD dwUpdatedProps = 0;

    //
    // We can set the update variable based on the number
    // of properties in the cache.
    //
    hr = _pPropertyCache->get_PropertyCount(&dwUpdatedProps);

    if (dwUpdatedProps != 0) {
        //
        // We can do all this to get the props
        //
        hr = GetLPTSTRPropertyFromCache(
                        _pPropertyCache,
                        TEXT("PrinterName"),
                        &pszPrinterName
                        );
        if(SUCCEEDED(hr)){
            lpPrinterInfo2->pPrinterName= pszPrinterName;
        }

        hr = GetLPTSTRPropertyFromCache(
                        _pPropertyCache,
                        TEXT("Model"),
                        &pszDriverName
                        );
        if(SUCCEEDED(hr)){
            lpPrinterInfo2->pDriverName = pszDriverName;
        }

        hr = GetLPTSTRPropertyFromCache(
                        _pPropertyCache,
                        TEXT("PrintProcessor"),
                        &pszPrintProcessor
                        );

        if(SUCCEEDED(hr)){

            lpPrinterInfo2->pPrintProcessor = pszPrintProcessor;
        }


        hr = GetLPTSTRPropertyFromCache(
                        _pPropertyCache,
                        TEXT("Description"),
                        &pszComment
                        );

        if(SUCCEEDED(hr)){

            lpPrinterInfo2->pComment = pszComment;
        }

        hr = GetLPTSTRPropertyFromCache(
                        _pPropertyCache,
                        TEXT("Location"),
                        &pszLocation
                        );

        if(SUCCEEDED(hr)){

            lpPrinterInfo2->pLocation = pszLocation;
        }

        hr = GetLPTSTRPropertyFromCache(
                        _pPropertyCache,
                        TEXT("Datatype"),
                        &pszDatatype
                        );

        if(SUCCEEDED(hr)){

            lpPrinterInfo2->pDatatype = pszDatatype;
        }

        hr = GetLPTSTRPropertyFromCache(
                        _pPropertyCache,
                        TEXT("BannerPage"),
                        &pszBannerPage
                        );

        if(SUCCEEDED(hr)){

            lpPrinterInfo2->pSepFile = pszBannerPage;
        }

        hr = GetDWORDPropertyFromCache(
                        _pPropertyCache,
                        TEXT("Priority"),
                        &dwPriority
                        );

        if(SUCCEEDED(hr)){

            lpPrinterInfo2->Priority = dwPriority;
        }

        hr = GetDWORDPropertyFromCache(
                        _pPropertyCache,
                        TEXT("DefaultJobPriority"),
                        &dwPriority
                        );

        if(SUCCEEDED(hr)){

            lpPrinterInfo2->DefaultPriority = dwPriority;
        }

        //
        // will NOT marshall or set job count on the server
        //

        hr = GetDWORDPropertyFromCache(
                        _pPropertyCache,
                        TEXT("Attributes"),
                        &dwAttributes
                        );

        if(SUCCEEDED(hr)){

            lpPrinterInfo2->Attributes = dwAttributes;
        }

        hr = GetDelimitedStringPropertyFromCache(
                        _pPropertyCache,
                        TEXT("PrintDevices"),
                        &pszPorts
                        );

        if(SUCCEEDED(hr)){

            lpPrinterInfo2->pPortName = pszPorts;
        }

        hr = GetDATEPropertyFromCache(
                        _pPropertyCache,
                        TEXT("StartTime"),
                        &dwTimeValue
                        );

        if(SUCCEEDED(hr)){

            lpPrinterInfo2->StartTime = dwTimeValue;
        }

        hr = GetDATEPropertyFromCache(
                        _pPropertyCache,
                        TEXT("UntilTime"),
                        &dwTimeValue
                        );

        if(SUCCEEDED(hr)){

            lpPrinterInfo2->UntilTime = dwTimeValue;
        }


        //
        // Need to do the set
        //

        hr = Set(lpPrinterInfo2,
                 _pszPrinterName);
        //
        // only this hr gets recorded
        //

        BAIL_IF_ERROR(hr);
    }

cleanup:
    if(pszDriverName)
        FreeADsStr(pszDriverName);
    if(pszComment)
        FreeADsStr(pszComment);
    if(pszLocation)
        FreeADsStr(pszLocation);
    if(pszDatatype)
        FreeADsStr(pszDatatype);
    if(pszPrintProcessor)
        FreeADsStr(pszPrintProcessor);
    if(pszBannerPage)
        FreeADsStr(pszBannerPage);
    if(pszPorts){
        FreeADsStr(pszPorts);
    }
    RRETURN(hr);

}

HRESULT
WinNTDeletePrinter( POBJECTINFO pObjectInfo)
{
    WCHAR szUncServerName[MAX_PATH];
    WCHAR szUncPrinterName[MAX_PATH];
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ALL_ACCESS};
    BOOL fStatus = FALSE;
    HRESULT hr = S_OK;
    //
    // first open printer to get a handle to it
    //

    MakeUncName(pObjectInfo->ComponentArray[1],
                szUncServerName
                );

    wcscpy(szUncPrinterName, szUncServerName);
    wcscat(szUncPrinterName, L"\\");
    wcscat(szUncPrinterName, (LPTSTR)pObjectInfo->ComponentArray[2]);

    fStatus = OpenPrinter((LPTSTR)szUncPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    fStatus = DeletePrinter(hPrinter);

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        fStatus = ClosePrinter(hPrinter);
        goto error;

    }


error:

    RRETURN(hr);
}

HRESULT
PrinterNameFromObjectInfo(
    POBJECTINFO pObjectInfo,
    LPTSTR szUncPrinterName
    )
{
    if(!pObjectInfo){
        RRETURN(S_OK);
    }

    if(!((pObjectInfo->NumComponents == 3) ||(pObjectInfo->NumComponents == 4)) ){
        RRETURN(E_ADS_BAD_PATHNAME);
    }

        if(pObjectInfo->NumComponents == 3) {
        wcscpy(szUncPrinterName, TEXT("\\\\"));
        wcscat(szUncPrinterName, pObjectInfo->ComponentArray[1]);
        wcscat(szUncPrinterName, TEXT("\\"));
        wcscat(szUncPrinterName, pObjectInfo->ComponentArray[2]);
        } else  {
            wcscpy(szUncPrinterName, TEXT("\\\\"));
        wcscat(szUncPrinterName, pObjectInfo->ComponentArray[0]);
        wcscat(szUncPrinterName, TEXT("\\"));
        wcscat(szUncPrinterName, pObjectInfo->ComponentArray[1]);
        }

    RRETURN(S_OK);
}




#if (!defined(BUILD_FOR_NT40))


//+---------------------------------------------------------------------------
//
//  Function:   MarshallAndSet
//
//  Synopsis:   Marshalls information from a Printer object to a
//              PRINTER_INFO_7 structure
//
//  Arguments:  [lpPrinterInfo7] -- Pointer to a PRINTER_INFO_2 struct.
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    11/09/95  RamV  Created
//
//----------------------------------------------------------------------------

HRESULT
CWinNTPrintQueue::MarshallAndSet(
    LPPRINTER_INFO_7 lpPrinterInfo7
    )

{
    HRESULT hr =S_OK;
    DWORD dwAction;
    LPTSTR   pszObjectGUID = NULL;
    BOOL fSetInfoNeeded = FALSE;

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("ObjectGUID"),
                    &pszObjectGUID
                    );
    if(SUCCEEDED(hr)){
        fSetInfoNeeded = TRUE;
        lpPrinterInfo7->pszObjectGUID = pszObjectGUID;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Action"),
                    &dwAction
                    );

    if(SUCCEEDED(hr)){
        fSetInfoNeeded = TRUE;
        lpPrinterInfo7->dwAction = dwAction;
    }


    //
    // Need to do the set if flag is set
    //
    if (fSetInfoNeeded) {
        hr = SetPrinter7(lpPrinterInfo7,
                 _pszPrinterName);
        //
        // only this hr gets recorded
        //

        BAIL_IF_ERROR(hr);
    }
    else {
        //
        // Need to this - if we are here it means that the hr is
        // probably set as prop was not found in cache.
        hr = S_OK;
    }


cleanup:
    if(pszObjectGUID)
        FreeADsStr(pszObjectGUID);

    RRETURN(hr);

}


HRESULT
GetPrinterInfo7(
    THIS_ LPPRINTER_INFO_7 *lplpPrinterInfo7,
    LPWSTR  pszPrinterName
    )
{

    //
    // Do a GetPrinter call to pszPrinterName
    //

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE |
                                            READ_CONTROL};
    DWORD LastError = 0;
    HANDLE hPrinter = NULL;
    LPBYTE pMem = NULL;
    HRESULT hr = S_OK;

    ADsAssert(pszPrinterName);
    fStatus = OpenPrinter(pszPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );

    if (!fStatus) {
        LastError = GetLastError();
        switch (LastError) {

        case ERROR_ACCESS_DENIED:
        {
            PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE};
            fStatus = OpenPrinter(pszPrinterName,
                                  &hPrinter,
                                  &PrinterDefaults
                                  );
            if (fStatus) {
                break;
            }
        }

        default:
            RRETURN(HRESULT_FROM_WIN32(GetLastError()));

    }
    }

    fStatus = WinNTGetPrinter(hPrinter,
                              7,
                              (LPBYTE *)&pMem
                              );
    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    *lplpPrinterInfo7 = (LPPRINTER_INFO_7)pMem;

cleanup:

    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN(hr);
}




HRESULT
SetPrinter7(
    LPPRINTER_INFO_7 lpPrinterInfo7,
    LPTSTR   pszPrinterName
    )
{

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ALL_ACCESS};
    HANDLE hPrinter = NULL;
    HRESULT hr;

    ADsAssert(pszPrinterName);

    fStatus = OpenPrinter(pszPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );

    if (!fStatus) {
        goto error;
    }

    fStatus = SetPrinter(hPrinter,
                         7,
                         (LPBYTE)lpPrinterInfo7,
                         0
                         );
    if (!fStatus) {
        goto error;
    }

    fStatus = ClosePrinter(hPrinter);

    RRETURN(S_OK);

error:
    hr = HRESULT_FROM_WIN32(GetLastError());
    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN(hr);

}


//+---------------------------------------------------------------------------
//
//  Function:   Unmarshall
//
//  Synopsis:   Unmarshalls information from a PRINTER_INFO_2 to a
//              WinNT Printer object.Frees PRINTER_INFO_2 object.
//
//  Arguments:  [lpPrinterInfo2] -- Pointer to a PRINTER_INFO_2 struct
//
//  Returns:    HRESULT
//
//  Modifies:   GeneralInfo and Operation Functional sets
//
//  History:    11/08/95  RamV   Created
//
//----------------------------------------------------------------------------

HRESULT
CWinNTPrintQueue::UnMarshall7(
    LPPRINTER_INFO_7 lpPrinterInfo7,
    BOOL fExplicit
    )
{
    HRESULT hr;
    VARIANT vPortNames;
    PNTOBJECT pNtObject;

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("ObjectGUID"),
                                  lpPrinterInfo7->pszObjectGUID,
                                  fExplicit
                                  );


    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("Action"),
                                  lpPrinterInfo7->dwAction,
                                  fExplicit
                                  );
    RRETURN(S_OK);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\umi_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0328 */
/* Compiler settings for umi.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_UMI_V6,0x12575a7a,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiPropList,0x12575a7b,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiBaseObject,0x12575a7c,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiObject,0x5ed7ee23,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiConnection,0x5ed7ee20,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiContainer,0x5ed7ee21,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiCursor,0x5ed7ee26,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiObjectSink,0x5ed7ee24,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiURLKeyList,0xcf779c98,0x4739,0x4fd4,0xa4,0x15,0xda,0x93,0x7a,0x59,0x9f,0x2f);


MIDL_DEFINE_GUID(IID, IID_IUmiURL,0x12575a7d,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiQuery,0x12575a7e,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiCustomInterfaceFactory,0x14CD599E,0x2BE7,0x4c6f,0xB9,0x5B,0xB1,0x50,0xDC,0xD9,0x35,0x85);


MIDL_DEFINE_GUID(CLSID, CLSID_UmiDefURL,0xd4b21cc2,0xf2a5,0x453e,0x84,0x59,0xb2,0x7f,0x36,0x2c,0xb0,0xe0);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0328 */
/* Compiler settings for umi.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_UMI_V6,0x12575a7a,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiPropList,0x12575a7b,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiBaseObject,0x12575a7c,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiObject,0x5ed7ee23,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiConnection,0x5ed7ee20,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiContainer,0x5ed7ee21,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiCursor,0x5ed7ee26,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiObjectSink,0x5ed7ee24,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiURLKeyList,0xcf779c98,0x4739,0x4fd4,0xa4,0x15,0xda,0x93,0x7a,0x59,0x9f,0x2f);


MIDL_DEFINE_GUID(IID, IID_IUmiURL,0x12575a7d,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiQuery,0x12575a7e,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiCustomInterfaceFactory,0x14CD599E,0x2BE7,0x4c6f,0xB9,0x5B,0xB1,0x50,0xDC,0xD9,0x35,0x85);


MIDL_DEFINE_GUID(CLSID, CLSID_UmiDefURL,0xd4b21cc2,0xf2a5,0x453e,0x84,0x59,0xb2,0x7f,0x36,0x2c,0xb0,0xe0);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\umiconcf.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     umiconcf.cxx
//
//  Contents: Contains the class factory for creating UMI connection objects. 
//
//  History:  03-02-00    SivaramR  Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"

//----------------------------------------------------------------------------
// Function:   CreateInstance 
//
// Synopsis:   Creates a connection object.
//
// Arguments:
//
// pUnkOuter   Pointer to aggregating IUnknown. UMI connection objects don't
//             support aggregation, so this has to be NULL.
// iid         Interface requested. Only interface supported is IUmiConnection.
// ppInterface Returns pointer to interface requested
//
// Returns:    S_OK on success. Error code otherwise. 
//
// Modifies:   *ppInterface to return a pointer to the interface requested
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiConnectionCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID iid,
    LPVOID *ppInterface
    )
{
    HRESULT        hr = S_OK;

    if(pUnkOuter != NULL)
    // Umi connection object cannot be aggregated
        RRETURN(CLASS_E_NOAGGREGATION);

    if(NULL == ppInterface)
        RRETURN(E_FAIL);

    *ppInterface = NULL;

    hr = CUmiConnection::CreateConnection(iid, ppInterface);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\property.cxx ===
#include "winnt.hxx"
#pragma hdrstop


#define VALIDATE_PTR(pPtr) \
    if (!pPtr) { \
        hr = E_ADS_BAD_PARAMETER;\
    }\
    BAIL_ON_FAILURE(hr);




HRESULT
put_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR   pSrcStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackStringinVariant(
            pSrcStringProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR *ppDestStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackStringfromVariant(
            varOutputData,
            ppDestStringProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_LONG_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    LONG   lSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackLONGinVariant(
            lSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_LONG_Property(
    IADs * pADsObject,
    BSTR  bstrPropertyName,
    PLONG plDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackLONGfromVariant(
            varOutputData,
            plDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear(&varOutputData);
    RRETURN(hr);

}

HRESULT
put_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    DATE   daSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackDATEinVariant(
            daSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PDATE pdaDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackDATEfromVariant(
            varOutputData,
            pdaDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    VARIANT_BOOL   fSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANT_BOOLinVariant(
            fSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT_BOOL pfDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANT_BOOLfromVariant(
            varOutputData,
            pfDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_VARIANT_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    VARIANT   vSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANTinVariant(
            vSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_VARIANT_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT pvDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANTfromVariant(
            varOutputData,
            pvDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varOutputData);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\system.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cPathname.cxx
//
//  Contents:  Pathname object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop

extern "C" {

typedef struct _WKSTA_USER_INFO_1A {
    LPSTR  wkui1_username;
    LPSTR  wkui1_logon_domain;
    LPSTR  wkui1_oth_domains;
    LPSTR  wkui1_logon_server;
}WKSTA_USER_INFO_1A, *PWKSTA_USER_INFO_1A, *LPWKSTA_USER_INFO_1A;


NET_API_STATUS NET_API_FUNCTION
NetWkstaUserGetInfoA (
    IN  LPSTR reserved,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

}

//  Class CWinNTSystemInfo

DEFINE_IDispatch_Implementation(CWinNTSystemInfo)

//+---------------------------------------------------------------------------
// Function:    CWinNTSystemInfo::CWinNTSystemInfo
//
// Synopsis:    Constructor
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
CWinNTSystemInfo::CWinNTSystemInfo():
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CWinNTSystemInfo);
}


//+---------------------------------------------------------------------------
// Function:    CWinNTSystemInfo::CreateWinNTSystemInfo
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
HRESULT
CWinNTSystemInfo::CreateWinNTSystemInfo(
    REFIID riid,
    void **ppvObj
    )
{
    CWinNTSystemInfo FAR * pWinNTSystemInfo = NULL;
    HRESULT hr = S_OK;

    hr = AllocateWinNTSystemInfoObject(&pWinNTSystemInfo);
    BAIL_ON_FAILURE(hr);

    hr = pWinNTSystemInfo->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pWinNTSystemInfo->Release();

    RRETURN(hr);

error:
    delete pWinNTSystemInfo;

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:    CWinNTSystemInfo::~CWinNTSystemInfo
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
CWinNTSystemInfo::~CWinNTSystemInfo( )
{

    delete _pDispMgr;
}

//+---------------------------------------------------------------------------
// Function:    CWinNTSystemInfo::QueryInterface
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTSystemInfo::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsWinNTSystemInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsWinNTSystemInfo))
    {
        *ppv = (IADsWinNTSystemInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsWinNTSystemInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------------------
// Function:    CWinNTSystemInfo::AllocateWinNTSystemInfoObject
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
HRESULT
CWinNTSystemInfo::AllocateWinNTSystemInfoObject(
    CWinNTSystemInfo  ** ppWinNTSystemInfo
    )
{
    CWinNTSystemInfo FAR * pWinNTSystemInfo = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pWinNTSystemInfo = new CWinNTSystemInfo();
    if (pWinNTSystemInfo == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsWinNTSystemInfo,
                (IADsWinNTSystemInfo *)pWinNTSystemInfo,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pWinNTSystemInfo->_pDispMgr = pDispMgr;
    *ppWinNTSystemInfo = pWinNTSystemInfo;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
// Function:    CWinNTSystemInfo::InterfaceSupportsErrorInfo
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
HRESULT
CWinNTSystemInfo::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADsWinNTSystemInfo)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}


HRESULT
CWinNTSystemInfo::get_UserName(
    BSTR * bstrUserName
    )
{
    PWSTR pszUserName = NULL;
    ULONG uLength;
    HRESULT hr;

    //
    // Validate parameters
    //
    if ( !bstrUserName )
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Get length of buffer to be allocated
    //
    uLength = 0;
    GetUserName(NULL, &uLength);

    if (uLength > 0)
    {
        //
        // Allocate memory and do the real work
        //
        pszUserName = (PWSTR)AllocADsMem(uLength * sizeof(WCHAR));
        if (!pszUserName)
        {
            RRETURN(E_OUTOFMEMORY);
        }

        if (GetUserName(pszUserName, &uLength))
        {
            hr = ADsAllocString(pszUserName, bstrUserName);
            BAIL_ON_FAILURE(hr);
        }
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

error:
    if (pszUserName)
    {
        FreeADsMem(pszUserName);
    }

    RRETURN(hr);
}

HRESULT
CWinNTSystemInfo::get_ComputerName(
    BSTR * bstrComputerName
    )
{
    PWSTR pszComputerName = NULL;
    ULONG uLength;
    HRESULT hr;

    //
    // Validate parameters
    //
    if (!bstrComputerName)
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Get length of buffer to be allocated
    //
    uLength = 0;
    GetComputerName(NULL, &uLength);

    if (uLength > 0)
    {
        //
        // Allocated memory and do the real work
        //
        pszComputerName = (PWSTR)AllocADsMem(uLength * sizeof(WCHAR));
        if (!pszComputerName)
        {
            RRETURN(E_OUTOFMEMORY);
        }

        if (GetComputerName(pszComputerName, &uLength))
        {
            hr = ADsAllocString(pszComputerName, bstrComputerName);
            BAIL_ON_FAILURE(hr);
        }
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

error:
    if (pszComputerName)
    {
        FreeADsMem(pszComputerName);
    }

    RRETURN(hr);
}

HRESULT
CWinNTSystemInfo::get_DomainName(
    BSTR * bstrDomainName
    )
{
    PWKSTA_USER_INFO_1  pInfo = NULL;
    PWKSTA_USER_INFO_1A pInfoA = NULL;
    DWORD err;
    HRESULT hr = S_OK;
    PWSTR pszDomainName = NULL;

    //
    // Validate parameters
    //
    if (!bstrDomainName )
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Call NetWkstaUserGetInfo to find domain name
    //
#if (defined WIN95)
    err = NetWkstaUserGetInfoA(NULL, 1, (LPBYTE *) &pInfoA);
    if (err != ERROR_SUCCESS)
    {
        RRETURN(HRESULT_FROM_WIN32(err));
    }

    pszDomainName = (PWSTR)AllocADsMem((lstrlenA(pInfoA->wkui1_logon_domain) + 1) * sizeof(WCHAR));
    if (!pszDomainName)
    {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }
    if (MultiByteToWideChar(CP_ACP,
                            MB_PRECOMPOSED,
                            pInfoA->wkui1_logon_domain,
                            -1,
                            pszDomainName,
                            lstrlenA(pInfoA->wkui1_logon_domain) + 1) == 0)
    {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
    }

    hr = ADsAllocString(pszDomainName, bstrDomainName);
    BAIL_ON_FAILURE(hr);
#else
    err = NetWkstaUserGetInfo(NULL, 1, (LPBYTE*) &pInfo);
    if (err != ERROR_SUCCESS)
    {
        RRETURN(HRESULT_FROM_WIN32(err));
    }

    hr = ADsAllocString((LPWSTR)pInfo->wkui1_logon_domain, bstrDomainName);
    BAIL_ON_FAILURE(hr);
#endif

error:
    if (pInfo)
    {
        NetApiBufferFree(pInfo);
    }

    if (pInfoA)
    {
        NetApiBufferFree(pInfoA);
    }

    if (pszDomainName)
    {
        FreeADsMem(pszDomainName);
    }

    RRETURN(hr);
}

HRESULT
CWinNTSystemInfo::get_PDC(
    BSTR * bstrPDC
    )
{
    PWSTR pszPDC = NULL;
    HRESULT hr;
    DWORD err;

    //
    // Validate parameters
    //
    if (!bstrPDC )
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    err = NetGetDCName(NULL, NULL, (LPBYTE*)&pszPDC);

    if (err != ERROR_SUCCESS)
    {
        RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    hr = ADsAllocString(&pszPDC[2], bstrPDC);   // remove '\\';
    BAIL_ON_FAILURE(hr);

error:
    if (pszPDC)
    {
        NetApiBufferFree(pszPDC);
    }

    return hr;
}


STDMETHODIMP
CWinNTSystemInfoCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID iid,
    LPVOID * ppv
    )
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);

    hr = CWinNTSystemInfo::CreateWinNTSystemInfo(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\umiglob.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     umiglob.cxx
//
//  Contents: Contains definition of UMI global variables
//
//  History:  02-28-00    SivaramR  Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"

UMI_TYPE g_mapNTTypeToUmiType[] = {
        UMI_TYPE_NULL,            // no NT_SYNTAX value of 0
        UMI_TYPE_BOOL,            // NT_SYNTAX_ID_BOOL
        UMI_TYPE_SYSTEMTIME,      // NT_SYNTAX_ID_SYSTEMTIME
        UMI_TYPE_I4,              // NT_SYNTAX_ID_DWORD
        UMI_TYPE_LPWSTR,          // NT_SYNTAX_ID_LPTSTR
        UMI_TYPE_LPWSTR,          // NT_SYNTAX_ID_DelimitedString
        UMI_TYPE_LPWSTR,          // NT_SYNTAX_ID_NulledString
        UMI_TYPE_SYSTEMTIME,      // NT_SYNTAX_ID_DATE
        UMI_TYPE_SYSTEMTIME,      // NT_SYNTAX_ID_DATE_1970
        UMI_TYPE_OCTETSTRING,     // NT_SYNTAX_ID_OCTETSTRING
        UMI_TYPE_LPWSTR           // NT_SYNTAX_ID_EncryptedString
        };

DWORD g_dwNumNTTypes = sizeof(g_mapNTTypeToUmiType) /
                                sizeof(g_mapNTTypeToUmiType[0]); 

ADSIToUMI g_IADsProps[] = 
    { { TEXT("ADsPath"), TEXT(UMIOBJ_INTF_PROP_PATH) },
      { TEXT("Class"), TEXT(UMIOBJ_INTF_PROP_CLASS) },
      { TEXT("Name"), TEXT(UMIOBJ_INTF_PROP_NAME) },
      { TEXT("Parent"), TEXT(UMIOBJ_INTF_PROP_PARENT) },
      { TEXT("Schema"), TEXT(UMIOBJ_INTF_PROP_SCHEMA) }
    };

DWORD g_dwIADsProperties = sizeof(g_IADsProps) / sizeof(ADSIToUMI);
 
    
#define UMI_MAX_STRLEN 1024
#define UMI_MAX_LONG 0x7fffffff

// interface properties on IUmiObject. 
PROPERTYINFO ObjClass[] = 
    { { TEXT(UMIOBJ_INTF_PROP_PATH), TEXT(""), TEXT("String"), 
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_CLASS), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_NAME), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_PARENT), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_SCHEMA), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR }, 
      { TEXT(UMIOBJ_INTF_PROP_RELURL), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_FULLURL), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_URL), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_RELPATH), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_GENUS), TEXT(""), TEXT("Integer"),
        UMI_MAX_LONG, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_DWORD },
      { TEXT(UMIOBJ_INTF_PROP_SCHEMAPATH), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_KEY), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_SUPERCLASS), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_FULLRELURL), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_PROPERTY_COUNT), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR }
    };
DWORD g_dwObjClassSize = sizeof(ObjClass)/sizeof(PROPERTYINFO); 

// interface properties on IUmiCOnnection.
PROPERTYINFO ConnectionClass[] =
    { { TEXT(CONN_INTF_PROP_USERNAME), TEXT(""), TEXT("String"), UMI_MAX_STRLEN,
        0, FALSE, PROPERTY_RW, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(CONN_INTF_PROP_PASSWORD), TEXT(""), TEXT("String"), UMI_MAX_STRLEN,
        0, FALSE, PROPERTY_RW, 0, NT_SYNTAX_ID_EncryptedString },
      { TEXT(CONN_INTF_PROP_SECURE_AUTH), TEXT(""), TEXT("Boolean"), 1, 0,
        FALSE, PROPERTY_RW, 0, NT_SYNTAX_ID_BOOL },
      { TEXT(CONN_INTF_PROP_READONLY_SERVER), TEXT(""), TEXT("Boolean"), 1, 0,
        FALSE, PROPERTY_RW, 0, NT_SYNTAX_ID_BOOL } 
    };

DWORD g_dwConnectionTableSize = sizeof(ConnectionClass) /
                                            sizeof(PROPERTYINFO);

PROPERTYINFO CursorClass[] =
    { { TEXT(CURSOR_INTF_PROP_FILTER), TEXT(""), TEXT("String"), UMI_MAX_STRLEN,        0, TRUE, PROPERTY_RW, 0, NT_SYNTAX_ID_LPTSTR }
    };

DWORD g_dwCursorTableSize = sizeof(CursorClass) /
                                           sizeof(PROPERTYINFO);

PROPERTYINFO SchClassClass[] =
    { { TEXT("PrimaryInterface"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN, 0, 
        FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT("CLSID"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN, 0,
        FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT("OID"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN, 0,
        FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Abstract"), TEXT(""), TEXT("Boolean"), 1, 0, FALSE, 
        PROPERTY_READABLE, 0, NT_SYNTAX_ID_BOOL },
      { TEXT("Auxiliary"), TEXT(""), TEXT("Boolean"), 1, 0, FALSE,
        PROPERTY_READABLE, 0, NT_SYNTAX_ID_BOOL },        
      { TEXT("MandatoryProperties"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN, 
        0, TRUE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT("OptionalProperties"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN,
        0, TRUE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PossibleSuperiors"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN,
        0, TRUE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR }, 
      { TEXT("Containment"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN,
        0, TRUE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Container"), TEXT(""), TEXT("Boolean"), 1, 0, FALSE,
        PROPERTY_READABLE, 0, NT_SYNTAX_ID_BOOL },
      { TEXT("HelpFileName"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN, 0,
        FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT("HelpFileContext"), TEXT(""), TEXT("Integer"),
        UMI_MAX_LONG, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_DWORD },
      { TEXT("Name"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN, 0,
        FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR }
    };

DWORD g_dwSchClassClassTableSize = sizeof(SchClassClass)/sizeof(PROPERTYINFO);

PROPERTYINFO PropertyClass[] =
    { { TEXT("OID"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN, 0,
        FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Syntax"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN, 0,
        FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT("MaxRange"), TEXT(""), TEXT("Integer"),
        UMI_MAX_LONG, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_DWORD },
      { TEXT("MinRange"), TEXT(""), TEXT("Integer"),
        UMI_MAX_LONG, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_DWORD },
      { TEXT("Multivalued"), TEXT(""), TEXT("Boolean"), 1, 0, FALSE,
        PROPERTY_READABLE, 0, NT_SYNTAX_ID_BOOL },
      { TEXT("Name"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN, 0,
        FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR }
    };

DWORD g_dwPropertyClassTableSize = sizeof(PropertyClass)/sizeof(PROPERTYINFO);

PROPERTYINFO SyntaxClass[] =
    { { TEXT("OleAutoDataType"), TEXT(""), TEXT("Integer"),
        UMI_MAX_LONG, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_DWORD },
      { TEXT("Name"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN, 0,
        FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR }
    };

DWORD g_dwSyntaxTableSize = sizeof(SyntaxClass)/sizeof(PROPERTYINFO);

PROPERTYINFO SchemaClass[] = 
    { { TEXT("Name"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN, 0,
        FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR }
    };

DWORD g_dwSchemaClassTableSize = sizeof(SchemaClass)/sizeof(PROPERTYINFO);

// Unimplemented standard interface properties on IUmiObject
LPWSTR g_UmiObjUnImplProps[] = 
   { L"__GUIDURL",
     L"__SECURITY_DESCRIPTOR",
     L"__SD_ACCESS",
     L"__TIME_MODIFIED",
     L"__TIME_CREATED",
     L"__GUID",
     NULL
   };

// Unimplemented standard interface properties on IUmiConnection
LPWSTR g_UmiConUnImplProps[] =
   { L"__TIMEOUT",
     L"__ENCRYPTION_METHOD",
     L"__NO_AUTHENTICATION",
     NULL
   };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{$(O)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\umi2nt.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     umi2nt.cxx
//
//  Contents: Contains the routines to convert from UMI_PROPERTY structures to
//            NT objects that can be stored in the cache.
//
//  History:  02-28-00    SivaramR  Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"

//----------------------------------------------------------------------------
// Function:   UmiToBooleans
//
// Synopsis:   Converts from UMI_PROPERTY structure to array of NT objects, 
//             each containing a boolean.
//
// Arguments:
//
// pPropArray  Pointer to UMI_PROPERTY structure
// pNtObjects  Array of NT objects that returns the values. 
// ulNumValues Number of values stored in pPropArray
//
// Returns:    UMI_S_NO_ERROR if successful. Error code otherwise (none now).
//
// Modifies:   *pNtObject to return the converted value. 
//
//----------------------------------------------------------------------------
HRESULT UmiToBooleans(
    UMI_PROPERTY *pPropArray,
    LPNTOBJECT   pNtObjects,
    ULONG        ulNumValues
    )
{
    ULONG ulIndex = 0;
    BOOL  bVal;

    ADsAssert( (pPropArray != NULL) && (pNtObjects != NULL) );
    ADsAssert(pPropArray->pUmiValue != NULL);

    for(ulIndex = 0; ulIndex < ulNumValues; ulIndex++)
    {
        bVal = pPropArray->pUmiValue->bValue[ulIndex];

        pNtObjects[ulIndex].NTType = NT_SYNTAX_ID_BOOL;
        if(bVal)
            pNtObjects[ulIndex].NTValue.fValue = TRUE;
        else
            pNtObjects[ulIndex].NTValue.fValue = FALSE;
    }

    RRETURN(UMI_S_NO_ERROR);
}

//----------------------------------------------------------------------------
// Function:   ConvertSystemTimeToUTCTime
//
// Synopsis:   Converts a system time structure containing a local time to a 
//             system time structure containing UTC time.  
//
// Arguments:
//
// pLocalTime  Pointer to local time
// pUTCTime    Returns UTC time
//
// Returns:    UMI_S_NO_ERROR if successful. Error code otherwise.
//
// Modifies:   *pUTCTime to contain the UTC time.
//
//----------------------------------------------------------------------------
HRESULT ConvertSystemTimeToUTCTime(
    SYSTEMTIME *pLocalTime,
    SYSTEMTIME *pUTCTime
    )
{
    HRESULT  hr = UMI_S_NO_ERROR;
    FILETIME localft, ft;
    BOOL     fRetVal;

    ADsAssert( (pLocalTime != NULL) && (pUTCTime != NULL) );

    fRetVal = SystemTimeToFileTime(pLocalTime, &localft);
    if(!fRetVal)
        BAIL_ON_FAILURE( hr = HRESULT_FROM_WIN32(GetLastError()) );

    fRetVal = LocalFileTimeToFileTime(&localft, &ft);
    if(!fRetVal)
        BAIL_ON_FAILURE( hr = HRESULT_FROM_WIN32(GetLastError()) );

    fRetVal = FileTimeToSystemTime(&ft, pUTCTime);
    if(!fRetVal)
        BAIL_ON_FAILURE( hr = HRESULT_FROM_WIN32(GetLastError()) );

    RRETURN(UMI_S_NO_ERROR);

error:
    RRETURN(hr);
}
   

//----------------------------------------------------------------------------
// Function:   UmiToSystemTimes
//
// Synopsis:   Converts from UMI_PROPERTY structure to array of NT objects,
//             each containing a system time. The time sent in by the user
//             is local time, so we need to convert it to UTC.
//
// Arguments:
//
// pPropArray  Pointer to UMI_PROPERTY structure
// pNtObjects  Array of NT objects that returns the values.
// ulNumValues Number of values stored in pPropArray
//
// Returns:    UMI_S_NO_ERROR if successful. Error code otherwise.
//
// Modifies:   *pNtObject to return the converted value.
//
//----------------------------------------------------------------------------
HRESULT UmiToSystemTimes(
    UMI_PROPERTY *pPropArray,
    LPNTOBJECT   pNtObjects,
    ULONG        ulNumValues
    )
{
    ULONG      ulIndex = 0;
    SYSTEMTIME *pSysTime, UTCTime;
    HRESULT    hr = UMI_S_NO_ERROR;

    ADsAssert( (pPropArray != NULL) && (pNtObjects != NULL) );
    ADsAssert(pPropArray->pUmiValue != NULL);

    for(ulIndex = 0; ulIndex < ulNumValues; ulIndex++)
    {
        pSysTime = &(pPropArray->pUmiValue->sysTimeValue[ulIndex]);

        hr = ConvertSystemTimeToUTCTime(pSysTime, &UTCTime);
        BAIL_ON_FAILURE(hr);

        pNtObjects[ulIndex].NTType = NT_SYNTAX_ID_SYSTEMTIME;
        pNtObjects[ulIndex].NTValue.stSystemTimeValue = UTCTime; 
    }      

    RRETURN(UMI_S_NO_ERROR);

error:
    RRETURN(hr);
}


//----------------------------------------------------------------------------
// Function:   UmiToDwords
//
// Synopsis:   Converts from UMI_PROPERTY structure to array of NT objects,
//             each containing a DWORD.
//
// Arguments:
//
// pPropArray  Pointer to UMI_PROPERTY structure
// pNtObjects  Array of NT objects that returns the values.
// ulNumValues Number of values stored in pPropArray
//
// Returns:    UMI_S_NO_ERROR if successful. Error code otherwise (none now).
//
// Modifies:   *pNtObject to return the converted value.
//
//----------------------------------------------------------------------------
HRESULT UmiToDwords(
    UMI_PROPERTY *pPropArray,
    LPNTOBJECT   pNtObjects,
    ULONG        ulNumValues
    )
{
    ULONG      ulIndex = 0;
    DWORD      dwVal;

    ADsAssert( (pPropArray != NULL) && (pNtObjects != NULL) );
    ADsAssert(pPropArray->pUmiValue != NULL);

    for(ulIndex = 0; ulIndex < ulNumValues; ulIndex++)
    {
        dwVal = pPropArray->pUmiValue->uValue[ulIndex];

        pNtObjects[ulIndex].NTType = NT_SYNTAX_ID_DWORD;
        pNtObjects[ulIndex].NTValue.dwValue = dwVal;
    }

    RRETURN(UMI_S_NO_ERROR);
}

//----------------------------------------------------------------------------
// Function:   UmiToDates
//
// Synopsis:   Converts from UMI_PROPERTY structure to array of NT objects,
//             each containing a DATE. Only the hours and minutes in the
//             system time are stored in the NT object. Again, the input
//             is local time, so it needs to be converted to UTC.
//
// Arguments:
//
// pPropArray  Pointer to UMI_PROPERTY structure
// pNtObjects  Array of NT objects that returns the values.
// ulNumValues Number of values stored in pPropArray
//
// Returns:    UMI_S_NO_ERROR if successful. Error code otherwise.
//
// Modifies:   *pNtObject to return the converted value.
//
//----------------------------------------------------------------------------
HRESULT UmiToDates(
    UMI_PROPERTY *pPropArray,
    LPNTOBJECT   pNtObjects,
    ULONG        ulNumValues
    )
{
    ULONG      ulIndex = 0;
    SYSTEMTIME *pSysTime, UTCTime;
    HRESULT    hr = UMI_S_NO_ERROR;

    ADsAssert( (pPropArray != NULL) && (pNtObjects != NULL) );
    ADsAssert(pPropArray->pUmiValue != NULL);

    for(ulIndex = 0; ulIndex < ulNumValues; ulIndex++)
    {
        pSysTime = &(pPropArray->pUmiValue->sysTimeValue[ulIndex]);

        hr = ConvertSystemTimeToUTCTime(pSysTime, &UTCTime);
        BAIL_ON_FAILURE(hr);

        pNtObjects[ulIndex].NTType = NT_SYNTAX_ID_DATE;
        pNtObjects[ulIndex].NTValue.dwValue = 
                                     UTCTime.wHour*60 + UTCTime.wMinute;
    }

    RRETURN(UMI_S_NO_ERROR);

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   ConvertSystemTimeToUTCFileTime
//
// Synopsis:   Converts a system time structure containing a local time to a
//             file time structure containing UTC time.
//
// Arguments:
//
// pLocalTime  Pointer to local time
// pUTCTime    Returns UTC file time
//
// Returns:    UMI_S_NO_ERROR if successful. Error code otherwise.
//
// Modifies:   *pUTCFileTime to contain the UTC file time.
//
//----------------------------------------------------------------------------
HRESULT ConvertSystemTimeToUTCFileTime(
    SYSTEMTIME *pLocalTime,
    FILETIME *pUTCFileTime
    )
{
    HRESULT  hr = UMI_S_NO_ERROR;
    FILETIME localft;
    BOOL     fRetVal;

    ADsAssert( (pLocalTime != NULL) && (pUTCFileTime != NULL) );

    fRetVal = SystemTimeToFileTime(pLocalTime, &localft);
    if(!fRetVal)
        BAIL_ON_FAILURE( hr = HRESULT_FROM_WIN32(GetLastError()) );

    fRetVal = LocalFileTimeToFileTime(&localft, pUTCFileTime);
    if(!fRetVal)
        BAIL_ON_FAILURE( hr = HRESULT_FROM_WIN32(GetLastError()) );

    RRETURN(UMI_S_NO_ERROR);

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   UmiToDate70s
//
// Synopsis:   Converts from UMI_PROPERTY structure to array of NT objects,
//             each containing the number of seconds from 1970 to the date
//             in UMI_PROPERTY. Again the input is local time, so it needs
//             to be converted to UTC. 
//
// Arguments:
//
// pPropArray  Pointer to UMI_PROPERTY structure
// pNtObjects  Array of NT objects that returns the values.
// ulNumValues Number of values stored in pPropArray
//
// Returns:    UMI_S_NO_ERROR if successful. Error code otherwise.
//
// Modifies:   *pNtObject to return the converted value.
//
//----------------------------------------------------------------------------
HRESULT UmiToDate70s(
    UMI_PROPERTY *pPropArray,
    LPNTOBJECT   pNtObjects,
    ULONG        ulNumValues
    )
{
    ULONG         ulIndex = 0;
    SYSTEMTIME    *pSysTime;
    FILETIME      UTCFileTime;
    HRESULT       hr = UMI_S_NO_ERROR;
    LARGE_INTEGER tmpTime;
    DWORD         dwSeconds1970 = 0;

    ADsAssert( (pPropArray != NULL) && (pNtObjects != NULL) );
    ADsAssert(pPropArray->pUmiValue != NULL);

    for(ulIndex = 0; ulIndex < ulNumValues; ulIndex++)
    {
        pSysTime = &(pPropArray->pUmiValue->sysTimeValue[ulIndex]);

        hr = ConvertSystemTimeToUTCFileTime(pSysTime, &UTCFileTime);
        BAIL_ON_FAILURE(hr);

        tmpTime.LowPart = UTCFileTime.dwLowDateTime;
        tmpTime.HighPart = UTCFileTime.dwHighDateTime;

        RtlTimeToSecondsSince1970(&tmpTime, (ULONG *) (&dwSeconds1970) );
 
        pNtObjects[ulIndex].NTType = NT_SYNTAX_ID_DATE_1970;
        pNtObjects[ulIndex].NTValue.dwSeconds1970 = dwSeconds1970;
    }

    RRETURN(UMI_S_NO_ERROR);

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   UmiToLPWSTRs
//
// Synopsis:   Converts from UMI_PROPERTY structure to array of NT objects,
//             each containing a string.
//
// Arguments:
//
// pPropArray  Pointer to UMI_PROPERTY structure
// pNtObjects  Array of NT objects that returns the values.
// ulNumValues Number of values stored in pPropArray
// dwSyntaxId  Syntax of the property. There are different syntaxes for
//             strings - Delimited_Strings, Nulled_Strings etc.
//
// Returns:    UMI_S_NO_ERROR if successful. Error code otherwise.
//
// Modifies:   *pNtObject to return the converted value.
//
//----------------------------------------------------------------------------
HRESULT UmiToLPWSTRs(
    UMI_PROPERTY *pPropArray,
    LPNTOBJECT   pNtObjects,
    ULONG        ulNumValues,
    DWORD        dwSyntaxId
    )
{
    ULONG   ulIndex = 0, i = 0;
    LPWSTR  pszStr = NULL; 
    HRESULT hr = UMI_S_NO_ERROR;

    ADsAssert( (pPropArray != NULL) && (pNtObjects != NULL) );
    ADsAssert(pPropArray->pUmiValue != NULL);

    for(ulIndex = 0; ulIndex < ulNumValues; ulIndex++)
    {
        pszStr = pPropArray->pUmiValue->pszStrValue[ulIndex];

        pNtObjects[ulIndex].NTType = dwSyntaxId;
        if(pszStr != NULL) {
            pNtObjects[ulIndex].NTValue.pszValue = AllocADsStr(pszStr);
            if(NULL == pNtObjects[ulIndex].NTValue.pszValue)
                BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY); 
        }
        else
            pNtObjects[ulIndex].NTValue.pszValue = NULL;
    }

    RRETURN(UMI_S_NO_ERROR);

error:

    for(i = 0; i < ulIndex; i++)
       if(pNtObjects[i].NTValue.pszValue != NULL)
           FreeADsStr(pNtObjects[i].NTValue.pszValue);
 
    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   UmiToOctetStrings
//
// Synopsis:   Converts from UMI_PROPERTY structure to array of NT objects,
//             each containing an octet string.
//
// Arguments:
//
// pPropArray  Pointer to UMI_PROPERTY structure
// pNtObjects  Array of NT objects that returns the values.
// ulNumValues Number of values stored in pPropArray
//
// Returns:    UMI_S_NO_ERROR if successful. Error code otherwise.
//
// Modifies:   *pNtObject to return the converted value.
//
//----------------------------------------------------------------------------
HRESULT UmiToOctetStrings(
    UMI_PROPERTY *pPropArray,
    LPNTOBJECT   pNtObjects,
    ULONG        ulNumValues
    )
{
    ULONG            ulIndex = 0, i = 0;
    UMI_OCTET_STRING *pUmiOctetStr;
    HRESULT          hr = UMI_S_NO_ERROR;

    ADsAssert( (pPropArray != NULL) && (pNtObjects != NULL) );
    ADsAssert(pPropArray->pUmiValue != NULL);

    for(ulIndex = 0; ulIndex < ulNumValues; ulIndex++)
    {
        pUmiOctetStr = &(pPropArray->pUmiValue->octetStr[ulIndex]);

        pNtObjects[ulIndex].NTType = NT_SYNTAX_ID_OCTETSTRING; 
        pNtObjects[ulIndex].NTValue.octetstring.pByte = 
            (BYTE *) AllocADsMem(pUmiOctetStr->uLength);
        if(NULL == pNtObjects[ulIndex].NTValue.octetstring.pByte)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

        memcpy(pNtObjects[ulIndex].NTValue.octetstring.pByte,
               pUmiOctetStr->lpValue, pUmiOctetStr->uLength);
        pNtObjects[ulIndex].NTValue.octetstring.dwSize = pUmiOctetStr->uLength;
    }

    RRETURN(UMI_S_NO_ERROR);

error:

    for(i = 0; i < ulIndex; i++)
       if(pNtObjects[i].NTValue.octetstring.pByte != NULL)
           FreeADsMem(pNtObjects[i].NTValue.octetstring.pByte);

    RRETURN(hr);
}
   
//----------------------------------------------------------------------------
// Function:   UmiToEncryptedLPWSTRs
//
// Synopsis:   Converts from UMI_PROPERTY structure to array of NT objects,
//             each containing an encrypted string. Used so that passwords
//             are not stored in cleartext.
//
// Arguments:
//
// pPropArray  Pointer to UMI_PROPERTY structure
// pNtObjects  Array of NT objects that returns the values.
// ulNumValues Number of values stored in pPropArray
//
// Returns:    UMI_S_NO_ERROR if successful. Error code otherwise.
//
// Modifies:   *pNtObject to return the converted value.
//
//----------------------------------------------------------------------------
HRESULT UmiToEncryptedLPWSTRs(
    UMI_PROPERTY *pPropArray,
    LPNTOBJECT   pNtObjects,
    ULONG        ulNumValues
    )
{
    ULONG          ulIndex = 0, i = 0;
    LPWSTR         pszStr = NULL;
    HRESULT        hr = UMI_S_NO_ERROR;
    UNICODE_STRING Password;
    UCHAR          Seed = UMI_ENCODE_SEED3;

    ADsAssert( (pPropArray != NULL) && (pNtObjects != NULL) );
    ADsAssert(pPropArray->pUmiValue != NULL);

    for(ulIndex = 0; ulIndex < ulNumValues; ulIndex++)
    {
        pszStr = pPropArray->pUmiValue->pszStrValue[ulIndex];

        pNtObjects[ulIndex].NTType = NT_SYNTAX_ID_EncryptedString; 

        if(pszStr != NULL) {
            pNtObjects[ulIndex].NTValue.pszValue = AllocADsStr(pszStr);
            if(NULL == pNtObjects[ulIndex].NTValue.pszValue)
                BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

            RtlInitUnicodeString(&Password, 
                                 pNtObjects[ulIndex].NTValue.pszValue);
            RtlRunEncodeUnicodeString(&Seed, &Password); 
        }
        else
            pNtObjects[ulIndex].NTValue.pszValue = NULL;
    }

    RRETURN(UMI_S_NO_ERROR);

error:

    for(i = 0; i < ulIndex; i++)
       if(pNtObjects[i].NTValue.pszValue != NULL)
           FreeADsStr(pNtObjects[i].NTValue.pszValue);

    RRETURN(hr);
} 

//----------------------------------------------------------------------------
// Function:   UmiToWinNTType 
//
// Synopsis:   Converts from UMI_PROPERTY structure to NT objects that can be
//             stored in the cache. 
//
// Arguments: 
//
// dwSyntaxId  Syntax of property
// pPropArray  Pointer to UMI_PROPERTY structure
// ppNtObjects Returns a pointer to an NT object that can be stored in the
//             cache. 
//
// Returns:    UMI_S_NO_ERROR if successful. Error code otherwise. 
//
// Modifies:   *ppNtObjects to return a pointer to NT object
//
//----------------------------------------------------------------------------
HRESULT UmiToWinNTType(
    DWORD         dwSyntaxId,
    UMI_PROPERTY *pPropArray,
    LPNTOBJECT   *ppNtObjects
    )
{
    ULONG      ulNumValues = 0;
    HRESULT    hr = UMI_S_NO_ERROR;
    LPNTOBJECT pNtObjects = NULL;

    ADsAssert((pPropArray != NULL) && (ppNtObjects != NULL));

    *ppNtObjects = NULL;
    ulNumValues = pPropArray->uCount;

    pNtObjects = (LPNTOBJECT) AllocADsMem(ulNumValues * sizeof(NTOBJECT));
    if(NULL == pNtObjects)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    switch(dwSyntaxId) {

        case NT_SYNTAX_ID_BOOL:
            if(pPropArray->uType != UMI_TYPE_BOOL)
                BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

            hr = UmiToBooleans(pPropArray, pNtObjects, ulNumValues);
            BAIL_ON_FAILURE(hr);

            break;

        case NT_SYNTAX_ID_SYSTEMTIME:
            if(pPropArray->uType != UMI_TYPE_SYSTEMTIME)
                BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

            hr = UmiToSystemTimes(pPropArray, pNtObjects, ulNumValues);
            BAIL_ON_FAILURE(hr);

            break;

        case NT_SYNTAX_ID_DWORD:
            if(pPropArray->uType != UMI_TYPE_I4)
                BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

            hr = UmiToDwords(pPropArray, pNtObjects, ulNumValues);
            BAIL_ON_FAILURE(hr);

            break;

        case NT_SYNTAX_ID_DATE:
            if(pPropArray->uType != UMI_TYPE_SYSTEMTIME)
                BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

            hr = UmiToDates(pPropArray, pNtObjects, ulNumValues);
            BAIL_ON_FAILURE(hr);

            break;

        case NT_SYNTAX_ID_DATE_1970:
            if(pPropArray->uType != UMI_TYPE_SYSTEMTIME)
                BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

            hr = UmiToDate70s(pPropArray, pNtObjects, ulNumValues);
            BAIL_ON_FAILURE(hr);

            break;

        case NT_SYNTAX_ID_LPTSTR:
            if(pPropArray->uType != UMI_TYPE_LPWSTR)
                BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

            hr = UmiToLPWSTRs(pPropArray, pNtObjects, ulNumValues,
                                   NT_SYNTAX_ID_LPTSTR);
            BAIL_ON_FAILURE(hr);

            break;

        case NT_SYNTAX_ID_DelimitedString:
            if(pPropArray->uType != UMI_TYPE_LPWSTR)
                BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

            hr = UmiToLPWSTRs(pPropArray, pNtObjects, ulNumValues,
                                   NT_SYNTAX_ID_DelimitedString);
            BAIL_ON_FAILURE(hr);

            break;

        case NT_SYNTAX_ID_NulledString:
            if(pPropArray->uType != UMI_TYPE_LPWSTR)
                BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

            hr = UmiToLPWSTRs(pPropArray, pNtObjects, ulNumValues,
                                    NT_SYNTAX_ID_NulledString);
            BAIL_ON_FAILURE(hr);

            break;

        case NT_SYNTAX_ID_OCTETSTRING:
            if(pPropArray->uType != UMI_TYPE_OCTETSTRING)
                BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

            hr = UmiToOctetStrings(pPropArray, pNtObjects, ulNumValues);

            BAIL_ON_FAILURE(hr);

            break;

        case NT_SYNTAX_ID_EncryptedString:
            if(pPropArray->uType != UMI_TYPE_LPWSTR)
                BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

            hr = UmiToEncryptedLPWSTRs(pPropArray, pNtObjects, ulNumValues);
            BAIL_ON_FAILURE(hr);

            break;

        default:
            BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);
    } // switch

    *ppNtObjects = pNtObjects;
    RRETURN(UMI_S_NO_ERROR);

error:
    if(pNtObjects != NULL)
        FreeADsMem(pNtObjects);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\win95\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\servhlp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  servhlp.hxx
//
//  Contents:  helper functions for winnt service object
//
//
//  History:   12/11/95     ramv (Ram Viswanathan)    Created.
//
//--------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop

//
// mapping WinNT Status Codes to ADs Status Codes and vice versa
//

typedef struct _ServiceStatusList {
    DWORD  dwWinNTServiceStatus;
    DWORD  dwADsServiceStatus;
} SERVICE_STATUS_LIST, *PSERVICE_STATUS_LIST;


SERVICE_STATUS_LIST ServiceStatusList[] =
{
{SERVICE_STOPPED, ADS_SERVICE_STOPPED },
{SERVICE_START_PENDING, ADS_SERVICE_START_PENDING },
{SERVICE_STOP_PENDING, ADS_SERVICE_STOP_PENDING },
{SERVICE_RUNNING, ADS_SERVICE_RUNNING },
{SERVICE_CONTINUE_PENDING, ADS_SERVICE_CONTINUE_PENDING },
{SERVICE_PAUSE_PENDING, ADS_SERVICE_PAUSE_PENDING },
{SERVICE_PAUSED, ADS_SERVICE_PAUSED },

};


typedef struct _ServiceTypeList {
DWORD  dwWinNTServiceType;
DWORD  dwADsServiceType;
} SERVICETYPELIST, *PSERVICETYPELIST;

typedef struct _StartTypeList {
DWORD  dwWinNTStartType;
DWORD  dwADsStartType;
} STARTTYPELIST, *PSTARTTYPELIST;

typedef struct _ErrorList {
DWORD   dwWinNTErrorControl;
DWORD   dwADsErrorControl;
} ERRORLIST, *PERRORLIST;


SERVICETYPELIST ServiceTypeList[] =
{
{ SERVICE_WIN32_OWN_PROCESS,ADS_SERVICE_OWN_PROCESS },
{ SERVICE_WIN32_SHARE_PROCESS,ADS_SERVICE_SHARE_PROCESS },
{ SERVICE_KERNEL_DRIVER,ADS_SERVICE_KERNEL_DRIVER},
{ SERVICE_FILE_SYSTEM_DRIVER,ADS_SERVICE_FILE_SYSTEM_DRIVER}
};


STARTTYPELIST StartTypeList[] =
{
{SERVICE_BOOT_START,ADS_SERVICE_BOOT_START },
{SERVICE_SYSTEM_START, ADS_SERVICE_SYSTEM_START},
{SERVICE_AUTO_START,ADS_SERVICE_AUTO_START },
{SERVICE_DEMAND_START, ADS_SERVICE_DEMAND_START},
{SERVICE_DISABLED, ADS_SERVICE_DISABLED}
};

ERRORLIST ErrorList[] =
{
{SERVICE_ERROR_IGNORE,ADS_SERVICE_ERROR_IGNORE },
{SERVICE_ERROR_NORMAL,ADS_SERVICE_ERROR_NORMAL },
{SERVICE_ERROR_SEVERE,ADS_SERVICE_ERROR_SEVERE },
{SERVICE_ERROR_CRITICAL,ADS_SERVICE_ERROR_CRITICAL}
};




BOOL ServiceStatusWinNTToADs( DWORD dwWinNTStatus,
DWORD *pdwADsStatus)
{
    BOOL found = FALSE;
    int i;

    for (i=0;i<7;i++){

        if(dwWinNTStatus == ServiceStatusList[i].dwWinNTServiceStatus){
            *pdwADsStatus = ServiceStatusList[i].dwADsServiceStatus;
            found = TRUE;
            break;
        }
    }
    return (found);

}

BOOL ServiceStatusADsToWinNT( DWORD dwADsStatus,
                               DWORD *pdwWinNTStatus)
{
    BOOL found = FALSE;
    int i;

    for (i=0;i<7;i++){

        if(dwADsStatus == ServiceStatusList[i].dwADsServiceStatus){
            *pdwWinNTStatus = ServiceStatusList[i].dwWinNTServiceStatus;
            found = TRUE;
            break;
        }
    }
    return (found);

}



HRESULT
WinNTEnumServices( LPTSTR szComputerName,
                  LPDWORD pdwServiceObjectReturned,
                  LPBYTE  *ppMem
                  )

{

    SC_HANDLE    schSCManager = NULL;
    LPBYTE       pMem        = NULL;
    DWORD  dwBytesNeeded =0;
    DWORD dwBufLen = 0;
    DWORD dwResumeHandle = 0;
    BOOL fStatus;
    DWORD dwLastError = NULL;
    HRESULT hr = S_OK;

    ADsAssert(pdwServiceObjectReturned);
    ADsAssert(ppMem);

    schSCManager = OpenSCManager(szComputerName,
                                 NULL,
                                 SC_MANAGER_ENUMERATE_SERVICE
                                 );

    if(schSCManager == NULL){
        hr =HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    //
    // enumerate all win32 services
    //

    fStatus = EnumServicesStatus(schSCManager,
                                 SERVICE_WIN32,
                                 SERVICE_ACTIVE|
                                 SERVICE_INACTIVE,
                                 (LPENUM_SERVICE_STATUS)pMem,
                                 dwBufLen,
                                 &dwBytesNeeded,
                                 pdwServiceObjectReturned,
                                 &dwResumeHandle
                                 );

    if(dwBytesNeeded==0){
        hr = S_FALSE;
        goto cleanup;
    }

    if (!fStatus) {
        dwLastError = GetLastError();
        switch (dwLastError) {
        case ERROR_INSUFFICIENT_BUFFER:
        case ERROR_MORE_DATA :
            pMem = (LPBYTE)AllocADsMem(dwBytesNeeded);
            dwBufLen = dwBytesNeeded;

            if (!pMem) {
                hr = E_OUTOFMEMORY;
                break;
            }

            fStatus = EnumServicesStatus(schSCManager,
                                         SERVICE_WIN32,
                                         SERVICE_ACTIVE|
                                         SERVICE_INACTIVE,
                                         (LPENUM_SERVICE_STATUS)pMem,
                                         dwBufLen,
                                         &dwBytesNeeded,
                                         pdwServiceObjectReturned,
                                         &dwResumeHandle
                                         );

            if (!fStatus) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
            }

            break;

        default:
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;

        }
        BAIL_IF_ERROR(hr);
    }

    *ppMem = pMem;

cleanup:
    if(FAILED(hr)){
        if(pMem){
            FreeADsMem(pMem);
        }
    }

    //
    // Close the handle to service control manager
    //
    if (schSCManager) {
        CloseServiceHandle(schSCManager);
    }

    RRETURN(hr);

}

BOOL ServiceTypeWinNTToADs(DWORD dwServiceType,
                             DWORD  *pdwADsServiceType )
{
    BOOL found = FALSE;
    int i;

    for (i=0; i<4; i++){

        if(dwServiceType == ServiceTypeList[i].dwWinNTServiceType){
            *pdwADsServiceType = ServiceTypeList[i].dwADsServiceType;
            found = TRUE;
            break;
        }
        break;
    }
    return(found);
}

BOOL StartTypeWinNTToADs(DWORD dwStartType,
                           DWORD  *pdwADsStartType )

{
    BOOL found = FALSE;
    int i;

    for (i=0; i<5; i++){

        if(dwStartType == StartTypeList[i].dwWinNTStartType){
            *pdwADsStartType = StartTypeList[i].dwADsStartType;
            found = TRUE;
            break;
        }
    }
    return(found);
}

BOOL ErrorControlWinNTToADs(DWORD dwErrorControl,
                              DWORD  *pdwADsErrorControl)

{
    BOOL found = FALSE;
    int i;

    for (i=0; i<4; i++){

        if(dwErrorControl == ErrorList[i].dwWinNTErrorControl){
            *pdwADsErrorControl = ErrorList[i].dwADsErrorControl;
            found = TRUE;
            break;
        }
    }
    return(found);

}

BOOL ServiceTypeADsToWinNT(DWORD  dwADsServiceType,
                             DWORD *pdwServiceType)
{
    BOOL found = FALSE;
    int i;

    for (i=0; i<4; i++){

        if(dwADsServiceType == ServiceTypeList[i].dwADsServiceType){
            *pdwServiceType = ServiceTypeList[i].dwWinNTServiceType;
            found = TRUE;
            break;
        }
        break;
    }
    return(found);
}


BOOL StartTypeADsToWinNT(DWORD  dwADsStartType,
                           DWORD *pdwStartType)

{
    BOOL found = FALSE;
    int i;

    for (i=0; i<5; i++){

        if(dwADsStartType == StartTypeList[i].dwADsStartType){
            *pdwStartType = StartTypeList[i].dwWinNTStartType;
            found = TRUE;
            break;
        }
    }
    return(found);

}

BOOL ErrorControlADsToWinNT(DWORD  dwADsErrorControl,
                              DWORD *pdwErrorControl )

{
    BOOL found = FALSE;
    int i;

    for (i=0; i<4; i++){

        if(dwADsErrorControl == ErrorList[i].dwADsErrorControl){
            *pdwErrorControl = ErrorList[i].dwWinNTErrorControl;
            found = TRUE;
            break;
        }
    }
    return(found);


}

HRESULT WinNTDeleteService(POBJECTINFO pObjectInfo)
{
    SC_HANDLE schService = NULL;
    SC_HANDLE schSCManager = NULL;
    HRESULT   hr = S_OK;
    BOOL fRetval = FALSE;

    schSCManager = OpenSCManager(pObjectInfo->ComponentArray[1],
                                 NULL,
                                 SC_MANAGER_ALL_ACCESS
                                 );

    if(schSCManager == NULL){
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    schService = OpenService(schSCManager,
                             pObjectInfo->ComponentArray[2],
                             DELETE );

    if(schService == NULL){
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    fRetval = DeleteService(schService);

    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }


cleanup:
    if(schSCManager){
        fRetval = CloseServiceHandle(schSCManager);
        if(!fRetval && SUCCEEDED(hr)){
            RRETURN(HRESULT_FROM_WIN32(GetLastError()));
        }
    }
    if(schService){
        fRetval = CloseServiceHandle(schService);
        if(!fRetval && SUCCEEDED(hr)){
            RRETURN(HRESULT_FROM_WIN32(GetLastError()));
        }
    }
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\var2nt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       var2winnt.cxx
//
//  Contents:
//
//  Functions:
//
//  History:      13-June-1996   RamV   Created.
//
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma  hdrstop
#define INITGUID


//
// WinNT objects copy code
//

HRESULT
VarTypeToWinNTTypeCopyBOOL(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpVarSrcObject){
        RRETURN(E_POINTER);
    }

    if(lpVarSrcObject->vt != VT_BOOL){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_BOOL;

    if(lpVarSrcObject->boolVal){
        (pNTDestValue->NTValue).fValue = TRUE;

    } else {
        (pNTDestValue->NTValue).fValue = FALSE;
    }

    RRETURN(hr);
}

HRESULT
VarTypeToWinNTTypeCopySYSTEMTIME(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpVarSrcObject){
        RRETURN(E_POINTER);
    }

    if(lpVarSrcObject->vt != VT_DATE){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = ConvertDATEToSYSTEMTIME(lpVarSrcObject->date,
                                 &(pNTDestValue->NTValue.stSystemTimeValue) );


    RRETURN( hr );
}


HRESULT
VarTypeToWinNTTypeCopyDWORD(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt == VT_I4){

        (pNTDestValue->NTValue).dwValue =
                (DWORD)lpVarSrcObject->lVal;
    }
    else if (lpVarSrcObject->vt == VT_I2) {

        (pNTDestValue->NTValue).dwValue =
                (DWORD)lpVarSrcObject->iVal;
    }
    else {
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_DWORD;

    RRETURN(hr);

}

HRESULT
VarTypeToWinNTTypeCopyDATE(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;
    SYSTEMTIME stTime;

    if(lpVarSrcObject->vt != VT_DATE){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_DATE;


    //
    // Note carefully! date is supplied as a value which is < 1 however
    // VariantTimeToDosDateTime complains when given a value < 30000.
    // (Number of days between 1900 and 1980). So
    // we add 35000 to make it a legal value.
    //

    hr = ConvertDATEToSYSTEMTIME(lpVarSrcObject->date+ 35000,
                                 &stTime);

    BAIL_ON_FAILURE(hr);

    (pNTDestValue->NTValue).dwValue = stTime.wHour*60 + stTime.wMinute ;


error:
    RRETURN(hr);

}

HRESULT
VarTypeToWinNTTypeCopyDATE70(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;
    SYSTEMTIME stTime;
    DWORD dwSeconds1970 = 0;

    if(lpVarSrcObject->vt != VT_DATE){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_DATE_1970;

    hr = ConvertDATEtoDWORD(
                lpVarSrcObject->date,
                &dwSeconds1970
                );
    BAIL_ON_FAILURE(hr);

    (pNTDestValue->NTValue).dwSeconds1970 = dwSeconds1970 ;

error:
    RRETURN(hr);

}

HRESULT
VarTypeToWinNTTypeCopyLPTSTR(
    PVARIANT lpVarSrcObject,
    PNTOBJECT   pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_LPTSTR;

    (pNTDestValue->NTValue).pszValue =
        AllocADsStr(lpVarSrcObject->bstrVal);

    if(!(pNTDestValue->NTValue).pszValue){
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
VarTypeToWinNTTypeCopyOctetString(
    PVARIANT lpVarSrcObject,
    PNTOBJECT   pNTDestValue
    )
{
    HRESULT hr = S_OK;

    pNTDestValue->NTType = NT_SYNTAX_ID_OCTETSTRING;
    hr = VariantToBinary(
            lpVarSrcObject,
            &(pNTDestValue->NTValue).octetstring.dwSize,
            &(pNTDestValue->NTValue).octetstring.pByte);

    RRETURN(hr);
}


HRESULT
VarTypeToNtTypeCopy(
    DWORD dwNtType,
    PVARIANT lpVarSrcObject,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;
    switch (dwNtType){
    case NT_SYNTAX_ID_BOOL:
        hr = VarTypeToWinNTTypeCopyBOOL(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:
        hr = VarTypeToWinNTTypeCopySYSTEMTIME(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;


    case NT_SYNTAX_ID_DWORD:
        hr = VarTypeToWinNTTypeCopyDWORD(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;

    case NT_SYNTAX_ID_DATE:
        hr = VarTypeToWinNTTypeCopyDATE(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;


    case NT_SYNTAX_ID_DATE_1970:
        hr = VarTypeToWinNTTypeCopyDATE70(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;


    case NT_SYNTAX_ID_LPTSTR:
        hr = VarTypeToWinNTTypeCopyLPTSTR(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;

    case NT_SYNTAX_ID_DelimitedString:
        hr = VarTypeToWinNTTypeCopyLPTSTR(
                 lpVarSrcObject,
                 lpNtDestObject
                 );

        lpNtDestObject->NTType = NT_SYNTAX_ID_DelimitedString;
        break;

    case NT_SYNTAX_ID_NulledString:
        hr = VarTypeToWinNTTypeCopyLPTSTR(
                 lpVarSrcObject,
                 lpNtDestObject
                 );
        lpNtDestObject->NTType = NT_SYNTAX_ID_NulledString;
        break;

    case NT_SYNTAX_ID_OCTETSTRING:
        hr = VarTypeToWinNTTypeCopyOctetString(
                 lpVarSrcObject,
                 lpNtDestObject
                 );
        lpNtDestObject->NTType = NT_SYNTAX_ID_OCTETSTRING;
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
VarTypeToNtTypeCopyConstruct(
    DWORD dwNtType,
    LPVARIANT pVarSrcObjects,
    DWORD dwNumObjects,
    LPNTOBJECT * ppNtDestObjects
    )
{

    DWORD i = 0;
    LPNTOBJECT pNtDestObjects = NULL;
    HRESULT hr = S_OK;

    pNtDestObjects = (LPNTOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NTOBJECT)
                                    );

    if (!pNtDestObjects) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = VarTypeToNtTypeCopy(
                    dwNtType,
                    pVarSrcObjects + i,
                    pNtDestObjects + i
                    );
         BAIL_ON_FAILURE(hr);
     }

     *ppNtDestObjects = pNtDestObjects;

     RRETURN(S_OK);

error:

     if (pNtDestObjects) {

         FreeADsMem(pNtDestObjects);
     }

     *ppNtDestObjects = NULL;

     RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\umi.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     umi.cxx
//
//  Contents: Contains miscellaneous UMI routines.
//
//  History:  02-28-00    SivaramR  Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"

//----------------------------------------------------------------------------
// Function:   IsPreDefinedErrorCode 
//
// Synopsis:   Returns TRUE if the error code passed in is a valid UMI error
//             code i.e one that can be returned by a UMI method. Returns
//             FALSE otherwise. 
//
// Arguments:  Self explanatory
//
// Returns:    TRUE/FALSE as mentioned above 
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
BOOL IsPreDefinedErrorCode(HRESULT hr)
{
    switch(hr) {
        case E_UNEXPECTED:
        case E_NOTIMPL:
        case E_OUTOFMEMORY:
        case E_INVALIDARG:
        case E_NOINTERFACE:
        case E_POINTER:
        case E_HANDLE:
        case E_ABORT:
        case E_FAIL:
        case E_ACCESSDENIED:
        case E_PENDING:
        case UMI_E_TYPE_MISMATCH:
        case UMI_E_NOT_FOUND:
        case UMI_E_INVALID_FLAGS:
        case UMI_E_UNSUPPORTED_OPERATION:
        case UMI_E_UNSUPPORTED_FLAGS:
        case UMI_E_SYNCHRONIZATION_REQUIRED:
        case UMI_E_UNBOUND_OBJECT:

            RRETURN(TRUE);

        default:

            RRETURN(FALSE);
    }
}

//----------------------------------------------------------------------------
// Function:   MapHrToUmiError 
//
// Synopsis:   This function returns the UMI error corresponding to a HRESULT
//             returned by the WinNT provider. The HRESULT can be retrieved
//             using GetLastStatus(), if required.
//
// Arguments:  Self explanatory
//
// Returns:    UMI error corresponding to the HRESULT 
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT MapHrToUmiError(HRESULT hr)
{
    if(SUCCEEDED(hr)) {
        if(S_FALSE == hr) // may be returned by end of cursor enumeration
            RRETURN(UMI_S_FALSE);
        else
            RRETURN(UMI_S_NO_ERROR);
    }

    // we had a failure
    if(TRUE == IsPreDefinedErrorCode(hr))
        RRETURN(hr); // OK to return this as a UMI error

    // Try to map ADSI errors to appropriate UMI errors. Default is to
    // map to E_FAIL.
    switch(hr) {
        case E_ADS_INVALID_DOMAIN_OBJECT:
        case E_ADS_INVALID_USER_OBJECT:
        case E_ADS_INVALID_COMPUTER_OBJECT:
        case E_ADS_UNKNOWN_OBJECT:
        
            RRETURN(UMI_E_OBJECT_NOT_FOUND);

        case E_ADS_PROPERTY_NOT_FOUND:
            RRETURN(UMI_E_PROPERTY_NOT_FOUND);

        case E_ADS_BAD_PARAMETER:
            RRETURN(UMI_E_INVALIDARG);

        case E_ADS_CANT_CONVERT_DATATYPE:
            RRETURN(UMI_E_TYPE_MISMATCH);

        case E_ADS_BAD_PATHNAME:
            RRETURN(UMI_E_INVALIDARG);

        case E_ADS_OBJECT_UNBOUND:
            RRETURN(UMI_E_UNBOUND_OBJECT);

        case HRESULT_FROM_WIN32(NERR_UserNotFound):
        case HRESULT_FROM_WIN32(NERR_GroupNotFound):
        case HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN):
        case HRESULT_FROM_WIN32(ERROR_BAD_NETPATH):

            RRETURN(UMI_E_OBJECT_NOT_FOUND);

        default:
            RRETURN(UMI_E_FAIL);
    }
}

//----------------------------------------------------------------------------
// Function:   ValidateUrl 
//
// Synopsis:   This function checks to see if a UMI path has the correct
//             namespace and server.
//
// Arguments:
//
// pURL        Pointer to URL interface containing the UMI path
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   Nothing 
//
//----------------------------------------------------------------------------
static HRESULT ValidateUrl(
    IUmiURL *pURL
    )
{
    HRESULT hr = S_OK;
    WCHAR   pszTmpArray[MAX_URL+1];
    ULONG   ulTmpArraySize = 0;
    ULONGLONG PathType = 0;

    hr = pURL->GetPathInfo(0, &PathType);
    BAIL_ON_FAILURE(hr);

    if(PathType & UMIPATH_INFO_RELATIVE_PATH)
    // relative paths cannot be converted to a WinNT path
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);
 
    // Make sure server name is empty. WinNT does not support servername
    // in UMI path.
    ulTmpArraySize = MAX_URL;
    hr = pURL->GetLocator(
        &ulTmpArraySize,
        pszTmpArray
        );
    if(WBEM_E_BUFFER_TOO_SMALL == hr)
    // Locator is not an empty string
        hr = UMI_E_INVALID_PATH;
    BAIL_ON_FAILURE(hr);

    if(wcscmp(pszTmpArray, L""))
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);

    // Make sure namespace is WinNT
    ulTmpArraySize = MAX_URL;
    hr = pURL->GetRootNamespace(
        &ulTmpArraySize,
        pszTmpArray
        );
    if(WBEM_E_BUFFER_TOO_SMALL == hr)
    // Namespace is not WinNT
        hr = UMI_E_INVALID_PATH;
    BAIL_ON_FAILURE(hr);

    if(_wcsicmp(pszTmpArray, L"WinNT"))
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);

error:

    RRETURN(hr);
}


 
//----------------------------------------------------------------------------
// Function:   UmiToWinNTPath 
//
// Synopsis:   This function converts a UMI path into a native path. 
//
// Arguments: 
//
// pURL          Pointer to URL interface containing the UMI path
// ppszWinNTPath Returns the WinNT path 
// pdwNumComps   Returns the number of components in the UMI path
// pppszClasses  Returns the class of each component in the UMI path
//
// Returns:    S_OK on success. Error code otherwise. 
//
// Modifies:   *ppszWinNTPath to return the WinNT path
//             *pdwNumComps to return the number of components
//             *pppszClasses to return the class of each component
//
//----------------------------------------------------------------------------
HRESULT UmiToWinNTPath(
    IUmiURL *pURL,  
    WCHAR   **ppszWinNTPath,
    DWORD *pdwNumComps,
    LPWSTR **pppszClasses
    )
{
    HRESULT hr = S_OK;
    WCHAR   *pszWinNTPath = NULL;
    WCHAR   pszTmpArray[MAX_URL+1], pszValueArray[MAX_URL+1];
    WCHAR   *pszValuePtr = NULL, pszClassArray[MAX_URL+1];
    ULONG   ulTmpArraySize = 0, ulNumComponents = 0, ulIndex = 0;
    ULONG   ulKeyCount = 0, ulValueArraySize = 0, ulClassArraySize = 0;
    IUmiURLKeyList *pKeyList = NULL;
    LPWSTR  *ppszClasses = NULL;

    ADsAssert( (pURL != NULL) && (ppszWinNTPath != NULL) &&
               (pdwNumComps != NULL) && (pppszClasses != NULL) );

    *ppszWinNTPath = NULL;
    *pdwNumComps = 0;
    *pppszClasses = NULL;

    hr = ValidateUrl(pURL);
    BAIL_ON_FAILURE(hr);

    // Get the total length needed for the WinNT path
    ulTmpArraySize = MAX_URL;
    hr = pURL->Get(0, &ulTmpArraySize, pszTmpArray);
    if(hr != WBEM_E_BUFFER_TOO_SMALL)
        BAIL_ON_FAILURE(hr);

    pszWinNTPath = (WCHAR *) AllocADsMem(ulTmpArraySize * sizeof(WCHAR));
    if(NULL == pszWinNTPath)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    wsprintf(pszWinNTPath, L"%s", L"WinNT:");

    hr = pURL->GetComponentCount(&ulNumComponents);
    BAIL_ON_FAILURE(hr);

    if(0 == ulNumComponents) {
    // umi:///winnt translates to WinNT: . Nothing more to do
        *ppszWinNTPath = pszWinNTPath;
        RRETURN(S_OK);
    }

    ppszClasses = (LPWSTR *) AllocADsMem(ulNumComponents * sizeof(LPWSTR *));
    if(NULL == ppszClasses) {
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    }
    memset(ppszClasses, 0, ulNumComponents * sizeof(LPWSTR *));

    // we have at least one component in the path
    wcscat(pszWinNTPath, L"/");

    for(ulIndex = 0; ulIndex < ulNumComponents; ulIndex++) {
        ulClassArraySize = MAX_URL;
        pKeyList = NULL;

        hr = pURL->GetComponent(
            ulIndex,
            &ulClassArraySize, 
            pszClassArray,
            &pKeyList
            );
        if(WBEM_E_BUFFER_TOO_SMALL == hr)
        // none of the WinNT classes is so long, so this has to be a bad path.
            hr = UMI_E_INVALID_PATH;
        BAIL_ON_FAILURE(hr);

        // WinNT does not supports components with an empty class name
        if(!wcscmp(pszClassArray, L""))
            BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);

        ppszClasses[ulIndex] = AllocADsStr(pszClassArray);
        if(NULL == ppszClasses[ulIndex]) {
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY); 
        }

        ADsAssert(pKeyList != NULL);

        // make sure there is only one key
        hr = pKeyList->GetCount(&ulKeyCount);
        BAIL_ON_FAILURE(hr);

        if(ulKeyCount != 1)
            BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);

        ulValueArraySize = MAX_URL;
        ulTmpArraySize = MAX_URL;
        pszValuePtr = pszValueArray;
        hr = pKeyList->GetKey(
            0,
            0,
            &ulTmpArraySize,
            pszTmpArray,
            &ulValueArraySize,
            pszValueArray
            );
        if( (WBEM_E_BUFFER_TOO_SMALL == hr) && (ulValueArraySize > MAX_URL) ) {
            pszValuePtr = (WCHAR *) AllocADsMem(ulValueArraySize);
            if(NULL == pszValuePtr)
                BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

            hr = pKeyList->GetKey(
                0,
                0,
                &ulTmpArraySize,
                pszTmpArray,
                &ulValueArraySize,
                pszValuePtr
                );
        }
        if(WBEM_E_BUFFER_TOO_SMALL == hr)
        // Key is always "Name" in WinNT. So, if the size required if so
        // high, it indicates a bad path
            hr = UMI_E_INVALID_PATH;

        BAIL_ON_FAILURE(hr);
       
        // Key has to be "Name" or empty in WinNT
        if( _wcsicmp(pszTmpArray, WINNT_KEY_NAME) && wcscmp(pszTmpArray, L"") )
            BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH); 

        // append the value to the WinNT path
        wcscat(pszWinNTPath, L"/");
        wcscat(pszWinNTPath, pszValuePtr);

        if(pszValuePtr != pszValueArray)
            FreeADsMem(pszValuePtr);

        pKeyList->Release();
    } // for

    // append the class to the WInNT path
    wcscat(pszWinNTPath, L",");
    wcscat(pszWinNTPath, pszClassArray);
 
    *ppszWinNTPath = pszWinNTPath;
    *pdwNumComps = ulNumComponents;
    *pppszClasses = ppszClasses;

     RRETURN(S_OK);
   
error:

    if(pszWinNTPath != NULL)
        FreeADsMem(pszWinNTPath);

    if( (pszValuePtr != NULL) && (pszValuePtr != pszValueArray) )
        FreeADsMem(pszValuePtr);

    if(ppszClasses != NULL) {
        for(ulIndex = 0; ulIndex < ulNumComponents; ulIndex++) {
            if(ppszClasses[ulIndex] != NULL)
                FreeADsStr(ppszClasses[ulIndex]);
        }

        FreeADsMem(ppszClasses);
    } 
             
    if(pKeyList != NULL)
        pKeyList->Release();

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   ADsToUmiPath
//
// Synopsis:   This function converts an ADsPath to a UMI path (full, short or
//             relative depending on a flag).
//
// Arguments:
//
// bstrADsPath   ADsPath to be converted
// pObjectInfo   Contains the values of each component in the ADsPath
// CompClasses   Array containing the classes of each component of the ADsPath
// dwNumComponents  Number of classes(components) in the ADsPath 
// dwUmiPathType Specifies the format of the UMI path to be returned
// ppszUmiPath   Returns UMI path in the requested format
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppszUmiPath to return the UMI path
//
//----------------------------------------------------------------------------
HRESULT ADsToUmiPath(
    BSTR bstrADsPath,
    OBJECTINFO *pObjectInfo,
    LPWSTR CompClasses[],
    DWORD dwNumComponents,
    DWORD dwUmiPathType,
    LPWSTR *ppszUmiPath
    )
{
    HRESULT hr = S_OK;
    DWORD   dwBufferLen = 0, dwIndex = 0;
    LPWSTR  pszUmiPath = NULL, *pszComponents = NULL;

    ADsAssert( (bstrADsPath != NULL) && (CompClasses != NULL) && 
               (pObjectInfo != NULL) && (ppszUmiPath != NULL) );
    *ppszUmiPath = NULL;

    // calculate approximate length of buffer required to return the UMI path
    // Each component is of the form "class.name=value". "value" is already
    // part of the ADSI path. Include the size of each class and add 6 to 
    // account for "Name" and '.' and '='.
    dwBufferLen = wcslen(L"umi:///winnt/") + wcslen(bstrADsPath) +
                  dwNumComponents * (MAX_CLASS + 6) + 1;

    pszUmiPath = (LPWSTR) AllocADsMem(dwBufferLen * sizeof(WCHAR));
    if(NULL == pszUmiPath)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    // if ADsPath is empty and it is not a namespace object, then this must be
    // a session, resource or  printjob object. Return an empty path for these.
    // Namespace objects have no components in the ADsPath, but they have a
    // non-empty ADsPath ("WinNT:")
    if( (0 == dwNumComponents) && _wcsicmp(CompClasses[0], L"Namespace") ) {
        wcscpy(pszUmiPath, L"");
        *ppszUmiPath = pszUmiPath;
    
        RRETURN(S_OK);
    } 

    if( (RELATIVE_UMI_PATH == dwUmiPathType) || 
        (FULL_RELATIVE_UMI_PATH == dwUmiPathType) ) {
        // return the last component, if any

        if(0 == dwNumComponents) {
            *pszUmiPath = '\0';
        }
        else {
            wcscpy(pszUmiPath, 
                   CompClasses[dwNumComponents - 1]
                   );
            if(FULL_RELATIVE_UMI_PATH == dwUmiPathType)
                wcscat(pszUmiPath, L".Name=");
            else
                wcscat(pszUmiPath, L"=");
    
            pszComponents = pObjectInfo->DisplayComponentArray;        

            wcscat(pszUmiPath, pszComponents[dwNumComponents - 1]);
        }

        *ppszUmiPath = pszUmiPath;

        RRETURN(S_OK);
    }

    wcscpy(pszUmiPath, L"umi:///winnt");

    // for namespace objects, there are no components and hence the umi path
    // is completely constructed at this point.
    if(0 == dwNumComponents) {
        *ppszUmiPath = pszUmiPath;
        RRETURN(S_OK);
    }

    wcscat(pszUmiPath, L"/");

    pszComponents = pObjectInfo->DisplayComponentArray;

    for(dwIndex = 0; dwIndex < dwNumComponents; dwIndex++) {
        wcscat(pszUmiPath, CompClasses[dwIndex]);
        if(FULL_UMI_PATH == dwUmiPathType)
            wcscat(pszUmiPath, L".Name=");
        else if(SHORT_UMI_PATH == dwUmiPathType)
            wcscat(pszUmiPath, L"=");

        wcscat(pszUmiPath, pszComponents[dwIndex]);
        if(dwIndex != (dwNumComponents - 1))
            wcscat(pszUmiPath, L"/");
    }

    *ppszUmiPath = pszUmiPath;

    RRETURN(S_OK);

error:

    if(pszUmiPath != NULL)
        FreeADsMem(pszUmiPath);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\winnt\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\xml\adsxml2.h ===
#define ADSXML_LIBIID_XMLOle 61340306-e79c-401d-a34a-cbbc99199025
#define ADSXML_IID_IADsXML   91e5c5dc-926b-46ff-9fdb-9fb112bf10e6
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\winntrc.h ===
#ifndef __ADSRC_H__
#define __ADSRC_H__

#define ADS_WINNT_BUILTIN           600000
#define ADS_WINNT_NT_AUTHORITY 	    600001
#define ADS_WINNT_NONE              600002
#define ADS_WINNT_EVERYONE          600003

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\winnt2.h ===
#define WINNT_LIBIID_WinNTOle              0214d870-fd16-11ce-abc4-02608c9e7553
#define WINNT_CLSID_WinNTNamespace         250e91a0-0367-11cf-abc4-02608c9e7553

#define WINNT_CLSID_WinNTDomain            01544ed0-fd16-11ce-abc4-02608c9e7553
#define WINNT_CLSID_WinNTUser              d83f1060-1e71-11cf-b1f3-02608c9e7553
#define WINNT_CLSID_WinNTGroup             d9c1aad0-1e71-11cf-b1f3-02608c9e7553
#define WINNT_CLSID_WinNTComputer          da438dc0-1e71-11cf-b1f3-02608c9e7553

#define WINNT_CLSID_WinNTService           636ec6e0-4c66-11cf-a995-00aa006bc149
#define WINNT_CLSID_WinNTFileService       881fe380-6ca1-11cf-a99b-00aa006bc149

#define WINNT_CLSID_WinNTPrintQueue        6c4a7120-4c66-11cf-a995-00aa006bc149
#define WINNT_CLSID_WinNTPrintJob          60002920-6ca1-11cf-a99b-00aa006bc149

#define WINNT_CLSID_WinNTSession           9e066670-6ca1-11cf-a99b-00aa006bc149
#define WINNT_CLSID_WinNTFileShare         b41ac100-6ca1-11cf-a99b-00aa006bc149
#define WINNT_CLSID_WinNTResource          f435bbf0-873d-11cf-a99f-00aa006bc149

#define WINNT_CLSID_WinNTSchema            6dc32210-4d19-11cf-9e74-00aa004a5691
#define WINNT_CLSID_WinNTClass             6dc32211-4d19-11cf-9e74-00aa004a5691
#define WINNT_CLSID_WinNTProperty          6dc32212-4d19-11cf-9e74-00aa004a5691
#define WINNT_CLSID_WinNTSyntax            6dc32213-4d19-11cf-9e74-00aa004a5691

#define WINNT_CLSID_FPNWFileService        a117d530-a1eb-11cf-a9a5-00aa006bc149
#define WINNT_CLSID_FPNWSession            a819cb50-a1eb-11cf-a9a5-00aa006bc149
#define WINNT_CLSID_FPNWFileShare          adf040b0-a1eb-11cf-a9a5-00aa006bc149 
#define WINNT_CLSID_FPNWResource           b381f2a0-a1eb-11cf-a9a5-00aa006bc149
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\xml\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{$(O)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\xml\base64.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     base64.cxx
//
//  Contents: Contains the implementation of base64 encoding.
//
//----------------------------------------------------------------------------

#include <ctype.h>

#include "cadsxml.hxx"

#define NL_STR            "\r\n"
#define NL_STR_LEN        2
#define OCTETS_PER_GROUP  3
#define SEXTETS_PER_GROUP 4

#define BASE64_PAD_CHAR  '='
#define BASE64_PAD_INDEX 64

/* NOTE: the pad character base64Alphabet[BASE64_PAD_INDEX] doesn't */
/*       really belong the strict definition of the Base64 character set */
static
char base64Alphabet[65] = {
'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 
'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 
'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/', '='
};

//---------------------------------------------------------------------------
// Function: encodeGroup
//
// Synopsis: Performs base64 encoding of a group of 3 bytes.
//
// Arguments:
//
// inBufPtr    Pointer to data to encode
// encodeBufPtr Encoded data
// inBufLen    Number of bytes in inBufPtr
//
// Returns:    Number of encoded sextets
//
// Modifies:   encodeBufPtr to store the encoded data.
//
//-------------------------------------------------------------------------- 
static int encodeGroup (
    char *inBufPtr,                /* input buffer to encode (3 8-bit octets) */
    char *encodeBufPtr,            /* encode buffer (4 6-bit sextets) */
    int inBufLen )
{
   int i;
   unsigned char octet;

   if (inBufLen > OCTETS_PER_GROUP)
      return(0);

   /* perform base64 encoding (convert 3 8-bit groups to 4 6-bit groups) */
   memset(encodeBufPtr, 0, SEXTETS_PER_GROUP);
   for (i=0; i<inBufLen; i++) {

      octet = *(inBufPtr + i);
      switch (i) {
      case 0:
         *encodeBufPtr = (char)(octet >> 2);
         *(encodeBufPtr+1) |= (char)((octet & 0x3) << 4);
         break;
      case 1:
         *(encodeBufPtr+1) |= (char)(octet >> 4);
         *(encodeBufPtr+2) |= (char)((octet & 0xf) << 2);
         break;
      case 2:
         *(encodeBufPtr+2) |= (char)(octet >> 6);
         *(encodeBufPtr+3) |= (char)(octet & 0x3f);
         break;
      }
   }

   /* perform padding for incomplete octet groups */
   switch (inBufLen) {
   case 1:
      *(encodeBufPtr+2) = BASE64_PAD_INDEX;
      /* the missing break is intentional! */
   case 2:
      *(encodeBufPtr+3) = BASE64_PAD_INDEX;
      break;
   default:
      break;
   }

   /* translate all base64 codes into characters from the base64 alphabet */
   for (i=0; i<SEXTETS_PER_GROUP; i++)
      *(encodeBufPtr+i) = base64Alphabet[ *(encodeBufPtr+i) ];

   return(SEXTETS_PER_GROUP);   /* # of encoded sextets (incldg padding) */
}


//--------------------------------------------------------------------------
// Function: encodeBase64Buffer
//
// Synopsis: Encodes a data buffer using the "Base64" method.
//
// Arguments:
//
// inBufPtr    points to input data 
// inBytesPtr  points to number of bytes in inBufPtr 
// outBufPtr   points to output area for encoded data
// outBytesPtr points to size of outBufPtr 
// outLineLen  number of base64 characters to output per
//             line (each line is <CR><LF> terminated) 
//
// Returns :   0 if successful, -1 otherwise.
//
// Modifies:  *inBytesPtr to return the number of bytes encoded.
//            *outBytesPtr to return number of bytes placed in outBufPtr.
//            outBufPtr returns the encoded data.
//
//--------------------------------------------------------------------------
int encodeBase64Buffer (
    char *inBufPtr,
    int *inBytesPtr,
    WCHAR *outBufPtr,
    int *outBytesPtr,
    int outLineLen
    )
{
   int i, ret, bytesToEncode, outBufSize, startOffset, encodeLen;
   int octetCount, lineCount, outOfSpace;
   char inBuf[OCTETS_PER_GROUP], encodeBuf[SEXTETS_PER_GROUP+NL_STR_LEN];
   char *ptr;

   bytesToEncode = *inBytesPtr;
   outBufSize    = *outBytesPtr;
   *inBytesPtr = 0;
   *outBytesPtr = 0;
   if (bytesToEncode <= 0  ||  outBufSize <= 0)
      return(-1);

   startOffset = -1;
   octetCount = lineCount = outOfSpace = 0;
   for (i=0;  i < bytesToEncode  &&  !outOfSpace;  i++) {
      ptr = inBufPtr + i;

      if (startOffset < 0)
         startOffset = i;

      inBuf[octetCount++] = *ptr;
      
      /* encode the octet group if sufficient octets have been accumulated */
      /* or if we're on the last byte */
      if (octetCount == OCTETS_PER_GROUP
      || (i == bytesToEncode-1)) {  
 
         /* encode the input octet group into an sextet group */
         encodeLen = encodeGroup(inBuf, encodeBuf, octetCount);

         lineCount += encodeLen;
         if (lineCount >= outLineLen) {
            memcpy(&encodeBuf[encodeLen], NL_STR, NL_STR_LEN);
            encodeLen += NL_STR_LEN;
            lineCount = 0;
         }
         if (*outBytesPtr + encodeLen > outBufSize)
            outOfSpace = 1;
         else {

            /* write decoded octets to output buffer */
            ret = mbstowcs(outBufPtr + *outBytesPtr, encodeBuf, encodeLen);
            *outBytesPtr += encodeLen;
            *inBytesPtr  += i - startOffset + 1;

            startOffset = -1;
            octetCount = 0;   
         }
      }
   }

   // Null terminate output
   if(*outBytesPtr < outBufSize) {
       *(outBufPtr + *outBytesPtr) = L'\0';
       (*outBytesPtr)++;
   }


   return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\xml\cadsxml.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     cadsxml.cxx
//
//  Contents: Contains the implementation of ADsXML. This class implements
//  XML persistence as an ADSI extension.  
//
//----------------------------------------------------------------------------

#include "cadsxml.hxx"

long glnObjCnt = 0;

// not used
ULONG g_ulObjCount = 0;

LPWSTR g_SchemaAttrs[] = { OID,
                          LDAP_DISPLAY_NAME,
                          TYPE,
                          SUBCLASSOF,
                          DESCRIPTION,
                          MUST_CONTAIN,
                          SYSTEM_MUST_CONTAIN,
                          MAY_CONTAIN,
                          SYSTEM_MAY_CONTAIN
                        };
DWORD g_dwNumSchemaAttrs = sizeof(g_SchemaAttrs)/sizeof(LPWSTR);

SEARCHPREFINFO g_SearchPrefInfo[] = 
{
    {ADS_SEARCHPREF_ASYNCHRONOUS, VT_BOOL, L"Asynchronous"},
    {ADS_SEARCHPREF_DEREF_ALIASES, VT_I4, L"Deref Aliases"},
    {ADS_SEARCHPREF_SIZE_LIMIT, VT_I4,L"Size Limit"},
    {ADS_SEARCHPREF_TIME_LIMIT, VT_I4, L"Server Time Limit"},
//    {ADS_SEARCHPREF_ATTRIBTYPES_ONLY, VT_BOOL, L"Column Names only"},
    {ADS_SEARCHPREF_TIMEOUT, VT_I4, L"Timeout"},
    {ADS_SEARCHPREF_PAGESIZE, VT_I4, L"Page size"},
    {ADS_SEARCHPREF_PAGED_TIME_LIMIT, VT_I4, L"Time limit"},
    {ADS_SEARCHPREF_CHASE_REFERRALS, VT_I4, L"Chase referrals"},
    {ADS_SEARCHPREF_SORT_ON, VT_BSTR, L"Sort On"},
    {ADS_SEARCHPREF_CACHE_RESULTS, VT_BOOL, L"Cache Results"}
};

DWORD g_dwNumSearchPrefInfo = sizeof(g_SearchPrefInfo)/sizeof(SEARCHPREFINFO);
                          

DEFINE_IADsExtension_Implementation(CADsXML)
DEFINE_DELEGATING_IDispatch_Implementation(CADsXML)

//----------------------------------------------------------------------------
// Function:   CADsXML
//
// Synopsis:   Constructor. Initializes member variables.
//
// Arguments:  None
//
// Returns:    Nothing
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
CADsXML::CADsXML(void)
{
    _pUnkOuter = NULL;
    _pADs = NULL;
    _pDispMgr = NULL;
    m_pCredentials = NULL;
    m_hFile = INVALID_HANDLE_VALUE;

    // make sure DLL isn't unloaded until all objects are destroyed
    InterlockedIncrement(&glnObjCnt);
}

//----------------------------------------------------------------------------
// Function:   ~CADsXML
//
// Synopsis:   Destructor. Frees member variables.
//
// Arguments:  None
//
// Returns:    Nothing
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
CADsXML::~CADsXML(void)
{
    if(m_pCredentials != NULL)
        delete m_pCredentials;

    InterlockedDecrement(&glnObjCnt);

    if(_pDispMgr != NULL)
        delete _pDispMgr;

    //
    // no need to release _pUnkOuter since aggregatee cannot hold a reference
    // on aggregator.
    //
}

//----------------------------------------------------------------------------
// Function:   SaveXML 
//
// Synopsis:   Implements XML persistence. 
//
// Arguments:  See IADsXML reference 
//
// Returns:    S_OK on success, error otherwise. 
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP CADsXML::SaveXML(
    VARIANT vDest,
    BSTR szFilter,
    BSTR szAttrs,
    long lScope,
    BSTR xslRef,
    long lFlag,
    BSTR szOptions,
    VARIANT *pDirSyncCookie
    )
{
    HRESULT hr = S_OK;
    LPWSTR  pszAttrs = NULL, pszOptions = NULL;

    // Validate inpute args
    hr = ValidateArgs(
            vDest, 
            lScope,
            lFlag,
            pDirSyncCookie
            );
    BAIL_ON_FAILURE(hr);

    // Open output stream for writing 
    hr = OpenOutputStream(vDest);
    BAIL_ON_FAILURE(hr);

    hr = WriteXMLHeader(xslRef);
    BAIL_ON_FAILURE(hr);

    // remove white spaces from attributes and search options, if required
    if(szAttrs != NULL) {
        pszAttrs = RemoveWhiteSpace(szAttrs);
        if(NULL == pszAttrs) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }
    if(szOptions != NULL) {
        pszOptions = ReduceWhiteSpace(szOptions);
        if(NULL == pszOptions) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

    // persist schema first if required
    if(lFlag & ADS_XML_SCHEMA) {
        hr = OutputSchema();
        BAIL_ON_FAILURE(hr);
    }

    if(lFlag & ADS_XML_DSML) {
        hr = OutputData(
                szFilter,
                pszAttrs,
                lScope,
                pszOptions
                );
        BAIL_ON_FAILURE(hr);
    }

    hr = WriteXMLFooter();
    BAIL_ON_FAILURE(hr);

    CloseOutputStream();

    if(pszAttrs != NULL)
        FreeADsStr(pszAttrs);

    if(pszOptions != NULL)
        FreeADsMem(pszOptions);

    RRETURN(S_OK);

error:

    if(pszAttrs != NULL)
        FreeADsStr(pszAttrs);

    if(pszOptions != NULL)
        FreeADsMem(pszOptions);

    RRETURN(hr);
}


    
//----------------------------------------------------------------------------
// Function:   ValidateArgs
//
// Synopsis:   Validates the arguments passed into SaveXML 
//
// Arguments:  See IADsXML reference
//
// Returns:    S_OK on success, error otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CADsXML::ValidateArgs(
    VARIANT vDest,
    long lScope,
    long lFlag,
    VARIANT *pDirSyncCookie
    )
{
    ULONG ulDsmlVer = 0;

    if( (V_VT(&vDest) != VT_BSTR) || (NULL == V_BSTR(&vDest)) )
        RRETURN(E_INVALIDARG);

    if( (lScope != ADS_SCOPE_BASE) && (lScope != ADS_SCOPE_ONELEVEL) &&
        (lScope != ADS_SCOPE_SUBTREE) )
        RRETURN(E_INVALIDARG);

    //
    // 4 MSBs of lFlag specify DSML version. Check to see if this is a
    // supported value.
    // 
    ulDsmlVer = ((ULONG) (lFlag & 0xf0000000)) >> 28;
    if(ulDsmlVer > 1)
        RRETURN(E_ADSXML_NOT_SUPPORTED);

    // check if lFlag is valid
    if( (lFlag & 0x0fffffff) & (~(ADS_XML_DSML | ADS_XML_SCHEMA)) )
        RRETURN(E_INVALIDARG);

    // not supported for now 
//    if(pDirSyncCookie != NULL)
//        RRETURN(E_INVALIDARG);

    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
// Function:   OpenOutputStream 
//
// Synopsis:   Opens the output stream for writing. Creates a file to store the
//             XML output.
//
// Arguments:  
//
// vDest       Specifies destination
//
// Returns:    S_OK on success, error otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CADsXML::OpenOutputStream(
    VARIANT vDest
    )
{
    LPWSTR pszFileName = NULL;
    HRESULT hr = S_OK;

    pszFileName = V_BSTR(&vDest);

    m_hFile = CreateFile(
                  pszFileName,
                  GENERIC_WRITE,
                  0,
                  NULL,
                  CREATE_ALWAYS,
                  FILE_ATTRIBUTE_NORMAL,
                  NULL
                  );

    if(INVALID_HANDLE_VALUE == m_hFile) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    RRETURN(S_OK);

error:

    RRETURN(hr);
} 

//----------------------------------------------------------------------------
// Function:   WriteXMLHeader 
//
// Synopsis:   Writes the standard XML header to the output. This includes
//             the XML version, XSL ref (if specified) and the DSML namespace. 
//
// Arguments:
//
// xslRef      XSL reference
//
// Returns:    S_OK on success, error otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CADsXML::WriteXMLHeader(
    BSTR xslRef
    )
{
    HRESULT hr = S_OK;
    WCHAR   szUnicodeMark[] = {0xfeff, 0};

    BAIL_ON_FAILURE(hr = Write(szUnicodeMark));

    BAIL_ON_FAILURE(hr = WriteLine(XML_HEADING));

    if(xslRef != NULL) {
        BAIL_ON_FAILURE(hr = Write(XML_STYLESHEET_REF));
        BAIL_ON_FAILURE(hr = Write(xslRef, TRUE));
        BAIL_ON_FAILURE(hr = WriteLine(XML_STYLESHEET_REF_END));
    }

    BAIL_ON_FAILURE(hr = WriteLine(DSML_NAMESPACE));

    RRETURN(S_OK);

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   WriteXMLFooter
//
// Synopsis:   Closes the XML document with the appropriate tag. 
//
// Arguments:
//
// Returns:    S_OK on success, error otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CADsXML::WriteXMLFooter(void)
{
    HRESULT hr = S_OK;

    hr = WriteLine(XML_FOOTER);
    BAIL_ON_FAILURE(hr);

    RRETURN(S_OK);

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   OutputSchema 
//
// Synopsis:   Writes the schema to the output stream 
//
// Arguments:
//
// Returns:    S_OK on success, error otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CADsXML::OutputSchema(void)
{   
    HRESULT hr = S_OK;
    IADsObjectOptions *pObjOpt = NULL;
    VARIANT vServer, vSchemaPath;
    LPWSTR pszRootDSEPath = NULL, pszSchemaPath = NULL;
    IADs *pIADs = NULL;
    IDirectorySearch *pSearch = NULL;
    ADS_SEARCHPREF_INFO searchPrefs[2];
    ADS_SEARCH_HANDLE hSearch=NULL;
    LPWSTR pszUserName = NULL, pszPasswd = NULL;

    VariantInit(&vServer);
    VariantInit(&vSchemaPath);

    hr = _pUnkOuter->QueryInterface(
                IID_IADsObjectOptions,
                (void **) &pObjOpt
                );
    BAIL_ON_FAILURE(hr);

    hr = pObjOpt->GetOption(ADS_OPTION_SERVERNAME, &vServer);
    BAIL_ON_FAILURE(hr);

    pszRootDSEPath = (LPWSTR) AllocADsMem((wcslen(V_BSTR(&vServer)) 
                                 + wcslen(L"LDAP://")
                                 + wcslen(L"/RootDSE") + 1) * 2);
    wcscpy(pszRootDSEPath, L"LDAP://");
    wcscat(pszRootDSEPath, V_BSTR(&vServer));
    wcscat(pszRootDSEPath, L"/RootDSE");

    hr = ADsOpenObject(
            pszRootDSEPath,
            NULL,
            NULL,
            0,
            IID_IADs,
            (void **) &pIADs
            );
    BAIL_ON_FAILURE(hr);

    hr = pIADs->Get(L"schemanamingcontext", &vSchemaPath);
    BAIL_ON_FAILURE(hr);

    pszSchemaPath = (LPWSTR) AllocADsMem((wcslen(V_BSTR(&vSchemaPath)) + 
                                wcslen(L"LDAP://") + wcslen(V_BSTR(&vServer)) +
                                2) * 2);
    wcscpy(pszSchemaPath, L"LDAP://");
    wcscat(pszSchemaPath, V_BSTR(&vServer));
    wcscat(pszSchemaPath, L"/");
    wcscat(pszSchemaPath, V_BSTR(&vSchemaPath));

    hr = m_pCredentials->GetUserName(&pszUserName);
    BAIL_ON_FAILURE(hr);

    hr = m_pCredentials->GetPassword(&pszPasswd);
    BAIL_ON_FAILURE(hr);

    hr = ADsOpenObject(
            pszSchemaPath,
            pszUserName,
            pszPasswd,
            m_dwAuthFlags,
            IID_IDirectorySearch,
            (void **) &pSearch
            );
    BAIL_ON_FAILURE(hr);

    // set the preferences for the search
    searchPrefs[0].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    searchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
    searchPrefs[0].vValue.Integer = SCHEMA_PAGE_SIZE;

    searchPrefs[1].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    searchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
    searchPrefs[1].vValue.Integer = ADS_SCOPE_ONELEVEL;

    hr = pSearch->SetSearchPreference(searchPrefs, 2);
    BAIL_ON_FAILURE(hr);

    hr = pSearch->ExecuteSearch(
                SCHEMA_FILTER, 
                g_SchemaAttrs, 
                g_dwNumSchemaAttrs,
                &hSearch
                );

    BAIL_ON_FAILURE(hr);

    //
    // if the search returned no results and the user requested schema to be
    // returned, return an error.
    //
    hr = pSearch->GetFirstRow(hSearch);
    BAIL_ON_FAILURE(hr);

    if(S_ADS_NOMORE_ROWS == hr) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED));
    }

    hr = OutputSchemaHeader();
    BAIL_ON_FAILURE(hr);

    while(hr != S_ADS_NOMORE_ROWS) {
        hr = OutputClassHeader(hSearch, pSearch);
        BAIL_ON_FAILURE(hr);

        hr = OutputClassAttrs(hSearch, pSearch);
        BAIL_ON_FAILURE(hr);

        hr = OutputClassFooter();
        BAIL_ON_FAILURE(hr);

        hr = pSearch->GetNextRow(hSearch);
        BAIL_ON_FAILURE(hr);
    } 
        
    hr = OutputSchemaFooter();
    BAIL_ON_FAILURE(hr);

error:

    if(pszUserName != NULL)
        FreeADsStr(pszUserName);

    if(pszPasswd != NULL)
        FreeADsStr(pszPasswd);

    if(pObjOpt != NULL)
        pObjOpt->Release();

    VariantClear(&vServer);
    VariantClear(&vSchemaPath);

    if(pszRootDSEPath != NULL)
        FreeADsMem(pszRootDSEPath);

    if(pszSchemaPath != NULL)
        FreeADsMem(pszSchemaPath);

    if(pIADs != NULL)
        pIADs->Release();

    if(hSearch != NULL)
        pSearch->CloseSearchHandle(hSearch);

    if(pSearch != NULL)
        pSearch->Release();

    RRETURN(hr);
} 
                

//----------------------------------------------------------------------------
// Function:   OutputSchemaHeader
//
// Synopsis:   Writes the schema tag to the output stream
//
// Arguments:
//
// Returns:    S_OK on success, error otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CADsXML::OutputSchemaHeader(void)
{
    HRESULT hr = S_OK;

    hr = WriteLine(DSML_SCHEMA_TAG);
    RRETURN(hr);
} 

//----------------------------------------------------------------------------
// Function:   OutputClassHeader
//
// Synopsis:   Writes class the and attributes to the output. 
//
// Arguments:
//
// hSearch     Handle returned by IDirectorySearch
// pSearch     IDirectorySearch interface
//
// Returns:    S_OK on success, error otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CADsXML::OutputClassHeader(
    ADS_SEARCH_HANDLE hSearch, 
    IDirectorySearch *pSearch
    )
{
    ADS_SEARCH_COLUMN column;
    LPWSTR pszName = NULL;
    HRESULT hr = S_OK;

    hr = Write(DSML_CLASS_TAG);
    BAIL_ON_FAILURE(hr);

    hr = Write(L"id =\"");
    BAIL_ON_FAILURE(hr);
    hr = pSearch->GetColumn(hSearch, LDAP_DISPLAY_NAME, &column);
    BAIL_ON_FAILURE(hr);
    hr = Write(column.pADsValues->CaseIgnoreString, TRUE);
    pszName = AllocADsStr(column.pADsValues->CaseIgnoreString);
    if(NULL == pszName) {
        hr = E_OUTOFMEMORY;
    }
    pSearch->FreeColumn(&column);
    BAIL_ON_FAILURE(hr);
    hr = Write(L"\" ");
    BAIL_ON_FAILURE(hr);

    hr = Write(L"sup = \"");
    BAIL_ON_FAILURE(hr);
    hr = pSearch->GetColumn(hSearch, SUBCLASSOF, &column);
    BAIL_ON_FAILURE(hr);
    hr = Write(column.pADsValues->CaseIgnoreString, TRUE);
    pSearch->FreeColumn(&column);
    BAIL_ON_FAILURE(hr);
    hr = Write(L"\" ");
    BAIL_ON_FAILURE(hr);

    hr = Write(L"type = \"");
    BAIL_ON_FAILURE(hr);
    hr = pSearch->GetColumn(hSearch, TYPE, &column);
    BAIL_ON_FAILURE(hr);
    switch(column.pADsValues->Integer) {
        case 1:
            hr = Write(L"structural");
            break;
        case 2:
            hr = Write(L"abstract");
            break;
        case 3:
            hr = Write(L"auxiliary");
            break;
    }
    pSearch->FreeColumn(&column);
    BAIL_ON_FAILURE(hr);
    hr = WriteLine(L"\">");
    BAIL_ON_FAILURE(hr);

    hr = Write(NAME_TAG);
    BAIL_ON_FAILURE(hr);
    hr = Write(pszName, TRUE);
    BAIL_ON_FAILURE(hr);
    hr = WriteLine(NAME_TAG_CLOSE);
    BAIL_ON_FAILURE(hr);

    hr = Write(DESC_TAG);
    BAIL_ON_FAILURE(hr);
    hr = pSearch->GetColumn(hSearch, DESCRIPTION, & column);
    BAIL_ON_FAILURE(hr);
    hr = Write(column.pADsValues->CaseIgnoreString, TRUE);
    pSearch->FreeColumn(&column);
    BAIL_ON_FAILURE(hr);
    hr = WriteLine(DESC_TAG_CLOSE);
    BAIL_ON_FAILURE(hr);

    hr = Write(OID_TAG);
    BAIL_ON_FAILURE(hr);
    hr = pSearch->GetColumn(hSearch, OID, &column);
    BAIL_ON_FAILURE(hr);
    hr = Write(column.pADsValues->CaseIgnoreString, TRUE);
    pSearch->FreeColumn(&column);
    BAIL_ON_FAILURE(hr); 
    hr = WriteLine(OID_TAG_CLOSE);
    BAIL_ON_FAILURE(hr);

error:
    if(pszName)
        FreeADsStr(pszName);

    RRETURN(hr);
}

    
//----------------------------------------------------------------------------
// Function:   OutputClassAttrs
//
// Synopsis:   Writes the names of the attributes of a class and whether
//             they are mandatory or not.
//
// Arguments:
//
// hSearch     Handle returned by IDirectorySearch
// pSearch     IDirectorySearch interface
//
// Returns:    S_OK on success, error otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CADsXML::OutputClassAttrs(
    ADS_SEARCH_HANDLE hSearch, 
    IDirectorySearch *pSearch
    ) 
{
    HRESULT hr = S_OK;

    hr = OutputAttrs(hSearch, pSearch, MUST_CONTAIN, TRUE);
    if(E_ADS_COLUMN_NOT_SET == hr)
        hr = S_OK;
    BAIL_ON_FAILURE(hr);

    hr = OutputAttrs(hSearch, pSearch, SYSTEM_MUST_CONTAIN, TRUE);
    if(E_ADS_COLUMN_NOT_SET == hr)
        hr = S_OK;
    BAIL_ON_FAILURE(hr);

    hr = OutputAttrs(hSearch, pSearch, MAY_CONTAIN, FALSE);
    if(E_ADS_COLUMN_NOT_SET == hr)
        hr = S_OK;
    BAIL_ON_FAILURE(hr);

    hr = OutputAttrs(hSearch, pSearch, SYSTEM_MAY_CONTAIN, FALSE);
    if(E_ADS_COLUMN_NOT_SET == hr)
        hr = S_OK;
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   OutputAttrs
//
// Synopsis:   Writes the names of the attributes. 
//
// Arguments:
//
// hSearch     Handle returned by IDirectorySearch
// pSearch     IDirectorySearch interface
// pszAttrName Name of the attribute in the class schema object
// fMandatory  Indicates if the attributes are mandatory or not
//
// Returns:    S_OK on success, error otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CADsXML::OutputAttrs(
    ADS_SEARCH_HANDLE hSearch, 
    IDirectorySearch *pSearch,
    LPWSTR pszAttrName,
    BOOL fMandatory
    )
{
    HRESULT hr = S_OK;
    ADS_SEARCH_COLUMN column;
    DWORD i = 0;
    BOOL fFreeCols = FALSE;

    hr = pSearch->GetColumn(hSearch, pszAttrName, &column);
    BAIL_ON_FAILURE(hr);

    fFreeCols = TRUE;

    for(i = 0; i < column.dwNumValues; i++) {
        hr = Write(DSML_ATTR_TAG);
        BAIL_ON_FAILURE(hr);

        hr = Write(column.pADsValues[i].CaseIgnoreString, TRUE);
        BAIL_ON_FAILURE(hr);

        hr = Write(L"\" required=\"");
        BAIL_ON_FAILURE(hr);

        if(fMandatory)
            hr = Write(L"true");
        else
            hr = Write(L"false");
        BAIL_ON_FAILURE(hr);

        hr = WriteLine(L"\"/>");
    }

error:

    if(fFreeCols)
        pSearch->FreeColumn(&column);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   OutputClassFooter
//
// Synopsis:   Writes the end tag for the class
//
// Arguments:
//
// Returns:    S_OK on success, error otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CADsXML::OutputClassFooter(void)
{
    HRESULT hr = S_OK;

    hr = WriteLine(DSML_CLASS_TAG_CLOSE);
    RRETURN(hr);
}    
  
//----------------------------------------------------------------------------
// Function:   OutputSchemaFooter
//
// Synopsis:   Writes the schema end tag to the output stream
//
// Arguments:
//
// Returns:    S_OK on success, error otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CADsXML::OutputSchemaFooter(void)
{
    HRESULT hr = S_OK;

    hr = WriteLine(DSML_SCHEMA_TAG_CLOSE);
    RRETURN(hr);
}
     
//----------------------------------------------------------------------------
// Function:   CloseOutputStream
//
// Synopsis:   Closes the output stream.
//
// Arguments:
//
// vDest       Specifies destination
//
// Returns:    S_OK on success, error otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
void CADsXML::CloseOutputStream(void)
{
    if(m_hFile != INVALID_HANDLE_VALUE)
        CloseHandle(m_hFile);

    return;
}

//----------------------------------------------------------------------------
// Function:   Write 
//
// Synopsis:   Writes text to the output. Does not append newline. 
//
//
// szStr       String to write to the output.
// fEscape     Indicates if string should be escaped ot not. FALSE by default.
//
// Returns:    S_OK on success, error otherwise.
//
// Modifies:   Nothing
//
//---------------------------------------------------------------------------- 
HRESULT CADsXML::Write(LPWSTR szStr, BOOL fEscape)
{
    BOOL bRetVal = 0;
    DWORD dwNumBytesWritten = 0;
    HRESULT hr = S_OK;
    LPWSTR pszEscapedStr = NULL;
    int i = 0, j = 0;
    WCHAR wc; 

    ADsAssert(szStr != NULL);
 
    if(TRUE == fEscape) {
        pszEscapedStr = (LPWSTR) AllocADsMem(2*(wcslen(szStr)*6 + 1)); 
        if(NULL == pszEscapedStr) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }
    else
        pszEscapedStr = szStr;

    for(i = 0; (TRUE == fEscape) && (szStr[i] != L'\0'); i++) {
        switch(szStr[i]) {
            case L'<':
                pszEscapedStr[j++] = L'&';
                pszEscapedStr[j++] = L'l';
                pszEscapedStr[j++] = L't';
                pszEscapedStr[j++] = L';';
                break;
            case L'>':
                pszEscapedStr[j++] = L'&';
                pszEscapedStr[j++] = L'g';
                pszEscapedStr[j++] = L't';
                pszEscapedStr[j++] = L';';
                break;
            case L'\'':
                pszEscapedStr[j++] = L'&';
                pszEscapedStr[j++] = L'a';
                pszEscapedStr[j++] = L'p';
                pszEscapedStr[j++] = L'o';
                pszEscapedStr[j++] = L's';
                pszEscapedStr[j++] = L';';
                break;
            case L'"':
                pszEscapedStr[j++] = L'&';
                pszEscapedStr[j++] = L'q';
                pszEscapedStr[j++] = L'u';
                pszEscapedStr[j++] = L'o';
                pszEscapedStr[j++] = L't';
                pszEscapedStr[j++] = L';';
                break; 
            case L'&':
                pszEscapedStr[j++] = L'&';
                pszEscapedStr[j++] = L'a';
                pszEscapedStr[j++] = L'm';
                pszEscapedStr[j++] = L'p';
                pszEscapedStr[j++] = L';';
                break;
            default:
               pszEscapedStr[j++] = szStr[i];
               break;
        } // switch
    } // for

    // pszEscapedStr NULL terminated by AllocADsMem  
                

    bRetVal = WriteFile(
                m_hFile,
                pszEscapedStr,
                wcslen(pszEscapedStr)*2,
                &dwNumBytesWritten,
                NULL
                );

    if(0 == bRetVal) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

   if(dwNumBytesWritten != (wcslen(pszEscapedStr)*2)) {
        hr = HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_FILE);
        BAIL_ON_FAILURE(hr);
    }

error:

    if(pszEscapedStr && (pszEscapedStr != szStr))
        FreeADsMem(pszEscapedStr);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   WriteLine
//
// Synopsis:   Writes text to the output. Appends newline.
//
//
// szStr       String to write to the output.
// fEscape     Indicates if string should be escaped ot not. FALSE by default.
//
// Returns:    S_OK on success, error otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CADsXML::WriteLine(LPWSTR szStr, BOOL fEscape)
{   
    HRESULT hr = S_OK;

    ADsAssert(szStr != NULL);

    hr = Write(szStr, fEscape);
    BAIL_ON_FAILURE(hr);

    hr = Write(L"\n");
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
} 

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   Queries object for supported interfaces. 
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CADsXML::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    HRESULT hr = S_OK;

    hr = _pUnkOuter->QueryInterface(iid,ppInterface);

    RRETURN(hr);

}

//----------------------------------------------------------------------------
// Function:   NonDelegatingQueryInterface
//
// Synopsis:   Queries object for supported interfaces.
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CADsXML::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    ADsAssert(ppInterface);

    if (IsEqualIID(iid, IID_IUnknown)) 
        *ppInterface = (INonDelegatingUnknown FAR *) this;
    else if (IsEqualIID(iid, IID_IADsExtension)) 
        *ppInterface = (IADsExtension FAR *) this;
    else if (IsEqualIID(iid, IID_IADsXML))
        *ppInterface = (IADsXML FAR *) this;
    else {
        *ppInterface = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *) (*ppInterface)) -> AddRef();

    return S_OK;
}  

//----------------------------------------------------------------------------
// Function:   Operate 
//
// Synopsis:   Implements IADsExtension::Operate. 
//
// Arguments:
//
// dwCode      Extension control code
// varData1    Username
// varData2    Password
// varData3    User flags
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   Nothing. 
//
//----------------------------------------------------------------------------
STDMETHODIMP CADsXML::Operate(
    THIS_ DWORD dwCode,
    VARIANT varData1,
    VARIANT varData2,
    VARIANT varData3
    )
{
    HRESULT hr = S_OK;

    switch (dwCode) {
    
        case ADS_EXT_INITCREDENTIALS:
           ADsAssert(V_VT(&varData1) == VT_BSTR);
           ADsAssert(V_VT(&varData2) == VT_BSTR);
           ADsAssert(V_VT(&varData3) == VT_I4);

           m_pCredentials = new CCredentials(
                                  V_BSTR(&varData1), 
                                  V_BSTR(&varData2),
                                  V_I4(&varData3)
                                  );
           if(NULL == m_pCredentials)
               RRETURN(E_OUTOFMEMORY);

           m_dwAuthFlags = V_I4(&varData3);

           break;

        default:
           RRETURN(E_FAIL);
    }

    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
// Function:   OutputData
//
// Synopsis:   Outputs data portion of DSML. 
//
// Arguments:
//
// szFilter    Search filter
// szAttrs     Attributes requested
// lScope      Search scope
// szOptions   Search preferences
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------                                       
                                  
HRESULT CADsXML::OutputData(
    BSTR szFilter,
    BSTR szAttrs,
    long lScope,
    BSTR szOptions
    )
{
    HRESULT hr = S_OK;
    IDirectorySearch *pSearch = NULL;
    LPWSTR *pAttrs = NULL;
    DWORD dwNumAttrs = 0, dwNumPrefs = 0;
    ADS_SEARCHPREF_INFO *psearchPrefs = NULL, searchPrefs;
    ADS_SEARCH_HANDLE hSearch=NULL;

    hr = _pUnkOuter->QueryInterface(
                IID_IDirectorySearch,
                (void **) &pSearch
                );
    BAIL_ON_FAILURE(hr);

    hr = ParseAttrList(
                szAttrs,
                &pAttrs,
                &dwNumAttrs
                );
    BAIL_ON_FAILURE(hr);

    if(szOptions != NULL) {
        hr = GetSearchPreferences(&psearchPrefs, &dwNumPrefs, lScope, 
                                  szOptions);
        BAIL_ON_FAILURE(hr);
    }
    else {
        searchPrefs.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
        searchPrefs.vValue.dwType = ADSTYPE_INTEGER;
        searchPrefs.vValue.Integer = lScope;

        psearchPrefs = &searchPrefs;
        dwNumPrefs = 1;
    }

    hr = pSearch->SetSearchPreference(psearchPrefs, dwNumPrefs);
    BAIL_ON_FAILURE(hr);

    hr = pSearch->ExecuteSearch(
                szFilter,
                pAttrs,
                dwNumAttrs,
                &hSearch
                );

    BAIL_ON_FAILURE(hr);    

    hr = OutputDataHeader();
    BAIL_ON_FAILURE(hr);

    hr = pSearch->GetFirstRow(hSearch);
    BAIL_ON_FAILURE(hr);

    while(hr != S_ADS_NOMORE_ROWS) {
        hr = OutputEntryHeader(hSearch, pSearch);
        BAIL_ON_FAILURE(hr);

        hr = OutputEntryAttrs(hSearch, pSearch);
        BAIL_ON_FAILURE(hr);

        hr = OutputEntryFooter();
        BAIL_ON_FAILURE(hr);

        hr = pSearch->GetNextRow(hSearch);
        BAIL_ON_FAILURE(hr);
    }

    hr = OutputDataFooter();
    BAIL_ON_FAILURE(hr);

error:

    if(hSearch != NULL)
        pSearch->CloseSearchHandle(hSearch);

    if(pSearch != NULL)
        pSearch->Release();

    if(psearchPrefs && (psearchPrefs != &searchPrefs)) {
        FreeSearchPrefInfo(psearchPrefs, dwNumPrefs);
    }

    if(pAttrs != NULL) {
        int i = 0;
      
        while(i < (int) dwNumAttrs) {
            FreeADsStr(pAttrs[i]);
            i++;
        }
        FreeADsMem(pAttrs);
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
// Function:   ParseAttrList 
//
// Synopsis:   Parses a single string containing the comm-separated attributes
//             and returns the number of attributes and an array of strings
//             containing teh attributes.
//
// Arguments:
//
// szAttrs     Comma-separated attribute list
// ppAttrs     Returns array of strings with attribute names
// pdwNumAttrs Returns number of attributes in list
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------

HRESULT CADsXML::ParseAttrList(
    BSTR szAttrs,
    LPWSTR **ppAttrs,
    DWORD *pdwNumAttrs
    )
{
    HRESULT hr = S_OK;
    WCHAR *pwChar = NULL;
    DWORD dwNumAttrs = 0;
    DWORD i = 0;
    BOOL fAddDn = TRUE, fAddObjClass = TRUE;
    LPWSTR *pAttrs = NULL;

    ADsAssert(ppAttrs && pdwNumAttrs);

    if(NULL == szAttrs) {
        *ppAttrs = NULL;
        *pdwNumAttrs = -1;

        RRETURN(S_OK);
    }

    pwChar = szAttrs;
    while(pwChar = wcschr(pwChar, L',')) {
        *pwChar = L'\0';
         pwChar++;
         dwNumAttrs++;
    }
    dwNumAttrs++;

    pAttrs = (LPWSTR *) AllocADsMem(sizeof(LPWSTR) * (dwNumAttrs+2));
    if(NULL == pAttrs) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }
    memset(pAttrs, 0, sizeof(LPWSTR) * dwNumAttrs);

    pwChar = szAttrs;

    for(i = 0; i < dwNumAttrs; i++) {
        if(L'\0' == (*pwChar)) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }

        pAttrs[i] = AllocADsStr(pwChar);
        if(NULL == pAttrs[i]) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        if(!_wcsicmp(pwChar, DISTINGUISHED_NAME))
            fAddDn = FALSE;
        else if(!_wcsicmp(pwChar, OBJECT_CLASS))
            fAddObjClass = FALSE;

        pwChar += (wcslen(pwChar) + 1);
    }

    if(fAddDn) {
        pAttrs[dwNumAttrs] = AllocADsStr(DISTINGUISHED_NAME);
        if(NULL == pAttrs[dwNumAttrs]) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        dwNumAttrs++;
    }

    if(fAddObjClass) {
        pAttrs[dwNumAttrs] = AllocADsStr(OBJECT_CLASS);
        if(NULL == pAttrs[dwNumAttrs]) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        dwNumAttrs++;
    }

    *pdwNumAttrs = dwNumAttrs;
    *ppAttrs = pAttrs;

    RRETURN(S_OK);

error:

    if(pAttrs != NULL) {
        i = 0;

        while(pAttrs[i]) {
            FreeADsStr(pAttrs[i]);
            i++;
        }

        FreeADsMem(pAttrs);
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   OutputDataHeader
//
// Synopsis:   Outputs data header 
//
// Arguments:
//
// None.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
             
HRESULT CADsXML::OutputDataHeader(void)
{
    HRESULT hr = S_OK;

    hr = WriteLine(DSML_DATA_TAG);
    RRETURN(hr);
}         

//----------------------------------------------------------------------------
// Function:   OutputEntryHeader
//
// Synopsis:   Outputs the standar4d DSML header for each entry 
//
// Arguments:
//
// hSearch     Handle to search results
// pSearch     IDirectorySearch interface pointer
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
        
HRESULT CADsXML::OutputEntryHeader(
    ADS_SEARCH_HANDLE hSearch,
    IDirectorySearch *pSearch
    )
{
    HRESULT hr = S_OK;
    ADS_SEARCH_COLUMN column;
    DWORD i = 0;
    BOOL fFreeCols = FALSE;

    hr = Write(DSML_ENTRY_TAG);
    BAIL_ON_FAILURE(hr);

    hr = Write(L"dn=\"");
    BAIL_ON_FAILURE(hr);

    hr = pSearch->GetColumn(hSearch, DISTINGUISHED_NAME, &column);
    BAIL_ON_FAILURE(hr);

    hr = Write(column.pADsValues->CaseIgnoreString, TRUE);
    pSearch->FreeColumn(&column);
    BAIL_ON_FAILURE(hr);
    hr = WriteLine(L"\">");
    BAIL_ON_FAILURE(hr);

    hr = WriteLine(DSML_OBJECTCLASS_TAG);
    BAIL_ON_FAILURE(hr);
    hr = pSearch->GetColumn(hSearch, OBJECT_CLASS, &column);
    BAIL_ON_FAILURE(hr);

    fFreeCols = TRUE; 

    for(i = 0; i < column.dwNumValues; i++) {
        hr = Write(DSML_OCVALUE_TAG);
        BAIL_ON_FAILURE(hr);

        hr = Write(column.pADsValues[i].CaseIgnoreString, TRUE);
        BAIL_ON_FAILURE(hr);    

        hr = WriteLine(DSML_OCVALUE_TAG_CLOSE);
        BAIL_ON_FAILURE(hr);
    }

    hr = WriteLine(DSML_OBJECTCLASS_TAG_CLOSE);
    BAIL_ON_FAILURE(hr);

error:

    if(fFreeCols)
        pSearch->FreeColumn(&column);

    RRETURN(hr);
}       
 
//----------------------------------------------------------------------------
// Function:   OutputEntryAttrs
//
// Synopsis:   Outputs the attributes that were requested for each entry. 
//
// Arguments:
//
// hSearch     Handle to search results
// pSearch     IDirectorySearch interface pointer
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------    
HRESULT CADsXML::OutputEntryAttrs(
    ADS_SEARCH_HANDLE hSearch,
    IDirectorySearch *pSearch
    )
{
    HRESULT hr = S_OK;    
    LPWSTR pszColumnName = NULL;
    ADS_SEARCH_COLUMN column;
    BOOL fFreeCols = FALSE;

    hr = pSearch->GetNextColumnName(hSearch, &pszColumnName);
    BAIL_ON_FAILURE(hr);

    while(hr != S_ADS_NOMORE_COLUMNS) {
       if(_wcsicmp(pszColumnName, DISTINGUISHED_NAME) && 
          _wcsicmp(pszColumnName, OBJECT_CLASS)) {
           
           hr = pSearch->GetColumn(
                   hSearch,
                   pszColumnName,
                   &column
                   );
           BAIL_ON_FAILURE(hr);
  
           fFreeCols = TRUE;

           hr = Write(DSML_ENTRY_ATTR_TAG);
           BAIL_ON_FAILURE(hr);

           hr = Write(L" name=\"");
           BAIL_ON_FAILURE(hr);

           hr = Write(pszColumnName, TRUE);
           BAIL_ON_FAILURE(hr);

           if( (column.dwNumValues > 1) ||
             (ADSTYPE_OCTET_STRING == column.dwADsType) ||
             (ADSTYPE_NT_SECURITY_DESCRIPTOR == column.dwADsType) ||
             (ADSTYPE_PROV_SPECIFIC == column.dwADsType) ) {
               hr = WriteLine(L"\">");
           }
           else
               hr = Write(L"\">");
           BAIL_ON_FAILURE(hr);

           hr = OutputValue(&column);
           BAIL_ON_FAILURE(hr);

           pSearch->FreeColumn(&column);
           fFreeCols = FALSE;

           hr = WriteLine(DSML_ENTRY_ATTR_TAG_CLOSE);
           BAIL_ON_FAILURE(hr);
        } // if

        FreeADsMem(pszColumnName);
        pszColumnName = NULL;
        hr = pSearch->GetNextColumnName(hSearch, &pszColumnName);
        BAIL_ON_FAILURE(hr);
    }

error:

    if(fFreeCols)
        pSearch->FreeColumn(&column);

    if(pszColumnName != NULL)
        FreeADsMem(pszColumnName);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   OutputValue
//
// Synopsis:   Outputs the value of an attribute 
//
// Arguments:
//
// pColumn     Attribute returned by IDirectorySearch
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------

HRESULT CADsXML::OutputValue(ADS_SEARCH_COLUMN *pColumn)
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    WCHAR NumBuffer[256], pszTmp[256];;
    DWORD dwLength = 0;
    LPBYTE lpByte = NULL;
    LPWSTR pszBase64Str = NULL;
    int inBytes = 0, outBytes = 0, ret;

    ADsAssert(pColumn);

    for(i = 0; i < pColumn->dwNumValues; i++) {

        switch(pColumn->dwADsType) {
            case ADSTYPE_DN_STRING:
                hr = Write(DSML_VALUE_TAG);
                BAIL_ON_FAILURE(hr);
                hr = Write(pColumn->pADsValues[i].DNString, TRUE);
                break;
            case ADSTYPE_CASE_EXACT_STRING:
                hr = Write(DSML_VALUE_TAG);
                BAIL_ON_FAILURE(hr);
                hr = Write(pColumn->pADsValues[i].CaseExactString, TRUE);
                break;
            case ADSTYPE_CASE_IGNORE_STRING:
                hr = Write(DSML_VALUE_TAG);
                BAIL_ON_FAILURE(hr);
                hr = Write(pColumn->pADsValues[i].CaseIgnoreString, TRUE);
                break;
            case ADSTYPE_PRINTABLE_STRING:
                hr = Write(DSML_VALUE_TAG);
                BAIL_ON_FAILURE(hr);
                hr = Write(pColumn->pADsValues[i].PrintableString, TRUE);
                break;
            case ADSTYPE_NUMERIC_STRING:
                hr = Write(DSML_VALUE_TAG);
                BAIL_ON_FAILURE(hr);
                hr = Write(pColumn->pADsValues[i].NumericString, TRUE);
                break;
            case ADSTYPE_BOOLEAN:
                hr = Write(DSML_VALUE_TAG);
                BAIL_ON_FAILURE(hr);
                if(pColumn->pADsValues[i].Boolean)
                    hr = Write(L"true");
                else
                    hr = Write(L"false");
                break;
            case ADSTYPE_INTEGER:
                hr = Write(DSML_VALUE_TAG);
                BAIL_ON_FAILURE(hr);
                _itow(pColumn->pADsValues[i].Integer, NumBuffer, 10);
                hr = Write(NumBuffer);
                break;
            case ADSTYPE_OCTET_STRING:
            case ADSTYPE_PROV_SPECIFIC:
            case ADSTYPE_NT_SECURITY_DESCRIPTOR:
                hr = WriteLine(DSML_VALUE_ENCODING_TAG);
                BAIL_ON_FAILURE(hr);

                if(ADSTYPE_OCTET_STRING == pColumn->dwADsType) {
                    dwLength = pColumn->pADsValues[i].OctetString.dwLength;
                    lpByte = pColumn->pADsValues[i].OctetString.lpValue;
                }
                else if(ADSTYPE_PROV_SPECIFIC == pColumn->dwADsType) {
                    dwLength =
                             pColumn->pADsValues[i].ProviderSpecific.dwLength; 
                    lpByte = pColumn->pADsValues[i].ProviderSpecific.lpValue;
                }
                else if(ADSTYPE_NT_SECURITY_DESCRIPTOR == pColumn->dwADsType) {
                    dwLength =
                             pColumn->pADsValues[i].SecurityDescriptor.dwLength;
                    lpByte = pColumn->pADsValues[i].SecurityDescriptor.lpValue;
                }

                // 
                // base64 encoding requires about 4/3 the size of the octet
                // string. Approximate to twice the size. Since we are
                // converting to WCHAR, need 4 times as much space.
                //
                pszBase64Str = (LPWSTR) AllocADsMem(2*(2*dwLength + 1));
                if(NULL == pszBase64Str) {
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                }
                inBytes = dwLength;
                outBytes = 2*dwLength + 1;
                ret = encodeBase64Buffer(
                        (char *) lpByte,
                        &inBytes,
                        pszBase64Str,
                        &outBytes,
                        LINE_LENGTH
                        ); 
                if( (-1 == ret) || (inBytes != (int) dwLength) ) {
                    FreeADsMem(pszBase64Str);
                    BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
                }

                // base64 string need not be escaped
                hr = WriteLine(pszBase64Str);
                BAIL_ON_FAILURE(hr);
   
                FreeADsMem(pszBase64Str);

                break;
            case ADSTYPE_UTC_TIME:
                WCHAR pszTime[256];
                SYSTEMTIME *pst;

                hr = Write(DSML_VALUE_TAG);
                BAIL_ON_FAILURE(hr);

                pst = &(pColumn->pADsValues[i].UTCTime);
                wsprintf(pszTime, L"%02d%02d%02d%02d%02d%02dZ",
                         pst->wYear % 100, pst->wMonth, pst->wDay,
                         pst->wHour, pst->wMinute, pst->wSecond);
                hr = Write(pszTime);
                BAIL_ON_FAILURE(hr);

                break;
            case ADSTYPE_LARGE_INTEGER:
                LARGE_INTEGER *pLargeInt;

                hr = Write(DSML_VALUE_TAG);
                BAIL_ON_FAILURE(hr);

                pLargeInt =  &(pColumn->pADsValues[i].LargeInteger);
                swprintf(NumBuffer, L"%I64d", *pLargeInt);

                hr = Write(NumBuffer);
                BAIL_ON_FAILURE(hr);

                break;

            case ADSTYPE_DN_WITH_BINARY:
                ADS_DN_WITH_BINARY *pDnBin;
                LPWSTR pszBinaryVal;

                hr = Write(DSML_VALUE_TAG);
                BAIL_ON_FAILURE(hr);

                pDnBin = pColumn->pADsValues[i].pDNWithBinary;
                swprintf(pszTmp, L"B:%d:", pDnBin->dwLength*2);

                hr = Write(pszTmp);
                BAIL_ON_FAILURE(hr);

                pszBinaryVal = (LPWSTR)AllocADsMem(2*(pDnBin->dwLength*2 + 2));
                if(NULL == pszBinaryVal) {
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                }

                for(i = 0; i < pDnBin->dwLength; i++)
                    swprintf(pszBinaryVal+(i*2), L"%02x", 
                                                 pDnBin->lpBinaryValue[i]);

                wcscat(pszBinaryVal, L":");

                hr = Write(pszBinaryVal);
                FreeADsMem(pszBinaryVal);
                BAIL_ON_FAILURE(hr);

                hr = Write(pDnBin->pszDNString, TRUE);
                BAIL_ON_FAILURE(hr);

                break;

            case ADSTYPE_DN_WITH_STRING:
                ADS_DN_WITH_STRING *pDnStr;

                hr = Write(DSML_VALUE_TAG);
                BAIL_ON_FAILURE(hr);

                pDnStr = pColumn->pADsValues[i].pDNWithString;
                swprintf(pszTmp, L"S:%d:", wcslen(pDnStr->pszStringValue));

                hr = Write(pszTmp);
                BAIL_ON_FAILURE(hr);

                hr = Write(pDnStr->pszStringValue, TRUE);
                BAIL_ON_FAILURE(hr);

                hr = Write(L":");
                BAIL_ON_FAILURE(hr);

                hr = Write(pDnStr->pszDNString, TRUE);
                BAIL_ON_FAILURE(hr);

                break;
                
            default:
                BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE); 
                break;
         }

         BAIL_ON_FAILURE(hr);

         if( (pColumn->dwNumValues > 1) ||
             (ADSTYPE_OCTET_STRING == pColumn->dwADsType) || 
             (ADSTYPE_NT_SECURITY_DESCRIPTOR == pColumn->dwADsType) ||
             (ADSTYPE_PROV_SPECIFIC == pColumn->dwADsType) ) {
             hr = WriteLine(DSML_VALUE_TAG_CLOSE);
         }
         else
             hr = Write(DSML_VALUE_TAG_CLOSE);

         BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   OutputEntryFooter
//
// Synopsis:   Outputs the DSML footer for an entry 
//
// Arguments:
//
// None
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
HRESULT CADsXML::OutputEntryFooter(void)
{
    HRESULT hr = S_OK;

    hr = WriteLine(DSML_ENTRY_TAG_CLOSE);
    RRETURN(hr);
}
      
//----------------------------------------------------------------------------
// Function:   OutputDataFooter
//
// Synopsis:   Outputs the DSML footer for all data 
//
// Arguments:
//
// None
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------      
HRESULT CADsXML::OutputDataFooter(void)
{
    HRESULT hr = S_OK;

    hr = WriteLine(DSML_DATA_TAG_CLOSE);
    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   RemoveWhiteSpace 
//
// Synopsis:   Remove all leading and trailing white space in every attribute 
//             of comma-separated attribute list
//
// Arguments:
//
// pszStr      Comma-separated attribute list
//
// Returns:    String with white spaces removed as mentioned above. NULL on
//             error. 
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------

LPWSTR CADsXML::RemoveWhiteSpace(BSTR pszStr)
{
    LPWSTR pszNewStr = NULL;
    int i,j, k;
    WCHAR prevChar = L',';

    ADsAssert(pszStr != NULL);

    pszNewStr = AllocADsStr(pszStr);
    if(NULL == pszNewStr)
        return NULL;

    for(i = 0, j = 0; i < (int) wcslen(pszStr); i++) {
        if(iswspace(pszStr[i]) && (L',' == prevChar) )
            continue;

        prevChar = pszNewStr[j] = pszStr[i];
        if(L',' == prevChar) {
            k = j - 1;
            while( (k >= 0) && (iswspace(pszNewStr[k])) )
                k--;
            j = k+1;
            pszNewStr[j] = pszStr[i];
        }
        j++;
    }

    k = j - 1;
    while( (k >= 0) && (iswspace(pszNewStr[k])) )
        k--;
    j = k+1;

    pszNewStr[j] = L'\0';

    return pszNewStr; 
}

//----------------------------------------------------------------------------
// Function:   ReduceWhiteSpace 
//
// Synopsis:   Removes white spaces from te string containing search prefs as
//             follows. No white spaces are allowed before or immediately after
//             an = sign. Each search preference is reduced to having at most
//             one space in it i.e, "\t\tsort    on  =  cn; timeout= 10"  will
//             be reduced to "sort on=cn;timeout=10"
//
// Arguments:
//
// pszStr      String containing search prefs
//
// Returns:    Reduced string. NULL on error.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------

LPWSTR CADsXML::ReduceWhiteSpace(BSTR pszStr)
{
    int i = 0, j = 0;
    LPWSTR pszNewStr = NULL;

    ADsAssert(pszStr != NULL);

    pszNewStr = (LPWSTR) AllocADsMem(wcslen(pszStr)*2+2);
    if(NULL == pszNewStr)
        return NULL;

    while(iswspace(pszStr[i]))
        i++;

    if(L'\0' == pszStr[i])
        return pszNewStr;

    while(1) {
        pszNewStr[j] = pszStr[i];

        if(L'\0' == pszStr[i]) {
            if( (j != 0) && (pszNewStr[j-1] == L' ') )
                pszNewStr[j-1] = pszStr[i];
            return pszNewStr;
        }

        if(iswspace(pszStr[i])) {
            if( (pszNewStr[j-1] == L';') ||
                (pszNewStr[j-1] == L'=') ||
                (pszNewStr[j-1] == L' ') ) {
                    i++;
                    continue;
            }
            else
                pszNewStr[j] = L' ';
        }
        else if( (pszStr[i] == L'=') || (pszStr[i] == L';') ) {
            if( (j != 0) && (pszNewStr[j-1] == L' ') ) {
                pszNewStr[j-1] = pszStr[i];
                i++;
                continue;
            }
        }

        i++;
        j++;
    }
}   

//----------------------------------------------------------------------------
// Function:   GetSearchPreferences
//
// Synopsis:   Returns array of search preferences base n string containing
//             options.
//
// Arguments:
//
// ppSearchPrefInfo   Returns search preferences
// pdwNumPrefs        Returns number of preferences
// lScope             Search scope
// szOptions          String containing options 
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
HRESULT CADsXML::GetSearchPreferences(
    ADS_SEARCHPREF_INFO** ppSearchPrefInfo,
    DWORD *pdwNumPrefs,
    LONG lScope,
    LPWSTR szOptions
    )
{
    ADS_SEARCHPREF_INFO *pSearchPrefs = NULL;
    DWORD dwNumPrefs = 0, dwLength = 0;
    LPWSTR pszTmp = szOptions, pszTmp1 = NULL;
    HRESULT hr = S_OK;
    int i,j, cAttrs = 0;
    LPWSTR pszCurrentAttr = NULL, pszFirstAttr = NULL, pszNextAttr = NULL;
    LPWSTR pszOrder = NULL;
    PADS_SORTKEY pSortKey = NULL;

    ADsAssert(ppSearchPrefInfo && pdwNumPrefs);

    *ppSearchPrefInfo = NULL;
    *pdwNumPrefs = 0;

    while(pszTmp = wcschr(pszTmp, L'=')) {
        dwNumPrefs++;
        *pszTmp = L'\0';
        pszTmp++;

        if(*pszTmp == L'\0') {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }

        pszTmp1 = wcschr(pszTmp, L';');
        if(pszTmp1 != NULL) {
            *pszTmp1 = L'\0';
             pszTmp = pszTmp1 + 1;
        }
        else
             break;
    }

    if(0 == dwNumPrefs) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    dwNumPrefs++; //include search scope

    pSearchPrefs = (ADS_SEARCHPREF_INFO *) AllocADsMem(dwNumPrefs * 
                                           sizeof(ADS_SEARCHPREF_INFO));
    if(NULL == pSearchPrefs) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pszTmp = szOptions;

    for(i = 0; i < (int) (dwNumPrefs - 1); i++) {
       for(j = 0; j <  (int) g_dwNumSearchPrefInfo; j++) {
           if(0 == _wcsicmp(pszTmp, g_SearchPrefInfo[j].pszName))
               break;
       }

       if(j == (int) g_dwNumSearchPrefInfo) {
           BAIL_ON_FAILURE(hr = E_INVALIDARG);
       }

       pSearchPrefs[i].dwSearchPref = g_SearchPrefInfo[j].Pref;

       pszTmp = pszTmp + wcslen(pszTmp) + 1;
       dwLength = wcslen(pszTmp);
       if(0 == dwLength) {
           BAIL_ON_FAILURE(hr = E_INVALIDARG);
       }

       switch(g_SearchPrefInfo[j].vtType) {
           case VT_BOOL:
               if(0 == _wcsicmp(pszTmp, L"true"))
                   pSearchPrefs[i].vValue.Boolean = VARIANT_TRUE;
               else if (0 == _wcsicmp(pszTmp, L"false"))
                   pSearchPrefs[i].vValue.Boolean = VARIANT_FALSE;
               else {
                   BAIL_ON_FAILURE(hr = E_INVALIDARG);
               }
               pSearchPrefs[i].vValue.dwType = ADSTYPE_BOOLEAN;

               break;

           case VT_I4:
               for(j = 0; j < (int) wcslen(pszTmp); j++) {
                   if(0 == iswdigit(pszTmp[j])) {
                       BAIL_ON_FAILURE(hr = E_INVALIDARG);
                   }
               }

               pSearchPrefs[i].vValue.dwType = ADSTYPE_INTEGER;
               pSearchPrefs[i].vValue.Integer = _wtoi(pszTmp);

               break;

           case VT_BSTR:
               if(L'\0' == *pszTmp) {
                   BAIL_ON_FAILURE(hr = E_INVALIDARG);
               }

               // guard against a string ending in ',' since it won't be caught
               // below
               if(L',' == pszTmp[wcslen(pszTmp) -1]) {
                   BAIL_ON_FAILURE ( hr = E_INVALIDARG );
               }

               pszCurrentAttr = pszFirstAttr = wcstok(pszTmp, L",");

               for(cAttrs=0; pszCurrentAttr != NULL; cAttrs++ ) {
                   pszCurrentAttr = wcstok(NULL, L",");
               }

               if(cAttrs == 0) { // shouldn't happen
                   BAIL_ON_FAILURE ( hr = E_INVALIDARG );
               } 

               pSortKey = (PADS_SORTKEY) AllocADsMem(sizeof(ADS_SORTKEY) * 
                                                     cAttrs);
               if(NULL == pSortKey) {
                   BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
               }

               pszCurrentAttr = pszFirstAttr;

               for(j = 0; j < cAttrs; j++) {
                   pszNextAttr = pszCurrentAttr + wcslen(pszCurrentAttr) + 1;

                   if(L' ' == *pszCurrentAttr) {
                   // cannot happen for first attr in list since there will
                   // never be a space following =. However, subsequent attrs
                   // may have exactly one leading space.
                       pszCurrentAttr++;
                       if(L'\0' == *pszCurrentAttr) {
                           BAIL_ON_FAILURE(hr = E_INVALIDARG);
                       }
                   }

                   pszOrder = wcstok(pszCurrentAttr, L" ");
                   pszOrder = pszOrder ? wcstok(NULL, L" ") : NULL;

                   if (pszOrder && !_wcsicmp(pszOrder, L"DESC"))
                       pSortKey[j].fReverseorder = 1;
                   else
                       pSortKey[j].fReverseorder = 0;  // This is the default

                   pSortKey[j].pszAttrType = AllocADsStr(pszCurrentAttr);
                   if(NULL == pSortKey[j].pszAttrType) {
                       BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                   }

                   pSortKey[j].pszReserved = NULL;

                   pszCurrentAttr = pszNextAttr;
               }            

               pSearchPrefs[i].vValue.ProviderSpecific.dwLength =
                   sizeof(ADS_SORTKEY) * cAttrs;
               pSearchPrefs[i].vValue.ProviderSpecific.lpValue = 
                   (LPBYTE) pSortKey;
 
               pSearchPrefs[i].vValue.dwType = ADSTYPE_PROV_SPECIFIC;

               pSortKey = NULL;

               break;

           default:
               BAIL_ON_FAILURE(hr = E_FAIL);
               break;
        } //switch

        pszTmp = pszTmp + dwLength + 1;

    } // for

    // set the search scope
    pSearchPrefs[i].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    pSearchPrefs[i].vValue.dwType = ADSTYPE_INTEGER;
    pSearchPrefs[i].vValue.Integer = lScope;    

    *ppSearchPrefInfo = pSearchPrefs;
    *pdwNumPrefs = dwNumPrefs;

error:

    if(FAILED(hr)) {
        if(pSortKey != NULL) {
            for(j = 0; j < cAttrs; j++) {
                if(pSortKey[j].pszAttrType)
                    FreeADsStr(pSortKey[j].pszAttrType);
            }

            FreeADsMem(pSortKey);
        }

        if(pSearchPrefs != NULL)
            FreeSearchPrefInfo(pSearchPrefs, dwNumPrefs);
    } 

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   FreeSearchPrefInfo 
//
// Synopsis:   Frees array of search prefs 
//
// Arguments:
//
// pSearchPrefInfo Array of search prefs
// dwNumPrefs      Number of preferences
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
       
void CADsXML::FreeSearchPrefInfo(
    ADS_SEARCHPREF_INFO *pSearchPrefInfo,
    DWORD dwNumPrefs
    )
{
    int i, j;
    DWORD nSortKeys = 0;
    PADS_SORTKEY pSortKey = NULL;

    if( (NULL == pSearchPrefInfo) || (0 == dwNumPrefs) )
        return;

    for(i = 0; i < (int)dwNumPrefs; i++) {
        if(ADSTYPE_PROV_SPECIFIC == pSearchPrefInfo[i].vValue.dwType) {
            if (pSearchPrefInfo[i].dwSearchPref == ADS_SEARCHPREF_SORT_ON) {
                nSortKeys = pSearchPrefInfo[i].vValue.ProviderSpecific.dwLength
                            / sizeof(ADS_SORTKEY);
                pSortKey = (PADS_SORTKEY) pSearchPrefInfo[i].vValue.ProviderSpecific.lpValue;
                for(j = 0; pSortKey && j < (int) nSortKeys; j++) {
                    FreeADsStr(pSortKey[j].pszAttrType);
                }

                if (pSortKey) {
                    FreeADsMem(pSortKey);
                }
            }
        } // if
    } // for 
   
    FreeADsMem(pSearchPrefInfo);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\xml\adsxmlcf.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     adsxmlcf.cxx
//
//  Contents: Contains the class factory for creating ADsXML extension.
//
//----------------------------------------------------------------------------

#include "adsxmlcf.hxx"
#include "adsxml2.h"

#define DISPID_REGULAR 1

const GUID LIBID_ADsXML = {0x61340306,0xe79c,0x401d,{0xa3,0x4a,0xcb,0xbc,0x99,0x19,0x90,0x25}};
const IID IID_IADsXML = {0x91e5c5dc,0x926b,0x46ff,{0x9f,0xdb,0x9f,0xb1,0x12,0xbf,0x10,0xe6}};

//----------------------------------------------------------------------------
// Function:   CreateInstance
//
// Synopsis:   Creates the ADsXML extension object.
//
// Arguments:
//
// pUnkOuter   Pointer to aggregating IUnknown. This has to be non-NULL since
//             the extension can't exist by itself. 
// iid         Interface requested. 
// ppInterface Returns pointer to interface requested
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return a pointer to the interface requested
//
//----------------------------------------------------------------------------
STDMETHODIMP CADsXMLCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID iid,
    LPVOID *ppInterface
    )
{
    HRESULT        hr = S_OK;
    CADsXML        *pCADsXML = NULL;
    IADs FAR *     pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;

    if( (NULL == pUnkOuter) || (NULL == ppInterface) )
        RRETURN(E_INVALIDARG);

    // can only ask for IUnknown
    ADsAssert(IsEqualIID(iid, IID_IUnknown));

    *ppInterface = NULL;

    pCADsXML = new CADsXML();

    if(NULL == pCADsXML) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pCADsXML->_pUnkOuter = pUnkOuter;

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pCADsXML->_pDispMgr = pDispMgr;

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADsXML,
                IID_IADsXML,
                (IADsXML *)pCADsXML,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr); 

    hr = pUnkOuter->QueryInterface(
                IID_IADs,
                (void **)&pADs
                );

    BAIL_ON_FAILURE(hr);

    pADs->Release();
    pCADsXML->_pADs = pADs;
   
    *ppInterface = (INonDelegatingUnknown FAR *) pCADsXML;

    RRETURN(hr);

error:

    if(pCADsXML)
        delete pCADsXML;

    *ppInterface = NULL;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\xml\cdispmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdispmgr.cxx
//
//  Contents:   The dispatch manager -- a class to manage
//      multiple IDispatch-callable interfaces.
//
//  Classes:    CAggregateeDispMgr
//
//  Functions:  None external.
//
//  History:    ??-???-??   KrishnaG   created
//      07-Sep-97   t-blakej   Commented, cleaned up, made
//                                     independent of ADSI.
//
//  See cdispmgr.hxx for a more thorough description of the dispatch manager.
//
//----------------------------------------------------------------------------

//
// Since this class is useful outside of ADSI, some work has been taken to
// make it not depend on any ADSI-specific code.  It needs two ADSI header
// files (cdispmgr.hxx and iprops.hxx), but they only depend on definitions
// from standard system header files.
//
// To accomodate the current building method in ADSI, the precompiled
// header "procs.hxx" is included; this includes all the necessary ADSI
// header files and definitions.  But for use outside of ADSI, the few
// necessary header files are explicitly included below; see the comment by
// "#ifndef ADsAssert".
//
// So if not compiling for ADSI, comment the following two lines out.
//

#include "cadsxml.hxx"
extern "C" {
#include <stdio.h>
#include <stddef.h>
}

//////////////////////////////////////////////////////////////////////////////
//
// General helper definitions, routines, and inclusions:

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    Begin Non-ADSI compile stuff
//
// This macro is defined by the precompiled header file, so the following
// will only be included if not compiling for ADSI.
//
#ifndef ADsAssert

//
// Necessary system headers.
//
#define UNICODE
#define _UNICODE
#define _OLEAUT32_
#define INC_OLE2
#include <windows.h>
#include <stdio.h>

//
// Necessary class definitions used by the dispatch manager.
// Edit these paths if necessary.
//
#include "cdispmgr.hxx"
#include "iprops.hxx"

#endif  // ADsAssert
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    End Non-ADSI compile stuff

//
// A simple assert function.
//
#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   AssertEx
//
//  Synopsis:   Display assertion information.
//
//  Effects:    Called when an assertion is hit.
//
//  History:    Simplified from Win4AssertEx, to make this dispatch manager
//          not depend on other files.
//
//----------------------------------------------------------------------------
static void
AssertEx(char const *szFile, int iLine, char const *szMessage)
{
    static char szAssertCaption[199];
    DWORD dwCount = strlen("File: %s line %u, thread id %d");

    if (szFile) {
        dwCount += strlen(szFile);
    }

    dwCount += 15; // for the line number and thread id

    if (dwCount > 199) {
        sprintf(szAssertCaption, "Error, could not get more infomration");
    } 
    else {
        sprintf(szAssertCaption, "File: %s line %u, thread id %d",
                szFile, iLine, GetCurrentThreadId());
    }

    if (IDCANCEL == MessageBoxA(
                NULL,
                (char *) szMessage,
                (LPSTR) szAssertCaption,
                MB_SETFOREGROUND |
                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL
                ))
    {
    DebugBreak();
    }
}
# define DispMgrAssert(x)  (void)((x) || (AssertEx(__FILE__, __LINE__, #x),0))
#else
# define AssertEx(f,l,m)
# define DispMgrAssert(x)
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Inline routines:

static inline LONG
getDispMgrId(DISPID InputDispId)
{
    return (InputDispId & 0x7f000000) >> 24;
}

static inline LONG
getTypeInfoId(DISPID InputDispId)
{
    return (InputDispId & 0x00ff0000) >> 16;
}

static inline LONG
getDispId(DISPID InputDispId)
{
    return (InputDispId & 0x0000ffff);
}

static inline void
MakeDISPID(
    LONG ExtensionId,
    LONG TypeInfoId,
    LONG DispId,
    DISPID *pResult
    )
{
    if (DispId == DISPID_UNKNOWN){

        *pResult = DispId;

    }else if (TypeInfoId < 0 || TypeInfoId >= 0x100 ||
                    DispId < 0 || DispId >= 0x10000){

        //
        // Might happen if some object has very large dispid's.
        // But we can't handle it if it does.
        //
        *pResult = DISPID_UNKNOWN;
    }
    else{

        *pResult = ((ExtensionId & 0xff) << 24) |((TypeInfoId & 0xff) << 16) | (DispId & 0xffff);

    }

}


static inline void
MakeDISPIDs(
    LONG ExtensionId,
    LONG TypeInfoId,
    DISPID *rgdispid,
    unsigned int cNames
    )
{
    for (unsigned int i = 0; i < cNames; i++)
    {
        MakeDISPID(ExtensionId, TypeInfoId, rgdispid[i], &rgdispid[i]);
    }
}

//
// Struct Def
//
typedef struct _typeinfotable
{
    GUID iid;
    ITypeInfo * pTypeInfo;
    struct _typeinfotable *pNext;
}TYPEINFO_TABLE, *PTYPEINFO_TABLE;

CRITICAL_SECTION g_ExtTypeInfoCritSect;

#define ENTER_EXT_TYPEINFO_CRITSECT()  EnterCriticalSection(&g_ExtTypeInfoCritSect)
#define LEAVE_EXT_TYPEINFO_CRITSECT()  LeaveCriticalSection(&g_ExtTypeInfoCritSect)

LONG glnMSEXTObjCount = 0;
LONG glnMSEXTTypesOfInfo = 0;

PTYPEINFO_TABLE gpAggregateeTypeInfoTable = NULL;

//////////////////////////////////////////////////////////////////////////////
//
// Public methods:

CAggregateeDispMgr::CAggregateeDispMgr()
{
    _pTypeInfoEntry = NULL;
    _pDispidNewEnum = NULL;
    _dwTypeInfoId = 0;
    _pDispidValue = NULL;
    _pPropertyCache = NULL;
    _dwPropCacheID = 0;
    _dwExtensionID = 0;
}

CAggregateeDispMgr::~CAggregateeDispMgr()
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    PTYPEINFOENTRY pTemp = NULL;
    ITypeInfo *pTypeInfo = NULL;

    pTypeInfoEntry = _pTypeInfoEntry;

    while (pTypeInfoEntry) {

        pTemp = pTypeInfoEntry;

        pTypeInfo = (ITypeInfo *)pTypeInfoEntry->ptypeinfo;
        pTypeInfo->Release();

        InterlockedDecrement(&glnMSEXTObjCount);

        pTypeInfoEntry = pTemp->pNext;

        LocalFree(pTemp);
    }

    ENTER_EXT_TYPEINFO_CRITSECT();

    if (glnMSEXTObjCount == glnMSEXTTypesOfInfo) {
        //
        // We need to clean up the list
        //
        AggregateeFreeTypeInfoTable();

        gpAggregateeTypeInfoTable = NULL;

        glnMSEXTObjCount = glnMSEXTTypesOfInfo = 0;

    }
    LEAVE_EXT_TYPEINFO_CRITSECT();
}

void
CAggregateeDispMgr::RegisterPropertyCache(IPropertyCache *pPropertyCache)
{
    _pPropertyCache = pPropertyCache;
    _dwPropCacheID = gentypeinfoid();
}


STDMETHODIMP
CAggregateeDispMgr::GetTypeInfoCount(unsigned int *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CAggregateeDispMgr::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CAggregateeDispMgr::GetIDsOfNames(REFIID iid, LPWSTR *rgszNames,
        unsigned int cNames, LCID lcid, DISPID *rgdispid)
{
    PTYPEINFOENTRY pTypeInfo = NULL;
    HRESULT hr = DISP_E_UNKNOWNNAME;

    //
    // Try our list of TypeInfos.
    //
    pTypeInfo = _pTypeInfoEntry;
    while (pTypeInfo) {
        hr = DispGetIDsOfNames(((ITypeInfo *)pTypeInfo->ptypeinfo),
                                rgszNames,
                                cNames,
                                rgdispid
                                );
        if (SUCCEEDED(hr)) {

            //
            // aggregatee no longer needs to include extension id
            // in dispid.
            //

            MakeDISPIDs(0, pTypeInfo->TypeInfoId, rgdispid, cNames);
            return hr;
        }
        pTypeInfo = pTypeInfo->pNext;
    }

    //
    // Try our property cache.
    //
    if (FAILED(hr) && _pPropertyCache) {
    hr = S_OK;
    for (DWORD dw = 0; dw < cNames; dw++) {
        if (FAILED(_pPropertyCache->locateproperty(rgszNames[dw],
            (PDWORD)(rgdispid + dw)))) {
        hr = DISP_E_UNKNOWNNAME;
        rgdispid[dw] = DISPID_UNKNOWN;
        }
    }
    if (SUCCEEDED(hr)) {

            //
            // aggregatee no longer needs to include extension id
            // in dispid.
            //

        MakeDISPIDs(0, _dwPropCacheID, rgdispid, cNames);
    }
    }

    return hr;
}

STDMETHODIMP
CAggregateeDispMgr::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,
    unsigned short wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo, unsigned int *puArgErr)
{
        //
        // Clear the error object before we call invoke.
        //
        SetErrorInfo(0, NULL);

        return TypeInfoInvoke(dispidMember,
                               iid,
                               lcid,
                               wFlags,
                               pdispparams,
                               pvarResult,
                               pexcepinfo,
                               puArgErr
                               );
}

//////////////////////////////////////////////////////////////////////////////
//
// Private methods and helper functions:

void *
CAggregateeDispMgr::getInterfacePtr(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (pTypeInfoEntry ? pTypeInfoEntry->pInterfacePointer : NULL);
}

ITypeInfo *
CAggregateeDispMgr::getTypeInfo(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (ITypeInfo *)(pTypeInfoEntry ? pTypeInfoEntry->ptypeinfo : NULL);
}

PTYPEINFOENTRY
CAggregateeDispMgr::FindTypeInfoEntry(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->TypeInfoId == TypeInfoId) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

PTYPEINFOENTRY
CAggregateeDispMgr::FindTypeInfo(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->ptypeinfo == pTypeInfo) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

HRESULT
CAggregateeDispMgr::AddTypeInfo(void *ptypeinfo, void *pIntfptr)
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    HRESULT hr;

    if (FindTypeInfo(ptypeinfo)) {
        return E_FAIL;
    }
    pTypeInfoEntry = (PTYPEINFOENTRY)LocalAlloc(LPTR,sizeof(TYPEINFOENTRY));
    if (!pTypeInfoEntry) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTypeInfoEntry->ptypeinfo = ptypeinfo;
    pTypeInfoEntry->TypeInfoId = gentypeinfoid();
    pTypeInfoEntry->pInterfacePointer = pIntfptr;

    pTypeInfoEntry->pNext = _pTypeInfoEntry;
    _pTypeInfoEntry = pTypeInfoEntry;

    return S_OK;

error:
    return hr;
}

STDMETHODIMP
CAggregateeDispMgr::TypeInfoInvoke(DISPID dispidMember, REFIID iid, LCID lcid,
    unsigned short wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo, unsigned int *puArgErr)
{
    void *pInterfacePtr = NULL;
    DISPID dispid = 0;
    DISPID typeinfoid = 0;
    ITypeInfo *pTypeInfo = NULL;
    HRESULT hr = S_OK;

    if (dispidMember <= 0) {

        //
        // One of the special DISPIDs.
        //
        // If we have an interface pointer for it, use that.
        // If we don't, and we have a base IDispatch pointer,
        //   pass it to the base pointer's Invoke() method.
        // If we don't, and we don't have a base IDispatch pointer,
        //   return failure.
        //

        dispid = dispidMember;
        switch (dispid) {

        case DISPID_VALUE:
            if (_pDispidValue) {
                pTypeInfo = (ITypeInfo *)_pDispidValue->ptypeinfo;
                pInterfacePtr = _pDispidValue->pInterfacePointer;
            }
        break;

        case DISPID_NEWENUM:
            if (_pDispidNewEnum) {
                pTypeInfo = (ITypeInfo *)_pDispidNewEnum->ptypeinfo;
                pInterfacePtr = _pDispidNewEnum->pInterfacePointer;
            }
            break;

        default:
            break;
        }

        if (!pInterfacePtr) {

            BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);

        }else {

            //
            // Fill in the special case scenarios here
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );

            return(hr);

        }

    } else {

        //                              
        // A regular DISPID of ours.
        //

        typeinfoid = getTypeInfoId(dispidMember);
        dispid = getDispId(dispidMember);

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {
            pInterfacePtr = getInterfacePtr(typeinfoid);
            pTypeInfo = getTypeInfo(typeinfoid);
            if (!pTypeInfo)
                //
            // Shouldn't happen.
            //
            BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);
        }

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {

            //
            // A regular interface.
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        }else {

            //
            // A "dynamic DISPID", for the property cache.
            //

            hr = AggregateeDynamicDispidInvoke(
                        _pPropertyCache,
                        dispid,
                        wFlags,
                        pdispparams,
                        pvarResult
                        );

        }

    }

error:
    return hr;
}


HRESULT
AggregateeDynamicDispidInvoke(
    IPropertyCache * pPropertyCache,
    DISPID  dispid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT * pvarResult
    )
{
    HRESULT hr = S_OK;

    if (!pPropertyCache) {

        return(E_INVALIDARG);
    }

    if (wFlags & DISPATCH_PROPERTYGET) {

        if (!pvarResult) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }

        hr = pPropertyCache->getproperty((DWORD)dispid,pvarResult);

        if (FAILED(hr)) {

#if 1
            // This lets us return S_OK and a VT_EMPTY variant if
            // there's no data.  #if this out to disable it.
            V_VT(pvarResult) = VT_EMPTY;
            hr = S_OK;
#else

            V_VT(pvarResult) = VT_ERROR;
#endif

        }
    }else if (wFlags & DISPATCH_PROPERTYPUT) {

        if (pdispparams[0].cArgs != 1){
            hr = DISP_E_BADPARAMCOUNT;
        }
        else {

            hr = pPropertyCache->putproperty(
                        (DWORD)dispid,
                        pdispparams[0].rgvarg[0]
                        );
        }

    }else {
        hr = E_INVALIDARG;
    }

error:
    return(hr);

}


HRESULT
CAggregateeDispMgr::MarkAsNewEnum(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidNewEnum = pTypeInfoEntry;
    return S_OK;
}

HRESULT
CAggregateeDispMgr::MarkAsItem(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidValue = pTypeInfoEntry;
    return S_OK;
}

LONG
CAggregateeDispMgr::gentypeinfoid()
{
    //
    // This would mean we've registered 65536 IDispatch methods
    //   in this object's dispatch manager.  We lose.
    //
    DispMgrAssert(_dwTypeInfoId < 0xffff);

    return (_dwTypeInfoId++);
}


ITypeInfo *
AggregateeFindTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = pTypeInfoTable;

    while (pTemp) {
        if (IsEqualIID(iid, pTemp->iid)) {
            return pTemp->pTypeInfo;
        }
        pTemp = pTemp->pNext;
    }
    return NULL;
}


PTYPEINFO_TABLE
AggregateeAddTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid,
    ITypeInfo * pTypeInfo
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = (PTYPEINFO_TABLE)LocalAlloc(LPTR, sizeof(TYPEINFO_TABLE));
    if (!pTemp) {
        return NULL;
    }

    memcpy(&pTemp->iid, &iid, sizeof(GUID));
    pTemp->pTypeInfo = pTypeInfo;
    pTemp->pNext = pTypeInfoTable;

    return pTemp;
}

//+------------------------------------------------------------------------
//
//  Function:   LoadTypeInfo
//
//  Synopsis:   Loads a typeinfo from a registered typelib.
//
//  Arguments:  [clsidTL] --  TypeLib GUID
//              [clsidTI] --  TypeInfo GUID
//              [ppTI]    --  Resulting typeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
AggregateeLoadTypeInfo(CLSID clsidTL, CLSID clsidTI, LPTYPEINFO *ppTI)
{
    HRESULT     hr;
    ITypeLib *  pTL;

    DispMgrAssert(ppTI);
    *ppTI = NULL;
    hr = LoadRegTypeLib(clsidTL, 1, 0, LOCALE_SYSTEM_DEFAULT, &pTL);
    if (!SUCCEEDED(hr))
        return hr;

    hr = pTL->GetTypeInfoOfGuid(clsidTI, ppTI);
    pTL->Release();
    return hr;
}

HRESULT
CAggregateeDispMgr::LoadTypeInfoEntry(
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    ITypeInfo * pTypeInfo = NULL;
    HRESULT hr;

    ENTER_EXT_TYPEINFO_CRITSECT();

    pTypeInfo = ::AggregateeFindTypeInfo(gpAggregateeTypeInfoTable, iid);

    if (!pTypeInfo) {

        LEAVE_EXT_TYPEINFO_CRITSECT();
        hr = AggregateeLoadTypeInfo(libid, iid, &pTypeInfo);
        BAIL_ON_FAILURE(hr);

        ENTER_EXT_TYPEINFO_CRITSECT();

        gpAggregateeTypeInfoTable = ::AggregateeAddTypeInfo(
                                          gpAggregateeTypeInfoTable,
                                          iid,
                                          pTypeInfo
                                          );

        if (!gpAggregateeTypeInfoTable) {
            LEAVE_EXT_TYPEINFO_CRITSECT();
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }

        //
        // Increment the global list of the types of type info's.
        //
        InterlockedIncrement(&glnMSEXTTypesOfInfo);

        InterlockedIncrement(&glnMSEXTObjCount);
    }

    pTypeInfo->AddRef();


    hr = AddTypeInfo(pTypeInfo, pIntf);
    BAIL_ON_FAILURE(hr);

    //
    // We have a ref on the object as add was succesful
    //
    InterlockedIncrement(&glnMSEXTObjCount);
    LEAVE_EXT_TYPEINFO_CRITSECT();

    if (SpecialId == -4) {
    hr = MarkAsNewEnum(pTypeInfo);
    } else if (SpecialId == DISPID_VALUE) {
    hr = MarkAsItem(pTypeInfo);
    }

    return S_OK;

error:
    if (pTypeInfo)
    pTypeInfo->Release();

    return hr;
}

//
// Kept for backwards compatibility.
//
HRESULT
LoadTypeInfoEntry(
    CAggregateeDispMgr *pDispMgr,
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    return pDispMgr->LoadTypeInfoEntry(libid, iid, pIntf, SpecialId);
}

void
AggregateeFreeTypeInfoTable()
{
    PTYPEINFO_TABLE pTypeInfoTable = NULL;
    PTYPEINFO_TABLE pTemp = NULL;
    ITypeInfo * pTypeInfo = NULL;

    pTypeInfoTable = gpAggregateeTypeInfoTable;

    while (pTypeInfoTable) {

        pTypeInfo = pTypeInfoTable->pTypeInfo;

        pTypeInfo->Release();


        pTemp = pTypeInfoTable;

        pTypeInfoTable = pTypeInfoTable->pNext;

        LocalFree(pTemp);
    }
}

HRESULT
CAggregateeDispMgr::InitializeDispMgr(
    DWORD dwExtensionID
    )
{
    if (dwExtensionID > 255) {
        return(E_FAIL);
    }
    _dwExtensionID = dwExtensionID;

    return(S_OK);
}

BOOL
AggregateeDllCanUnload()
{
    BOOL retVal = FALSE;

    ENTER_EXT_TYPEINFO_CRITSECT();
    retVal = (glnMSEXTObjCount == 0);
    LEAVE_EXT_TYPEINFO_CRITSECT();

    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\xml\winnt\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\xml\libmain.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     libmain.cxx
//
//  Contents: Contains the implementation of DLL entry points. 
//
//----------------------------------------------------------------------------

#define INITGUID

#include "cadsxml.hxx"
#include "adsxmlcf.hxx"
#include <ole2.h>

DECLARE_INFOLEVEL(ADs)

CADsXMLCF g_cfADsXML;
CRITICAL_SECTION g_ADsXMLCritSect;

struct CLSCACHE
{
    const CLSID *pclsid;
    IClassFactory *pCF;
};

DEFINE_GUID(CLSID_ADsXML, 0x800fc136,0xb101,0x46c4,0xa5,0xd9,0x80,0xfb,0x31,0x4e,0x1a,0x13);

CLSCACHE g_aclscache[] =
{
    &CLSID_ADsXML, &g_cfADsXML
};

#define ARRAY_SIZE(_a)  (sizeof(_a) / sizeof(_a[0]))
#define EXTENSION_CLSID L"SOFTWARE\\Microsoft\\ADs\\Providers\\LDAP\\Extensions\\top\\{800fc136-b101-46c4-a5d9-80fb314e1a13}"
#define EXTENSION_IID L"{91e5c5dc-926b-46ff-9fdb-9fb112bf10e6}"

extern CRITICAL_SECTION g_ExtTypeInfoCritSect;
extern CRITICAL_SECTION g_DispTypeInfoCritSect;

//----------------------------------------------------------------
//
//  Function:  DllGetClassObject
//
//  Synopsis:  Standard DLL entrypoint for locating class factories
//
// Arguments:  
//
// clsid       Class ID of object being created
// iid         Interface requested
// ppv         Returns interface requested
//
// Returns:    S_OK on success, error otherwise 
//
// Modifies:   *ppv to return interface pointer 
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(
    REFCLSID clsid, 
    REFIID iid, 
    LPVOID FAR* ppv
)
{
    HRESULT         hr = S_OK;
    size_t          i = 0;

    ADsAssert(ppv != NULL);

    for (i = 0; i < ARRAY_SIZE(g_aclscache); i++)
    {
        if (IsEqualCLSID(clsid, *g_aclscache[i].pclsid))
        {
            hr = g_aclscache[i].pCF->QueryInterface(iid, ppv);
            RRETURN(hr);
        }
    }

    *ppv = NULL;

    RRETURN(E_NOINTERFACE);
}

//----------------------------------------------------------------
//
// Function:   DllCanUnloadNow
//
// Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
// Arguments:  None
//
// Returns:    Returns S_FALSE if the DLL cannot be unloaded, S_OK otherwise.
//             The DLL can be unloaded if there are no outstanding objects. 
//
// Modifies:   Nothing
//
//---------------------------------------------------------------

STDAPI
DllCanUnloadNow(void)
{
    HRESULT hr = S_FALSE;

    EnterCriticalSection(&g_ADsXMLCritSect);
    if(0 == glnObjCnt) {
        hr = S_OK;
    }
    LeaveCriticalSection(&g_ADsXMLCritSect);

    return hr;
}

//+---------------------------------------------------------------
//
// Function:   DllMain 
//
// Synopsis:   Standard DLL initialization entrypoint
//
// Arguments:  
//
// hDll        Handle to the DLL module
// dwReason    Reason for calling this entry point
// lpReserved  Reserved 
//
// Returns:    Returns FALSE on failure, TRUE otherwise. 
//
// Modifies:   Nothing
//
//---------------------------------------------------------------

BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    HRESULT     hr;

    switch (dwReason) {

        case DLL_PROCESS_ATTACH:
            //
            // Catch case of init crit sect failing.
            //
            __try {

                DisableThreadLibraryCalls((HINSTANCE)hDll);

                InitializeCriticalSection(&g_ADsXMLCritSect);

#if DBG==1
#ifndef MSVC
                InitializeCriticalSection(&g_csOT);
                InitializeCriticalSection(&g_csMem);
#endif
                InitializeCriticalSection(&g_csDP);
#endif

                InitializeCriticalSection(&g_ExtTypeInfoCritSect);
                InitializeCriticalSection(&g_DispTypeInfoCritSect);

            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                //
                // Critical failure
                //
                return FALSE;
            }

            break;

        case DLL_PROCESS_DETACH:

            DeleteCriticalSection(&g_ADsXMLCritSect);

            AggregateeFreeTypeInfoTable();
#if DBG==1
#ifndef MSVC
            DeleteCriticalSection(&g_csOT);
            DeleteCriticalSection(&g_csMem);
#endif
            DeleteCriticalSection(&g_csDP);
#endif

            DeleteCriticalSection(&g_ExtTypeInfoCritSect);
            DeleteCriticalSection(&g_DispTypeInfoCritSect);

            break;

        default:
            return FALSE;
    }

    return TRUE;
}

//----------------------------------------------------------------
//
// Function:   DllRegisterServer
//
// Synopsis:   Standard DLL entrypoint to create registry entries for classes
//             supported by this DLL. 
//
// Arguments:  None
//
// Returns:    Returns S_OK on success, error otherwise. 
//
// Modifies:   Nothing
//
//---------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
    HRESULT hr = S_OK;
    long lRetVal = 0;
    HKEY hKey;

    lRetVal = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            EXTENSION_CLSID,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            NULL
            );

    if(lRetVal != ERROR_SUCCESS)
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(lRetVal));
   
    lRetVal = RegSetValueEx(
           hKey,
           L"Interfaces",
           0,
           REG_SZ,
           (const BYTE *) EXTENSION_IID,
           (wcslen(EXTENSION_IID) + 1) * 2
           );
        
    if(lRetVal != ERROR_SUCCESS)
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(lRetVal));

    RegCloseKey(hKey); 
           
error:

    RRETURN(hr);
}

//----------------------------------------------------------------
//
// Function:   DllUnregisterServer
//
// Synopsis:   Standard DLL entrypoint to remove registry entries for classes
//             supported by this DLL.
//
// Arguments:  None
//
// Returns:    Returns S_OK on success, error otherwise.
//
// Modifies:   Nothing
//
//--------------------------------------------------------------- 
STDAPI DllUnregisterServer(void)
{
    LONG lRetVal = 0;
    HRESULT hr = S_OK;

    lRetVal = RegDeleteKey(
            HKEY_LOCAL_MACHINE,
            EXTENSION_CLSID
            );

    if(lRetVal != ERROR_SUCCESS)
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(lRetVal));

    lRetVal = RegDeleteKey(
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Microsoft\\ADs\\Providers\\LDAP\\Extensions\\top"
            );
          
    if(lRetVal != ERROR_SUCCESS)
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(lRetVal));  

error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dbgexts\dnsdbg.c ===
#include "header.h"
#if DBG
    char DebuggerType[] = "Checked";
#else
    char DebuggerType[] = "Free";
#endif

char COMPILED[] = "File " __FILE__ "\n"
                  "Compiled on " __DATE__ " at " __TIME__ "\n";

#if defined( _WDBGEXTS_ )

EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
BOOLEAN                ChkTarget;

void
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT                 MajorVersion,
    USHORT                 MinorVersion
    )
{
    ExtensionApis     = *lpExtensionApis;
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget         = (SavedMajorVersion == 0x0c);
    return;
}


LPEXT_API_VERSION ExtensionApiVersion( void )
{
    return &ApiVersion;
}


DECLARE_API( version )
{
    dprintf( "%s Extension dll for Build %d debugging %s"
             "kernel for Build %d\n",

             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
    dprintf( COMPILED );
}

#else // not _WDBGEXTS_

//
// Dummy windbg specific exports allows a common .def
// file for both ntsd and windbg.
//

NTSD_EXTENSION_APIS  ExtensionApis;
HANDLE               ExtensionCurrentProcess;

void WinDbgExtensionDllInit( void ) { return; }
void ExtensionApiVersion( void ) {    return; }

DECLARE_API( version )
{
    INIT_API();
    dprintf( "%s Extension dll for Build %d\n",
             DebuggerType, VER_PRODUCTBUILD );
    dprintf( COMPILED );
}

#endif // _WDBGEXTS

//
// Common
//

void CheckVersion( void ) {
    return;
}


DllInit( HANDLE hModule, DWORD  dwReason, DWORD  dwReserved )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:  break;
        case DLL_THREAD_DETACH:  break;
        case DLL_PROCESS_DETACH: break;
        case DLL_PROCESS_ATTACH: break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\xml\macro.h ===
#define BAIL_ON_NULL(p)       \
        if (!(p)) {           \
                goto error;   \
        }

#define BAIL_IF_ERROR(hr) \
        if (FAILED(hr)) {       \
                goto cleanup;   \
        }\

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define CONTINUE_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                continue;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\


#define RRETURN_ENUM_STATUS(hr) \
        if (hr != S_OK) {       \
            RRETURN(S_FALSE);   \
        }                       \
        RRETURN(S_OK);




#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}

#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}

#define DEFINE_IADsPutGet_UnImplementation(cls)                          \
STDMETHODIMP                                                             \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                             \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                     \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}


#define DEFINE_IPrivateDispatch_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::ADSIGetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ADSIGetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::ADSIGetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ADSIInvoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}


#define DEFINE_IADsExtension_Implementation(cls)                        \
STDMETHODIMP                                                            \
cls::PrivateGetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,            \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)           \
{                                                                       \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                           \
                                         rgszNames,                     \
                                         cNames,                        \
                                         lcid,                          \
                                         rgdispid                       \
                                         ));                            \
}                                                                       \
                                                                        \
STDMETHODIMP                                                            \
cls::PrivateInvoke(DISPID dispidMember, REFIID iid, LCID lcid,          \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,             \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,             \
        unsigned int FAR* puArgErr)                                     \
{                                                                       \
        RRETURN (_pDispMgr->Invoke(dispidMember,                        \
                                   iid,                                 \
                                   lcid,                                \
                                   wFlags,                              \
                                   pdispparams,                         \
                                   pvarResult,                          \
                                   pexcepinfo,                          \
                                   puArgErr                             \
                                   ));                                  \
}


#define DEFINE_DELEGATING_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pADs->GetTypeInfoCount(pctinfo));                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pADs->GetTypeInfo(itinfo,                            \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pADs->GetIDsOfNames(iid,                             \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pADs->Invoke(dispidMember,                          \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dbgexts\export.c ===
#include "header.h"

//
//  This is the struct we want to dump.
//

//
// Dumps symbol information about Pointer.
//

void dprintSymbolPtr( void* Pointer)
{
    UCHAR SymbolName[ 80 ];
    ULONG Displacement;
    GetSymbol( Pointer, SymbolName, &Displacement );
    dprintf( "%-10lx (%s + 0x%X)%s\n", Pointer, SymbolName, Displacement );
}

// ========================================================================
// Reads the dword at p.

DWORD ReadDword( void * p )
{
    ULONG  result;
    DWORD  val;

    if ( !ReadMemory( p, &val, sizeof(DWORD), &result )){
        // dprintf( "ReadDword:Invalid DWORD * p = 0x%08x\n", p );
        val = 0;
    }
    return val;
}

WORD ReadWord( void * p )
{
    ULONG  result;
    WORD  val;

    if ( !ReadMemory( p, &val, sizeof(WORD), &result )){
        // dprintf( "ReadWord:Invalid DWORD * p = 0x%08x\n", p );
        val = 0;
    }
    return val;
}

// Read the string[n] at p, updates userstring[];
// Default len is 20 chars.

char userstring[255];

char * ReadStr( char * p, int len )
{
    ULONG  result;
    if( len <= 0 )
        len = 20;
    else if( len > sizeof( userstring ) )
        len = sizeof( userstring );

    if ( !ReadMemory( p, userstring, len, &result )){
        sprintf( userstring, "char p[%d] @ 0x%08x unreadable", len, p );
    }
    userstring[len] = '\0';
    return userstring;
}


//
// Dump the node p, and returns pointer to next node.
//

//
// Exported functions.
//

DECLARE_API( help )
{
    INIT_API();
    dprintf("Dnsapi debugger extension commands:\n\n");
    dprintf("\tdprint_CLIENT_QELEMENT <addr>   - Dump a CLIENT_QELEMENT.\n");
    dprintf("\tdprint_BUCKET <addr>   - Dump a BUCKET.\n");
    dprintf("\tdprint_ZONE_INFO <addr> \n");
    dprintf("\tdprint_SERVER_INFO <addr>   - Dump SrvCfg structure \n");
    dprintf("\tdprint_ResourceRecord <addr>   - Dump RR \n");
    return;
}

//
//  Usage: !mosh.node 002509e0
//



void print_CLIENT_QELEMENT( char* message, struct _CLIENT_QELEMENT * s );

DECLARE_API( dprint_CLIENT_QELEMENT ){    struct _CLIENT_QELEMENT * p = NULL;
    struct _CLIENT_QELEMENT   Q;    ULONG  result;    INIT_API();    if( *args )
        sscanf( args, "%lx", &p );
    if( !p || !ReadMemory( p, &Q, sizeof(Q), &result )){
       dprintf("Could not read address 0x%08x\n", p );       return;    }
    print_CLIENT_QELEMENT( "none", &Q );    return;}

// ==================================================//  _CLIENT_QELEMENTvoid

void
print_CLIENT_QELEMENT( char* message, struct _CLIENT_QELEMENT * s ){
    if(  message   ){       dprintf( "%s\n", message );    }
    if(  s == NULL ){       dprintf( "struct _CLIENT_QELEMENT is NULL.\n");
       return;    }    dprintf("struct _CLIENT_QELEMENT = {\n" );
    dprintf("  List         = 0x%08x \n", s->List );
    dprintf("  lpstrAdapterName = %s \n", ReadStr(s->lpstrAdapterName,0) );
    dprintf("  lpstrHostName = %s \n", ReadStr(s->lpstrHostName, 0) );
    dprintf("  pRegisterStatus = 0x%08x \n", ReadDword( s->pRegisterStatus ) );
    dprintf("  pHostAddrs   = 0x%08x \n", ReadDword( s->pHostAddrs ) );
    dprintf("  dwHostAddrCount = %d \n", s->dwHostAddrCount );
    dprintf("  lpstrDomainName = %s \n", ReadStr(s->lpstrDomainName, 0) );
    dprintf("  pipDnsServerList = 0x%08x \n", ReadDword( s->pipDnsServerList ) );
    dprintf("  dwDnsServerCount = %d \n", s->dwDnsServerCount );
    dprintf("  dwTTL        = %d \n", s->dwTTL );
    dprintf("  dwFlags      = %d \n", s->dwFlags );
    dprintf("  fNewElement  = 0x%08x \n", s->fNewElement );
    dprintf("  fRemove      = 0x%08x \n", s->fRemove );
    dprintf( "}; // struct _CLIENT_QELEMENT.\n");    return;
} /* print_CLIENT_QELEMENT */


void print_BUCKET( char* message, struct _BUCKET * s );
DECLARE_API( dprint_BUCKET ){    struct _BUCKET * p = NULL;
    struct _BUCKET   Q;    ULONG  result;    INIT_API();    if( *args )
        sscanf( args, "%lx", &p );
    if( !p || !ReadMemory( p, &Q, sizeof(Q), &result )){
       dprintf("Could not read address 0x%08x\n", p );       return;    }
    print_BUCKET( "none", &Q );    return;}

// ==================================================//  _BUCKETvoid
VOID
print_BUCKET( char* message, struct _BUCKET * s ){    if(  message   ){
       dprintf( "%s\n", message );    }    if(  s == NULL ){
       dprintf( "struct _BUCKET is NULL.\n");       return;    }
    dprintf("struct _BUCKET = {\n" );
    dprintf("  List         = 0x%08x \n", s->List );
    dprintf("  ppQList      = 0x%08x \n", ReadDword(s->ppQList) );
    dprintf("  dwListCount  = %d \n", s->dwListCount );
    dprintf("  dwRetryTime  = %d \n", s->dwRetryTime );
    dprintf("  HostName     = %s \n", ReadStr(s->HostName, 0) );
    dprintf("  DomainName   = %s \n", ReadStr(s->DomainName, 0));
    dprintf("  fSucceeded   = 0x%08x \n", s->fSucceeded );
    dprintf("  pRelatedBucket = 0x%08x \n", s->pRelatedBucket );
    dprintf("  fRemove      = 0x%08x \n", s->fRemove );
    dprintf("  dwRetryFactor = %d \n", s->dwRetryFactor );
    dprintf( "}; // struct _BUCKET.\n");    return;} /* print_BUCKET */

void
print_SERVER_INFO( char* message, struct _SERVER_INFO * s );

DECLARE_API( dprint_SERVER_INFO ){    struct _SERVER_INFO * p = NULL;
    struct _SERVER_INFO   Q;    ULONG  result;    INIT_API();    if( *args )
        sscanf( args, "%lx", &p );
    if( !p || !ReadMemory( p, &Q, sizeof(Q), &result )){
       dprintf("Could not read address 0x%08x\n", p );       return;    }
    print_SERVER_INFO( "none", &Q );    return;}
// ==================================================//  _SERVER_INFO
void
print_SERVER_INFO( char* message, struct _SERVER_INFO * s ){
    if(  message   ){       dprintf( "%s\n", message );    }
    if(  s == NULL ){       dprintf( "struct _SERVER_INFO is NULL.\n");
       return;    }    dprintf("struct _SERVER_INFO = {\n" );
    dprintf("  dwVersion    = %d \n", s->dwVersion );
    dprintf("  pszServerName = %s \n", ReadStr(s->pszServerName,0) );
    dprintf("  pszServerDomainName = %s \n", ReadStr(s->pszServerDomainName,0));
    dprintf("  fStarted     = 0x%08x \n", s->fStarted );
    dprintf("  fThreadAlert = 0x%08x \n", s->fThreadAlert );
    dprintf("  fServiceExit = 0x%08x \n", s->fServiceExit );
    dprintf("  hContinueEvent = 0x%08x \n", s->hContinueEvent );
    dprintf("  hShutdownEvent = 0x%08x \n", s->hShutdownEvent );
    dprintf("  fWinsInitialized = 0x%08x \n", s->fWinsInitialized );
    dprintf("  fMemoryException = 0x%08x \n", s->fMemoryException );
    dprintf("  fAVException = 0x%08x \n", s->fAVException );
    dprintf("  dwCurrentTime = %d \n", s->dwCurrentTime );
    dprintf("  fBootRegistry = %d \n", s->fBootRegistry );
    dprintf("  fBootFileDirty = %d \n", s->fBootFileDirty );
    dprintf("  cDsZones     = %d \n", s->cDsZones );
    dprintf("  fRemoteDs    = %d \n", s->fRemoteDs );
    dprintf("  fDatabaseSupported = %d \n", s->fDatabaseSupported );
    dprintf("  pszDatabaseDirectory = 0x%08x \n", s->pszDatabaseDirectory );
    dprintf("  dwRpcProtocol = %d \n", s->dwRpcProtocol );
    dprintf("  dwLogLevel   = %d \n", s->dwLogLevel );
    dprintf("  dwDebugLevel = %d \n", s->dwDebugLevel );
    dprintf("  aipServerAddrs = 0x%08x \n", ReadDword( s->aipServerAddrs ) );
    dprintf("  aipBoundAddrs = 0x%08x \n", ReadDword( s->aipBoundAddrs ) );
    dprintf("  aipListenAddrs = 0x%08x \n", ReadDword( s->aipListenAddrs ) );
    dprintf("  fListenAddrsSet = %d \n", s->fListenAddrsSet );
    dprintf("  fListenAddrsStale = %d \n", s->fListenAddrsStale );
    dprintf("  fDisjointNets = %d \n", s->fDisjointNets );
    dprintf("  fNoTcp       = %d \n", s->fNoTcp );
    dprintf("  fRecurseOnDnsPort = %d \n", s->fRecurseOnDnsPort );
    dprintf("  aipForwarders = 0x%08x \n", ReadDword( s->aipForwarders ) );
    dprintf("  dwForwardTimeout = %d \n", s->dwForwardTimeout );
    dprintf("  fSlave       = %d \n", s->fSlave );
    dprintf("  fNoRecursion = %d \n", s->fNoRecursion );
    dprintf("  fRecursionAvailable = %d \n", s->fRecursionAvailable );
    dprintf("  dwRecursionRetry = %d \n", s->dwRecursionRetry );
    dprintf("  dwRecursionTimeout = %d \n", s->dwRecursionTimeout );
    dprintf("  dwMaxCacheTtl = %d \n", s->dwMaxCacheTtl );
    dprintf("  fSecureResponses = %d \n", s->fSecureResponses );
    dprintf("  fAllowUpdate = %d \n", s->fAllowUpdate );
    dprintf("  fExtendedCharNames = %d \n", s->fExtendedCharNames );
    dprintf("  dwNameCheckFlag = %d \n", s->dwNameCheckFlag );
    dprintf("  dwCleanupInterval = %d \n", s->dwCleanupInterval );
    dprintf("  fNoAutoReverseZones = %d \n", s->fNoAutoReverseZones );
    dprintf("  fAutoCacheUpdate = %d \n", s->fAutoCacheUpdate );
    dprintf("  fRoundRobin  = %d \n", s->fRoundRobin );
    dprintf("  fLocalNetPriority = %d \n", s->fLocalNetPriority );
    dprintf("  cAddressAnswerLimit = %d \n", s->cAddressAnswerLimit );
    dprintf("  fBindSecondaries = %d \n", s->fBindSecondaries );
    dprintf("  fWriteAuthoritySoa = %d \n", s->fWriteAuthoritySoa );
    dprintf("  fWriteAuthorityNs = %d \n", s->fWriteAuthorityNs );
    dprintf("  fWriteAuthority = %d \n", s->fWriteAuthority );
    dprintf("  fStrictFileParsing = %d \n", s->fStrictFileParsing );
    dprintf("  fLooseWildcarding = %d \n", s->fLooseWildcarding );
    dprintf( "}; // struct _SERVER_INFO.\n");    return;
} /* print_SERVER_INFO */


// Generated Mon Aug 18 20:53:32 1997 on MohsinA5 1.2.13
void print_ZONE_INFO( char* message, ZONE_INFO * s );

DECLARE_API( dprint_ZONE_INFO )
{
    ZONE_INFO * p = NULL;
    ZONE_INFO   Q;
    ULONG  result;
    INIT_API();
    if( *args )
        sscanf( args, "%lx", &p );
    if( !p || !ReadMemory( p, &Q, sizeof(Q), &result )){
       dprintf("Could not read address 0x%08x\n", p );
       return;
    }
    print_ZONE_INFO( "none", &Q );
    return;
}
// ==================================================
//  ZONE_INFO

void
print_ZONE_INFO( char* message, ZONE_INFO * s )
{
    if(  message   ){
        dprintf( "%s\n", message );
    }
    if(  s == NULL ){
        dprintf( "ZONE_INFO is NULL.\n");
        return;
    }
    dprintf("ZONE_INFO = {\n" );
    dprintf("  ListEntry    = 0x%08x \n", s->ListEntry );
    dprintf("  pZoneRoot    = 0x%08x \n", ReadDword( s->pZoneRoot ) );
    dprintf("  pszZoneName  = %s \n", ReadStr(s->pszZoneName,0) );
    dprintf("  pszDataFile  = %s \n", ReadStr(s->pszDataFile,0) );
    dprintf("  pszLogFile   = %s \n", ReadStr(s->pszLogFile,0) );
    dprintf("  pszZoneDN    = %s \n", ReadStr(s->pszZoneDN,0) );
    dprintf("  dwLastUsn    = %s \n", ReadStr(s->szLastUsn,0) );
    dprintf("  ipReverse    = 0x%08x \n", s->ipReverse );
    dprintf("  ipReverseMask = 0x%08x \n", s->ipReverseMask );
    dprintf("  pSoaRR       = 0x%08x \n", ReadDword( s->pSoaRR ) );
    dprintf("  dwSerialNo   = %d \n", s->dwSerialNo );
    dprintf("  dwLoadSerialNo = %d \n", s->dwLoadSerialNo );
    dprintf("  dwLastXfrSerialNo = %d \n", s->dwLastXfrSerialNo );
    dprintf("  dwNewSerialNo = %d \n", s->dwNewSerialNo );
    dprintf("  dwDefaultTtl = %d \n", s->dwDefaultTtl );
    dprintf("  dwDefaultTtlHostOrder = %d \n", s->dwDefaultTtlHostOrder );
    dprintf("  hfileUpdateLog = 0x%08x \n", s->hfileUpdateLog );
    dprintf("  iUpdateLogCount = %d \n", s->iUpdateLogCount );
    dprintf("  UpdateList   = 0x%08x \n", s->UpdateList );
    dprintf("  iRRCount     = %d \n", s->iRRCount );
    dprintf("  aipSecondaries = 0x%08x \n", ReadDword( s->aipSecondaries ) );
    dprintf("  aipNameServers = 0x%08x \n", ReadDword( s->aipNameServers ) );
    dprintf("  dwNextTransferTime = %d \n", s->dwNextTransferTime );
    dprintf("  ipPrimary    = 0x%08x \n", s->ipPrimary );
    dprintf("  aipMasters   = 0x%08x \n", ReadDword( s->aipMasters ) );
    dprintf("  dwNextSoaCheckTime = %d \n", s->dwNextSoaCheckTime );
    dprintf("  dwExpireTime = %d \n", s->dwExpireTime );
    dprintf("  ipNotifier   = 0x%08x \n", s->ipNotifier );
    dprintf("  ipFreshMaster = 0x%08x \n", s->ipFreshMaster );
    dprintf("  pszMasterIpString = 0x%08x \n", s->pszMasterIpString );
    dprintf("  dwZoneRecvStartTime = %d \n", s->dwZoneRecvStartTime );
    dprintf("  pLocalWinsRR = 0x%08x \n", ReadDword( s->pLocalWinsRR ) );
    dprintf("  pWinsRR      = 0x%08x \n", ReadDword( s->pWinsRR ) );
    dprintf("  dwLockingThreadId = %d \n", s->dwLockingThreadId );
    dprintf("  chZoneType   = %c \n", s->chZoneType );
    dprintf("  cZoneNameLabelCount = 0x%08x \n", s->cZoneNameLabelCount );
    dprintf("  fReverse     = 0x%08x \n", s->fReverse );
    dprintf("  fDsIntegrated = 0x%08x \n", s->fDsIntegrated );
    dprintf("  fDsLoadVersion = 0x%08x \n", s->fDsLoadVersion );
    dprintf("  fUnicode     = 0x%08x \n", s->fUnicode );
    dprintf("  fAutoCreated = 0x%08x \n", s->fAutoCreated );
    dprintf("  fSecureSecondaries = 0x%08x \n", s->fSecureSecondaries );
    dprintf("  fAllowUpdate = 0x%08x \n", s->fAllowUpdate );
    dprintf("  fLogUpdates  = 0x%08x \n", s->fLogUpdates );
    dprintf("  fPaused      = 0x%08x \n", s->fPaused );
    dprintf("  fDirty       = 0x%08x \n", s->fDirty );
    dprintf("  fShutdown    = 0x%08x \n", s->fShutdown );
    dprintf("  fNotified    = 0x%08x \n", s->fNotified );
    dprintf("  fStale       = 0x%08x \n", s->fStale );
    dprintf("  fEmpty       = 0x%08x \n", s->fEmpty );
    dprintf("  fLocked      = 0x%08x \n", s->fLocked );
    dprintf("  fUpdateLock  = 0x%08x \n", s->fUpdateLock );
    dprintf("  fXfrRecvLock = 0x%08x \n", s->fXfrRecvLock );
    dprintf("  fFileWriteLock = 0x%08x \n", s->fFileWriteLock );
    dprintf("  cReaders     = 0x%08x \n", s->cReaders );
    dprintf( "}; // struct ZONE_INFO.\n");
    return;
} /* print_ZONE_INFO */




// Generated Mon Aug 18 21:22:54 1997 on MohsinA5 1.2.13
void print_ResourceRecord( char* message, struct _ResourceRecord * s );

DECLARE_API( dprint_ResourceRecord )
{
    struct _ResourceRecord * p = NULL;
    struct _ResourceRecord   Q;
    ULONG  result;
    INIT_API();
    if( *args )
        sscanf( args, "%lx", &p );
    if( !p || !ReadMemory( p, &Q, sizeof(Q), &result )){
       dprintf("Could not read address 0x%08x\n", p );
       return;
    }
    print_ResourceRecord( "none", &Q );
    return;
}
// ==================================================
//  ResourceRecord

void
print_ResourceRecord( char* message, struct _ResourceRecord * s )
{
    if(  message   ){
        dprintf( "%s\n", message );
    }
    if(  s == NULL ){
        dprintf( "struct ResourceRecord is NULL.\n");
        return;
    }
    dprintf("struct _ResourceRecord = {\n" );
    dprintf("  pRRNext      = 0x%08x \n", s->pRRNext );
    dprintf("  RecordRank   = 0x%08x \n", s->RecordRank );
    dprintf("  RRReserved   = 0x%08x \n", s->RRReserved );
    dprintf("  wRRFlags     = %d \n", s->wRRFlags );
    dprintf("  wType        = %d \n", s->wType );
    dprintf("  wDataLength  = %d \n", s->wDataLength );
    dprintf("  dwTtlSeconds = %d \n", s->dwTtlSeconds );
    dprintf("  ipAddress    = 0x%08x \n", s->Data.A.ipAddress );
    dprintf("  ipv6Address  = 0x%08x \n", s->Data.AAAA.ipv6Address );
    dprintf("  pnodePrimaryServer = 0x%08x \n", ReadDword( s->Data.SOA.pnodePrimaryServer ) );
    dprintf("  pnodeZoneAdmin = 0x%08x \n", ReadDword( s->Data.SOA.pnodeZoneAdmin ) );
    dprintf("  dwSerialNo   = %d \n", s->Data.SOA.dwSerialNo );
    dprintf("  dwRefresh    = %d \n", s->Data.SOA.dwRefresh );
    dprintf("  dwRetry      = %d \n", s->Data.SOA.dwRetry );
    dprintf("  dwExpire     = %d \n", s->Data.SOA.dwExpire );
    dprintf("  dwMinimumTtl = %d \n", s->Data.SOA.dwMinimumTtl );
    dprintf("  pnodeAddress = 0x%08x \n", ReadDword( s->Data.PTR.pnodeAddress ) );
    dprintf("  pnodeMailbox = 0x%08x \n", ReadDword( s->Data.MINFO.pnodeMailbox ) );
    dprintf("  pnodeErrorsMailbox = 0x%08x \n", ReadDword( s->Data.MINFO.pnodeErrorsMailbox ) );
    dprintf( "}; // struct ResourceRecord.\n");
    return;
} /* print_ResourceRecord */


void print_ADDITIONAL_INFO( char* message, ADDITIONAL_INFO * s );

DECLARE_API( dprint_ADDITIONAL_INFO )
{
    ADDITIONAL_INFO * p = NULL;
    ADDITIONAL_INFO   Q;
    ULONG  result;
    INIT_API();
    if( *args )
        sscanf( args, "%lx", &p );
    if( !p || !ReadMemory( p, &Q, sizeof(Q), &result )){
       dprintf("Could not read address 0x%08x\n", p );
       return;
    }
    print_ADDITIONAL_INFO( "none", &Q );
    return;
}
// ==================================================
//  _ADDITIONAL_INFO

void
print_ADDITIONAL_INFO( char* message, ADDITIONAL_INFO * s )
{
    if(  message   ){
        dprintf( "%s\n", message );
    }
    if(  s == NULL ){
        dprintf( "ADDITIONAL_INFO is NULL.\n");
        return;
    }
    dprintf("ADDITIONAL_INFO = {\n" );
    dprintf("  cMaxCount    = %d \n", s->cMaxCount );
    dprintf("  cCount       = %d \n", s->cCount );
    dprintf("  iIndex       = %d \n", s->iIndex );
    dprintf( "}; // ADDITIONAL_INFO.\n");
    return;
} /* print_ADDITIONAL_INFO */


void print_DNS_MSGINFO( char* message, struct _DNS_MSGINFO * s );

DECLARE_API( dprint_DNS_MSGINFO ){    struct _DNS_MSGINFO * p = NULL;

struct _DNS_MSGINFO   Q;    ULONG  result;    INIT_API();    if( *args )
        sscanf( args, "%lx", &p );
    if( !p || !ReadMemory( p, &Q, sizeof(Q), &result )){
       dprintf("Could not read address 0x%08x\n", p );       return;    }
    print_DNS_MSGINFO( "none", &Q );    return;}
// ==================================================//  _DNS_MSGINFO
void
print_DNS_MSGINFO( char* message, struct _DNS_MSGINFO * s ){
    if(  message   ){       dprintf( "%s\n", message );    }
    if(  s == NULL ){       dprintf( "struct _DNS_MSGINFO is NULL.\n");
       return;    }    dprintf("struct _DNS_MSGINFO = {\n" );
    dprintf("  ListEntry    = 0x%08x \n", s->ListEntry );
    dprintf("  Socket       = 0x%08x \n", s->Socket );
    dprintf("  RemoteAddressLength = %d \n", s->RemoteAddressLength );
    dprintf("  RemoteAddress = 0x%08x \n", s->RemoteAddress );
    dprintf("  BufferLength = %d \n", s->BufferLength );
    dprintf("  pBufferEnd   = %s \n", ReadStr( s->pBufferEnd, 20 ) );
    dprintf("  pCurrentCountField = %d \n", ReadDword( s->pCurrentCountField ) );
    dprintf("  pCurrent     = 0x%08x \n", ReadDword( s->pCurrent ) );
    dprintf("  pnodeCurrent = 0x%08x \n", ReadDword( s->pnodeCurrent ) );
    dprintf("  wTypeCurrent = %d \n", s->wTypeCurrent );
    dprintf("  wOffsetCurrent = %d \n", s->wOffsetCurrent );
    dprintf("  pQuestion    = 0x%08x \n", ReadDword( s->pQuestion ) );
    dprintf("  wQuestionType = %d \n", s->wQuestionType );
    dprintf("  wQueuingXid  = %d \n", s->wQueuingXid );
    dprintf("  dwQueryTime  = %d \n", s->dwQueryTime );
    dprintf("  dwQueuingTime = %d \n", s->dwQueuingTime );
    dprintf("  dwExpireTime = %d \n", s->dwExpireTime );
    dprintf("  OriginalSocket = 0x%08x \n", s->OriginalSocket );
    dprintf("  ipOriginal   = 0x%08x \n", s->ipOriginal );
    dprintf("  wOriginalPort = %d \n", s->wOriginalPort );
    dprintf("  wOriginalXid = %d \n", s->wOriginalXid );
    dprintf("  pRecurseMsg  = 0x%08x \n", s->pRecurseMsg );
    dprintf("  pnodeRecurseRetry = 0x%08x \n", ReadDword( s->pnodeRecurseRetry ) );
    dprintf("  pVisitedNs   = 0x%08x \n", ReadDword( s->pVisitedNs ) );
    dprintf("  pConnection  = 0x%08x \n", ReadDword( s->pConnection ) );
    dprintf("  pchRecv      = %s \n", ReadStr( s->pchRecv, 20 ) );
    dprintf("  pzoneCurrent = 0x%08x \n", ReadDword( s->pzoneCurrent ) );
    dprintf("  pWinsRR      = 0x%08x \n", ReadDword( s->pWinsRR ) );
    dprintf("  ipNbstat     = 0x%08x \n", s->ipNbstat );
    dprintf("  pNbstat      = 0x%08x \n", ReadDword( s->pNbstat ) );
    dprintf("  dwNbtInterfaceMask = %d \n", s->dwNbtInterfaceMask );
    dprintf("  fDelete      = 0x%08x \n", s->fDelete );
    dprintf("  fTcp         = 0x%08x \n", s->fTcp );
    dprintf("  fMessageComplete = 0x%08x \n", s->fMessageComplete );
    dprintf("  fDoAdditional = 0x%08x \n", s->fDoAdditional );
    dprintf("  fRecursePacket = 0x%08x \n", s->fRecursePacket );
    dprintf("  fRecurseIfNecessary = 0x%08x \n", s->fRecurseIfNecessary );
    dprintf("  fQuestionRecursed = 0x%08x \n", s->fQuestionRecursed );
    dprintf("  fQuestionCompleted = 0x%08x \n", s->fQuestionCompleted );
    dprintf("  fRecurseTimeoutWait = 0x%08x \n", s->fRecurseTimeoutWait );
    dprintf("  nForwarder   = %c \n", s->nForwarder );
    dprintf("  fReplaceCname = 0x%08x \n", s->fReplaceCname );
    dprintf("  cCnameAnswerCount = 0x%08x \n", s->cCnameAnswerCount );
    dprintf("  fBindTransfer = 0x%08x \n", s->fBindTransfer );
    dprintf("  fNoCompressionWrite = 0x%08x \n", s->fNoCompressionWrite );
    dprintf("  fWins        = 0x%08x \n", s->fWins );
    dprintf("  fNbstatResponded = 0x%08x \n", s->fNbstatResponded );
    dprintf("  cchWinsName  = 0x%08x \n", s->cchWinsName );
    dprintf("  pLooknameQuestion = 0x%08x \n", ReadDword( s->pLooknameQuestion ) );
    dprintf("  Additional   = 0x%08x \n", s->Additional );
    dprintf("  Compression  = 0x%08x \n", s->Compression );
    dprintf("  BytesToReceive = %d \n", s->BytesToReceive );
    dprintf("  MessageLength = %d \n", s->MessageLength );
    dprintf("  MessageHead  = 0x%08x \n", s->MessageHead );
    dprintf( "}; // struct _DNS_MSGINFO.\n");    return;
} /* print_DNS_MSGINFO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dbgexts\header.h ===
//
// Define this constant so that hal.h won't be included.  This is so that
// the project will build, as someone under here has redefined some types
// that are in hal.h
//

#define _HAL_



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

//  headers are screwed up
//  if you bring in nt.h, then don't bring in winnt.h and
//  then you miss these

#ifndef MAXWORD
#define MINCHAR     0x80
#define MAXCHAR     0x7f
#define MINSHORT    0x8000
#define MAXSHORT    0x7fff
#define MINLONG     0x80000000
#define MAXLONG     0x7fffffff
#define MAXBYTE     0xff
#define MAXWORD     0xffff
#define MAXDWORD    0xffffffff
#endif

#ifndef DNS_WINSOCK1
#include <winsock2.h>
#define DNS_WINSOCK2 1
#else
#include <winsock.h>
#endif

#if WINDBG
#   include <wdbgexts.h>
#else
#   include <ntsdexts.h>
#endif

#include <basetyps.h>
#include <nspapi.h>
#include <svcguid.h>

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

//#include <tcpsvcs.h>        //  tcpsvcs globals

#include <dnsapi.h>         //  DNS library routines
#include <windns.h>         //  DNS API
#include <dnsrpc.h>

//  #include <dnsapip.h>
//  #include <record.h>         //  record defs in library
//  #include "dnsrpc_s.h"       //  DNS RPC definitions

#include "srvcfg.h"
#include "dnsmsg.h"
#include "file.h"
#include "name.h"
#include "tree.h"
#include "record.h"
#include "update.h"
#include "zone.h"
#include "registry.h"
#include "zone.h"
#include "msginfo.h"
#include "tcpcon.h"
#include "packetq.h"
#include "dbase.h"

#include "recurse.h"
#include "nameutil.h"
#include "ntverp.h"
//
// RBUGBUG
// PCLIENT_QELEMENT structure and PBUCKET structure have been 
// copied from dhcpclnt.c. Make sure to copy them from wherever necessary
//
//

typedef struct _CLIENT_QELEMENT {

    LIST_ENTRY           List;
    LPSTR                lpstrAdapterName;
    LPSTR                lpstrHostName;
    PREGISTER_HOST_STATUS pRegisterStatus;
    PREGISTER_HOST_ENTRY pHostAddrs;
    DWORD                dwHostAddrCount;
    LPSTR                lpstrDomainName;
    PIP_ADDRESS          pipDnsServerList;
    DWORD                dwDnsServerCount;
    DWORD                dwTTL;
    DWORD                dwFlags;
    BOOL                 fNewElement;
    BOOL                 fRemove;

} CLIENT_QELEMENT, *PCLIENT_QELEMENT;

typedef struct _BUCKET 
{
    LIST_ENTRY        List;
    PCLIENT_QELEMENT* ppQList;
    DWORD             dwListCount;
    DWORD             dwRetryTime;
    CHAR              HostName[50];
    CHAR              DomainName[50];
    BOOL              fSucceeded;
    struct _BUCKET*   pRelatedBucket;    
    BOOL              fRemove;       // delete elements in this bucket?
    DWORD             dwRetryFactor;
} BUCKET, *PBUCKET;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\asyncreg.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    asyncreg.c

Abstract:

    Domain Name System (DNS) API

    Client IP/PTR dynamic update.

Author:

    Glenn Curtis (GlennC)   Feb-16-1998

Revision History:

    Jim Gilroy (jamesg)     May\June 2001
                            - eliminate duplicate code
                            - simplify lines
                            - PTR reg only if forward successful
                            - alternate names

--*/


#include "local.h"
#include <netevent.h>

#define ENABLE_DEBUG_LOGGING 1

#include "logit.h"


//
//  Flags for debugging for this module
//

#define DNS_DBG_DHCP            DNS_DBG_UPDATE
#define DNS_DBG_DHCP2           DNS_DBG_UPDATE2

//
//  Registry values
//

#define ADAPTER_NAME_CLASS          "AdapterNameClass"

#define REGISTERED_ADDRS            "RegisteredAddresses"
#define REGISTERED_ADDRS_COUNT      "RegisteredAddressCount"
#define REGISTERED_NAME             "RegisteredName"

//
//  DCR_CLEANUP:  tag these definitions to avoid collision
//      with registry.h defs
//

#define REGISTERED_HOST_NAME        "HostName"
#define REGISTERED_HOST_NAME_W      L"HostName"
#define REGISTERED_DOMAIN_NAME      "DomainName"
#define REGISTERED_DOMAIN_NAME_W    L"DomainName"

#define SENT_UPDATE_TO_IP           "SentUpdateToIp"
#define SENT_PRI_UPDATE_TO_IP       "SentPriUpdateToIp"
#define REGISTERED_TTL              "RegisteredTTL"
#define FLAGS                       "RegisteredFlags"
#define REGISTERED_SINCE_BOOT       "RegisteredSinceBoot"
#define DNS_SERVER_ADDRS            "DNSServerAddresses"
#define DNS_SERVER_ADDRS_COUNT      "DNSServerAddressCount"

#define DEFAULT_REG_LOCATION        "System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\DNSRegisteredAdapters"
#define DEFAULT_REG_LOCATION_WIN95  "System\\CurrentControlSet\\Services\\VxD\\MSTCP\\Parameters\\DNSRegisteredAdapters"
#define NT_INTERFACE_REG_LOCATION   "System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\"
#define TCPIP_REG_LOCATION          "System\\CurrentControlSet\\Services\\Tcpip\\Parameters"

#define DYN_DNS_ROOT_CLASS          "DynDRootClass"
#define BOOT_TIME                   "BootTime"


#define DHCPVER_WIN95               2
#define DHCPVER_WINNT               1
#define DHCPVER_UNINIT              0

#define FIRST_RETRY_INTERVAL        5*60     // 5 minutes
#define SECOND_RETRY_INTERVAL       10*60    // 10 minutes
#define FAILED_RETRY_INTERVAL       60*60    // 1 hour

#define ASYNC_INIT_CALLED()         (g_dwVersion != DHCPVER_UNINIT)
#define CLEAR_ASYNC_INIT()          g_dwVersion = DHCPVER_UNINIT ;


//
//  Registry state flags
//

#define REGISTERED_FORWARD          0x00000001
#define REGISTERED_PRIMARY          0x00000002
#define REGISTERED_POINTER          0x00000004

//
//  Update type
//
//  Multiple types of updates for a given entry.
//  These identify which type (which name) being updated.
//

typedef enum _UpType
{
    UPTYPE_PRIMARY  = 1,
    UPTYPE_DOMAIN,
    UPTYPE_ALTERNATE,
    UPTYPE_PTR
}
UPTYPE, *PUPTYPE;

#define IS_UPTYPE_PRIMARY(UpType)       ((UpType)==UPTYPE_PRIMARY)
#define IS_UPTYPE_DOMAIN(UpType)        ((UpType)==UPTYPE_DOMAIN)
#define IS_UPTYPE_ALTERNATE(UpType)     ((UpType)==UPTYPE_ALTERNATE)
#define IS_UPTYPE_PTR(UpType)           ((UpType)==UPTYPE_PTR)


//
//  On unjoin, deregistration wait no more than two minutes
//      to clean up -- then just get outta Dodge
//
#if DBG
#define REMOVE_REGISTRATION_WAIT_LIMIT  (0xffffffff)
#else
#define REMOVE_REGISTRATION_WAIT_LIMIT  (120000)    // 2 minutes in ms
#endif


//
// definition of client list element
//

#define DNS_SIG_TOP        0x123aa321
#define DNS_SIG_BOTTOM     0x321bb123

typedef struct _DnsUpdateEntry
{
    LIST_ENTRY              List;
    DWORD                   SignatureTop;
    PSTR                    AdapterName;
    PSTR                    HostName;
    PSTR                    PrimaryDomainName;
    PSTR                    DomainName;
    PSTR                    AlternateNames;
    DWORD                   AlternateIndex;
    DWORD                   HostAddrCount;
    PREGISTER_HOST_ENTRY    HostAddrs;
    PIP_ARRAY               DnsServerList;
    IP_ADDRESS              SentUpdateToIp;
    IP_ADDRESS              SentPriUpdateToIp;
    DWORD                   TTL;
    DWORD                   Flags;
    BOOL                    fNewElement;
    BOOL                    fFromRegistry;
    BOOL                    fRemove;
    BOOL                    fRegisteredPRI;
    BOOL                    fRegisteredFWD;
    BOOL                    fRegisteredALT;
    BOOL                    fRegisteredPTR;
    BOOL                    fDisableErrorLogging;
    DWORD                   RetryCount;
    DWORD                   RetryTime;
    PREGISTER_HOST_STATUS   pRegisterStatus;
    DWORD                   SignatureBottom;
}
UPDATE_ENTRY, *PUPDATE_ENTRY;


//
// globals
//

//
// the behavior of the system at boot differs from when it is not at
// boot. At boot time we collect a bunch of requests and register them
// in one shot. One thread does this. After boot, we register them
// as requests come in, one at a time.
//

BOOL    g_fAtBoot = TRUE;
BOOL    g_fPurgeRegistrations = FALSE;
BOOL    g_fPurgeRegistrationsInitiated = FALSE;
BOOL    g_fRegistrationThreadRunning = FALSE;
BOOL    g_fNoMoreDDNSUpdates = FALSE;
BOOL    g_fShutdown = FALSE;
DWORD   g_dwTime = 0;           // To determine boot time or not


//
// The following global is used to eliminate multiple calls to GetVersion()
//

DWORD g_dwVersion = DHCPVER_UNINIT; // is 1 for winnt and 2 for win95

LIST_ENTRY  g_RegistrationList;

HANDLE      g_hStopEvent = NULL;
HANDLE      g_hThreadDeadEvent = NULL;
HANDLE      g_hNewItemEvent = NULL;

HANDLE      g_hRegistrationThread = NULL;

BOOL        g_fQuit = FALSE;
HKEY        g_hKey = NULL;
DWORD       g_dwBootTime = 60;


//
// Private heap
//

#define     INITIAL_DDNS_HEAP     (16*1024)
HANDLE      g_DDNSHeap;

#define     PHEAP_ALLOC_ZERO( s )   HeapAlloc( g_DDNSHeap, HEAP_ZERO_MEMORY, (s) )
#define     PHEAP_ALLOC( s )        HeapAlloc( g_DDNSHeap, HEAP_ZERO_MEMORY, (s) )
#define     PHEAP_FREE( p )         HeapFree( g_DDNSHeap, 0, (p) )


//
//  Private protos
//

DNS_STATUS
AllocateUpdateEntry(
    IN  PSTR                    AdapterName,
    IN  PSTR                    HostName,
    IN  PSTR                    DomainName,
    IN  PSTR                    PrimaryDomainName,
    IN  PSTR                    AlternateNames,
    IN  DWORD                   HostAddrCount,
    IN  PREGISTER_HOST_ENTRY    HostAddrs,
    IN  DWORD                   DnsServerCount,
    IN  PIP_ADDRESS             DnsServerList,
    IN  IP_ADDRESS              SentUpdateToIp,
    IN  IP_ADDRESS              SentPriUpdateToIp,
    IN  DWORD                   TTL,
    IN  DWORD                   Flags,
    IN  DWORD                   RetryCount,
    IN  DWORD                   RetryTime,
    IN  PREGISTER_HOST_STATUS   RegisterStatus,
    OUT PUPDATE_ENTRY *         ppUpdateEntry
    );

VOID
FreeUpdateEntry(
    IN OUT  PUPDATE_ENTRY   pUpdateEntry
    );

VOID
FreeUpdateEntryList(
    IN      PLIST_ENTRY     pUpdateEntry
    );

DWORD
WINAPI
RegistrationThread(
    VOID
    );

VOID
WriteUpdateEntryToRegistry(
    IN      PUPDATE_ENTRY   pUpdateEntry
    );

PUPDATE_ENTRY
ReadUpdateEntryFromRegistry(
    IN      PSTR            pszAdapterName
    );

VOID
MarkAdapterAsPendingUpdate(
    IN      PSTR            pAdapterName
    );

DWORD
GetNextUpdateEntryFromList(
    OUT     PUPDATE_ENTRY * ppUpdateEntry,
    OUT     PDWORD          pdwWaitTime
    );

VOID
ProcessUpdateEntry(
    IN OUT  PUPDATE_ENTRY   pUpdateEntry,
    IN      BOOL            fPurgeMode
    );

DNS_STATUS
ModifyAdapterRegistration(
    IN OUT  PUPDATE_ENTRY   pUpdateEntry,
    IN OUT  PUPDATE_ENTRY   pRegistryEntry,
    IN      PDNS_RECORD     pUpdateRecord,
    IN      PDNS_RECORD     pRegRecord,
    IN      BOOL            fPrimaryDomain
    );

VOID
ResetAdaptersInRegistry(
    VOID
    );

VOID

DeregisterUnusedAdapterInRegistry(
    IN      BOOL            fPurgeMode
    );

PDNS_RECORD
GetPreviousRegistrationInformation(
    IN      PUPDATE_ENTRY   pUpdateEntry,
    IN      BOOL            fPrimaryDomain,
    OUT     PIP_ADDRESS     pServerIp
    );

PDNS_RECORD
CreateDnsRecordSetUnion(
    IN      PDNS_RECORD     pSet1,
    IN      PDNS_RECORD     pSet2
    );

#if 1 // DBG
VOID 
LogHostEntries(
    IN  DWORD                dwHostAddrCount,
    IN  PREGISTER_HOST_ENTRY pHostAddrs
    );
#define DNSLOG_HOST_ENTRYS( a, b )  LogHostEntries( a, b )
#else
#define DNSLOG_HOST_ENTRYS( a, b )
#endif

#if 1 // DBG
VOID 
LogPipAddress(
    IN  DWORD       dwServerListCount,
    IN  PIP_ADDRESS pServers
    );
#define DNSLOG_PIP_ADDRESS( a, b )  LogPipAddress( a, b )
#else
#define DNSLOG_PIP_ADDRESS( a, b )
#endif

#if 1 // DBG
VOID 
LogPipArray(
    IN  PIP_ARRAY pServers
    );
#define DNSLOG_PIP_ARRAY( a )  LogPipArray( a )
#else
#define DNSLOG_PIP_ARRAY( a )
#endif


DNS_STATUS
alertOrStartRegistrationThread(
    VOID
    );

VOID
registerUpdateStatus(
    IN OUT  PREGISTER_HOST_STATUS   pRegStatus,
    IN      DNS_STATUS              Status
    );

VOID
enqueueUpdate(
    IN OUT  PUPDATE_ENTRY   pUpdate
    );

VOID
enqueueUpdateMaybe(
    IN OUT  PUPDATE_ENTRY   pUpdate
    );

PLIST_ENTRY
dequeueAndCleanupUpdate(
    IN OUT  PLIST_ENTRY     pUpdateEntry
    );

BOOL
searchForOldUpdateEntriesAndCleanUp(
    IN      PSTR            pszAdapterName,
    IN      PUPDATE_ENTRY   pUpdateEntry OPTIONAL,
    IN      BOOL            fLookInRegistry
    );

BOOL
compareUpdateEntries(
    IN      PUPDATE_ENTRY   pUdapteEntry1,
    IN      PUPDATE_ENTRY   pUpdateEntry2
    );

BOOL
compareHostEntryAddrs(
    IN      PREGISTER_HOST_ENTRY    Addrs1,
    IN      PREGISTER_HOST_ENTRY    Addrs2,
    IN      DWORD                   Count
    );

BOOL
compareServerLists(
    IN  PIP_ARRAY List1,
    IN  PIP_ARRAY List2
    );

DWORD
GetRegistryValue(
    HKEY   KeyHandle,
    PSTR   ValueName,
    DWORD  ValueType,
    LPBYTE BufferPtr
    );


//
//  Jim routines
//

VOID
LogRegistration(
    IN      PUPDATE_ENTRY   pUpdateEntry,
    IN      DNS_STATUS      Status,
    IN      DWORD           UpType,
    IN      BOOL            fDeregister,
    IN      IP4_ADDRESS     DnsIp,
    IN      IP4_ADDRESS     UpdateIp
    );

VOID
AsyncLogUpdateEntry(
    IN      PSTR            pszHeader,
    IN      PUPDATE_ENTRY   pEntry
    );

#define ASYNCREG_UPDATE_ENTRY(h,p)      AsyncLogUpdateEntry(h,p)

VOID
DnsPrint_UpdateEntry(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN      PPRINT_CONTEXT  PrintContext,
    IN      PSTR            pszHeader,
    IN      PUPDATE_ENTRY   pUpdateEntry
    );

#if DBG
#define DnsDbg_UpdateEntry(h,p)     DnsPrint_UpdateEntry(DnsPR,NULL,h,p)
#else
#define DnsDbg_UpdateEntry(h,p)
#endif

PDNS_RECORD
CreateForwardRecords(
    IN      PUPDATE_ENTRY   pUpdateEntry,
    IN      BOOL            fUsePrimaryName
    );

PDNS_RECORD
CreatePtrRecord(
    IN      PSTR            pszHostName,
    IN      PSTR            pszDomainName,
    IN      IP4_ADDRESS     Ip4Addr,
    IN      DWORD           Ttl
    );

VOID
UpdatePtrRecords(
    IN OUT  PUPDATE_ENTRY   pUpdateEntry,
    IN      BOOL            fAdd
    );

VOID
SetUpdateStatus(
    IN OUT  PUPDATE_ENTRY   pUpdateEntry,
    IN      DNS_STATUS      Status,
    IN      BOOL            fPrimary
    );



//
//  Public functions
//

DNS_STATUS
WINAPI
DnsAsyncRegisterInit(
   IN   PSTR                pszRootRegKey
   )
/*++

Routine Description:

    Initialize asynchronous DNS registration.

    Process must call (one time) before calling DnsAsyncRegisterHostAddrs.

Arguments:

    None.

Return Value:

    DNS or Win32 error code.

--*/
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   disposition;
    DWORD   disallowUpdate;

    //
    // Initialize debug logging funtion
    //

    ASYNCREG_INIT();

    ASYNCREG_F1( "Inside function DnsAsyncRegisterInit" );
    ASYNCREG_TIME();
    ASYNCREG_F2( "   pszRootRegKey value set to %s", pszRootRegKey );

    //
    // g_dwVersion is only set once and this function must be called exactly
    // once until the corresponding TERM is called.
    //

    if ( ASYNC_INIT_CALLED() )
    {
        //
        // we are calling this more than once!
        //

        DNS_ASSERT(FALSE) ;
        return ERROR_INTERNAL_ERROR ;
    }
    else
    {
        DWORD sysVersion;

        if ( g_fRegistrationThreadRunning )
        {
            //
            // we encountered a previous problem while trying to stop
            // the registration thread, do not allow any further update
            // operations for this process!
            //

            DNS_ASSERT(FALSE) ;
            return ERROR_INTERNAL_ERROR ;
        }

        sysVersion = GetVersion();

        if ( sysVersion < 0x80000000 )
        {
            g_dwVersion = DHCPVER_WINNT;
        }
        else
        {
            g_dwVersion = DHCPVER_WIN95;
        }
    }

    //
    // if not supplied, use default
    //

    if ( !pszRootRegKey )
    {
        if ( g_dwVersion == DHCPVER_WINNT )
        {
            pszRootRegKey = DEFAULT_REG_LOCATION ;
        }
        else if ( g_dwVersion == DHCPVER_WIN95 )
        {
            pszRootRegKey = DEFAULT_REG_LOCATION_WIN95 ;
        }
        else
        {
            // we did not set g_dwVersion
            DNS_ASSERT(FALSE) ;
            pszRootRegKey = DEFAULT_REG_LOCATION ;
        }
    }

    //
    // Create private heap
    //

    g_DDNSHeap = HeapCreate( 0, INITIAL_DDNS_HEAP, 0 );
    if ( g_DDNSHeap == NULL )
    {
        g_DDNSHeap = GetProcessHeap();
        if ( g_DDNSHeap == NULL )
        {
            ASYNCREG_F1( "ERROR: DnsAsyncRegisterInit function failed to create heap" );
            Status = DNS_ERROR_NO_MEMORY;
            goto ErrorExit;
        }
    }

    //
    //  get registration configuration info
    //      - just insure we have the latest copy
    //
    //  DCR_FIX:  when available get latest copy from resolver
    //      does not need to be done on init, may be done on call
    //

    Reg_ReadGlobalsEx( 0, NULL );

    //
    // Open the registry location used to store this info
    //
    // Note that Win95 does not support WideCharacter types
    // The result is that we are forced to use RegCreateKeyExA for
    // both
    //

    Status = RegCreateKeyExA(
                      HKEY_LOCAL_MACHINE,
                      pszRootRegKey,
                      0,                         // reserved
                      DYN_DNS_ROOT_CLASS,
                      REG_OPTION_NON_VOLATILE,   // options
                      KEY_READ | KEY_WRITE,      // desired access
                      NULL,
                      &g_hKey,
                      &disposition
                      );

    if ( Status != NO_ERROR )
    {
        goto ErrorExit;
    }


    if ( !( g_hStopEvent = CreateEvent( NULL, TRUE, FALSE, NULL ) ) )
    {
        Status = GetLastError();
        goto ErrorExit;
    }

    if ( !( g_hThreadDeadEvent = CreateEvent( NULL, TRUE, FALSE, NULL ) ) )
    {
        Status = GetLastError();
        goto ErrorExit;
    }

    if ( !( g_hNewItemEvent = CreateEvent( NULL, TRUE, FALSE, NULL ) ) )
    {
        Status = GetLastError();
        goto ErrorExit;
    }

    EnterCriticalSection( &g_RegistrationListCS );
    InitializeListHead( &g_RegistrationList );
    LeaveCriticalSection( &g_RegistrationListCS );

    //
    // the following call is needed for determining if we are still in
    // boot time or not
    //

    g_dwTime = Dns_GetCurrentTimeInSeconds();
    g_fQuit = FALSE;
    g_fAtBoot = TRUE;
    g_fPurgeRegistrations = FALSE;
    g_fPurgeRegistrationsInitiated = FALSE;
    g_fNoMoreDDNSUpdates = FALSE;

    ResetAdaptersInRegistry();

    return NO_ERROR;

ErrorExit:

    if ( g_DDNSHeap &&
         g_DDNSHeap != GetProcessHeap() )
    {
        HeapDestroy( g_DDNSHeap );
        g_DDNSHeap = NULL;
    }

    if ( g_hStopEvent )
    {
        CloseHandle(g_hStopEvent);
        g_hStopEvent = NULL;
    }

    if ( g_hThreadDeadEvent )
    {
        CloseHandle(g_hThreadDeadEvent);
        g_hThreadDeadEvent = NULL;
    }

    if ( g_hNewItemEvent )
    {
        CloseHandle(g_hNewItemEvent);
        g_hNewItemEvent = NULL;
    }

    if ( g_hKey )
    {
        RegCloseKey( g_hKey );
        g_hKey = NULL;
    }

    CLEAR_ASYNC_INIT();  // reset this so we are no longer in use

    return(Status);
}




DNS_STATUS
WINAPI
DnsAsyncRegisterTerm(
   VOID
   )
/*++

Routine Description:

    Stop DNS registration.  Shutdown DNS registration thread.

    Initialization routine each process should call exactly on exit after
    using DnsAsyncRegisterHostAddrs. This will signal to us that if our
    thread is still trying to talk to a server, we'll stop trying.

Arguments:

    None.

Return Value:

    DNS or Win32 error code.

--*/
{
    DWORD waitResult;

    ASYNCREG_F1( "Inside function DnsAsyncRegisterTerm" );
    ASYNCREG_TIME();
    ASYNCREG_F1( "" );

    if ( ASYNC_INIT_CALLED() )
    {
        if ( g_hStopEvent &&
             g_fRegistrationThreadRunning )
        {
            SetEvent(g_hStopEvent);

            waitResult = WaitForSingleObject( g_hThreadDeadEvent,
                                                INFINITE );

            switch ( waitResult )
            {
                case WAIT_OBJECT_0 :
                    ASYNCREG_F1( "DNSAPI.DLL: Registration thread signaled it was finished" );
                    ASYNCREG_F1( "" );

                    break;

                case WAIT_TIMEOUT :
                    ASYNCREG_F1( "DNSAPI.DLL: Registration thread won't stop! " );
                    ASYNCREG_F1( "" );
                    DNS_ASSERT( FALSE );

                    break;
            }

            if ( g_fRegistrationThreadRunning )
            {
                ASYNCREG_F1( "DNSAPI.DLL: Registration thread wasn't stopped! " );
                ASYNCREG_F1( "" );

                DNS_ASSERT(FALSE) ;

                CLEAR_ASYNC_INIT();  // reset this so we are no longer in use

                return ERROR_INTERNAL_ERROR ;
            }
        }

        EnterCriticalSection( &g_RegistrationThreadCS );

        //
        // Close the thread handles if they aren't already.
        //
        if ( g_hRegistrationThread )
        {
            CloseHandle( g_hRegistrationThread );
            g_hRegistrationThread = NULL;
        }

        if ( g_hStopEvent )
        {
            CloseHandle(g_hStopEvent);
            g_hStopEvent = NULL;
        }

        if ( g_hThreadDeadEvent )
        {
            CloseHandle(g_hThreadDeadEvent);
            g_hThreadDeadEvent = NULL;
        }

        if ( g_hNewItemEvent )
        {
            CloseHandle(g_hNewItemEvent);
            g_hNewItemEvent = NULL;
        }

        g_fQuit = TRUE;

        if ( g_hKey )
        {
            RegCloseKey(g_hKey);
            g_hKey = NULL;
        }

        LeaveCriticalSection( &g_RegistrationThreadCS );

        Dns_TimeoutSecurityContextList( TRUE );

        CLEAR_ASYNC_INIT();  // reset this so we are no longer in use

        if ( g_DDNSHeap &&
             g_DDNSHeap != GetProcessHeap() )
        {
            HeapDestroy( g_DDNSHeap );
            g_DDNSHeap = NULL;
        }

        return NO_ERROR;
    }
    else
    {
        //
        // This is being called more than once! Or the Init function has
        // not yet been called!
        //

        DNS_ASSERT(FALSE) ;
        return ERROR_INTERNAL_ERROR ;
    }
}



DNS_STATUS
WINAPI
DnsRemoveRegistrations(
   VOID
   )
/*++

Routine Description:

    Remove DNS host registrations for this machine.

    This will be called by DHCP client on domain unjoin.  Removes DNS
    registrations for the box, then terminates the registration thread
    to disable further registrations.

    Registrations can only be reenabled by calling DnsAsyncRegisterInit()
    again.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PLIST_ENTRY pListEntry;
    PLIST_ENTRY pTopOfList;

    ASYNCREG_F1( "Inside function DnsRemoveRegistrations" );
    ASYNCREG_TIME();
    DNSDBG( TRACE, ( "DnsRemoveRegistrations()\n" ));

    DNS_ASSERT(ASYNC_INIT_CALLED());  // make sure init was called
    if ( !ASYNC_INIT_CALLED() )
    {
        ASYNCREG_F1( "DnsAsyncRemoveRegistrations returning ERROR_SERVICE_NOT_ACTIVE" );
        ASYNCREG_F1( "This is an error in DHCP client code, it forgot to call DnsAsyncRegisterInit()" );
        return ERROR_SERVICE_NOT_ACTIVE;
    }

    //
    // Set a global flag to disable any further adapter registration calls
    //

    g_fNoMoreDDNSUpdates = TRUE;

    //
    // Get the Registration list lock
    //
    EnterCriticalSection( &g_RegistrationListCS );

    //
    // Mark any and all adapter registration information in the registry
    // as non-registered. These will be later interpreted as non-existant
    // and deregistered by the RegistrationThread.
    //
    ResetAdaptersInRegistry();

    //
    // Walk the list of pending update entries and clear out the
    // non-neccessary updates.
    //

    pTopOfList = &g_RegistrationList;
    pListEntry = pTopOfList->Flink;

    while ( pListEntry != pTopOfList )
    {
        if ( ((PUPDATE_ENTRY) pListEntry)->SignatureTop !=
             DNS_SIG_TOP ||
             ((PUPDATE_ENTRY) pListEntry)->SignatureBottom !=
             DNS_SIG_BOTTOM )
        {
            //
            // Someone trashed our registration list!
            //
            DNS_ASSERT( FALSE );

            //
            // We'll reset it and try to move on . . .
            //
            InitializeListHead( &g_RegistrationList );
            pTopOfList = &g_RegistrationList;
            pListEntry = pTopOfList->Flink;
            continue;
        }

        if ( !((PUPDATE_ENTRY) pListEntry)->fRemove )
        {
            //
            // There is an update entry in the registration list
            // that has not yet been processed. Since it is an
            // add update, we'll blow it away.
            //

            pListEntry = dequeueAndCleanupUpdate( pListEntry );
            continue;
        }
        else
        {
            ((PUPDATE_ENTRY) pListEntry)->fNewElement = TRUE;
            ((PUPDATE_ENTRY) pListEntry)->fRegisteredFWD = FALSE;
            ((PUPDATE_ENTRY) pListEntry)->fRegisteredPRI = FALSE;
            ((PUPDATE_ENTRY) pListEntry)->fRegisteredPTR = FALSE;
            ((PUPDATE_ENTRY) pListEntry)->fDisableErrorLogging = FALSE;
            ((PUPDATE_ENTRY) pListEntry)->RetryCount = 2;
            ((PUPDATE_ENTRY) pListEntry)->RetryTime =
                Dns_GetCurrentTimeInSeconds();

            pListEntry = pListEntry->Flink;
        }
    }

    LeaveCriticalSection( &g_RegistrationListCS );

    g_fPurgeRegistrations = TRUE;

    //
    //  start async registration thread if not started
    //

    alertOrStartRegistrationThread();

    //
    //  wait for async registration thread to terminate
    //
    //  however we'll bag it after a few minutes -- a robustness check
    //  to avoid long hang;  Generally the machine will be rebooted
    //  so failure to cleanup the list and terminate is not critical;
    //  Registrations will have to be cleaned up by admin action or
    //  aging on the DNS server
    //

#if DBG
    {
        DWORD   waitResult;
        waitResult = WaitForSingleObject(
                            g_hThreadDeadEvent,
                            REMOVE_REGISTRATION_WAIT_LIMIT );
        if ( waitResult != WAIT_OBJECT_0 )
        {
            ASYNCREG_F1(
                "ERROR:  RemoveRegistration() wait expired before async thread\n"
                "\ttermination!\n" );
        }
    }
#else
    WaitForSingleObject( g_hThreadDeadEvent, REMOVE_REGISTRATION_WAIT_LIMIT );
#endif

    return NO_ERROR;
}



DNS_STATUS
WINAPI
privateAsyncRegisterHostAddrs(
    IN      PSTR                    pszAdapterName,
    IN      PSTR                    pszHostName,
    IN      PREGISTER_HOST_ENTRY    pHostAddrs,
    IN      DWORD                   dwHostAddrCount,
    IN      PIP4_ADDRESS            pipDnsServerList,
    IN      DWORD                   dwDnsServerCount,
    IN      PSTR                    pszDomainName,
    IN      PREGISTER_HOST_STATUS   pRegisterStatus,
    IN      DWORD                   dwTTL,
    IN      DWORD                   dwFlags
    )
/*++

Routine Description:

    Registers host address with DNS server.
    This is called by DHCP client to register a particular IP.

    This is the working UTF8 version of the
    DnsAsyncRegisterHostAddrs() unicode routine actually called by
    the DHCP client.

Arguments:


Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DWORD               status = NO_ERROR;
    PUPDATE_ENTRY       pupEntry = NULL;
    PSTR                padapterDN = NULL;
    PSTR                pprimaryDN = NULL;
    REG_UPDATE_INFO     updateInfo;
    BOOL                fcleanupUpdateInfo = FALSE;


    ASYNCREG_F1( "Inside function privateDnsAsyncRegisterHostAddrs, parameters are:" );
    ASYNCREG_F2( "    pszAdapterName : %s", pszAdapterName );
    ASYNCREG_F2( "    pszHostName    : %s", pszHostName );
    ASYNCREG_F2( "    dwHostAddrCount  : %d", dwHostAddrCount );
    DNSLOG_HOST_ENTRYS( dwHostAddrCount, pHostAddrs );
    ASYNCREG_F2( "    dwDnsServerCount : %d", dwDnsServerCount );
    if ( dwDnsServerCount && pipDnsServerList )
    {
        DNSLOG_PIP_ADDRESS( dwDnsServerCount, pipDnsServerList );
    }
    ASYNCREG_F2( "    pszDomainName  : %s", pszDomainName );
    ASYNCREG_F2( "    dwTTL            : %d", dwTTL );
    ASYNCREG_F2( "    dwFlags          : %d", dwFlags );
    ASYNCREG_F1( "" );
    ASYNCREG_TIME();

    DNSDBG( TRACE, (
        "privateAsyncRegisterHostAddrs()\n"
        "\tadapter name     = %s\n"
        "\thost name        = %s\n"
        "\tadapter domain   = %s\n"
        "\tpHostAddrs       = %p\n"
        "\tAddrCount        = %d\n"
        "\tpDNSServers      = %p\n"
        "\tServerCount      = %d\n"
        "\tFlags            = %08x\n",
        pszAdapterName,
        pszHostName,
        pszDomainName,
        pHostAddrs,
        dwHostAddrCount,
        pipDnsServerList,
        dwDnsServerCount,
        dwTTL ));

    //
    // first things first, need to inform underlying code that something
    // has changed in the list of net adapters. Glenn is going to be called
    // now so that he can re read the registry (or do any appropriate query)
    // to now note the changed state.
    //

    if ( !(dwFlags & DYNDNS_DEL_ENTRY) )
    {
        DnsNotifyResolver( 0, NULL );
    }

    DNS_ASSERT(ASYNC_INIT_CALLED());  // make sure init was called
    if ( !ASYNC_INIT_CALLED() )
    {
        DNSDBG( ANY, (
            "ERROR:  AsyncRegisterHostAddrs called before Init routine!!!\n" ));
        status = ERROR_SERVICE_NOT_ACTIVE;
        goto Exit;
    }

    if ( g_fNoMoreDDNSUpdates )
    {
        DNSDBG( ANY, (
            "ERROR:  AsyncRegisterHostAddrs called after RemoveRegistrations()!!!\n" ));
        status = ERROR_SERVICE_NOT_ACTIVE;
        goto Exit;
    }

    //
    //  Validate parameters
    //

    if ( !pszAdapterName || !(*pszAdapterName) )
    {
        DNSDBG( ANY, ( "ERROR:  RegisterHostAddrs invalid adaptername!\n" ));
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }
    if ( ( !pszHostName || !(*pszHostName) ) &&
         !( dwFlags & DYNDNS_DEL_ENTRY ) )
    {
        DNSDBG( ANY, ( "ERROR:  RegisterHostAddrs invalid hostname!\n" ));
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }
    if ( dwHostAddrCount && !pHostAddrs )
    {
        DNSDBG( ANY, ( "ERROR:  RegisterHostAddrs invalid host addresses!\n" ));
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    //
    //  get adapter update configuration
    //

    status = Reg_ReadUpdateInfo(
                pszAdapterName,
                & updateInfo );
    if ( status != ERROR_SUCCESS )
    {
        DNSDBG( INIT, (
            "Update registry read failure %d\n",
            status ));
        goto Exit;
    }
    fcleanupUpdateInfo = TRUE;


    //
    //  skip WAN, if not doing WAN by policy
    //

    if ( (dwFlags & DYNDNS_REG_RAS) && !g_RegisterWanAdapters )
    {
        ASYNCREG_F1( "privateAsyncRegisterHostAddrs returning NO_ERROR, because WAN adapter registrations are disabled" );
        goto NoActionExit;
    }

    //
    //  policy DNS servers, override passed in list
    //

    if ( updateInfo.pDnsServerArray )
    {
        pipDnsServerList = updateInfo.pDnsServerArray->AddrArray;
        dwDnsServerCount = updateInfo.pDnsServerArray->AddrCount;
    }

    //
    //  must have DNS servers to update adapter
    //      - don't update IP on one interface starting with DNS servers
    //      from another
    //

    if ( dwDnsServerCount && !pipDnsServerList )
    {
        ASYNCREG_F1( "privateAsyncRegisterHostAddrs returning ERROR_INVALID_PARAMETER" );
        ASYNCREG_F1( "ERROR_INVALID_PARAMETER reason 4" );
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }
    if ( ! dwDnsServerCount &&
         ! (dwFlags & DYNDNS_DEL_ENTRY) )
    {
        ASYNCREG_F1( "privateAsyncRegisterHostAddrs returning NO_ERROR, because adapter does not have any DNS servers configured" );
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    //
    //  no update on adpater => delete outstanding updates
    //      note, we do before delete check below for event check
    //

    if ( !updateInfo.fRegistrationEnabled )
    {
        ASYNCREG_F1( "privateAsyncRegisterHostAddrs returning NO_ERROR, because adapter is disabled" );

        if ( pRegisterStatus )
        {
            pRegisterStatus->dwStatus = NO_ERROR;
            SetEvent( pRegisterStatus->hDoneEvent );
        }
        if ( searchForOldUpdateEntriesAndCleanUp(
                    pszAdapterName,
                    NULL,
                    TRUE ) )
        {
            goto CheckThread;
        }
        status = NO_ERROR;
        goto Exit;
        //goto NoActionExit;
    }

    //
    //  delete update -- cleanup and delete
    //      - delete outstanding update in list
    //      - cleanup registry
    //      - do delete
    //

    if ( dwFlags & DYNDNS_DEL_ENTRY )
    {
        if ( searchForOldUpdateEntriesAndCleanUp(
                pszAdapterName,
                NULL,
                TRUE ) )
        {
            goto CheckThread;
        }
    }

    //
    //  limit IP registration count
    //      if doing registration and no addresses -- bail
    //

    if ( updateInfo.RegistrationMaxAddressCount < dwHostAddrCount )
    {
        dwHostAddrCount = updateInfo.RegistrationMaxAddressCount;
        ASYNCREG_F2(
            "Restricting adapter registration to the first %d addresses",
            dwHostAddrCount );
    }
    if ( dwHostAddrCount == 0 )
    {
        ASYNCREG_F1( "privateAsyncRegisterHostAddrs returning NO_ERROR" );
        ASYNCREG_F1( "We are done, there are no addresses to register in DNS" );
        goto NoActionExit;
    }

    //
    //  no\empty host name or zero IP => bogus
    //

    if ( !pszHostName ||
         !(*pszHostName) ||
         ( dwHostAddrCount && ( pHostAddrs[0].Addr.ipAddr == 0 ) ) )
    {
        ASYNCREG_F1( "privateAsyncRegisterHostAddrs returning ERROR_INVALID_PARAMETER" );
        ASYNCREG_F1( "ERROR_INVALID_PARAMETER reason 5" );
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    //
    //  determine domain names to update
    //      - get PDN
    //      - adapter name
    //          - none if adapter name registration off
    //          - else check policy override
    //          - else name passed in
    //          - but treat empty as NULL
    //

    pprimaryDN = updateInfo.pszPrimaryDomainName;

    if ( updateInfo.fRegisterAdapterName )
    {
        if ( updateInfo.pszAdapterDomainName )
        {
            padapterDN = updateInfo.pszAdapterDomainName;
        }
        else
        {
            padapterDN = pszDomainName;
        }
        if ( padapterDN &&
             !(*padapterDN) )
        {
            padapterDN = NULL;
        }
    }

    //
    //  no domains => nothing to register, we're done
    //

    if ( !padapterDN &&
         !pprimaryDN )
    {
        ASYNCREG_F1( "privateAsyncRegisterHostAddrs returning ERROR_SUCCESS" );
        ASYNCREG_F1( "no adapter name and no PDN" );
        goto NoActionExit;
    }

    //  if adapter name same as PDN -- just one update

    if ( pprimaryDN &&
         padapterDN &&
         Dns_NameCompare_UTF8( pprimaryDN, padapterDN ) )
    {
        padapterDN = NULL;
    }

    //  build update

    status = AllocateUpdateEntry(
                    pszAdapterName,
                    pszHostName,
                    padapterDN,
                    pprimaryDN,
                    updateInfo.pmszAlternateNames,
                    dwHostAddrCount,
                    pHostAddrs,
                    dwDnsServerCount,
                    pipDnsServerList,
                    0,      // No particular server IP at this time
                    0,      // No particular server IP at this time
                    (dwTTL == 0xffffffff || dwTTL == 0)
                            ? g_RegistrationTtl
                            : dwTTL,
                    dwFlags,
                    0,
                    Dns_GetCurrentTimeInSeconds(),
                    pRegisterStatus,
                    &pupEntry );

    if ( status != NO_ERROR )
    {
        goto Exit;
    }

    //
    // More WAN adapter hacks . . .
    // If DDNS is not disabled for WAN adapters, then the default
    // behavior for logging update events is disabled on these type
    // adapters. There is a registry key that can turn on the logging
    // of WAN adapter updates if such a user is interested. We configure
    // those settings here.
    //

    if ( dwFlags & DYNDNS_REG_RAS )
    {
        //pupEntry->fDisableErrorLogging = !g_EnableWanDynamicUpdateEventLog;
        pupEntry->fDisableErrorLogging = TRUE;
    }

    //
    // When adding an entry to the registration list, first walk the
    // list to look for any other updates for the same adapter.
    // If there is already an add update in the list, blow it away.
    // If there is already a delete update in the list with the same
    // information, blow it away.
    //
    // Then put update into registration list.
    //

    searchForOldUpdateEntriesAndCleanUp(
        pupEntry->AdapterName,
        pupEntry,
        FALSE );

    //
    // Since we are about to queue up an update entry for a given
    // adapter, we need to mark any possible previous registration
    // information that could be in the registry as pending. This
    // marking will prevent the old data from being incorrectly
    // queued as a disabled adapter if any errors are encountered
    // on the update attempts. i.e failed update attempts on a given
    // adapter should not be regarded as a disabled adapter that needs
    // to have it's stale records cleaned up.
    //
    MarkAdapterAsPendingUpdate( pszAdapterName );

    EnterCriticalSection( &g_RegistrationListCS );
    InsertTailList( &g_RegistrationList, (PLIST_ENTRY) pupEntry );
    LeaveCriticalSection( &g_RegistrationListCS );

CheckThread:

    //
    //  DCR:  do we need cleanup if thread is dead?
    //

    alertOrStartRegistrationThread();
    status = NO_ERROR;
    goto Exit;


NoActionExit:

    //
    //  exit for no-action no-error exit
    //

    DNSDBG( UPDATE, (
        "privateAsyncRegisterHostAddrs()\n"
        "\tno-update no-error exit\n" ));

    status = NO_ERROR;

    if ( pRegisterStatus )
    {
        pRegisterStatus->dwStatus = NO_ERROR;
        SetEvent( pRegisterStatus->hDoneEvent );
    }

Exit:

    //
    //  cleanup allocated update info
    //

    if ( fcleanupUpdateInfo )
    {
        Reg_FreeUpdateInfo(
            &updateInfo,
            FALSE           // no free struct, it's on stack
            );
    }

    DNSDBG( UPDATE, (
        "Leaving privateAsyncRegisterHostAddrs()\n"
        "\tstatus = %d\n",
        status ));

    return( status );
}



DNS_STATUS
WINAPI
DnsAsyncRegisterHostAddrs(
    IN  PWSTR                   pwsAdapterName,
    IN  PWSTR                   pwsHostName,
    IN  PREGISTER_HOST_ENTRY    pHostAddrs,
    IN  DWORD                   dwHostAddrCount,
    IN  PIP_ADDRESS             pipDnsServerList,
    IN  DWORD                   dwDnsServerCount,
    IN  PWSTR                   pwsDomainName,
    IN  PREGISTER_HOST_STATUS   pRegisterStatus,
    IN  DWORD                   dwTTL,
    IN  DWORD                   dwFlags
    )
/*++

Routine Description:

    Registers host address with DNS server.

    This is called by DHCP client to register a particular IP.

Arguments:

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    CHAR    adapterName[2*MAX_PATH];
    CHAR    hostName[ DNS_MAX_LABEL_BUFFER_LENGTH ];
    CHAR    domainName[ DNS_MAX_NAME_BUFFER_LENGTH ];
    PSTR    padapterName = NULL;
    PSTR    phostName = NULL;
    PSTR    pdomainName = NULL;

    DNSDBG( TRACE, (
        "DnsAsyncRegisterHostAddrs()\n"
        "\tadapter name     = %S\n"
        "\thost name        = %S\n"
        "\tadapter domain   = %S\n"
        "\tpHostAddrs       = %p\n",
        pwsAdapterName,
        pwsHostName,
        pwsDomainName,
        pHostAddrs
        ));
        
    //
    //  convert unicode strings to UTF8
    //

    if ( pwsAdapterName )
    {
        Dns_NameCopy(
            adapterName,
            NULL,
            (PCHAR) pwsAdapterName,
            0,
            DnsCharSetUnicode,
            DnsCharSetUtf8 );

        padapterName = adapterName;
    }

    if ( pwsHostName )
    {
        Dns_NameCopy(
            hostName,
            NULL,
            (PCHAR) pwsHostName,
            0,
            DnsCharSetUnicode,
            DnsCharSetUtf8 );

        phostName = hostName;
    }

    if ( pwsDomainName )
    {
        Dns_NameCopy(
            domainName,
            NULL,
            (PCHAR) pwsDomainName,
            0,
            DnsCharSetUnicode,
            DnsCharSetUtf8 );

        pdomainName = domainName;
    }

    return privateAsyncRegisterHostAddrs(
                padapterName,
                phostName,
                pHostAddrs,
                dwHostAddrCount,
                pipDnsServerList,
                dwDnsServerCount,
                pdomainName,
                pRegisterStatus,
                dwTTL,
                dwFlags );
}



//
//  Async registration utilities
//

PSTR
CreateNarrowStringCopy(
    IN      PSTR            pString
    )
{
    PSTR    pnew = NULL;

    if ( pString )
    {
        pnew = HeapAlloc(
                    g_DDNSHeap,
                    0,
                    strlen(pString) + 1 );
        if ( pnew )
        {
            strcpy( pnew, pString );
        }
    }

    return  pnew;
}

VOID
PrivateHeapFree(
    IN      PVOID           pVal
    )
{
    if ( pVal )
    {
        HeapFree(
             g_DDNSHeap,
             0,
             pVal );
    }
}



DNS_STATUS
AllocateUpdateEntry(
    IN  PSTR                    AdapterName,
    IN  PSTR                    HostName,
    IN  PSTR                    DomainName,
    IN  PSTR                    PrimaryDomainName,
    IN  PSTR                    AlternateNames,
    IN  DWORD                   HostAddrCount,
    IN  PREGISTER_HOST_ENTRY    HostAddrs,
    IN  DWORD                   DnsServerCount,
    IN  PIP_ADDRESS             DnsServerList,
    IN  IP_ADDRESS              SentUpdateToIp,
    IN  IP_ADDRESS              SentPriUpdateToIp,
    IN  DWORD                   TTL,
    IN  DWORD                   Flags,
    IN  DWORD                   RetryCount,
    IN  DWORD                   RetryTime,
    IN  PREGISTER_HOST_STATUS   Registerstatus,
    OUT PUPDATE_ENTRY *         ppUpdateEntry
    )
/*++

Routine Description:

    Create update info blob.

Arguments:

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PUPDATE_ENTRY   pupEntry = NULL;
    DWORD           status = ERROR_SUCCESS;
    PSTR            ptempDomain = DomainName;
    PSTR            ptempPrimaryDomain = PrimaryDomainName;

    if ( ptempDomain && !(*ptempDomain) )
    {
        ptempDomain = NULL;
    }
    if ( ptempPrimaryDomain && !(*ptempPrimaryDomain) )
    {
        ptempPrimaryDomain = NULL;
    }
    if ( AdapterName && !(*AdapterName) )
    {
        AdapterName = NULL;
    }
    if ( HostName && !(*HostName) )
    {
        HostName = NULL;
    }

    DNSDBG( TRACE, ( "AllocateUpdateEntry()\n" ));
    DNSDBG( DHCP, (
        "AllocateUpdateEntry()\n"
        "\tAdapterName          = %s\n"
        "\tHostName             = %s\n"
        "\tPrimaryDomain        = %s\n"
        "\tAdapterDomain        = %s\n"
        "\tAlternateNames       = %s\n"
        "\tHostAddrCount        = %d\n"
        "\tpHostAddrs           = %p\n"
        "\tTTL                  = %d\n"
        "\tFlags                = %08x\n"
        "\tHostAddrCount        = %d\n"
        "\tTime                 = %d\n",
        AdapterName,
        HostName,
        PrimaryDomainName,
        DomainName,
        AlternateNames,
        HostAddrCount,
        HostAddrs,
        TTL,
        Flags,
        RetryTime
        ));

    if ( !AdapterName ||
         !HostName ||
         !HostAddrCount )
    {
        ASYNCREG_F1( "AllocateUpdateEntry returing error : ERROR_INVALID_PARAMETER" );
        ASYNCREG_F1( "" );
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    pupEntry = PHEAP_ALLOC_ZERO( sizeof(UPDATE_ENTRY) );
    if ( !pupEntry )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Exit;
    }

    InitializeListHead( &(pupEntry->List) );

    pupEntry->SignatureTop = DNS_SIG_TOP;
    pupEntry->SignatureBottom = DNS_SIG_BOTTOM;

    //
    //  copy strings
    //

    pupEntry->AdapterName = CreateNarrowStringCopy( AdapterName );
    if ( !pupEntry->AdapterName )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Exit;
    }
    if ( HostName )
    {
        pupEntry->HostName = CreateNarrowStringCopy( HostName );
        if ( !pupEntry->HostName )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Exit;
        }
    }
    if ( ptempDomain )
    {
        pupEntry->DomainName = CreateNarrowStringCopy( ptempDomain );
        if ( !pupEntry->DomainName )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Exit;
        }
    }
    if ( ptempPrimaryDomain )
    {
        pupEntry->PrimaryDomainName = CreateNarrowStringCopy( ptempPrimaryDomain );
        if ( !pupEntry->PrimaryDomainName )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Exit;
        }
    }
    if ( AlternateNames )
    {
        pupEntry->AlternateNames = MultiSz_Copy_A( AlternateNames );
        if ( !pupEntry->AlternateNames )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Exit;
        }
    }

    if ( HostAddrCount )
    {
        pupEntry->HostAddrs = PHEAP_ALLOC( sizeof(REGISTER_HOST_ENTRY) * HostAddrCount );

        if ( !pupEntry->HostAddrs )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Exit;
        }
        memcpy(
            pupEntry->HostAddrs,
            HostAddrs,
            sizeof(REGISTER_HOST_ENTRY) * HostAddrCount );
    }
    pupEntry->HostAddrCount = HostAddrCount;

    if ( DnsServerCount )
    {
        pupEntry->DnsServerList = Dns_BuildIpArray( DnsServerCount,
                                                        DnsServerList );
        if ( !pupEntry->DnsServerList )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Exit;
        }
    }

    pupEntry->SentUpdateToIp = SentUpdateToIp;
    pupEntry->SentPriUpdateToIp = SentPriUpdateToIp;
    pupEntry->pRegisterStatus = Registerstatus;
    pupEntry->TTL = TTL;
    pupEntry->Flags = Flags;
    pupEntry->fRemove = Flags & DYNDNS_DEL_ENTRY ? TRUE : FALSE;
    pupEntry->fNewElement = TRUE;
    pupEntry->RetryCount = RetryCount;
    pupEntry->RetryTime = RetryTime;

Exit:

    if ( status!=ERROR_SUCCESS && pupEntry )
    {
        FreeUpdateEntry( pupEntry );
        pupEntry = NULL;
    }

    *ppUpdateEntry = pupEntry;

    return (status);
}



VOID
FreeUpdateEntry(
    IN OUT  PUPDATE_ENTRY   pUpdateEntry
    )
/*++

Routine Description:

    Free update blob entry.

Arguments:

    pUpdateEntry -- update entry blob to free

Return Value:

    None

--*/
{
    DNSDBG( TRACE, (
        "FreeUpdateEntry( %p )\n",
        pUpdateEntry ));

    //
    //  deep free the update entry
    //

    if ( pUpdateEntry )
    {
        PrivateHeapFree( pUpdateEntry->AdapterName );
        PrivateHeapFree( pUpdateEntry->HostName );
        PrivateHeapFree( pUpdateEntry->DomainName );
        PrivateHeapFree( pUpdateEntry->PrimaryDomainName );
        PrivateHeapFree( pUpdateEntry->AlternateNames );
        PrivateHeapFree( pUpdateEntry->HostAddrs );

        //  note that server list is created by Dns_BuildIpArray()
        //  (uses dnslib heap) so must free by Dns_Free()

        Dns_Free( pUpdateEntry->DnsServerList );

        PrivateHeapFree( pUpdateEntry );
    }
}



VOID
FreeUpdateEntryList(
    IN OUT  PLIST_ENTRY     pUpdateEntry
    )
/*++

Routine Description:

    Free all updates in update list.

Arguments:

    pUpdateEntry -- update list head

Return Value:

    None

--*/
{
    PLIST_ENTRY     pentry = NULL;

    DNSDBG( TRACE, (
        "FreeUpdateEntryList( %p )\n",
        pUpdateEntry ));

    while ( !IsListEmpty( pUpdateEntry ) )
    {
        pentry = RemoveHeadList( pUpdateEntry );
        if ( pentry )
        {
            FreeUpdateEntry( (PUPDATE_ENTRY) pentry );
        }
    }
}



DWORD
WINAPI
RegistrationThread(
    VOID
    )
/*++

Routine Description:

    Asynchronous registration thread.

    This thread does actual updates, and stays alive until they are
    completed, allowing registration API calls to return.

    This thread is created at boot time as soon as the first register
    request comes in. The thread simply waits for a certain amount of time
    given by boot time or be signaled by DnsAsyncRegisterHostEntries.

    This function collects all the requests and does the appropriate
    aggregation of requests and sends off the modify/add/delete commands
    to the DNS Server. When the call is successful, it makes a note of
    this in the registry

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DWORD           waitResult;
    PUPDATE_ENTRY   pupEntry = NULL;
    HANDLE          handle[2];
    DWORD           status = NO_ERROR;
    DWORD           dwWaitTime = g_dwBootTime;
    DWORD           rcode = 0;

    if ( !g_hKey )
    {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Note that this thread is running by setting a global flag
    //

    g_fRegistrationThreadRunning = TRUE;

    //
    // for use at a subsequent WFMO
    //
    handle[0] = g_hStopEvent;
    handle[1] = g_hNewItemEvent;

    //
    // Check to see this thread is at boot time or not.
    // At boot time we simply wait for BOOT_TIME, otherwise move on.
    // The global g_fAtBoot is not protected by critical section because
    // only one thread accesses it at any time.
    //

    if ( !g_fAtBoot || g_fPurgeRegistrations )
    {
        dwWaitTime = 0;
    }

    dwWaitTime *= 1000;

    waitResult = WaitForSingleObject( g_hStopEvent,
                                        dwWaitTime );

    switch( waitResult )
    {
        case WAIT_OBJECT_0 :
            //
            // kill event
            //
            goto CleanUpAndDie;

        case WAIT_TIMEOUT :
            //
            // Means we can start processing the elements in the queue now
            //
            break;
    }

    //
    //  loop through update list, doing any update
    //      - do new updates
    //      - do retries that have reached retry time
    //      - when list empty, terminate thread
    //

    while ( 1 )
    {
        //  if empty list and not-booting or purging
        //      => get out

        EnterCriticalSection( &g_RegistrationListCS );

        if ( IsListEmpty( &g_RegistrationList ) &&
                ! g_fAtBoot &&
                ! g_fPurgeRegistrations )
        {
            LeaveCriticalSection( &g_RegistrationListCS );
            break;
        }

        //
        //  get "updateable" update from list (if any)
        //      0 -- new update, or retry update ready
        //      1 -- retry update, not yet ready
        //      -1 -- list empty
        //

        rcode = GetNextUpdateEntryFromList( &pupEntry,
                                            &dwWaitTime );

        if ( &g_RegistrationList == (PLIST_ENTRY) pupEntry )
        {
            DNS_ASSERT(&g_RegistrationList != (PLIST_ENTRY) pupEntry);

            LeaveCriticalSection( &g_RegistrationListCS );
            goto CleanUpAndDie;
        }

        LeaveCriticalSection( &g_RegistrationListCS );

        //
        //  rcode==0 -- new update in list
        //
        //  DCR_QUESTION:  not clear that this terminates updates in the
        //                  purging updates case
        //

        if ( rcode == 0 )
        {
            //
            // See if we have been signaled to stop running . . .
            //

            waitResult = WaitForMultipleObjects(
                                2,
                                handle,
                                FALSE,
                                1 ); // a very small wait
            switch( waitResult )
            {
                case WAIT_OBJECT_0 :
                    //
                    // kill event
                    //
                    FreeUpdateEntry( pupEntry );
                    goto CleanUpAndDie;

                default :
                    //
                    // Keep going, process next item in registration list
                    //
                    break;
            }

            ProcessUpdateEntry( pupEntry, g_fPurgeRegistrations );
            continue;
        }

        //
        //  rcode==1 -- update needs retry
        //

        else if ( rcode == 1 &&
                  ! g_fAtBoot &&
                  ! g_fPurgeRegistrations )
        {
            waitResult = WaitForMultipleObjects(
                                2,
                                handle,
                                FALSE,
                                dwWaitTime );
            switch( waitResult )
            {
                case WAIT_OBJECT_0 :
                    //
                    // kill event
                    //
                    goto CleanUpAndDie;

                case WAIT_OBJECT_0 + 1 :
                    //
                    // new item has been added to registration list
                    //
                    break;

                case WAIT_TIMEOUT :
                    //
                    // process next item in registration list
                    //
                    break;
            }
            continue;
        }

        //
        //  rcode == (-1) -- list empty
        //      OR
        //  rcode == (1) -- reties, not booting or purging
        //

        else
        {
            if ( !g_fAtBoot && !g_fPurgeRegistrations )
            {
                goto CleanUpAndDie;
            }

            if ( g_fPurgeRegistrationsInitiated )
            {
                goto CleanUpAndDie;
            }

            if ( g_fPurgeRegistrations )
            {
                ResetAdaptersInRegistry();
            }

            //
            // Remove any adapter configurations from the registry
            // that were not processed. Do this by attempting to
            // remove the related DNS records from the DNS server(s).
            //
            DeregisterUnusedAdapterInRegistry( g_fPurgeRegistrations );

            if ( g_fPurgeRegistrations )
            {
                g_fPurgeRegistrationsInitiated = TRUE;
            }

            g_fAtBoot = FALSE;

            continue;
        }
    }


CleanUpAndDie :

    ASYNCREG_F1( "RegistrationThread - terminating" );
    ASYNCREG_F1( "" );

    EnterCriticalSection( &g_RegistrationThreadCS );
    EnterCriticalSection( &g_RegistrationListCS );

    g_fQuit = TRUE;
    g_fAtBoot = FALSE;
    g_fPurgeRegistrations = FALSE;
    g_fPurgeRegistrationsInitiated = FALSE;

    //
    // Blow away the registration list
    //
    FreeUpdateEntryList( &g_RegistrationList );
    InitializeListHead( &g_RegistrationList );

    LeaveCriticalSection( &g_RegistrationListCS );

    //
    // Blow away any cached security handles
    //
    Dns_TimeoutSecurityContextList( TRUE );


    //
    // Close the thread handle.
    //
    if ( g_hRegistrationThread )
    {
        CloseHandle( g_hRegistrationThread );
        g_hRegistrationThread = NULL;
    }

    //
    // Note that this thread is NOT running by setting a global flag
    //

    g_fRegistrationThreadRunning = FALSE;

    //
    // Now signal that we've finished
    //

    ASYNCREG_F1( "RegistrationThread - Signaling ThreadDeadEvent" );
    ASYNCREG_F1( "" );

    //  clear purge incase of later restart
    //g_fPurgeRegistrations = FALSE;
    // currently must go through Init routine which clears this flag

    SetEvent( g_hThreadDeadEvent );

    LeaveCriticalSection( &g_RegistrationThreadCS );

    ASYNCREG_F1( "RegistrationThread - Finished" );
    ASYNCREG_F1( "" );

    return NO_ERROR;
}


VOID
WriteUpdateEntryToRegistry(
    IN      PUPDATE_ENTRY   pUpdateEntry
    )
{
    HKEY   hAdapterKey = NULL;
    DWORD  disposition;
    DWORD  status = ERROR_SUCCESS;
    DWORD  dwRegistered = 0;
    DWORD  dwFlags = 0;
    WCHAR  uName[ DNS_MAX_NAME_BUFFER_LENGTH ];

    ASYNCREG_UPDATE_ENTRY(
        "Inside function WriteUpdateEntryToRegistry",
        pUpdateEntry );

    DNSDBG( TRACE, (
        "WriteUpdateEntryToRegistry( %p )\n",
        pUpdateEntry ));

    //
    //  write only add update
    //
    //  remove's should not be non-volatile as don't know anything
    //      about state when come back up
    //

    if ( !pUpdateEntry->fRemove )
    {
        if ( pUpdateEntry->fRegisteredFWD )
        {
            dwFlags |= REGISTERED_FORWARD;
        }
        if ( pUpdateEntry->fRegisteredPRI )
        {
            dwFlags |= REGISTERED_PRIMARY;
        }
        if ( pUpdateEntry->fRegisteredPTR )
        {
            dwFlags |= REGISTERED_POINTER;
        }

        if ( dwFlags )
        {
            dwRegistered = 1;
        }

        status = RegCreateKeyExA ( g_hKey,
                                   pUpdateEntry->AdapterName,
                                   0,
                                   ADAPTER_NAME_CLASS,
                                   REG_OPTION_NON_VOLATILE,   // options
                                   KEY_READ | KEY_WRITE, // desired access
                                   NULL,
                                   &hAdapterKey,
                                   &disposition );
        if ( status )
        {
            goto Exit;
        }

        Dns_Utf8ToUnicode( pUpdateEntry->HostName,
                           strlen( pUpdateEntry->HostName ),
                           uName,
                           256 );

        status = RegSetValueExW( hAdapterKey,
                                 REGISTERED_HOST_NAME_W,
                                 0,
                                 REG_SZ,
                                 (LPBYTE)uName,
                                 ( wcslen( uName )
                                   + 1 ) * sizeof(WCHAR) );

        if ( status )
        {
            goto Exit;
        }

        if ( pUpdateEntry->DomainName &&
             pUpdateEntry->fRegisteredFWD )
        {
          Dns_Utf8ToUnicode( pUpdateEntry->DomainName,
                             strlen( pUpdateEntry->DomainName ),
                             uName,
                             256 );

          status = RegSetValueExW( hAdapterKey,
                                   REGISTERED_DOMAIN_NAME_W,
                                   0,
                                   REG_SZ,
                                   (LPBYTE)uName,
                                   ( wcslen( uName )
                                     + 1 ) * sizeof(WCHAR) );

          if ( status )
          {
              goto Exit;
          }
        }
        else
        {
          status = RegSetValueExA( hAdapterKey,
                                   REGISTERED_DOMAIN_NAME,
                                   0,
                                   REG_SZ,
                                   (LPBYTE)"",
                                   ( strlen( "" )
                                     + 1 ) * sizeof(CHAR) );

          if ( status )
          {
              goto Exit;
          }
        }

        if ( pUpdateEntry->PrimaryDomainName &&
             pUpdateEntry->fRegisteredPRI )
        {
          Dns_Utf8ToUnicode( pUpdateEntry->PrimaryDomainName,
                             strlen( pUpdateEntry->PrimaryDomainName ),
                             uName,
                             256 );

          status = RegSetValueExW( hAdapterKey,
                                   PRIMARY_DOMAIN_NAME,
                                   0,
                                   REG_SZ,
                                   (LPBYTE)uName,
                                   ( wcslen( uName )
                                     + 1 ) * sizeof(WCHAR) );

          if ( status )
          {
              goto Exit;
          }
        }
        else
        {
          status = RegSetValueExA( hAdapterKey,
                                   PRIMARY_DOMAIN_NAME_A,
                                   0,
                                   REG_SZ,
                                   (LPBYTE)"",
                                   ( strlen( "" )
                                     + 1 ) * sizeof(CHAR) );

          if ( status )
          {
              goto Exit;
          }
        }

        RegSetValueExA( hAdapterKey,
                        SENT_UPDATE_TO_IP,
                        0,
                        REG_DWORD,
                        (LPBYTE)&pUpdateEntry->SentUpdateToIp,
                        sizeof(DWORD) );

        RegSetValueExA( hAdapterKey,
                        SENT_PRI_UPDATE_TO_IP,
                        0,
                        REG_DWORD,
                        (LPBYTE)&pUpdateEntry->SentPriUpdateToIp,
                        sizeof(DWORD) );

        RegSetValueExA( hAdapterKey,
                        REGISTERED_TTL,
                        0,
                        REG_DWORD,
                        (LPBYTE)&pUpdateEntry->TTL,
                        sizeof(DWORD) );

        RegSetValueExA( hAdapterKey,
                        FLAGS,
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwFlags,
                        sizeof(DWORD) );

        //
        // ignore error on the last two. Non critical
        //

        status = RegSetValueExA( hAdapterKey,
                                 REGISTERED_ADDRS,
                                 0,
                                 REG_BINARY,
                                 (LPBYTE) pUpdateEntry->HostAddrs,
                                 pUpdateEntry->HostAddrCount *
                                 sizeof(REGISTER_HOST_ENTRY) );
        if ( status )
        {
            goto Exit;
        }

        status = RegSetValueExA( hAdapterKey,
                                 REGISTERED_ADDRS_COUNT,
                                 0,
                                 REG_DWORD,
                                 (LPBYTE)&pUpdateEntry->HostAddrCount,
                                 sizeof(DWORD) );
        if ( status )
        {
            goto Exit;
        }

        status = RegSetValueExA( hAdapterKey,
                                 REGISTERED_SINCE_BOOT,
                                 0,
                                 REG_DWORD,
                                 (LPBYTE)&dwRegistered,
                                 sizeof(DWORD) );
        if ( status )
        {
            goto Exit;
        }

        if ( pUpdateEntry->DnsServerList )
        {
            status = RegSetValueExA( hAdapterKey,
                                     DNS_SERVER_ADDRS,
                                     0,
                                     REG_BINARY,
                                     (LPBYTE) pUpdateEntry ->
                                              DnsServerList ->
                                              AddrArray,
                                     pUpdateEntry ->
                                     DnsServerList ->
                                     AddrCount *
                                     sizeof(IP_ADDRESS) );
            if ( status )
            {
                goto Exit;
            }

            status = RegSetValueExA( hAdapterKey,
                                     DNS_SERVER_ADDRS_COUNT,
                                     0,
                                     REG_DWORD,
                                     (LPBYTE) &pUpdateEntry ->
                                               DnsServerList ->
                                               AddrCount,
                                     sizeof(DWORD) );
            if ( status )
            {
                goto Exit;
            }
        }
        else
        {
            DWORD count = 0;

            status = RegSetValueExA( hAdapterKey,
                                     DNS_SERVER_ADDRS_COUNT,
                                     0,
                                     REG_DWORD,
                                     (LPBYTE) &count,
                                     sizeof(DWORD) );
            if ( status )
            {
                goto Exit;
            }

            status = RegSetValueExA( hAdapterKey,
                                     DNS_SERVER_ADDRS,
                                     0,
                                     REG_BINARY,
                                     (LPBYTE) NULL,
                                     0 );
            if ( status )
            {
                goto Exit;
            }
        }

        RegCloseKey( hAdapterKey );
        return;
    }

Exit:

    //
    //  remove or failure -- kill adapter key
    //

    RegDeleteKey( g_hKey, pUpdateEntry->AdapterName );

    if ( hAdapterKey )
    {
        RegCloseKey( hAdapterKey );
    }
}


PUPDATE_ENTRY
ReadUpdateEntryFromRegistry(
    IN      PSTR            AdapterName
    )
{
    PREGISTER_HOST_ENTRY pHostAddrs = NULL;
    PUPDATE_ENTRY   pupEntry = NULL;
    DWORD           status = NO_ERROR;
    PSTR            pregHostName = NULL;
    PSTR            pregDomain = NULL;
    PSTR            pregPrimary = NULL;
    IP_ADDRESS      ipSentUpdateTo = 0;
    IP_ADDRESS      ipSentPriUpdateTo = 0;
    DWORD           dwTTL = 0;
    DWORD           dwFlags = 0;
    DWORD           dwHostAddrCount = 0;
    DWORD           dwServerAddrCount = 0;
    PIP_ADDRESS     pServerList = NULL;
    PSTR            pdomain;
    PSTR            pprimary;
    HKEY            hAdapterKey = NULL;
    DWORD           dwType;
    DWORD           dwBytesRead = MAX_PATH -1;
    DWORD           dwBufferSize = 2048;
    BOOL            fRegFWD = FALSE;
    BOOL            fRegPRI = FALSE;
    BOOL            fRegPTR = FALSE;


    DNSDBG( TRACE, (
        "ReadUpdateEntryFromRegistry( %s )\n",
        AdapterName ));

    //
    //  implementation note
    //
    //  two different heaps here
    //      - g_DDNSHeap specific for this module
    //      - general DnsApi heap which all the stuff which is
    //      allocated by GetRegistryValue() is using
    //
    //  GetRegistryValue() uses ALLOCATE_HEAP() (general dnsapi heap)
    //  so all the stuff it creates must be freed by FREE_HEAP()
    //

    pHostAddrs = (PREGISTER_HOST_ENTRY) PHEAP_ALLOC( dwBufferSize );
    if ( !pHostAddrs )
    {
        goto Exit;
    }

    pServerList = (PIP_ADDRESS) PHEAP_ALLOC( dwBufferSize );
    if ( !pServerList )
    {
        goto Exit;
    }

    status = RegOpenKeyEx(
                    g_hKey,
                    AdapterName,
                    0,
                    KEY_ALL_ACCESS,
                    &hAdapterKey );
    if ( status )
    {
        hAdapterKey = NULL;
        goto Exit;
    }

    //
    //  read each value in turn
    //

    //  note that registry flags are not the API flags but the
    //  flags denoting successful registration

    status = GetRegistryValue(
                    hAdapterKey,
                    FLAGS,
                    REG_DWORD,
                    (PBYTE)&dwFlags );
    if ( status )
    {
        goto Exit;
    }
    fRegPRI = !!( dwFlags & REGISTERED_PRIMARY );
    fRegFWD = !!( dwFlags & REGISTERED_FORWARD );
    fRegPTR = !!( dwFlags & REGISTERED_POINTER );


    status = GetRegistryValue(
                    hAdapterKey,
                    REGISTERED_HOST_NAME,
                    REG_SZ,
                    (PBYTE)&pregHostName );
    if ( status )
    {
        goto Exit;
    }

    if ( fRegPRI )
    {
        status = GetRegistryValue(
                        hAdapterKey,
                        PRIMARY_DOMAIN_NAME_A,
                        REG_SZ,
                        (LPBYTE)&pregPrimary );
        if ( status )
        {
            goto Exit;
        }
    }

    if ( fRegFWD )
    {
        status = GetRegistryValue(
                        hAdapterKey,
                        REGISTERED_DOMAIN_NAME,
                        REG_SZ,
                        (LPBYTE)&pregDomain );
        if ( status )
        {
            goto Exit;
        }
    }


    status = GetRegistryValue(
                    hAdapterKey,
                    SENT_UPDATE_TO_IP,
                    REG_DWORD,
                    (LPBYTE)&ipSentUpdateTo );
    if ( status )
    {
        goto Exit;
    }

    status = GetRegistryValue(
                    hAdapterKey,
                    SENT_PRI_UPDATE_TO_IP,
                    REG_DWORD,
                    (LPBYTE)&ipSentPriUpdateTo );
    if ( status )
    {
        goto Exit;
    }

    status = GetRegistryValue(
                    hAdapterKey,
                    REGISTERED_TTL,
                    REG_DWORD,
                    (LPBYTE)&dwTTL );
    if ( status )
    {
        goto Exit;
    }

    status = GetRegistryValue(
                    hAdapterKey,
                    REGISTERED_ADDRS_COUNT,
                    REG_DWORD,
                    (LPBYTE)&dwHostAddrCount );
    if ( status )
    {
        goto Exit;
    }

    dwBytesRead = dwBufferSize;
    status = RegQueryValueEx(
                    hAdapterKey,
                    REGISTERED_ADDRS,
                    0,
                    &dwType,
                    (LPBYTE)pHostAddrs,
                    &dwBytesRead );

    if( status == ERROR_MORE_DATA )
    {
        PrivateHeapFree( pHostAddrs );

        pHostAddrs = (PREGISTER_HOST_ENTRY) PHEAP_ALLOC( dwBytesRead );
        if ( !pHostAddrs )
        {
            goto Exit;
        }
        status = RegQueryValueEx(
                        hAdapterKey,
                        REGISTERED_ADDRS,
                        0,
                        &dwType,
                        (LPBYTE)pHostAddrs,
                        &dwBytesRead );
    }
    if ( status )
    {
        goto Exit;
    }

    if ( dwBytesRead/sizeof(REGISTER_HOST_ENTRY) < dwHostAddrCount )
    {
        goto Exit;
    }

    status = GetRegistryValue(
                    hAdapterKey,
                    DNS_SERVER_ADDRS_COUNT,
                    REG_DWORD,
                    (LPBYTE)&dwServerAddrCount );
    if ( status )
    {
        dwServerAddrCount = 0;
    }

    if ( dwServerAddrCount )
    {
        dwBytesRead = dwBufferSize;

        status = RegQueryValueEx(
                    hAdapterKey,
                    DNS_SERVER_ADDRS,
                    0,
                    &dwType,
                    (LPBYTE)pServerList,
                    &dwBytesRead );

        if ( status == ERROR_MORE_DATA )
        {
            PHEAP_FREE( pServerList );

            pServerList = (PIP_ADDRESS) PHEAP_ALLOC( dwBytesRead );
            if ( !pServerList )
            {
                goto Exit;
            }
            status = RegQueryValueEx(
                        hAdapterKey,
                        DNS_SERVER_ADDRS,
                        0,
                        &dwType,
                        (LPBYTE)pServerList,
                        &dwBytesRead );
        }
        if ( status )
        {
            goto Exit;
        }

        if ( dwBytesRead/sizeof(IP_ADDRESS) < dwServerAddrCount )
        {
            goto Exit;
        }
    }
    else
    {
        pServerList = NULL;
    }

    //
    //  validate domain names non-empty
    //

    pdomain = pregDomain;
    if ( pdomain &&
         strlen( pdomain ) == 0 )
    {
        pdomain = NULL;
    }

    pprimary = pregPrimary;
    if ( pprimary &&
         strlen( pprimary ) == 0 )
    {
        pprimary = NULL;
    }

    status = AllocateUpdateEntry(
                    AdapterName,
                    pregHostName,
                    pdomain,
                    pprimary,
                    NULL,           // no alternate names
                    dwHostAddrCount,
                    pHostAddrs,
                    dwServerAddrCount,
                    pServerList,
                    ipSentUpdateTo,
                    ipSentPriUpdateTo,
                    dwTTL,
                    ( fRegPTR ) ? DYNDNS_REG_PTR : 0,
                    0,
                    Dns_GetCurrentTimeInSeconds(),
                    NULL,
                    &pupEntry );
    if ( status )
    {
        DNS_ASSERT( pupEntry == NULL );
        pupEntry = NULL;
        goto Exit;
    }

    pupEntry->fFromRegistry     = TRUE;
    pupEntry->fRegisteredFWD    = fRegFWD;
    pupEntry->fRegisteredPRI    = fRegPRI;
    pupEntry->fRegisteredPTR    = fRegPTR;


Exit:

    //
    //  cleanup
    //      - close registry
    //      - dump local data
    //

    if ( hAdapterKey )
    {
        RegCloseKey( hAdapterKey );
    }

    PrivateHeapFree( pHostAddrs );
    PrivateHeapFree( pServerList );

    FREE_HEAP( pregHostName );
    FREE_HEAP( pregDomain );
    FREE_HEAP( pregPrimary );
    
    //  set return value

    ASYNCREG_UPDATE_ENTRY(
        "Leaving ReadUpdateEntryFromRegistry:",
        pupEntry );

    IF_DNSDBG( TRACE )
    {
        DnsDbg_UpdateEntry(
            "Leave ReadUpdateEntryFromRegistry():",
            pupEntry );
    }

    return  pupEntry;
}


VOID
MarkAdapterAsPendingUpdate(
    IN      PSTR            AdapterName
    )
{
    DWORD   status = NO_ERROR;
    DWORD   dwRegistered = 1;
    HKEY    hAdapterKey = NULL;

    DNSDBG( TRACE, (
        "MarkAdapterAsPendingUpdate( %s )\n",
        AdapterName ));

    status = RegOpenKeyEx(
                g_hKey,
                AdapterName,
                0,
                KEY_ALL_ACCESS,
                &hAdapterKey );
    if ( status )
    {
        return;
    }

    RegSetValueExA(
        hAdapterKey,
        REGISTERED_SINCE_BOOT,
        0,
        REG_DWORD,
        (LPBYTE) &dwRegistered,
        sizeof(DWORD) );

    RegCloseKey( hAdapterKey );
}



DWORD
GetNextUpdateEntryFromList(
    OUT     PUPDATE_ENTRY * ppUpdateEntry,
    OUT     PDWORD          pdwWaitTime
    )
/*++

Routine Description:

    Dequeue update entry from update list.

    //
    // If a new entry is found, set ppUpdateEntry to point
    // to it and return 0 (prefering deletes over adds).
    //
    // If there are only retry entries in the list, and one or more
    // have reached their retry time interval, then set ppUpdateEntry
    // to point to the one with the least retry time and return 0.
    //
    // If there are only retry entries in the list, but none have
    // yet reached there retry time interval then set pdwWaitTime to
    // the time remaining to wait for the entry with the least retry
    // interval and return 1 (WAIT)
    //
    // If there are no more records in list, return (-1)
    //

Arguments:

Return Value:

    (0) -- returning entry in ppUpdateEntry
            - new entry if found
            - retry which is past its retry time

    (1) -- list has only retries which have NOT reached retry time
            - set pdwWaitTime to remaining time to first retry

    (-1) -- list is empty

--*/
{
    PLIST_ENTRY     pentry;
    PLIST_ENTRY     plistHead;
    PLIST_ENTRY     pleastWaitEntry = NULL;
    DWORD           minWaitTime = 0xffffffff;
    INT             waitTime;

    ASYNCREG_F1( "Inside function GetNextUpdateEntryFromList" );

    DNSDBG( TRACE, ( "GetNextUpdateEntryFromList()" ));

    if ( IsListEmpty( &g_RegistrationList ) )
    {
        *ppUpdateEntry = NULL;
        *pdwWaitTime = 0;
        ASYNCREG_F1( "GetNextUpdateEntryFromList - returning (NO_MORE_RECORDS)" );
        ASYNCREG_F1( "" );
        return(-1);
    }

    //
    // Loop through list looking for a new delete related update entry.
    // If so, remove it from list and return it.
    //
    plistHead = &g_RegistrationList;
    pentry = plistHead->Flink;

    while ( pentry != plistHead )
    {
        if ( ((PUPDATE_ENTRY) pentry)->fRemove &&
             ((PUPDATE_ENTRY) pentry)->fNewElement )
        {
            RemoveEntryList( pentry );
            *ppUpdateEntry = (PUPDATE_ENTRY) pentry;
            *pdwWaitTime = 0;
            ASYNCREG_F1( "GetNextUpdateEntryFromList - returning new remove entry (SUCCESS)" );
            ASYNCREG_F1( "" );
            return 0;
        }
        else
        {
            pentry = pentry->Flink;
        }
    }

    //
    // Now loop through list looking for any new update.
    // If so, remove it from list and return it.
    //
    plistHead = &g_RegistrationList;
    pentry = plistHead->Flink;

    while ( pentry != plistHead )
    {
        if ( ((PUPDATE_ENTRY) pentry)->fNewElement )
        {
            RemoveEntryList( pentry );
            *ppUpdateEntry = (PUPDATE_ENTRY) pentry;
            *pdwWaitTime = 0;
            ASYNCREG_F1( "GetNextUpdateEntryFromList - returning new entry (SUCCESS)" );
            ASYNCREG_F1( "" );
            return 0;
        }
        else
        {
            pentry = pentry->Flink;
        }
    }

    //
    // There are no new update entries to process, now need to
    // loop through list looking for the next possible update to
    // wait on. If wait time has expired return it, otherwise
    // set pdwWaitTime to time remaining and return 1.
    //
    plistHead = &g_RegistrationList;
    pentry = plistHead->Flink;

    while ( pentry != plistHead )
    {
        if ( ((PUPDATE_ENTRY) pentry)->RetryTime <
             minWaitTime )
        {
            minWaitTime = ((PUPDATE_ENTRY) pentry)->RetryTime;
            pleastWaitEntry = pentry;
        }

        pentry = pentry->Flink;
    }

    waitTime = (INT) ( minWaitTime - Dns_GetCurrentTimeInSeconds() );

    if ( waitTime > 0 )
    {
        waitTime *= 1000;
        *ppUpdateEntry = NULL;
        *pdwWaitTime = (DWORD) waitTime;
        ASYNCREG_F1( "GetNextUpdateEntryFromList - returning (WAIT)" );
        ASYNCREG_F1( "" );
        return 1;
    }
    else
    {
        RemoveEntryList( pleastWaitEntry );
        *ppUpdateEntry = (PUPDATE_ENTRY) pleastWaitEntry;
        *pdwWaitTime = 0;
        ASYNCREG_F1( "GetNextUpdateEntryFromList - returning wait entry (SUCCESS)" );
        ASYNCREG_F1( "" );
        return 0;
    }
}



//
//  Update entry processing
//

DNS_STATUS
DoRemoveUpdate(
    IN OUT  PUPDATE_ENTRY   pRemoveEntry,
    IN OUT  PDNS_RECORD     pRemoveRecord,
    IN      UPTYPE          UpType
    )
/*++

Routine Description:

    Do a remove update.

    Helper routine for DoUpdate().
    Routine simply avoids duplicate code as this is called
    with both registry entry and with update entry.

Arguments:

    pRemoveEntry -- entry to remove, from update or registry

    pRemoveRecord -- record to remove

    fPrimary -- TRUE for primary update;  FALSE otherwise

Return Value:

    DNS or Win32 error code.

--*/
{
    DNS_STATUS  status = NO_ERROR;

    DNSDBG( TRACE, (
        "DoRemoveUpdate( %p, %p, %d )\n",
        pRemoveEntry,
        pRemoveRecord,
        UpType
        ));

    //
    //  try remove
    //      - don't track failure, this is a one shot deal before
    //      adapter goes down
    //

    status = DnsModifyRecordsInSet_UTF8(
                    NULL,               // no add records
                    pRemoveRecord,      // delete records
                    DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                    NULL,               // no context handle
                    (PIP4_ARRAY) pRemoveEntry->DnsServerList,
                    NULL                // reserved
                    );

    SetUpdateStatus(
        pRemoveEntry,
        status,
        UpType );

    if ( IS_UPTYPE_PRIMARY(UpType) )
    {
        LogRegistration(
            pRemoveEntry,
            status,
            UpType,
            TRUE,       // deregistration
            0,          // default server IP
            0           // default update IP
            );
    }

#if 0
    //  doing entire update entry PTR dereg at once
    //  in ProcessUpdate() once done
    //
    //  deregister the PTR records
    //

    if ( (pRemoveEntry->Flags & DYNDNS_REG_PTR) &&
         g_RegisterReverseLookup )
    {
        UpdatePtrRecords(
            pRemoveEntry,
            FALSE           // remove records
            );
    }
#endif

    return  status;
}



DNS_STATUS
ModifyAdapterRegistration(
    IN      PUPDATE_ENTRY   pUpdateEntry,
    IN      PUPDATE_ENTRY   pRegistryEntry,
    IN      PDNS_RECORD     pUpdateRecord,
    IN      PDNS_RECORD     pRegRecord,
    IN      BOOL            fPrimaryDomain
    )
{
    DNS_STATUS      status = NO_ERROR;
    PDNS_RECORD     potherRecords = NULL;
    PDNS_RECORD     pNewUpdateRecord = NULL;
    PDNS_RECORD     pNewRegRecord = NULL;
    IP_ADDRESS      serverIp = 0;

    DNSDBG( TRACE, (
        "ModifyAdapterRegistration()\n"
        "\tpUpdateEntry     = %p\n"
        "\tpUpdateRecords   = %p\n"
        "\tpRegistryEntry   = %p\n"
        "\tpRegistryRecords = %p\n"
        "\tfPrimary         = %d\n",
        pUpdateEntry,
        pRegistryEntry,
        pUpdateRecord,
        pRegRecord,
        fPrimaryDomain ));

    //
    //  multi-adapter registration test
    //
    //  check other adapters for registrations on the same name
    //  if found, include in updates
    //

    potherRecords = GetPreviousRegistrationInformation(
                        pUpdateEntry,
                        fPrimaryDomain,
                        &serverIp );
    if ( potherRecords )
    {
        IP_ARRAY    ipArray;

        DNSDBG( DHCP, (
            "Have registry update data for other adapters!\n"
            "\tCreating combined update record sets.\n" ));

        ipArray.AddrCount = 1;
        ipArray.AddrArray[0] = serverIp;

        pNewUpdateRecord = CreateDnsRecordSetUnion(
                                pUpdateRecord,
                                potherRecords );
        if ( pRegRecord
                &&
             Dns_NameCompare_UTF8(
                    pRegRecord->pName,
                    pUpdateRecord->pName )
                &&
             CompareMultiAdapterSOAQueries(
                    pUpdateRecord->pName,
                    pUpdateEntry->DnsServerList,
                    pRegistryEntry->DnsServerList ) )
        {
            pNewRegRecord = CreateDnsRecordSetUnion(
                                pRegRecord,
                                potherRecords );
        }
        else
        {
            if ( pRegRecord )
            {
                //
                // The record found in the registry for this adapter
                // is stale and should be deleted. Otherwise we set the
                // current list of records to only that of potherRecords.
                //
                ASYNCREG_F1( "DoUpdateForPrimaryName - Found stale registry entry:" );
                ASYNCREG_F2( "   Name : %s", pRegRecord->pName );
                ASYNCREG_F1( "   Address :" );
                DNSLOG_PIP_ADDRESS( 1, &(pRegRecord->Data.A.IpAddress) );
                ASYNCREG_F1( "" );
                ASYNCREG_F1( "   Calling DnsRemoveRecords_UTF8 to get rid of it" );

                status = DnsModifyRecordsInSet_UTF8(
                                NULL,           // no add records
                                pRegRecord,     // delete records
                                DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                                NULL,           // no context handle
                                (PIP4_ARRAY) pRegistryEntry->DnsServerList,
                                NULL            // reserved
                                );

                ASYNCREG_F3( "   DnsRemoveRecords_UTF8 returned: 0x%x\n\t%s",
                             status,
                             Dns_StatusString( status ) );
            }

            pNewRegRecord = potherRecords;
            potherRecords = NULL;
        }

        if ( !pNewUpdateRecord || !pNewRegRecord )
        {
            DNSDBG( ANY, (
                "ERROR:  failed to build combined record set for update!\n" ));
            status = DNS_ERROR_NO_MEMORY;
            goto Exit;
        }

        ASYNCREG_F1( "ModifyAdapterRegistration - Calling DnsModifyRecordSet_UTF8" );
        ASYNCREG_F1( "    (current update + previous records)" );

        if ( serverIp )
        {
            //
            //  DCR:  just do replace from the start
            //

            ASYNCREG_F1( "    (sending update to specific server)" );
            DNSLOG_PIP_ARRAY( &ipArray );

            status = DnsModifyRecordSet_UTF8(
                        NULL,                   // no creds
                        pNewRegRecord,          // previous set
                        pNewUpdateRecord,       // new set
                        DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                        &ipArray );

            ASYNCREG_F3( "   DnsModifyRecordSet_UTF8 returned: 0x%x\n\t%s",
                         status,
                         Dns_StatusString( status ) );

            if ( status == DNS_ERROR_RCODE_SERVER_FAILURE ||
                 status == ERROR_TIMEOUT )
            {
                goto SendUpdate1;
            }

            if ( status == DNS_ERROR_NOT_UNIQUE  &&
                 g_RegistrationOverwritesInConflict )
            {
                ASYNCREG_F1( "ModifyAdapterRegistration - Calling DnsReplaceRecordSet_UTF8" );
                ASYNCREG_F1( "    (current update + previous records)" );

                status = DnsReplaceRecordSetUTF8(
                                pNewUpdateRecord,       // replace set
                                DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                                NULL,                   // no security context
                                (PIP4_ARRAY) &ipArray,  // DNS servers
                                NULL                    // reserved
                                );

                ASYNCREG_F3( "   DnsReplaceRecordSet_UTF8 returned: 0x%x\n\t%s",
                             status,
                             Dns_StatusString( status ) );
            }
        }
        else
        {

SendUpdate1 :

            ASYNCREG_F1( "    (sending update to adapter server list)" );
            DNSLOG_PIP_ARRAY( pUpdateEntry->DnsServerList );

            status = DnsModifyRecordSet_UTF8(
                            NULL,               // no creds
                            pNewRegRecord,      // previous set
                            pNewUpdateRecord,   // new set
                            DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                            pUpdateEntry->DnsServerList
                            );

            ASYNCREG_F3( "   DnsModifyRecordSet_UTF8 returned: 0x%x\n\t%s",
                         status,
                         Dns_StatusString( status ) );

            if ( status == DNS_ERROR_NOT_UNIQUE &&
                 g_RegistrationOverwritesInConflict )
            {
                ASYNCREG_F1( "ModifyAdapterRegistration - Calling DnsReplaceRecordSet_UTF8" );
                ASYNCREG_F1( "    (current update + previous records)" );

                status = DnsReplaceRecordSetUTF8(
                                pNewUpdateRecord,       // replace set
                                DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                                NULL,                   // no security context
                                (PIP4_ARRAY) pUpdateEntry->DnsServerList,
                                NULL                    // reserved
                                );

                ASYNCREG_F3( "   DnsReplaceRecordSet_UTF8 returned: 0x%x\n\t%s",
                             status,
                             Dns_StatusString( status ) );
            }
        }
    }
    else
    {
        if ( pRegRecord
                &&
             Dns_NameCompare_UTF8(
                    pRegRecord->pName,
                    pUpdateRecord->pName )
                &&
             CompareMultiAdapterSOAQueries(
                    pUpdateRecord->pName,
                    pUpdateEntry->DnsServerList,
                    pRegistryEntry->DnsServerList ) )
        {
            ASYNCREG_F1( "ModifyAdapterRegistration - Calling DnsModifyRecordSet_UTF8" );
            ASYNCREG_F1( "    (current update record only)" );

            status = DnsModifyRecordSet_UTF8(
                            NULL,           // no creds
                            pRegRecord,     // previous set
                            pUpdateRecord,  // new set
                            DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                            pUpdateEntry->DnsServerList );

            ASYNCREG_F3( "   DnsModifyRecordSet_UTF8 returned: 0x%x\n\t%s",
                         status,
                         Dns_StatusString( status ) );
        }
        else
        {
            if ( pRegRecord )
            {
                //
                // The record found in the registry for this adapter
                // is stale and should be deleted. Otherwise we set the
                // current list of records to only that of potherRecords.
                //
                ASYNCREG_F1( "DoUpdateForPrimaryName - Found stale registry entry:" );
                ASYNCREG_F2( "   Name : %s", pRegRecord->pName );
                ASYNCREG_F1( "   Address :" );
                DNSLOG_PIP_ADDRESS( 1, &(pRegRecord->Data.A.IpAddress) );
                ASYNCREG_F1( "" );
                ASYNCREG_F1( "   Calling DnsRemoveRecords_UTF8 to get rid of it" );

                status = DnsModifyRecordsInSet_UTF8(
                                NULL,           // no add records
                                pRegRecord,     // delete records
                                DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                                NULL,           // no context handle
                                pRegistryEntry->DnsServerList,
                                NULL            // reserved
                                );

                ASYNCREG_F3( "   DnsRemoveRecords_UTF8 returned: 0x%x\n\t%s",
                             status,
                             Dns_StatusString( status ) );
            }

            ASYNCREG_F1( "ModifyAdapterRegistration - Calling DnsAddRecordSet_UTF8" );

            status = DnsAddRecordSet_UTF8(
                            NULL,               // no creds
                            pUpdateRecord,
                            DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                            pUpdateEntry->DnsServerList );

            ASYNCREG_F3( "   DnsAddRecordSet_UTF8 returned: 0x%x\n\t%s",
                         status,
                         Dns_StatusString( status ) );
        }

        if ( status == DNS_ERROR_NOT_UNIQUE &&
             g_RegistrationOverwritesInConflict )
        {
            ASYNCREG_F1( "ModifyAdapterRegistration - Calling DnsReplaceRecordSet_UTF8" );
            ASYNCREG_F1( "    (current update record only)" );

            status = DnsReplaceRecordSetUTF8(
                            pUpdateRecord,          // replace set
                            DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                            NULL,                   // no security context
                            (PIP4_ARRAY) pUpdateEntry->DnsServerList,
                            NULL                    // reserved
                            );

            ASYNCREG_F3( "   DnsReplaceRecordSet_UTF8 returned: 0x%x\n\t%s",
                         status,
                         Dns_StatusString( status ) );
        }
    }

Exit:

    Dns_RecordListFree( potherRecords );
    Dns_RecordListFree( pNewUpdateRecord );
    Dns_RecordListFree( pNewRegRecord );

    return status;
}



DNS_STATUS
DoModifyUpdate(
    IN OUT  PUPDATE_ENTRY   pUpdateEntry,
    IN OUT  PDNS_RECORD     pUpdateRecord,
    IN      PUPDATE_ENTRY   pRegistryEntry,     OPTIONAL
    IN OUT  PDNS_RECORD     pRegRecord,         OPTIONAL
    IN      UPTYPE          UpType
    )
/*++

Routine Description:

    Standard modify registration.

    Helper routine for DoUpdate().
    This handles modify for typical non-remove case.
        - Forward records updated
        - Old PTR removed if new address.
        - New PTR added (or name modified).

Arguments:

    pUpdateEntry    -- update entry

    pUpdateRecord   -- records for update

    pRegistryEntry  -- registry entry

    pRegRecord      -- records from registry entry

    fPrimary        -- TRUE if update for primary domain name
                       FALSE for adapter domain name

Return Value:

    DNS or Win32 error code.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    IP4_ADDRESS     ip = 0;
    BOOL            fregistered = FALSE;

    DNSDBG( TRACE, (
        "DoModifyUpdate()\n"
        "\tUpdateEntry  = %p\n"
        "\tUpType       = %d\n",
        pUpdateEntry,
        UpType ));

    DNS_ASSERT( pUpdateEntry != NULL );
    DNS_ASSERT( pUpdateRecord != NULL );

    //
    //  do forward registration modify
    //

    status = ModifyAdapterRegistration(
                    pUpdateEntry,       // add
                    pRegistryEntry,     // remove
                    pUpdateRecord,
                    pRegRecord,
                    IS_UPTYPE_PRIMARY(UpType)
                    );

    //
    //  save success info
    //

    SetUpdateStatus(
        pUpdateEntry,
        status,
        UpType );

    //
    //  PTR records
    //
    //  deregister previous PTR registration
    //      - registry entry indicates previous registration
    //      - not the same address as current (otherwise it's an update)
    //
    //  note:  adding new registration takes place in DoUpdate() once
    //      ALL forward updates are complete
    //

    if ( g_RegisterReverseLookup )
    {
        if ( pRegistryEntry &&
             (pRegistryEntry->Flags & DYNDNS_REG_PTR) &&
             !compareUpdateEntries( pRegistryEntry, pUpdateEntry ) )
        {
            UpdatePtrRecords(
                pRegistryEntry,
                FALSE           // remove previous PTR
                );
        }
    }

    //
    //  Log registration status in EventLog
    //

    if ( pUpdateEntry->RetryCount == 2 ||
         status == DNS_ERROR_RCODE_NOT_IMPLEMENTED ||
         status == DNS_ERROR_RCODE_REFUSED )
    {
        LogRegistration(
            pUpdateEntry,
            status,
            UpType,
            FALSE,      // registration
            0,          // default server IP
            0           // default update IP
            );
    }

    DNSDBG( TRACE, (
        "Leave DoModifyUpdate() => %d\n",
        status ));

    return status;
}



DNS_STATUS
DoUpdate(
    IN OUT  PUPDATE_ENTRY   pRegistryEntry  OPTIONAL,
    IN OUT  PUPDATE_ENTRY   pUpdateEntry,
    IN      UPTYPE          UpType
    )
/*++

Routine Description:

    Do update for a particular name.

    Helper routine for ProcessUpdate().
    Handles one name, called separately for AdapaterDomainName and
    PrimaryDomainName.

Arguments:

    pUpdateEntry    -- update entry

    pRegistryEntry  -- registry entry

    fPrimary        -- TRUE if update for primary domain name
                       FALSE for adapter domain name

Return Value:

    DNS or Win32 error code.

--*/
{
    PDNS_RECORD     prrRegistry = NULL;
    PDNS_RECORD     prrUpdate = NULL;
    DNS_STATUS      status = NO_ERROR;

    ASYNCREG_UPDATE_ENTRY(
        "DoUpdate() -- UpdateEntry:",
        pUpdateEntry );
    ASYNCREG_UPDATE_ENTRY(
        "DoUpdate() -- RegistryEntry:",
        pRegistryEntry );

    IF_DNSDBG( TRACE )
    {
        DnsDbg_UpdateEntry(
            "DoUpdate() -- UpdateEntry:",
            pUpdateEntry );
        DnsDbg_UpdateEntry(
            "DoUpdate() -- RegistryEntry:",
            pRegistryEntry );
    }
    DNS_ASSERT( pUpdateEntry != NULL );

    //
    //  build records from update entrys
    //

    prrUpdate = CreateForwardRecords(
                        pUpdateEntry,
                        UpType
                        );
    if ( ! prrUpdate )
    {
        DNSDBG( TRACE, (
            "No forward records created for update entry (%p) for update type %d!",
            pUpdateEntry,
            UpType ));
        return NO_ERROR;
    }

    if ( pRegistryEntry )
    {
        prrRegistry = CreateForwardRecords(
                            pRegistryEntry,
                            UpType
                            );
        DNS_ASSERT( !IS_UPTYPE_ALTERNATE(UpType) || prrRegistry==NULL );
    }

    //
    //  remove?
    //      - remove previous registry entry if exists
    //      - remove update entry
    //

    if ( pUpdateEntry->fRemove )
    {
        if ( prrRegistry )
        {
            //  we don't lookup registry entries on fRemove updates, so i
            //      don't see how we'd get here

            DNS_ASSERT( FALSE );

            DoRemoveUpdate(
                pRegistryEntry,
                prrRegistry,
                UpType );
        }
        status = DoRemoveUpdate(
                    pUpdateEntry,
                    prrUpdate,
                    UpType );
    }

    //
    //  add\modify registration
    //

    else
    {
        status = DoModifyUpdate(
                    pUpdateEntry,
                    prrUpdate,
                    pRegistryEntry,
                    prrRegistry,
                    UpType
                    );
    }

    //
    //  cleanup records
    //

    Dns_RecordListFree( prrRegistry );
    Dns_RecordListFree( prrUpdate );

    return  status;
}



BOOL
IsQuickRetryError(
    IN      DNS_STATUS      Status
    )
{
    return( Status != NO_ERROR
                &&
            (   Status == DNS_ERROR_RCODE_REFUSED ||
                Status == DNS_ERROR_RCODE_SERVER_FAILURE ||
                Status == DNS_ERROR_TRY_AGAIN_LATER ||
                Status == DNS_ERROR_NO_DNS_SERVERS ||
                Status == WSAECONNREFUSED ||
                Status == WSAETIMEDOUT ||
                Status == ERROR_TIMEOUT ) );

}



VOID
ProcessUpdateEntry(
    IN OUT  PUPDATE_ENTRY   pUpdateEntry,
    IN      BOOL            fPurgeMode
    )
/*++

Routine Description:

    Main routine processing an update.

Arguments:

    pUpdateEntry    -- update entry to execute
        note:  this routine frees pUpdateEntry when complete

    fPurgeMode      -- TRUE if purging update queue

Return Value:

    DNS or Win32 error code.

--*/
{
    DNS_STATUS      status;
    DNS_STATUS      statusPri = NO_ERROR;
    DNS_STATUS      statusAdp = NO_ERROR;
    DNS_STATUS      statusAlt = NO_ERROR;
    PUPDATE_ENTRY   pregEntry = NULL;
    DWORD           retryInterval;


    DNSDBG( TRACE, (
        "ProcessUpdateEntry( %p, purge=%d )\n",
        pUpdateEntry,
        fPurgeMode ));

    IF_DNSDBG( TRACE )
    {
        DnsDbg_UpdateEntry(
            "Enter ProcessUpdateEntry():",
            pUpdateEntry );
    }

    //
    //  add (not remove)
    //

    if ( !pUpdateEntry->fRemove )
    {
        //  no adds during purge mode

        if ( fPurgeMode )
        {
            goto Cleanup;
        }

        //
        //  get any prior update info from registry
        //
        //  if hostname change, then delete on prior update
        //

        pregEntry = ReadUpdateEntryFromRegistry( pUpdateEntry->AdapterName );
        if ( pregEntry )
        {
            if ( ! Dns_NameCompare_UTF8(
                        pregEntry->HostName,
                        pUpdateEntry->HostName ) )
            {
                DNSDBG( TRACE, (
                    "Prior registry data with non-matching hostname!\n"
                    "\tqueuing delete for prior data and doing standard add.\n" ));

                //
                // Create delete update entry for registry information and
                // add to registration list. Clear registry in the mean time.
                //
                pregEntry->fRemove = TRUE;
                pregEntry->Flags |= DYNDNS_DEL_ENTRY;
    
                pregEntry->fRegisteredFWD = FALSE;
                pregEntry->fRegisteredPRI = FALSE;
                pregEntry->fRegisteredPTR = FALSE;
    
                if ( fPurgeMode )
                {
                    pregEntry->RetryCount = 2;
                    pregEntry->RetryTime = Dns_GetCurrentTimeInSeconds();
                }
    
                //
                // Clear registry key for adapter
                //
                WriteUpdateEntryToRegistry( pregEntry );
    
                //
                //  Put update in registration list
                //      - clear registry entry PTR so not used below
                //
                enqueueUpdate( pregEntry );
                pregEntry = NULL;

                //  fall through to do standard add update with no prior data
            }
        }
    }

    //
    //  do updates
    //      - primary
    //      - adapter domain
    //      - alternate name
    //

    if ( ! pUpdateEntry->fRegisteredFWD )
    {
        statusAdp = DoUpdate(
                        pregEntry,
                        pUpdateEntry,
                        UPTYPE_DOMAIN
                        );
    }
    if ( ! pUpdateEntry->fRegisteredPRI )
    {
        statusPri = DoUpdate(
                        pregEntry,
                        pUpdateEntry,
                        UPTYPE_PRIMARY  // primary update
                        );
    }
    if ( ! pUpdateEntry->fRegisteredALT )
    {
        PSTR        pname = pUpdateEntry->AlternateNames;
        DNS_STATUS  statusTmp;
        DWORD       count = 0;

        //
        //  update each alternate name in MULTISZ
        //      - must set index in update blob to use correct name in
        //          record building
        //      - any failure fails ALT names
        //

        statusAlt = NO_ERROR;

        while ( pname )
        {
            pUpdateEntry->AlternateIndex = count++;

            DNSDBG( DHCP, (
                "Update with alternate name %s\n"
                "\tindex = %d\n",
                pname,
                count-1 ));

            statusTmp = DoUpdate(
                            NULL,           // not saving alternate info in registry
                            //  pregEntry,
                            pUpdateEntry,
                            UPTYPE_ALTERNATE
                            );
            if ( statusTmp != NO_ERROR )
            {
                statusAlt = statusTmp;
            }
            pname = MultiSz_NextString_A( pname );
        }

        pUpdateEntry->fRegisteredALT = (statusAlt == NO_ERROR);
    }

    //
    //  update PTRs once forward done
    //
    //  doing this outside DoUpdate() because will ONLY do PTRs
    //  for forwards that succeed, so want all forward updates
    //  completed first;  but this also helps in that it combines
    //  the reverse updates
    //

    if (( pUpdateEntry->Flags & DYNDNS_REG_PTR) && g_RegisterReverseLookup)
    {
        UpdatePtrRecords(
            pUpdateEntry,
            !pUpdateEntry->fRemove  // add update
            );
    }

    //
    //  write completed update info to registry
    //

    if ( !pUpdateEntry->fRemove )
    {
        WriteUpdateEntryToRegistry( pUpdateEntry );
    }

    //
    //  setup retry on failure
    //

    if ( statusPri != NO_ERROR )
    {
        status = statusPri;
        goto ErrorRetry;
    }
    else if ( statusAdp != NO_ERROR )
    {
        status = statusAdp;
        goto ErrorRetry;
    }
    else if ( statusAlt != NO_ERROR )
    {
        status = statusAlt;
        goto ErrorRetry;
    }

    //
    //  successful update
    //      - signal update event (if given)
    //      - cleanup if remove or purging
    //      - requeue if add
    //

    if ( pUpdateEntry->pRegisterStatus )
    {
        registerUpdateStatus( pUpdateEntry->pRegisterStatus, ERROR_SUCCESS );
    }

    if ( pUpdateEntry->fRemove || fPurgeMode || g_fPurgeRegistrations )
    {
        DNSDBG( TRACE, (
            "Leaving ProcessUpdate() => successful remove\\purge.\n" ));
        goto Cleanup;
    }
    else
    {
        pUpdateEntry->fNewElement           = FALSE;
        pUpdateEntry->fRegisteredFWD        = FALSE;
        pUpdateEntry->fRegisteredPRI        = FALSE;
        pUpdateEntry->fRegisteredPTR        = FALSE;
        pUpdateEntry->RetryCount            = 0;
        pUpdateEntry->fDisableErrorLogging  = TRUE;
        pUpdateEntry->RetryTime = Dns_GetCurrentTimeInSeconds() +
                                  g_RegistrationRefreshInterval;

        if ( pUpdateEntry->pRegisterStatus )
        {
            pUpdateEntry->pRegisterStatus = NULL;
        }
        enqueueUpdate( pUpdateEntry );

        DNSDBG( TRACE, (
            "Leaving ProcessUpdate( %p ) => successful => requeued.\n",
            pUpdateEntry ));

        pUpdateEntry = NULL;
        goto Cleanup;
    }


ErrorRetry:


    //  failures during purge mode are not retried
    //  just free entry and bail

    if ( fPurgeMode || g_fPurgeRegistrations )
    {
        DNSDBG( TRACE, (
            "Leaving ProcessUpdate() => failed purging.\n" ));
        goto Cleanup;
    }

    //
    //  set retry time
    //
    //  less than two retries and more transient errors
    //      => short retry
    //
    //  third failure or longer term error code
    //      => push retry back to an hour
    //

    if ( pUpdateEntry->RetryCount < 2
            &&
         (  IsQuickRetryError(statusAdp) ||
            IsQuickRetryError(statusPri) ||
            IsQuickRetryError(statusAlt) ) )
    {
        pUpdateEntry->RetryCount++;
        retryInterval = (pUpdateEntry->RetryCount == 1)
                            ? FIRST_RETRY_INTERVAL
                            : SECOND_RETRY_INTERVAL;
    }
    else
    {
        retryInterval = FAILED_RETRY_INTERVAL;
        pUpdateEntry->RetryCount = 0;
        pUpdateEntry->fDisableErrorLogging = TRUE;

        if ( pUpdateEntry->pRegisterStatus )
        {
            registerUpdateStatus( pUpdateEntry->pRegisterStatus, status );
            pUpdateEntry->pRegisterStatus = NULL;
        }
    }

    pUpdateEntry->fNewElement = FALSE;
    pUpdateEntry->RetryTime = Dns_GetCurrentTimeInSeconds() + retryInterval;

    //
    //  requeue
    //      - entry dumped if another update for adapter already queued
    //

    enqueueUpdateMaybe( pUpdateEntry );

    DNSDBG( TRACE, (
        "Leaving ProcessUpdate( %p ) => failed => requeued.\n",
        pUpdateEntry ));

    pUpdateEntry = NULL;


Cleanup:

    //
    //  cleanup
    //      - registry entry
    //      - update entry if not requeued
    //

    FreeUpdateEntry( pregEntry );
    FreeUpdateEntry( pUpdateEntry );
}


VOID
ResetAdaptersInRegistry(
    VOID
    )
{
    DWORD  retVal = NO_ERROR;
    DWORD  status = NO_ERROR;
    CHAR   szName[ MAX_PATH ];
    HKEY   hAdapterKey = NULL;
    DWORD  dwType;
    INT    index;
    DWORD  dwBytesRead = MAX_PATH -1;
    DWORD  dwRegistered = 0;

    ASYNCREG_F1( "Inside function ResetAdaptersInRegistry" );
    ASYNCREG_F1( "" );

    index = 0;

    while ( !retVal )
    {
        dwBytesRead = MAX_PATH - 1;

        retVal = RegEnumKeyEx ( g_hKey,
                                  index,
                                  szName,
                                  &dwBytesRead,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL );
        if ( retVal )
        {
            goto Exit;
        }

        status = RegOpenKeyEx( g_hKey,
                               szName,
                               0,
                               KEY_ALL_ACCESS,
                               &hAdapterKey );
        if ( status )
        {
            goto Exit;
        }

        //
        // Found an adapter in the registry, set registered since
        // boot to FALSE.
        //
        status = RegSetValueExA( hAdapterKey,
                                 REGISTERED_SINCE_BOOT,
                                 0,
                                 REG_DWORD,
                                 (LPBYTE)&dwRegistered, // 0 - False
                                 sizeof(DWORD) );
        if ( status )
        {
            goto Exit;
        }

        RegCloseKey( hAdapterKey );
        hAdapterKey = NULL;
        index++;
    }

Exit :

    if ( hAdapterKey )
    {
        RegCloseKey( hAdapterKey );
    }
}


VOID
DeregisterUnusedAdapterInRegistry(
    IN      BOOL            fPurgeMode
    )
{
    DWORD           retVal = NO_ERROR;
    DWORD           status = NO_ERROR;
    CHAR            szName[MAX_PATH];
    HKEY            hAdapterKey = NULL;
    INT             index;
    DWORD           dwBytesRead = MAX_PATH -1;
    DWORD           dwRegistered = 0;
    PUPDATE_ENTRY   pregEntry = NULL;

    ASYNCREG_F1( "Inside function DeregisterUnusedAdapterInRegistry" );
    ASYNCREG_F1( "" );

    index = 0;

    while ( !retVal )
    {
        dwBytesRead = MAX_PATH - 1;
        retVal = RegEnumKeyEx ( g_hKey,
                                  index,
                                  szName,
                                  &dwBytesRead,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL );

        if ( retVal != ERROR_SUCCESS )
        {
            goto Exit;
        }

        status = RegOpenKeyEx( g_hKey,
                               szName,
                               0,
                               KEY_ALL_ACCESS,
                               &hAdapterKey );

        if ( status != ERROR_SUCCESS )
        {
            goto Exit;
        }

        //
        // Found an adapter in the registry, read registered since
        // boot value to see if FALSE.
        //
        status = GetRegistryValue( hAdapterKey,
                                   REGISTERED_SINCE_BOOT,
                                   REG_DWORD,
                                   (LPBYTE)&dwRegistered );

        RegCloseKey( hAdapterKey );
        hAdapterKey = NULL;

        if ( status != ERROR_SUCCESS )
        {
            goto Exit;
        }

        if ( dwRegistered == 0 &&
             (pregEntry = ReadUpdateEntryFromRegistry( szName )) )
        {
            if ( pregEntry->fRegisteredFWD ||
                 pregEntry->fRegisteredPRI ||
                 pregEntry->fRegisteredPTR )
            {
                ASYNCREG_F2( "Found unused adapter: %s", szName );
                ASYNCREG_F1( "Removing entry from registry and adding" );
                ASYNCREG_F1( "delete entry to registration list" );

                //
                // This adapter has not been configured since boot time,
                // create delete update entry for registry information
                // and add to registration list. Clear registry in the
                // mean time.
                //
                pregEntry->fRemove = TRUE;
                pregEntry->Flags |= DYNDNS_DEL_ENTRY;

                pregEntry->fRegisteredFWD = FALSE;
                pregEntry->fRegisteredPRI = FALSE;
                pregEntry->fRegisteredPTR = FALSE;

                if ( fPurgeMode )
                {
                    pregEntry->RetryCount = 2;
                    pregEntry->RetryTime = Dns_GetCurrentTimeInSeconds();
                }

                //
                // Clear registry key for adapter
                //
                WriteUpdateEntryToRegistry( pregEntry );
                index--;

                //
                // Put update in registration list
                //
                enqueueUpdate( pregEntry );

                PulseEvent( g_hNewItemEvent );
            }
            else
            {
                ASYNCREG_F2( "Found unused adapter: %s", szName );
                ASYNCREG_F1( "This adapter is still pending an update, ignoring . . ." );

                //
                // We are only just starting to try to update this entry.
                // Do not queue up a delete for it since the entry shows
                // that no records have been registered anyhow.
                //

                FreeUpdateEntry( pregEntry );
                pregEntry = NULL;
            }
        }

        index++;
    }

Exit :

    if ( hAdapterKey )
    {
        RegCloseKey( hAdapterKey );
    }
}


PDNS_RECORD
GetPreviousRegistrationInformation(
    IN      PUPDATE_ENTRY   pUpdateEntry,
    IN      BOOL            fPrimaryDomain,
    OUT     PIP_ADDRESS     pServerIp
    )
{
    DWORD           retVal = NO_ERROR;
    DWORD           status = NO_ERROR;
    CHAR            szName[MAX_PATH];
    INT             index;
    DWORD           dwBytesRead = MAX_PATH -1;
    DWORD           dwRegistered = 0;
    PUPDATE_ENTRY   pregEntry = NULL;
    PDNS_RECORD     precords = NULL;
    PSTR            pdomain;

    DNSDBG( TRACE, (
        "GetPreviousRegistrationInformation( %p )\n",
        pUpdateEntry ));


    //
    //  determine desired domain name to use
    //

    if ( fPrimaryDomain )
    {
        pdomain = pUpdateEntry->PrimaryDomainName;
    }
    else
    {
        pdomain = pUpdateEntry->DomainName;
    }
    if ( !pdomain )
    {
        goto Exit;
    }

    index = 0;

    while ( !retVal )
    {
        dwBytesRead = MAX_PATH - 1;

        retVal = RegEnumKeyEx(
                        g_hKey,
                        index,
                        szName,
                        &dwBytesRead,
                        NULL,
                        NULL,
                        NULL,
                        NULL );
        if ( retVal )
        {
            goto Exit;
        }

        //
        // Skip past registry information for the given adapter name
        //
        if ( !_stricmp( szName, pUpdateEntry->AdapterName ) )
        {
            index++;
            continue;
        }

        //
        // Found an adapter in the registry
        //

        pregEntry = ReadUpdateEntryFromRegistry( szName );
        if ( pregEntry )
        {
            //
            // See if registered entry is related to update entry
            // ( same HostName and DomainName )
            //
            if ( Dns_NameCompare_UTF8(
                        pregEntry->HostName,
                        pUpdateEntry->HostName )
                 &&
                 (  Dns_NameCompare_UTF8(
                        pregEntry->DomainName,
                        pdomain )
                    ||
                    Dns_NameCompare_UTF8(
                        pregEntry->PrimaryDomainName,
                        pdomain ) ) )
            {
                BOOL    fUsePrimary = TRUE;

                if ( Dns_NameCompare_UTF8(
                            pregEntry->DomainName,
                            pdomain ) )
                {
                    fUsePrimary = FALSE;
                }

                //
                // PHASE 1 - COMPARE SOAS FROM REGISTRY AND UPDATE ENTRIES
                //           IF SAME, ADD TO LIST. ELSE, TOSS.
                //
                // PHASE 2 - COMPARE NS RECORDS FROM BOTH ENTRIES
                //           IF SAME ZONE AND SERVER, ADD TO LIST. ELSE, TOSS.
                //
                // PHASE 3 - COMPARE NS RECORDS FROM BOTH ENTRIES
                //           IF SAME ZONE AND THERE IS AN INTERSECTION OF
                //           SERVERS, ADD TO LIST. ELSE, TOSS.
                //           NOTE: FOR THIS PHASE, THERE HAD BETTER BE ALL
                //                 SOAS RETURNED TO TEST INTERSECTION?
                //

                if ( CompareMultiAdapterSOAQueries(
                            pdomain,
                            pUpdateEntry->DnsServerList,
                            pregEntry->DnsServerList ) )
                {
                    PDNS_RECORD prr;

                    //
                    // Convert registered entry to a PDNS_RECORD and
                    // add to current list
                    //
                    prr = CreateForwardRecords(
                                    pregEntry,
                                    fUsePrimary );
                    if ( prr )
                    {
                        precords = Dns_RecordListAppend(
                                        precords,
                                        prr );
                        if ( pServerIp &&
                             *pServerIp == 0 &&
                             pUpdateEntry->RetryCount == 0 &&
                             pregEntry->SentUpdateToIp )
                        {
                            *pServerIp = pregEntry->SentUpdateToIp;
                        }
                    }
                }
            }

            FreeUpdateEntry( pregEntry );
            pregEntry = NULL;
        }

        index++;
    }

Exit:

    DNSDBG( TRACE, (
        "Leave  GetPreviousRegistrationInformation()\n"
        "\tprevious records = %p\n",
        precords ));

    return( precords );
}



PDNS_RECORD
CreateDnsRecordSetUnion(
    IN      PDNS_RECORD     pSet1,
    IN      PDNS_RECORD     pSet2
    )
{
    PDNS_RECORD pSet1Copy = NULL;
    PDNS_RECORD pSet2Copy = NULL;

    pSet1Copy = Dns_RecordSetCopyEx(
                    pSet1,
                    DnsCharSetUtf8,
                    DnsCharSetUtf8 );
    if ( !pSet1Copy )
    {
        return NULL;
    }
    pSet2Copy = Dns_RecordSetCopyEx(
                    pSet2,
                    DnsCharSetUtf8,
                    DnsCharSetUtf8 );
    if ( !pSet2Copy )
    {
        Dns_RecordListFree( pSet1Copy );
        return NULL;
    }

    return Dns_RecordListAppend( pSet1Copy, pSet2Copy );
}



//
//  Logging
//


#if 1 // DBG

VOID 
LogHostEntries(
    IN  DWORD                dwHostAddrCount,
    IN  PREGISTER_HOST_ENTRY pHostAddrs
    )
{
    DWORD iter;

    for ( iter = 0; iter < dwHostAddrCount; iter++ )
    {
        ASYNCREG_F3( "    HostAddrs[%d].dwOptions : 0x%x",
                     iter,
                     pHostAddrs[iter].dwOptions );

        if ( pHostAddrs->dwOptions & REGISTER_HOST_A )
        {
            ASYNCREG_F6( "    HostAddrs[%d].Addr.ipAddr : %d.%d.%d.%d",
                         iter,
                         ((BYTE *) &pHostAddrs[iter].Addr.ipAddr)[0],
                         ((BYTE *) &pHostAddrs[iter].Addr.ipAddr)[1],
                         ((BYTE *) &pHostAddrs[iter].Addr.ipAddr)[2],
                         ((BYTE *) &pHostAddrs[iter].Addr.ipAddr)[3] );
        }
        else if ( pHostAddrs->dwOptions & REGISTER_HOST_AAAA )
        {
            ASYNCREG_F6( "    HostAddrs[%d].Addr.ipV6Addr : %d.%d.%d.%d",
                         iter,
                         ((DWORD *) &pHostAddrs[iter].Addr.ipV6Addr)[0],
                         ((DWORD *) &pHostAddrs[iter].Addr.ipV6Addr)[1],
                         ((DWORD *) &pHostAddrs[iter].Addr.ipV6Addr)[2],
                         ((DWORD *) &pHostAddrs[iter].Addr.ipV6Addr)[3] );
        }
        else
        {
            ASYNCREG_F1( "ERROR: HostAddrs[%d].Addr UNKNOWN ADDRESS TYPE!" );
        }
    }
}

#endif


#if 1 // DBG


VOID 
LogPipAddress(
    IN  DWORD       dwServerListCount,
    IN  PIP_ADDRESS pServers
    )
{
    DWORD iter;

    for ( iter = 0; iter < dwServerListCount; iter++ )
    {
        ASYNCREG_F6( "    Server [%d] : %d.%d.%d.%d",
                     iter,
                     ((BYTE *) &pServers[iter])[0],
                     ((BYTE *) &pServers[iter])[1],
                     ((BYTE *) &pServers[iter])[2],
                     ((BYTE *) &pServers[iter])[3] );
    }
}

#endif


#if 1 // DBG


VOID 
LogPipArray(
    IN  PIP_ARRAY pServers
    )
{
    DWORD count;
    DWORD iter;

    if ( pServers )
    {
        count = pServers->AddrCount;
    }
    else
    {
        return;
    }

    for ( iter = 0; iter < count; iter++ )
    {
        ASYNCREG_F6( "    Server [%d] : %d.%d.%d.%d",
                     iter,
                     ((BYTE *) &pServers->AddrArray[iter])[0],
                     ((BYTE *) &pServers->AddrArray[iter])[1],
                     ((BYTE *) &pServers->AddrArray[iter])[2],
                     ((BYTE *) &pServers->AddrArray[iter])[3] );
    }
}

#endif



DNS_STATUS
alertOrStartRegistrationThread(
    VOID
    )
/*++

Routine Description:

    Alerts registration thread of new update, starting thread if necessary.

    This is called in registration\deregistration functions to ensure
    thread has been started.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DWORD       threadId;
    DNS_STATUS  Status;

    ASYNCREG_F1( "Inside alertOrStartRegistrationThread()\n" );

    //
    //  must lock to avoid multiple async start
    //
    //  DCR_PERF:  use a single general CS for init protect issues
    //      simply check
    //          - done => bail
    //          - not done => dumb wait (sleep, check)
    //

    EnterCriticalSection( &g_RegistrationThreadCS );

    if ( g_hRegistrationThread )
    {
        LeaveCriticalSection( &g_RegistrationThreadCS );
        PulseEvent( g_hNewItemEvent );

        return( ERROR_SUCCESS );
    }

    //
    //  if not started, fire it up
    //

    Status = ERROR_SUCCESS;
    g_fQuit = FALSE;
    g_fShutdown = FALSE;
    ResetEvent( g_hStopEvent );
    ResetEvent( g_hThreadDeadEvent );

    g_hRegistrationThread = CreateThread(
                                NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)
                                RegistrationThread,
                                NULL,
                                0,
                                & threadId );

    if ( ! g_hRegistrationThread )
    {
        Status = GetLastError();
    }

    LeaveCriticalSection( &g_RegistrationThreadCS );
    return( Status );
}



VOID
registerUpdateStatus(
    IN OUT  PREGISTER_HOST_STATUS   pRegstatus,
    IN      DNS_STATUS              Status
    )
/*++

Routine Description:

    Set Status and signal completion.

Arguments:

    pRegstatus -- registration Status block to indicate

    Status -- Status to indicate

Return Value:

    None

--*/
{
    //  test for existence and event

    if ( !pRegstatus || !pRegstatus->hDoneEvent )
    {
        return;
    }

    //  set return Status
    //  signal event

    pRegstatus->dwStatus = Status;

    SetEvent( pRegstatus->hDoneEvent );
}



VOID
enqueueUpdate(
    IN OUT  PUPDATE_ENTRY   pUpdate
    )
/*++

Routine Description:

    Queue update on registration queue.

Arguments:

    pUpdate -- update completed

Return Value:

    None

--*/
{
    EnterCriticalSection( &g_RegistrationListCS );
    InsertTailList( &g_RegistrationList, (PLIST_ENTRY)pUpdate );
    LeaveCriticalSection( &g_RegistrationListCS );
}



VOID
enqueueUpdateMaybe(
    IN OUT  PUPDATE_ENTRY   pUpdate
    )
/*++

Routine Description:

    Queue update on registration queue, only if there does not exist
    any updates in the queue already for the given adapter.

Arguments:

    pUpdate -- update completed

Return Value:

    None

--*/
{
    PLIST_ENTRY       plistHead;
    PLIST_ENTRY       pentry;
    BOOL              fAdd = TRUE;

    EnterCriticalSection( &g_RegistrationListCS );

    plistHead = &g_RegistrationList;
    pentry = plistHead->Flink;

    while ( pentry != plistHead )
    {
        if ( !_stricmp( ((PUPDATE_ENTRY) pentry)->AdapterName,
                        pUpdate->AdapterName ) )
        {
            fAdd = FALSE;
            break;
        }

        pentry = pentry->Flink;
    }

    if ( fAdd )
    {
        InsertTailList( &g_RegistrationList, (PLIST_ENTRY)pUpdate );
    }
    else
    {
        FreeUpdateEntry( pUpdate );
    }

    LeaveCriticalSection( &g_RegistrationListCS );
}



PLIST_ENTRY
dequeueAndCleanupUpdate(
    IN OUT  PLIST_ENTRY     pUpdateEntry
    )
/*++

Routine Description:

    Dequeue and free update.

    Includes any registration Status setting.

Arguments:

    pUpdateEntry -- pUpdateEntry

Return Value:

    Ptr to next update in queue.

--*/
{
    PLIST_ENTRY pnext = pUpdateEntry->Flink;

    RemoveEntryList( pUpdateEntry );

    if ( ((PUPDATE_ENTRY)pUpdateEntry)->pRegisterStatus )
    {
        registerUpdateStatus(
            ((PUPDATE_ENTRY)pUpdateEntry)->pRegisterStatus,
            ERROR_SUCCESS );
    }

    FreeUpdateEntry( (PUPDATE_ENTRY) pUpdateEntry );

    return( pnext );
}



BOOL
searchForOldUpdateEntriesAndCleanUp(
    IN      PSTR            pszAdapterName,
    IN      PUPDATE_ENTRY   pUpdateEntry,    OPTIONAL
    IN      BOOL            fLookInRegistry
    )
/*++

Routine Description:

    Searches registry for any previous registrations for a given adapter
    name and queues up a delete update entry for it. Then walks the update
    registration list to remove any add updates for the given adapter.

Arguments:

    pszAdapterName -- name of adapters that is going away (disabled for
    DDNS or now removed).

Return Value:

    Flag to indicate whether a delete update has been queued up ready to
    be processed.

--*/
{
    PUPDATE_ENTRY pregEntry = NULL;
    BOOL              fReturn = FALSE;
    PLIST_ENTRY       plistHead;
    PLIST_ENTRY       pentry;

    //
    // See if this adapter has been previously registered
    //
    if ( fLookInRegistry &&
         (pregEntry = ReadUpdateEntryFromRegistry( pszAdapterName )) )
    {
        pregEntry->fRemove = TRUE;
        pregEntry->Flags |= DYNDNS_DEL_ENTRY;

        pregEntry->fRegisteredFWD = FALSE;
        pregEntry->fRegisteredPRI = FALSE;
        pregEntry->fRegisteredPTR = FALSE;

        //
        // Clear registry key for adapter
        //
        WriteUpdateEntryToRegistry( pregEntry );

        //
        // Put update in registration list
        //
        enqueueUpdate( pregEntry );

        fReturn = TRUE; // We have queued a delete update to process.
    }

    //
    // Now walk the pending update list looking for updates that should
    // be removed for the given adapter name.
    //
    EnterCriticalSection( &g_RegistrationListCS );

    plistHead = &g_RegistrationList;
    pentry = plistHead->Flink;

    while ( pentry != plistHead )
    {
        if ( !_stricmp( ((PUPDATE_ENTRY) pentry)->AdapterName,
                        pszAdapterName ) &&
             !((PUPDATE_ENTRY) pentry)->fRemove )
        {
            //
            // There is an update entry in the registration list
            // that has the same adapter name. We need to get rid of
            // this entry since the adapter is being deleted.
            //

            if ( pUpdateEntry &&
                 compareUpdateEntries( (PUPDATE_ENTRY) pentry,
                                       pUpdateEntry ) )
            {
                //
                // The adapter entry in the queue is the same as the
                // one being being processed. i.e. All of the adapter
                // information seems to be the same and we must have
                // just been called to refresh the adapter info in DNS.
                // Since they are the same, if we have previously tried
                // an update with these settings and failed and have
                // already logged an event, then there is no reason to
                // repeat the error event in the retries to follow
                // on the new pUpdateEntry. That said, we'll copy over
                // the flag from the queued update to the new one . . .
                //

                pUpdateEntry->fDisableErrorLogging =
                    ((PUPDATE_ENTRY) pentry)->fDisableErrorLogging;
            }

            pentry = dequeueAndCleanupUpdate( pentry );
            continue;
        }
        else if ( !_stricmp( ((PUPDATE_ENTRY) pentry)->AdapterName,
                             pszAdapterName ) )
        {
            if ( !fLookInRegistry &&
                 pUpdateEntry &&
                 compareUpdateEntries( (PUPDATE_ENTRY) pentry,
                                       pUpdateEntry ) )
            {
                //
                // There is a delete update entry in the registration list
                // that has the same adapter data. Get rid of this delete
                // entry since the adapter is being updated again.
                //

                pentry = dequeueAndCleanupUpdate( pentry );
                continue;
            }
            else
            {
                //
                // There is a delete update entry in the registration list for
                // the same adapter that contains different data, have the
                // delete update set to new with a retry count of 2.
                //
                ((PUPDATE_ENTRY) pentry)->fNewElement = TRUE;
                ((PUPDATE_ENTRY) pentry)->fRegisteredFWD = FALSE;
                ((PUPDATE_ENTRY) pentry)->fRegisteredPRI = FALSE;
                ((PUPDATE_ENTRY) pentry)->fRegisteredPTR = FALSE;
                ((PUPDATE_ENTRY) pentry)->fDisableErrorLogging = FALSE;
                ((PUPDATE_ENTRY) pentry)->RetryCount = 2;
                ((PUPDATE_ENTRY) pentry)->RetryTime =
                Dns_GetCurrentTimeInSeconds();

                pentry = pentry->Flink;
            }
        }
        else
        {
            pentry = pentry->Flink;
        }
    }

    LeaveCriticalSection( &g_RegistrationListCS );

    return fReturn;
}



BOOL
compareHostEntryAddrs(
    IN      PREGISTER_HOST_ENTRY    Addrs1,
    IN      PREGISTER_HOST_ENTRY    Addrs2,
    IN      DWORD                   Count
    )
{
    DWORD iter;

    for ( iter = 0; iter < Count; iter++ )
    {
        if ( ( Addrs1[iter].dwOptions & REGISTER_HOST_A ) &&
             ( Addrs2[iter].dwOptions & REGISTER_HOST_A ) )
        {
            if ( memcmp( &Addrs1[iter].Addr.ipAddr,
                         &Addrs2[iter].Addr.ipAddr,
                         sizeof( IP_ADDRESS ) ) )
            {
                return FALSE;
            }
        }
        else if ( ( Addrs1[iter].dwOptions & REGISTER_HOST_AAAA ) &&
                  ( Addrs2[iter].dwOptions & REGISTER_HOST_AAAA ) )
        {
            if ( memcmp( &Addrs1[iter].Addr.ipV6Addr,
                         &Addrs2[iter].Addr.ipV6Addr,
                         sizeof( IP6_ADDRESS  ) ) )
            {
                return FALSE;
            }
        }
        else
        {
            return FALSE;
        }
    }

    return TRUE;
}



//
//  Routines for update entry comparison
//

BOOL
compareServerLists(
    IN      PIP_ARRAY       List1,
    IN      PIP_ARRAY       List2
    )
{
    if ( List1 && List2 )
    {
        if ( List1->AddrCount != List2->AddrCount )
        {
            return FALSE;
        }

        if ( memcmp( List1->AddrArray,
                     List2->AddrArray,
                     sizeof( IP_ADDRESS ) * List1->AddrCount ) )
        {
            return FALSE;
        }
    }

    return TRUE;
}



BOOL
compareUpdateEntries(
    IN      PUPDATE_ENTRY   pUpdateEntry1,
    IN      PUPDATE_ENTRY   pUpdateEntry2
    )
/*++

Routine Description:

    Compares to update entries to see if they are describing the same
    adapter configuration settings. Tests the domain names, the IP
    address(es), host names, and the DNS server lists.

Arguments:

    pUdapteEntry1 - one of the update entries to compare against the other.
    pUdapteEntry2 - one of the update entries to compare against the other.

Return Value:

    Flag to indicate whether a the two updates are the same.

--*/
{
    if ( !pUpdateEntry1 || !pUpdateEntry2 )
    {
        return FALSE;
    }

    if ( ( pUpdateEntry1->HostName || pUpdateEntry2->HostName ) &&
         !Dns_NameCompare_UTF8( pUpdateEntry1->HostName,
                                pUpdateEntry2->HostName ) )
    {
        return FALSE;
    }

    if ( ( pUpdateEntry1->DomainName || pUpdateEntry2->DomainName ) &&
         !Dns_NameCompare_UTF8( pUpdateEntry1->DomainName,
                                pUpdateEntry2->DomainName ) )
    {
        return FALSE;
    }

    if ( ( pUpdateEntry1->PrimaryDomainName || pUpdateEntry2->PrimaryDomainName )
            &&
           ! Dns_NameCompare_UTF8(
                pUpdateEntry1->PrimaryDomainName,
                pUpdateEntry2->PrimaryDomainName ) )
    {
        return FALSE;
    }

    if ( pUpdateEntry1->HostAddrCount != pUpdateEntry2->HostAddrCount ||
         ! compareHostEntryAddrs(
                pUpdateEntry1->HostAddrs,
                pUpdateEntry2->HostAddrs,
                pUpdateEntry1->HostAddrCount ) )
    {
        return FALSE;
    }

    if ( pUpdateEntry1->DnsServerList &&
         pUpdateEntry2->DnsServerList &&
         ! compareServerLists(
                pUpdateEntry1->DnsServerList,
                pUpdateEntry2->DnsServerList ) )
    {
        return FALSE;
    }

    return TRUE;
}



//
//  Glenn's old registry function
//
//  No longer in use anywhere else but still used in these
//  registration (dynreg and asyncreg) modules.
//

DWORD
GetRegistryValue(
    HKEY    KeyHandle,
    PSTR    ValueName,
    DWORD   ValueType,
    PBYTE   BufferPtr
    )
/*++

Routine Description:

    This function retrieves the value of the specified value field. This
    function allocates memory for variable length fields such as REG_SZ.
    For REG_DWORD data type, it copies the field value directly into
    BufferPtr. If fIsWin9X is NOT set, all string types are read as
    UNICODE (W) and then converted to UTF8 format. Currently it can
    handle only the following fields :

    REG_DWORD,
    REG_SZ,
    REG_MULTI_SZ,
    REG_EXPAND_SZ
    REG_BINARY

Arguments:

    KeyHandle : handle of the key whose value field is retrieved.

    ValueName : name of the value field.

    ValueType : Expected type of the value field.

    BufferPtr : Pointer to DWORD location where a DWORD datatype value
                is returned or a buffer pointer for REG_SZ or REG_BINARY
                datatype value is returned.

Return Value:

    Registry Errors.

--*/
{
    DWORD   Error;
    DWORD   LocalValueType;
    DWORD   ValueSize;
    PBYTE   DataBuffer = NULL;
    PBYTE   AllotedBuffer = NULL;
    PWSTR   ValueNameW = NULL;


    //
    //  DCR_PERF:  heap buffer for name is stupid (MAX_PATH covers it)
    //

    DWORD Length = ( strlen( ValueName )  + 1 ) * sizeof( WCHAR );
    ValueNameW = ALLOCATE_HEAP( Length );

    if ( !ValueNameW )
    {
        return DNS_ERROR_NO_MEMORY;
    }

    Dns_Utf8ToUnicode( ValueName,
                       strlen( ValueName ),
                       ValueNameW,
                       Length );

    //
    //  Query DataType and BufferSize.
    //

    Error = RegQueryValueExW( KeyHandle,
                              ValueNameW,
                              0,
                              &LocalValueType,
                              NULL,
                              &ValueSize );

    if ( Error != ERROR_SUCCESS )
    {
        FREE_HEAP( ValueNameW );
        return(Error);
    }
    

    switch( ValueType )
    {
        case REG_DWORD:
            DataBuffer = BufferPtr;
            break;

        case REG_SZ:
        case REG_MULTI_SZ:
        case REG_EXPAND_SZ:
        case REG_BINARY:

            if ( ValueSize == 0 )
            {
                //
                // if string not found in the registry,
                // allocate space for null string.
                //

                ValueSize = sizeof(WCHAR);
            }

            AllotedBuffer = DataBuffer = ALLOCATE_HEAP( ValueSize );

            if ( DataBuffer == NULL )
            {
                return( DNS_ERROR_NO_MEMORY );
            }

            break;

        default:
            FREE_HEAP( ValueNameW );
            return( ERROR_INVALID_PARAMETER );
    }

    //
    // retrieve data.
    //

    Error = RegQueryValueExW( KeyHandle,
                              ValueNameW,
                              0,
                              &LocalValueType,
                              DataBuffer,
                              &ValueSize );

    FREE_HEAP( ValueNameW );

    if ( Error != ERROR_SUCCESS )
    {
        if ( AllotedBuffer )
        {
            FREE_HEAP( AllotedBuffer );
        }

        *(DWORD *)BufferPtr = 0;

        return(Error);
    }
    
    switch( ValueType )
    {
        case REG_BINARY:

            if ( ValueSize == 0 )
            {
                //
                // if string no found in the registry,
                // return null string.
                //

                *(LPWSTR)DataBuffer = '\0';
            }

            *(LPBYTE *)BufferPtr = DataBuffer;

            break;

        case REG_SZ:
        case REG_EXPAND_SZ:
        case REG_MULTI_SZ:

            if ( ValueSize == 0 )
            {
                //
                // if string no found in the registry,
                // return null string.
                //

                *(LPWSTR)DataBuffer = '\0';
            }

            {
                LPBYTE Utf8Buffer = ALLOCATE_HEAP( ValueSize * 2 );

                if ( Utf8Buffer == NULL )
                {
                    return( DNS_ERROR_NO_MEMORY );
                }

                if ( !Dns_UnicodeToUtf8( (LPWSTR) DataBuffer,
                                         ValueSize / sizeof(WCHAR),
                                         Utf8Buffer,
                                         ValueSize * 2 ) )
                {
                    FREE_HEAP( DataBuffer );
                    return ERROR_INVALID_PARAMETER;
                }

                FREE_HEAP( DataBuffer );
                *(LPBYTE *)BufferPtr = Utf8Buffer;
            }
            break;

        default:
            break;
    }

    return( Error );
}




//
//  Jim Utils
//

PDNS_RECORD
CreatePtrRecord(
    IN      PSTR            pszHostName,
    IN      PSTR            pszDomainName,
    IN      IP4_ADDRESS     Ip4Addr,
    IN      DWORD           Ttl
    )
/*++

Routine Description:

    Create PTR record for update from IP and host and domain names.

Arguments:


Return Value:

    PTR record to use in update.

--*/
{
    IP_UNION    ipUnion;

    DNSDBG( TRACE, (
        "CreatePtrRecord( %s, %s, %s )\n",
        pszHostName,
        pszDomainName,
        IP_STRING( Ip4Addr ) ));

    IPUNION_SET_IP4( &ipUnion, Ip4Addr );

    return  Dns_CreatePtrRecordExEx(
                    & ipUnion,
                    pszHostName,
                    pszDomainName,
                    Ttl,
                    DnsCharSetUtf8,     // from UTF8
                    DnsCharSetUtf8      // to UTF8
                    );
}



VOID
UpdatePtrRecords(
    IN OUT  PUPDATE_ENTRY   pUpdateEntry,
    IN      BOOL            fAdd
    )
/*++

Routine Description:

    Register PTR records for an update entry.

Arguments:

    pUpdateEntry -- update being processed

    fAdd -- TRUE for add;  FALSE for delete

Return Value:

    PTR record to use in update.

--*/
{
    DWORD           iter;
    PDNS_RECORD     prr = NULL;
    DNS_STATUS      status = NO_ERROR;
    IP_ADDRESS      ipServer;
    DNS_RRSET       rrset;
    PSTR            pdomain = NULL;
    PSTR            pprimary = NULL;
    DWORD           ttl = pUpdateEntry->TTL;
    PSTR            phostname = pUpdateEntry->HostName;


    DNSDBG( TRACE, (
        "UpdatePtrRecords( %p, fAdd=%d )\n",
        pUpdateEntry,
        fAdd ));

    IF_DNSDBG( TRACE )
    {
        DnsDbg_UpdateEntry(
            "Entering UpdatePtrRecords:",
            pUpdateEntry );
    }

    //
    //  make sure we have update to do
    //  only do ADD updates if forward registrations were
    //      successful
    //

    pdomain  = pUpdateEntry->DomainName;
    pprimary = pUpdateEntry->PrimaryDomainName;

    if ( fAdd )
    {
        if ( !pUpdateEntry->fRegisteredFWD )
        {
            pdomain = NULL;
        }
        if ( !pUpdateEntry->fRegisteredPRI )
        {
            pprimary = NULL;
        }
    }
    if ( !pdomain && !pprimary )
    {
        DNSDBG( TRACE, (
            "UpdatePtrRecords() => no forward registrations"
            "-- skipping PTR update.\n" ));
        return;
    }

    //
    //  build PTR (or set) for each IP in update entry
    //

    for ( iter = 0; iter < pUpdateEntry->HostAddrCount; iter++ )
    {
        IP4_ADDRESS ip = pUpdateEntry->HostAddrs[iter].Addr.ipAddr;

        if ( ip == 0 || ip == DNS_NET_ORDER_LOOPBACK )
        {
            DNS_ASSERT( FALSE );
            continue;
        }

        //
        //   build update PTR set
        //      - primary name
        //      - adapter name
        //

        DNS_RRSET_INIT( rrset );

        if ( pprimary )
        {
            prr = CreatePtrRecord(
                        phostname,
                        pprimary,
                        ip,
                        ttl );
            if ( prr )
            {
                DNS_RRSET_ADD( rrset, prr );
            }
        }
        if ( pdomain )
        {
            prr = CreatePtrRecord(
                        phostname,
                        pdomain,
                        ip,
                        ttl );
            if ( prr )
            {
                DNS_RRSET_ADD( rrset, prr );
            }
        }
        prr = rrset.pFirstRR;
        if ( !prr )
        {
            continue;
        }

        //
        //  do update
        //
        //  for ADD     => replace, we own the IP address now
        //  for REMOVE  => modify, as another update might have already
        //                  written correct info
        //

        if ( fAdd )
        {
            status = DnsReplaceRecordSetUTF8(
                            prr,                    // update set
                            DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                            NULL,                   // no security context
                            (PIP4_ARRAY) pUpdateEntry->DnsServerList,
                            NULL                    // reserved
                            );
        }
        else
        {
            status = DnsModifyRecordsInSet_UTF8(
                            NULL,           // no add records
                            prr,            // delete records
                            DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                            NULL,           // no context handle
                            pUpdateEntry->DnsServerList,
                            NULL            // reserved
                            );
        }
        DNSDBG( TRACE, (
            "%s on PTRs for IP %s => %d (%s)\n",
            fAdd
                ? "Replace"
                : "Modify (remove)",
            IP_STRING(ip),
            status,
            Dns_StatusString(status) ));

        ipServer = 0;

        if ( status == NO_ERROR ||
             // status == DNS_ERROR_RCODE_SERVER_FAILURE ||
             status == DNS_ERROR_RCODE_NOT_IMPLEMENTED ||
             status == DNS_ERROR_RCODE_REFUSED ||
             status == DNS_ERROR_RCODE_YXRRSET ||
             status == DNS_ERROR_RCODE_NXRRSET )
        {
            ipServer = DnsGetLastServerUpdateIP();
        }

        if ( !fAdd ||
             pUpdateEntry->RetryCount == 2 )
        {
            LogRegistration(
                pUpdateEntry,
                status,
                UPTYPE_PTR,
                !fAdd,
                ipServer,
                ip );
        }

        //  note successful PTR registrations (adds)

        if ( fAdd && status==NO_ERROR )
        {
            pUpdateEntry->fRegisteredPTR = TRUE;
        }
        Dns_RecordListFree( prr );
    }

    DNSDBG( TRACE, (
        "Leave UpdatePtrRecords()\n" ));
}



PDNS_RECORD
CreateForwardRecords(
    IN      PUPDATE_ENTRY   pUpdateEntry,
    IN      UPTYPE          UpType
    )
/*++

Routine Description:

    Create A records for update.

Arguments:

    pUpdateEntry -- update entry

    UpType -- update type
        UPTYPE_DOMAIN
        UPTYPE_PRIMARY
        UPTYPE_ALTERNATE

Return Value:

    Ptr to list of A records.

--*/
{
    PDNS_RECORD prr = NULL;
    PSTR        pname;
    DWORD       iter;
    CHAR        nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    DNS_RRSET   rrset;


    DNSDBG( TRACE, (
        "CreateForwardRecords( %p, %d )\n",
        pUpdateEntry,
        UpType ));

    //
    //  build FQDN
    //
    //  for alternate name, go to name for desired index
    //

    if ( IS_UPTYPE_ALTERNATE(UpType) )
    {
        DWORD   count = pUpdateEntry->AlternateIndex;

        pname = pUpdateEntry->AlternateNames;
        
        while ( count-- )
        {
            pname = MultiSz_NextString_A( pname );
            if ( !pname )
            {
                DNSDBG( ANY, (
                    "ERROR:  Alternate count %d does NOT exist in name!\n",
                    pUpdateEntry->AlternateIndex ));
                DNS_ASSERT( FALSE );
                return  NULL;
            }
        }
        DNSDBG( DHCP, (
            "Create records with alternate name %s\n",
            pname ));
    }
    else
    {
        PSTR    pdomain = pUpdateEntry->DomainName;

        if ( IS_UPTYPE_PRIMARY(UpType) )
        {
            pdomain = pUpdateEntry->PrimaryDomainName;
        }
        if ( !pdomain || !pUpdateEntry->HostName )
        {
            return NULL;
        }
    
        if ( !Dns_NameAppend_A(
                nameBuffer,
                DNS_MAX_NAME_BUFFER_LENGTH,
                pUpdateEntry->HostName,
                pdomain ) )
        {
            return  NULL;
        }
        pname = nameBuffer;
    }

    //
    //  create records for name
    //

    DNS_RRSET_INIT( rrset );

    for ( iter = 0; iter < pUpdateEntry->HostAddrCount; iter++ )
    {
        if ( !(pUpdateEntry->HostAddrs[iter].dwOptions & REGISTER_HOST_A) )
        {
            continue;
        }

        prr = Dns_CreateARecord(
                    pname,
                    pUpdateEntry->HostAddrs[iter].Addr.ipAddr,
                    pUpdateEntry->TTL,
                    DnsCharSetUtf8,
                    DnsCharSetUtf8 );
        if ( !prr )
        {
            SetLastError( DNS_ERROR_NO_MEMORY );
            Dns_RecordListFree( rrset.pFirstRR );
            return  NULL;
        }

        DNS_RRSET_ADD( rrset, prr );
    }

    DNSDBG( TRACE, (
        "Leave CreateForwardRecords() => %p\n",
        rrset.pFirstRR ));

    return rrset.pFirstRR;
}



VOID
SetUpdateStatus(
    IN OUT  PUPDATE_ENTRY   pUpdateEntry,
    IN      DNS_STATUS      Status,
    IN      UPTYPE          UpType
    )
/*++

Routine Description:

    Set update Status info in update entry.

Arguments:

    pUpdateEntry -- entry to set Status in

    Status -- result of update

    fPrimary -- TRUE if update was for primary name; FALSE otherwise

Return Value:

    None

--*/
{
    IP4_ADDRESS     ipServer = 0;
    BOOL            fregistered = FALSE;

    DNSDBG( TRACE, ( "SetUpdateStatus()\n" ));

    DNS_ASSERT( pUpdateEntry != NULL );

    fregistered = ( Status == NO_ERROR );
    ipServer = DnsGetLastServerUpdateIP();

    if ( IS_UPTYPE_PRIMARY(UpType) )
    {
        pUpdateEntry->SentPriUpdateToIp = ipServer;
        pUpdateEntry->fRegisteredPRI = fregistered;
    }
    else if ( IS_UPTYPE_DOMAIN(UpType) )
    {
        pUpdateEntry->SentUpdateToIp = ipServer;
        pUpdateEntry->fRegisteredFWD = fregistered;
    }
}



VOID
DnsPrint_UpdateEntry(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PUPDATE_ENTRY   pEntry
    )
/*++

Routine Description:

    Print update entry.

Arguments:

    PrintRoutine - routine to print with

    pszHeader   - header

    pEntry      - ptr to update entry

Return Value:

    None.

--*/
{
    DWORD   i;

    if ( !pszHeader )
    {
        pszHeader = "Update Entry:";
    }

    if ( !pEntry )
    {
        PrintRoutine(
            pContext,
            "%s %s\r\n",
            pszHeader,
            "NULL Update Entry ptr." );
        return;
    }

    //  print the struct

    PrintRoutine(
        pContext,
        "%s\r\n"
        "\tPtr                  = %p\n"
        "\tSignatureTop         = %08x\n"
        "\tAdapterName          = %s\n"
        "\tHostName             = %s\n"
        "\tDomainName           = %s\n"
        "\tPrimaryDomainName    = %s\n"
        "\tAlternateName        = %s\n"
        "\tAlternateIndex       = %d\n"
        "\tHostAddrCount        = %d\n"
        "\tHostAddrs            = %p\n"
        "\tDnsServerList        = %p\n"
        "\tSentUpdateToIp       = %s\n"
        "\tSentPriUpdateToIp    = %s\n"
        "\tTTL                  = %d\n"
        "\tFlags                = %08x\n"
        "\tfNewElement          = %d\n"
        "\tfFromRegistry        = %d\n"
        "\tfRemove              = %d\n"
        "\tfRegisteredFWD       = %d\n"
        "\tfRegisteredPRI       = %d\n"
        "\tfRegisteredPTR       = %d\n"
        "\tfDisableLogging      = %d\n"
        "\tRetryCount           = %d\n"
        "\tRetryTime            = %d\n"
        "\tpRegisterStatus      = %p\n"
        "\tSignatureBottom      = %08x\n",
        pszHeader,
        pEntry,
        pEntry->SignatureTop,        
        pEntry->AdapterName,         
        pEntry->HostName,            
        pEntry->DomainName,          
        pEntry->PrimaryDomainName,   
        pEntry->AlternateNames,
        pEntry->AlternateIndex,
        pEntry->HostAddrCount,       
        pEntry->HostAddrs,           
        pEntry->DnsServerList,       
        IP_STRING( pEntry->SentUpdateToIp ),      
        IP_STRING( pEntry->SentPriUpdateToIp ),   
        pEntry->TTL,                 
        pEntry->Flags,               
        pEntry->fNewElement,         
        pEntry->fFromRegistry,
        pEntry->fRemove,             
        pEntry->fRegisteredFWD,      
        pEntry->fRegisteredPRI,      
        pEntry->fRegisteredPTR,      
        pEntry->fDisableErrorLogging,
        pEntry->RetryCount,          
        pEntry->RetryTime,           
        pEntry->pRegisterStatus,     
        pEntry->SignatureBottom     
        );
}



VOID
AsyncLogUpdateEntry(
    IN      PSTR            pszHeader,
    IN      PUPDATE_ENTRY   pEntry
    )
{
    if ( !pEntry )
    {
        return;
    }

    ASYNCREG_F2( "    %s", pszHeader );
    ASYNCREG_F1( "    Update Entry" );
    ASYNCREG_F1( "    ______________________________________________________" );
    ASYNCREG_F2( "      AdapterName       : %s", pEntry->AdapterName );
    ASYNCREG_F2( "      HostName          : %s", pEntry->HostName );
    ASYNCREG_F2( "      DomainName        : %s", pEntry->DomainName );
    ASYNCREG_F2( "      PrimaryDomainName : %s", pEntry->PrimaryDomainName );
    ASYNCREG_F2( "      HostAddrCount     : %d", pEntry->HostAddrCount );
    DNSLOG_HOST_ENTRYS( pEntry->HostAddrCount,
                        pEntry->HostAddrs );
    if ( pEntry->DnsServerList )
    {
        DNSLOG_PIP_ARRAY( pEntry->DnsServerList );
    }
    ASYNCREG_F2( "      TTL               : %d", pEntry->TTL );
    ASYNCREG_F2( "      Flags             : %d", pEntry->Flags );
    ASYNCREG_F2( "      fNewElement       : %d", pEntry->fNewElement );
    ASYNCREG_F2( "      fRemove           : %d", pEntry->fRemove );
    ASYNCREG_F2( "      fRegisteredFWD    : %d", pEntry->fRegisteredFWD );
    ASYNCREG_F2( "      fRegisteredPRI    : %d", pEntry->fRegisteredPRI );
    ASYNCREG_F2( "      fRegisteredPTR    : %d", pEntry->fRegisteredPTR );
    ASYNCREG_F2( "      RetryCount        : %d", pEntry->RetryCount );
    ASYNCREG_F2( "      RetryTime         : %d", pEntry->RetryTime );
    ASYNCREG_F1( "" );
}



//
//  Logging
//

DWORD   RegistrationEventArray[6][6] =
{
    EVENT_DNSAPI_REGISTRATION_FAILED_TIMEOUT,
    EVENT_DNSAPI_REGISTRATION_FAILED_SERVERFAIL,
    EVENT_DNSAPI_REGISTRATION_FAILED_NOTSUPP,
    EVENT_DNSAPI_REGISTRATION_FAILED_REFUSED,
    EVENT_DNSAPI_REGISTRATION_FAILED_SECURITY,
    EVENT_DNSAPI_REGISTRATION_FAILED_OTHER,

    EVENT_DNSAPI_DEREGISTRATION_FAILED_TIMEOUT,
    EVENT_DNSAPI_DEREGISTRATION_FAILED_SERVERFAIL,
    EVENT_DNSAPI_DEREGISTRATION_FAILED_NOTSUPP,
    EVENT_DNSAPI_DEREGISTRATION_FAILED_REFUSED,
    EVENT_DNSAPI_DEREGISTRATION_FAILED_SECURITY,
    EVENT_DNSAPI_DEREGISTRATION_FAILED_OTHER,

    EVENT_DNSAPI_REGISTRATION_FAILED_NOTSUPP_PRIMARY_DN,
    EVENT_DNSAPI_REGISTRATION_FAILED_REFUSED_PRIMARY_DN,
    EVENT_DNSAPI_REGISTRATION_FAILED_TIMEOUT_PRIMARY_DN,
    EVENT_DNSAPI_REGISTRATION_FAILED_SERVERFAIL_PRIMARY_DN,
    EVENT_DNSAPI_REGISTRATION_FAILED_SECURITY_PRIMARY_DN,
    EVENT_DNSAPI_REGISTRATION_FAILED_OTHER_PRIMARY_DN,

    EVENT_DNSAPI_DEREGISTRATION_FAILED_NOTSUPP_PRIMARY_DN,
    EVENT_DNSAPI_DEREGISTRATION_FAILED_REFUSED_PRIMARY_DN,
    EVENT_DNSAPI_DEREGISTRATION_FAILED_TIMEOUT_PRIMARY_DN,
    EVENT_DNSAPI_DEREGISTRATION_FAILED_SERVERFAIL_PRIMARY_DN,
    EVENT_DNSAPI_DEREGISTRATION_FAILED_SECURITY_PRIMARY_DN,
    EVENT_DNSAPI_DEREGISTRATION_FAILED_OTHER_PRIMARY_DN,

    EVENT_DNSAPI_PTR_REGISTRATION_FAILED_TIMEOUT,
    EVENT_DNSAPI_PTR_REGISTRATION_FAILED_SERVERFAIL,
    EVENT_DNSAPI_PTR_REGISTRATION_FAILED_NOTSUPP,
    EVENT_DNSAPI_PTR_REGISTRATION_FAILED_REFUSED,
    EVENT_DNSAPI_PTR_REGISTRATION_FAILED_SECURITY,
    EVENT_DNSAPI_PTR_REGISTRATION_FAILED_OTHER,

    EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_TIMEOUT,
    EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_SERVERFAIL,
    EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_NOTSUPP,
    EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_REFUSED,
    EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_SECURITY,
    EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_OTHER
};

//
//  Map update status to index into table
//
//  This is the outside -- fast varying -- index
//

#define EVENTINDEX_TIMEOUT      (0)
#define EVENTINDEX_SERVFAIL     (1)
#define EVENTINDEX_NOTSUPP      (2)
#define EVENTINDEX_REFUSED      (3)
#define EVENTINDEX_SECURITY     (4)
#define EVENTINDEX_OTHER        (5)

//
//  Map adapter, primary, PTR registration into index into table
//
//  This index +0 for reg, +1 for dereg gives inside index into
//  event table.
//

#define EVENTINDEX_ADAPTER      (0)
#define EVENTINDEX_PRIMARY      (2)
#define EVENTINDEX_PTR          (4)



DWORD
GetUpdateEventId(
    IN      DNS_STATUS      Status,
    IN      UPTYPE          UpType,
    IN      BOOL            fDeregister,
    OUT     PDWORD          pdwLevel
    )
/*++

Routine Description:

    Get event ID.

Arguments:

    Status -- status from update call

    fDeregister -- TRUE if deregistration, FALSE for registration

    fPtr -- TRUE if PTR, FALSE for forward

    fPrimary -- TRUE for primary domain name

Return Value:

    Event Id.
    Zero if no event.

--*/
{
    DWORD   level = EVENTLOG_WARNING_TYPE;
    DWORD   statusIndex;
    DWORD   typeIndex;

    //
    //  find status code
    //

    switch ( Status )
    {
    case NO_ERROR :

        //  success logging in disabled
        return  0;

    case ERROR_TIMEOUT:

        statusIndex = EVENTINDEX_TIMEOUT;
        break;

    case DNS_ERROR_RCODE_SERVER_FAILURE:

        statusIndex = EVENTINDEX_SERVFAIL;
        break;

    case DNS_ERROR_RCODE_NOT_IMPLEMENTED:

        //  NOT_IMPL means no update on DNS server, not a client
        //      specific problem so informational level

        statusIndex = EVENTINDEX_NOTSUPP;
        level = EVENTLOG_INFORMATION_TYPE;
        break;

    case DNS_ERROR_RCODE_REFUSED:

        statusIndex = EVENTINDEX_REFUSED;
        break;

    case DNS_ERROR_RCODE_BADSIG:
    case DNS_ERROR_RCODE_BADKEY:
    case DNS_ERROR_RCODE_BADTIME:

        statusIndex = EVENTINDEX_SECURITY;
        break;

    default:

        statusIndex = EVENTINDEX_OTHER;
        break;
    }

    //
    //  determine interior index for type of update
    //      - all PTR logging is at informational level
    //      - dereg events are one group behind registration events
    //          in table;  just inc index

    if ( IS_UPTYPE_PTR(UpType) )
    {
        typeIndex = EVENTINDEX_PTR;
    }
    else if ( IS_UPTYPE_PRIMARY(UpType) )
    {
        typeIndex = EVENTINDEX_PRIMARY;
    }
    else
    {
        typeIndex = EVENTINDEX_ADAPTER;
    }

    if ( fDeregister )
    {
        typeIndex++;
    }

    //
    //  get event from table
    //

    *pdwLevel = level;

    return  RegistrationEventArray[ typeIndex ][ statusIndex ];
}



VOID
LogRegistration(
    IN      PUPDATE_ENTRY   pUpdateEntry,
    IN      DNS_STATUS      Status,
    IN      DWORD           UpType,
    IN      BOOL            fDeregister,
    IN      IP4_ADDRESS     DnsIp,
    IN      IP4_ADDRESS     UpdateIp
    )
/*++

Routine Description:

    Log register\deregister failure.

Arguments:

    pUpdateEntry -- update entry being executed

    Status -- status from update call

    Type -- UPTYPE  (PRIMARY, ADAPTER, PTR)

    fDeregister -- TRUE if deregistration, FALSE for registration

    DnsIp -- DNS server IP that failed update

    UpdateIp -- IP we tried to update

Return Value:

    None

--*/
{
    PSTR        insertStrings[ 7 ];
    CHAR        serverIpBuffer[ IP4_ADDRESS_STRING_BUFFER_LENGTH ];
    CHAR        serverListBuffer[ (IP4_ADDRESS_STRING_BUFFER_LENGTH+2)*9 ];
    CHAR        ipListBuffer[ (IP4_ADDRESS_STRING_BUFFER_LENGTH+2)*9 ];
    CHAR        hostnameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    CHAR        domainBuffer[ DNS_MAX_NAME_BUFFER_LENGTH*2 ];
    CHAR        errorCodeBuffer[ 25 ];
    DWORD       iter;
    IP4_ADDRESS ip;
    PSTR        pname;
    DWORD       eventId;
    DWORD       level;

    DNSDBG( TRACE, (
        "LogRegistration()\n"
        "\tpEntry       = %p\n"
        "\tStatus       = %d\n"
        "\tUpType       = %d\n"
        "\tfDereg       = %d\n"
        "\tDNS IP       = %s\n"
        "\tUpdate IP    = %s\n",
        pUpdateEntry,
        Status,
        UpType,
        fDeregister,
        IP_STRING( DnsIp ),
        IP_STRING( UpdateIp ) ));

    //
    //  not logging?
    //      - no success logging
    //      - disabled
    //      - on DNS server (which registers itself)
    //  

    if ( Status == NO_ERROR ||
         pUpdateEntry->fDisableErrorLogging ||
         g_IsDnsServer )
    {
        return;
    }

    //
    //  adapter name
    //

    insertStrings[0] = pUpdateEntry->AdapterName;

    //
    //  hostname
    //

    Dns_NameCopy(
        (PCHAR) hostnameBuffer,
        NULL,
        pUpdateEntry->HostName,
        0,
        DnsCharSetUtf8,
        DnsCharSetAnsi );

    insertStrings[1] = hostnameBuffer;

    //
    //  domain name
    //      - name depends on type
    //      - if no name, no logging

    if ( IS_UPTYPE_PTR(UpType) )
    {
        pname = pUpdateEntry->PrimaryDomainName;
        if ( !pname )
        {
            pname = pUpdateEntry->DomainName;
        }
    }
    else if ( IS_UPTYPE_PRIMARY(UpType) )
    {
        pname = pUpdateEntry->PrimaryDomainName;
    }
    else
    {
        pname = pUpdateEntry->DomainName;
    }

    if ( !pname )
    {
        return;
    }

    Dns_NameCopy(
        (PCHAR) domainBuffer,
        NULL,
        pname,
        0,
        DnsCharSetUtf8,
        DnsCharSetAnsi );

    insertStrings[2] = domainBuffer;

    //
    //  DNS server list
    //      - layout comma separated, four per line, limit 8

    {
        PCHAR       pch = serverListBuffer;
        DWORD       count = 0;

        *pch = 0;

        if ( pUpdateEntry->DnsServerList )
        {
            count = pUpdateEntry->DnsServerList->AddrCount;
        }

        for ( iter=0; iter < count; iter++ )
        {
            if ( iter == 0 )
            {
                strcpy( pch, "\t" );
                pch++;
            }
            else
            {
                *pch++ = ',';
                *pch++ = ' ';

                if ( iter == 4 )
                {
                    strcpy( pch, "\r\n\t" );
                    pch += 3;
                }              
                else if ( iter > 8 )
                {
                    strcpy( pch, "..." );
                    break;
                }
            }
            pch = Dns_Ip4AddressToString_A(
                        pch,
                        & pUpdateEntry->DnsServerList->AddrArray[iter]
                        );
        }

        if ( pch == serverListBuffer )
        {
            strcpy( serverListBuffer, "\t<?>" );
        }
        insertStrings[3] = serverListBuffer;
    }

    //
    //  DNS server IP
    //

    ip = DnsIp;
    if ( ip == 0 )
    {
        if ( IS_UPTYPE_PRIMARY(UpType) )
        {
            ip = pUpdateEntry->SentPriUpdateToIp;
        }
        else
        {
            ip = pUpdateEntry->SentUpdateToIp;
        }
    }
    if ( ip )
    {
        sprintf(
            serverIpBuffer,
            "%d.%d.%d.%d",
            (ip & 0xff),
            ((ip>8) & 0xff),
            ((ip>16) & 0xff),
            ((ip>24) & 0xff) );
    }
    else
    {
        strcpy( serverIpBuffer, "<?>" );
    }

    insertStrings[4] = serverIpBuffer;

    //
    //  Update IP
    //      - passed in (for PTR)
    //      - OR get IP list from update entry
    //      - layout comma separated, four per line, limit 8
    //

    ip = UpdateIp;
    if ( ip )
    {
        sprintf(
             ipListBuffer,
             "%d.%d.%d.%d",
             (ip & 0xff),
             ((ip>8) & 0xff),
             ((ip>16) & 0xff),
             ((ip>24) & 0xff) );
    }
    else
    {
        DWORD   count = pUpdateEntry->HostAddrCount;
        PCHAR   pch = ipListBuffer;

        *pch = 0;

        for ( iter=0; iter < count; iter++ )
        {
            if ( iter > 0 )
            {
                *pch++ = ',';
                *pch++ = ' ';

                if ( iter == 4 )
                {
                    strcpy( pch, "\r\n\t" );
                    pch += 3;
                }              
                else if ( iter > 8 )
                {
                    strcpy( pch, "..." );
                    break;
                }
            }
            pch = Dns_Ip4AddressToString_A(
                        pch,
                        & pUpdateEntry->HostAddrs[iter].Addr.ipAddr );
        }

        if ( pch == ipListBuffer )
        {
            strcpy( ipListBuffer, "<?>" );
        }
    }
    insertStrings[5] = ipListBuffer;

    //  terminate insert string array

    insertStrings[6] = NULL;

    //
    //  get event ID for type of update and update status
    //

    eventId = GetUpdateEventId(
                    Status,
                    UpType,
                    fDeregister,
                    & level );
    if ( !eventId )
    {
        DNS_ASSERT( FALSE );
        return;
    }

    //
    //  log the event
    //

    DNSDBG( TRACE, (
        "Logging registration event:\n"
        "\tid           = %d\n"
        "\tlevel        = %d\n"
        "\tstatus       = %d\n"
        "\tfor uptype   = %d\n",
        eventId,
        level,
        Status,
        UpType ));

    DnsLogEvent(
        eventId,
        (WORD) level,
        7,
        insertStrings,
        Status );
}

//
//  End asyncreg.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\config.c ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    config.c

Abstract:

    Domain Name System (DNS) API 

    Configuration routines.

Author:

    Jim Gilroy (jamesg)     September 1999

Revision History:

--*/


#include "local.h"




//
//  Config mapping table.
//
//  Maps config IDs into corresponding registry lookups.
//

typedef struct _ConfigMapping
{
    DWORD       ConfigId;
    DWORD       RegId;
    BOOLEAN     fAdapterAllowed;
    BOOLEAN     fAdapterRequired;
    BYTE        CharSet;
    //BYTE        Reserved;
}
CONFIG_MAPPING, *PCONFIG_MAPPING;

//
//  Mapping table
//

CONFIG_MAPPING  ConfigMappingArray[] =
{
    //  In Win2K

    DnsConfigPrimaryDomainName_W,
        RegIdPrimaryDomainName,
        0,
        0,
        DnsCharSetUnicode,

    DnsConfigPrimaryDomainName_A,
        RegIdPrimaryDomainName,
        0,
        0,
        DnsCharSetAnsi,

    DnsConfigPrimaryDomainName_UTF8,
        RegIdPrimaryDomainName,
        0,
        0,
        DnsCharSetUtf8,

    //  Not available

    DnsConfigAdapterDomainName_W,
        RegIdAdapterDomainName,
        1,
        1,
        DnsCharSetUnicode,

    DnsConfigAdapterDomainName_A,
        RegIdAdapterDomainName,
        1,
        1,
        DnsCharSetAnsi,

    DnsConfigAdapterDomainName_UTF8,
        RegIdAdapterDomainName,
        1,
        1,
        DnsCharSetUtf8,

    //  In Win2K

    DnsConfigDnsServerList,
        RegIdDnsServers,
        1,              // adapter allowed
        0,              // not required
        0,

    //  Not available

    DnsConfigSearchList,
        RegIdSearchList,
        0,              // adapter allowed
        0,              // not required
        0,

    DnsConfigAdapterInfo,
        0,              // no reg mapping
        0,              // adapter allowed
        0,              // not required
        0,

    //  In Win2K

    DnsConfigPrimaryHostNameRegistrationEnabled,
        RegIdRegisterPrimaryName,
        1,              // adapter allowed
        0,              // not required
        0,
    DnsConfigAdapterHostNameRegistrationEnabled,
        RegIdRegisterAdapterName,
        1,              // adapter allowed
        0,              // adapter note required
        0,
    DnsConfigAddressRegistrationMaxCount,
        RegIdRegistrationMaxAddressCount,
        1,              // adapter allowed
        0,              // not required
        0,

    //  In WindowsXP

    DnsConfigHostName_W,
        RegIdHostName,
        0,
        0,
        DnsCharSetUnicode,

    DnsConfigHostName_A,
        RegIdHostName,
        0,
        0,
        DnsCharSetAnsi,

    DnsConfigHostName_UTF8,
        RegIdHostName,
        0,
        0,
        DnsCharSetUtf8,

    //  In WindowsXP



    //
    //  System Public -- Windows XP
    //

    DnsConfigRegistrationEnabled,
        RegIdRegistrationEnabled,
        1,              // adapter allowed
        0,              // not required
        0,

    DnsConfigWaitForNameErrorOnAll,
        RegIdWaitForNameErrorOnAll,
        0,              // no adapter
        0,              // not required
        0,

    //  These exist in system-public space but are
    //  not DWORDs and table is never used for them
    //
    //  DnsConfigNetworkInformation:
    //  DnsConfigSearchInformation:
    //  DnsConfigNetInfo:
};

#define LAST_CONFIG_MAPPED      (DnsConfigHostName_UTF8)

#define CONFIG_TABLE_LENGTH     (sizeof(ConfigMappingArray) / sizeof(CONFIG_MAPPING))



PCONFIG_MAPPING
GetConfigToRegistryMapping(
    IN      DNS_CONFIG_TYPE     ConfigId,
    IN      PCWSTR              pwsAdapterName,
    IN      BOOL                fCheckAdapter
    )
/*++

Routine Description:

    Get registry enum type for config enum type.

    Purpose of this is to do mapping -- thus hiding internal
    registry implemenation -- AND to do check on whether
    adapter info is allowed or required for the config type.

Arguments:

    ConfigId  -- config type

    pwsAdapterName -- adapter name

Return Value:

    Ptr to config to registry mapping -- if found.

--*/
{
    DWORD           iter = 0;
    PCONFIG_MAPPING pfig;

    //
    //  find config
    //
    //  note, using loop through config IDs;  this allows
    //  use to have gap in config table allowing private
    //  ids well separated from public id space
    //

    while ( iter < CONFIG_TABLE_LENGTH )
    {
        pfig = & ConfigMappingArray[ iter ];
        if ( pfig->ConfigId != (DWORD)ConfigId )
        {
            iter++;
            continue;
        }
        goto Found;
    }
    goto Invalid;


Found:

    //
    //  verify adapter info is appropriate to config type
    //

    if ( fCheckAdapter )
    {
        if ( pwsAdapterName )
        {
            if ( !pfig->fAdapterAllowed )
            {
                goto Invalid;
            }
        }
        else
        {
            if ( pfig->fAdapterRequired )
            {
                goto Invalid;
            }
        }
    }
    return pfig;


Invalid:

    DNS_ASSERT( FALSE );
    SetLastError( ERROR_INVALID_PARAMETER );
    return  NULL;
}



DNS_STATUS
LookupDwordConfigValue(
    OUT     PDWORD              pResult,
    IN      DNS_CONFIG_TYPE     ConfigId,
    IN      PWSTR               pwsAdapter
    )
/*++

Routine Description:

    Get registry enum type for config enum type.

    Purpose of this is to do mapping -- thus hiding internal
    registry implemenation -- AND to do check on whether
    adapter info is allowed or required for the config type.

Arguments:

    pResult -- address to recv DWORD result

    ConfigId  -- config type

    pwsAdapter -- adapter name

Return Value:

    ERROR_SUCCESS on successful read.
    ErrorCode on failure.

--*/
{
    PCONFIG_MAPPING pfig;
    DNS_STATUS      status;

    //
    //  verify config is known and mapped
    //

    pfig = GetConfigToRegistryMapping(
                ConfigId,
                pwsAdapter,
                TRUE            // check adapter validity
                );
    if ( !pfig )
    {
        return  ERROR_INVALID_PARAMETER;
    }

    //
    //  lookup in registry
    //

    status = Reg_GetDword(
                NULL,               // no session
                NULL,               // no key given
                pwsAdapter,
                pfig->RegId,        // reg id for config type
                pResult );
#if DBG
    if ( status != NO_ERROR )
    {
        DNSDBG( ANY, (
            "Reg_GetDword() failed for config lookup!\n"
            "\tstatus       = %d\n"
            "\tConfigId     = %d\n"
            "\tRedId        = %d\n"
            "\tpwsAdapter   = %S\n",
            status,
            ConfigId,
            pfig->RegId,
            pwsAdapter ));

        ASSERT( status == NO_ERROR );
    }
#endif
    return( status );
}



//
//  Public Configuration API
//

DNS_STATUS
DnsQueryConfig(
    IN      DNS_CONFIG_TYPE     ConfigId,
    IN      DWORD               Flag,
    IN      PWSTR               pwsAdapterName,
    IN      PVOID               pReserved,
    OUT     PVOID               pBuffer,
    IN OUT  PDWORD              pBufferLength
    )
/*++

Routine Description:

    Get DNS configuration info.

Arguments:

    ConfigId -- type of config info desired

    Flag -- flags to query

    pAdapterName -- name of adapter;  NULL if no specific adapter

    pReserved -- reserved parameter, should be NULL

    pBuffer -- buffer to receive config info

    pBufferLength -- addr of DWORD containing buffer length;  on return
        contains length

Return Value:

    ERROR_SUCCESS -- if query successful
    ERROR_MORE_DATA -- if not enough space in buffer

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       bufLength = 0;
    DWORD       resultLength = 0;
    PBYTE       presult;
    PBYTE       pallocResult = NULL;
    BOOL        boolData;
    DWORD       dwordData;


    DNSDBG( TRACE, (
        "DnsQueryConfig()\n"
        "\tconfig   = %d\n"
        "\tflag     = %08x\n"
        "\tadapter  = %S\n"
        "\tpBuffer  = %p\n",
        ConfigId,
        Flag,
        pwsAdapterName,
        pBuffer
        ));

    //
    //  check out param setup
    //

    if ( !pBufferLength )
    {
        return  ERROR_INVALID_PARAMETER;
    }
    if ( pBuffer )
    {
        bufLength = *pBufferLength;
    }

    //
    //  find specific configuration data requested
    //

    switch( ConfigId )
    {

    case DnsConfigPrimaryDomainName_W:

        presult = (PBYTE) Reg_GetPrimaryDomainName( DnsCharSetUnicode );
        goto  WideString;

    case DnsConfigPrimaryDomainName_A:

        presult = (PBYTE) Reg_GetPrimaryDomainName( DnsCharSetAnsi );
        goto  NarrowString;

    case DnsConfigPrimaryDomainName_UTF8:

        presult = (PBYTE) Reg_GetPrimaryDomainName( DnsCharSetUtf8 );
        goto  NarrowString;


    case DnsConfigDnsServerList:

        presult = (PBYTE) GetDnsServerList(
                            TRUE    // force registry read
                            );
        if ( !presult )
        {
            status = GetLastError();
            if ( status == NO_ERROR )
            {
                DNS_ASSERT( FALSE );
                status = DNS_ERROR_NO_DNS_SERVERS;
            }
            goto Done;
        }
        pallocResult = presult;
        resultLength = Dns_SizeofIpArray( (PIP_ARRAY)presult );
        goto Process;


    case DnsConfigPrimaryHostNameRegistrationEnabled:
    case DnsConfigAdapterHostNameRegistrationEnabled:
    case DnsConfigAddressRegistrationMaxCount:

        goto Dword;

    //case DnsConfigAdapterDomainName:
    //case DnsConfigAdapterInfo:
    //case DnsConfigSearchList:

    case DnsConfigHostName_W:

        presult = (PBYTE) Reg_GetHostName( DnsCharSetUnicode );
        goto  WideString;

    case DnsConfigHostName_A:

        presult = (PBYTE) Reg_GetHostName( DnsCharSetAnsi );
        goto  NarrowString;

    case DnsConfigHostName_UTF8:

        presult = (PBYTE) Reg_GetHostName( DnsCharSetUtf8 );
        goto  NarrowString;

    case DnsConfigFullHostName_W:

        presult = (PBYTE) Reg_GetFullHostName( DnsCharSetUnicode );
        goto  WideString;

    case DnsConfigFullHostName_A:

        presult = (PBYTE) Reg_GetFullHostName( DnsCharSetAnsi );
        goto  NarrowString;

    case DnsConfigFullHostName_UTF8:

        presult = (PBYTE) Reg_GetFullHostName( DnsCharSetUtf8 );
        goto  NarrowString;

    default:

        return  ERROR_INVALID_PARAMETER;
    }


    //
    //  setup return info for common types
    //
    //  this just avoids code duplication above
    //

Dword:

    status = LookupDwordConfigValue(
                & dwordData,
                ConfigId,
                pwsAdapterName );

    if ( status != NO_ERROR )
    {
        goto Done;
    }
    presult = (PBYTE) &dwordData;
    resultLength = sizeof(DWORD);
    goto  Process;


NarrowString:

    if ( !presult )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }
    pallocResult = presult;
    resultLength = strlen( (PSTR)presult ) + 1;
    goto  Process;


WideString:

    if ( !presult )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }
    pallocResult = presult;
    resultLength = (wcslen( (PWSTR)presult ) + 1) * sizeof(WCHAR);
    goto  Process;


Process:

    //
    //  return results -- three basic programs
    //      - no buffer         => only return length required
    //      - allocate          => return allocated result
    //      - supplied buffer   => copy result into buffer
    //
    //  note, this section only handles simple flag datablobs to aVOID
    //  duplicating code for specific config types above;
    //  when we add config types that require nested pointers, they must
    //  roll their own return-results code and jump to Done
    //

    //
    //  no buffer
    //      - no-op, length is set below

    if ( !pBuffer )
    {
    }

    //
    //  allocated result
    //      - return buffer gets ptr
    //      - allocate copy of result if not allocated
    //

    else if ( Flag & DNS_CONFIG_FLAG_ALLOC )
    {
        PBYTE   pheap;

        if ( bufLength < sizeof(PVOID) )
        {
            resultLength = sizeof(PVOID);
            status = ERROR_MORE_DATA;
            goto Done;
        }

        //  create local alloc buffer

        pheap = LocalAlloc( 0, resultLength );
        if ( !pheap )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Done;
        }
        RtlCopyMemory(
            pheap,
            presult,
            resultLength );
        
        //  return ptr to allocated result

        * (PVOID*) pBuffer = pheap;
    }

    //
    //  allocated result -- but dnsapi alloc
    //

    else if ( Flag & DNS_CONFIG_FLAG_DNSAPI_ALLOC )
    {
        if ( bufLength < sizeof(PVOID) )
        {
            resultLength = sizeof(PVOID);
            status = ERROR_MORE_DATA;
            goto Done;
        }

        //  if result not allocated, alloc and copy it

        if ( ! pallocResult )
        {
            pallocResult = ALLOCATE_HEAP( resultLength );
            if ( !pallocResult )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Done;
            }

            RtlCopyMemory(
                pallocResult,
                presult,
                resultLength );
        }

        //  return ptr to allocated result

        * (PVOID*) pBuffer = pallocResult;

        //  clear pallocResult, so not freed in generic cleanup

        pallocResult = NULL;
    }

    //
    //  copy result to caller buffer
    //

    else
    {
        if ( bufLength < resultLength )
        {
            status = ERROR_MORE_DATA;
            goto Done;
        }
        RtlCopyMemory(
            pBuffer,
            presult,
            resultLength );
    }


Done:

    //
    //  set result length
    //  cleanup any allocated (but not returned) data
    //

    *pBufferLength = resultLength;

    if ( pallocResult )
    {
        FREE_HEAP( pallocResult );
    }

    return( status );
}




//
//  System Public Configuration API
//

PVOID
WINAPI
DnsQueryConfigAllocEx(
    IN      DNS_CONFIG_TYPE     ConfigId,
    IN      PWSTR               pwsAdapterName,
    IN      BOOL                fLocalAlloc
    )
/*++

Routine Description:

    Get DNS configuration info.

    Allocate DNS configuration info.
    This is the cover API both handling the system public API
    DnsQueryConfigAlloc() below and the backward compatible
    macros for the old hostname and PDN alloc routines (see dnsapi.h)

Arguments:

    ConfigId -- type of config info desired

    pAdapterName -- name of adapter;  NULL if no specific adapter

    fLocalAlloc -- allocate with LocalAlloc

Return Value:

    ERROR_SUCCESS -- if query successful
    ERROR_MORE_DATA -- if not enough space in buffer

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       bufLength = sizeof(PVOID);
    PBYTE       presult = NULL;

    DNSDBG( TRACE, (
        "DnsQueryConfigAllocEx()\n"
        "\tconfig   = %d\n"
        "\tadapter  = %S\n"
        "\tflocal   = %d\n",
        ConfigId,
        pwsAdapterName,
        fLocalAlloc
        ));

    //
    //  SDK-public types
    //

    if ( ConfigId < DnsConfigSystemBase )
    {
        //
        //  DCR:  could screen here for alloc types
        //
        //    DnsConfigPrimaryDomainName_W:
        //    DnsConfigPrimaryDomainName_A:
        //    DnsConfigPrimaryDomainName_UTF8:
        //    DnsConfigHostname_W:
        //    DnsConfigHostname_A:
        //    DnsConfigHostname_UTF8:
        //    DnsConfigDnsServerList:
        //
        
        status = DnsQueryConfig(
                    ConfigId,
                    fLocalAlloc
                        ? DNS_CONFIG_FLAG_LOCAL_ALLOC
                        : DNS_CONFIG_FLAG_DNSAPI_ALLOC,
                    pwsAdapterName,
                    NULL,               // reserved
                    & presult,
                    & bufLength );
        
        if ( status != NO_ERROR )
        {
            SetLastError( status );
            return  NULL;
        }
        return  presult;
    }

    //
    //  System public types
    //

    if ( fLocalAlloc )
    {
        goto Invalid;
    }

    switch ( ConfigId )
    {
    case    DnsConfigNetworkInformation:

        return  GetNetworkInformation();

    case    DnsConfigSearchInformation:

        return  GetSearchInformation();

    case    DnsConfigNetInfo:

        return  NetInfo_Get(
                    TRUE,       // force
                    TRUE        // include IP addresses
                    );

    case    DnsConfigIp4AddressArray:

        return  LocalIp_GetIp4Array();

    //  unknown falls through to invalid
    }

Invalid:

    DNS_ASSERT( FALSE );
    SetLastError( ERROR_INVALID_PARAMETER );
    return( NULL );
}




//
//  DWORD system-public config
//

DWORD
DnsQueryConfigDword(
    IN      DNS_CONFIG_TYPE     ConfigId,
    IN      PWSTR               pwsAdapter
    )
/*++

Routine Description:

    Get DNS DWORD configuration value.

    This is system public routine.

Arguments:

    ConfigId -- type of config info desired

    pwsAdapter -- name of adapter;  NULL if no specific adapter

Return Value:

    DWORD config value.
    Zero if no such config.

--*/
{
    DNS_STATUS  status;
    DWORD       value = 0;

    DNSDBG( TRACE, (
        "DnsQueryConfigDword()\n"
        "\tconfig   = %d\n"
        "\tadapter  = %S\n",
        ConfigId,
        pwsAdapter
        ));

    status = LookupDwordConfigValue(
                & value,
                ConfigId,
                pwsAdapter );

#if DBG
    if ( status != NO_ERROR )
    {
        DNSDBG( ANY, (
            "LookupDwordConfigValue() failed for config lookup!\n"
            "\tstatus       = %d\n"
            "\tConfigId     = %d\n"
            "\tpwsAdapter   = %S\n",
            status,
            ConfigId,
            pwsAdapter ));

        DNS_ASSERT( status == NO_ERROR );
    }
#endif

    return( value );
}



DNS_STATUS
DnsSetConfigDword(
    IN      DNS_CONFIG_TYPE     ConfigId,
    IN      PWSTR               pwsAdapter,
    IN      DWORD               NewValue
    )
/*++

Routine Description:

    Set DNS DWORD configuration value.

    This is system public routine.

Arguments:

    ConfigId -- type of config info desired

    pwsAdapter -- name of adapter;  NULL if no specific adapter

    NewValue -- new value for parameter

Return Value:

    DWORD config value.
    Zero if no such config.

--*/
{
    PCONFIG_MAPPING pfig;

    DNSDBG( TRACE, (
        "DnsSetConfigDword()\n"
        "\tconfig   = %d\n"
        "\tadapter  = %S\n"
        "\tvalue    = %d (%08x)\n",
        ConfigId,
        pwsAdapter,
        NewValue, NewValue
        ));

    //
    //  verify config is known and mapped
    //

    pfig = GetConfigToRegistryMapping(
                ConfigId,
                pwsAdapter,
                TRUE            // check adapter validity
                );
    if ( !pfig )
    {
        return  ERROR_INVALID_PARAMETER;
    }

    //
    //  set in registry
    //

    return  Reg_SetDwordPropertyAndAlertCache(
                    pwsAdapter,     // adapter name key (if any)
                    pfig->RegId,
                    NewValue );
}



//
//  Config data free
//

VOID
WINAPI
DnsFreeConfigStructure(
    IN OUT  PVOID           pData,
    IN      DNS_CONFIG_TYPE ConfigId
    )
/*++

Routine Description:

    Free config data

    This routine simply handles the mapping between config IDs
    and the free type.

Arguments:

    pData -- data to free

    ConfigId -- config id

Return Value:

    None

--*/
{
    DNS_FREE_TYPE   freeType = DnsFreeFlat;

    DNSDBG( TRACE, (
        "DnsFreeConfigStructure( %p, %d )\n",
        pData,
        ConfigId ));

    //
    //  find any unflat config types
    //
    //  note:  currently all config types that are not flat
    //      are system-public only and the config ID is also
    //      the free type (for convenience);  if we start
    //      exposing some of these bringing them into the low
    //      space, then this will change
    //
    //  unfortunately these types can NOT be identical because
    //  the space conflicts in shipped Win2K  (FreeType==1 is
    //  record list)
    //

    if ( ConfigId > DnsConfigSystemBase  &&
         ( ConfigId == DnsConfigNetworkInformation  ||
           ConfigId == DnsConfigSearchInformation   ||
           ConfigId == DnsConfigAdapterInformation  ||
           ConfigId == DnsConfigNetInfo ) )
    {
        freeType = (DNS_FREE_TYPE) ConfigId;
    }

    DnsFree(
        pData,
        freeType );
}


//
//  End config.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\dll.c ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    dll.c

Abstract:

    Domain Name System (DNS) API

    Dnsapi.dll basic DLL infrastructure (init, shutdown, etc)

Author:

    Jim Gilroy (jamesg)     April 2000

Revision History:

--*/


#include "local.h"


//
//  Global Definitions
//

HINSTANCE   g_hInstanceDll;

//
//  Initialization level
//

DWORD       g_InitLevel = 0;

//
//  General purpose CS
//  Protects init and any other small scale uses
//

CRITICAL_SECTION    g_GeneralCS;





//
//  Initialization and cleanup
//

BOOL
startInit(
    VOID
    )
/*++

Routine Description:

    Minimum DLL init at process attach.

Arguments:

    None

Return Value:

    TRUE if successful.
    FALSE otherwise.

--*/
{
    //
    //  DCR_PERF:  simplified init -- simple Interlock
    //      then all external calls, must test the flag
    //      if not set do the real init (then set flag)
    //
    //      note:  init function itself must have a dumb
    //      wait to avoid race;  this can be as simple
    //      as sleep\test loop
    //
    //  multilevel init:
    //      have a bunch of levels of init
    //          - query (registry stuff)
    //          - update
    //          - secure update
    //
    //      call would add the init for the level required
    //      this would need to be done under a lock to
    //      test, take lock, retest
    //
    //      could either take one CS on all inits (simple)
    //      or init only brings stuff on line
    //

    InitializeCriticalSection( &g_GeneralCS );

    //  for debug, note that we've gotten this far

    g_InitLevel = INITLEVEL_BASE;


    //  tracing init

    Trace_Initialize();

    //
    //  DCR_PERF:  fast DLL init
    //
    //  currently initializing everything -- like we did before
    //  once we get init routines (macro'd) in interfaces we
    //  can drop this
    //

    return  DnsApiInit( INITLEVEL_ALL );
}



BOOL
DnsApiInit(
    IN      DWORD           InitLevel
    )
/*++

Routine Description:

    Initialize the DLL for some level of use.

    The idea here is to avoid all the init and registry
    reading for processes that don't need it.
    Only insure initialization to the level required.

Arguments:

    InitLevel -- level of initialization required.

Return Value:

    TRUE if desired initialization is successful.
    FALSE otherwise.

--*/
{
    //
    //  DCR_PERF:  simplified init -- simple Interlock
    //      then all external calls, must test the flag
    //      if not set do the real init (then set flag)
    //
    //      note:  init function itself must have a dumb
    //      wait to avoid race;  this can be as simple
    //      as sleep\test loop
    //
    //  multilevel init:
    //      have a bunch of levels of init
    //          - query (registry stuff)
    //          - update
    //          - secure update
    //
    //      call would add the init for the level required
    //      this would need to be done under a lock to
    //      test, take lock, retest
    //
    //      could either take one CS on all inits (simple)
    //      or init only brings stuff on line
    //


    //
    //  check if already initialized to required level
    //      => if there we're done
    //
    //  note:  could check after lock for MT, but not
    //      unlikely and not much perf benefit over
    //      individual checks
    //

    if ( (g_InitLevel & InitLevel) == InitLevel )
    {
        return( TRUE );
    }

    EnterCriticalSection( &g_GeneralCS );

    //
    //  heap
    //

    Heap_Initialize();


#if DBG
    //
    //  init debug logging
    //      - do for any process beyond simple attach
    //
    //  start logging with log filename generated to be
    //      unique for this process
    //
    //  do NOT put drive specification in the file path
    //  do NOT set the debug flag -- the flag is read from the dnsapi.flag file
    //

    if ( !(g_InitLevel & INITLEVEL_DEBUG) )
    {
        CHAR    szlogFileName[ 30 ];

        sprintf(
            szlogFileName,
            "dnsapi.%d.log",
            GetCurrentProcessId() );

         Dns_StartDebug(
            0,
            "dnsapi.flag",
            NULL,
            szlogFileName,
            0 );

         g_InitLevel = INITLEVEL_DEBUG;
    }
#endif

    //
    //  general query service
    //      - need registry info
    //      - need adapter list info (servlist.c)
    //
    //  DCR:  even query level doesn't need full registry info
    //          if either queries through cache OR gets netinfo from cache
    //
    //  note:  do NOT initialize winsock here
    //      WSAStartup() in dll init routine is strictly verboten
    //

    if ( (InitLevel & INITLEVEL_QUERY) &&
         !(g_InitLevel & INITLEVEL_QUERY) )
    {
        DNS_STATUS  status;

        //
        //  Init registry lookup
        //

        status = Reg_ReadGlobalsEx( 0, NULL );
        if ( status != ERROR_SUCCESS )
        {
            ASSERT( FALSE );
            goto Failed;
        }

        //
        //  net failure caching
        //

        InitializeCriticalSection( &g_NetFailureCS );
        g_NetFailureTime = 0;
        g_NetFailureStatus = ERROR_SUCCESS;

        //
        //  init CS to protect adapter list global
        //

        InitNetworkInfo();
        
        //
        //  set the query timeouts
        //

        Dns_InitQueryTimeouts();


        //  indicate query init complete

        g_InitLevel |= INITLEVEL_QUERY;

        DNSDBG( INIT, ( "Query\\Config init is complete.\n" ));
    }

    //
    //  registration services
    //

    if ( (InitLevel & INITLEVEL_REGISTRATION) &&
         !(g_InitLevel & INITLEVEL_REGISTRATION) )
    {
        InitializeCriticalSection( &g_RegistrationListCS );
        InitializeCriticalSection( &g_QueueCS );
        InitializeCriticalSection( &g_RegistrationThreadCS );
        
        g_InitLevel |= INITLEVEL_REGISTRATION;

        DNSDBG( INIT, ( "Registration init is complete.\n" ));
    }

    //
    //  secure update?
    //      - init security CS
    //  note, this already has built in protection -- it doesn't init
    //  the package, just the CS, which protects package init
    //

    if ( (InitLevel & INITLEVEL_SECURE_UPDATE) &&
         !(g_InitLevel & INITLEVEL_SECURE_UPDATE ) )
    {
        Dns_StartSecurity( TRUE );
        g_InitLevel |= INITLEVEL_SECURE_UPDATE;

        DNSDBG( INIT, ( "Secure update init is complete.\n" ));
    }

    //
    //  clear global CS
    //

    LeaveCriticalSection( &g_GeneralCS );

    return( TRUE );

Failed:

    LeaveCriticalSection( &g_GeneralCS );

    return( FALSE );
}



VOID
cleanupForExit(
    VOID
    )
/*++

Routine Description:

    Cleanup for DLL unload.
    Cleanup memory and handles dnsapi.dll allocated.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  unload security packages used by secure dynamic update.
    //

    if ( g_InitLevel & INITLEVEL_SECURE_UPDATE )
    {
        Dns_TerminateSecurityPackage();
    }

    //
    //  registration stuff
    //

    if ( g_InitLevel & INITLEVEL_REGISTRATION )
    {
        DeleteCriticalSection( &g_QueueCS );
        DeleteCriticalSection( &g_RegistrationListCS );
        DeleteCriticalSection( &g_RegistrationThreadCS );
    }

    //
    //  query stuff
    //

    if ( g_InitLevel & INITLEVEL_QUERY )
    {
        //
        //  clean up Server/Net Adapter lists
        //
    
        CleanupNetworkInfo();

        Dns_CacheSocketCleanup();

        Dns_CleanupWinsock();
    
        if ( g_pwsRemoteResolver )
        {
            FREE_HEAP( g_pwsRemoteResolver );
        }
    
        DeleteCriticalSection( &g_NetFailureCS );
    }

    //
    //  unload IP Help
    //

    IpHelp_Cleanup();

    //
    //  tracing
    //

    Trace_Cleanup();

    //
    //  cleanup heap
    //

    Heap_Cleanup();

    //
    //  kill general CS
    //

    DeleteCriticalSection( &g_GeneralCS );

    g_InitLevel = 0;
}



//
//  Main dnsapi.dll routines
//

__declspec(dllexport)
BOOL
WINAPI
DnsDllInit(
    IN      HINSTANCE       hInstance,
    IN      DWORD           Reason,
    IN      PVOID           pReserved
    )
/*++

Routine Description:

    Dll attach entry point.

Arguments:

    hinstDll -- instance handle of attach

    Reason -- reason for attach
        DLL_PROCESS_ATTACH, DLL_PROCESS_DETACH, etc.

    Reserved -- unused

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    //
    //  on process attach
    //      - disable thread notifications
    //      - save instance handle
    //      - do minimum DLL initialization
    //

    if ( Reason == DLL_PROCESS_ATTACH )
    {
        if ( ! DisableThreadLibraryCalls( hInstance ) )
        {
            return( FALSE );
        }
        g_hInstanceDll = hInstance;

        return startInit();
    }

    //
    //  on process detach
    //      - cleanup IF pReserved==NULL which indicates detach due
    //      to FreeLibrary
    //      - if process is exiting do nothing
    //

    if ( Reason == DLL_PROCESS_DETACH
            &&
         pReserved == NULL )
    {
        cleanupForExit();
    }

    return TRUE;
}

//
//  End dll.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\dnsapi.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    dnsapi.c

Abstract:

    Domain Name System (DNS) API

    Dnsapi.dll infrastructure (init, shutdown, etc)
    Routines to access DNS resolver

Author:

    GlennC      22-Jan-1997

Revision History:

    Jim Gilroy (jamesg)     March 2000      cleanup

--*/


#include "local.h"
#include <lmcons.h>


#define DNS_NET_FAILURE_CACHE_TIME      30  // Seconds


//
//  Global Definitions
//

//
//  Globals
//

CRITICAL_SECTION    g_RegistrationListCS;
CRITICAL_SECTION    g_RegistrationThreadCS;
CRITICAL_SECTION    g_QueueCS;
CRITICAL_SECTION    g_NetFailureCS;

DWORD               g_NetFailureTime;
DNS_STATUS          g_NetFailureStatus;

IP_ADDRESS          g_LastDNSServerUpdated = 0;


//
// Local Function Prototypes
//

BOOL
DnsInitialize(
    VOID
    );

VOID
DnsCleanup(
    VOID
    );

VOID
ClearDnsCacheEntry_A (
    IN  LPSTR,
    IN  WORD );

VOID
ClearDnsCacheEntry_W (
    IN  LPWSTR,
    IN  WORD );

VOID
FreeRpcIpAddressList(
    IN  PDNS_IP_ADDR_LIST );



//
//  System public Network Information
//
//  The dnsapi.dll interface is in config.c
//

PDNS_NETWORK_INFORMATION
CreateNetworkInformation(
    IN  DWORD cAdapterCount
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PDNS_NETWORK_INFORMATION pNetworkInfo = NULL;
    DWORD dwAdapterListBufLen = sizeof( DNS_NETWORK_INFORMATION ) -
                                sizeof( PDNS_ADAPTER_INFORMATION ) +
                                ( sizeof( PDNS_ADAPTER_INFORMATION ) *
                                  cAdapterCount );

    pNetworkInfo = (PDNS_NETWORK_INFORMATION) ALLOCATE_HEAP_ZERO(
                                            dwAdapterListBufLen );

    return pNetworkInfo;
}


PDNS_SEARCH_INFORMATION
CreateSearchInformation(
    IN  DWORD cNameCount,
    IN  LPSTR pszName
    )
{
    PDNS_SEARCH_INFORMATION pSearchInfo = NULL;
    DWORD dwSearchInfoBufLen = sizeof( DNS_SEARCH_INFORMATION ) -
                               sizeof( LPSTR ) +
                               ( sizeof( LPSTR ) *
                                 cNameCount );

    if ( ( cNameCount == 0 ) && ( ! pszName ) )
    {
        return NULL;
    }

    pSearchInfo =
        (PDNS_SEARCH_INFORMATION) ALLOCATE_HEAP_ZERO( dwSearchInfoBufLen );

    if ( ! pSearchInfo )
    {
        return NULL;
    }

    if ( pszName )
    {
        pSearchInfo->pszPrimaryDomainName = Dns_NameCopyAllocate(
                                                pszName,
                                                0,
                                                DnsCharSetUtf8,
                                                DnsCharSetUtf8 );

        if ( ! pSearchInfo->pszPrimaryDomainName )
        {
            FREE_HEAP( pSearchInfo );
            return NULL;
        }
    }

    return pSearchInfo;
}


PDNS_SEARCH_INFORMATION
CreateSearchInformationCopyFromList(
    IN      PSEARCH_LIST    pSearchList
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PDNS_SEARCH_INFORMATION pSearchInformation;
    DWORD iter;

    if ( ! pSearchList )
    {
        return NULL;
    }

    pSearchInformation = CreateSearchInformation(
                                pSearchList->NameCount,
                                pSearchList->pszDomainOrZoneName );
    if ( ! pSearchInformation )
    {
        return NULL;
    }

    for ( iter = 0; iter < pSearchList->NameCount; iter++ )
    {
        if ( pSearchList->SearchNameArray[iter].pszName )
        {
            pSearchInformation->aSearchListNames[iter] =
                    Dns_NameCopyAllocate(
                            pSearchList->SearchNameArray[iter].pszName,
                            0,
                            DnsCharSetUtf8,
                            DnsCharSetUtf8 );
        }

        if ( pSearchInformation->aSearchListNames[iter] )
        {
            pSearchInformation->cNameCount++;
        }
    }

    return pSearchInformation;
}


PDNS_ADAPTER_INFORMATION
CreateAdapterInformation(
    IN      DWORD               cServerCount,
    IN      DWORD               dwFlags,
    IN      LPSTR               pszDomain,
    IN      LPSTR               pszGuidName
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PDNS_ADAPTER_INFORMATION pAdapter = NULL;
    DWORD dwAdapterInfoBufLen = sizeof( DNS_ADAPTER_INFORMATION ) -
                                sizeof( DNS_SERVER_INFORMATION ) +
                                ( sizeof( DNS_SERVER_INFORMATION ) *
                                  cServerCount );

    pAdapter = (PDNS_ADAPTER_INFORMATION)
                    ALLOCATE_HEAP_ZERO( dwAdapterInfoBufLen );
    if ( ! pAdapter )
    {
        return NULL;
    }

    pAdapter->InfoFlags = dwFlags;
    pAdapter->cServerCount = 0;
    if ( pszDomain )
    {
        pAdapter->pszDomain = Dns_NameCopyAllocate(
                                    pszDomain,
                                    0,
                                    DnsCharSetUtf8,
                                    DnsCharSetUtf8 );
    }

    if ( pszGuidName )
    {
        pAdapter->pszAdapterGuidName = Dns_NameCopyAllocate(
                                            pszGuidName,
                                            0,
                                            DnsCharSetUtf8,
                                            DnsCharSetUtf8 );
    }

    return pAdapter;
}


PDNS_ADAPTER_INFORMATION
CreateAdapterInformationCopyFromList(
    IN  PDNS_ADAPTER        pAdapter
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PDNS_ADAPTER_INFORMATION pAdapterInformation;
    DWORD iter;

    if ( ! pAdapter )
    {
        return NULL;
    }

    pAdapterInformation = CreateAdapterInformation(
                                pAdapter->ServerCount,
                                pAdapter->InfoFlags,
                                pAdapter->pszAdapterDomain,
                                pAdapter->pszAdapterGuidName );
    if ( ! pAdapterInformation )
    {
        return NULL;
    }

    pAdapterInformation->pIPAddresses =
        Dns_CreateIpArrayCopy( pAdapter->pAdapterIPAddresses );

    pAdapterInformation->pIPSubnetMasks =
        Dns_CreateIpArrayCopy( pAdapter->pAdapterIPSubnetMasks );

    for ( iter = 0; iter < pAdapter->ServerCount;  iter++ )
    {
        pAdapterInformation->aipServers[iter].ipAddress =
            pAdapter->ServerArray[iter].IpAddress;
        pAdapterInformation->aipServers[iter].Priority =
            pAdapter->ServerArray[iter].Priority;
    }

    pAdapterInformation->cServerCount = pAdapter->ServerCount;

    return pAdapterInformation ;
}


PDNS_NETWORK_INFORMATION
WINAPI
GetNetworkInformation(
    VOID )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PDNS_NETINFO    pNetInfo = GetNetworkInfo();
    DWORD           iter;
    PDNS_NETWORK_INFORMATION pNetworkInformation = NULL;

    if ( !pNetInfo )
    {
        return NULL;
    }

    //
    //  create Network Information of desired size
    //  then copy entire structure
    //

    pNetworkInformation = CreateNetworkInformation( pNetInfo->AdapterCount );
    if ( ! pNetworkInformation )
    {
        goto Done;
    }

    pNetworkInformation->pSearchInformation =
        CreateSearchInformationCopyFromList( pNetInfo->pSearchList );

    for ( iter = 0; iter < pNetInfo->AdapterCount; iter++ )
    {
        pNetworkInformation->aAdapterInfoList[iter] =
            CreateAdapterInformationCopyFromList( pNetInfo->AdapterArray[iter] );

        if ( pNetworkInformation->aAdapterInfoList[iter] )
        {
            pNetworkInformation->cAdapterCount += 1;
        }
    }

Done:

    NetInfo_Free( pNetInfo );

    return pNetworkInformation;
}


PDNS_SEARCH_INFORMATION
WINAPI
GetSearchInformation(
    VOID )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PDNS_NETINFO            pNetInfo = GetNetworkInfo();
    PDNS_SEARCH_INFORMATION pSearchInformation = NULL;

    if ( !pNetInfo )
    {
        return NULL;
    }

    pSearchInformation = CreateSearchInformationCopyFromList(
                                pNetInfo->pSearchList );

    NetInfo_Free( pNetInfo );

    return pSearchInformation;
}


VOID
WINAPI
FreeAdapterInformation(
    IN  PDNS_ADAPTER_INFORMATION pAdapterInformation
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if ( pAdapterInformation )
    {
        if ( pAdapterInformation->pszAdapterGuidName )
        {
            FREE_HEAP( pAdapterInformation->pszAdapterGuidName );
        }

        if ( pAdapterInformation->pszDomain )
        {
            FREE_HEAP( pAdapterInformation->pszDomain );
        }

        if ( pAdapterInformation->pIPAddresses )
        {
            FREE_HEAP( pAdapterInformation->pIPAddresses );
        }

        if ( pAdapterInformation->pIPSubnetMasks )
        {
            FREE_HEAP( pAdapterInformation->pIPSubnetMasks );
        }

        FREE_HEAP( pAdapterInformation );
    }
}


VOID
WINAPI
FreeSearchInformation(
    IN  PDNS_SEARCH_INFORMATION pSearchInformation
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD iter;

    if ( pSearchInformation )
    {
        if ( pSearchInformation->pszPrimaryDomainName )
        {
            FREE_HEAP( pSearchInformation->pszPrimaryDomainName );
        }

        for ( iter = 0; iter < pSearchInformation->cNameCount; iter++ )
        {
            if ( pSearchInformation->aSearchListNames[iter] )
            {
                FREE_HEAP( pSearchInformation->aSearchListNames[iter] );
            }
        }

        FREE_HEAP( pSearchInformation );
    }
}


VOID
WINAPI
FreeNetworkInformation(
    IN  PDNS_NETWORK_INFORMATION pNetworkInformation
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD iter;

    if ( pNetworkInformation )
    {
        FreeSearchInformation( pNetworkInformation->pSearchInformation );

        for ( iter = 0; iter < pNetworkInformation->cAdapterCount; iter++ )
        {
            FreeAdapterInformation( pNetworkInformation ->
                                       aAdapterInfoList[iter] );
        }

        FREE_HEAP( pNetworkInformation );
    }
}


//
//  Net failure caching
//

BOOL
IsKnownNetFailure(
    VOID
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    BOOL flag = FALSE;

    DNSDBG( TRACE, ( "IsKnownNetFailure()\n" ));

    EnterCriticalSection( &g_NetFailureCS );

    if ( g_NetFailureStatus )
    {
        if ( g_NetFailureTime < Dns_GetCurrentTimeInSeconds() )
        {
            g_NetFailureTime = 0;
            g_NetFailureStatus = ERROR_SUCCESS;
            flag = FALSE;
        }
        else
        {
            SetLastError( g_NetFailureStatus );
            flag = TRUE;
        }
    }

    LeaveCriticalSection( &g_NetFailureCS );

    return flag;
}


VOID
SetKnownNetFailure(
    IN      DNS_STATUS      Status
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DNSDBG( TRACE, ( "SetKnownNetFailure()\n" ));

    EnterCriticalSection( &g_NetFailureCS );

    g_NetFailureTime = Dns_GetCurrentTimeInSeconds() +
                       DNS_NET_FAILURE_CACHE_TIME;
    g_NetFailureStatus = Status;

    LeaveCriticalSection( &g_NetFailureCS );
}


BOOL
WINAPI
DnsGetCacheDataTable(
    OUT     PDNS_CACHE_TABLE *  ppTable
    )
/*++

Routine Description:

    Get cache data table.

Arguments:

    ppTable -- address to receive ptr to cache data table

Return Value:

    ERROR_SUCCES if successful.
    Error code on failure.

--*/
{
    DNS_STATUS           status = ERROR_SUCCESS;
    DWORD                rpcStatus = ERROR_SUCCESS;
    PDNS_RPC_CACHE_TABLE pcacheTable = NULL;

    DNSDBG( TRACE, ( "DnsGetCacheDataTable()\n" ));

    if ( ! ppTable )
    {
        return FALSE;
    }
#if DNSBUILDOLD
    if ( g_IsWin9X )
    {
        return  FALSE;
    }
#endif

    RpcTryExcept
    {
        status = CRrReadCache( NULL, &pcacheTable );
    }
    RpcExcept( DNS_RPC_EXCEPTION_FILTER )
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    //  set out param

    *ppTable = (PDNS_CACHE_TABLE) pcacheTable;

#if DBG
    if ( status != ERROR_SUCCESS )
    {
        DNSDBG( RPC, (
            "DnsGetCacheDataTable()  status = %d\n",
            status ));
    }
#endif

    return( pcacheTable && status == ERROR_SUCCESS );
}



BOOL
IsLocalIpAddress(
    IN      IP_ADDRESS      IpAddress
    )

//
//  DCR_FIX:  this has no customers other than debug code in update.c
//
//  If wanted this API it should be remoteable -- we could avoid alloc
//      and include IP6
//

{
    BOOL      bfound = FALSE;
    PIP_ARRAY ipList = Dns_GetLocalIpAddressArray();
    DWORD     iter;

    if ( !ipList )
    {
        return bfound;
    }

    //
    //  check if IpAddress is in local list
    //

    for ( iter = 0; iter < ipList->AddrCount; iter++ )
    {
        if ( IpAddress == ipList->AddrArray[iter] )
        {
            bfound = TRUE;
        }
    }

    FREE_HEAP( ipList );

    return bfound;
}

//
//  End dnsapi.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\dnsmem.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    dnsmem.h

Abstract:

    Domain Name System (DNS) Library

    Memory routines declarations.

Author:

    Jim Gilroy (jamesg)     January 1997

Revision History:

--*/

#ifndef _DNS_MEMORY_INCLUDED_
#define _DNS_MEMORY_INCLUDED_



//
//  Ram's leak tracking debug routines
//  Changes made here to be exportable to dns server end

LPVOID
DnsApiAlloc(
    DWORD cb
    );

#if  DBG
LPVOID
DebugDnsApiAlloc(
    CHAR*,
    int,
    DWORD cb
);
#endif

#if  DBG
BOOL
DebugDnsApiFree(
    LPVOID
    );
#endif

BOOL
DnsApiFree(
    LPVOID pMem
    );

//
// Dont care about ReAlloc because it is not exported to server
// side. May need to fix this if this is changed at a future point
//

#if  DBG
LPVOID
DebugDnsApiReAlloc(
    CHAR*,
    int,
    LPVOID pOldMem,
    DWORD cbOld,
    DWORD cbNew
    );
#define  DnsApiReAlloc( pOldMem, cbOld, cbNew ) DebugDnsApiReAlloc( __FILE__, __LINE__, pOldMem, cbOld, cbNew )
#else
LPVOID
DnsApiReAlloc(
    LPVOID pOldMem,
    DWORD cbOld,
    DWORD cbNew
    );
#endif


#if DBG

extern LIST_ENTRY DnsMemList ;
extern CRITICAL_SECTION DnsMemCritSect ;

VOID InitDnsMem(
    VOID
    );

VOID AssertDnsMemLeaks(
    VOID
    );

VOID
DumpMemoryTracker(
    VOID
    );


#else
//
//  non-debug, macroize away heap tracking
//
#define InitDnsMem()
#define AssertDnsMemLeaks()
#define DumpMemoryTracker()
#endif


//
//  DCR:  a better idea is just to call DnsApiHeapReset (if necessary)
//      to install any underlying allocators you want
//
//      then just cover the standard macros for your debug builds
//

#define DNS_ALLOCATE_HEAP(size)              DnsApiAlloc(size)
#define DNS_FREE_HEAP(p)                     DnsApiFree(p)


#endif  //  _DNS_MEMORY_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\dnsup.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    dnsup.c

Abstract:

    Domain Name System (DNS) Update Client

    Main program.

Author:

    Jim Gilroy (jamesg)     October, 1996

Environment:

    User Mode - Win32

Revision History:

--*/

#include "local.h"
#if 0
#include <windows.h>
#include <winsock2.h>
#include <stdlib.h>
#include <stdio.h>      //  printf()
#include <string.h>     //  strtoul()

#include <windns.h>
#include <dnsapi.h>

#include "dnslib.h"
#include "..\resolver\idl\resrpc.h"
#include "dnsapip.h"
#include "dnslibp.h"
#endif

#include "svcguid.h"    // RnR guids


//  Use dnslib memory routines
#if 0
#define ALLOCATE_HEAP(iSize)            Dns_Alloc(iSize)
#define ALLOCATE_HEAP_ZERO(iSize)       Dns_AllocZero(iSize)
#define REALLOCATE_HEAP(pMem,iSize)     Dns_Realloc((pMem),(iSize))
#define FREE_HEAP(pMem)                 Dns_Free(pMem)
#endif

//  Debug flag

DWORD   LocalDebugFlag;

//
//  Printing
//

#define dnsup_PrintRoutine  ((PRINT_ROUTINE) fprintf)

#define dnsup_PrintContext  ((PPRINT_CONTEXT) stdout)

//
//  Special names and buffers
//

PCHAR   SingleLongName = "longname";
CHAR    SeLongName[] = "longname";

PCHAR   LongName = ( "longname"
                    ".label22222222222222222222222222222222222222222222222222"
                    ".label33333333333333333333333333333333333333333333333333"
                    ".label44444444444444444444444444444444444444444444444444"
                    ".label55555555555555555555555555555555555555555555555555"
                    ".label66666666666666666666666666666666666666666666666666.");

#define LONG_LABEL_NAME ("longlabel" \
        ".longlabel2222222222222222222222222222222222222222222222222222222222")

CHAR    NameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];

CHAR    AddressBuffer[ sizeof(DNS_IP6_ADDRESS) ];


//
//  Quit or Exit status
//

#define ERROR_DNSUP_QUIT    ((DNS_STATUS)(0x87654321))



//
//  Command table setup
//

typedef DNS_STATUS (* COMMAND_FUNCTION)( DWORD Argc, CHAR** Argv);

typedef struct _COMMAND_INFO
{
    PSTR                pszCommandName;
    PSTR                pszDescription;
    COMMAND_FUNCTION    pCommandFunction;
}
COMMAND_INFO, *LPCOMMAND_INFO;

//
//  Note, command table is at bottom of file to
//  avoid need for prototyping all the functions
//

extern COMMAND_INFO GlobalCommandInfo[];




COMMAND_FUNCTION
GetCommandFunction(
    IN      PSTR            pszCommandName
    )
{
    DWORD i;

    //
    //  find command in list matching string
    //

    i = 0;
    while( GlobalCommandInfo[i].pszCommandName )
    {
        if( _stricmp(
                pszCommandName,
                GlobalCommandInfo[i].pszCommandName ) == 0 )
        {
            return( GlobalCommandInfo[i].pCommandFunction );
        }
        i++;
    }
    return( NULL );
}



//
//  Print utils
//

VOID
PrintCommands(
    VOID
    )
{
    DWORD i;

    //
    //  print all commands in list
    //

    i = 0;
    while( GlobalCommandInfo[i].pszCommandName )
    {
        printf(
            "    %10s  (%s)\n",
            GlobalCommandInfo[i].pszCommandName,
            GlobalCommandInfo[i].pszDescription );
        i++;
    }
}


VOID
PrintDnsQueryFlags(
    VOID
    )
{
    DWORD i;

    //
    //  print query flags
    //

    printf(
        "DNS Query flags:\n"
        "\tDNS_QUERY_STANDARD               = 0x%x\n"
        "\tDNS_QUERY_ACCEPT_PARTIAL_UDP     = 0x%x\n"
        "\tDNS_QUERY_USE_TCP_ONLY           = 0x%x\n"
        "\tDNS_QUERY_NO_RECURSION           = 0x%x\n"
        "\tDNS_QUERY_BYPASS_CACHE           = 0x%x\n"
        "\tDNS_QUERY_NO_WIRE_QUERY          = 0x%x\n"
        "\tDNS_QUERY_NO_HOSTS_FILE          = 0x%x\n"
        "\tDNS_QUERY_NO_LOCAL_NAME          = 0x%x\n",
        DNS_QUERY_STANDARD              ,
        DNS_QUERY_ACCEPT_PARTIAL_UDP    ,
        DNS_QUERY_USE_TCP_ONLY          ,
        DNS_QUERY_NO_RECURSION          ,
        DNS_QUERY_BYPASS_CACHE          ,
        DNS_QUERY_NO_WIRE_QUERY         ,
        DNS_QUERY_NO_HOSTS_FILE         ,
        DNS_QUERY_NO_LOCAL_NAME     
        );
}



//
//  Optional DNS server list to use
//
//  Overides default list on this client for some commands
//

PIP_ARRAY pDnsServerArray = NULL;

DNS_STATUS
readNameServers(
    IN  PIP_ARRAY * ppIpServers,
    IN  DWORD *     pArgc,
    IN  PSTR  **    pArgv
    )
{
    DWORD       argc = *pArgc;
    PCHAR *     argv = *pArgv;
    PCHAR *     startArgv;
    PCHAR       arg;
    CHAR        ch;
    IP_ADDRESS  ipserver;
    PIP_ARRAY   aipservers = NULL;
    DWORD       countServers = 0;
    DWORD       i;

    //
    //  -n / -N denotes DNS server
    //  server IP immediate follows (in same arg)
    //

    startArgv = argv;

    while ( argc )
    {
        arg = argv[0];
        if ( '-' == *arg++ )
        {
            ch = *arg++;
            if ( ch == 'n' || ch == 'N' )
            {
                countServers++;
                argc--;
                argv++;
                continue;
            }
        }
        break;
    }

    //
    //  found servers
    //      - allocate IP array
    //      - parse servers into it
    //      - reset callers Argc, Argv
    //

    if ( countServers )
    {
        *pArgc = argc;
        *pArgv = argv;
        argv = startArgv;

        aipservers = DnsCreateIpArray( countServers );
        if ( ! aipservers )
        {
            return( ERROR_OUTOFMEMORY );
        }

        for (i=0; i<(INT)countServers; i++)
        {
            arg = (*argv++) + 2;
            if ( *arg == '.' )
            {
                arg = "127.0.0.1";
            }
            ipserver = inet_addr( arg );
            if ( ipserver == INADDR_NONE )
            {
                printf( "ERROR: name server IP (in arg %s) is bogus\n", arg );
                return( ERROR_INVALID_PARAMETER );
            }
            IF_DNSDBG( INIT )
            {
                DNS_PRINT((
                    "Read name server address from arg %s.\n",
                    arg ));
            }
            aipservers->AddrArray[i] = ipserver;
        }

        DnsDbg_IpArray(
            "Name servers to register with\n",
            NULL,
            aipservers );
    }

    *ppIpServers = aipservers;
    return( ERROR_SUCCESS );
}



DNS_STATUS
ProcessCommandLine(
    IN      INT             Argc,
    IN      CHAR **         Argv
    )
/*++

Routine Description:

    Process command in Argc\Argv form.

Arguments:

    Argc -- arg count

    Argv -- argument list
        Argv[0] -- dnsup
        Argv[1] -- Command to execute
        Argv[2...] -- arguments to command

Return Value:

    Return from the desired command.
    Usually a pass through of the return code from DNS Update API call.

--*/
{
    DNS_STATUS          status;
    COMMAND_FUNCTION    pcommandFunction;
    PCHAR               pcommand;

    if ( Argc < 1 )
    {
        goto Usage;
    }
    DNS_PRINT(( "Argc = %d\n", Argc ));

    //
    //  check for server list
    //

    status = readNameServers(
                & pDnsServerArray,
                & Argc,
                & Argv );
    if ( status != ERROR_SUCCESS )
    {
        goto Usage;
    }

    //
    //  next param is command
    //      - optionally decorated with leading "-"
    //  

    if ( Argc < 1 )
    {
        goto Usage;
    }
    pcommand = Argv[0];
    if ( *pcommand == '-' )
    {
        pcommand++;
    }

    pcommandFunction = GetCommandFunction( pcommand );
    if ( ! pcommandFunction )
    {
        status = ERROR_INVALID_PARAMETER;
        printf( "Unknown Command Specified -- type dnsup -?.\n" );
        goto Usage;
    }

    //
    //  dispatch to processor for this command
    //      - skip over command argv

    Argc--;
    Argv++;
    status = pcommandFunction( Argc, Argv );
    
    if ( status == ERROR_SUCCESS ||
         status == ERROR_DNSUP_QUIT )
    {
        printf( "Command successfully completed.\n" );
    }
    else
    {
        printf( "Command failed, %d (%ul)\n", status, status );
    }
    return( status );

Usage:

    printf(
        "DnsUp command line:\n"
        "\t[-n<Server IP List>] -<Command> [Command Parameters].\n"
        "\t<Server IP List> is a list of one or more DNS server IP addresses\n"
        "\t\toverriding the default list on this client\n"
        "Commands:\n"
        );
    PrintCommands();
    return( ERROR_INVALID_PARAMETER );
}



VOID
InteractiveLoop(
    VOID
    )
/*++

Routine Description:

    Interactive loop.

Arguments:

    None

Return Value:

    None

--*/
{
#define MAX_ARG_COUNT   50

    DNS_STATUS  status;
    INT         argc;
    CHAR *      argv[ MAX_ARG_COUNT ];
    CHAR        lineBuffer[500];


    //
    //  loop taking command params
    //

    while ( 1 )
    {
        printf( "\n> " );

        //  read next command line

        gets( lineBuffer );

        argc = Dns_TokenizeString(
                    lineBuffer,
                    argv,
                    MAX_ARG_COUNT );

        DNS_PRINT(( "argc = %d\n", argc ));

        IF_DNSDBG( INIT )
        {
            DnsDbg_Argv(
                NULL,
                argv,
                argc,
                FALSE   // not unicode
                );
        }

        //  process next command line

        status = ProcessCommandLine(
                    argc,
                    argv );

        if ( status == ERROR_DNSUP_QUIT )
        {
            break;
        }
    }
}



LONG
__cdecl
main(
    IN      INT             Argc,
    IN      CHAR **         Argv
    )
/*++

Routine Description:

    DnsUp program entry point.

    Executes specified command corresponding to a DNS update API operation.

Arguments:

    Argc -- arg count

    Argv -- argument list
        Argv[0] -- dnsup
        Argv[1] -- Command to execute
        Argv[2...] -- arguments to command

Return Value:

    Zero if successful.
    1 on error.

--*/
{
    DNS_STATUS          status;

    //
    //  initialize debug
    //

    Dns_StartDebugEx(
        0,                  //  no flag value
        "dnsup.flag",       //  read flag from file
        NULL,   //&LocalDebugFlag,
        "dnsup.log",        //  log to file
        0,                  //  no wrap limit
        FALSE,              //  don't use existing global
        FALSE,
        TRUE                //  make this file global
        );

    DNS_PRINT(( "*pDnsDebugFlag = %08x\n", *pDnsDebugFlag ));
    //DNS_PRINT(( "LocalDebugFlag = %08x\n", LocalDebugFlag ));

    if ( Argc < 1 )
    {
        goto Usage;
    }
    DNS_PRINT(( "Argc = %d\n", Argc ));

    //  skip "dnsup" argument 

    Argc--;
    Argv++;

    //
    //  interactive mode?
    //      - if no command, just open interactively
    //

    if ( Argc == 0 )
    {
        InteractiveLoop();
        status = ERROR_SUCCESS;
    }
    else
    {
        status = ProcessCommandLine(
                    Argc,
                    Argv );
    }

    Dns_EndDebug();

    return( status != ERROR_SUCCESS );

Usage:

    Dns_EndDebug();
    printf(
        "usage:  DnsUp [-n<Server IP List>] -<Command> [Command Parameters].\n"
        "\t<Server IP List> is a list of one or more DNS server IP addresses\n"
        "\t\toverriding the default list on this client\n"
        "Commands:\n"
        );
    PrintCommands();
    return(1);
}




//
//  Command processing
//

PDNS_RECORD
buildRecordList(
    IN      DWORD           Argc,
    IN      PSTR  *         Argv
    )
/*++

Routine Description:

    Build record list from Argc \ Argv list.

Arguments:

    Argc -- arg count

    Argv -- argument list

Return Value:

    Ptr to list of records built.
    NULL on parsing error.

--*/
{
    PCHAR           arg;
    PCHAR           pszname;
    WORD            type;
    BOOLEAN         fadd;
    BOOLEAN         section;
    CHAR            ch;
    PDNS_RECORD     prr;
    DNS_RRSET       rrset;
    INT             recordArgc;
    PCHAR *         recordArgv;

    //
    //  loop through remaining arguments building appropriate record types
    //

    DNS_RRSET_INIT( rrset );
    recordArgc = (-3);
    pszname = NULL;

    while ( Argc-- && (arg = *Argv++) )
    {
        //
        //  if previous arg started new record, first parameter is name
        //

        if ( recordArgc == (-2) )
        {
            pszname = arg;
            type = 0;
            recordArgc++;
            continue;
        }

        //
        //  second parameter is type
        //

        else if ( recordArgc == (-1) )
        {
            type = DnsRecordTypeForName( arg, 0 );
            if ( type == 0 )
            {
                printf( "ERROR:  unknown type %s.\n", arg );
                goto Failed;
            }
            recordArgc++;
            continue;
        }

        //
        //  check for end of existing record \ start of new record
        //

        ch = *arg;

        if ( ch == '+' || ch == '-' )
        {
            //  build old record (if any)

            if ( pszname != NULL )
            {
                prr = Dns_RecordBuild_A(
                        & rrset,
                        pszname,
                        type,
                        fadd,
                        section,
                        recordArgc,
                        recordArgv );
                if ( !prr )
                {
                    printf( "ERROR:  building record.\n" );
                    goto Failed;
                }
                if ( fadd && section == DNSREC_UPDATE )
                {
                    prr->dwTtl = 3600;
                }
            }

            fadd = ( ch == '+' );
            recordArgc = (-2);

            //
            //  second character in new arg, indicates section
            //      - for update ADD records use 3600 TTL instead of zero
            //

            ch = *++arg;
            if ( ch == 0 )
            {
                section = DNSREC_QUESTION;
            }
            else if ( ch == 'p' )
            {
                section = DNSREC_PREREQ;
            }
            else if ( ch == 'u' )
            {
                section = DNSREC_UPDATE;
            }
            else if ( ch == 'a' )
            {
                section = DNSREC_ADDITIONAL;
            }
            else
            {
                printf( "ERROR:  unknown section id %d.\n", ch );
                goto Failed;
            }
            continue;
        }

        //  catch bad starting record (no +/-)

        else if ( recordArgc < 0 )
        {
            printf( "ERROR:  bad start of record arg %s\n", arg );
            goto Failed;
        }

        //
        //  anything else is data, save in argv format
        //      - save starting point
        //      - count records

        else if ( recordArgc == 0 )
        {
            recordArgv = --Argv;
            Argv++;
        }
        recordArgc++;
        continue;
    }

    //
    //  build any final record
    //

    if ( pszname != NULL )
    {
        prr = Dns_RecordBuild_A(
                & rrset,
                pszname,
                type,
                fadd,
                section,
                recordArgc,
                recordArgv );
        if ( !prr )
        {
            printf( "ERROR:  building record.\n" );
            goto Failed;
        }
        if ( fadd && section == DNSREC_UPDATE )
        {
            prr->dwTtl = 3600;
        }
    }
    IF_DNSDBG( INIT )
    {
        DnsDbg_RecordSet(
            "Record set:\n",
            rrset.pFirstRR );
    }

    return( rrset.pFirstRR );

Failed:

    printf( "ERROR:  building records from arguments.\n" );
    SetLastError( ERROR_INVALID_PARAMETER );
    return( NULL );
}



PCHAR
getNamePointer(
    IN      PSTR            pszName
    )
/*++

Routine Description:

    Get name pointer.

    This may be legit pointer or tag
    Tags:
        - null
        - blank
        - badptr
        - badname
        - longname
        - longlabel
        - buffer

Arguments:

    Argc -- arg count

    Argv -- argument list

Return Value:

    Ptr to list of records built.
    NULL on parsing error.

--*/
{
    PCHAR   pname = pszName;

    //
    //  check special case names
    //

    if ( _stricmp( pname, "null" ) == 0 )
    {
        pname = NULL;
    }
    else if ( _stricmp( pname, "blank" ) == 0 )
    {
        pname = "";
    }
    else if ( _stricmp( pname, "badname" ) == 0 )
    {
        pname = "..badname..";
    }
    else if ( _stricmp( pname, "longname" ) == 0 )
    {
        //pname = LONG_NAME;
        pname = LongName;
    }
    else if ( _stricmp( pname, "longlabel" ) == 0 )
    {
        pname = LONG_LABEL_NAME;
    }
    else if ( _stricmp( pname, "badptr" ) == 0 )
    {
        pname = (PCHAR) (-1);
    }
    else if ( _stricmp( pname, "buffer" ) == 0 )
    {
        pname = (PCHAR) NameBuffer;
    }

    return( pname );
}



BOOL
getAddressPointer(
    IN      PSTR            pAddrString,
    OUT     PCHAR *         ppAddr,
    OUT     PDWORD          pLength,
    OUT     PDWORD          pFamily
    )
/*++

Routine Description:

    Get address from address string argument.

    Wraps up special arguments (NULL, badptr), with string
    to address conversion.

Arguments:

    pAddrString -- address as string

    pAddr   -- ptr to recv address

    pLength -- ptr to recv length of returned address

    pFamily -- ptr to recv family (socket family) of returned address

Return Value:

    TRUE if valid address converted.
    FALSE if special ptr or pass through.

--*/
{
    PCHAR   paddr;
    INT     length = sizeof(IP4_ADDRESS);
    INT     family = AF_INET;
    BOOL    result = FALSE;

    //
    //  first check for special cases
    //      - default to AF_INET
    //

    if ( _stricmp( pAddrString, "null" ) == 0 )
    {
        paddr = NULL;
    }
    else if ( _stricmp( pAddrString, "blank" ) == 0 )
    {
        paddr = "";
        length = 0;
    }
    else if ( _stricmp( pAddrString, "badptr" ) == 0 )
    {
        paddr = (PCHAR) (-1);
    }

    //
    //  not-special -- treat as address string
    //      - use type and length on successful conversion
    //      - just return pAddrString and it's length if not successful
    //

    else 
    {
        family = 0;     // any family
        length = sizeof(AddressBuffer);

        result = Dns_StringToAddress_A(
                        AddressBuffer,
                        & length,
                        pAddrString,
                        & family );
        if ( result )
        {
            paddr = AddressBuffer;
        }
        else
        {
            paddr = pAddrString;
            length = strlen( pAddrString );
            family = AF_INET;
        }
    }

    *ppAddr  = paddr;
    *pLength = length;
    *pFamily = family;

    return( result );
}



BOOL
getSockaddrFromString(
    IN OUT  PSOCKADDR *     ppSockaddr,
    IN OUT  PDWORD          pSockaddrLength,
    IN      PSTR            pAddrString
    )
/*++

Routine Description:

    Get sockaddr from address string argument.

    Wraps up special arguments (NULL, badptr), with string
    to address conversion.

Arguments:

    ppSockaddr -- addr of ptr to sockaddr buffer
        on return may be set to point at dummy sockaddr

    pSockaddrLength -- addr with sockaddr buffer length
        receives sockaddr length

    pAddrString -- address as string

Return Value:

    TRUE if parsed sockaddr string
        Note this does not mean it is a valid sockaddr.
    FALSE if special ptr or pass through.

--*/
{
    PCHAR       paddr = NULL;
    DWORD       addrLength;
    DWORD       family;
    DWORD       flags = 0;
    DNS_STATUS  status;

    //
    //  convert address string
    //
    //  if valid string => write into given sockaddr
    //  if invalid => set sockaddr ptr to dummy sockaddr
    //

    if ( getAddressPointer(
                pAddrString,
                & paddr,
                & addrLength,
                & family ) )
    {
        status = Dns_AddressToSockaddr(
                        *ppSockaddr,
                        pSockaddrLength,
                        TRUE,       // clear sockaddr
                        paddr,
                        addrLength,
                        family );

        if ( status != NO_ERROR )
        {
            DNS_ASSERT( FALSE );
            return  FALSE;
        }
    }
    else    // special bogus address, use it directly
    {
        *ppSockaddr = (PSOCKADDR) paddr;
    }
    return  TRUE;
}




//
//  Command functions
//

DNS_STATUS
ProcessQuit(
    IN      DWORD           Argc,
    IN      PSTR  *         Argv
    )
{
    //
    //  alert command processor to break iteractive loop
    //

    return( ERROR_DNSUP_QUIT );
}




//
//  Update routines
//
//  DCR:  could add context handle interface to update routines
//

DNS_STATUS
ProcessUpdate(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    DWORD           flags = 0;
    PCHAR           arg;
    PDNS_RECORD     prr = NULL;
    PDNS_MSG_BUF    pmsgRecv = NULL;
    HANDLE          hCreds=NULL;

    //
    //  flags?
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    arg = Argv[0];
    if ( strncmp( arg, "-f", 2 ) == 0 )
    {
        flags = strtoul( arg+2, NULL, 16 );
        Argc--;
        Argv++;
    }

    //
    //  build update packet RRs
    //

    prr = buildRecordList(
                Argc,
                Argv );
    if ( !prr )
    {
        status = GetLastError();
        if ( status != ERROR_SUCCESS )
        {
            printf( "ERROR:  building records from arguments\n" );
            goto Usage;
        }
    }

    //
    //  build \ send update
    //

    status = DnsUpdate(
                prr,
                flags,
                NULL,       // no UPDATE adapter list specified
                hCreds,
                &pmsgRecv
                );
    if ( pmsgRecv )
    {
        DnsPrint_Message(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            "Update response:\n",
            pmsgRecv );
    }

    Dns_RecordListFree( prr );

    FREE_HEAP( pmsgRecv );

    if ( status != ERROR_SUCCESS )
    {
        printf(
            "DnsUpdate failed, %x %s.\n",
            status,
            DnsStatusString(status) );
    }
    else
    {
        printf( "Update successfully completed.\n" );
    }
    return( status );

Usage:

    Dns_RecordListFree( prr );

    printf(
        "DnsUpdate\n"
        "usage:\n"
        "  DnsUp -u [-f<Flags>] [<Record> | ...]\n"
        "   <Record> record for update packet\n"
        "   <Record> == (-,+)(p,u,a) <Name> <Type> [Data | ...]\n"
        "       (-,+)   - add or delete, exist or no-exist flag\n"
        "       (p,u,a) - prereq, update or additional section\n"
        "       <Name>  - RR owner name\n"
        "       <Type>  - record type (ex A, SRV, PTR, TXT, CNAME, etc.)\n"
        "       <Data>  - data strings (type specific), if any\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessUpdateTest(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    DWORD           flags = 0;
    PCHAR           pszzone = NULL;
    PCHAR           arg;
    PDNS_RECORD     prr = NULL;
    PDNS_MSG_BUF    pmsg = NULL;
    PDNS_MSG_BUF    pmsgRecv = NULL;
    IP_ADDRESS      ipserver;
    PIP_ARRAY       aipservers = NULL;
    PSTR            pszserverName = NULL;
    HANDLE          hCreds = NULL;

    //
    //  optional name server to query?
    //

    aipservers = pDnsServerArray;
    if ( !aipservers )
    {
        aipservers = Dns_GetDnsServerList( FALSE );
    }
    if ( !aipservers )
    {
        printf( "Update failed:  no DNS server list available.\n" );
        return( GetLastError() );
    }

    //
    //  flags?
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    arg = Argv[0];
    if ( strncmp( arg, "-f", 2 ) == 0 )
    {
        flags = strtoul( arg+2, NULL, 16 );
        Argc--;
        Argv++;
    }

    //
    //  security -- then need target server name
    //      presence of server name automatically turns on security
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    arg = Argv[0];
    if ( strncmp( arg, "-s", 2 ) == 0 )
    {
        pszserverName = arg+2;
        flags |= DNS_UPDATE_SECURITY_ONLY;
        Argc--;
        Argv++;
    }

    //
    //  name of zone to update
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    arg = Argv[0];
    if ( *arg != '-' && *arg != '+' )
    {
        pszzone = arg;
        DNSDBG( INIT, (
            "Read update zone name %s\n",
            pszzone ));
        Argc--;
        Argv++;
    }

    //
    //  build update packet RRs
    //

    prr = buildRecordList(
                Argc,
                Argv );
    if ( !prr )
    {
        status = GetLastError();
        if ( status != ERROR_SUCCESS )
        {
            printf( "ERROR:  building records from arguments\n" );
            goto Usage;
        }
    }

    //
    //  build \ send update
    //

    status = Dns_UpdateLibEx(
                prr,
                flags,
                pszzone,
                pszserverName,
                aipservers,
                NULL,
                &pmsgRecv
                );
    if ( pmsgRecv )
    {
        DnsPrint_Message(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            "Update response:\n",
            pmsgRecv );
    }

    FREE_HEAP( aipservers );
    Dns_RecordListFree( prr );
    FREE_HEAP( pmsg );
    FREE_HEAP( pmsgRecv );

    if( status != ERROR_SUCCESS )
    {
        printf(
            "DnsUpdateEx failed, %x %s.\n",
            status,
            DnsStatusString(status) );
    }
    else
    {
        printf( "Update successfully completed.\n" );
    }
    return( status );

Usage:

    FREE_HEAP( aipservers );
    Dns_RecordListFree( prr );
    FREE_HEAP( pmsg );
    FREE_HEAP( pmsgRecv );

    printf(
        "UpdateTest -- Dns_UpdateLibEx\n"
        "usage:\n"
        "  DnsUp [-n<DNS IP>|...] -ut [-f<Flags>] [-s<ServerName>] [<ZoneName>] [<Record> | ...]\n"
        "   <DNS IP> optional IP address of server to send update to.\n"
        "   <ServerName> name of DNS server we are sending update to;\n"
        "       presence of server name automatically turns on update security\n"
        "   <ZoneName> name of zone to update\n"
        "   <Record> record for update packet\n"
        "   <Record> == (-,+)(p,u,a) <Name> <Type> [Data | ...]\n"
        "       (-,+)   - add or delete, exist or no-exist flag\n"
        "       (p,u,a) - prereq, update or additional section\n"
        "       <Name>  - RR owner name\n"
        "       <Type>  - record type (ex A, SRV, PTR, TXT, CNAME, etc.)\n"
        "       <Data>  - data strings (type specific), if any\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessDhcpTest(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS              status;
    REGISTER_HOST_ENTRY     hostEntry;
    REGISTER_HOST_STATUS    hostStatus;
    HANDLE                  doneEvent;

    //
    //  create completion event
    //

    doneEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    //
    //  build dumpy DHCP update
    //

    hostEntry.Addr.ipAddr = 0x01010101;
    hostEntry.dwOptions = REGISTER_HOST_A;
    hostStatus.hDoneEvent = doneEvent;

    //
    //  send to DHCP DynDNS update routine
    //

    status = DnsAsyncRegisterHostAddrs(
                L"El59x1",
                L"testdhcpname",
                &hostEntry,
                1,              // address count
                NULL, // no regkey with previous
                0,
                L"nttest.microsoft.com",
                & hostStatus,
                60,        // TTL
                0
                );

    if( status != ERROR_SUCCESS )
    {
        printf(
            "DnsAsynRegisterHostAddrs_W() %s.\n",
            status,
            DnsStatusString(status) );
        return( status );
    }

    printf( "DHCP DynDNS registration successfully completed.\n" );

    WaitForSingleObject(
        doneEvent,
        INFINITE );

    return( status );
}



//
//  Query routines
//

DNS_STATUS
ProcessQueryEx(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    PCHAR           pszname;
    WORD            type;
    DWORD           flags = 0;
    PDNS_MSG_BUF    pmsgRecv = NULL;
    HANDLE          hevent = NULL;
    DNS_QUERY_INFO  queryInfo;

    //
    //  name to query
    //

    if ( Argc < 2 || Argc > 4 )
    {
        goto Usage;
    }
    pszname = Argv[0];
    Argc--;
    Argv++;

    //
    //  type
    //

    type = DnsRecordTypeForName( Argv[0], 0 );
    if ( type == 0 )
    {
        goto Usage;
    }
    Argc--;
    Argv++;

    //
    //  flags and options
    //

    while ( Argc )
    {
        if ( _stricmp( Argv[0], "-a" ) == 0 )
        {
            hevent = CreateEvent( NULL, FALSE, FALSE, NULL );
        }
        else
        {
            flags = strtoul( Argv[0], NULL, 16 );
        }
        Argc--;
        Argv++;
    }

    //
    //  query
    //

    RtlZeroMemory(
        & queryInfo,
        sizeof(queryInfo) );

    queryInfo.pName         = pszname;
    queryInfo.Type          = type;
    queryInfo.Flags         = flags;
    queryInfo.pDnsServers   = pDnsServerArray;
    queryInfo.hEvent        = hevent;

    status = DnsQueryEx( &queryInfo );

    if ( status == ERROR_IO_PENDING )
    {
        printf(
            "DnsQueryEx() running asynchronously.\n"
            "\tEvent = %p\n",
            hevent );

        WaitForSingleObject( hevent, INFINITE );

        printf( "DnsQueryEx() async completion.\n" );

        status = queryInfo.Status;
    }

    if ( status == ERROR_SUCCESS ||
         status == DNS_ERROR_RCODE_NAME_ERROR ||
         status == DNS_INFO_NO_RECORDS )
    {
        printf(
            "DnsQueryEx() completed => %s.\n"
            "\tstatus = %d\n",
            DnsStatusString( status ),
            status );

        DnsPrint_QueryInfo(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            "DnsQueryEx() result",
            &queryInfo );
    }
    else
    {
        printf(
            "DnsQueryEx() failed, %x %s.\n",
            status,
            DnsStatusString(status) );

        DNS_ASSERT( !queryInfo.pAnswerRecords );
        DNS_ASSERT( !queryInfo.pAliasRecords );
        DNS_ASSERT( !queryInfo.pAdditionalRecords );
        DNS_ASSERT( !queryInfo.pAuthorityRecords );
    }

    return( status );

Usage:

    printf(
        "DnsQueryEx\n"
        "usage:\n"
        "  DnsUp [-n<DNS IP>|...] -qex <Name> <Type> <Flags> [-a]\n"
        "   <DNS IP> optional IP address of DNS server to query.\n"
        "   <Name> DNS name to query\n"
        "   <Type> type of query\n"
        "   <Flags> flags to use in query (in hex)\n"
        "   -a to indicate asynchronous operation\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessQueryCompare(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    PCHAR           pszname;
    WORD            type;
    PIP_ARRAY       aipservers;
    PDNS_MSG_BUF    pmsgRecv = NULL;
    PDNS_RECORD     prrQuery;
    PDNS_RECORD     prrParsed;
    PDNS_RECORD     prrQueryDiff;
    PDNS_RECORD     prrParsedDiff;

    //
    //  optional name server to query?
    //

    aipservers = pDnsServerArray;

    //
    //  name to query
    //

    if ( Argc < 2 )
    {
        goto Usage;
    }
    pszname = Argv[0];
    Argc--;
    Argv++;

    //
    //  type
    //

    type = DnsRecordTypeForName( Argv[0], 0 );
    if ( type == 0 )
    {
        goto Usage;
    }
    Argc--;
    Argv++;

    //
    //  build expected RR set
    //

    prrParsed = buildRecordList(
                    Argc,
                    Argv );
    if ( !prrParsed )
    {
        status = GetLastError();
        if ( status != ERROR_SUCCESS )
        {
            printf( "ERROR:  building records from arguments\n" );
            goto Usage;
        }
    }
    DnsPrint_RecordSet(
        dnsup_PrintRoutine,
        dnsup_PrintContext,
        "Parsed comparison record list:\n",
        prrParsed );

    //
    //  query
    //
    //  DCR:  waiting for new DnsQueryEx()
    //

    return( ERROR_CALL_NOT_IMPLEMENTED );

#if 0
    status = DnsQueryEx(
                & pmsgRecv,
                & prrQuery,
                pszname,
                type,
                0,          // currently no flag support
                aipservers,
                NULL
                );

    if( status != ERROR_SUCCESS )
    {
        printf(
            "DnsQueryEx() failed, %x %s.\n",
            status,
            DnsStatusString(status) );
        if ( DnsIsStatusRcode(status) )
        {
            DnsPrint_Message(
                dnsup_PrintRoutine,
                dnsup_PrintContext,
                "Query response:\n",
                pmsgRecv );
        }
        return( status );
    }
    DnsPrint_RecordSet(
        dnsup_PrintRoutine,
        dnsup_PrintContext,
        "Query response records:\n",
        prrQuery );


    //
    //  compare with records received
    //

    DnsRecordSetCompare(
        prrQuery,
        prrParsed,
        & prrQueryDiff,
        & prrParsedDiff );

    DnsPrint_RecordSet(
        dnsup_PrintRoutine,
        dnsup_PrintContext,
        "Unmatch records in query response:\n",
        prrQueryDiff );

    DnsPrint_RecordSet(
        dnsup_PrintRoutine,
        dnsup_PrintContext,
        "Unmatch records in parsed list:\n",
        prrParsedDiff );

    return( ERROR_SUCCESS );
#endif

Usage:

    printf(
        "Query compare\n"
        "usage:\n"
        "  DnsUp [-n<DNS IP>|...] -qc <Name> <Type> [<Record> | ...]\n"
        "   <DNS IP> optional IP address of DNS server to update.\n"
        "   <Name> DNS name to query\n"
        "   <Type> type of query\n"
        "   <Record> record in list to compare\n"
        "   <Record> == (-,+) <Name> <Type> [Data | ...]\n"
        "       (-,+) - add or delete, exist or no-exist flag\n"
        "       <Name> - RR owner name\n"
        "       <Type> - record type\n"
        "       <Data> - data strings (type specific), if any\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessQuery(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    PCHAR           pszname;
    WORD            type;
    DWORD           flags = 0;
    PDNS_RECORD     precord = NULL;
    PDNS_MSG_BUF    pmsgRecv = NULL;
    PDNS_MSG_BUF *  ppmsgRecv = NULL;
    PIP_ARRAY       aipservers = NULL;

    //
    //  name to query
    //

    if ( Argc < 2 || Argc > 3 )
    {
        goto Usage;
    }

    pszname = getNamePointer( Argv[0] );
    Argc--;
    Argv++;

    //
    //  type
    //

    type = DnsRecordTypeForName( Argv[0], 0 );
    if ( type == 0 )
    {
        goto Usage;
    }
    Argc--;
    Argv++;

    //
    //  flags
    //

    if ( Argc )
    {
        flags = strtoul( Argv[0], NULL, 16 );
        Argc--;
        Argv++;
    }
    if ( Argc )
    {
        goto Usage;
    }

    //
    //  only if flag has BYPASS_CACHE set can we
    //      1) send to specific servers
    //      2) receive message buffer itself
    //

    aipservers = pDnsServerArray;

    if ( flags & DNS_QUERY_BYPASS_CACHE )
    {
        ppmsgRecv = & pmsgRecv;
    }

    //
    //  query
    //

    status = DnsQuery(
                pszname,
                type,
                flags,
                aipservers,
                & precord,
                ppmsgRecv );

    if( status != ERROR_SUCCESS )
    {
        printf(
            "DnsQuery() failed, %x %s.\n",
            status,
            DnsStatusString(status) );
        if ( DnsIsStatusRcode(status) && pmsgRecv )
        {
            DnsPrint_Message(
                dnsup_PrintRoutine,
                dnsup_PrintContext,
                "Query response:\n",
                pmsgRecv );
        }
    }
    else
    {
        printf( "DnsQuery() successfully completed.\n" );
        if ( pmsgRecv )
        {
            DnsPrint_Message(
                dnsup_PrintRoutine,
                dnsup_PrintContext,
                "Query response:\n",
                pmsgRecv );
        }
        DnsPrint_RecordSet(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            "Query response records:\n",
            precord );
    }

    DnsRecordListFree( precord, DnsFreeRecordListDeep );
    return( status );

Usage:

    printf(
        "DnsQuery\n"
        "usage:\n"
        "  DnsUp [-n<DNS IP>|...] -q <Name> <Type> [<Flags>]\n"
        "   <DNS IP> optional IP address of DNS server to query.\n"
        "   <Name> DNS name to query\n"
        "   <Type> type of query\n"
        "   <Flags> flags to use in query (in hex)\n"
        "\n"
        "  Note for DnsQuery() to use specific server or to return\n"
        "  a DNS message buffer, BYPASS_CACHE flag MUST be set.\n"
        );
    PrintDnsQueryFlags();

    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessQueryMultiple(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    PCHAR           pszname1;
    WORD            type1;
    PCHAR           pszname2;
    WORD            type2;
    DWORD           flags = 0;
    PDNS_RECORD     precord = NULL;
    PDNS_MSG_BUF    pmsgRecv = NULL;
    PDNS_MSG_BUF *  ppmsgRecv = NULL;
    PIP_ARRAY       aipservers = NULL;

    //
    //  optional name server to query?
    //

    if ( Argc < 4 || Argc > 5 )
    {
        goto Usage;
    }

    //
    //  first name to query
    //

    pszname1 = Argv[0];
    Argc--;
    Argv++;

    //
    //  first type
    //

    type1 = DnsRecordTypeForName( Argv[0], 0 );
    if ( type1 == 0 )
    {
        goto Usage;
    }
    Argc--;
    Argv++;

    //
    //  second name to query
    //

    pszname2 = Argv[0];
    Argc--;
    Argv++;

    //
    //  second type
    //

    type2 = DnsRecordTypeForName( Argv[0], 0 );
    if ( type2 == 0 )
    {
        goto Usage;
    }
    Argc--;
    Argv++;

    //
    //  flags
    //

    if ( Argc )
    {
        flags = strtoul( Argv[0], NULL, 16 );
        Argc--;
        Argv++;
    }
    if ( Argc )
    {
        goto Usage;
    }

    //
    //  only if flag has BYPASS_CACHE set can we
    //      1) send to specific servers
    //      2) receive message buffer itself
    //

    if ( flags & DNS_QUERY_BYPASS_CACHE )
    {
        aipservers = pDnsServerArray;
        ppmsgRecv = & pmsgRecv;
    }

    //
    //  make first query
    //

    status = DnsQuery(
                pszname1,
                type1,
                flags,
                aipservers,
                & precord,
                ppmsgRecv );

    if( status != ERROR_SUCCESS )
    {
        printf(
            "DnsQuery() failed, %x %s.\n",
            status,
            DnsStatusString(status) );
        if ( DnsIsStatusRcode(status) && pmsgRecv )
        {
            DnsPrint_Message(
                dnsup_PrintRoutine,
                dnsup_PrintContext,
                "Query response:\n",
                pmsgRecv );
        }
    }
    else
    {
        printf( "DnsQuery() successfully completed.\n" );
        if ( pmsgRecv )
        {
            DnsPrint_Message(
                dnsup_PrintRoutine,
                dnsup_PrintContext,
                "Query response:\n",
                pmsgRecv );
        }
        DnsPrint_RecordSet(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            "Query response records:\n",
            precord );
    }
    DnsRecordListFree( precord, DnsFreeRecordListDeep );

    //
    //  make second query
    //

    status = DnsQuery(
                pszname2,
                type2,
                flags,
                aipservers,
                & precord,
                ppmsgRecv );

    if( status != ERROR_SUCCESS )
    {
        printf(
            "DnsQuery() failed, %x %s.\n",
            status,
            DnsStatusString(status) );
        if ( DnsIsStatusRcode(status) && pmsgRecv )
        {
            DnsPrint_Message(
                dnsup_PrintRoutine,
                dnsup_PrintContext,
                "Query response:\n",
                pmsgRecv );
        }
    }
    else
    {
        printf( "DnsQuery() successfully completed.\n" );
        if ( pmsgRecv )
        {
            DnsPrint_Message(
                dnsup_PrintRoutine,
                dnsup_PrintContext,
                "Query response:\n",
                pmsgRecv );
        }
        DnsPrint_RecordSet(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            "Query response records:\n",
            precord );
    }
    DnsRecordListFree( precord, DnsFreeRecordListDeep );
    return( status );

Usage:

    printf(
        "Multiple DnsQuery()s\n"
        "usage:\n"
        "  DnsUp [-n<DNS IP>|...] -qm <Name1> <Type1> <Name2> <Type2> [<Flags>]\n"
        "   <DNS IP> optional IP address of DNS server to query.\n"
        "   <Name1> DNS name to query\n"
        "   <Type1> type of query\n"
        "   <Name2> DNS name to query\n"
        "   <Type2> type of query\n"
        "   <Flags> flags to use in query (in hex)\n"
        "\n"
        "  Note for DnsQuery() to use specific server or to return\n"
        "  a DNS message buffer, BYPASS_CACHE flag MUST be set.\n"
        );
    PrintDnsQueryFlags();
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessQueryTest(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    PCHAR           pszname;
    WORD            type;
    DWORD           flags = 0;
    PDNS_RECORD     precord = NULL;
    PDNS_MSG_BUF    pmsgRecv = NULL;
    PIP_ARRAY       aipservers = NULL;

    //
    //  optional name server to query?
    //

    aipservers = pDnsServerArray;

    //
    //  name to query
    //

    if ( Argc < 2 || Argc > 3 )
    {
        goto Usage;
    }
    pszname = Argv[0];
    Argc--;
    Argv++;

    //
    //  type
    //

    type = DnsRecordTypeForName( Argv[0], 0 );
    if ( type == 0 )
    {
        goto Usage;
    }
    Argc--;
    Argv++;

    //
    //  flags
    //

    if ( Argc )
    {
        flags = strtoul( Argv[0], NULL, 16 );
        Argc--;
        Argv++;
    }
    if ( Argc )
    {
        goto Usage;
    }

    //
    //  query
    //

    status = QueryDirectEx(
                & pmsgRecv,
                & precord,
                NULL,       // no header
                0,          // no header counts
                pszname,
                type,
                NULL,       // no records
                flags,
                aipservers,
                NULL
                );

    if( status != ERROR_SUCCESS )
    {
        printf(
            "QueryDirectEx() failed, %x %s.\n",
            status,
            DnsStatusString(status) );
        if ( DnsIsStatusRcode(status) )
        {
            DnsPrint_Message(
                dnsup_PrintRoutine,
                dnsup_PrintContext,
                "Query response:\n",
                pmsgRecv );
        }
    }
    else
    {
        printf( "QueryDirectEx() successfully completed.\n" );
        DnsPrint_Message(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            "Query response:\n",
            pmsgRecv );
        DnsPrint_RecordSet(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            "Query response records:\n",
            precord );
    }
    DnsRecordListFree( precord, DnsFreeRecordListDeep );
    return( status );

Usage:

    printf(
        "QueryDirectEx()\n"
        "usage:\n"
        "  DnsUp [-n<DNS IP>|...] -qt <Name> <Type> [<Flags>]\n"
        "   QueryTest -- uses dnslib.lib QueryDirectEx()\n"
        "   <DNS IP> optional IP address of DNS server to query.\n"
        "   <Name> DNS name to query\n"
        "   <Type> type of query\n"
        "   <Flags> flags to use in query (in hex)\n"
        );
    return( ERROR_INVALID_PARAMETER );
}

#if 0

DNS_STATUS
ProcessUpdateMultiple(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    DWORD           flags = 0;
    PCHAR           pszzone = NULL;
    PCHAR           pszname = NULL;
    IP_ADDRESS      ip;
    IP_ADDRESS      hostIp;
    DWORD           countIp;
    DWORD           i;
    PCHAR           arg;
    PDNS_RECORD     prr = NULL;
    PDNS_MSG_BUF    pmsg = NULL;
    PDNS_MSG_BUF    pmsgRecv = NULL;
    IP_ADDRESS      ipserver;
    PIP_ARRAY       aipservers = NULL;
    PIP_ARRAY       ipArray = NULL;
    PSTR            pszserverName = NULL;
    HANDLE          hCreds=NULL;

    //
    //  optional name server to query?
    //

    aipservers = pDnsServerArray;
    if ( !aipservers )
    {
        aipservers = Dns_GetDnsServerList( FALSE );
    }
    if ( !aipservers )
    {
        printf( "Update failed:  no DNS server list available.\n" );
        return( GetLastError() );
    }

    //
    //  flags?
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    arg = Argv[0];
    if ( strncmp( arg, "-f", 2 ) == 0 )
    {
        flags = strtoul( arg+2, NULL, 16 );
        Argc--;
        Argv++;
    }

    //
    //  security -- then need target server name
    //      presence of server name automatically turns on security
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    arg = Argv[0];
    if ( strncmp( arg, "-s", 2 ) == 0 )
    {
        pszserverName = arg+2;
        flags |= DNS_UPDATE_SECURITY_ON;
        Argc--;
        Argv++;
    }

    //
    //  name of zone to update
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    pszzone = Argv[0];
    DNSDBG( INIT, (
        "Read update zone name %s\n",
        pszzone ));
    Argc--;
    Argv++;

    //
    //  name to update
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    pszname = Argv[0];
    DNSDBG( INIT, (
        "Read update host name %s\n",
        pszname ));
    Argc--;
    Argv++;

    //
    //  start IP
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    ip = inet_addr( Argv[0] );
    if ( ip == (-1) )
    {
        goto Usage;
    }
    Argc--;
    Argv++;

    //
    //  IP count
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    countIp = strtoul( Argv[0], NULL, 10 );
    Argc--;
    Argv++;

    //
    //  build update record list
    //      - allocate and generate IP array
    //      - then create DNS records
    //

    ipArray = Dns_CreateIpArray( countIp );
    if ( !ipArray )
    {
        status = GetLastError();
        if ( status != ERROR_SUCCESS )
        {
            printf( "ERROR:  creating IP array\n" );
            goto Usage;
        }
        goto Usage;
    }

    hostIp = ntohl( ip );

    for ( i=0; i<countIp; i++ )
    {
        ipArray->AddrArray[i] = htonl( hostIp );
        hostIp++;
    }

    prr = Dns_HostUpdateRRSet(
            pszname,
            ipArray,
            3600 );
    if ( !prr )
    {
        status = GetLastError();
        if ( status != ERROR_SUCCESS )
        {
            printf( "ERROR:  building records from arguments\n" );
            goto Usage;
        }
    }

    //
    //  build \ send update
    //

    status = Dns_UpdateLibEx(
                prr,
                flags,
                pszzone,
                pszserverName,
                aipservers,
                hCreds,
                &pmsgRecv
                );
    if ( pmsgRecv )
    {
        DnsPrint_Message(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            "Update response:\n",
            pmsgRecv );
    }

    FREE_HEAP( aipservers );
    Dns_RecordListFree( prr );
    FREE_HEAP( pmsg );
    FREE_HEAP( pmsgRecv );

    if( status != ERROR_SUCCESS )
    {
        printf(
            "Dns_UpdateLibEx failed, %x %s.\n",
            status,
            DnsStatusString(status) );
    }
    else
    {
        printf( "Update successfully completed.\n" );
    }
    return( status );

Usage:

    FREE_HEAP( aipservers );
    Dns_RecordListFree( prr );
    FREE_HEAP( pmsg );
    FREE_HEAP( pmsgRecv );

    printf(
        "usage:\n"
        "  DnsUp [-n<DNS IP>|...] -um [-f<Flags>] [-s<ServerName>] <ZoneName>\n"
        "        <HostName> <Starting IP> <IP Count>\n"
        "   <DNS IP> optional IP address of server to send update to.\n"
        "   <ServerName> name of DNS server we are sending update to;\n"
        "       presence of server name automatically turns on update security\n"
        "   <ZoneName> name of zone to update\n"
        "   <HostName> name of host to update\n"
        "   <Starting IP> first IP (in dotted decimal) in range to update\n"
        "   <IP Count> count of IPs to send in update;  IP address in update will\n"
        "       be the next <IP count> after <Starting IP>\n"
        );
    return( ERROR_INVALID_PARAMETER );
}
#endif



DNS_STATUS
ProcessIQuery(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    DWORD           flags = 0;
    PCHAR           arg;
    PDNS_RECORD     prr = NULL;
    PDNS_MSG_BUF    pmsg = NULL;
    PDNS_MSG_BUF    pmsgRecv = NULL;
    IP_ADDRESS      ipserver;
    PIP_ARRAY       aipservers = NULL;
    DNS_HEADER      header;

    //
    //  setup header
    //      - zero flags

    *(PDWORD) &header = 0;
    header.Xid = (WORD) GetCurrentTimeInSeconds();
    header.Opcode = DNS_OPCODE_IQUERY;

    //
    //  optional name server to query?
    //

    aipservers = pDnsServerArray;
    if ( !aipservers )
    {
        aipservers = Dns_GetDnsServerList( FALSE );
    }
    if ( !aipservers )
    {
        printf( "Update failed:  no DNS server list available.\n" );
        return( GetLastError() );
    }

    //
    //  flags?
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    arg = Argv[0];
    if ( strncmp( arg, "-f", 2 ) == 0 )
    {
        flags = strtoul( arg+2, NULL, 16 );
        Argc--;
        Argv++;
    }

    //
    //  build update packet RRs
    //

    prr = buildRecordList(
                Argc,
                Argv );
    if ( !prr )
    {
        status = GetLastError();
        if ( status != ERROR_SUCCESS )
        {
            printf( "ERROR:  building records from arguments\n" );
            goto Usage;
        }
    }

    //
    //  build \ send update
    //

    status = QueryDirectEx(
                & pmsgRecv,
                NULL,           // no response records
                & header,       // header with IQUERY set
                TRUE,           // no copy header count fields
                NULL,           // no question
                0,              // no question type
                prr,            // record list built
                0,              // flags
                aipservers,     // server IP list
                NULL            // no adapter list
                );
    if ( pmsgRecv )
    {
        DnsPrint_Message(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            "IQUERY response:\n",
            pmsgRecv );
    }

    FREE_HEAP( aipservers );
    Dns_RecordListFree( prr );
    FREE_HEAP( pmsg );
    FREE_HEAP( pmsgRecv );

    if( status != ERROR_SUCCESS )
    {
        printf(
            "QueryDirectExEx failed, %x %s.\n",
            status,
            DnsStatusString(status) );
    }
    else
    {
        printf( "IQUERY successfully completed.\n" );
    }
    return( status );

Usage:

    FREE_HEAP( aipservers );
    Dns_RecordListFree( prr );
    FREE_HEAP( pmsg );
    FREE_HEAP( pmsgRecv );

    printf(
        "usage:\n"
        "  DnsUp [-n<DNS IP>|...] -iq [-f<Flags>] [<Record> | ...]\n"
        "   <DNS IP> optional IP address of server to send update to.\n"
        "   <ServerName> name of DNS server we are sending update to;\n"
        "       presence of server name automatically turns on update security\n"
        "   <ZoneName> name of zone to update\n"
        "   <Record> record for update packet\n"
        "   <Record> == (-,+)(p,u,a) <Name> <Type> [Data | ...]\n"
        "       (-,+) - add or delete, exist or no-exist flag\n"
        "       (p,u,a) - prereq, update or additional section\n"
        "       <Name> - RR owner name\n"
        "       <Type> - record type\n"
        "       <Data> - data strings (type specific), if any\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessValidateName(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    PCHAR           pszname;
    DWORD           format;

    //
    //  name to validate
    //

    if ( Argc != 2 )
    {
        goto Usage;
    }
    pszname = Argv[0];
    Argc--;
    Argv++;

    //
    //  name format
    //

    if ( Argc )
    {
        format = strtoul( Argv[0], NULL, 10 );
    }

    //
    //  validate
    //

    status = DnsValidateName_A(
                pszname,
                format );

    printf(
        "DnsValidateName( %s, %d ) status = %d %s.\n",
        pszname,
        format,
        status,
        DnsStatusString(status) );

    return( status );

Usage:

    printf(
        "DnsValidateName\n"
        "usage:\n"
        "  DnsUp -vn <Name> <Format>\n"
        "   <Name> DNS name to validate\n"
        "   <Format> format of name\n"
        "\tDomainName       -- %d\n"
        "\tDomainLabel      -- %d\n"
        "\tHostnameFull     -- %d\n"
        "\tHostnameLabel    -- %d\n"
        "\tWildcard         -- %d\n"
        "\tSrvRecord        -- %d\n",
        DnsNameDomain,
        DnsNameDomainLabel,
        DnsNameHostnameFull,
        DnsNameHostnameLabel,
        DnsNameWildcard,
        DnsNameSrvRecord
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessNameCompare(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    BOOL    result;
    PCHAR   pszname1;
    PCHAR   pszname2;

    //
    //  names to compare
    //

    if ( Argc != 2 )
    {
        goto Usage;
    }
    pszname1 = Argv[0];
    pszname2 = Argv[1];

    //
    //  compare
    //

    result = DnsNameCompare_A(
                pszname1,
                pszname2 );

    printf(
        "DnsNameCompare( %s, %s ) result = %s.\n",
        pszname1,
        pszname2,
        result ? "TRUE" : "FALSE"
        );

    return( ERROR_SUCCESS );

Usage:

    printf(
        "DnsNameCompare\n"
        "usage:\n"
        "  DnsUp -nc <Name1> <Name2>\n"
        "   <Name1> <Name2> DNS names to compare.\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessNameCompareEx(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    PCHAR           pszname1;
    PCHAR           pszname2;

    //
    //  names to compare
    //

    if ( Argc != 2 )
    {
        goto Usage;
    }
    pszname1 = Argv[0];
    pszname2 = Argv[1];

    //
    //  compare
    //

    status = DnsNameCompareEx_A(
                pszname1,
                pszname2,
                0 );

    printf(
        "DnsNameCompareEx( %s, %s ) result = %d.\n",
        pszname1,
        pszname2,
        status
        );

    return( ERROR_SUCCESS );

Usage:

    printf(
        "DnsNameCompareEx\n"
        "usage:\n"
        "  DnsUp -cnx <Name1> <Name2>\n"
        "   <Name1> <Name2> DNS names to compare.\n"
        "Compare Result:\n"
        "\tNot Equal            -- %d\n"
        "\tEqual                -- %d\n"
        "\tLeft is Ancestor     -- %d\n"
        "\tRight is Ancestor    -- %d\n"
        "\tInvalid Name         -- %d\n",
        DnsNameCompareNotEqual,
        DnsNameCompareEqual,
        DnsNameCompareLeftParent,
        DnsNameCompareRightParent,
        DnsNameCompareInvalid
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessStringTranslate(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    WCHAR           unicodeString[ DNS_MAX_NAME_LENGTH ];
    WCHAR           unicodeStandard[ DNS_MAX_NAME_LENGTH ];
    BYTE            utf8Standard[ DNS_MAX_NAME_LENGTH ];
    PWCHAR          punicode;
    PCHAR           putf8;
    DWORD           unicodeLength;
    DWORD           utf8Length;
    DWORD           unicodeLengthStandard;


    //
    //  string translate
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }

    //
    //  read in unicode characters
    //

    unicodeLength = 0;
    while ( Argc )
    {
        unicodeString[ unicodeLength++] = (WORD) strtoul( Argv[0], NULL, 16 );
        Argc--;
        Argv++;
    }
    unicodeString[ unicodeLength ] = 0;

    DnsPrint_UnicodeStringBytes(
        dnsup_PrintRoutine,
        dnsup_PrintContext,
        "DnsStringTranslate().\n"
        "Input string",
        unicodeString,
        unicodeLength );

    //
    //  convert to UTF8 -- my way and their way
    //

    putf8 = Dns_StringCopyAllocate(
                (PCHAR) unicodeString,
                0,
                DnsCharSetUnicode,
                DnsCharSetUtf8 );
    if ( !putf8 )
    {
        return( DNS_ERROR_NO_MEMORY );
    }

    utf8Length = WideCharToMultiByte(
                    CP_UTF8,
                    0,                  // no flags
                    (PWCHAR) unicodeString,
                    (-1),               // null terminated
                    utf8Standard,
                    MAXWORD,            // assuming adequate length
                    NULL,
                    NULL );

    DnsPrint_Utf8StringBytes(
        dnsup_PrintRoutine,
        dnsup_PrintContext,
        "My UTF8",
        putf8,
        strlen(putf8) );

    DnsPrint_Utf8StringBytes(
        dnsup_PrintRoutine,
        dnsup_PrintContext,
        "Standard UTF8",
        utf8Standard,
        strlen(utf8Standard) );

    //
    //  convert back to unicode
    //

    punicode = Dns_StringCopyAllocate(
                    (PCHAR) utf8Standard,
                    0,
                    DnsCharSetUtf8,
                    DnsCharSetUnicode );

    unicodeLengthStandard = MultiByteToWideChar(
                                CP_UTF8,
                                0,                  // no flags
                                (PCHAR) utf8Standard,
                                (-1),               // null terminated
                                (PWCHAR) unicodeStandard,
                                MAXWORD             // assuming adequate length
                                );

    DnsPrint_UnicodeStringBytes(
        dnsup_PrintRoutine,
        dnsup_PrintContext,
        "My unicode",
        punicode,
        wcslen(punicode) );

    DnsPrint_UnicodeStringBytes(
        dnsup_PrintRoutine,
        dnsup_PrintContext,
        "Standard unicode",
        unicodeStandard,
        wcslen(unicodeStandard) );

    status = ERROR_SUCCESS;
    return( status );

Usage:

    printf(
        "usage:\n"
        "  DnsUp -s [unicode chars in hex]\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessQueryConfig(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
#define CONFIG_BUF_SIZE  (100)

    DNS_STATUS      status;
    DNS_CONFIG_TYPE config;
    PCHAR           psznext;
    PCHAR           pendString;
    PWSTR           pwsadapter = NULL;
    DWORD           flag = 0;
    BOOL            ballocated = FALSE;
    BOOL            bsleep = FALSE;
    DWORD           bufLength = 0;
    DWORD           sentBufLength;
    PBYTE           pbuffer = NULL;
    PBYTE           pallocResult;
    BYTE            buffer[ CONFIG_BUF_SIZE ];


    //
    //  query config
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }

    //  config value

    config = strtoul( Argv[0], &pendString, 10 );
    Argc--;
    Argv++;

    //  flag?

    while ( Argc )
    {
        psznext = Argv[0];

        //  flag

        if ( !_stricmp( psznext, "-f" ) ||
             !_stricmp( psznext, "/f" ) )
        {
            Argc--;
            Argv++;
            flag = strtoul( Argv[0], &pendString, 16 );
            Argc--;
            Argv++;

            if ( flag & DNS_CONFIG_FLAG_ALLOC )
            {
                bufLength = sizeof(PVOID);
                pbuffer = buffer;
            }
            continue;
        }

        //  length input

        if ( !_stricmp( psznext, "-l" ) ||
             !_stricmp( psznext, "/l" ) )
        {
            Argc--;
            Argv++;
            bufLength = strtoul( Argv[0], &pendString, 16 );
            Argc--;
            Argv++;
            continue;
        }

        //  sleep?

        if ( !_stricmp( psznext, "-s" ) ||
             !_stricmp( psznext, "/s" ) )
        {
            Argc--;
            Argv++;
            bsleep = TRUE;
            continue;
        }

        //  buffer

        if ( !_stricmp( psznext, "-b" ) ||
             !_stricmp( psznext, "/b" ) )
        {
            Argc--;
            Argv++;
            pbuffer = buffer;
            bufLength = CONFIG_BUF_SIZE;
            continue;
        }

        //  adapter name

        else
        {
            pwsadapter = DnsStringCopyAllocateEx(
                            Argv[0],
                            0,
                            DnsCharSetAnsi,         // ANSI in
                            DnsCharSetUnicode       // unicode out
                            );
            continue;
        }
    }

    //
    //  query DNS config
    //

    sentBufLength = bufLength;

    status = DnsQueryConfig(
                config,
                flag,
                pwsadapter,
                NULL,
                pbuffer,
                & bufLength );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DnsQueryConfig() successful.\n"
            "\tflag             = 0x%.8X\n"
            "\tadapter          = %s\n"
            "\tsent length      = %d\n"
            "\tlength required  = %d\n",
            flag,
            pwsadapter,
            sentBufLength,
            bufLength );

        if ( !pbuffer )
        {
            return( status );
        }

        printf(
            "\tbuffer = %02x %02x %02x %02x ...\n",
            pbuffer[0],
            pbuffer[1],
            pbuffer[2],
            pbuffer[3] );

        if ( flag & DNS_CONFIG_FLAG_ALLOC )
        {
            pbuffer = * (PVOID *) pbuffer;
        }

        switch( config )
        {

        case DnsConfigPrimaryDomainName_W:

            printf(
                "Primary domain name = %S\n",
                pbuffer );
            break;

        case DnsConfigPrimaryDomainName_A:
        case DnsConfigPrimaryDomainName_UTF8:

            printf(
                "Primary domain name = %s\n",
                pbuffer );
            break;

        case DnsConfigDnsServerList:

            DnsPrint_IpArray(
                dnsup_PrintRoutine,
                dnsup_PrintContext,
                "DNS server list",
                NULL,
                (PIP_ARRAY) pbuffer );
            break;

        case DnsConfigPrimaryHostNameRegistrationEnabled:

            printf(
                "Is Primary registration enabled = %d\n",
                *(PBOOL)pbuffer );
            break;

        case DnsConfigAdapterHostNameRegistrationEnabled:

            printf(
                "Is Adapter registration enabled = %d\n",
                *(PBOOL)pbuffer );
            break;

        case DnsConfigAddressRegistrationMaxCount:

            printf(
                "Max IP registration count = %d\n",
                *(PDWORD)pbuffer );
            break;

        default:

            printf( "Unknown config %d", config );
        }
    }

    else if ( status == ERROR_MORE_DATA )
    {
        printf(
            "DnsQueryConfig() ERROR_MORE_DATA.\n"
            "\tsent length     = %d\n"
            "\tlength required = %d\n",
            sentBufLength,
            bufLength );
    }
    else
    {
        printf(
            "DnsQueryConfig() failed status = %d (0x%.8X).\n",
            status, status );
    }

    if ( bsleep )
    {
        printf( "Sleeping" );
        Sleep( MAXDWORD );
    }
    return( status );

Usage:

    printf(
        "usage:\n"
        "  DnsUp -config <Config> [-f <flag>] [-b] [-l <length>] [<adapter name>]\n"
        );

    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessReplaceRecordSet(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    DWORD           flags = 0;
    PCHAR           arg;
    PDNS_RECORD     prr = NULL;
    HANDLE          hCreds=NULL;

    //
    //  flags?
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    arg = Argv[0];
    if ( strncmp( arg, "-f", 2 ) == 0 )
    {
        flags = strtoul( arg+2, NULL, 16 );
        Argc--;
        Argv++;
    }

    //
    //  build update packet RRs
    //

    prr = buildRecordList(
                Argc,
                Argv );
    if ( !prr )
    {
        status = GetLastError();
        if ( status != ERROR_SUCCESS )
        {
            printf( "ERROR:  building records from arguments\n" );
            goto Usage;
        }
    }

    //
    //  build \ send update
    //

    status = DnsReplaceRecordSetA(
                prr,
                flags,
                hCreds,
                NULL,       // no adapter list specified
                NULL        // reserved
                );

    Dns_RecordListFree( prr );

    if ( status != ERROR_SUCCESS )
    {
        printf(
            "DnsReplaceRecordSet failed, %x %s.\n",
            status,
            DnsStatusString(status) );
    }
    else
    {
        printf( "ReplaceRecordSet successfully completed.\n" );
    }
    return( status );

Usage:

    Dns_RecordListFree( prr );

    printf(
        "usage:\n"
        "  DnsUp -rs [-f<Flags>] [<Record> | ...]\n"
        "   <Record> record for update packet\n"
        "   <Record> == (+)(u) <Name> <Type> [Data | ...]\n"
        "       <Name>  - RR owner name\n"
        "       <Type>  - record type (ex A, SRV, PTR, TXT, CNAME, etc.)\n"
        "       <Data>  - data strings (type specific), if any\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessModifyRecordsInSet(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    DWORD           flags = 0;
    PCHAR           arg;
    PDNS_RECORD     prr;
    PDNS_RECORD     prrAdd = NULL;
    PDNS_RECORD     prrDelete = NULL;
    HANDLE          hCreds=NULL;
    INT             addCount;
    DNS_RRSET       rrsetDelete;
    DNS_RRSET       rrsetAdd;

    DNS_RRSET_INIT( rrsetAdd );
    DNS_RRSET_INIT( rrsetDelete );

    //
    //  flags?
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }

    //  flag?

    arg = Argv[0];
    if ( strncmp( arg, "-f", 2 ) == 0 )
    {
        flags = strtoul( arg+2, NULL, 16 );
        Argc--;
        Argv++;
    }

    //
    //  build update add RRs
    //

    prr = buildRecordList(
                Argc,
                Argv );
    if ( !prr )
    {
        status = GetLastError();
        if ( status != ERROR_SUCCESS )
        {
            printf( "ERROR:  building records from arguments\n" );
            goto Usage;
        }
    }

    //
    //  build separate Add and Delete lists
    //

    while ( prr )
    {
        if ( prr->Flags.S.Delete )
        {
            DNS_RRSET_ADD( rrsetDelete, prr );
        }
        else
        {
            DNS_RRSET_ADD( rrsetAdd, prr );
        }
        prr = prr->pNext;
    }

    DNS_RRSET_TERMINATE( rrsetAdd );
    DNS_RRSET_TERMINATE( rrsetDelete );

    //
    //  build \ send update
    //

    status = DnsModifyRecordsInSet_A(
                rrsetAdd.pFirstRR,
                rrsetDelete.pFirstRR,
                flags,
                hCreds,
                NULL,       // no adapter list specified
                NULL        // reserved
                );

    Dns_RecordListFree( rrsetAdd.pFirstRR );
    Dns_RecordListFree( rrsetDelete.pFirstRR );

    if ( status != ERROR_SUCCESS )
    {
        printf(
            "DnsModifyRecordsInSet failed, %x %s.\n",
            status,
            DnsStatusString(status) );
    }
    else
    {
        printf( "ModifyRecordsInSet successfully completed.\n" );
    }
    return( status );

Usage:

    Dns_RecordListFree( rrsetAdd.pFirstRR );
    Dns_RecordListFree( rrsetDelete.pFirstRR );

    printf(
        "usage:\n"
        "  DnsUp -mr [-f<Flags>] [<Record> | ...]\n"
        "   <Record> == (-,+)(u) <Name> <Type> [Data | ...]\n"
        "       (-,+)   - add or delete, exist or no-exist flag\n"
        "       <Name>  - RR owner name\n"
        "       <Type>  - record type (ex A, SRV, PTR, TXT, CNAME, etc.)\n"
        "       <Data>  - data strings (type specific), if any\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



//
//  Winsock \ RnR
//

//
//  Protocol array for WSAQUERYSET
//
//  DCR:  may want to default to NULL instead?
//

AFPROTOCOLS g_ProtocolArray[2] =
{
    {   AF_INET,    IPPROTO_UDP },
    {   AF_INET,    IPPROTO_TCP }
};

//
//  Service GUIDs
//

GUID HostNameGuid       = SVCID_HOSTNAME;
GUID HostAddrByNameGuid = SVCID_INET_HOSTADDRBYNAME;
GUID AddressGuid        = SVCID_INET_HOSTADDRBYINETSTRING;
GUID IANAGuid           = SVCID_INET_SERVICEBYNAME;

typedef struct _GuidStringMap
{
    LPGUID      pGuid;
    LPSTR       pString;
};

struct _GuidStringMap GuidMapTable[] =
{
    & HostNameGuid          ,   "HostName"               ,
    & HostAddrByNameGuid    ,   "AddrByName"             ,
    & HostAddrByNameGuid    ,   "HostAddrByName"         ,
    & AddressGuid           ,   "HostAddrByInetString"   ,
    & IANAGuid              ,   "ServiceByName"          ,
    & IANAGuid              ,   "Iana"                   ,
    NULL                    ,   "NULL"                   ,
    NULL                    ,   NULL                     ,
};


PGUID
guidForString(
    IN      PSTR            pszGuidName
    )
/*++

Routine Description:

    Get GUID for string.

    This is to allow simple specification of command line for GUIDs.

Arguments:

    pszGuidName -- name of desired GUID
        (see table above for current names of common guids)

Return Value:

    Ptr to desired GUID if found.
    Errors default to hostname (host lookup) GUID.

--*/
{
    DWORD   i;
    PCHAR   pname;

    //
    //  if no guid name, use host name guid
    //

    if ( !pszGuidName )
    {
        return  &HostNameGuid;
    }

    //
    //  find guid matching name in table
    //

    i = 0;

    while ( pname = GuidMapTable[i].pString )
    {
        if ( _stricmp( pname, pszGuidName ) == 0 )
        {
            return  GuidMapTable[i].pGuid;
        }
        i++;
    }

    //  default to HostName guid

    return  &HostNameGuid;
}



//
//  Parsing utility
//

typedef struct _RnRParseBlob
{
    HANDLE          Handle;
    PCHAR           pBuffer;
    PWSAQUERYSET    pQuerySet;
    PGUID           pGuid;
    PSTR            pName;
    DWORD           Flags;
    DWORD           NameSpace;
    DWORD           BufferLength;
}
RNR_PARSE_BLOB, *PRNR_PARSE_BLOB;


VOID
printRnRArgHelp(
    VOID
    )
/*++

Routine Description:

    Print RnR argument usage.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    //  describe standard RnR lookup arguements
    //
    //  DCR:  add flag, ptr validity check
    //  DCR:  add "already set" check for names and guids
    //  DCR:  fix zero flag case below
    //

    printf(
        "\tRnR Arguments:\n"
        "\t\t-h<handle>     --  ptr in hex to lookup handle\n"
        "\t\t-b<buffer>     --  ptr in hex to result buffer to use\n"
        "\t\t-l<buf length> --  buffer length to use\n"
        "\t\t-f<flag>       --  RnR control flag in hex or LUP_X mneumonic\n"
        "\t\t                   may be multiple flags specified\n"
        "\t\t-q<query set>  --  ptr in hex to existing WSAQUERYSET struct\n"
        "\t\t-i<name space> --  name space id NS_X mneumonic\n"
        "\t\t-a<name>       --  ANSI lookup name\n"
        "\t\t-g<guid>       --  NS GUID mneumonic:\n"
        "\t\t                       HostName\n"           
        "\t\t                       HostAddrByName\n"
        "\t\t                       HostAddrByInetString\n"
        "\t\t                       ServiceByName\n"
        );
}



DNS_STATUS
parseForRnr(
    IN      DWORD           Argc,
    IN      PSTR  *         Argv,
    OUT     PRNR_PARSE_BLOB pBlob
    )
/*++

Routine Description:

    Parse RnR routine command line params.

    This is to simplify avoid duplicate parsing for various RnR
    functions.

Arguments:

    Argc -- argc

    Argv -- argument array

    pBlob -- ptr to RnR parsing blob to be filled by function

Return Value:

    ERROR_SUCCESS if successful parsing.
    ErrorCode on parsing error.
    (Note, currently errors are ignored and whatever parsing is possible
    is completed.)

--*/
{
    PCHAR   parg;

    //
    //  init parse blob
    //

    RtlZeroMemory(
        pBlob,
        sizeof(RNR_PARSE_BLOB) );

    //
    //  read arguments
    //
    //  DCR:  add flag, ptr validity check
    //  DCR:  add "already set" check for names and guids
    //  DCR:  fix zero flag case below
    //

    while ( Argc )
    {
        parg = Argv[0];

        if ( strncmp( parg, "-h", 2 ) == 0 )
        {
            pBlob->Handle = (PVOID) (ULONG_PTR) strtoul( parg+2, NULL, 16 );
        }
        else if ( strncmp( parg, "-f", 2 ) == 0 )
        {
            DWORD   thisFlag;

            thisFlag = strtoul( parg+2, NULL, 16 );
            if ( thisFlag == 0 )
            {
                thisFlag = Dns_RnrLupFlagForString( parg+2, 0 );
            }
            pBlob->Flags |= thisFlag;
        }
        else if ( strncmp( parg, "-b", 2 ) == 0 )
        {
            pBlob->pBuffer = (PBYTE) (ULONG_PTR) strtoul( parg+2, NULL, 16 );
        }
        else if ( strncmp( parg, "-l", 2 ) == 0 )
        {
            pBlob->BufferLength = strtoul( parg+2, NULL, 10 );
        }
        else if ( strncmp( parg, "-a", 2 ) == 0 )
        {
            pBlob->pName = parg+2;
        }
        else if ( strncmp( parg, "-g", 2 ) == 0 )
        {
            pBlob->pGuid = guidForString( parg+2 );
        }
        else if ( strncmp( parg, "-i", 2 ) == 0 )
        {
            pBlob->NameSpace = Dns_RnrNameSpaceIdForString(
                                    parg+2,
                                    0       // length unknown
                                    );
        }
        else if ( strncmp( parg, "-q", 2 ) == 0 )
        {
            pBlob->pQuerySet = (PWSAQUERYSET) (ULONG_PTR) strtoul( parg+2, NULL, 16 );
        }
        else if ( *parg=='?' || strncmp( parg, "-?", 2 ) == 0 )
        {
            goto Usage;
        }
        else
        {
            printf( "Unknown Arg = %s\n", parg );
            goto Usage;
        }
        Argc--;
        Argv++;
    }

    return( ERROR_SUCCESS );

Usage:

    printRnRArgHelp();

    return( ERROR_INVALID_PARAMETER );
}



PWSAQUERYSET
buildWsaQuerySet(
    IN      PRNR_PARSE_BLOB pBlob
    )
/*++

Routine Description:

    Create (allocate) a query set.

Arguments:

    pBlob -- ptr to blob of parsing info

Return Value:

    Ptr to new WSAQUERYSET struct.
    NULL on allocation failure.

--*/
{
    PWSAQUERYSET    pwsaq;

    //
    //  allocate
    //

    pwsaq = ALLOCATE_HEAP_ZERO( sizeof(WSAQUERYSET) );
    if ( !pwsaq )
    {
        return( NULL );
    }

    //
    //  basic
    //      - default GUID to hostname lookup
    //

    pwsaq->dwSize                   = sizeof(WSAQUERYSET);
    pwsaq->dwNumberOfProtocols      = 2;
    pwsaq->lpafpProtocols           = g_ProtocolArray;
    pwsaq->lpServiceClassId         = & HostNameGuid;

    //
    //  tack on info from blob
    //      - keep parsing generic by casting name to TSTR
    // 

    if ( pBlob )
    {
        pwsaq->dwNameSpace              = pBlob->NameSpace;
        pwsaq->lpszServiceInstanceName  = (LPTSTR) pBlob->pName;
        pwsaq->lpServiceClassId         = pBlob->pGuid;
    }

    return  (PWSAQUERYSET) pwsaq;
}



DNS_STATUS
ProcessLookupServiceBegin(
    IN      DWORD           Argc,
    IN      PSTR  *         Argv
    )
{
    DNS_STATUS      status;
    HANDLE          handle = NULL;
    PWSAQUERYSET    pquerySet = NULL;
    PWSAQUERYSET    pquerySetLocal = NULL;
    RNR_PARSE_BLOB  blob;

    //
    //  WSALookupServiceBegin 
    //

    //
    //  parse args
    //

    status = parseForRnr( Argc, Argv, &blob );

    if ( status != ERROR_SUCCESS )
    {
        goto Usage;
    }

    //
    //  setup query set
    //

    pquerySet = blob.pQuerySet;

    if ( !pquerySet )
    {
        pquerySet = buildWsaQuerySet( &blob );
        pquerySetLocal = pquerySet;
    }

    IF_DNSDBG( INIT )
    {
        DnsDbg_WsaQuerySet(
            "Query set to WLSBegin",
            pquerySet,
            FALSE           // currently ANSI
            );
    }

    DnsPrint_WsaQuerySet(
        dnsup_PrintRoutine,
        dnsup_PrintContext,
        "QuerySet to LookupServiceBegin",
        (PWSAQUERYSET) pquerySet,
        FALSE           // ANSI call
        );

    //
    //  force winsock start
    //

    Dns_InitializeWinsock();

    //
    //  call 
    //

    status = WSALookupServiceBeginA(
                pquerySet,
                blob.Flags,
                & handle );

    if ( status != ERROR_SUCCESS )
    {
        status = GetLastError();

        printf(
            "WSALookupServiceBegin( %p, %08x, %p ) failed, %d %s.\n",
            pquerySet,
            blob.Flags,
            & handle,
            status,
            DnsStatusString(status) );

        if ( pquerySetLocal )
        {
            FREE_HEAP( pquerySetLocal );
        }
    }
    else
    {
        printf(
            "WSALookupServiceBegin() succeeded.\n"
            "\thandle   = %p\n"
            "\tqueryset = %p\n",
            handle,
            pquerySet );
    }
    return( status );

Usage:

    printf(
        "WSALookupServiceBegin\n"
        "usage:\n"
        "  DnsUp -lsb [RnR args]\n"
        "       note handle arg does not apply\n"
        );

    printRnRArgHelp();

    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessLookupServiceNext(
    IN      DWORD           Argc,
    IN      PSTR  *         Argv
    )
{
    DNS_STATUS      status;
    HANDLE          handle = NULL;
    PCHAR           pbuf = NULL;
    PCHAR           pbufLocal = NULL;
    DWORD           bufLength;
    RNR_PARSE_BLOB  blob;

    //
    //  WSALookupServiceNext 
    //

    //
    //  parse args
    //

    status = parseForRnr( Argc, Argv, &blob );
    if ( status != ERROR_SUCCESS )
    {
        goto Usage;
    }

    //
    //  if no handle need to do WLSBegin
    //

    handle = blob.Handle;
    if ( !handle )
    {
        goto Usage;
    }

    //
    //  setup buffer
    //

    bufLength = blob.BufferLength;
    pbuf = blob.pBuffer;

    if ( !pbuf && bufLength )
    {
        pbuf = ALLOCATE_HEAP( blob.BufferLength );
        if ( !pbuf )
        {
            status = DNS_ERROR_NO_MEMORY;
        }
        pbufLocal = pbuf;
    }

    //
    //  call 
    //

    printf(
        "Enter WSALookupServiceNext()\n"
        "\thandle   = %p\n"
        "\tflag     = %08x\n"
        "\tlength   = %p (%d)\n"
        "\tbuffer   = %p\n",
        handle,
        blob.Flags,
        &bufLength, bufLength,
        pbuf );

    status = WSALookupServiceNextA(
                handle,
                blob.Flags,
                & bufLength,
                (PWSAQUERYSETA) pbuf );

    if ( status != ERROR_SUCCESS )
    {
        status = GetLastError();

        printf(
            "WSALookupServiceNext( h=%p, f=%08x, len=%d, buf=%p ) failed, %d %s.\n",
            handle,
            blob.Flags,
            bufLength,
            pbuf,
            status,
            DnsStatusString(status) );

        if ( pbufLocal )
        {
            FREE_HEAP( pbufLocal );
        }
    }
    else
    {
        printf(
            "WSALookupServiceNext() succeeded.\n"
            "\thandle       = %p\n"
            "\tbuf length   = %d\n"
            "\tpbuffer      = %p\n",
            handle,
            bufLength,
            pbuf );

        if ( pbuf )
        {
            DnsPrint_WsaQuerySet(
                dnsup_PrintRoutine,
                dnsup_PrintContext,
                "Result from LookupServiceNext",
                (PWSAQUERYSET) pbuf,
                FALSE           // ANSI call
                );
        }
    }
    return( status );

Usage:

    printf(
        "WSALookupServiceNext\n"
        "usage:\n"
        "  DnsUp -lsn [RnR args]\n"
        "       valid WSALookupServiceNext args:\n"
        "           <handle> <flags> <buffer> <buf length>\n"
        "       <handle> is required, call WSALookupServiceBegin\n"
        "           to get handle to use with this function\n"
        );

    printRnRArgHelp();

    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessLookupServiceEnd(
    IN      DWORD           Argc,
    IN      PSTR  *         Argv
    )
{
    DNS_STATUS      status;
    HANDLE          handle;

    //
    //  WSALookupServiceEnd <handle>
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }

    //  read handle
    //
    //  DCR:  need QWORD read to handle win64 case

    handle = (HANDLE) (UINT_PTR) strtoul( Argv[0], NULL, 16 );

    //
    //  call 
    //

    status = WSALookupServiceEnd( handle );
    if ( status != ERROR_SUCCESS )
    {
        printf(
            "WSALookupServiceEnd( %p ) failed, %d %s.\n",
            handle,
            status,
            DnsStatusString(status) );
    }
    else
    {
        printf(
            "WSALookupServiceEnd( %p ) succeeded.\n",
            handle );
    }

    Dns_CleanupWinsock();

    return( status );

Usage:

    printf(
        "WSALookupServiceEnd\n"
        "usage:\n"
        "  DnsUp -lse -h<handle>\n"
        "       <handle>  - lookup handle to close in hex.\n"
        "           handle is from prior WSALookupServiceBegin call.\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessGetHostName(
    IN      DWORD           Argc,
    IN      PSTR  *         Argv
    )
{
    DNS_STATUS      status;
    CHAR            nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    DWORD           length = DNS_MAX_NAME_BUFFER_LENGTH;
    PCHAR           pname = nameBuffer;
    INT             result;

    //
    //  gethostname [-n<name>] [-l<length>]
    //

    if ( Argc > 2 )
    {
        goto Usage;
    }

    //
    //  get optional name or length
    //      - defaults to full size buffer above
    //

    while ( Argc )
    {
        PCHAR   arg = Argv[0];

        if ( strncmp( arg, "-n", 2 ) == 0 )
        {
            pname = getNamePointer( arg+2 );
            Argc--;
            Argv++;
        }
        else if ( strncmp( arg, "-l", 2 ) == 0 )
        {
            length = strtoul( arg+2, NULL, 10 );
            Argc--;
            Argv++;
        }
        else
        {
            goto Usage;
        }
    }

    //
    //  force winsock start
    //

    Dns_InitializeWinsock();

    //
    //  call 
    //

    result = gethostname( (PSTR)pname, length );

    if ( result != 0 )
    {
        status = GetLastError();

        printf(
            "gethostname(), %d (%x) %s.\n",
            status, status,
            DnsStatusString(status) );
    }
    else
    {
        printf(
            "gethostname() successfully completed.\n"
            "\tname = %s\n",
            pname );
    }
    return( status );

Usage:

    printf(
        "gethostname\n"
        "usage:\n"
        "  DnsUp -ghn [-n<Name>] [-l<length>]\n"
        "       <Name>   - one of special names.\n"
        "       <Length> - buffer length to pass in\n"
        "       Defaults to valid name buffer of full DNS name length\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessGetHostByName(
    IN      DWORD           Argc,
    IN      PSTR  *         Argv
    )
{
    DNS_STATUS      status;
    PCHAR           pname;
    PHOSTENT        phost;

    //
    //  gethostbyname <name>
    //

    if ( Argc != 1 )
    {
        goto Usage;
    }

    //  name

    pname = getNamePointer( Argv[0] );

    //
    //  force winsock start
    //

    Dns_InitializeWinsock();

    //
    //  call 
    //

    phost = gethostbyname( (PCSTR)pname );

    status = GetLastError();

    if ( !phost )
    {
        printf(
            "gethostbyname(), %x %s.\n",
            status,
            DnsStatusString(status) );
    }
    else
    {
        printf( "gethostbyname successfully completed.\n" );

        DnsPrint_Hostent(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            NULL,       // default header
            phost,
            FALSE       // ANSI
            );
    }
    return( status );

Usage:

    printf(
        "gethostbyname\n"
        "usage:\n"
        "  DnsUp -ghbn <Name>\n"
        "       <Name>  - DNS name to query.\n"
        "           \"NULL\" for null input.\n"
        "           \"blank\" for blank (empty string)\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessGetHostByAddr(
    IN      DWORD           Argc,
    IN      PSTR  *         Argv
    )
{
    DNS_STATUS      status;
    PCHAR           pname;
    PCHAR           paddr;
    PHOSTENT        phost;
    IP6_ADDRESS     ip6;
    INT             length;
    INT             family;

    //
    //  gethostbyaddr <ip> [len] [family]
    //

    if ( Argc < 1 || Argc > 3 )
    {
        goto Usage;
    }

    //
    //  address
    //

    pname = getNamePointer( Argv[0] );
    Argc--;
    Argv++;

    length = sizeof(IP6_ADDRESS);
    family = 0;

    if ( pname
            &&
         Dns_StringToAddress_A(
                (PCHAR) & ip6,
                & length,
                pname,
                & family ) )
    {
        paddr = (PCHAR) &ip6;
    }
    else
    {
        paddr = pname;
        length = sizeof(IP4_ADDRESS);
        family = AF_INET;
    }

    //  length -- optional

    if ( Argc )
    {
        length = strtoul( Argv[0], NULL, 10 );
        Argc--;
        Argv++;
    }

    //  family -- optional

    if ( Argc )
    {
        family = strtoul( Argv[0], NULL, 10 );
        Argc--;
        Argv++;
    }

    //
    //  force winsock start
    //

    Dns_InitializeWinsock();

    //
    //  call 
    //

    printf(
        "calling gethostbyaddr( %p, %d, %d )\n",
        paddr,
        length,
        family );

    phost = gethostbyaddr(
                (PSTR)paddr,
                length,
                family );

    status = GetLastError();

    if ( !phost )
    {
        printf(
            "gethostbyaddr(), %d %s.\n",
            status,
            DnsStatusString(status) );
    }
    else
    {
        printf( "gethostbyaddr successfully completed.\n" );

        DnsPrint_Hostent(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            NULL,       // default header
            phost,
            FALSE       // ANSI
            );
    }
    return( status );

Usage:

    printf(
        "gethostbyaddr\n"
        "usage:\n"
        "  DnsUp -ghba <Address> [<length>] [<family>]\n"
        "       <Name>  - DNS name to query.\n"
        "           \"null\" for null input.\n"
        "           \"blank\" for blank (empty string)\n"
        "       [length] - length of address\n"
        "           defaults to sizeof(IP_ADDRESS)\n"
        "       [family] - address family\n"
        "           AF_INET     = %d\n"
        "           AF_INET6    = %d\n"
        "           AF_ATM      = %d\n"
        "           defaults to AF_INET\n",
        AF_INET,
        AF_INET6,
        AF_ATM );

    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessGetAddrInfo(
    IN      DWORD           Argc,
    IN      PSTR  *         Argv
    )
{
    DNS_STATUS      status;
    PCHAR           pname;
    PSTR            pservice = NULL;
    PADDRINFO       phint = NULL;
    PADDRINFO       paddrInfo = NULL;
    ADDRINFO        hintAddrInfo;
    BOOL            fhint = FALSE;
    INT             result;

    //
    //  getaddrinfo <name> [service] [hints]
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }

    //
    //  name
    //

    pname = getNamePointer( Argv[0] );
    Argc--;
    Argv++;

    //
    //  setup hints
    //      - default flags to include canonnical name
    //

    RtlZeroMemory(
        & hintAddrInfo,
        sizeof(hintAddrInfo) );

    hintAddrInfo.ai_flags = AI_CANONNAME;


    //
    //  get optional service name or hints
    //

    while ( Argc )
    {
        PCHAR   arg = Argv[0];

        if ( strncmp( arg, "-s", 2 ) == 0 )
        {
            pservice = getNamePointer( arg+2 );
            Argc--;
            Argv++;
        }
        if ( strncmp( arg, "-h", 2 ) == 0 )
        {
            fhint = TRUE;
            Argc--;
            Argv++;
        }
        else if ( strncmp( arg, "-f", 2 ) == 0 )
        {
            hintAddrInfo.ai_flags = strtoul( arg+2, NULL, 16 );
            fhint = TRUE;
            Argc--;
            Argv++;
        }
        else if ( strncmp( arg, "-m", 2 ) == 0 )
        {
            hintAddrInfo.ai_family = strtoul( arg+2, NULL, 10 );
            fhint = TRUE;
            Argc--;
            Argv++;
        }
        else if ( strncmp( arg, "-t", 2 ) == 0 )
        {
            hintAddrInfo.ai_socktype = strtoul( arg+2, NULL, 10 );
            fhint = TRUE;
            Argc--;
            Argv++;
        }
        else if ( strncmp( arg, "-p", 2 ) == 0 )
        {
            hintAddrInfo.ai_protocol = strtoul( arg+2, NULL, 10 );
            fhint = TRUE;
            Argc--;
            Argv++;
        }
        else if ( strncmp( arg, "-l", 2 ) == 0 )
        {
            hintAddrInfo.ai_addrlen = strtoul( arg+2, NULL, 10 );
            fhint = TRUE;
            Argc--;
            Argv++;
        }
        else
        {
            goto Usage;
        }
    }

    //
    //  setup hints
    //

    if ( fhint )
    {
        phint = &hintAddrInfo;
    }

    //
    //  force winsock start
    //

    Dns_InitializeWinsock();

    //
    //  call 
    //

    printf(
        "calling getaddrinfo()\n"
        "\tpname            = %s\n"
        "\tpservice         = %s\n"
        "\tphint            = %p\n"
        "\tpaddrinfo buf    = %p\n",
        pname,
        pservice,
        phint,
        paddrInfo );

    if ( phint )
    {
        DnsPrint_AddrInfo(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            "hint addrinfo",
            1,          // indent
            phint
            );
    }

    result = getaddrinfo(
                pname,
                pservice,
                phint,
                & paddrInfo );

    status = GetLastError();

    if ( result != NO_ERROR )
    {
        printf(
            "getaddrinfo(), %x %s.\n",
            status,
            DnsStatusString(status) );
    }
    else
    {
        printf( "getaddrinfo successfully completed.\n" );

        DnsPrint_AddrInfo(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            NULL,       // default header
            0,          // no indent
            paddrInfo
            );

        freeaddrinfo( paddrInfo );
    }
    return( status );

Usage:

    printf(
        "getaddrinfo\n"
        "usage:\n"
        "  DnsUp -gai <Name> [-s<Service>] [-h] [-f<flags>] [-m<family>]\n"
        "                    [-p<Protocol>] [-t<SockType>] [-l<length>]\n"
        "       <Name>  - DNS name to query.\n"
        "           \"null\" for null input.\n"
        "           \"blank\" for blank (empty string)\n"
        "       <Service>  - service name to query for.\n"
        "       [-h] - use hints (this allows empty hint buffer\n"
        "       <flags> - hint flags\n"
        "           AI_PASSIVE      = %0x\n"
        "           AI_CANONNAME    = %0x\n"
        "           AI_NUMERICHOST  = %0x\n"
        "       <family> - hint family\n"
        "           AF_INET         = %d\n"
        "           AF_INET6        = %d\n"
        "           AF_ATM          = %d\n"
        "       <socktype>  - hint socket type\n"
        "       <protocol>  - hint protocol\n"
        "       <length>    - hint address length\n",

        AI_PASSIVE,
        AI_CANONNAME,
        AI_NUMERICHOST,

        AF_INET,
        AF_INET6,
        AF_ATM );

    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessGetNameInfo(
    IN      DWORD           Argc,
    IN      PSTR  *         Argv
    )
{
    DNS_STATUS      status;
    BOOL            result;
    PCHAR           paddr = NULL;
    DWORD           addrLength;
    DWORD           family;
    DWORD           flags = 0;

    SOCKADDR_IN6    sockaddr;
    CHAR            hostBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    CHAR            serviceBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];

    PSOCKADDR_IN6   psockaddr = &sockaddr;
    PCHAR           pservice = serviceBuffer;
    PCHAR           phost = hostBuffer;
    DWORD           sockaddrLength = sizeof(sockaddr);
    DWORD           serviceLength = sizeof(hostBuffer);
    DWORD           hostLength = DNS_MAX_NAME_BUFFER_LENGTH;


    //
    //  getnameinfo <address> [sockaddr fields | args]
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }

    //
    //  address
    //

    RtlZeroMemory(
        psockaddr,
        sizeof(*psockaddr) );

#if 0
    if ( getAddressPointer(
                Argv[0],
                & paddr,
                & addrLength,
                & family ) )
    {
        sockaddr.sin6_family = (SHORT) family;

        if ( family == AF_INET )
        {
            RtlCopyMemory(
                & ((PSOCKADDR_IN)psockaddr)->sin_addr,
                paddr,
                addrLength );

            sockaddrLength = sizeof(SOCKADDR_IN);
        }
        else    // IP6
        {
            RtlCopyMemory(
                & psockaddr->sin6_addr,
                paddr,
                addrLength );

            sockaddrLength = sizeof(SOCKADDR_IN6);
        }
    }
    else    // special bogus address, use it directly
    {
        psockaddr = (PSOCKADDR_IN6) paddr;
    }
#endif
    if ( getAddressPointer(
                Argv[0],
                & paddr,
                & addrLength,
                & family ) )
    {
        status = Dns_AddressToSockaddr(
                        (PSOCKADDR) &sockaddr,
                        & sockaddrLength,
                        TRUE,       // clear
                        paddr,
                        addrLength,
                        family );

        if ( status != NO_ERROR )
        {
            goto Usage;
        }
    }
    else    // special bogus address, use it directly
    {
        psockaddr = (PSOCKADDR_IN6) paddr;
    }

    Argc--;
    Argv++;

    //
    //  get sockaddr fields or optional arguments
    //      - note, if using bogus sockaddr, the sockaddr tweaks are lost
    //

    while ( Argc )
    {
        PCHAR   arg = Argv[0];

        //  flags

        if ( strncmp( arg, "-f", 2 ) == 0 )
        {
            flags = strtoul( arg+2, NULL, 16 );
            Argc--;
            Argv++;
        }

        //  sockaddr subfields

        else if ( strncmp( arg, "-m", 2 ) == 0 )
        {
            sockaddr.sin6_family = (SHORT) strtoul( arg+2, NULL, 10 );
            Argc--;
            Argv++;
        }
        else if ( strncmp( arg, "-p", 2 ) == 0 )
        {
            sockaddr.sin6_port = (SHORT) strtoul( arg+2, NULL, 10 );
            Argc--;
            Argv++;
        }

        //  tweak out params

        else if ( strncmp( arg, "-sl", 3 ) == 0 )
        {
            serviceLength = strtoul( arg+3, NULL, 10 );
            Argc--;
            Argv++;
        }
        else if ( _strnicmp( arg, "-snull", 5 ) == 0 )
        {
            pservice = NULL;
            Argc--;
            Argv++;
        }
        else if ( strncmp( arg, "-hl", 3 ) == 0 )
        {
            hostLength = strtoul( arg+3, NULL, 10 );
            Argc--;
            Argv++;
        }
        else if ( _strnicmp( arg, "-hnull", 5 ) == 0 )
        {
            phost = NULL;
            Argc--;
            Argv++;
        }
        else
        {
            goto Usage;
        }
    }

    //
    //  force winsock start
    //

    Dns_InitializeWinsock();

    //
    //  call 
    //

    printf(
        "Calling getnameinfo()\n"
        "\tsockaddr         %p\n"
        "\tsockaddr len     %d\n"
        "\thost buffer      %p\n"
        "\thost buflen      %d\n"
        "\tservice buffer   %p\n"
        "\tservice buflen   %d\n"
        "\tflags            %08x\n",
        psockaddr,
        sockaddrLength,
        phost,
        hostLength,
        pservice,
        serviceLength,
        flags );

    DnsPrint_Sockaddr(
        dnsup_PrintRoutine,
        dnsup_PrintContext,
        "\n\tsockaddr",
        1,      // indent
        (PSOCKADDR) psockaddr,
        sockaddrLength );

    result = getnameinfo(
                (PSOCKADDR) psockaddr,
                sockaddrLength,
                phost,
                hostLength,
                pservice,
                serviceLength,
                flags );

    status = GetLastError();

    if ( result != NO_ERROR )
    {
        printf(
            "getnameinfo(), %x %s.\n",
            status,
            DnsStatusString(status) );
    }
    else
    {
        printf(
            "getnameinfo successfully completed.\n"
            "\thost     = %s\n"
            "\tservice  = %s\n",
            phost,
            pservice );
    }
    return( status );

Usage:

    printf(
        "getnameinfo\n"
        "usage:\n"
        "  DnsUp -gni <Address> [-s<Service>] [-f<flags>] [-m<family>]\n"
        "               [-p<port>] [-sl<length>] [-snull] [-hl<length>] [-hnull]\n"
        "       <Address>  - Address string to query name for.\n"
        "           \"null\" for null input.\n"
        "           \"blank\" for blank (empty string)\n"
        "       <flags> - hint flags\n"
        "           AI_PASSIVE      = %0x\n"
        "           AI_CANONNAME    = %0x\n"
        "           AI_NUMERICHOST  = %0x\n"
        "       <family> - sockaddr family, overrides default for address;\n"
        "           AF_INET         = %d\n"
        "           AF_INET6        = %d\n"
        "           AF_ATM          = %d\n"
        "       <port> - port to set in sockaddr;  defaults to zero\n"
        "       <length> - length of out buffer\n"
        "           -sl<length> - length of service name buffer\n"
        "           -hl<length> - length of host name buffer\n"
        "       [-snull] - server buffer ptr NULL\n"
        "       [-hnull] - host buffer ptr NULL\n",

        AI_PASSIVE,
        AI_CANONNAME,
        AI_NUMERICHOST,

        AF_INET,
        AF_INET6,
        AF_ATM );

    return( ERROR_INVALID_PARAMETER );
}




DNS_STATUS
ProcessClusterIp(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    SOCKADDR_IN6    sockaddr;
    PSOCKADDR       psockaddr = (PSOCKADDR) &sockaddr;
    DWORD           sockaddrLength = sizeof(sockaddr);
    IP_ADDRESS      ip;
    BOOL            fadd = TRUE;
    PWSTR           pname = NULL;
    DNS_STATUS      status;

    //
    //  -ci <Name> <IP> [-d]
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }

    //
    //  name
    //

    pname = (PWSTR) Dns_StringCopyAllocate(
                        Argv[0],
                        0,              // unknown length
                        DnsCharSetAnsi,
                        DnsCharSetUnicode );
    Argc--;
    Argv++;

    //
    //  cluster IP
    //

#if 0
    ip = inet_addr( Argv[0] );
    if ( ip == (-1) )
    {
        goto Usage;
    }
    Argc--;
    Argv++;
#endif

    if ( !getSockaddrFromString(
                & psockaddr,
                & sockaddrLength,
                Argv[0] ) )
    {
        goto Usage;  
    }
    Argc--;
    Argv++;

    //
    //  optional delete flag
    //

    if ( Argc > 0 )
    {
        if ( strncmp( Argv[0], "-d", 2 ) == 0 )
        {
            fadd = FALSE;
            Argc--;
            Argv++;
        }
        if ( Argc != 0 )
        {
            goto Usage;
        }
    }

    //
    //  notify resolver
    //

    status = DnsRegisterClusterAddress(
                0xd734453d,
                pname,
                psockaddr,
                fadd );

    FREE_HEAP( pname );
    return( status );

Usage:

    printf(
        "Set Cluster IP\n"
        "usage:\n"
        "  DnsUp [-ci] <Name> <IP> [-d]\n"
        "   <Name> is cluster name\n"
        "   <IP> is cluster IP\n"
        "   [-d] to indicate delete of cluster IP\n"
        );

    FREE_HEAP( pname );
    return( ERROR_INVALID_PARAMETER );
}



#if 0
DNS_STATUS
ProcessAddIp(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    IP_ADDRESS      ip;
    BOOL            fadd = TRUE;

    //
    //  -addip <IP>
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }

    //
    //  IP to add
    //

    ip = inet_addr( Argv[0] );
    if ( ip == (-1) )
    {
        goto Usage;
    }
    Argc--;
    Argv++;

    //
    //  optional delete flag
    //

    if ( Argc > 0 )
    {
        if ( strncmp( Argv[0], "-d", 2 ) == 0 )
        {
            fadd = FALSE;
            Argc--;
            Argv++;
        }
        if ( Argc != 0 )
        {
            goto Usage;
        }
    }

    //
    //  notify resolver
    //

    DnsNotifyResolverClusterIp(
        ip,
        fadd );

    return( ERROR_SUCCESS );

Usage:

    printf(
        "usage:\n"
        "  DnsUp [-ci] <IP> [-d]\n"
        "   <IP> is cluster IP\n"
        "   [-d] to indicate delete of cluster IP\n"
        );
    return( ERROR_INVALID_PARAMETER );
}
#endif



DNS_STATUS
ProcessSetEnvironmentVariable(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    //
    //  setenv <name> <value>
    //

    if ( Argc < 1 || Argc > 2 )
    {
        goto Usage;
    }

    SetEnvironmentVariableA(
        Argv[0],
        (Argc == 2) ? Argv[1] : NULL );

    return( ERROR_SUCCESS );

Usage:

    printf(
        "Set environment variable\n"
        "usage:\n"
        "  DnsUp [-setenv] <name> [<value>]\n"
        "   <name> name of environment variable\n"
        "   <value> value of environment variable, if missing\n"
        "     then environment variable is deleted\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



//
//  Command Table
//
//  Keep this down here to avoid having prototypes for
//  all these functions.
//

COMMAND_INFO GlobalCommandInfo[] =
{
    //  query

    { "qex"     ,   "QueryEx"               ,   ProcessQueryEx          },
    { "qc"      ,   "QueryCompare"          ,   ProcessQueryCompare     },
    { "q"       ,   "Query"                 ,   ProcessQuery            },
    { "qm"      ,   "QueryMulitple"         ,   ProcessQueryMultiple    },
    { "qt"      ,   "QueryTest"             ,   ProcessQueryTest        },
    { "iq"      ,   "IQuery"                ,   ProcessIQuery           },

    //  update

    { "u"       ,   "Update"                ,   ProcessUpdate               },
    { "ut"      ,   "UpdateTest"            ,   ProcessUpdateTest           },
    //{ "um"      ,   "UpdateMultiple"        ,   ProcessUpdateMultiple       },
    { "dt"      ,   "DhcpTest"              ,   ProcessDhcpTest             },
    { "mr"      ,   "ModifyRecordsInSet"    ,   ProcessModifyRecordsInSet   },
    { "rs"      ,   "ReplaceRecordSet"      ,   ProcessReplaceRecordSet     },

    //  utility

    { "vn"      ,   "ValidateName"          ,   ProcessValidateName         },
    { "s"       ,   "StringTranslate"       ,   ProcessStringTranslate      },
    { "cn"      ,   "NameCompare"           ,   ProcessNameCompare          },
    { "cnx"     ,   "NameCompareEx"         ,   ProcessNameCompareEx        },
    { "config"  ,   "QueryConfig"           ,   ProcessQueryConfig          },

    //  config

    { "setenv"  ,   "SetEnvironmentVariable",   ProcessSetEnvironmentVariable   },

    //  resolver

    { "ci"      ,   "ClusterIp"             ,   ProcessClusterIp            },

    //  RnR

    { "ghn"     ,   "gethostname"           ,   ProcessGetHostName          },
    { "ghbn"    ,   "gethostbyname"         ,   ProcessGetHostByName        },
    { "ghba"    ,   "gethostbyaddr"         ,   ProcessGetHostByAddr        },
    { "gai"     ,   "getaddrinfo"           ,   ProcessGetAddrInfo          },
    { "gni"     ,   "getnameinfo"           ,   ProcessGetNameInfo          },
    { "lsb"     ,   "LookupServiceBegin"    ,   ProcessLookupServiceBegin   },
    { "lsn"     ,   "LookupServiceNext"     ,   ProcessLookupServiceNext    },
    { "lse"     ,   "LookupServiceEnd"      ,   ProcessLookupServiceEnd     },

    //  quit

    { "quit"    ,   "Quit"                  ,   ProcessQuit             },
    { "exit"    ,   "Quit"                  ,   ProcessQuit             },

    { NULL, NULL, NULL },
};

//
//  End dnsup.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\dnsapip.h ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    dnsapip.h

Abstract:

    Domain Name System (DNS) API

    DNS API Private routines.

    These are internal routines for dnsapi.dll AND some exported
    routines for private use by DNS components which need not or
    should not be exposed in public dnsapi.h header.

Author:

    Jim Gilroy (jamesg)     December 7, 1996

Revision History:

--*/


#ifndef _DNSAPIP_INCLUDED_
#define _DNSAPIP_INCLUDED_

#include <ws2tcpip.h>
#include <dnsapi.h>
#include "dnslib.h"
#include "align.h"
#include "iphlpapi.h"


#ifdef __cplusplus
extern "C"
{
#endif  // __cplusplus


//
//  DCR:   add to winerror.h
//

#define DNS_ERROR_REFERRAL_RESPONSE     9506L


//
//  Service stuff
//

//  defined in resrpc.h
//#define DNS_RESOLVER_SERVICE    L"dnscache"
#define DNS_SERVER_SERVICE      L"dns"


//
//  QWORD 
//

#ifndef QWORD
typedef DWORD64     QWORD, *PQWORD;
#endif


//
//  Max address and sockaddr
//      IP6 in ws2tcpip.h
//      ATM in ws2atm.h

typedef union
{
    SOCKADDR_IN     SockaddrIn;
    SOCKADDR_IN6    SockaddrIn6;
    //SOCKADDR_ATM    SockaddrAtm;
}
SOCKADDR_IP, *PSOCKADDR_IP;

typedef union
{
    IP4_ADDRESS     Ip4Addr;
    IP6_ADDRESS     Ip6Addr;
    //ATM_ADDRESS;    AtmAddr;
}
DNS_MAX_ADDRESS, *PDNS_MAX_ADDRESS;

#define DNS_MAX_ADDRESS_LENGTH      (sizeof(DNS_MAX_ADDRESS))
#define DNS_MAX_SOCKADDR_LENGTH     (sizeof(SOCKADDR_IP))


//
//  ws2tcpip.h macros converted to IP6_ADDRESS
//

WS2TCPIP_INLINE
BOOL
IP6_ADDR_EQUAL(
    IN      const IP6_ADDRESS * pIp1,
    IN      const IP6_ADDRESS * pIp2
    )
{
    return RtlEqualMemory( pIp1, pIp2, sizeof(IP6_ADDRESS) );
}

WS2TCPIP_INLINE
BOOL
IP6_IS_ADDR_MULTICAST(
    IN      const IP6_ADDRESS * pIpAddr
    )
{
    return( pIpAddr->IP6Byte[0] == 0xff );
}

WS2TCPIP_INLINE
BOOL
IP6_IS_ADDR_LINKLOCAL(
    IN      const IP6_ADDRESS * pIpAddr
    )
{
    return( (pIpAddr->IP6Byte[0] == 0xfe) &&
            ((pIpAddr->IP6Byte[1] & 0xc0) == 0x80) );
}

WS2TCPIP_INLINE
BOOL
IP6_IS_ADDR_SITELOCAL(
    IN      const IP6_ADDRESS * pIpAddr
    )
{
    return ((pIpAddr->IP6Byte[0] == 0xfe) &&
            ((pIpAddr->IP6Byte[1] & 0xc0) == 0xc0));
}

WS2TCPIP_INLINE
BOOL
IP6_IS_ADDR_V4MAPPED(
    IN      const IP6_ADDRESS * pIpAddr
    )
{
    return ((pIpAddr->IP6Dword[0] == 0) && 
            (pIpAddr->IP6Dword[1] == 0) && 
            (pIpAddr->IP6Dword[2] == 0xffff0000) );
}

WS2TCPIP_INLINE
BOOL
IP6_IS_ADDR_V4COMPAT(
    IN      const IP6_ADDRESS * pIpAddr
    )
{
    //  IP6 address has only last DWORD
    //      and is NOT any or loopback

    return ((pIpAddr->IP6Dword[0] == 0) && 
            (pIpAddr->IP6Dword[1] == 0) &&
            (pIpAddr->IP6Dword[2] == 0) &&
            (pIpAddr->IP6Dword[3] != 0) && 
            (pIpAddr->IP6Dword[3] != 0x01000000) );
}

//
//  Tests piggy-backing on ws2tcpip.h ones
//

#define IP6_IS_ADDR_UNSPECIFIED(a) \
        IN6_ADDR_EQUAL( (PIN6_ADDR)(a), &in6addr_any )

#if 0
//  this doesn't seem to work

#define IP6_IS_ADDR_LOOPBACK(a)  \
        IN6_ADDR_EQUAL( (PIN6_ADDR)(a), &in6addr_loopback )
#endif

WS2TCPIP_INLINE
BOOL
IP6_IS_ADDR_LOOPBACK(
    IN      const IP6_ADDRESS * pIpAddr
    )
{
    return ((pIpAddr->IP6Dword[0] == 0) && 
            (pIpAddr->IP6Dword[1] == 0) &&
            (pIpAddr->IP6Dword[2] == 0) &&
            (pIpAddr->IP6Dword[3] == 0x01000000) );
}

//
//  More IP6 extensions missing from ws2tcpip.h
//

WS2TCPIP_INLINE
VOID
IP6_SET_ADDR_ANY(
    OUT     PIP6_ADDRESS    pIn6Addr
    )
{
    memset( pIn6Addr, 0, sizeof(*pIn6Addr) );

    //pIn6Addr->IP6Dword[0]  = 0;
    //pIn6Addr->IP6Dword[1]  = 0;
    //pIn6Addr->IP6Dword[2]  = 0;
    //pIn6Addr->IP6Dword[3]  = 0;
}

WS2TCPIP_INLINE
VOID
IP6_SET_ADDR_LOOPBACK(
    OUT     PIP6_ADDRESS    pIn6Addr
    )
{
    pIn6Addr->IP6Dword[0]  = 0;
    pIn6Addr->IP6Dword[1]  = 0;
    pIn6Addr->IP6Dword[2]  = 0;
    pIn6Addr->IP6Dword[3]  = 0x01000000;
}

WS2TCPIP_INLINE
VOID
IP6_SET_ADDR_V4COMPAT(
    OUT     PIP6_ADDRESS    pIn6Addr,
    IN      IP4_ADDRESS     Ip4
    )
{
    pIn6Addr->IP6Dword[0]  = 0;
    pIn6Addr->IP6Dword[1]  = 0;
    pIn6Addr->IP6Dword[2]  = 0;
    pIn6Addr->IP6Dword[3]  = Ip4;
}

WS2TCPIP_INLINE
VOID
IP6_SET_ADDR_V4MAPPED(
    OUT     PIP6_ADDRESS    pIn6Addr,
    IN      IP4_ADDRESS     Ip4
    )
{
    pIn6Addr->IP6Dword[0]  = 0;
    pIn6Addr->IP6Dword[1]  = 0;
    pIn6Addr->IP6Dword[2]  = 0xffff0000;
    pIn6Addr->IP6Dword[3]  = Ip4;
}

WS2TCPIP_INLINE
IP4_ADDRESS
IP6_GET_V4_ADDR(
    IN      const IP6_ADDRESS * pIn6Addr
    )
{
    return( pIn6Addr->IP6Dword[3] );
}



//
//  Message Addressing
//

#define MSG_REMOTE_IP4(pMsg)  \
        ( (pMsg)->RemoteAddress.In4.sin_addr.s_addr )

#define MSG_REMOTE_IP_STRING(pMsg)  \
        IP_STRING( MSG_REMOTE_IP4(pMsg) )

#define MSG_REMOTE_IP_PORT(pMsg)  \
        ( (pMsg)->RemoteAddress.In4.sin_port )



//
//  Callback function defs
//
//  These allow dnsapi.dll code to be executed with callbacks
//  into the resolver where behavior should differ for
//  execution in resolver context.
//

typedef PDNS_ADDR_ARRAY (* GET_ADDR_ARRAY_FUNC)( VOID );

typedef BOOL (* QUERY_CACHE_FUNC)( PVOID );

typedef BOOL (* IS_CLUSTER_IP_FUNC)( PVOID, PIP_UNION );


//
//  Private query flags
//

#define DNSP_QUERY_FILTER_CLUSTER           0x01000000


//
//  Query blob
//

#ifdef PQUERY_BLOB    
#undef PQUERY_BLOB    
#endif

typedef struct _DnsResults
{
    DNS_STATUS          Status;
    WORD                Rcode;

    //  DCR:  allow IP6, then put IP4 in IP6Mapped

    IP6_ADDRESS         ServerIp6;
    IP4_ADDRESS         ServerIp;

    PDNS_RECORD         pAnswerRecords;
    PDNS_RECORD         pAliasRecords;
    PDNS_RECORD         pAuthorityRecords;
    PDNS_RECORD         pAdditionalRecords;
    PDNS_RECORD         pSigRecords;

    PDNS_MSG_BUF        pMessage;
}
DNS_RESULTS, *PDNS_RESULTS;


typedef struct _QueryBlob
{
    //  query data

    PWSTR               pNameOrig;
    PSTR                pNameOrigWire;
    PSTR                pNameWire;
    WORD                wType;
    WORD                Reserved1;
    //16
    DWORD               Flags;

    //  query name info

    DWORD               NameLength;
    DWORD               NameAttributes;
    DWORD               QueryCount;
    //32
    DWORD               NameFlags;
    BOOL                fAppendedName;

    //  return info

    DWORD               Status;
    WORD                Rcode;
    WORD                Reserved2;
    //48
    DWORD               NetFailureStatus;
    BOOL                fCacheNegative;
    BOOL                fNoIpLocal;

    //  remove these once results fixed up

    PDNS_RECORD         pRecords;
    //64
    PDNS_RECORD         pLocalRecords;

    //  control info

    PDNS_NETINFO        pNetworkInfo;
    PIP4_ARRAY          pDnsServers;
    HANDLE              hEvent;
    //80

    GET_ADDR_ARRAY_FUNC pfnGetAddrArray;
    QUERY_CACHE_FUNC    pfnQueryCache;
    IS_CLUSTER_IP_FUNC  pfnIsClusterIp;

    //  result info

    PDNS_MSG_BUF        pSendMsg;
    PDNS_MSG_BUF        pRecvMsg;

    DNS_RESULTS         Results;
    DNS_RESULTS         BestResults;

    //  buffers

    CHAR                NameOriginalWire[ DNS_MAX_NAME_BUFFER_LENGTH ];
    CHAR                NameWire[ DNS_MAX_NAME_BUFFER_LENGTH ];
    WCHAR               NameBufferWide[ DNS_MAX_NAME_BUFFER_LENGTH ];

    //  DCR:  could do a message here
}
QUERY_BLOB, *PQUERY_BLOB;


//
//  System event notification routine (PnP) (svccntl.c)
//

DWORD
_fastcall
SendServiceControl(
    IN  LPWSTR pszServiceName,
    IN  DWORD  dwControl
    );

//
//  Poke ops
//

#define POKE_OP_UPDATE_NETINFO      (0x2f0d7831)

#define POKE_COOKIE_UPDATE_NETINFO  (0x4598efab)


//
//  Network Info
//

//
//  Runtime network info flags
//
//  DCR:  no runtime ignore\disable
//      not yet using runtime ignore disable flag
//      when do should create combined
//

#define RUN_FLAG_NETINFO_PREPARED           (0x00000001)
#define RUN_FLAG_STOP_QUERY_ON_ADAPTER      (0x00000010)
#define RUN_FLAG_QUERIED_ADAPTER_DOMAIN     (0x00010000)
#define RUN_FLAG_RESET_SERVER_PRIORITY      (0x00100000)
#define RUN_FLAG_IGNORE_ADAPTER             (0x10000000)

#define RUN_FLAG_QUERY_MASK                 (0x00ffffff)
#define RUN_FLAG_SINGLE_NAME_MASK           (0x000000ff)

//  Create cleanup "levels" as mask of bits to keep
//  These are the params to NetInfo_Clean()

#define CLEAR_LEVEL_ALL                     (0)
#define CLEAR_LEVEL_QUERY                   (~RUN_FLAG_QUERY_MASK)
#define CLEAR_LEVEL_SINGLE_NAME             (~RUN_FLAG_SINGLE_NAME_MASK)
        
        
VOID
NetInfo_Free(
    IN OUT  PDNS_NETINFO    pNetInfo
    );

PDNS_NETINFO     
NetInfo_Copy(
    IN      PDNS_NETINFO    pNetInfo
    );

PDNS_NETINFO     
NetInfo_Build(
    IN      BOOL            fGetIpAddrs
    );

VOID
NetInfo_Clean(
    IN OUT  PDNS_NETINFO    pNetInfo,
    IN      DWORD           ClearLevel
    );
        
VOID
NetInfo_ResetServerPriorities(
    IN OUT  PDNS_NETINFO    pNetInfo,
    IN      BOOL            fLocalDnsOnly
    );


//
//  Local IP info (localip.c)
//

PDNS_ADDR_ARRAY
DnsGetLocalAddrArray(
    VOID
    );

PDNS_ADDR_ARRAY
DnsGetLocalAddrArrayDirect(
    VOID
    );



//
//  Query (query.c)
//

#define DNS_ERROR_NAME_NOT_FOUND_LOCALLY \
        DNS_ERROR_RECORD_DOES_NOT_EXIST


//
//  Main query routine to DNS servers
//
//  Called both internally and from resolver
//

DNS_STATUS
Query_Main(
    IN OUT  PQUERY_BLOB     pBlob
    );

DNS_STATUS
Query_SingleName(
    IN OUT  PQUERY_BLOB     pBlob
    );

VOID
CombineRecordsInBlob(
    IN      PDNS_RESULTS    pResults,
    OUT     PDNS_RECORD *   ppRecords
    );

VOID
BreakRecordsIntoBlob(
    OUT     PDNS_RESULTS    pResults,
    IN      PDNS_RECORD     pRecords,
    IN      WORD            wType
    );

DNS_STATUS
GetRecordsForLocalName(
    IN OUT  PQUERY_BLOB     pBlob
    );


//
//  Called by dnsup.c
//

DNS_STATUS
QueryDirectEx(
    IN OUT  PDNS_MSG_BUF *      ppMsgResponse,
    OUT     PDNS_RECORD *       ppResponseRecords,
    IN      PDNS_HEADER         pHeader,
    IN      BOOL                fNoHeaderCounts,
    IN      PDNS_NAME           pszQuestionName,
    IN      WORD                wQuestionType,
    IN      PDNS_RECORD         pRecords,
    IN      DWORD               dwFlags,
    IN      PIP_ARRAY           aipDnsServers,
    IN OUT  PDNS_NETINFO        pNetworkInfo
    );


//
//  FAZ (faz.c)
//

DNS_STATUS
DnsFindAuthoritativeZone(
    IN      PDNS_NAME           pszName,
    IN      DWORD               dwFlags,
    IN      PIP_ARRAY           aipQueryServers,    OPTIONAL
    OUT     PDNS_NETINFO      * ppFazNetworkInfo
    );

BOOL
WINAPI
CompareMultiAdapterSOAQueries(
    IN      LPSTR               pszDomainName,
    IN      PIP_ARRAY           pDnsServerList1,
    IN      PIP_ARRAY           pDnsServerList2
    );

BOOL
WINAPI
CompareTwoAdaptersForSameNameSpace(
    IN      PIP_ARRAY           pDnsServerList1,
    IN      PDNS_NETINFO        pNetworkInfo1,
    IN OUT  PDNS_RECORD *       ppNsRecord1,
    IN      PIP_ARRAY           pDnsServerList2,
    IN      PDNS_NETINFO        pNetworkInfo2,
    IN OUT  PDNS_RECORD *       ppNsRecord2,
    IN      BOOL                bDoNsCheck
    );



//
//  Update (update.c)
//

DNS_STATUS
DnsUpdate(
    IN      PDNS_RECORD         pRecord,
    IN      DWORD               dwFlags,
    IN      PDNS_NETINFO        pNetworkInfo,
    IN      HANDLE              hCreds,
    OUT     PDNS_MSG_BUF *      ppMsgRecv       OPTIONAL
    );

//
// Old flags used for DnsModifyRecordSet & DnsRegisterRRSet
//
#define DNS_UPDATE_UNIQUE                   0x00000000
#define DNS_UPDATE_SHARED                   0x00000001

//
//  Modify SET is completely private
//

DNS_STATUS
WINAPI
DnsModifyRecordSet_A(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pCurrentSet,
    IN  PDNS_RECORD pNewSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

DNS_STATUS
WINAPI
DnsModifyRecordSet_UTF8(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pCurrentSet,
    IN  PDNS_RECORD pNewSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

DNS_STATUS
WINAPI
DnsModifyRecordSet_W(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pCurrentSet,
    IN  PDNS_RECORD pNewSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

#ifdef UNICODE
#define DnsModifyRecordSet DnsModifyRecordSet_W
#else
#define DnsModifyRecordSet DnsModifyRecordSet_A
#endif



DNS_STATUS
WINAPI
DnsAddRecordSet_A(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

DNS_STATUS
WINAPI
DnsAddRecordSet_UTF8(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

DNS_STATUS
WINAPI
DnsAddRecordSet_W(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

#ifdef UNICODE
#define DnsAddRecordSet DnsAddRecordSet_W
#else
#define DnsAddRecordSet DnsAddRecordSet_A
#endif




//
//  Sockets (socket.c)
//

DNS_STATUS
Dns_InitializeWinsockEx(
    IN      BOOL            fForce
    );

DNS_STATUS
Dns_CacheSocketInit(
    IN      DWORD           MaxSocketCount
    );

VOID
Dns_CacheSocketCleanup(
    VOID
    );

SOCKET
Dns_GetUdpSocket(
    VOID
    );

VOID
Dns_ReturnUdpSocket(
    IN      SOCKET          Socket
    );


//
//  Host file (hostfile.c)
//

#define MAXALIASES                  (8)
#define MAX_HOST_FILE_LINE_SIZE     (1000)     

typedef struct _HostFileInfo
{
    FILE *          hFile;
    PSTR            pszFileName;

    //  build records

    BOOL            fBuildRecords;

    //  record results

    PDNS_RECORD     pForwardRR;
    PDNS_RECORD     pReverseRR;
    PDNS_RECORD     pAliasRR;

    //  line data

    IP_UNION        Ip;
    PCHAR           pAddrString;
    PCHAR           pHostName;
    PCHAR           AliasArray[ MAXALIASES+1 ];

    CHAR            HostLineBuf[ MAX_HOST_FILE_LINE_SIZE+1 ];
}
HOST_FILE_INFO, *PHOST_FILE_INFO;


BOOL
Dns_OpenHostFile(
    IN OUT  PHOST_FILE_INFO pHostInfo
    );

VOID
Dns_CloseHostFile(
    IN OUT  PHOST_FILE_INFO pHostInfo
    );

BOOL
Dns_ReadHostFileLine(
    IN OUT  PHOST_FILE_INFO pHostInfo
    );


//
//  Debug sharing 
//

PDNS_DEBUG_INFO
DnsApiSetDebugGlobals(
    IN OUT  PDNS_DEBUG_INFO pInfo
    );



//
//  DnsLib routine
//
//  dnslib.lib routines that depend on client only definitions
//  and hence not defined in server space.
//  Note, these could be moved to dnslibp.h with some sort of
//  #define for client only builds, or #define that the type
//  definition has been picked up from resrpc.h
//

//
//  Record prioritization  (rrsort.c)
//
//  Defined here because DNS_ADDR_INFO definition
//  should NOT be public
//

PDNS_RECORD
Dns_PrioritizeARecordSet(
    IN      PDNS_RECORD         pRR,
    IN      PDNS_ADDR_INFO      aAddressInfo,
    IN      DWORD               cipAddress
    );

PDNS_RECORD
Dns_PrioritizeRecordSet(
    IN OUT  PDNS_RECORD         pRecordList,
    IN      PDNS_ADDR_INFO      aAddressInfo,
    IN      DWORD               cAddressInfo
    );

PDNS_RECORD
Dns_PrioritizeRecordSetEx(
    IN OUT  PDNS_RECORD         pRecordList,
    IN      PDNS_ADDR_ARRAY     pAddrArray
    );


//
//  Printing of private dnsapi types (dnslib\print.c)
//

VOID
DnsPrint_NetworkInfo(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PVOID           pContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_NETINFO    pNetworkInfo
    );

VOID
DnsPrint_AdapterInfo(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_ADAPTER    pAdapterInfo
    );

VOID
DnsPrint_SearchList(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      LPSTR           pszHeader,
    IN      PSEARCH_LIST    pSearchList
    );

VOID
DnsPrint_QueryBlob(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PQUERY_BLOB     pQueryBlob
    );

VOID
DnsPrint_QueryInfo(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_QUERY_INFO pQueryInfo
    );

VOID
DnsPrint_DnsAddrArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_ADDR_ARRAY pAddrArray
    );

#if DBG

#define DnsDbg_NetworkInfo(a,b)             DnsPrint_NetworkInfo(DnsPR,NULL,(a),(b))
#define DnsDbg_AdapterInfo(a,b)             DnsPrint_AdapterInfo(DnsPR,NULL,(a),(b))
#define DnsDbg_SearchList(a,b)              DnsPrint_SearchList(DnsPR,NULL,(a),(b))

#define DnsDbg_DnsAddrArray(a,b)            DnsPrint_DnsAddrArray(DnsPR,NULL,a,b)
#define DnsDbg_QueryBlob(a,b)               DnsPrint_QueryBlob(DnsPR,NULL,(a),(b))
#define DnsDbg_QueryInfo(a,b)               DnsPrint_QueryInfo(DnsPR,NULL,(a),(b))

#else   // retail

#define DnsDbg_NetworkInfo(a,b)
#define DnsDbg_AdapterInfo(a,b)
#define DnsDbg_SearchList(a,b)

#define DnsDbg_DnsAddrArray(a,b)
#define DnsDbg_QueryBlob(a,b)
#define DnsDbg_QueryInfo(a,b)

#endif


#ifdef __cplusplus
}
#endif  // __cplusplus

#endif // _DNSAPIP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\dynreg.c ===
/*++

Copyright (c) 1997-2001 Microsoft Corporation

Module Name:

    dynreg.c

Abstract:

    Domain Name System (DNS) API 

    Dynamic registration implementation

Author:

    Ram Viswanathan (ramv)  March 27 1997

Revision History:

--*/

#include "local.h"

#define ENABLE_DEBUG_LOGGING 0

#include "logit.h"


HANDLE                  hQuitEvent = NULL;
HANDLE                  hSem = NULL;
HANDLE                  handle[2] = { NULL, NULL} ;
HANDLE                  hConsumerThread = NULL;
BOOL                    g_fStopNotify = FALSE;
PDYNDNSQUEUE            g_pdnsQueue = NULL;
PDYNDNSQUEUE            g_pTimedOutQueue = NULL;
DWORD                   g_dwQCount = 0;
DWORD                   g_MainQueueCount = 0;


#define MAX_QLEN                        0xFFFF
#define MAX_RETRIES                     0x3

#define DNS_MAX_DHCP_SERVER_REGISTRATION_QUEUE_SIZE 250 // Arbitrary?


//
//  Credentials for updates
//

PSEC_WINNT_AUTH_IDENTITY_W  g_pIdentityCreds = NULL;

//CredHandle g_CredHandle;

HANDLE  g_UpdateCredContext = NULL;


//
//  Queue allocations in dnslib heap
//

#define QUEUE_ALLOC_HEAP(Size)      Dns_Alloc(Size)
#define QUEUE_ALLOC_HEAP_ZERO(Size) Dns_AllocZero(Size)
#define QUEUE_FREE_HEAP(pMem)       Dns_Free(pMem)



//
// local helper functions
//

DNS_STATUS
DynDnsRegisterEntries(
    VOID
    );


DNS_STATUS
DynDnsAddForward(
    IN OUT  REGISTER_HOST_ENTRY HostAddr,
    IN      LPWSTR              pszName,
    IN      DWORD               dwTTL,
    IN      PIP_ARRAY           DnsServerList
    )
{
    DNS_STATUS  status = 0;
    DNS_RECORD  record;

    DYNREG_F1( "Inside function DynDnsAddForward" );

    RtlZeroMemory( &record, sizeof(DNS_RECORD) );

    record.pName = (PCHAR)pszName;
    record.wType = DNS_TYPE_A;
    record.dwTtl = dwTTL;
    record.wDataLength = sizeof(record.Data.A);
    record.Data.A.IpAddress = HostAddr.Addr.ipAddr;

    DYNREG_F1( "DynDnsAddForward - Calling DnsReplaceRecordSet_W for A record:" );
    DYNREG_F2( "  Name: %S", record.pName );
    DYNREG_F2( "  Address: 0x%x", record.Data.A.IpAddress );

    status = DnsReplaceRecordSetW(
                & record,
                DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                NULL,               // no security context
                (PIP4_ARRAY) DnsServerList,
                NULL                // reserved
                );

    DYNREG_F2( "DynDnsAddForward - DnsReplaceRecordSet returned status: 0%x", status );

    return( status );
}


DNS_STATUS
DynDnsDeleteForwards(
    IN      PDNS_RECORD     pDnsList,
    IN      IP_ADDRESS      ipAddr,
    IN      PIP_ARRAY       DnsServerList
    )
{
    DNS_STATUS  status = 0;
    PDNS_RECORD prr;
    DNS_RECORD  record;

    DYNREG_F1( "Inside function DynDnsDeleteForwards" );

    //
    // the list pointed to by pDnsList is a set of PTR records.
    //

    RtlZeroMemory( &record, sizeof(DNS_RECORD) );

    prr = pDnsList;

    for ( prr = pDnsList;
          prr;
          prr = prr->pNext )
    {
        if ( prr->wType != DNS_TYPE_PTR )
        {
            //
            // should not happen
            //
            continue;
        }

        //
        // As far as the DHCP server is concerned, when timeout happens
        // or when client releases an address, It can update the
        // address lookup to clean up turds left over by say, a roaming
        // laptop
        //

        record.pName = prr->Data.Ptr.pNameHost;
        record.wType = DNS_TYPE_A;
        record.wDataLength = sizeof(DNS_A_DATA);
        record.Data.A.IpAddress = ipAddr ;

        //
        // make the appropriate call and return the first failed error
        //

        DYNREG_F1( "DynDnsDeleteForwards - Calling ModifyRecords(Remove) for A record:" );
        DYNREG_F2( "  Name: %S", record.pName );
        DYNREG_F2( "  Address: 0x%x", record.Data.A.IpAddress );

        status = DnsModifyRecordsInSet_W(
                        NULL,                       // no add records
                        & record,                   // delete record
                        DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                        NULL,                       // no security context
                        (PIP4_ARRAY) DnsServerList, // DNS servers
                        NULL                        // reserved
                        );

        if ( status != ERROR_SUCCESS )
        {
            //
            //  DCR_QUESTION:  do we really want to stop on failure?
            break;
        }
        DYNREG_F2( "DynDnsDeleteForwards - ModifyRecords(Remove) returned status: 0%x", status );
    }

    return( status );
}


DNS_STATUS
DynDnsAddEntry(
    REGISTER_HOST_ENTRY HostAddr,
    LPWSTR              pszName,
    DWORD               dwRegisteredTTL,
    BOOL                fDoForward,
    PDWORD              pdwFwdErrCode,
    PIP_ARRAY           DnsServerList
    )
{
    DNS_STATUS  status = 0;
    DWORD       returnCode = 0;
    DNS_RECORD  record;
    WCHAR       reverseNameBuf[DNS_MAX_REVERSE_NAME_BUFFER_LENGTH];
    DWORD       cch;

    DYNREG_F1( "Inside function DynDnsAddEntry" );

    *pdwFwdErrCode = 0;

    if ( !(HostAddr.dwOptions & REGISTER_HOST_PTR) )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    //
    //  create reverse lookup name for IP address
    //

    Dns_Ip4AddressToReverseName_W(
        reverseNameBuf,
        HostAddr.Addr.ipAddr );


    if ( fDoForward )
    {
        DYNREG_F1( "DynDnsAddEntry - Calling DynDnsAddForward" );

        //
        // we simply make a best case effort to do the forward add
        // if it fails, we simply ignore
        //

        returnCode = DynDnsAddForward(
                        HostAddr,
                        pszName,
                        dwRegisteredTTL,
                        DnsServerList );

        DYNREG_F2( "DynDnsAddEntry - DynDnsAddForward returned: 0%x",
                   returnCode );

        *pdwFwdErrCode = returnCode;
    }

    RtlZeroMemory( &record, sizeof(DNS_RECORD) );

    record.pName =  (PDNS_NAME) reverseNameBuf;
    record.dwTtl =  dwRegisteredTTL;
    record.wType =  DNS_TYPE_PTR;
    record.Data.Ptr.pNameHost = (PDNS_NAME)pszName;
    record.wDataLength = sizeof(record.Data.Ptr.pNameHost);

    DYNREG_F1( "DynDnsAddEntry - Calling DnsAddRecords_W for PTR record:" );
    DYNREG_F2( "  Name: %S", record.pName );
    DYNREG_F2( "  Ptr: %S", record.Data.Ptr.pNameHost );

    status = DnsModifyRecordsInSet_W(
                    & record,                   // add record
                    NULL,                       // no delete records
                    DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                    NULL,                       // no context handle
                    (PIP4_ARRAY) DnsServerList, // DNS servers
                    NULL                        // reserved
                    );

    DYNREG_F2( "DynDnsAddEntry - DnsAddRecords_W returned status: 0%x", status );

Exit:

    return( status );
}


DNS_STATUS
DynDnsDeleteEntry(
    REGISTER_HOST_ENTRY HostAddr,
    LPWSTR              pszName,
    BOOL                fDoForward,
    PDWORD              pdwFwdErrCode,
    PIP_ARRAY           DnsServerList
    )
{
    //
    // Brief Synopsis of functionality:
    // On DoForward try deleting the forward mapping. Ignore failure
    // Then try deleting the PTR record. If that fails
    // because server is down, try again, if it fails because the
    // operation was refused, then dont retry
    //

    DWORD       status = 0;
    DWORD       returnCode = 0;
    DNS_RECORD  recordPtr;
    DNS_RECORD  recordA;
    WCHAR       reverseNameBuf[DNS_MAX_REVERSE_NAME_BUFFER_LENGTH] ;
    INT         i;
    INT         cch;
    PDNS_RECORD precord = NULL;

    DYNREG_F1( "Inside function DynDnsDeleteEntry" );

    *pdwFwdErrCode = 0;

    //
    //  build reverse lookup name for IP
    //

    Dns_Ip4AddressToReverseName_W(
        reverseNameBuf,
        HostAddr.Addr.ipAddr);


    if ( fDoForward )
    {
        if ( pszName && *pszName )
        {
            //
            // we delete a specific forward. not all forwards as we do
            // when we do a query
            //

            RtlZeroMemory( &recordA, sizeof(DNS_RECORD) );

            recordA.pName = (PDNS_NAME) pszName;
            recordA.wType = DNS_TYPE_A;
            recordA.wDataLength = sizeof(DNS_A_DATA);
            recordA.Data.A.IpAddress = HostAddr.Addr.ipAddr;

            DYNREG_F1( "DynDnsDeleteEntry - Calling ModifyRecords(Remove) for A record:" );
            DYNREG_F2( "  Name: %S", recordA.pName );
            DYNREG_F2( "  Address: 0x%x", recordA.Data.A.IpAddress );

            //
            // make the appropriate call
            //

            returnCode = DnsModifyRecordsInSet_W(
                                NULL,                       // no add records
                                &recordA,                   // delete record
                                DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                                NULL,                       // no security context
                                (PIP4_ARRAY) DnsServerList, // DNS servers
                                NULL                        // reserved
                                );

            DYNREG_F2( "DynDnsDeleteEntry - ModifyRecords(Remove) returned status: 0%x", returnCode );

            *pdwFwdErrCode = returnCode;
        }
        else
        {
            DYNREG_F1( "DynDnsDeleteEntry - Name not specified, going to query for PTR" );

            //
            //name not specified
            //
            status = DnsQuery_W(
                            reverseNameBuf,
                            DNS_TYPE_PTR,
                            DNS_QUERY_BYPASS_CACHE,
                            DnsServerList,
                            &precord,
                            NULL );

            DYNREG_F2( "DynDnsDeleteEntry - DnsQuery_W returned status: 0%x", status );

            switch ( status )
            {
                case DNS_ERROR_RCODE_NO_ERROR:

                    DYNREG_F1( "DynDnsDeleteEntry - Calling DynDnsDeleteForwards" );

                    returnCode = DynDnsDeleteForwards(
                                        precord,
                                        HostAddr.Addr.ipAddr,
                                        DnsServerList );

                    DYNREG_F2( "DynDnsDeleteEntry - DynDnsDeleteForwards returned status: 0%x", returnCode );

                    *pdwFwdErrCode = returnCode;

#if 0
                    switch ( returnCode )
                    {
                        case DNS_ERROR_RCODE_NO_ERROR:
                            //
                            // we succeeded, break out
                            //
                            break;

                        case DNS_ERROR_RCODE_REFUSED:
                            //
                            // nothing can be done
                            //
                            break;

                        case DNS_ERROR_RCODE_SERVER_FAILURE:
                        case DNS_ERROR_TRY_AGAIN_LATER:
                        case ERROR_TIMEOUT:
                            //
                            // need to retry this again
                            //
                            // goto Exit; // if uncommented will force retry
                            break;

                        case DNS_ERROR_RCODE_NOT_IMPLEMENTED:
                        default:
                            //
                            // query itself failed. Nothing can be done
                            //
                            break;
                    }
#endif

                    break;

                default:
                    //
                    // caller takes care of each situation in turn
                    // PTR record cannot be queried for and hence
                    // cant be deleted
                    //
                    goto Exit;
            }
        }
    }

    //
    // delete PTR Record
    //

    if ( pszName && *pszName )
    {
        //
        // name is known
        //

        RtlZeroMemory( &recordPtr, sizeof(DNS_RECORD) );

        recordPtr.pName = (PDNS_NAME) reverseNameBuf;
        recordPtr.wType = DNS_TYPE_PTR;
        recordPtr.wDataLength = sizeof(DNS_PTR_DATA);
        recordPtr.Data.Ptr.pNameHost = (PDNS_NAME) pszName;

        DYNREG_F1( "DynDnsDeleteEntry - Calling ModifyRecords(Remove) for PTR record:" );
        DYNREG_F2( "  Name: %S", recordPtr.pName );
        DYNREG_F2( "  PTR : 0%x", recordPtr.Data.Ptr.pNameHost );

        status = DnsModifyRecordsInSet_W(
                            NULL,           // no add records
                            &recordPtr,     // delete record
                            DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                            NULL,           // no security context
                            (PIP4_ARRAY) DnsServerList, // DNS servers
                            NULL            // reserved
                            );

        DYNREG_F2( "DynDnsDeleteEntry - ModifyRecords(Remove) returned status: 0%x", status );
    }
    else
    {
        DYNREG_F1( "DynDnsDeleteEntry - Calling ModifyRecords(Remove) for PTR record:" );

        if ( fDoForward && precord )
        {
            //
            //  remove record from the earlier query that you made
            //

            status = DnsModifyRecordsInSet_W(
                                NULL,           // no add records
                                precord,        // delete record from query
                                DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                                NULL,           // no security context
                                (PIP4_ARRAY) DnsServerList,
                                NULL            // reserved
                                );
    
            DYNREG_F2( "DynDnsDeleteEntry - ModifyRecords(Remove) returned status: 0%x", status );
        }
        else
        {
            //
            //  name is NOT known
            //
            //  remove ALL records of PTR type
            //      - zero datalength indicates type delete
            //

            RtlZeroMemory( &recordPtr, sizeof(DNS_RECORD) );

            recordPtr.pName = (PDNS_NAME) reverseNameBuf;
            recordPtr.wType = DNS_TYPE_PTR;
            recordPtr.Data.Ptr.pNameHost = (PDNS_NAME) NULL;

            DYNREG_F1( "DynDnsDeleteEntry - Calling ModifyRecords(Remove) for ANY PTR records:" );
            DYNREG_F2( "  Name: %S", recordPtr.pName );
            DYNREG_F2( "  PTR : 0%x", recordPtr.Data.Ptr.pNameHost );

            status = DnsModifyRecordsInSet_W(
                                NULL,           // no add records
                                &recordPtr,     // delete record
                                DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                                NULL,           // no security context
                                (PIP4_ARRAY) DnsServerList,
                                NULL            // reserved
                                );
    
            DYNREG_F2( "DynDnsDeleteEntry - ModifyRecords(Remove) returned status: 0%x", status );
        }
    }

Exit:

    if ( precord )
    {
        //  DCR:  need to fix this in Win2K
        //  
        //QUEUE_FREE_HEAP( precord );

        DnsRecordListFree(
            precord,
            DnsFreeRecordListDeep );
    }

    return( status );
}


DNS_STATUS
DynDnsRegisterEntries(
    VOID
    )

/*
  DynDnsRegisterEntries()

      This is the thread that dequeues the appropriate parameters
      from the main queue and starts acting upon it. This is where
      the bulk of the work gets done. Note that this function
      gets called in an endless loop

      Briefly, this is what the function does.

      a) Find PTR corresponding to the Host Addr passed in.
      b) If this is the same as the Address name passed in, then leave as is,
         Otherwise delete and add new PTR record.
      c) Follow forward and delete if possible from the forward's
         dns server.
      d) If DoForward then do what the client would've done in an NT5.0 case,
         i.e. Try to write a new forward lookup.


  Arguments:

      No arguments

  Return Value:

  is 0 if Success. and (DWORD)-1 if failure.

*/

{
    /*
      cases to be considered here.

      DYNDNS_ADD_ENTRY:
      First query for the lookup
      For each of the PTR records that come back, you need to check
      against the one you are asked to register. If there is a match,
      exit with success. If not add this entry for the PTR

      if downlevel, then we need to add this entry to forward A record
      as well.

      DYNDNS_DELETE_ENTRY
      Delete the entry that corresponds to the pair that you have specified
      here. If it does not exist then do nothing about it.

      If downlevel here, then go to the A record correspond to this and
      delete the forward entry as well.

    */

    DWORD               status, dwWaitResult;
    PQELEMENT           pQElement = NULL;
    LPWSTR              pszName = NULL;
    BOOL                fDoForward;
    PQELEMENT           pBackDependency = NULL;
    REGISTER_HOST_ENTRY HostAddr ;
    DWORD               dwOperation;
    DWORD               dwCurrTime;
    DWORD               dwTTL;
    DWORD               dwWaitTime = INFINITE;
    DWORD               dwFwdAddErrCode = 0;
    DHCP_CALLBACK_FN    pfnDhcpCallBack = NULL;
    PVOID               pvData = NULL;

    DYNREG_F1( "Inside function DynDnsRegisterEntries" );

    //
    // call back function
    //

    //
    // check to see if there is any item in the timed out queue
    // that has the timer gone out and so you can start processing
    // that element right away
    //

    dwCurrTime = Dns_GetCurrentTimeInSeconds();

    if ( g_pTimedOutQueue &&
         g_pTimedOutQueue->pHead &&
         (dwCurrTime > g_pTimedOutQueue->pHead->dwRetryTime) )
    {
        //
        // dequeue an element from the timed out queue and process it
        //
        DYNREG_F1( "DynDnsRegisterEntries - Dequeue element from timed out list" );

        pQElement = Dequeue( g_pTimedOutQueue );

        if ( !pQElement )
        {
            status = ERROR_SUCCESS;
            goto Exit;
        }

        pfnDhcpCallBack = pQElement->pfnDhcpCallBack;
        pvData = pQElement->pvData;

        //
        // now determine if we have processed this element way too many
        // times
        //

        if ( pQElement->dwRetryCount >= MAX_RETRIES )
        {
            DYNREG_F1( "DynDnsRegisterEntries - Element has failed too many times, calling DHCP callback function" );
            if (pQElement->fDoForwardOnly)
            {
                if ( pfnDhcpCallBack )
                    (*pfnDhcpCallBack)(DNSDHCP_FWD_FAILED, pvData);
            }
            else
            {
                if ( pfnDhcpCallBack )
                    (*pfnDhcpCallBack)(DNSDHCP_FAILURE, pvData);
            }

            if ( pQElement->pszName )
                QUEUE_FREE_HEAP( pQElement->pszName );

            QUEUE_FREE_HEAP( pQElement );
            status = ERROR_SUCCESS;
            goto Exit;
        }
    }
    else
    {
        DWORD dwRetryTime = GetEarliestRetryTime (g_pTimedOutQueue);

        DYNREG_F1( "DynDnsRegisterEntries - No element in timed out queue." );
        DYNREG_F1( "                        Going to wait for next element." );

        dwWaitTime = dwRetryTime != (DWORD)-1 ?
            (dwRetryTime > dwCurrTime? (dwRetryTime - dwCurrTime) *1000: 0)
            : INFINITE;

        dwWaitResult = WaitForMultipleObjects ( 2,
                                                handle,
                                                FALSE,
                                                dwWaitTime );

        switch ( dwWaitResult )
        {
            case WAIT_OBJECT_0:
                //
                // quit event, return and let caller take care
                //
                return(0);

            case WAIT_OBJECT_0 + 1 :
                //
                // dequeue an element from the main queue and process
                //
                pQElement = Dequeue(g_pdnsQueue);

                if (!pQElement)
                {
                    //
                    // should not happen, assert failure and return error
                    //
                    status = NO_ERROR; // Note: This actually does happen
                                        // because when Ram adds a new
                                        // entry, he may put it in the
                                        // timed out queue instead of the
                                        // g_pdnsQueue when there is a related
                                        // item pending a retry time. Assert
                                        // removed and error code changed to
                                        // to success by GlennC - 3/6/98.
                    goto Exit;
                }

                EnterCriticalSection(&g_QueueCS);
                g_MainQueueCount--;
                LeaveCriticalSection(&g_QueueCS);

                break;

            case WAIT_TIMEOUT:
                //
                // Let us exit the function this time around. We will catch the
                // timed out element the next time around
                //
                return ERROR_SUCCESS;
        }
    }

    //
    // safe to make a call since you are not dependent on anyone
    //

    DYNREG_F1( "DynDnsRegisterEntries - Got an element to process!" );

    pszName = pQElement->pszName;
    fDoForward = pQElement->fDoForward;
    HostAddr = pQElement->HostAddr;
    dwOperation = pQElement->dwOperation;
    dwTTL = pQElement->dwTTL;
    pfnDhcpCallBack = pQElement->pfnDhcpCallBack;
    pvData = pQElement->pvData;

    if ( dwOperation == DYNDNS_ADD_ENTRY )
    {
        //
        // make the appropriate API call to add an entry
        //

        if (pQElement->fDoForwardOnly )
        {
            DYNREG_F1( "DynDnsRegisterEntries - Calling DynDnsAddForward" );
            status = DynDnsAddForward ( HostAddr,
                                         pszName,
                                         dwTTL,
                                         pQElement->DnsServerList );
            DYNREG_F2( "DynDnsRegisterEntries - DynDnsAddForward returned status: 0%x", status );
        }
        else
        {
            DYNREG_F1( "DynDnsRegisterEntries - Calling DynDnsAddEntry" );
            status = DynDnsAddEntry( HostAddr,
                                      pszName,
                                      dwTTL,
                                      fDoForward,
                                      &dwFwdAddErrCode,
                                      pQElement->DnsServerList );
            DYNREG_F2( "DynDnsRegisterEntries - DynDnsAddEntry returned status: 0%x", status );
        }
    }
    else
    {
        //
        // make the appropriate call to delete here
        //

        if ( pQElement->fDoForwardOnly )
        {
            DNS_RECORD record;

            RtlZeroMemory( &record, sizeof(DNS_RECORD) );

            record.pName = (PCHAR)pszName;
            record.wType = DNS_TYPE_A;
            record.wDataLength = sizeof(DNS_A_DATA);
            record.Data.A.IpAddress = HostAddr.Addr.ipAddr ;

            status = DNS_ERROR_RCODE_NO_ERROR;

            DYNREG_F1( "DynDnsRegisterEntries - Calling ModifyRecords(Remove)" );

            dwFwdAddErrCode = DnsModifyRecordsInSet_W(
                                    NULL,           // no add records
                                    & record,       // delete record
                                    DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                                    NULL,           // no security context
                                    (PIP4_ARRAY) pQElement->DnsServerList,
                                    NULL            // reserved
                                    );
    
            DYNREG_F2( "DynDnsRegisterEntries - ModifyRecords(Remove) returned status: 0%x", dwFwdAddErrCode );
        }
        else
        {
            DYNREG_F1( "DynDnsRegisterEntries - Calling DynDnsDeleteEntry" );
            status = DynDnsDeleteEntry( HostAddr,
                                         pszName,
                                         fDoForward,
                                         &dwFwdAddErrCode,
                                         pQElement->DnsServerList );
            DYNREG_F2( "DynDnsRegisterEntries - DynDnsDeleteEntry returned status: 0%x", status );
        }
    }

    if (status == DNS_ERROR_RCODE_NO_ERROR &&
        dwFwdAddErrCode == DNS_ERROR_RCODE_NO_ERROR )
    {
        if ( pfnDhcpCallBack )
            (*pfnDhcpCallBack) (DNSDHCP_SUCCESS, pvData);

        if ( pQElement )
        {
            if ( pQElement->pszName )
                QUEUE_FREE_HEAP( pQElement->pszName );

            QUEUE_FREE_HEAP( pQElement );
        }

    }
    else if ( status == DNS_ERROR_RCODE_NO_ERROR &&
              dwFwdAddErrCode != DNS_ERROR_RCODE_NO_ERROR )
    {
        //
        // adding reverse succeeded but adding forward failed
        //

        DWORD dwCurrTime = Dns_GetCurrentTimeInSeconds();

        pQElement->fDoForwardOnly = TRUE;

        if ( pQElement->dwRetryCount >= MAX_RETRIES )
        {
            //
            // clean up pQElement and stop retrying
            //
            if ( pfnDhcpCallBack )
                (*pfnDhcpCallBack)(DNSDHCP_FWD_FAILED, pvData);

            if ( pQElement->pszName )
                QUEUE_FREE_HEAP( pQElement->pszName );

            QUEUE_FREE_HEAP( pQElement );

            status = ERROR_SUCCESS;
            goto Exit;
        }

        //
        // we may need to retry this guy later
        //

        switch ( dwFwdAddErrCode )
        {
            case DNS_ERROR_RCODE_SERVER_FAILURE:

                status = AddToTimedOutQueue(
                              pQElement,
                              g_pTimedOutQueue,
                              dwCurrTime + RETRY_TIME_SERVER_FAILURE );
                break;

            case DNS_ERROR_TRY_AGAIN_LATER:

                status = AddToTimedOutQueue(
                              pQElement,
                              g_pTimedOutQueue,
                              dwCurrTime + RETRY_TIME_TRY_AGAIN_LATER );
                break;

            case ERROR_TIMEOUT:

                status = AddToTimedOutQueue(
                              pQElement,
                              g_pTimedOutQueue,
                              dwCurrTime + RETRY_TIME_TIMEOUT );
                break;

            default:

                //
                // different kind of error on attempting to add forward.
                // like connection refused etc.
                // call the callback to indicate that you failed on
                // forward only

                if ( pQElement )
                {
                    if ( pQElement->pszName )
                        QUEUE_FREE_HEAP( pQElement->pszName );

                    QUEUE_FREE_HEAP( pQElement );
                }

                if ( pfnDhcpCallBack )
                    (*pfnDhcpCallBack)(DNSDHCP_FWD_FAILED, pvData);
        }
    }
    else if ( status != DNS_ERROR_RCODE_NO_ERROR &&
              dwFwdAddErrCode == DNS_ERROR_RCODE_NO_ERROR )
    {
        //
        // adding forward succeeded but adding reverse failed
        //

        DWORD dwCurrTime = Dns_GetCurrentTimeInSeconds();

        pQElement->fDoForwardOnly = FALSE;
        pQElement->fDoForward = FALSE;

        if ( pQElement->dwRetryCount >= MAX_RETRIES )
        {
            //
            // clean up pQElement and stop retrying
            //
            if ( pfnDhcpCallBack )
                (*pfnDhcpCallBack)(DNSDHCP_FAILURE, pvData);

            if ( pQElement->pszName )
                QUEUE_FREE_HEAP( pQElement->pszName );

            QUEUE_FREE_HEAP( pQElement );

            status = ERROR_SUCCESS;
            goto Exit;
        }

        //
        // we may need to retry this guy later
        //

        switch ( status )
        {
            case DNS_ERROR_RCODE_SERVER_FAILURE:

                status = AddToTimedOutQueue(
                              pQElement,
                              g_pTimedOutQueue,
                              dwCurrTime + RETRY_TIME_SERVER_FAILURE );
                break;

            case DNS_ERROR_TRY_AGAIN_LATER:

                status = AddToTimedOutQueue(
                              pQElement,
                              g_pTimedOutQueue,
                              dwCurrTime + RETRY_TIME_TRY_AGAIN_LATER );
                break;

            case ERROR_TIMEOUT:

                status = AddToTimedOutQueue(
                              pQElement,
                              g_pTimedOutQueue,
                              dwCurrTime + RETRY_TIME_TIMEOUT );
                break;

            default:

                //
                // different kind of error on attempting to add forward.
                // like connection refused etc.
                // call the callback to indicate that you at least succeeded
                // with the forward registration

                if ( pQElement )
                {
                    if ( pQElement->pszName )
                        QUEUE_FREE_HEAP( pQElement->pszName );

                    QUEUE_FREE_HEAP( pQElement );
                }

                if ( pfnDhcpCallBack )
                    (*pfnDhcpCallBack)(DNSDHCP_FAILURE, pvData);
        }
    }
    else if (status == DNS_ERROR_RCODE_SERVER_FAILURE ||
             status == DNS_ERROR_TRY_AGAIN_LATER ||
             status == ERROR_TIMEOUT )
    {
        //
        // we need to retry this guy later
        //
        DWORD dwCurrTime = Dns_GetCurrentTimeInSeconds();

        switch (status)
        {
            case DNS_ERROR_RCODE_SERVER_FAILURE:

                status = AddToTimedOutQueue(
                              pQElement,
                              g_pTimedOutQueue,
                              dwCurrTime + RETRY_TIME_SERVER_FAILURE );
                break;

            case DNS_ERROR_TRY_AGAIN_LATER:

                status = AddToTimedOutQueue(
                              pQElement,
                              g_pTimedOutQueue,
                              dwCurrTime + RETRY_TIME_TRY_AGAIN_LATER );
                break;

            case ERROR_TIMEOUT:

                status = AddToTimedOutQueue(
                              pQElement,
                              g_pTimedOutQueue,
                              dwCurrTime + RETRY_TIME_TIMEOUT );
                break;
        }
    }
    else
    {
        //
        // a different kind of error, really nothing can be done
        // free memory and get the hell out
        // call the callback to say that registration failed
        //

        if ( pQElement )
        {
            if ( pQElement->pszName )
                QUEUE_FREE_HEAP( pQElement->pszName );

            QUEUE_FREE_HEAP( pQElement );
        }

        if ( pfnDhcpCallBack )
            (*pfnDhcpCallBack)(DNSDHCP_FAILURE, pvData);
    }

Exit:

    return( status);
}


//
//  Main registration thread
//

VOID
DynDnsConsumerThread(
    VOID
    )
{
    DWORD dwRetval;

    DYNREG_F1( "Inside function DynDnsConsumerThread" );

    while ( ! g_fStopNotify )
    {
        dwRetval = DynDnsRegisterEntries();

        if ( !dwRetval )
        {
            //
            //  Ram note: get Munil/Ramesh to implement call back function
            //
        }
    }

    //
    // you have been asked to exit
    //

    FreeQueue( g_pdnsQueue );
    g_pdnsQueue = NULL;

    EnterCriticalSection(&g_QueueCS);
    g_MainQueueCount = 0;
    LeaveCriticalSection(&g_QueueCS);

    FreeQueue( g_pTimedOutQueue );
    g_pTimedOutQueue = NULL;
    ExitThread(0); // This sets the handle in the waitforsingleobject for

    //
    // the termination function
    //
}


//
//  Init\Cleanup routines
//

VOID
CommonDynRegCleanup(
    VOID
    )
/*++

Routine Description:

    Common cleanup between failed init and terminate.

    Function exists just to kill off common code.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  common cleanup
    //      - semaphore
    //      - event
    //      - security credential info

    if ( hSem )
    {
        CloseHandle( hSem );
        hSem = NULL;
    }

    if ( hQuitEvent )
    {
        CloseHandle( hQuitEvent );
        hQuitEvent = NULL;
    }

    if ( g_pIdentityCreds )
    {
        Dns_FreeAuthIdentityCredentials( g_pIdentityCreds );
        g_pIdentityCreds = NULL;
    }

    if ( g_UpdateCredContext )
    {
        DnsReleaseContextHandle( g_UpdateCredContext );
        g_UpdateCredContext = NULL;
    }
}


DNS_STATUS
WINAPI
DnsDhcpSrvRegisterInitialize(
    IN      PDNS_CREDENTIALS    pCredentials
    )
/*++

Routine Description:

    Initialize DHCP server DNS registration.

Arguments:

    pCredentials -- credentials to do registrations under (if any)

Return Value:

    DNS or Win32 error code.

--*/
{
    INT                     i;
    DWORD                   threadId;
    DNS_STATUS              status;

    //
    //  init globals
    //      - also init debug logging
    //

    DYNREG_INIT();

    DNS_ASSERT(!hQuitEvent && !hSem);

    g_fStopNotify = FALSE;

    if ( !( hQuitEvent = CreateEvent( NULL, TRUE, FALSE, NULL ) ) )
    {
        status = GetLastError();
        goto Exit;
    }

    if ( ! ( hSem = CreateSemaphore( NULL, 0, MAX_QLEN, NULL ) ) )
    {
        status = GetLastError();
        goto Exit;
    }

    handle[0]= hQuitEvent;
    handle[1]= hSem;

    Dns_InitializeSecondsTimer();

    status = InitializeQueues( &g_pdnsQueue, &g_pTimedOutQueue );
    if ( status != NO_ERROR )
    {
        g_pdnsQueue = NULL;
        g_pTimedOutQueue = NULL;
        goto Exit;
    }

    EnterCriticalSection(&g_QueueCS);
    g_MainQueueCount = 0;
    LeaveCriticalSection(&g_QueueCS);

    //
    //  have creds?
    //      - create global credentials
    //      - acquire a valid SSPI handle using these creds
    //
    //  DCR:  global cred handle not MT safe
    //      here we are in the DHCP server process and don't have
    //      any reason to use another update context;  but if
    //      shared with some other service this breaks
    //
    //      fix should be to have separate
    //          - creds
    //          - cred handle
    //      that is kept here (not cached) and pushed down
    //      on each update call
    //

    if ( pCredentials )
    {
        DNS_ASSERT( g_pIdentityCreds == NULL );

        g_pIdentityCreds = Dns_AllocateCredentials(
                                pCredentials->pUserName,
                                pCredentials->pDomain,
                                pCredentials->pPassword );
        if ( !g_pIdentityCreds )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Exit;
        }

        //  DCR:  this won't work if creds will expire
        //      but it seems like they autorefresh

        status = Dns_StartSecurity(
                    FALSE       // not process attach
                    );
        if ( status != NO_ERROR )
        {
            status = ERROR_CANNOT_IMPERSONATE;
            goto Exit;
        }

        status = Dns_RefreshSSpiCredentialsHandle(
                    FALSE,                      // client
                    (PCHAR) g_pIdentityCreds    // creds
                    );
        if ( status != NO_ERROR )
        {
            status = ERROR_CANNOT_IMPERSONATE;
            goto Exit;
        }
#if 0
        DNS_ASSERT( g_UpdateCredContext == NULL );

        status = DnsAcquireContextHandle_W(
                    0,                      // flags
                    g_pIdentityCreds,        // creds
                    & g_UpdateCredContext   // set handle
                    );
        if ( status != NO_ERROR )
        {
            goto Exit;
        }
#endif
    }

    //
    //  fire up registration thread
    //      - pass creds as start param
    //      - if thread start fails, free creds
    //

    hConsumerThread = CreateThread(
                          NULL,
                          0,
                          (LPTHREAD_START_ROUTINE)DynDnsConsumerThread,
                          NULL,
                          0,
                          &threadId );

    if ( hConsumerThread == NULL )
    {
        status = GetLastError();
        goto Exit;
    }

Exit:

    //
    //  if failed, clean up globals
    //

    if ( status != NO_ERROR &&
         status != ERROR_CANNOT_IMPERSONATE )
    {
        if ( g_pdnsQueue )
        {
            FreeQueue( g_pdnsQueue );
            g_pdnsQueue = NULL;
        }

        if ( g_pTimedOutQueue )
        {
            FreeQueue(g_pTimedOutQueue);
            g_pTimedOutQueue = NULL;
        }

        EnterCriticalSection(&g_QueueCS);
        g_MainQueueCount = 0;
        LeaveCriticalSection(&g_QueueCS);

        //  global cleanup
        //      - shared between failure case here and term function

        CommonDynRegCleanup();
    }

    return  status;
}


DNS_STATUS
WINAPI
DnsDhcpSrvRegisterInit(
    VOID
    )
/*++

Routine Description:

    Backward compatibility stub to above function.

Arguments:

    None.

Return Value:

    DNS or Win32 error code.

--*/
{
    return  DnsDhcpSrvRegisterInitialize( NULL );
}



DNS_STATUS
WINAPI
DnsDhcpSrvRegisterTerm(
   VOID
   )
/*++

Routine Description:

    Initialization routine each process should call exactly on exit after
    using DnsDhcpSrvRegisterHostAddrs. This will signal to us that if our
    thread is still trying to talk to a server, we'll stop trying.

Arguments:

    None.

Return Value:

    DNS or Win32 error code.

--*/
{
    BOOL    fRet;
    DWORD   dwRetval = ERROR_SUCCESS;
    DWORD   dwWaitResult;

    DYNREG_F1( "Inside function DnsDhcpSrvRegisterTerm" );

    //
    // Need to notify Consumer Thread that he is getting thrown
    // out and clean up after him. Send an event after him
    //

    g_fStopNotify = TRUE;

    fRet = SetEvent( hQuitEvent );

    dwWaitResult = WaitForSingleObject( hConsumerThread, INFINITE );

    switch (dwWaitResult)
    {
        case WAIT_OBJECT_0:
            //
            // client thread terminated
            //
            CloseHandle(hConsumerThread);
            hConsumerThread = NULL;
            break;

        case WAIT_TIMEOUT:
            if ( hConsumerThread )
            {
                //
                // Why hasn't this thread stopped?
                //
                DYNREG_F1( "DNSAPI: DHCP Server DNS registration thread won't stop!" );
                DNS_ASSERT( FALSE );
            }
    }

    //
    //  cleanup globals
    //      - event
    //      - semaphore
    //      - update security cred info
    //

    CommonDynRegCleanup();

    //
    // Blow away any cached security context handles
    //
    //  DCR:  security context dump is not multi-service safe
    //      should have this cleanup just the context's associated
    //      with DHCP server service;
    //      either need some key or use cred handle
    //

    Dns_TimeoutSecurityContextList( TRUE );

    return dwRetval;
}



DNS_STATUS
WINAPI
DnsDhcpSrvRegisterHostName(
    IN  REGISTER_HOST_ENTRY HostAddr,
    IN  PWSTR               pwsName,
    IN  DWORD               dwTTL,
    IN  DWORD               dwFlags, // An entry you want to blow away
    IN  DHCP_CALLBACK_FN    pfnDhcpCallBack,
    IN  PVOID               pvData,
    IN  PIP_ADDRESS         pipDnsServerList,
    IN  DWORD               dwDnsServerCount
    )
/*++

  DnsDhcpSrvRegisterHostName()

    The main DHCP registration thread calls this function each time a
    registration needs to be done.

    Brief Synopsis of the working of this function

    This function creates a queue object of the type given in queue.c
    and enqueues the appropriate object after grabbing hold of the
    critical section.

  Arguments:

     HostAddr  ---  The Host Addr you wish to register
     pszName   ---  The Host Name to be associated with the address
     dwTTL     ---   Time to Live.
     dwOperation    --   The following flags are valid

     DYNDNS_DELETE_ENTRY -- Delete the entry being referred to.
     DYNDNS_ADD_ENTRY    -- Register the new entry.
     DYNDNS_REG_FORWARD  -- Register the forward as well

  Return Value:

  is 0 if Success. and (DWORD)-1 if failure.

--*/
{
    PQELEMENT  pQElement = NULL;
    DWORD      status = ERROR_SUCCESS;
    BOOL fSem = FALSE;
    BOOL fRegForward =  dwFlags & DYNDNS_REG_FORWARD ? TRUE: FALSE ;

    DYNREG_F1( "Inside function DnsDhcpSrvRegisterHostName_W" );

    // RAMNOTE:  parameter checking on queuing

    if ( g_fStopNotify ||
         ! g_pTimedOutQueue ||
         ! g_pdnsQueue )
    {
        DYNREG_F1( "g_fStopNotify || ! g_pTimedOutQueue || ! g_pdnsQueue" );
        DYNREG_F1( "DnsDhcpSrvRegisterHostName_W - Returning ERROR_INVALID_PARAMETER" );
        return ERROR_INVALID_PARAMETER;
    }

    if ( !(dwFlags & DYNDNS_DELETE_ENTRY) && ( !pwsName || !*pwsName ) )
    {
        DYNREG_F1( "!(dwFlags & DYNDNS_DELETE_ENTRY) && ( !pwsName || !*pwsName )" );
        DYNREG_F1( "DnsDhcpSrvRegisterHostName_W - Returning ERROR_INVALID_PARAMETER" );
        //
        // Null parameter for name can be specified only when operation
        // is to do a delete
        //
        return ERROR_INVALID_PARAMETER;
    }

    if ( ! (dwFlags & DYNDNS_ADD_ENTRY || dwFlags & DYNDNS_DELETE_ENTRY ) )
    {
        DYNREG_F1( "! (dwFlags & DYNDNS_ADD_ENTRY || dwFlags & DYNDNS_DELETE_ENTRY )" );
        DYNREG_F1( "DnsDhcpSrvRegisterHostName_W - Returning ERROR_INVALID_PARAMETER" );
        return ERROR_INVALID_PARAMETER;
    }

    if ( (dwFlags & DYNDNS_DELETE_ENTRY) && (dwFlags & DYNDNS_ADD_ENTRY) )
    {
        DYNREG_F1( "(dwFlags & DYNDNS_DELETE_ENTRY) && (dwFlags & DYNDNS_ADD_ENTRY)" );
        DYNREG_F1( "DnsDhcpSrvRegisterHostName_W - Returning ERROR_INVALID_PARAMETER" );
        //
        // you cant ask me to both add and delete an entry
        //
        return ERROR_INVALID_PARAMETER;
    }

    if ( ! (HostAddr.dwOptions & REGISTER_HOST_PTR) )
    {
        DYNREG_F1( "! (HostAddr.dwOptions & REGISTER_HOST_PTR)" );
        DYNREG_F1( "DnsDhcpSrvRegisterHostName_W - Returning ERROR_INVALID_PARAMETER" );
        return ERROR_INVALID_PARAMETER;
    }

    if ( g_MainQueueCount > DNS_MAX_DHCP_SERVER_REGISTRATION_QUEUE_SIZE )
    {
        return DNS_ERROR_TRY_AGAIN_LATER;
    }

    //
    // create a queue element.
    //

    pQElement = (PQELEMENT) QUEUE_ALLOC_HEAP_ZERO(sizeof(QELEMENT) );

    if ( !pQElement )
    {
        DYNREG_F1( "DnsDhcpSrvRegisterHostName_W - Failed to create element!" );
        status = DNS_ERROR_NO_MEMORY;
        goto Exit;
    }

    memcpy(&(pQElement->HostAddr), &HostAddr, sizeof(REGISTER_HOST_ENTRY));

    pQElement->pszName = NULL;

    if ( pwsName )
    {
        pQElement->pszName = (LPWSTR) QUEUE_ALLOC_HEAP_ZERO(wcslen(pwsName)*2+ 2 );

        if ( !pQElement->pszName )
        {
            DYNREG_F1( "DnsDhcpSrvRegisterHostName_W - Failed to allocate name buffer!" );
            status = DNS_ERROR_NO_MEMORY;
            goto Exit;
        }

        wcscpy(pQElement->pszName, pwsName);
    }

    if ( dwDnsServerCount )
    {
        pQElement->DnsServerList = Dns_BuildIpArray( dwDnsServerCount,
                                                     pipDnsServerList );

        if ( !pQElement->DnsServerList )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Exit;
        }
    }

    pQElement->dwTTL = dwTTL;
    pQElement->fDoForward = fRegForward;

    //
    // callback function
    //

    pQElement->pfnDhcpCallBack = pfnDhcpCallBack;
    pQElement->pvData = pvData;  // parameter to callback function

    if (dwFlags & DYNDNS_ADD_ENTRY)
        pQElement->dwOperation = DYNDNS_ADD_ENTRY;
    else
        pQElement->dwOperation = DYNDNS_DELETE_ENTRY;

    //
    // Set all the other fields to NULLs
    //

    pQElement->dwRetryTime = 0;
    pQElement->pFLink = NULL;
    pQElement->pBLink = NULL;
    pQElement ->fDoForwardOnly = FALSE;

    //
    // put this element in the queue
    //

    DYNREG_F1( "DnsDhcpSrvRegisterHostName_W - Put queue element in list" );

    status = Enqueue ( pQElement, g_pdnsQueue, g_pTimedOutQueue);

    //
    // FYI: Count of main queue elements is incremented inside Enqueue()
    //

    if (status)
    {
        DYNREG_F1( "DnsDhcpSrvRegisterHostName_W - Failed to queue element in list!" );
        goto Exit;
    }

    //
    // Signal the semaphore the consumer may be waiting on
    //

    fSem = ReleaseSemaphore( hSem,
                             1,
                             &g_dwQCount );

    if ( !fSem )
    {
        DNS_ASSERT( fSem );  // assert and say that something weird happened
    }

    return(status);

Exit:

    if ( status )
    {
        //
        // something failed. Free all alloc'd memory
        //

        if ( pQElement )
        {
            if ( pQElement->pszName )
                QUEUE_FREE_HEAP( pQElement->pszName );

            QUEUE_FREE_HEAP( pQElement );
        }
    }

    return( status );
}


//
//  End dynreg.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\hostfile.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    hostfile.c

Abstract:

    Read host file data.

Author:

    Jim Gilroy (jamesg)     October 2000

Revision History:

--*/


#include "local.h"

//  sockreg.h includes "etc" directory file opens
//  sockreg.h is NT file so must define NTSTATUS first

#ifndef NTSTATUS
#define NTSTATUS LONG
#endif

#include <sockreg.h>

//
//  Host file defs
//  Note, HOST_FILE_INFO blob defined in dnsapip.h
//

#define HOST_FILE_PATH_LENGTH  (MAX_PATH + sizeof("\\hosts") + 1)

//
//  Host file record TTL
//      (use a week)
//

#define HOSTFILE_RECORD_TTL  (604800)




BOOL
Dns_OpenHostFile(
    IN OUT  PHOST_FILE_INFO pHostInfo
    )
/*++

Routine Description:

    Open hosts file or rewind existing file to beginning.

Arguments:

    pHostInfo - ptr to host info;

        hFile - must be NULL if file not previously opened
            otherwise hFile is assumed to be existing FILE pointer

        pszFileName - NULL to open "hosts" file
            otherwise is name of file to open

Return Value:

    None.

--*/
{
    CHAR    hostFileNameBuffer[ HOST_FILE_PATH_LENGTH ];

    DNSDBG( TRACE, (
        "Dns_OpenHostFile()\n" ));

    //
    //  open host file OR rewind if already open
    //

    if ( pHostInfo->hFile == NULL )
    {
        PSTR  pnameFile = pHostInfo->pszFileName;

        if ( !pnameFile )
        {
            pnameFile = "hosts";
        }

        pHostInfo->hFile = SockOpenNetworkDataBase(
                                pnameFile,
                                hostFileNameBuffer,
                                HOST_FILE_PATH_LENGTH,
                                "r" );
    }
    else
    {
        rewind( pHostInfo->hFile );
    }

    return ( pHostInfo->hFile ? TRUE : FALSE );
}



VOID
Dns_CloseHostFile(
    IN OUT  PHOST_FILE_INFO pHostInfo
    )
/*++

Routine Description:

    Close hosts file.

Arguments:

    pHostInfo -- ptr to host info;  hFile assumed to contain file pointer

Return Value:

    None.

--*/
{
    DNSDBG( TRACE, (
        "Dns_CloseHostFile()\n" ));

    if ( pHostInfo->hFile )
    {
        fclose( pHostInfo->hFile );
        pHostInfo->hFile = NULL;
    }
}



VOID
BuildHostfileRecords(
    IN OUT  PHOST_FILE_INFO pHostInfo
    )
/*++

Routine Description:

    Build records from hostfile line.

Arguments:

    pHostInfo -- ptr to host info

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    DNS_LIST    aliasList;
    PCHAR *     paliasEntry;
    PCHAR       palias;
    PDNS_RECORD prr;

    DNSDBG( TRACE, (
        "BuildHostfileRecords()\n" ));

    //
    //  create all the records
    //      - A or AAAA for name
    //      - CNAMEs for aliases
    //      - PTR
    //
    //  for hosts file records
    //      - section == ANSWER
    //      - hostsfile flag set
    //

    prr = Dns_CreateForwardRecord(
                pHostInfo->pHostName,
                & pHostInfo->Ip,
                HOSTFILE_RECORD_TTL,
                DnsCharSetAnsi,
                DnsCharSetUnicode );

    pHostInfo->pForwardRR = prr;
    if ( prr )
    {
        SET_RR_HOSTS_FILE( prr );
        prr->Flags.S.Section = DnsSectionAnswer;
    }

    //
    //  build aliases into list of CNAME records
    //      - append forward lookup answer with each CNAME  
    //

    DNS_LIST_STRUCT_INIT( aliasList );

    for( paliasEntry = pHostInfo->AliasArray;
         palias = *paliasEntry;
         paliasEntry++ )
    {
        PDNS_RECORD prrForward = pHostInfo->pForwardRR;
        PDNS_RECORD prrAnswer;

        DNSDBG( INIT, (
            "Building for alias %s for hostname %s\n",
            palias,
            pHostInfo->pHostName ));

        prr = Dns_CreatePtrTypeRecord(
                    palias,
                    TRUE,           // make name copy
                    pHostInfo->pHostName,
                    DNS_TYPE_CNAME,
                    HOSTFILE_RECORD_TTL,
                    DnsCharSetAnsi,
                    DnsCharSetUnicode );
        if ( prr )
        {
            SET_RR_HOSTS_FILE( prr );
            prr->Flags.S.Section = DnsSectionAnswer;
            DNS_LIST_STRUCT_ADD( aliasList, prr );

            //  append forward record

            if ( prrForward &&
                 (prrAnswer = Dns_RecordCopy_W(prrForward)) )
            {
                DNS_LIST_STRUCT_ADD( aliasList, prrAnswer );
            }
        }
    }

    pHostInfo->pAliasRR = aliasList.pFirst;

    //
    //  PTR points only to name
    //

    prr = Dns_CreatePtrRecordEx(
                & pHostInfo->Ip,
                pHostInfo->pHostName,   // target name
                HOSTFILE_RECORD_TTL,
                DnsCharSetAnsi,
                DnsCharSetUnicode );

    pHostInfo->pReverseRR = prr;
    if ( prr )
    {
        SET_RR_HOSTS_FILE( prr );
        prr->Flags.S.Section = DnsSectionAnswer;
    }

    IF_DNSDBG( QUERY )
    {
        DnsDbg_RecordSet(
            "HostFile forward record:",
            pHostInfo->pForwardRR );

        DnsDbg_RecordSet(
            "HostFile reverse record:",
            pHostInfo->pReverseRR );

        if ( pHostInfo->pAliasRR )
        {
            DnsDbg_RecordSet(
                "HostFile alias records:",
                pHostInfo->pAliasRR );
        }
    }
}



BOOL
TokenizeHostFileLine(
    IN OUT  PHOST_FILE_INFO pHostInfo
    )
/*++

Routine Description:

    Reads an entry from hosts file.

Arguments:

    pHostInfo -- ptr to host info;
        if hFile is NULL, first attempts host file open
        other fields are filled with info from next hostfile line

Return Value:

    TRUE if successfully tokenized line.
    FALSE on empty or bad line

--*/
{
    PCHAR       pch;
    PCHAR       ptoken;
    DWORD       countAlias = 0;
    DWORD       count = 0;

    DNSDBG( TRACE, ( "TokenizeHostFileLine()\n" ));

    //
    //  tokenize line
    //

    pch = pHostInfo->HostLineBuf;

    while( pch )
    {
        //  strip leading whitespace

        while( *pch == ' ' || *pch == '\t' )
        {
            pch++;
        }
        ptoken = pch;

        //
        //  NULL terminate token
        //      - NULL pch serves as signal to stop after this token
        //

        pch = strpbrk( pch, " \t#\n\r" );
        if ( pch != NULL )
        {
            //  empty (zero-length) token => done now

            if ( pch == ptoken )
            {
                break;
            }

            //  terminated by whitespace -- may be another token

            if ( *pch == ' ' || *pch == '\t' )
            {
                *pch++ = '\0';
            }

            //  terminated by EOL -- no more tokens

            else    // #\r\n
            {
                *pch = '\0';
                pch = NULL;
            }
        }
        count++;

        //
        //  save address, name or alias
        //

        if ( count == 1 )
        {
            pHostInfo->pAddrString = ptoken;
        }
        else if ( count == 2 )
        {
            pHostInfo->pHostName = ptoken;
        }
        else
        {
            if ( countAlias >= MAXALIASES )
            {
                break;
            }
            pHostInfo->AliasArray[ countAlias++ ] = ptoken;
        }
    }

    //  NULL terminate alias array

    pHostInfo->AliasArray[ countAlias ] = NULL;

    IF_DNSDBG( INIT )
    {
        if ( count >= 2 )
        {
            PSTR    palias;

            DnsDbg_Printf(
                "Parsed host file line:\n"
                "\tAddress  = %s\n"
                "\tHostname = %s\n",
                pHostInfo->pAddrString,
                pHostInfo->pHostName );

            countAlias = 0;
            while ( palias = pHostInfo->AliasArray[countAlias] )
            {
                DnsDbg_Printf(
                    "\tAlias    = %s\n",
                    palias );
                countAlias++;
            }
        }
    }

    return( count >= 2 );
}



BOOL
Dns_ReadHostFileLine(
    IN OUT  PHOST_FILE_INFO pHostInfo
    )
/*++

Routine Description:

    Reads an entry from hosts file.

Arguments:

    pHostInfo -- ptr to host info;
        if hFile is NULL, first attempts host file open
        other fields are filled with info from next hostfile line

Return Value:

    TRUE if successfully reads a host entry.
    FALSE if on EOF or no hosts file found.

--*/
{
    IP4_ADDRESS         ip4;
    DNS_IP6_ADDRESS     ip6;

    DNSDBG( TRACE, (
        "Dns_ReadHostFileLine()\n" ));

    //
    //  open hosts file if not open
    //

    if ( pHostInfo->hFile == NULL )
    {
        Dns_OpenHostFile( pHostInfo );
        if ( pHostInfo->hFile == NULL )
        {
            return  FALSE;
        }
    }

    //
    //  loop until successfully read IP address
    //

    while( 1 )
    {
        //  setup for next line

        pHostInfo->pForwardRR   = NULL;
        pHostInfo->pReverseRR   = NULL;
        pHostInfo->pAliasRR     = NULL;

        //  read line, quit on EOF

        if ( ! fgets(
                    pHostInfo->HostLineBuf,
                    sizeof(pHostInfo->HostLineBuf) - 1,
                    pHostInfo->hFile ) )
        {
            return FALSE;
        }

        //  tokenize line

        if ( !TokenizeHostFileLine( pHostInfo ) )
        {
            continue;
        }

        //
        //  read address
        //      - try IP4
        //      - try IP6
        //      - otherwise skip
        //
    
        ip4 = inet_addr( pHostInfo->pAddrString );

        if ( ip4 != INADDR_NONE ||
             _strnicmp( "255.255.255.255", pHostInfo->pAddrString, 15 ) == 0 )
        {
            IPUNION_SET_IP4( &pHostInfo->Ip, ip4 );
            break;
        }

        //  not valid IP4 -- check IP6

        if ( Dns_Ip6StringToAddress_A(
                & ip6,
                pHostInfo->pAddrString
                ) )
        {
            IPUNION_SET_IP6( &pHostInfo->Ip, ip6 );
            break;
        }

        //  invalid address, ignore line

        DNSDBG( INIT, (
            "Error parsing host file address %s\n",
            pHostInfo->pAddrString ));
        continue;
    }

    //
    //  build records for line if desired
    //

    if ( pHostInfo->fBuildRecords )
    {
        BuildHostfileRecords( pHostInfo );
    }

    return TRUE;
}



BOOL
QueryHostFile(
    IN OUT  PQUERY_BLOB         pBlob
    )
/*++

Routine Description:

    Lookup query in host file.

Arguments:

Return Value:

    TRUE if found host file entry.
    FALSE otherwise.

--*/
{
    HOST_FILE_INFO  hostInfo;
    BOOL            fip6 = FALSE;
    BOOL            fptr = FALSE;
    IP_UNION        ipUnion;
    WORD            wtype;
    WORD            buildType;
    PCHAR           pcnameHost = NULL;
    PDNS_RECORD     prrAlias = NULL;
    PDNS_RECORD     prr = NULL;
    DNS_LIST        forwardList;
    DWORD           bufLength;
    PSTR            pnameAnsi = (PCHAR) pBlob->NameBufferWide;


    DNSDBG( INIT, ( "QueryHostFile()\n" ));

    //
    //  determine if host file type
    //

    wtype = pBlob->wType;

    if ( wtype == DNS_TYPE_A ||
         wtype == DNS_TYPE_PTR ||
         wtype == DNS_TYPE_ALL )
    {
        // no op
    }
    else if ( wtype == DNS_TYPE_AAAA )
    {
        fip6 = TRUE;
    }
    else
    {
        return  FALSE;
    }

    //
    //  open hosts file -- if fails, we're done
    //

    RtlZeroMemory(
        &hostInfo,
        sizeof(hostInfo) );

    if ( !Dns_OpenHostFile( &hostInfo ) )
    {
        return( FALSE );
    }

    //
    //  convert name to ANSI
    //      - validate and select IP4\IP6 for PTR
    //

    bufLength = DNS_MAX_NAME_BUFFER_LENGTH;

    if ( ! Dns_NameCopy(
                pnameAnsi,
                & bufLength,
                pBlob->pNameWire,
                0,
                DnsCharSetWire,
                DnsCharSetAnsi ) )
    {
        goto Cleanup;
    }

    //
    //  reverse name check
    //      - validate and select IP 4\6
    //      - PTR lookup MUST be valid reverse name
    //      - ALL may be reverse name
    //

    if ( wtype == DNS_TYPE_PTR ||
         wtype == DNS_TYPE_ALL )
    {
        DWORD   bufferLength = sizeof(IP6_ADDRESS);
        BOOL    family = 0;

        if ( Dns_ReverseNameToAddress_A(
                (PCHAR) & ipUnion.Addr,
                & bufferLength,
                pnameAnsi,
                & family        // either address type
                ) )
        {
            fptr = TRUE;
            ipUnion.IsIp6 = (family == AF_INET6);
        }
        else if ( wtype == DNS_TYPE_PTR )
        {
            //  bad reverse name
            goto Cleanup;
        }
    }

    //
    //  forward build type
    //      - matches query type
    //      - EXCEPT all which currently builds
    //          AAAA for IP6, A for IP4
    //

    if ( !fptr )
    {
        buildType = wtype;
        DNS_LIST_STRUCT_INIT( forwardList );
    }

    //
    //  read entries from host file until exhausted
    //      - cache A record for each name and alias
    //      - cache PTR to name
    //

    while ( Dns_ReadHostFileLine( &hostInfo ) )
    {
        //
        //  reverse
        //      - match IP
        //      - success is terminal as reverse mapping is one-to-one
        //
        //  DCR_QUESTION:  parse hosts for multiple reverse mappings?
        //

        if ( fptr )
        {
            //  DCR:  extract as genericIP comparison

            if ( ! Dns_EqualIpUnion( &ipUnion, &hostInfo.Ip ) )
            {
                continue;
            }

            //  create RR
            //      - don't need to use IP conversion version
            //      as we already have reverse lookup name

            DNSDBG( QUERY, (
                "Build PTR record for name %s to %s\n",
                pnameAnsi,
                hostInfo.pHostName ));

            prr = Dns_CreatePtrTypeRecord(
                    pnameAnsi,
                    TRUE,       // copy name
                    hostInfo.pHostName,
                    DNS_TYPE_PTR,
                    HOSTFILE_RECORD_TTL,
                    DnsCharSetAnsi,
                    DnsCharSetUnicode );

            if ( !prr )
            {
                SetLastError( DNS_ERROR_NO_MEMORY );
            }
            break;
        }

        //
        //  forward lookup
        //

        else
        {
            PCHAR   pnameHost;

            //  type ALL builds on any match
            //      - build type appropriate for IP
            //
            //  other query types must match address type

            if ( wtype == DNS_TYPE_ALL )
            {
                buildType = IPUNION_IS_IP6(&hostInfo.Ip)
                                ?   DNS_TYPE_AAAA
                                :   DNS_TYPE_A;
            }
            else if ( fip6 != IPUNION_IS_IP6(&hostInfo.Ip) )
            {
                continue;
            }

            //
            //  check name match
            //
            //  DCR:  use unicode name?  or UTF8 name directly

            pnameHost = NULL;

            if ( Dns_NameCompare_A(
                    hostInfo.pHostName,
                    pnameAnsi ) )
            {
                pnameHost = pnameAnsi;
            }

            //
            //  check match to previous CNAME
            //

            else if ( pcnameHost )
            {
                if ( Dns_NameCompare_A(
                        hostInfo.pHostName,
                        pcnameHost ) )
                {
                    pnameHost = pcnameHost;
                }
            }

            //
            //  aliases
            //
            //  DCR_QUESTION:  build aliases even if name hit?
            //
            //  currently:
            //      - don't allow alias if already have direct record
            //      - limit to one alias (CNAME)
            //
            //  if find alias:
            //      - build CNAME record
            //      - save CNAME target (in ANSI for faster compares)
            //      - check CNAME target for subsequent address records (above)
            //

            else if ( IS_DNS_LIST_STRUCT_EMPTY( forwardList )
                        &&
                      !prrAlias )
            {
                PCHAR * paliasEntry;
                PCHAR   palias;

                for( paliasEntry = hostInfo.AliasArray;
                     palias = *paliasEntry;
                     paliasEntry++ )
                {
                    if ( Dns_NameCompare_A(
                            palias,
                            pnameAnsi ) )
                    {
                        DNSDBG( QUERY, (
                            "Build CNAME record for name %s to CNAME %s\n",
                            pnameAnsi,
                            hostInfo.pHostName ));

                        prrAlias = Dns_CreatePtrTypeRecord(
                                        pnameAnsi,
                                        TRUE,       // copy name
                                        hostInfo.pHostName,
                                        DNS_TYPE_CNAME,
                                        HOSTFILE_RECORD_TTL,
                                        DnsCharSetAnsi,
                                        DnsCharSetUnicode );
    
                        if ( prrAlias )
                        {
                            pcnameHost = Dns_NameCopyAllocate(
                                            hostInfo.pHostName,
                                            0,
                                            DnsCharSetAnsi,
                                            DnsCharSetAnsi );

                            pnameHost = pcnameHost;
                        }
                        break;
                    }
                }
            }

            //  add address record for this hostline

            if ( pnameHost )
            {
                DNSDBG( QUERY, (
                    "Build address record for name %s\n",
                    pnameHost ));

                prr = Dns_CreateForwardRecord(
                            pnameHost,
                            & hostInfo.Ip,
                            HOSTFILE_RECORD_TTL,
                            DnsCharSetAnsi,
                            DnsCharSetUnicode );
                if ( prr )
                {
                    DNS_LIST_STRUCT_ADD( forwardList, prr );
                }
            }
        }
    }

    //
    //  build response
    //
    //  DCR:  new multiple section response
    //

    if ( !fptr )
    {
        prr = forwardList.pFirst;
        if ( prrAlias )
        {
            prrAlias->pNext = prr;
            prr = prrAlias;
        }
    }

    IF_DNSDBG( QUERY )
    {
        DnsDbg_RecordSet(
            "HostFile Answers:",
            prr );
    }
    pBlob->pRecords = prr;


Cleanup:

    //
    //  cleanup
    //

    Dns_CloseHostFile( &hostInfo );

    if ( pcnameHost )
    {
        FREE_HEAP( pcnameHost );
    }

    DNSDBG( TRACE, (
        "Leave  QueryHostFile() -> %d\n"
        "\tprr  = %p\n",
        prr ? TRUE : FALSE,
        prr ));

    return( prr ? TRUE : FALSE );
}

//
//  End hostfile.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\export.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    export.c

Abstract:

    Domain Name System (DNS) API

    Covering functions for exported routines that are actually in
    dnslib.lib.

Author:

    Jim Gilroy (jamesg)     November, 1997

Environment:

    User Mode - Win32

Revision History:

--*/

#include "local.h"


//
//  SDK routines
//

//
//  Name comparison
//

BOOL
WINAPI
DnsNameCompare_A(
    IN      LPSTR           pName1,
    IN      LPSTR           pName2
    )
{
    return Dns_NameCompare_A( pName1, pName2 );
}

BOOL
WINAPI
DnsNameCompare_UTF8(
    IN      LPSTR           pName1,
    IN      LPSTR           pName2
    )
{
    return Dns_NameCompare_UTF8( pName1, pName2 );
}

BOOL
WINAPI
DnsNameCompare_W(
    IN      LPWSTR          pName1,
    IN      LPWSTR          pName2
    )
{
    return Dns_NameCompare_W( pName1, pName2 );
}


DNS_NAME_COMPARE_STATUS
DnsNameCompareEx_A(
    IN      LPCSTR          pszLeftName,
    IN      LPCSTR          pszRightName,
    IN      DWORD           dwReserved
    )
{
    return Dns_NameCompareEx(
                pszLeftName,
                pszRightName,
                dwReserved,
                DnsCharSetAnsi );
}

DNS_NAME_COMPARE_STATUS
DnsNameCompareEx_UTF8(
    IN      LPCSTR          pszLeftName,
    IN      LPCSTR          pszRightName,
    IN      DWORD           dwReserved
    )
{
    return Dns_NameCompareEx(
                pszLeftName,
                pszRightName,
                dwReserved,
                DnsCharSetUtf8 );
}

DNS_NAME_COMPARE_STATUS
DnsNameCompareEx_W(
    IN      LPCWSTR         pszLeftName,
    IN      LPCWSTR         pszRightName,
    IN      DWORD           dwReserved
    )
{
    return Dns_NameCompareEx(
                (LPSTR) pszLeftName,
                (LPSTR) pszRightName,
                dwReserved,
                DnsCharSetUnicode );
}


//
//  Name validation
//

DNS_STATUS
DnsValidateName_UTF8(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    )
{
    return Dns_ValidateName_UTF8( pszName, Format );
}


DNS_STATUS
DnsValidateName_W(
    IN      LPCWSTR         pszName,
    IN      DNS_NAME_FORMAT Format
    )
{
    return Dns_ValidateName_W( pszName, Format );
}

DNS_STATUS
DnsValidateName_A(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    )
{
    return Dns_ValidateName_A( pszName, Format );
}


//
//  Record List 
//

BOOL
DnsRecordCompare(
    IN      PDNS_RECORD     pRecord1,
    IN      PDNS_RECORD     pRecord2
    )
{
    return Dns_RecordCompare(
                pRecord1,
                pRecord2 );
}

BOOL
WINAPI
DnsRecordSetCompare(
    IN OUT  PDNS_RECORD     pRR1,
    IN OUT  PDNS_RECORD     pRR2,
    OUT     PDNS_RECORD *   ppDiff1,
    OUT     PDNS_RECORD *   ppDiff2
    )
{
    return  Dns_RecordSetCompare(
                pRR1,
                pRR2,
                ppDiff1,
                ppDiff2
                );
}

PDNS_RECORD
WINAPI
DnsRecordCopyEx(
    IN      PDNS_RECORD     pRecord,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
{
    return Dns_RecordCopyEx( pRecord, CharSetIn, CharSetOut );
}

PDNS_RECORD
WINAPI
DnsRecordSetCopyEx(
    IN      PDNS_RECORD     pRecordSet,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
{
    return Dns_RecordSetCopyEx( pRecordSet, CharSetIn, CharSetOut );
}


VOID
WINAPI
DnsRecordListFree(
    IN OUT  PDNS_RECORD     pRecordList,
    IN      DNS_FREE_TYPE   FreeType
    )
{
    Dns_RecordListFreeEx(
        pRecordList,
        (BOOL)FreeType );
}

PDNS_RECORD
WINAPI
DnsRecordSetDetach(
    IN OUT  PDNS_RECORD pRR
    )
{
    return Dns_RecordSetDetach( pRR );
}



//
//  Timer (timer.c)
//

DWORD
GetCurrentTimeInSeconds(
    VOID
    )
{
    return Dns_GetCurrentTimeInSeconds();
}




//
//  Resource record type utilities (record.c)
//

BOOL _fastcall
DnsIsAMailboxType(
    IN      WORD        wType
    )
{
    return Dns_IsAMailboxType( wType );
}

WORD
DnsRecordTypeForName(
    IN      PCHAR       pszName,
    IN      INT         cchNameLength
    )
{
    return Dns_RecordTypeForName( pszName, cchNameLength );
}

PCHAR
DnsRecordStringForType(
    IN      WORD        wType
    )
{
    return Dns_RecordStringForType( wType );
}

PCHAR
DnsRecordStringForWritableType(
    IN  WORD    wType
    )
{
    return Dns_RecordStringForWritableType( wType );
}

BOOL
DnsIsStringCountValidForTextType(
    IN  WORD    wType,
    IN  WORD    StringCount )
{
    return Dns_IsStringCountValidForTextType( wType, StringCount );
}


//
//  DCR_CLEANUP:  these probably don't need exporting
//

DWORD
DnsWinsRecordFlagForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    )
{
    return Dns_WinsRecordFlagForString( pchName, cchNameLength );
}

PCHAR
DnsWinsRecordFlagString(
    IN      DWORD           dwFlag,
    IN OUT  PCHAR           pchFlag
    )
{
    return Dns_WinsRecordFlagString( dwFlag, pchFlag );
}




//
//  DNS utilities (dnsutil.c)
//
//  DCR_DELETE:  DnsStatusString routines should be able to use win32 API
//

//
//  Remove marco definitions so we can compile
//  The idea here is we can have the entry points in the Dll
//  for any old code, BUT the macros (dnsapi.h) point at new entry points
//  for freshly built modules.
//

#ifdef DnsStatusToErrorString_A
#undef DnsStatusToErrorString_A
#endif

LPSTR
_fastcall
DnsStatusString(
    IN      DNS_STATUS      Status
    )
{
    return Dns_StatusString( Status );
}


DNS_STATUS
_fastcall
DnsMapRcodeToStatus(
    IN      BYTE            ResponseCode
    )
{
    return Dns_MapRcodeToStatus( ResponseCode );
}

BYTE
_fastcall
DnsIsStatusRcode(
    IN      DNS_STATUS      Status
    )
{
    return Dns_IsStatusRcode( Status );
}



//
//  Name routines (string.c and dnsutil.c)
//

LPSTR _fastcall
DnsGetDomainName(
    IN      LPSTR           pszName
    )
{
    return Dns_GetDomainName( pszName );
}



//
//  String routines (string.c)
//

LPSTR
DnsCreateStringCopy(
    IN      PCHAR       pchString,
    IN      DWORD       cchString
    )
{
    return Dns_CreateStringCopy(
                pchString,
                cchString );
}

DWORD
DnsGetBufferLengthForStringCopy(
    IN      PCHAR       pchString,
    IN      DWORD       cchString,
    IN      BOOL        fUnicodeIn,
    IN      BOOL        fUnicodeOut
    )
{
    return (WORD) Dns_GetBufferLengthForStringCopy(
                        pchString,
                        cchString,
                        fUnicodeIn ? DnsCharSetUnicode : DnsCharSetUtf8,
                        fUnicodeOut ? DnsCharSetUnicode : DnsCharSetUtf8
                        );
}

//
//  Need to
//      - get this unexported or
//      - real verions or
//      - explicit UTF8-unicode converter if thats what's desired
//

PVOID
DnsCopyStringEx(
    OUT     PBYTE       pBuffer,
    IN      PCHAR       pchString,
    IN      DWORD       cchString,
    IN      BOOL        fUnicodeIn,
    IN      BOOL        fUnicodeOut
    )
{
    DWORD   resultLength;

    resultLength =
        Dns_StringCopy(
                pBuffer,
                NULL,
                pchString,
                cchString,
                fUnicodeIn ? DnsCharSetUnicode : DnsCharSetUtf8,
                fUnicodeOut ? DnsCharSetUnicode : DnsCharSetUtf8
                );

    return( pBuffer + resultLength );
}

PVOID
DnsStringCopyAllocateEx(
    IN      PCHAR       pchString,
    IN      DWORD       cchString,
    IN      BOOL        fUnicodeIn,
    IN      BOOL        fUnicodeOut
    )
{
    return Dns_StringCopyAllocate(
                pchString,
                cchString,
                fUnicodeIn ? DnsCharSetUnicode : DnsCharSetUtf8,
                fUnicodeOut ? DnsCharSetUnicode : DnsCharSetUtf8
                );
}

//
// The new and improved string copy routines . . .
//

DWORD
DnsNameCopy(
    OUT     PBYTE           pBuffer,
    IN OUT  PDWORD          pdwBufLength,
    IN      PCHAR           pchString,
    IN      DWORD           cchString,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
{
    return Dns_NameCopy( pBuffer,
                         pdwBufLength,
                         pchString,
                         cchString,
                         CharSetIn,
                         CharSetOut );
}

PVOID
DnsNameCopyAllocate(
    IN      PCHAR           pchString,
    IN      DWORD           cchString,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
{
    return Dns_NameCopyAllocate ( pchString,
                                  cchString,
                                  CharSetIn,
                                  CharSetOut );
}



//
//  String\Address mapping
//
//  DCR:  eliminate these exports
//  DCR:  fix these to SDK the real deal
//
//  DCR:  probably shouldn't expose alloc -- easy workaround for caller
//

PCHAR
DnsWriteReverseNameStringForIpAddress(
    OUT     PCHAR           pBuffer,
    IN      IP4_ADDRESS     Ip4Addr
    )
{
    return  Dns_Ip4AddressToReverseName_A(
                pBuffer,
                Ip4Addr );
}

PCHAR
DnsCreateReverseNameStringForIpAddress(
    IN      IP4_ADDRESS     Ip4Addr
    )
{
    return  Dns_Ip4AddressToReverseNameAlloc_A( Ip4Addr );
}


//
//  DCR_CLEANUP:  pull these in favor of winsock IPv6 string routines
//

BOOL
DnsIpv6StringToAddress(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCHAR           pchString,
    IN      DWORD           dwStringLength
    )
{
    return Dns_Ip6StringToAddressEx_A(
                pIp6Addr,
                pchString,
                dwStringLength );
}

VOID
DnsIpv6AddressToString(
    OUT     PCHAR           pchString,
    IN      PIP6_ADDRESS    pIp6Addr
    )
{
    Dns_Ip6AddressToString_A(
            pchString,
            pIp6Addr );
}



DNS_STATUS
DnsValidateDnsString_UTF8(
    IN      LPCSTR      pszName
    )
{
    return Dns_ValidateDnsString_UTF8( pszName );
}

DNS_STATUS
DnsValidateDnsString_W(
    IN      LPCWSTR     pszName
    )
{
    return Dns_ValidateDnsString_W( pszName );
}



//
//  Resource record utilities (rr*.c)
//

PDNS_RECORD
WINAPI
DnsAllocateRecord(
    IN      WORD        wBufferLength
    )
{
    return Dns_AllocateRecord( wBufferLength );
}


PDNS_RECORD
DnsRecordBuild_UTF8(
    IN OUT  PDNS_RRSET  pRRSet,
    IN      LPSTR       pszOwner,
    IN      WORD        wType,
    IN      BOOL        fAdd,
    IN      UCHAR       Section,
    IN      INT         Argc,
    IN      PCHAR *     Argv
    )
{
    return Dns_RecordBuild_A(
                pRRSet,
                pszOwner,
                wType,
                fAdd,
                Section,
                Argc,
                Argv );
}

PDNS_RECORD
DnsRecordBuild_W(
    IN OUT  PDNS_RRSET  pRRSet,
    IN      LPWSTR      pszOwner,
    IN      WORD        wType,
    IN      BOOL        fAdd,
    IN      UCHAR       Section,
    IN      INT         Argc,
    IN      PWCHAR *    Argv
    )
{
    return Dns_RecordBuild_W(
                pRRSet,
                pszOwner,
                wType,
                fAdd,
                Section,
                Argc,
                Argv );
}

//
//  Message processing
//

DNS_STATUS
WINAPI
DnsExtractRecordsFromMessage_W(
    IN  PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN  WORD                wMessageLength,
    OUT PDNS_RECORD *       ppRecord
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    return Dns_ExtractRecordsFromBuffer(
                pDnsBuffer,
                wMessageLength,
                TRUE,
                ppRecord );
}


DNS_STATUS
WINAPI
DnsExtractRecordsFromMessage_UTF8(
    IN  PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN  WORD                wMessageLength,
    OUT PDNS_RECORD *       ppRecord
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    return Dns_ExtractRecordsFromBuffer(
                pDnsBuffer,
                wMessageLength,
                FALSE,
                ppRecord );
}


//
//  Debug sharing
//

PDNS_DEBUG_INFO
DnsApiSetDebugGlobals(
    IN OUT  PDNS_DEBUG_INFO pInfo
    )
{
    return  Dns_SetDebugGlobals( pInfo );
}



//  
//  Config UI, ipconfig backcompat
//
//  DCR_CLEANUP:  Backcompat query config stuff -- yank once clean cycle
//


//
//  DCR:  Questionable exports
//

LPSTR
DnsCreateStandardDnsNameCopy(
    IN      PCHAR       pchName,
    IN      DWORD       cchName,
    IN      DWORD       dwFlag
    )
{
    return  Dns_CreateStandardDnsNameCopy(
                pchName,
                cchName,
                dwFlag );
}


//
//  DCR_CLEANUP:  who is using this?
//

DWORD
DnsDowncaseDnsNameLabel(
    OUT     PCHAR       pchResult,
    IN      PCHAR       pchLabel,
    IN      DWORD       cchLabel,
    IN      DWORD       dwFlags
    )
{
    return Dns_DowncaseNameLabel(
                pchResult,
                pchLabel,
                cchLabel,
                dwFlags );
}

//
//  DCR_CLEANUP:  who is using my direct UTF8 conversions AS API!
//

DWORD
_fastcall
DnsUnicodeToUtf8(
    IN      PWCHAR      pwUnicode,
    IN      DWORD       cchUnicode,
    OUT     PCHAR       pchResult,
    IN      DWORD       cchResult
    )
{
    return Dns_UnicodeToUtf8(
                pwUnicode,
                cchUnicode,
                pchResult,
                cchResult );
}

DWORD
_fastcall
DnsUtf8ToUnicode(
    IN      PCHAR       pchUtf8,
    IN      DWORD       cchUtf8,
    OUT     PWCHAR      pwResult,
    IN      DWORD       cwResult
    )
{
    return  Dns_Utf8ToUnicode(
                pchUtf8,
                cchUtf8,
                pwResult,
                cwResult );
}

DNS_STATUS
DnsValidateUtf8Byte(
    IN      BYTE        chUtf8,
    IN OUT  PDWORD      pdwTrailCount
    )
{
    return Dns_ValidateUtf8Byte(
                chUtf8,
                pdwTrailCount );
}


//
//  Old cluster call
//
//  DCR:  cleanup -- remove once cluster fixed up
//

VOID
DnsNotifyResolverClusterIp(
    IN      IP_ADDRESS      ClusterIp,
    IN      BOOL            fAdd
    )
/*++

Routine Description:

    Notify resolver of cluster IP coming on\offline.

Arguments:

    ClusterIp -- cluster IP

    fAdd -- TRUE if coming online;  FALSE if offline.

Return Value:

    None

--*/
{
    SOCKADDR_IN     sockaddrIn;

    DNSDBG( TRACE, (
        "DnsNotifyResolverClusterIp( %08x, %d )\n",
        ClusterIp,
        fAdd ));

    sockaddrIn.sin_family = AF_INET;
    sockaddrIn.sin_addr.s_addr = ClusterIp;

    DnsRegisterClusterAddress(
        0xd734453d,
        NULL,       // no name
        (PSOCKADDR) & sockaddrIn,
        fAdd
            ? DNS_CLUSTER_ADD
            : DNS_CLUSTER_DELETE_IP
        );
}

//
//  backcompat for macros
//      - DNS server list
//
//  this is called without dnsapi.h include somewhere in IIS
//

#undef DnsGetDnsServerList

DWORD
DnsGetDnsServerList(
    OUT     PIP4_ARRAY *    ppDnsArray
    )
{
    *ppDnsArray = GetDnsServerList( TRUE );

    //  if no servers read, return

    if ( !*ppDnsArray )
    {
        return 0;
    }

    return( (*ppDnsArray)->AddrCount );
}

//
//  Config UI, ipconfig backcompat
//
//  DCR_CLEANUP:  this is called without dnsapi.h include somewhere in DHCP
//

#undef  DnsGetPrimaryDomainName_A

#define PrivateQueryConfig( Id )      DnsQueryConfigAllocEx( Id, NULL, FALSE )

PSTR 
WINAPI
DnsGetPrimaryDomainName_A(
    VOID
    )
{
    return  PrivateQueryConfig( DnsConfigPrimaryDomainName_A );
}

//
//  End export.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\faz.c ===
/*++

Copyright (c) 1997-2001 Microsoft Corporation

Module Name:

    faz.c

Abstract:

    Domain Name System (DNS) API 

    Find Authoritative Zone (FAZ) routines

Author:

    Jim Gilroy (jamesg)     January, 1997

Revision History:

--*/


#include "local.h"



//
//  Max number of server's we'll ever bother to extract from packet
//  (much more and you're out of UDP packet space anyway)
//

#define MAX_NAME_SERVER_COUNT (20)




#if 1
//
//  Original FAZ routines -- now obsolete
//

PDNS_NETINFO     
Dns_BuildUpdateNetworkInfoFromFAZ(
    IN      LPSTR           pszZone,
    IN      LPSTR           pszPrimaryDns,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Build new DNS network info from record list.

Arguments:

    paipServers -- addr to receive ptr to zone's DNS server list

    pRR - incoming RR set

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    INT         countIp = 0;
    IP_ADDRESS  arrayIp[ MAX_NAME_SERVER_COUNT + 1];
    PIP_ARRAY   piparray = (PIP_ARRAY)arrayIp;
    BOOL        fmatch = FALSE;

    DNS_ASSERT( &piparray->AddrCount == &arrayIp[0] );

    //
    //  DNS hostname unknown, extract from SOA or NS records
    //

    if ( !pszPrimaryDns )
    {
        return( NULL );
    }

    //
    //  find IP addresses of primary DNS server
    //      - skip first entry, so array can mimic PIP_ARRAY structure
    //

    while ( pRecord )
    {
        //  if not A record
        //      - we're done if already read records, otherwise continue

        if ( pRecord->wType != DNS_TYPE_A )
        {
            if ( countIp != 0 )
            {
                break;
            }
            fmatch = FALSE;
            pRecord = pRecord->pNext;
            continue;
        }

        //  if record has name, check it
        //  otherwise match is the same as previous record

        if ( pRecord->pName )
        {
            fmatch = Dns_NameCompare_UTF8(
                        pRecord->pName,
                        pszPrimaryDns );
        }
        if ( fmatch )
        {
            arrayIp[ ++countIp ] = pRecord->Data.A.IpAddress;
        }
        pRecord = pRecord->pNext;
        continue;
    }

    if ( countIp == 0 )
    {
        return( NULL );
    }
    piparray->AddrCount = countIp;

    //
    //  convert into UPDATE adapter list
    //

    return  NetInfo_CreateForUpdate(
                pszZone,
                pszPrimaryDns,
                piparray,
                0 );
}



DNS_STATUS
Dns_FindAuthoritativeZoneLib(
    IN      PDNS_NAME           pszName,
    IN      DWORD               dwFlags,
    IN      PIP_ARRAY           aipQueryServers,
    OUT     PDNS_NETINFO      * ppNetworkInfo
    )
/*++

Routine Description:

    Find name of authoritative zone.

    Result of FAZ:
        - zone name
        - primary DNS server name
        - primary DNS IP list

Arguments:

    pszName         -- name to find authoritative zone for
                        Unicode string if dwFlags has DNSQUERY_UNICODE_NAME set.
                        ANSI string otherwise.

    dwFlags         -- flags to use for DnsQuery

    aipQueryServers -- servers to query, defaults used if NULL

    ppNetworkInfo   -- ptr to network info built for FAZ

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS          status;
    PDNS_RECORD         precord = NULL;
    PDNS_RECORD         precordPrimary = NULL;
    LPSTR               pszdnsHost = NULL;
    PDNS_NETINFO        pNetworkInfo = NULL;

    DNSDBG( QUERY, (
        "Dns_FindAuthoritativeZoneLib()\n"
        "\tname     %s\n"
        "\tflags    %08x\n",
        pszName,
        dwFlags ));

    //
    //  query until find name with SOA record -- the zone root
    //
    //  note, MUST check that actually get SOA record
    //      - servers may return referral
    //      - lame server might return CNAME to name
    //

    while ( pszName )
    {
        if ( precord )
        {
            Dns_RecordListFree( precord );
            precord = NULL;
        }

        status = QueryDirectEx(
                    NULL,               // no return message buffer
                    & precord,
                    NULL,               // no header
                    0,                  // no header counts
                    (LPSTR) pszName,
                    DNS_TYPE_SOA,
                    NULL,               // no input records
                    dwFlags,
                    aipQueryServers,
                    NULL                // no network info
                    );

        if ( status == ERROR_SUCCESS ||
            status == DNS_ERROR_RCODE_NAME_ERROR ||
            status == DNS_INFO_NO_RECORDS )
        {
            if ( precord && precord->wType == DNS_TYPE_SOA )
            {
                //  received SOA
                //  devolve name to zone name

                DNSDBG( QUERY, (
                    "FAZ found SOA (section %d) at zone %s\n",
                    precord->Flags.S.Section,
                    precord->pName ));

                while( pszName &&
                    ! Dns_NameCompare_UTF8( pszName, precord->pName ) )
                {
                    pszName = Dns_GetDomainName( pszName );
                }
                break;
            }

            //  this could be because server no-recurse or
            //  bum server (BIND) that CNAMEs even when type=SOA
            //      drop down to devolve name and continue

            DNSDBG( ANY, (
                "ERROR:  response from FAZ query with no SOA records.\n" ));
        }

        //
        //  other errors besides
        //      - name error
        //      - no records
        //  indicate terminal problem
        //

        else
        {
            DNS_ASSERT( precord == NULL );
            goto Cleanup;
        }

        //
        //  name error or empty response, continue with next higher domain
        //

        pszName = Dns_GetDomainName( pszName );
    }

    //
    //  if reached root, we're dead
    //

    if ( !pszName )
    {
        if ( status == ERROR_SUCCESS )
        {
            DNS_ASSERT( FALSE );
            status = DNS_ERROR_RCODE_SERVER_FAILURE;
        }
        goto Cleanup;
    }

    //
    //  have SOA record
    //
    //  if primary server A record in the packet, use it
    //  otherwise query for primary DNS A record
    //

    DNS_ASSERT( precord->wType == DNS_TYPE_SOA );
    DNS_ASSERT( status == ERROR_SUCCESS );

    pszdnsHost = (LPSTR) precord->Data.SOA.pNamePrimaryServer;

    pNetworkInfo = Dns_BuildUpdateNetworkInfoFromFAZ(
                        pszName,
                        pszdnsHost,
                        precord );
    if ( !pNetworkInfo )
    {
        status = QueryDirectEx(
                    NULL,               // no return message buffer
                    & precordPrimary,
                    NULL,               // no header
                    0,                  // no header counts
                    pszdnsHost,
                    DNS_TYPE_A,
                    NULL,               // no input records
                    dwFlags,
                    aipQueryServers,
                    NULL                // no network info
                    );

        if ( status != ERROR_SUCCESS || precordPrimary == NULL )
        {
            DNS_PRINT(( "ERROR:  no response to primary A query\n" ));
            TEST_ASSERT( FALSE );
            status = DNS_ERROR_RCODE_SERVER_FAILURE;
            goto Cleanup;
        }
        pNetworkInfo = Dns_BuildUpdateNetworkInfoFromFAZ(
                            pszName,
                            pszdnsHost,
                            precordPrimary );
        if ( !pNetworkInfo )
        {
            status = DNS_ERROR_RCODE_SERVER_FAILURE;
        }
    }

Cleanup:

    if ( precord )
    {
        Dns_RecordListFree( precord );
    }
    if ( precordPrimary )
    {
        Dns_RecordListFree( precordPrimary );
    }

    *ppNetworkInfo = pNetworkInfo;

    IF_DNSDBG( QUERY )
    {
        DNS_PRINT((
            "Leaving Dns_FindAuthoritativeZoneLib()\n"
            "\tstatus = %d\n"
            "\tzone = %s\n",
            status,
            pszName ));
    }

    return( status );
}
#endif



//
//  Private utilities
//

PDNS_NETINFO     
buildUpdateNetworkInfoFromFAZ(
    IN      LPSTR                   pszZone,
    IN      LPSTR                   pszPrimaryDns,
    IN      PDNS_RECORD             pRecord
    )
/*++

Routine Description:

    Build new DNS server list from record list.

Arguments:

    pszZone -- zone name

    pszPrimaryDns -- DNS server name

    pRecord -- record list from FAZ or other lookup that contain DNS server
        host records

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    INT         countIp = 0;
    IP_ADDRESS  arrayIp[ MAX_NAME_SERVER_COUNT + 1];
    PIP_ARRAY   piparray = (PIP_ARRAY)arrayIp;
    BOOL        fmatch = FALSE;

    DNS_ASSERT( &piparray->AddrCount == &arrayIp[0] );

    DNSDBG( TRACE, (
        "buildUpdateNetworkInfoFromFAZ( %s )\n",
        pszZone ));

    //
    //  DNS hostname unknown, extract from SOA or NS records
    //

    if ( !pszPrimaryDns )
    {
        return( NULL );
    }

    //
    //  find IP addresses of primary DNS server
    //      - skip first entry, so array can mimic PIP_ARRAY structure
    //

    while ( pRecord )
    {
        //  if not A record
        //      - we're done if already read records, otherwise continue

        if ( pRecord->wType != DNS_TYPE_A )
        {
            if ( countIp != 0 )
            {
                break;
            }
            fmatch = FALSE;
            pRecord = pRecord->pNext;
            continue;
        }

        //  if record has name, check it
        //  otherwise match is the same as previous record

        if ( pRecord->pName )
        {
            fmatch = Dns_NameCompare_UTF8(
                        pRecord->pName,
                        pszPrimaryDns );
        }
        if ( fmatch &&
             countIp < MAX_NAME_SERVER_COUNT )
        {
            arrayIp[ ++countIp ] = pRecord->Data.A.IpAddress;
        }
        pRecord = pRecord->pNext;
        continue;
    }

    if ( countIp == 0 )
    {
        return( NULL );
    }
    piparray->AddrCount = countIp;

    //
    //  convert into UPDATE adapter list
    //

    return  NetInfo_CreateForUpdate(
                pszZone,
                pszPrimaryDns,
                piparray,
                0 );
}



BOOL
ValidateZoneNameForUpdate(
    IN      PSTR            pszZone
    )
/*++

Routine Description:

    Check if zone is valid for update.

Arguments:

    pszZone -- zone name

Return Value:

    TRUE    -- zone is valid for update
    FALSE   -- zone is invalid, should NOT send update to this zone

--*/
{
    PSTR        pzoneExclusions = NULL;
    PSTR        pch;
    PSTR        pnext;
    DNS_STATUS  status;
    DWORD       length;
    BOOL        returnVal = TRUE;
    DWORD       labelCount;

    DNSDBG( TRACE, (
        "ValidateZoneNameForUpdate( %s )\n",
        pszZone ));

    //
    //  never update the root
    //

    if ( !pszZone || *pszZone=='.' )
    {
        return( FALSE );
    }

    //
    //  never update TLD
    //      - except config override in case someone
    //      gave themselves a single label domain name
    //

    if ( g_UpdateTopLevelDomains )
    {
        return( TRUE );
    }

    labelCount = Dns_NameLabelCount( pszZone );

    if ( labelCount > 2 )
    {
        return( TRUE );
    }
    if ( labelCount < 2 )
    {
        return( FALSE );
    }

    //
    //  screen out
    //      - "in-addr.arpa"
    //      - "ip6.int"
    //

    if ( Dns_NameCompare_UTF8(
            "in-addr.arpa",
            pszZone ) )
    {
        return( FALSE );
    }
    if ( Dns_NameCompare_UTF8(
            "ip6.int",
            pszZone ) )
    {
        return( FALSE );
    }

    return( TRUE );

#if 0
    //
    //  DCR:  "update zone allowed" list?
    //
    //  note:  this is complicated as need to test
    //      SECOND label because tough cases are
    //      "co.uk" -- difficult to test first label  
    //

    //
    //  read exclusion list from registry
    //

    status = DnsRegGetValueEx(
                NULL,               // no session
                NULL,               // no adapter
                NULL,               // no adapter name
                DnsRegUpdateZoneExclusions,
                REGTYPE_UPDATE_ZONE_EXCLUSIONS,
                DNSREG_FLAG_DUMP_EMPTY,         // dump empty string
                (PBYTE *) &pzoneExclusions
                );

    if ( status != ERROR_SUCCESS ||
         !pzoneExclusions )
    {
        ASSERT( pzoneExclusions == NULL );
        return( TRUE );
    }

    //
    //  check all exclusion zones   
    //
    //  note:  UTF8 compare mediocre perfwise
    //      if critically would keep exclusions in
    //      cannonical form so don't go to unicode
    //      for case-insensitive compare
    //

    pch = pzoneExclusions;

    while ( 1 )
    {
        //  check for termination
        //  or find next string

        length = strlen( pch );
        if ( length == 0 )
        {
            break;
        }
        pnext = pch + length + 1;

        //
        //  check this string
        //

        DNSDBG( TRACE, (
            "Update zone compare to %s\n",
            pch ));

        if ( Dns_NameCompare_UTF8(
                pch,
                pszZone ) )
        {
            returnVal = FALSE;
            break;
        }

        pch = pnext;
    }

    //  if no match, zone is valid

    FREE_HEAP( pzoneExclusions );

    return( returnVal );
#endif
}



DNS_STATUS
DnsFindAuthoritativeZone(
    IN      PDNS_NAME               pszName,
    IN      DWORD                   dwFlags,
    IN      PIP_ARRAY               aipQueryServers,
    OUT     PDNS_NETINFO      *     ppNetworkInfo
    )
/*++

Routine Description:

    Find name of authoritative zone.

    Result of FAZ:
        - zone name
        - primary DNS server name
        - primary DNS IP list

Arguments:

    pszName         -- name to find authoritative zone for

    dwFlags         -- flags to use for DnsQuery

    aipQueryServers -- servers to query, defaults used if NULL

    ppNetworkInfo   -- ptr to adapter list built for FAZ

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS          status;
    PDNS_RECORD         precord = NULL;
    PDNS_RECORD         precordPrimary = NULL;
    PDNS_RECORD         precordSOA = NULL;
    LPSTR               pszdnsHost = NULL;
    PDNS_NETINFO        pnetInfo = NULL;
    PSTR                pzoneName;

    DNSDBG( QUERY, (
        "DnsFindAuthoritativeZone()\n"
        "\tname     %s\n"
        "\tflags    %08x\n",
        pszName,
        dwFlags ));

    //
    //  query until find name with SOA record -- the zone root
    //
    //  note, MUST check that actually get SOA record
    //      - servers may return referral
    //      - lame server might return CNAME to name
    //

    pzoneName = pszName;

    while ( pzoneName )
    {
        if ( precord )
        {
            Dns_RecordListFree( precord );
            precord = NULL;
        }

        status = DnsQuery_UTF8(
                        (LPSTR) pzoneName,
                        DNS_TYPE_SOA,
                        dwFlags |
                            DNS_QUERY_TREAT_AS_FQDN |
                            DNS_QUERY_ALLOW_EMPTY_AUTH_RESP,
                        aipQueryServers,
                        & precord,
                        NULL );

        //
        //  find SOA and possibly primary name A
        //
        //  test for ERROR_SUCCESS, AUTH_EMPTY or NAME_ERROR
        //  in all cases first record should be SOA
        //      ERROR_SUCCESS -- answer section
        //      NAME_ERROR or AUTH_EMPTY -- authority section
        //  all MAY also have additional record for SOA primary server
        //

        if ( status == ERROR_SUCCESS ||
             status == DNS_INFO_NO_RECORDS ||
             status == DNS_ERROR_RCODE_NAME_ERROR )
        {
            if ( precord && precord->wType == DNS_TYPE_SOA )
            {
                //  received SOA
                //  devolve name to zone name

                DNSDBG( QUERY, (
                    "FAZ found SOA (section %d) at zone %s\n",
                    precord->Flags.S.Section,
                    precord->pName ));

                while( pzoneName &&
                    ! Dns_NameCompare_UTF8( pzoneName, precord->pName ) )
                {
                    pzoneName = DnsGetDomainName( pzoneName );
                }
                precordSOA = precord;
                status = ERROR_SUCCESS;
                break;
            }
            //  this could be because server no-recurse or
            //  bum server (BIND) that CNAMEs even when type=SOA
            //      drop down to devolve name and continue

            DNSDBG( ANY, (
                "ERROR:  response from FAZ query with no SOA records.\n" ));
        }

        //
        //  other errors besides
        //      - name error
        //      - no records
        //  indicate terminal problem
        //

        else
        {
            DNS_ASSERT( precord == NULL );
            goto Cleanup;
        }

        //
        //  name error or empty response, continue with next higher domain
        //

        pzoneName = DnsGetDomainName( pzoneName );
    }

    //
    //  if reached root or TLD -- no update
    //      - note currently returning SERVFAIL because of
    //      screwy netlogon logic
    //

    if ( !ValidateZoneNameForUpdate(pzoneName) )
    {
        //status = DNS_ERROR_INVALID_ZONE_OPERATION;
        status = DNS_ERROR_RCODE_SERVER_FAILURE;
        //status = DNS_ERROR_RCODE_REFUSED;
        goto Cleanup;
    }

    //
    //  have SOA record
    //
    //  if primary server A record in the packet, use it
    //  otherwise query for primary DNS A record
    //

    DNS_ASSERT( precordSOA );
    DNS_ASSERT( status == ERROR_SUCCESS );

    pszdnsHost = (LPSTR) precordSOA->Data.SOA.pNamePrimaryServer;

    //
    //  check additional for primary A record
    //      if found, build network info blob for update
    //      that points only to update server
    //

    pnetInfo = buildUpdateNetworkInfoFromFAZ(
                        pzoneName,
                        pszdnsHost,
                        precordSOA );


    //
    //  if no primary server A record found -- must query
    //

    if ( !pnetInfo )
    {
        DNSDBG( QUERY, (
           "WARNING:  FAZ making additional query for primary!\n"
           "\tPrimary (%s) A record should have been in additional section!\n",
           pszdnsHost ));

        status = DnsQuery_UTF8(
                        pszdnsHost,
                        DNS_TYPE_A,
                        dwFlags |
                            DNS_QUERY_TREAT_AS_FQDN |
                            DNS_QUERY_ALLOW_EMPTY_AUTH_RESP,
                        aipQueryServers,
                        & precordPrimary,
                        NULL );

        if ( status != ERROR_SUCCESS || precordPrimary == NULL )
        {
            DNS_PRINT(( "ERROR:  no response to primary A query\n" ));
            TEST_ASSERT( FALSE );
            status = DNS_ERROR_RCODE_SERVER_FAILURE;
            goto Cleanup;
        }
        pnetInfo = buildUpdateNetworkInfoFromFAZ(
                            pzoneName,
                            pszdnsHost,
                            precordPrimary );
        if ( !pnetInfo )
        {
            status = DNS_ERROR_RCODE_SERVER_FAILURE;
        }
    }

Cleanup:

    Dns_RecordListFree( precord );
    Dns_RecordListFree( precordPrimary );

    *ppNetworkInfo = pnetInfo;

    IF_DNSDBG( QUERY )
    {
        DNS_PRINT((
            "Leaving DnsFindAuthoritativeZone()\n"
            "\tstatus = %d\n"
            "\tzone = %s\n",
            status,
            pzoneName ));
    }

    return( status );
}



DNS_STATUS
DoQuickFAZ(
    OUT     PDNS_NETINFO      * ppNetworkInfo,
    IN      LPSTR               pszName,
    IN      PIP_ARRAY           aipServerList OPTIONAL
    )
/*++

Routine Description:

    FAZ to build network info from FAZ result

    Result of FAZ:
        - zone name
        - primary DNS server name
        - primary DNS IP list

    This routine is cheap shell around real FAZ to handle
    network failure issue, speeding things in net down
    condition.

Arguments:

    ppNetworkInfo -- addr to recv ptr to network info

    pszName -- name for update

    aipServerList -- IP array of DNS servers to contact

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure

--*/
{
    DNS_STATUS  status;

    DNSDBG( TRACE, ( "DoQuickFAZ( %s )\n", pszName ));

    if ( IsKnownNetFailure() )
    {
        return GetLastError();
    }

    //
    //  call real FAZ
    //      - get results as adapter list struct
    //

    status = DnsFindAuthoritativeZone(
                    pszName,
                    aipServerList ? DNS_QUERY_BYPASS_CACHE : 0,
                    aipServerList,
                    ppNetworkInfo       // build adapter list from results
                    );

    //
    //  if unsuccessful, check if network failure
    //

    if ( status != ERROR_SUCCESS && !aipServerList )
    {
        if ( status == WSAEFAULT ||
             status == WSAENOTSOCK ||
             status == WSAENETDOWN ||
             status == WSAENETUNREACH ||
             status == WSAEPFNOSUPPORT ||
             status == WSAEAFNOSUPPORT ||
             status == WSAEHOSTDOWN ||
             status == WSAEHOSTUNREACH ||
             status == ERROR_TIMEOUT )
        {
            SetKnownNetFailure( status );
            return status;
        }
    }
    return status;
}




//
//  Update network info preparation
//

DWORD
GetDnsServerListsForUpdate(
    IN OUT  PIP_ARRAY *     DnsServerListArray,
    IN      DWORD           ArrayLength,
    IN      DWORD           Flags
    )
/*++

Routine Description:

    Get DNS server lists for update.

    One DNS server list returned for each valid updateable adapter.

Arguments:

    DnsServerListArray -- array to hold DNS server lists found

    ArrayLength -- length of array

    Flags -- update flags

Return Value:

    Count of DNS server lists found.

--*/
{
    PDNS_NETINFO      pnetInfo;
    DWORD             iter1;
    DWORD             iter2;
    DWORD             countNets = 0;

    //  clear server list array

    RtlZeroMemory(
        DnsServerListArray,
        sizeof(PIP_ARRAY) * ArrayLength );


    //  build list from current netinfo

    pnetInfo = GetNetworkInfo();
    if ( ! pnetInfo )
    {
        return 0;
    }

    //
    //  check if update is disabled
    //      - update dependent on registration state
    //      - global registration state is OFF
    //      => then skip
    //

    if ( (Flags & DNS_UPDATE_SKIP_NO_UPDATE_ADAPTERS)
            &&
         ! g_RegistrationEnabled )              
    {
        return 0;
    }

    //
    //  build DNS server list for each updateable adapter
    //

    for ( iter1 = 0; iter1 < pnetInfo->AdapterCount; iter1++ )
    {
        PDNS_ADAPTER    padapter;
        DWORD               serverCount;
        PIP_ARRAY           pdnsArray;

        if ( iter1 >= ArrayLength )
        {
            break;
        }

        padapter = pnetInfo->AdapterArray[iter1];
        if ( !padapter )
        {
            continue;
        }

        //  skip if no DNS servers

        serverCount = padapter->ServerCount;
        if ( serverCount== 0 )
        {
            continue;
        }

        //  skip "no-update" adapter?
        //      - if skip-disabled flag set for this update
        //      - and no-update flag on adapter

        if ( (Flags & DNS_UPDATE_SKIP_NO_UPDATE_ADAPTERS) &&
                !(padapter->InfoFlags & DNS_FLAG_REGISTER_IP_ADDRESSES) )
        {
            continue;
        }

        //
        //  valid update adapter
        //      - create\save DNS server list
        //      - bump count of lists
        //
        //  DCR:  functionalize adapter DNS list to IP array
        //
        //  DCR_PERF:  collapse DNS server lists in netinfo BEFORE allocating them
        //      in other words bring this function into collapse and fix
        //

        pdnsArray = Dns_CreateIpArray( serverCount );
        if ( ! pdnsArray )
        {
            goto Exit;
        }

        for ( iter2 = 0; iter2 < serverCount; iter2++ )
        {
            pdnsArray->AddrArray[iter2] = padapter->ServerArray[iter2].IpAddress;
        }

        DnsServerListArray[countNets] = pdnsArray;
        countNets++;
    }

Exit:

    //  free network info
    //  return count of DNS server lists found

    NetInfo_Free( pnetInfo );

    return countNets;
}



DWORD
cleanDeadAdaptersFromArray(
    IN OUT  PIP_ARRAY *         IpArrayArray,
    IN OUT  PDNS_NETINFO      * NetworkInfoArray,   OPTIONAL
    IN      DWORD               Count
    )
/*++

Routine Description:

    Cleanup and remove from array(s) adapter info, when an
    adapter is determined to be dead, useless or duplicate for
    the update.

Arguments:

    IpArrayArray -- array of IP array pointers

    NetworkInfoArray -- array of ptrs to network info structs

    Count -- length arrays (current adapter count)

Return Value:

    New adapter count.

--*/
{
    register DWORD iter;

    //
    //  remove useless adapters
    //  useless means no DNS server list
    //

    for ( iter = 0;  iter < Count;  iter++ )
    {
        PIP_ARRAY parray = IpArrayArray[iter];

        if ( !parray || parray->AddrCount==0 )
        {
            if ( parray )
            {
                FREE_HEAP( parray );
                IpArrayArray[ iter ] = NULL;
            }
            Count--;
            IpArrayArray[ iter ]   = IpArrayArray[ Count ];
            IpArrayArray[ Count ]  = NULL;

            //  if have corresponding NetworkInfo array, clean it in same fashion

            if ( NetworkInfoArray )
            {
                if ( NetworkInfoArray[iter] )
                {
                    NetInfo_Free( NetworkInfoArray[iter] );
                    NetworkInfoArray[iter] = NULL;
                }
                NetworkInfoArray[ iter ]    = NetworkInfoArray[ Count ];
                NetworkInfoArray[ Count ]   = NULL;
            }
        }
    }

    //  return count of cleaned list

    return  Count;
}



DWORD
eliminateDuplicateAdapterFromArrays(
    IN OUT  PIP_ARRAY *         IpArrayArray,
    IN OUT  PDNS_NETINFO      * NetworkInfoArray,
    IN OUT  PDNS_RECORD *       NsRecordArray,
    IN      DWORD               Count,
    IN      DWORD               DuplicateIndex
    )
/*++

Routine Description:

    Cleanup and remove from array(s) adapter info, when an
    adapter is determined to be dead, useless or duplicate for
    the update.

Arguments:

    IpArrayArray -- array of IP array pointers

    NetworkInfoArray -- array of ptrs to network info structs

    NsRecordArray -- array of NS record lists for FAZed zone

    Count -- length arrays (current adapter count)

    DuplicateIndex -- index of duplicate

Return Value:

    New adapter count.

--*/
{
    ASSERT( DuplicateIndex < Count );

    DNSDBG( TRACE, (
        "eliminateDuplicateAdapterFromArrays( dup=%d, max=%d )\n",
        DuplicateIndex,
        Count ));

    //
    //  free any info on duplicate adapter
    //

    FREE_HEAP( IpArrayArray[DuplicateIndex] );
    NetInfo_Free( NetworkInfoArray[DuplicateIndex] );
    Dns_RecordListFree( NsRecordArray[DuplicateIndex] );

    //
    //  copy top entry to this spot
    //

    Count--;

    if ( Count != DuplicateIndex )
    {
        IpArrayArray[DuplicateIndex]     = IpArrayArray[Count];
        NetworkInfoArray[DuplicateIndex] = NetworkInfoArray[Count];
        NsRecordArray[DuplicateIndex]    = NsRecordArray[Count];
    }

    return Count;
}



DWORD
combineDnsServerListsForTwoAdapters(
    IN OUT  PIP_ARRAY *     IpArrayArray,
    IN      DWORD           Count,
    IN      DWORD           Index1,
    IN      DWORD           Index2
    )
/*++

Routine Description:

    Combine DNS server lists for two adapters.

    Note, this unions the DNS server lists for the two
    adapters and eliminates the higher indexed adapter
    from the list.

Arguments:

    IpArrayArray -- array of IP array pointers

    Count -- length of pointer array

    Index1 -- low index to union

    Index2 -- high index to union

Return Value:

    New adapter count.

--*/
{
    PIP_ARRAY punionArray = NULL;

    DNSDBG( TRACE, (
        "combineDnsServerListsForTwoAdapters( count=%d, i1=%d, i2=%d )\n",
        Count,
        Index1,
        Index2 ));

    ASSERT( Index1 < Count );
    ASSERT( Index2 < Count );
    ASSERT( Index1 < Index2 );

    //
    //  union the arrays
    //
    //  if unable to allocate union, then just use list in first array
    //  and dump second
    //

    Dns_UnionOfIpArrays( IpArrayArray[Index1], IpArrayArray[Index2], &punionArray );

    if ( punionArray )
    {
        FREE_HEAP( IpArrayArray[Index1] );
        IpArrayArray[Index1] = punionArray;
    }

    FREE_HEAP( IpArrayArray[Index2] );
    IpArrayArray[Index2] = NULL;

    //
    //  swap deleted entry with last entry in list
    //

    Count--;
    IpArrayArray[Index2] = IpArrayArray[ Count ];

    return( Count );
}



DNS_STATUS
CollapseDnsServerListsForUpdate(
    IN OUT  PIP_ARRAY *         DnsServerListArray,
    OUT     PDNS_NETINFO      * NetworkInfoArray,
    IN OUT  PDWORD              pNetCount,
    IN      LPSTR               pszUpdateName
    )
/*++

Routine Description:

    Builds update network info blob for each unique name space.

    This essentially starts with DNS server list for each adapter
    and progressively detects adapters pointing at same name space
    until down minimum number of name spaces.

Arguments:

    DnsServerListArray -- array of ptrs to DNS server lists for each adapter

    NetworkInfoArray -- array to hold pointer to update network info for each
        adapter on return contains ptr to network info for each unique name
        space update should be sent to

    dwNetCount -- starting count of individual adapters networks

    pszUpdateName -- name to update

Return Value:

    Count of unique name spaces to update.
    NetworkInfoArray contains update network info blob for each name space.

--*/
{
    PDNS_RECORD     NsRecordArray[ UPDATE_ADAPTER_LIMIT ];
    PIP_ARRAY       parray1;
    DWORD           iter1;
    DWORD           iter2;
    DWORD           maxCount = *pNetCount;
    DNS_STATUS      status = DNS_ERROR_NO_DNS_SERVERS;


    DNSDBG( TRACE, (
        "collapseDnsServerListsForUpdate( count=%d )\n"
        "\tupdate name = %s\n",
        maxCount,
        pszUpdateName ));

    //
    //  clean list of any useless adapters
    //

    maxCount = cleanDeadAdaptersFromArray(
                    DnsServerListArray,
                    NULL,                   // no network info yet
                    maxCount );

    //
    //  if only one adapter -- nothing to compare
    //      - do FAZ to build update network info, if
    //      successful, we're done
    //

    if ( maxCount <= 1 )
    {
        if ( maxCount == 1 )
        {
            NetworkInfoArray[0] = NULL;

            status = DoQuickFAZ(
                        &NetworkInfoArray[0],
                        pszUpdateName,
                        DnsServerListArray[0] );

            if ( NetworkInfoArray[0] )
            {
                goto Done;
            }
            FREE_HEAP( DnsServerListArray[0] );
            maxCount = 0;
            goto Done;
        }
        goto Done;
    }

    //
    //  clear NetworkInfo
    //

    RtlZeroMemory(
        NetworkInfoArray,
        maxCount * sizeof(PVOID) );

    //
    //  loop through combining adapters with shared DNS servers
    //
    //  as we combine entries we shrink the list
    //

    for ( iter1 = 0; iter1 < maxCount; iter1++ )
    {
        parray1 = DnsServerListArray[ iter1 ];

        for ( iter2=iter1+1;  iter2 < maxCount;  iter2++ )
        {
            if ( Dns_IsIntersectionOfIpArrays( parray1, DnsServerListArray[iter2] ) )
            {
                DNSDBG( UPDATE, (
                    "collapseDSLFU:  whacking intersecting DNS server lists\n"
                    "\tadapters %d and %d (max =%d)\n",
                    iter1,
                    iter2,
                    maxCount ));

                maxCount = combineDnsServerListsForTwoAdapters(
                                DnsServerListArray,
                                maxCount,
                                iter1,
                                iter2 );
                iter2--;
                parray1 = DnsServerListArray[ iter1 ];
            }
        }
    }

    DNSDBG( TRACE, (
        "collapseDSLFU:  count after dup server whack = %d\n",
        maxCount ));


#if 0
    //  clean again, in case we missed something

    maxCount = cleanDeadAdaptersFromArray(
                    DnsServerListArray,
                    NULL,                   // no network info yet
                    maxCount );
#endif

    //
    //  FAZ remaining adapters
    //
    //  save result NetworkInfo struct
    //      => for comparison to determine adapters that share DNS name space
    //      => to return to caller to do actual update
    //
    //  if FAZ fails this adapter is useless for update -- dead issue
    //      adapter is removed and replaced by highest array entry
    //

    for ( iter1 = 0; iter1 < maxCount; iter1++ )
    {
        status = DnsFindAuthoritativeZone(
                    pszUpdateName,
                    DNS_QUERY_BYPASS_CACHE,
                    DnsServerListArray[ iter1 ],
                    & NetworkInfoArray[ iter1 ] );

        if ( status != ERROR_SUCCESS )
        {
            FREE_HEAP( DnsServerListArray[ iter1 ] );
            DnsServerListArray[ iter1 ] = NULL;
            maxCount--;
            DnsServerListArray[ iter1 ] = DnsServerListArray[ maxCount ];
            iter1--;
            continue;
        }
    }

#if 0
    //  clean out failed FAZ entries

    maxCount = cleanDeadAdaptersFromArray(
                    DnsServerListArray,
                    NetworkInfoArray,
                    maxCount );
#endif

    //  if only able to FAZ one adapter -- we're done
    //      only point here is to skip a bunch of unnecessary
    //      stuff in the most typical case multi-adapter case

    if ( maxCount <= 1 )
    {
        DNSDBG( TRACE, (
            "collapseDSLFU:  down to single FAZ adapter\n" ));
        goto Done;
    }

    //
    //  compare FAZ results to see if adapters are in same name space
    //
    //  do two passes
    //  -  on first pass only compare based on FAZ results, if successful
    //      we eliminate duplicate adapter
    //
    //  -  on second pass, adapters that are still separate are compared;
    //      if they don't fail FAZ matches (which are retried) then NS queries
    //      are used to determine if separate nets;
    //      note that NS query results are saved, so NS query is order N, even
    //      though we are in N**2 loop
    //

    RtlZeroMemory(
        NsRecordArray,
        maxCount * sizeof(PVOID) );

    for ( iter1=0;  iter1 < maxCount;  iter1++ )
    {
        for ( iter2=iter1+1;  iter2 < maxCount;  iter2++ )
        {
            if ( CompareTwoAdaptersForSameNameSpace(
                        DnsServerListArray[iter1],
                        NetworkInfoArray[iter1],
                        NULL,               // no NS list
                        DnsServerListArray[iter2],
                        NetworkInfoArray[iter2],
                        NULL,               // no NS list
                        FALSE               // don't use NS queries
                        ) )
            {
                DNSDBG( UPDATE, (
                    "collapseDSLFU:  whacking same-FAZ adapters\n"
                    "\tadapters %d and %d (max =%d)\n",
                    iter1,
                    iter2,
                    maxCount ));

                eliminateDuplicateAdapterFromArrays(
                    DnsServerListArray,
                    NetworkInfoArray,
                    NsRecordArray,
                    maxCount,
                    iter2 );

                maxCount--;
                iter2--;
            }
        }
    }

    DNSDBG( TRACE, (
        "collapseDSLFU:  count after dup FAZ whack = %d\n",
        maxCount ));


    //  second pass using NS info
    //  if NS info is created, we save it to avoid requery

    for ( iter1=0;  iter1 < maxCount;  iter1++ )
    {
        for ( iter2=iter1+1;  iter2 < maxCount;  iter2++ )
        {
            if ( CompareTwoAdaptersForSameNameSpace(
                        DnsServerListArray[iter1],
                        NetworkInfoArray[iter1],
                        & NsRecordArray[iter1],
                        DnsServerListArray[iter2],
                        NetworkInfoArray[iter2],
                        & NsRecordArray[iter2],
                        TRUE                // follow up with NS queries
                        ) )
            {
                DNSDBG( UPDATE, (
                    "collapseDSLFU:  whacking same-zone-NS adapters\n"
                    "\tadapters %d and %d (max =%d)\n",
                    iter1,
                    iter2,
                    maxCount ));

                eliminateDuplicateAdapterFromArrays(
                    DnsServerListArray,
                    NetworkInfoArray,
                    NsRecordArray,
                    maxCount,
                    iter2 );

                maxCount--;
                iter2--;
            }
        }
    }

    //
    //  kill off any NS records found
    //

    for ( iter1=0;  iter1 < maxCount;  iter1++ )
    {
        Dns_RecordListFree( NsRecordArray[iter1] );
    }

Done:

    //
    //  set count of remaining adapters (update DNS server lists)
    //
    //  return status
    //      - success if have any update adapter
    //      - on failure bubble up FAZ error
    //  

    DNSDBG( TRACE, (
        "Leave CollapseDnsServerListsForUpdate( collapsed count=%d )\n",
        maxCount ));

    *pNetCount = maxCount;

    if ( maxCount > 0 )
    {
        status = ERROR_SUCCESS;
    }
    return status;
}



BOOL
WINAPI
CompareTwoAdaptersForSameNameSpace(
    IN      PIP_ARRAY           pDnsServerList1,
    IN      PDNS_NETINFO        pNetworkInfo1,
    IN OUT  PDNS_RECORD *       ppNsRecord1,
    IN      PIP_ARRAY           pDnsServerList2,
    IN      PDNS_NETINFO        pNetworkInfo2,
    IN OUT  PDNS_RECORD *       ppNsRecord2,
    IN      BOOL                bDoNsCheck
    )
/*++

Routine Description:

    Compare two adapters to see if in same name space for update.

Arguments:

    pDnsServerList1 -- IP array of DNS servers for first adapter

    pNetworkInfo1   -- update netinfo for first adapter

    ppNsRecord1     -- addr of ptr to NS record list of update zone done on
                        first adapter;  NULL if no NS check required;  if
                        NS check required and *ppNsRecord1 is NULL, NS query
                        is made and results returned

    pDnsServerList2 -- IP array of DNS servers for second adapter

    pNetworkInfo2   -- update netinfo for second adapter

    ppNsRecord2     -- addr of ptr to NS record list of update zone done on
                        second adapter;  NULL if no NS check required;  if
                        NS check required and *ppNsRecord2 is NULL, NS query
                        is made and results returned

    bDoNsCheck      -- include update-zone NS check compare;  if NS overlap then
                        name spaces assumed to be the same

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    BOOL            fsame = FALSE;
    PDNS_ADAPTER    padapter1 = pNetworkInfo1->AdapterArray[0];
    PDNS_ADAPTER    padapter2 = pNetworkInfo2->AdapterArray[0];
    PDNS_RECORD     pns1 = NULL;
    PDNS_RECORD     pns2 = NULL;
    PDNS_RECORD     pnotUsed = NULL;
    PSTR            pzoneName;


    //
    //  done if bad params
    //

    if ( !pDnsServerList1 || !pDnsServerList2 )
    {
        return FALSE;
    }

    //
    //  validity check
    //      - note:  could probably be just ASSERT()
    //

    if ( ! NetInfo_IsForUpdate(pNetworkInfo1) ||
         ! NetInfo_IsForUpdate(pNetworkInfo2) )
    {
        ASSERT( FALSE );
        return( FALSE );
    }

    //
    //  compare FAZ results
    //
    //  first compare zone names
    //  if FAZ returns different zone names, then clearly
    //  have disjoint name spaces
    //

    pzoneName = NetInfo_UpdateZoneName( pNetworkInfo1 );

    if ( ! Dns_NameCompare_UTF8(
                pzoneName,
                NetInfo_UpdateZoneName( pNetworkInfo2 ) ) )
    {
        return FALSE;
    }

    //
    //  check if pointing at same server:
    //      - if have same update DNS server -- have a match
    //      - if same server name -- have a match
    //

    if ( padapter1->ServerCount == 1  &&
         padapter2->ServerCount == 1  &&
         padapter1->ServerArray[0].IpAddress == padapter2->ServerArray[0].IpAddress )
    {
        return TRUE;
    }
    else
    {
        fsame = Dns_NameCompare_UTF8(
                    NetInfo_UpdateServerName( pNetworkInfo1 ),
                    NetInfo_UpdateServerName( pNetworkInfo2 ) );
    }

    //
    //  if matched or not doing NS check => then done
    //

    if ( fsame || !bDoNsCheck )
    {
        return( fsame );
    }

    //
    //  NS check
    //
    //  if not pointing at same server, may be two multimaster primaries
    //
    //  use NS queries to determine if NS lists for same servers are in
    //  fact a match
    //

    if ( ppNsRecord1 )
    {
        pns1 = *ppNsRecord1;
    }
    if ( !pns1 )
    {
        status = DnsQuery_UTF8(
                        pzoneName,
                        DNS_TYPE_NS,
                        DNS_QUERY_BYPASS_CACHE,
                        pDnsServerList1,
                        &pns1,
                        NULL );

        if ( status != ERROR_SUCCESS )
        {
            goto Done;
        }
        pnotUsed = DnsRecordSetDetach( pns1 );
        if ( pnotUsed )
        {
            Dns_RecordListFree( pnotUsed );
            pnotUsed = NULL;
        }
    }

    if ( ppNsRecord2 )
    {
        pns2 = *ppNsRecord2;
    }
    if ( !pns2 )
    {
        status = DnsQuery_UTF8(
                        pzoneName,
                        DNS_TYPE_NS,
                        DNS_QUERY_BYPASS_CACHE,
                        pDnsServerList2,
                        &pns2,
                        NULL );

        if ( status != ERROR_SUCCESS )
        {
            goto Done;
        }
        pnotUsed = DnsRecordSetDetach( pns2 );
        if ( pnotUsed )
        {
            Dns_RecordListFree( pnotUsed );
            pnotUsed = NULL;
        }
    }

    //
    //  if NS lists the same -- same namespace
    //

    fsame = Dns_RecordSetCompareForIntersection( pns1, pns2 );

Done:

    //
    //  cleanup or return NS lists
    //
    //  note, purpose of returning is so caller can avoid requerying
    //      NS if must make compare against multiple other adapters
    //

    if ( ppNsRecord1 )
    {
        *ppNsRecord1 = pns1;
    }
    else
    {
        Dns_RecordListFree( pns1 );
    }

    if ( ppNsRecord2 )
    {
        *ppNsRecord2 = pns2;
    }
    else
    {
        Dns_RecordListFree( pns2 );
    }

    return fsame;
}



BOOL
WINAPI
CompareMultiAdapterSOAQueries(
    IN      LPSTR               pszDomainName,
    IN      PIP_ARRAY           pDnsServerList1,
    IN      PIP_ARRAY           pDnsServerList2
    )
/*++

Routine Description:

    Compare two adapters to see if in same name space for update.

Arguments:

    pszDomainName   -- domain name to update

    pDnsServerList1 -- IP array of DNS servers for first adapter

    pDnsServerList2 -- IP array of DNS servers for second adapter

Return Value:

    TRUE -- if adapters are found to be on same net
    FALSE -- otherwise (definitely NOT or unable to determine)

--*/
{
    DNS_STATUS          status;
    BOOL                fsame = FALSE;
    PDNS_NETINFO        pnetInfo1 = NULL;
    PDNS_NETINFO        pnetInfo2 = NULL;


    DNSDBG( TRACE, (
        "CompareMultiAdapterSOAQueries()\n" ));


    //  bad param screening

    if ( !pDnsServerList1 || !pDnsServerList2 || !pszDomainName )
    {
        return FALSE;
    }

    //
    //  compare DNS server lists
    //  if any overlap, them effectively in same DNS namespace
    //

    if ( Dns_IsIntersectionOfIpArrays( pDnsServerList1, pDnsServerList2 ) )
    {
        return TRUE;
    }

    //
    //  if no DNS server overlap, must compare FAZ results
    //
    //  note:  FAZ failures interpreted as FALSE response
    //      required for callers in asyncreg.c
    //

    status = DnsFindAuthoritativeZone(
                pszDomainName,
                DNS_QUERY_BYPASS_CACHE,
                pDnsServerList1,
                &pnetInfo1 );

    if ( status != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    status = DnsFindAuthoritativeZone(
                pszDomainName,
                DNS_QUERY_BYPASS_CACHE,
                pDnsServerList2,
                &pnetInfo2 );

    if ( status != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    //  call the comparison routine
    //

    fsame = CompareTwoAdaptersForSameNameSpace(
                pDnsServerList1,
                pnetInfo1,
                NULL,               // no NS record list
                pDnsServerList2,
                pnetInfo2,
                NULL,               // no NS record list
                TRUE                // follow up with NS queries
                );

Cleanup:

    NetInfo_Free( pnetInfo1 );
    NetInfo_Free( pnetInfo2 );

    return fsame;
}



IP_ADDRESS
FindHostIpAddressInRecordList(
    IN      PDNS_RECORD     pRecordList,
    IN      LPSTR           pszHostName
    )
/*++

Routine Description:

    Find IP for hostname, if its A record is in list.

    NOTE: This code was borrowed from \dns\dnslib\query.c!  ;-)

Arguments:

    pRecordList - incoming RR set

    pszHostName - hostname to find (in UTF8)

Return Value:

    IP address matching hostname, if A record for hostname found.
    Zero if not found.

--*/
{
    register PDNS_RECORD prr = pRecordList;

    //
    //  loop through all records until find IP matching hostname
    //

    while ( prr )
    {
        if ( prr->wType == DNS_TYPE_A &&
                Dns_NameCompare_UTF8(
                    prr->pName,
                    pszHostName ) )
        {
            return( prr->Data.A.IpAddress );
        }
        prr = prr->pNext;
    }

    return( 0 );
}



PIP_ARRAY
GetNameServersListForDomain(
    IN     LPSTR            pDomainName,
    IN     PIP_ARRAY        aipServers
    )
/*++

Routine Description:

    Get IPs for all DNS servers for zone.

Arguments:

    pDomainName -- zone name

    aipServers -- server list to query

Return Value:

    IP array of IPs of DNS servers for zone.
    NULL if error.

--*/
{
    DNS_STATUS  status = NO_ERROR;
    PDNS_RECORD prrQuery = NULL;
    PIP_ARRAY   aipNSList = NULL;
    DWORD       countAddr = 0;

    status = DnsQuery_UTF8(
                pDomainName,
                DNS_TYPE_NS,
                DNS_QUERY_BYPASS_CACHE,
                aipServers,
                &prrQuery,
                NULL );

    if ( status == NO_ERROR )
    {
        PDNS_RECORD pTemp = prrQuery;
        DWORD       dwCount = 0;

        while ( pTemp )
        {
            dwCount++;
            pTemp = pTemp->pNext;
        }

        aipNSList = Dns_CreateIpArray( dwCount );

        if ( aipNSList )
        {
            pTemp = prrQuery;

            while ( pTemp )
            {
                if ( pTemp->wType == DNS_TYPE_NS )
                {
                    IP_ADDRESS ip = 0;

                    ip = FindHostIpAddressInRecordList(
                             pTemp,
                             pTemp->Data.NS.pNameHost );

                    if ( !ip )
                    {
                        PDNS_RECORD pARecord = NULL;

                        //
                        // Query again to get the server's address
                        //

                        status = DnsQuery_UTF8( pTemp->Data.NS.pNameHost,
                                                DNS_TYPE_A,
                                                DNS_QUERY_BYPASS_CACHE,
                                                aipServers,
                                                &pARecord,
                                                NULL );

                        if ( status == NO_ERROR &&
                             pARecord )
                        {
                            ip = pARecord->Data.A.IpAddress;
                            Dns_RecordListFree( pARecord );
                        }
                    }

                    if ( ip &&
                         !Dns_IsAddressInIpArray( aipNSList, ip ) )
                    {
                        Dns_AddIpToIpArray( aipNSList, ip );
                        countAddr++;
                    }
                }

                pTemp = pTemp->pNext;
            }
        }
    }

    if ( prrQuery )
    {
        Dns_RecordListFree( prrQuery );
    }

    if ( aipNSList )
    {
        aipNSList->AddrCount = countAddr;
    }

    return aipNSList;
}


//
//  End of faz.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\event.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    event.c

Abstract:

    DNS event logging.

Author:

    Ramv      June-02-1997

Revision History:

--*/


#include "local.h"

#define  DNSAPI_LOG_SOURCE  (L"DnsApi")


//
//  Globals to suppress event logging
//

DWORD   g_TimeLastDnsEvent = 0;
DWORD   g_DnsEventCount = 0;

#define DNS_EVENTS_MAX_COUNT                (5)
#define DNS_EVENT_LOG_BLOCK_INTERVAL        (1800)      // 30 minutes



VOID
DnsLogEvent(
    IN      DWORD           MessageId,
    IN      WORD            EventType,
    IN      DWORD           NumberOfSubStrings,
    IN      LPSTR *         SubStrings,
    IN      DWORD           ErrorCode
    )
{
    HANDLE  logHandle;
    DWORD   dataLength = 0;
    PVOID   pdata = NULL;

    //
    //  protect against log spin
    //
    //  we'll allow a few events to log, then slam the door for
    //  a while to avoid filling event log
    //
    //  note:  none of these protection structures are MT safe, but
    //  there's no issue here, the failure mode is allowing an additional
    //  log entry or denying one that should now be allowed;  I don't
    //  believe there's any failure mode that permanently turns logging
    //  to always on or always off
    //

    if ( g_DnsEventCount > DNS_EVENTS_MAX_COUNT )
    {
        DWORD   currentTime = Dns_GetCurrentTimeInSeconds();
        if ( g_TimeLastDnsEvent + DNS_EVENT_LOG_BLOCK_INTERVAL > currentTime )
        {
            DNS_PRINT((
                "DNSAPI:  Refusing event logging!\n"
                "\tevent count  = %d\n"
                "\tlast time    = %d\n"
                "\tcurrent time = %d\n",
                g_DnsEventCount,
                g_TimeLastDnsEvent,
                currentTime ));
            return;
        }

        //  interval has elapsed, clear counters and continue logging

        g_DnsEventCount = 0;
    }


#if 0
    //
    //  open event log -- if haven't already
    //
    //  DCR_PERF:  better to just open this and close on process detach?
    //      will be open for services (maybe netlogon) but not much else
    //

    if ( !g_DnsEventlogHandle )
    {
        HANDLE hlog;

        hlog = RegisterEventSourceW(
                    NULL,
                    DNSAPI_LOG_SOURCE
                    );
        if ( hlog == NULL )
        {
            DNS_PRINT(("DNSAPI : RegisterEventSourceA failed %lu\n",
                     GetLastError()));
            return;
        }
        g_DnsEventlogHandle = hlog;
    }
#endif

    //
    //  open event log
    //

    logHandle = RegisterEventSourceW(
                    NULL,
                    DNSAPI_LOG_SOURCE
                    );
    if ( logHandle == NULL )
    {
        DNS_PRINT(("DNSAPI : RegisterEventSourceA failed %lu\n",
                 GetLastError()));
        return;
    }

    //
    //  log the event
    //      - get ptr and sizeof data
    //

    if ( ErrorCode != NO_ERROR )
    {
        dataLength = sizeof(DWORD);
        pdata = (PVOID) &ErrorCode;
    }

    //
    //  DCR_FIX0:  event logging should be unicode
    //

    ReportEventA(
        logHandle,
        EventType,
        0,            // event category
        MessageId,
        (PSID) NULL,
        (WORD) NumberOfSubStrings,
        dataLength,
        (LPSTR *)SubStrings,
        pdata );

    DeregisterEventSource( logHandle );

    //
    //  successful logging spin protection
    //      - inc count
    //      - if at max, save last logging time
    //

    if ( ++g_DnsEventCount >= DNS_EVENTS_MAX_COUNT )
    {
        g_TimeLastDnsEvent = Dns_GetCurrentTimeInSeconds();
    }
}

//
//  End of event.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\iplist4.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    iplist4.c

Abstract:

    Domain Name System (DNS) Library

    NT4 version of routines to get IP addresses of stack.

    Contents:
        Dns_GetIpAddressesNT4
        Dns_GetLocalIpAddressArrayNt4

Author:

    Glenn A. Curtis (glennc) 05-May-1997

Revision History:

    05-May-1997 glennc
        Copied from the (NT4 SP3) winsock2 directory

--*/

//
// includes
//

#include "local.h"

#define SERVICES_KEY              "System\\CurrentControlSet\\Services\\"
#define ADAPTER_TCPIP_PARMS_KEY   "Parameters\\TCPIP"
#define BIND_VALUE                "Bind"
#define DHCP_ENABLED_VALUE        "EnableDHCP"
#define DHCP_ADDRESS_VALUE        "DhcpIPAddress"
#define DHCP_SUBNET_VALUE         "DhcpSubnetMask"
#define STATIC_ADDRESS_VALUE      "IPAddress"
#define STATIC_SUBNET_VALUE       "SubnetMask"
#define KEY_CONNECT               "\\"
#define KEY_CONNECT_CHAR          '\\'
#define LINKAGE_KEY               "System\\CurrentControlSet\\Services\\Tcpip\\Linkage"
#define BIND_VALUE_TYPE           REG_MULTI_SZ
#define DHCP_ENABLED_VALUE_TYPE   REG_DWORD
#define DHCP_ADDRESS_VALUE_TYPE   REG_SZ
#define DHCP_SUBNET_VALUE_TYPE    REG_SZ
#define STATIC_ADDRESS_VALUE_TYPE REG_MULTI_SZ
#define STATIC_SUBNET_VALUE_TYPE  REG_MULTI_SZ

typedef DWORD IP_ADDRESS, *PIP_ADDRESS;

typedef struct _ADAPTER_INFO_
{
    BOOL        IsDhcpEnabled;
    PIP_ARRAY   pipAddresses;
    PIP_ARRAY   pipSubnetMasks;

} ADAPTER_INFO, *LPADAPTER_INFO;

extern PIP_ARRAY GetIpArray( BOOL, LPSTR );
extern PIP_ARRAY GetMaskArray( BOOL, LPSTR );

//
//  Heap operations
//

#define ALLOCATE_HEAP(size)         Dns_AllocZero( size )
#define REALLOCATE_HEAP(p,size)     Dns_Realloc( (p), (size) )
#define FREE_HEAP(p)                Dns_Free( p )
#define ALLOCATE_HEAP_ZERO(size)    Dns_AllocZero( size )


//
// functions
//

/*******************************************************************************
 *
 *  Dns_GetIpAddressesNT4
 *
 *  Retrieves all active IP addresses from all active adapters on this machine.
 *  Returns them as an array
 *
 *  ENTRY   IpAddressList   - pointer to array of IP addresses
 *          ListCount       - number of IP address IpAddressList can hold
 *
 *  EXIT    IpAddressList   - filled with retrieved IP addresses
 *
 *  RETURNS number of IP addresses retrieved, or 0 if error
 *
 *  ASSUMES 1. an IP address can be represented in a DWORD
 *          2. ListCount > 0
 *
 ******************************************************************************/

DWORD
Dns_GetIpAddressesNT4(
    IN OUT PDNS_ADDRESS_INFO IpAddressInfoList,
    IN     DWORD             ListCount
    )
{
    DWORD Error;
    DWORD addressCount = 0;
    HKEY   LinkageKeyHandle = NULL;
    LPSTR  BindString = NULL;
    LPSTR  StringPtr;
    DWORD  StringLen;
    DWORD  iter, iter2;
    DWORD  NumberOfNets;
    DWORD  TotalNumberOfNets;
    HKEY   AdapterKeyHandle = NULL;
    LPSTR  IpAddressString = NULL;
    LPADAPTER_INFO AdapterInfoList = NULL;

    RtlZeroMemory( IpAddressInfoList, sizeof( DNS_ADDRESS_INFO ) * ListCount );

    //
    // open linkage key in the to determine the the nets we are bound
    // to.
    //

    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          LINKAGE_KEY,
                          0,
                          KEY_QUERY_VALUE,
                          &LinkageKeyHandle );

    if( Error != ERROR_SUCCESS )
         goto Cleanup;

    //
    // read BIND value.
    //

    Error =  GetRegistryValue( LinkageKeyHandle,
                               FALSE,
                               BIND_VALUE,
                               BIND_VALUE_TYPE,
                               (LPBYTE)&BindString );

    if ( Error != ERROR_SUCCESS )
         goto Cleanup;

    RegCloseKey( LinkageKeyHandle );
    LinkageKeyHandle = NULL;

    //
    // determine number of string in BindStrings, that many NETs are
    // bound.
    //

    StringPtr = BindString;
    NumberOfNets = 0;
    while ( (StringLen = strlen(StringPtr)) != 0 )
    {
        //
        // found another NET.
        //
        NumberOfNets++;
        StringPtr += (StringLen + 1); // move to next string.
    }

    //
    // allocate memory for the ADAPTER_INFO array.
    //

    AdapterInfoList =
        ALLOCATE_HEAP( sizeof(ADAPTER_INFO) * NumberOfNets );

    if( AdapterInfoList == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // enum the NETs.
    //

    TotalNumberOfNets = 0;

    for ( iter = 0, StringPtr = BindString;
          ( ( StringLen = strlen( StringPtr ) ) != 0 );
          iter++, StringPtr += ( StringLen + 1 ) )
    {
        LPSTR  AdapterName;
        char   AdapterParamKey[256];
        DWORD  EnableDHCPFlag;

        //
        // open Parameter key of the adapter that is bound to DHCP.
        //

        AdapterName = strrchr( StringPtr, KEY_CONNECT_CHAR);

        if( AdapterName == NULL )
            continue;

        //
        // skip CONNECT_CHAR
        //

        AdapterName += 1;

        if( AdapterName == '\0' )
            continue;

        strcpy( AdapterParamKey, SERVICES_KEY);
        strcat( AdapterParamKey, AdapterName);
        strcat( AdapterParamKey, KEY_CONNECT);
        strcat( AdapterParamKey, ADAPTER_TCPIP_PARMS_KEY );

        Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              AdapterParamKey,
                              0,
                              KEY_QUERY_VALUE,
                              &AdapterKeyHandle );

        if( Error != ERROR_SUCCESS )
             goto Skip;

        //
        // read DHCPEnableFlag.
        //

        Error =  GetRegistryValue( AdapterKeyHandle,
                                   FALSE,
                                   DHCP_ENABLED_VALUE,
                                   DHCP_ENABLED_VALUE_TYPE,
                                   (LPBYTE)&EnableDHCPFlag );

        if ( Error == ERROR_SUCCESS )
        {
            if ( EnableDHCPFlag )
            {
                AdapterInfoList[TotalNumberOfNets].IsDhcpEnabled = TRUE;

TryRas:

                //
                // Get the DHCP IP address value
                //
                Error =  GetRegistryValue( AdapterKeyHandle,
                                           FALSE,
                                           DHCP_ADDRESS_VALUE,
                                           DHCP_ADDRESS_VALUE_TYPE,
                                           (LPBYTE)&IpAddressString );

                if( Error != ERROR_SUCCESS )
                     goto Skip;

                AdapterInfoList[TotalNumberOfNets].pipAddresses =
                    GetIpArray( FALSE, IpAddressString );

                if ( IpAddressString )
                {
                    FREE_HEAP( IpAddressString );
                    IpAddressString = NULL;
                }

                //
                // Get the DHCP subnet mask value
                //
                Error =  GetRegistryValue( AdapterKeyHandle,
                                           FALSE,
                                           DHCP_SUBNET_VALUE,
                                           DHCP_SUBNET_VALUE_TYPE,
                                           (LPBYTE)&IpAddressString );

                if ( Error != ERROR_SUCCESS )
                {
                  if ( AdapterInfoList[TotalNumberOfNets].pipAddresses )
                  {
                    FREE_HEAP( AdapterInfoList[TotalNumberOfNets].pipAddresses );
                    AdapterInfoList[TotalNumberOfNets].pipAddresses = NULL;
                  }

                  goto Skip;
                }

                AdapterInfoList[TotalNumberOfNets].pipSubnetMasks =
                    GetMaskArray( FALSE, IpAddressString );

                //
                // add this adpter to the list only if the ip address is
                // non-zero.
                //
                if ( AdapterInfoList[TotalNumberOfNets].pipAddresses &&
                     AdapterInfoList[TotalNumberOfNets].pipSubnetMasks )
                {
                    TotalNumberOfNets++;
                }
                else
                {
                  if ( AdapterInfoList[TotalNumberOfNets].pipAddresses )
                  {
                    FREE_HEAP( AdapterInfoList[TotalNumberOfNets].pipAddresses );
                    AdapterInfoList[TotalNumberOfNets].pipAddresses = NULL;
                  }

                  if ( AdapterInfoList[TotalNumberOfNets].pipSubnetMasks )
                  {
                    FREE_HEAP( AdapterInfoList[TotalNumberOfNets].pipSubnetMasks );
                    AdapterInfoList[TotalNumberOfNets].pipSubnetMasks = NULL;
                  }
                }
            }
            else
            {
                AdapterInfoList[TotalNumberOfNets].IsDhcpEnabled = FALSE;

                //
                // Get the Static IP address value(s)
                //
                Error =  GetRegistryValue( AdapterKeyHandle,
                                           FALSE,
                                           STATIC_ADDRESS_VALUE,
                                           STATIC_ADDRESS_VALUE_TYPE,
                                           (LPBYTE)&IpAddressString );

                if ( Error != ERROR_SUCCESS )
                     goto TryRas;

                AdapterInfoList[TotalNumberOfNets].pipAddresses =
                    GetIpArray( TRUE, IpAddressString );

                if ( IpAddressString )
                {
                    FREE_HEAP( IpAddressString );
                    IpAddressString = NULL;
                }

                //
                // Get the Static subnet mask value
                //
                Error =  GetRegistryValue( AdapterKeyHandle,
                                           FALSE,
                                           STATIC_SUBNET_VALUE,
                                           STATIC_SUBNET_VALUE_TYPE,
                                           (LPBYTE)&IpAddressString );

                if ( Error != ERROR_SUCCESS )
                {
                  if ( AdapterInfoList[TotalNumberOfNets].pipAddresses )
                  {
                    FREE_HEAP( AdapterInfoList[TotalNumberOfNets].pipAddresses );
                    AdapterInfoList[TotalNumberOfNets].pipAddresses = NULL;
                  }

                  goto Skip;
                }

                AdapterInfoList[TotalNumberOfNets].pipSubnetMasks =
                    GetMaskArray( TRUE, IpAddressString );

                //
                // add this adpter to the list only if the ip address is
                // non-zero.
                //
                if ( AdapterInfoList[TotalNumberOfNets].pipAddresses &&
                     AdapterInfoList[TotalNumberOfNets].pipSubnetMasks )
                {
                    TotalNumberOfNets++;
                }
                else
                {
                  FREE_HEAP( IpAddressString );
                  IpAddressString = NULL;

                  if ( AdapterInfoList[TotalNumberOfNets].pipAddresses )
                  {
                    FREE_HEAP( AdapterInfoList[TotalNumberOfNets].pipAddresses );
                    AdapterInfoList[TotalNumberOfNets].pipAddresses = NULL;
                  }

                  if ( AdapterInfoList[TotalNumberOfNets].pipSubnetMasks )
                  {
                    FREE_HEAP( AdapterInfoList[TotalNumberOfNets].pipSubnetMasks );
                    AdapterInfoList[TotalNumberOfNets].pipSubnetMasks = NULL;
                  }

                  goto TryRas;
                }
            }
        }

Skip :

        if ( AdapterKeyHandle )
        {
            RegCloseKey( AdapterKeyHandle );
            AdapterKeyHandle = NULL;
        }

        if ( IpAddressString )
        {
            FREE_HEAP( IpAddressString );
            IpAddressString = NULL;
        }
    }

    //
    // We now have a data structure that represents the current
    // net adapters and assigned IP addresses based on the binding
    // order described by the adapter protocol bindings for TCPIP.
    //
    // Now stuff as many as we can into the users buffer provided.
    //

    //
    // Start by putting the first address from each adapter into the
    // IP list.
    //
    for ( iter = 0; iter < TotalNumberOfNets && ListCount; iter++ )
    {
        IpAddressInfoList[addressCount].ipAddress =
            AdapterInfoList[iter].pipAddresses->AddrArray[0];
        IpAddressInfoList[addressCount++].subnetMask =
            AdapterInfoList[iter].pipSubnetMasks->AddrArray[0];
        ListCount--;
    }

    for ( iter = 0; iter < TotalNumberOfNets && ListCount; iter++ )
    {
        for ( iter2 = 1;
              iter2 < AdapterInfoList[iter].pipAddresses->AddrCount;
              iter2++ )
        {
            IpAddressInfoList[addressCount].ipAddress =
                AdapterInfoList[iter].pipAddresses->AddrArray[iter2];
            IpAddressInfoList[addressCount++].subnetMask =
                AdapterInfoList[iter].pipSubnetMasks->AddrArray[iter2];
            ListCount--;
        }
    }

Cleanup:

    if( LinkageKeyHandle )
        RegCloseKey( LinkageKeyHandle );

    if( BindString )
        FREE_HEAP( BindString );

    if( AdapterKeyHandle )
        RegCloseKey( AdapterKeyHandle );

    if( IpAddressString )
        FREE_HEAP( IpAddressString );

    for ( iter = 0; iter < TotalNumberOfNets; iter++ )
    {
        if( AdapterInfoList[iter].pipAddresses )
            FREE_HEAP( AdapterInfoList[iter].pipAddresses );

        if( AdapterInfoList[iter].pipSubnetMasks )
            FREE_HEAP( AdapterInfoList[iter].pipSubnetMasks );
    }

    FREE_HEAP( AdapterInfoList );

    AdapterInfoList = NULL;

    return addressCount;
}

//
//  End iplist4.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\iplist.c ===
/*++

Copyright (c) 1994-2001  Microsoft Corporation

Module Name:

    iplist.c

Abstract:

    Domain Name System (DNS) Library

    Contains functions to get IP addresses from TCP/IP stack

    Contents:
        Dns_GetIpAddresses

Author:

    Glenn A Curtis (glennc) 10-Sept-1997

Revision History:

    10-Sept-1997 glennc
        Created

--*/


#include "local.h"


//
//  Temp structure for holding adapter IP info
//

typedef struct
{
    BOOL        IsDhcpEnabled;
    PIP_ARRAY   pIpAddrArray;
    PIP_ARRAY   pipSubnetMasks;
}
TEMP_ADAPTER_INFO, *PTEMP_ADAPTER_INFO;


//
//  DCR:  need IP6\cluster aware IP reading
//


/*******************************************************************************
 *
 *  Dns_GetIpAddresses
 *
 *  Retrieves all active IP addresses from all active adapters on this machine.
 *  Returns them as an array
 *
 *  ENTRY   IpAddressList   - pointer to array of IP addresses
 *          ListCount       - number of IP address IpAddressList can hold
 *
 *  EXIT    IpAddressList   - filled with retrieved IP addresses
 *
 *  RETURNS number of IP addresses retrieved, or 0 if error
 *
 *  ASSUMES 1. an IP address can be represented in a DWORD
 *          2. ListCount > 0
 *
 ******************************************************************************/

DWORD
Dns_GetIpAddresses(
    IN OUT  PDNS_ADDRESS_INFO   IpAddressInfoList,
    IN      DWORD               ListCount
    )
{
    DWORD               status = NO_ERROR;
    DWORD               addressCount = 0;
    DWORD               i;
    DWORD               j;
    DWORD               countAdapters;
    PTEMP_ADAPTER_INFO  ptempList = NULL;
    PIP_ARRAY           ptempArray = NULL;
    PIP_ADAPTER_INFO    padapterInfo = NULL;
    PIP_ADAPTER_INFO    ptempAdapterInfo = NULL;


    //
    //  clear result buffer
    //

    RtlZeroMemory(
        IpAddressInfoList,
        sizeof(DNS_ADDRESS_INFO) * ListCount
        );

    //
    //  read adapters info data.
    //

    status = IpHelp_GetAdaptersInfo( &padapterInfo );
    if ( status != ERROR_SUCCESS )
    {
        return 0;
    }

    //
    // Count up the number of active adapters
    //

    ptempAdapterInfo = padapterInfo;
    countAdapters = 0;

    while ( ptempAdapterInfo )
    {
        ptempAdapterInfo = ptempAdapterInfo->Next;
        countAdapters++;
    }

    //
    // allocate memory for the TEMP_ADAPTER_INFO array.
    //

    ptempList = ALLOCATE_HEAP_ZERO( sizeof(TEMP_ADAPTER_INFO) * countAdapters );
    ptempArray = DnsCreateIpArray( DNS_MAX_IP_INTERFACE_COUNT );

    if ( !ptempList || !ptempArray )
    {
        goto Cleanup;
    }

    //
    //  build temp structure for each adapter:
    //      - IP array
    //      - subnet array
    //      - DHCP enabled flag
    //
    //  note that IP and subnet arrays are in reverse order from IP help
    //  to preserve binding order for gethostbyname()
    //
    //  DCR:  should have single interface (DNS_ADAPTER) build routine
    //      and use it to build specific sub-info like global IP list
    //  DCR:  also IPs returned should be name specific -- matching only
    //      those on a particular adapter
    //

    countAdapters = 0;
    ptempAdapterInfo = padapterInfo;

    while ( ptempAdapterInfo )
    {
        PIP_ARRAY  parray;

        ptempList[countAdapters].IsDhcpEnabled = ptempAdapterInfo->DhcpEnabled;

        //  build IP array
        ptempArray->AddrCount = 0;
        status = IpHelp_ParseIpAddressString(
                        ptempArray,
                        &ptempAdapterInfo->IpAddressList,
                        FALSE,      // Get the ip address
                        TRUE );     // Reverse the order

        if ( status != NO_ERROR ||
             ! (parray = Dns_CreateIpArrayCopy( ptempArray )) )
        {
            goto Next;
        }
        ptempList[countAdapters].pIpAddrArray = parray;

        //  subnet array

        ptempArray->AddrCount = 0;
        status = IpHelp_ParseIpAddressString(
                        ptempArray,
                        &ptempAdapterInfo->IpAddressList,
                        TRUE,       // Get the subnet mask
                        TRUE );     // Reverse the order

        if ( status != NO_ERROR ||
             ! (parray = Dns_CreateIpArrayCopy( ptempArray )) )
        {
            FREE_HEAP( ptempList[countAdapters].pIpAddrArray );
            goto Next;
        }
        ptempList[countAdapters].pipSubnetMasks = parray;

        countAdapters++;

Next:

        ptempAdapterInfo = ptempAdapterInfo->Next;
    }

    //
    //  fill up address info blob
    //      - fill with first IP on each adapter
    //      - then fill with remaining IPs
    //

    addressCount = 0;

    for ( i = 0;
          (i < countAdapters) && ListCount;
          i++ )
    {
        IpAddressInfoList[addressCount].ipAddress =
            ptempList[i].pIpAddrArray->AddrArray[0];
        IpAddressInfoList[addressCount].subnetMask =
            ptempList[i].pipSubnetMasks->AddrArray[0];

        ListCount--;
        addressCount++;
    }

    for ( i = 0;
          (i < countAdapters) && ListCount;
          i++ )
    {
        for ( j = 1;
              j < ptempList[i].pIpAddrArray->AddrCount && ListCount;
              j++ )
        {
            IpAddressInfoList[addressCount].ipAddress =
                ptempList[i].pIpAddrArray->AddrArray[j];
            IpAddressInfoList[addressCount].subnetMask =
                ptempList[i].pipSubnetMasks->AddrArray[j];

            ListCount--;
            addressCount++;
        }
    }

Cleanup:

    if ( padapterInfo )
    {
        FREE_HEAP( padapterInfo );
    }

    if ( ptempArray )
    {
        FREE_HEAP( ptempArray );
    }

    if ( ptempList )
    {
        for ( i = 0; i < countAdapters; i++ )
        {
            if( ptempList[i].pIpAddrArray )
                FREE_HEAP( ptempList[i].pIpAddrArray );

            if( ptempList[i].pipSubnetMasks )
                FREE_HEAP( ptempList[i].pipSubnetMasks );
        }
        FREE_HEAP( ptempList );
    }

    return addressCount;
}


PIP_ARRAY
Dns_GetLocalIpAddressArray(
    VOID
    )
/*++

Routine Description:

    Return the local IP list as IP array.

Arguments:

    None.

Return Value:

    Ptr to IP array of addresses on local machine.
    NULL only on memory allocation failure.

--*/
{
    DWORD             count;
    DWORD             i;
    PIP_ARRAY         pipArray;
    PDNS_ADDRESS_INFO pipInfo = NULL;

    DNSDBG( NETINFO, ( "Dns_GetLocalIpAddressArray()\n" ));

    pipInfo = ALLOCATE_HEAP( DNS_MAX_IP_INTERFACE_COUNT *
                             sizeof(DNS_ADDRESS_INFO) );
    if ( !pipInfo )
    {
        return NULL;
    }

    count = Dns_GetIpAddresses(
                pipInfo,
                DNS_MAX_IP_INTERFACE_COUNT );

    pipArray = Dns_CreateIpArray( count );
    if ( pipArray )
    {
        for ( i = 0; i < count; i++ )
        {
            pipArray->AddrArray[i] = pipInfo[i].ipAddress;
        }
    }

    FREE_HEAP( pipInfo );

    return pipArray;
}

//
//  End iplist.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\iphelp.c ===
/*++

Copyright (c) 2001-2001   Microsoft Corporation

Module Name:

    iphelp.c

Abstract:

    IP help API routines.

Author:

    Jim Gilroy (jamesg)     January 2001

Revision History:

--*/


#include "local.h"



BOOL
IpHelp_Initialize(
    VOID
    )
/*++

Routine Description:

    Startup IP Help API

Arguments:

    None

Return Value:

    TRUE if started successfully.
    FALSE on error.

--*/
{
    return  TRUE;
}



VOID
IpHelp_Cleanup(
    VOID
    )
/*++

Routine Description:

    Cleanup IP Help API

Arguments:

    None

Return Value:

    None

--*/
{
}



DNS_STATUS
IpHelp_GetAdaptersInfo(
    OUT     PIP_ADAPTER_INFO *  ppAdapterInfo
    )
/*++

Routine Description:

    Call IP Help GetAdaptersInfo()

Arguments:

    ppAdapterInfo -- addr to receive pointer to adapter info retrieved

Return Value:

    None

--*/
{
    DNS_STATUS          status = NO_ERROR;
    DWORD               bufferSize;
    INT                 fretry;
    PIP_ADAPTER_INFO    pbuf;


    DNSDBG( TRACE, (
        "GetAdaptersInfo( %p )\n",
        ppAdapterInfo ));

    //
    //  init IP Help (no-op) if already done
    //  

    *ppAdapterInfo = NULL;

    //
    //  call down to get buffer size
    //
    //  start with reasonable alloc, then bump up if too small
    //

    fretry = 0;
    bufferSize = 1000;

    while ( fretry < 2 )
    {
        pbuf = (PIP_ADAPTER_INFO) ALLOCATE_HEAP( bufferSize );
        if ( !pbuf )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto  Unlock;
        }
    
        status = (DNS_STATUS) GetAdaptersInfo(
                                    pbuf,
                                    &bufferSize );
        if ( status == NO_ERROR )
        {
            break;
        }

        FREE_HEAP( pbuf );
        pbuf = NULL;

        //  if buf too small on first try,
        //  continue to retry with suggested buffer size

        if ( status == ERROR_BUFFER_OVERFLOW ||
             status == ERROR_INSUFFICIENT_BUFFER )
        {
            fretry++;
            continue;
        }

        //  any other error is terminal

        DNSDBG( ANY, (
            "ERROR:  GetAdapterInfo() failed with error %d\n",
            status ));
        status = DNS_ERROR_NO_DNS_SERVERS;
        break;
    }

    DNS_ASSERT( !pbuf || status==NO_ERROR );

    if ( status == NO_ERROR )
    {
        *ppAdapterInfo = pbuf;
    }

Unlock:

    DNSDBG( TRACE, (
        "Leave GetAdaptersInfo() => %d\n",
        status ));

    return  status;
}



DNS_STATUS
IpHelp_GetPerAdapterInfo(
    IN      DWORD                   AdapterIndex,
    OUT     PIP_PER_ADAPTER_INFO  * ppPerAdapterInfo
    )
/*++

Routine Description:

    Call IP Help GetPerAdapterInfo()

Arguments:

    AdapterIndex -- index of adapter to get info for

    ppPerAdapterInfo -- addr to receive pointer to per adapter info

Return Value:

    None

--*/
{
    DNS_STATUS              status = NO_ERROR;
    DWORD                   bufferSize;
    INT                     fretry;
    PIP_PER_ADAPTER_INFO    pbuf;


    DNSDBG( TRACE, (
        "GetPerAdapterInfo( %d, %p )\n",
        AdapterIndex,
        ppPerAdapterInfo ));

    //
    //  init IP Help (no-op) if already done
    //  

    *ppPerAdapterInfo = NULL;

    //
    //  call down to get buffer size
    //
    //  start with reasonable alloc, then bump up if too small
    //

    fretry = 0;
    bufferSize = 1000;

    while ( fretry < 2 )
    {
        pbuf = (PIP_PER_ADAPTER_INFO) ALLOCATE_HEAP( bufferSize );
        if ( !pbuf )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Unlock;
        }
    
        status = (DNS_STATUS) GetPerAdapterInfo(
                                    AdapterIndex,
                                    pbuf,
                                    &bufferSize );
        if ( status == NO_ERROR )
        {
            break;
        }

        FREE_HEAP( pbuf );
        pbuf = NULL;

        //  if buf too small on first try,
        //  continue to retry with suggested buffer size

        if ( status == ERROR_BUFFER_OVERFLOW ||
             status == ERROR_INSUFFICIENT_BUFFER )
        {
            fretry++;
            continue;
        }

        //  any other error is terminal

        DNSDBG( ANY, (
            "ERROR:  GetAdapterInfo() failed with error %d\n",
            status ));
        status = DNS_ERROR_NO_DNS_SERVERS;
        break;
    }

    DNS_ASSERT( !pbuf || status==NO_ERROR );

    if ( status == NO_ERROR )
    {
        *ppPerAdapterInfo = pbuf;
    }

Unlock:

    DNSDBG( TRACE, (
        "Leave GetPerAdapterInfo() => %d\n",
        status ));

    return  status;
}




DNS_STATUS
IpHelp_GetBestInterface(
    IN      IP4_ADDRESS     Ip4Addr,
    OUT     PDWORD          pdwInterfaceIndex
    )
/*++

Routine Description:

    Call IP Help GetBestInterface()

Arguments:

    Ip4Addr -- IP address to check

    pdwInterfaceIndex -- addr to recv interface index

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status;

    DNSDBG( TRACE, (
        "GetBestInterface( %08x, %p )\n",
        Ip4Addr,
        pdwInterfaceIndex ));

    //
    //  init IP Help (no-op) if already done
    //  

    status = (DNS_STATUS) GetBestInterface(
                                Ip4Addr,
                                pdwInterfaceIndex );
    
    DNSDBG( TRACE, (
        "Leave GetBestInterface() => %d\n"
        "\tinterface = %d\n",
        status,
        *pdwInterfaceIndex ));

    return  status;
}



DNS_STATUS
IpHelp_ParseIpAddressString(
    IN OUT  PIP_ARRAY       pIpArray,
    IN      PIP_ADDR_STRING pIpAddrString,
    IN      BOOL            fGetSubnetMask,
    IN      BOOL            fReverse
    )
/*++

Routine Description:

    Build IP array from IP help IP_ADDR_STRING structure.

Arguments:

    pIpArray -- IP array of DNS servers

    pIpAddrString -- pointer to address info with address data

    fGetSubnetMask -- get subnet masks

    fReverse -- reverse the IP array

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_NO_DNS_SERVERS if nothing parsed.

--*/
{
    PIP_ADDR_STRING pipBlob = pIpAddrString;
    IP_ADDRESS      ip;
    DWORD           countServers = pIpArray->AddrCount;

    DNSDBG( TRACE, (
        "IpHelp_ParseIpAddressString()\n"
        "\tout IP array = %p\n"
        "\tIP string    = %p\n"
        "\tsubnet?      = %d\n"
        "\treverse?     = %d\n",
        pIpArray,
        pIpAddrString,
        fGetSubnetMask,
        fReverse ));

    //
    //  loop reading IP or subnet
    //
    //  DCR_FIX0:  address and subnet will be misaligned if read separately
    //
    //  DCR:  move to count\allocate model and if getting subnets get together
    //

    while ( pipBlob &&
            countServers < DNS_MAX_IP_INTERFACE_COUNT )
    {
        if ( fGetSubnetMask )
        {
            ip = inet_addr( pipBlob->IpMask.String );

            if ( ip != INADDR_ANY )
            {
                pIpArray->AddrArray[ countServers ] = ip;
                countServers++;
            }
        }
        else
        {
            ip = inet_addr( pipBlob->IpAddress.String );

            if ( ip != INADDR_ANY && ip != INADDR_NONE )
            {
                pIpArray->AddrArray[ countServers ] = ip;
                countServers++;
            }
        }

        pipBlob = pipBlob->Next;
    }

    //  reset IP count

    pIpArray->AddrCount = countServers;

    //  reverse array if desired

    if ( fReverse )
    {
        Dns_ReverseOrderOfIpArray( pIpArray );
    }

    DNSDBG( NETINFO, (
        "Leave IpHelp_ParseIpAddressString()\n"
        "\tcount    = %d\n"
        "\tfirst IP = %s\n",
        countServers,
        countServers
            ? IP_STRING( pIpArray->AddrArray[0] )
            : "" ));

    return  ( pIpArray->AddrCount ) ? ERROR_SUCCESS : DNS_ERROR_NO_DNS_SERVERS;
}

//
//  End iphelp.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\iplist2.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    iplist.c

Abstract:

    Contains functions to get IP addresses from TCP/IP stack

    Contents:
        DnsGetIpAddressList

Author:

    Glenn A. Curtis (glennc) 05-May-1197

Revision History:


--*/

//
// includes
//

#include "local.h"


#if 0
/*******************************************************************************
 *
 *  DnsGetIpAddressList
 *
 *  Retrieves all active IP addresses from all active adapters on this machine.
 *  Returns them as an array
 *
 *  EXIT    IpAddressList   - filled with retrieved IP addresses
 *                            memory freed with FREE_HEAP
 *
 *  RETURNS number of IP addresses retrieved, or 0 if error
 *
 *  ASSUMES 1. an IP address can be represented in a DWORD
 *
 ******************************************************************************/

DWORD
DnsGetIpAddressList(
    OUT PIP_ARRAY * ppIpAddresses
    )
{
    DWORD      RpcStatus = NO_ERROR;
    PDNS_IP_ADDR_LIST pIpAddrList = NULL;
    DWORD      Count;
    DWORD      iter = 0;
    DWORD      iter2 = 0;

    *ppIpAddresses = NULL;

    if ( !g_IsWin9X )
    {
        ENVAR_DWORD_INFO    filterInfo;

        //  get config including environment variable

        Dns_ReadDwordEnvar(
           DnsRegFilterClusterIp,
           &filterInfo );

        RpcTryExcept
        {
            Count = R_ResolverGetIpAddressList(
                        NULL,
                        &pIpAddrList,
                        filterInfo
                        );
        }
        RpcExcept( DNS_RPC_EXCEPTION_FILTER )
        {
            RpcStatus = RpcExceptionCode();
        }
        RpcEndExcept

    }
    else
        RpcStatus = RPC_S_SERVER_UNAVAILABLE;

    if ( RpcStatus )
    {
        *ppIpAddresses = Dns_GetLocalIpAddressArray();

        if ( *ppIpAddresses )
        {
            if ( (*ppIpAddresses)->AddrCount == 0 )
            {
                FREE_HEAP( *ppIpAddresses );
                *ppIpAddresses = NULL;
                return 0;
            }
            else
            {
                return (*ppIpAddresses)->AddrCount;
            }
        }
        else
            return 0;
    }

    if ( Count && pIpAddrList )
    {
        *ppIpAddresses = DnsCreateIpArray( Count );

        if ( *ppIpAddresses == NULL )
        {
            FREE_HEAP( pIpAddrList );
            return 0;
        }

        for ( iter = 0; iter < pIpAddrList->dwAddressCount; iter++ )
        {
            if ( Dns_AddIpToIpArray( *ppIpAddresses,
                                     pIpAddrList ->
                                     AddressArray[iter].ipAddress ) )
            {
                iter2++;
            }
        }

        FREE_HEAP( pIpAddrList );
    }

    return iter2;
}


DWORD
DnsGetIpAddressInfoList(
    OUT     PDNS_ADDRESS_INFO * ppAddrInfo
    )
{
    DWORD      RpcStatus = NO_ERROR;
    PDNS_IP_ADDR_LIST pIpAddrList = NULL;
    DWORD      Count;
    DWORD      iter = 0;

    *ppAddrInfo = NULL;

    if ( !g_IsWin9X )
    {
        RpcTryExcept
        {
            Count = CRrGetIpAddressList( NULL, &pIpAddrList );
        }
        RpcExcept( DNS_RPC_EXCEPTION_FILTER )
        {
            RpcStatus = RpcExceptionCode();
        }
        RpcEndExcept
    }
    else
        RpcStatus = RPC_S_SERVER_UNAVAILABLE;

    if ( RpcStatus )
    {
        DNS_ADDRESS_INFO ipInfoArray[256];

        Count = Dns_GetIpAddresses( ipInfoArray, 256 );

        if ( Count )
        {
            *ppAddrInfo = (PDNS_ADDRESS_INFO )
                          ALLOCATE_HEAP( Count * sizeof( DNS_ADDRESS_INFO ) );

            if ( *ppAddrInfo == NULL )
                return 0;

            for ( iter = 0; iter < Count; iter++ )
            {
                (*ppAddrInfo)[iter].ipAddress = ipInfoArray[iter].ipAddress;
                (*ppAddrInfo)[iter].subnetMask = ipInfoArray[iter].subnetMask;
            }
        }

        return Count;
    }

    if ( Count && pIpAddrList )
    {
        *ppAddrInfo = (PDNS_ADDRESS_INFO )
                      ALLOCATE_HEAP( Count * sizeof( DNS_ADDRESS_INFO ) );

        if ( *ppAddrInfo == NULL )
        {
            FREE_HEAP( pIpAddrList );

            return 0;
        }

        if ( pIpAddrList->dwAddressCount < Count )
        {
            Count = pIpAddrList->dwAddressCount;
        }

        for ( iter = 0; iter < Count; iter++ )
        {
            (*ppAddrInfo)[iter].ipAddress =
                pIpAddrList->AddressArray[iter].ipAddress;
            (*ppAddrInfo)[iter].subnetMask =
                pIpAddrList->AddressArray[iter].subnetMask;
        }

        FREE_HEAP( pIpAddrList );
    }

    return Count;
}
#endif


DWORD
DnsGetDnsServerList(
    OUT     PIP_ARRAY *     ppDnsAddresses
    )
{
    PDNS_NETINFO      pNetworkInfo;
    PIP_ARRAY         pserverIpArray;

    if ( ! ppDnsAddresses )
    {
        return 0;
    }

    *ppDnsAddresses = NULL;

    DNSDBG( TRACE, ( "DnsGetDnsServerList()\n" ));

    pNetworkInfo = GetNetworkInfo();
    if ( !pNetworkInfo )
    {
        return 0;
    }

    pserverIpArray = NetInfo_ConvertToIpArray( pNetworkInfo );

    NetInfo_Free( pNetworkInfo );

    if ( !pserverIpArray )
    {
        return 0;
    }

    //  if no servers read, return

    if ( pserverIpArray->AddrCount == 0 )
    {
        FREE_HEAP( pserverIpArray );
        return 0;
    }

    *ppDnsAddresses = pserverIpArray;

    return( pserverIpArray->AddrCount );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\logit.c ===
/*****************************************\
 *        Data Logging -- Debug only      *
\*****************************************/

//
//  Precompiled header
//  Note -- this is not required for this modules.
//  It is included only to allow use of precompiled header.
//

#include "local.h"

#if 0
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#endif


#pragma  hdrstop

#include "logit.h"

// #if DBG

int LoggingMode;
time_t  long_time;      // has to be in DS, assumed by time() funcs
int LineCount;

char    *month[] =
{
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
} ;


/*
 -  LogInit
 -
 *  Purpose:
 *  Determines if logging is desired and if so, adds a header to log file.
 *
 *  Parameters:
 *
 */
void LogInit( LPSTR Filename )
{
    FILE    *fp;
    struct  tm  *newtime;
    char    am_pm[] = "a.m.";

    LoggingMode = 0;
    LineCount = 0;

    if ( fp = fopen( Filename, "r+" ) )
    {
        LoggingMode = 1;
        fclose( fp );

        // Get time and date information

        long_time = time( NULL);        /* Get time as long integer. */
        newtime = localtime( &long_time ); /* Convert to local time. */

        if( newtime->tm_hour > 12 )    /* Set up extension. */
            am_pm[0] = 'p';
        if( newtime->tm_hour > 12 )    /* Convert from 24-hour */
            newtime->tm_hour -= 12;    /*   to 12-hour clock.  */
        if( newtime->tm_hour == 0 )    /*Set hour to 12 if midnight. */
            newtime->tm_hour = 12;

        // Write out a header to file

        fp = fopen(Filename, "a" );

        fprintf( fp, "Logging information for DNS API source file\n" );
        fprintf( fp, "****************************************************\n" );
        fprintf( fp, "\tTime: %d:%02d %s\n\tDate: %s %d, 19%d\n", 
                 newtime->tm_hour, newtime->tm_min, am_pm,
                 month[newtime->tm_mon], newtime->tm_mday,
                 newtime->tm_year );
        fprintf( fp, "****************************************************\n\n" );
        fclose( fp );
    }
}


/*
 -  LogIt
 -
 *  Purpose:
 *  Formats a string and prints it to a log file with handle hLog.
 *
 *  Parameters:
 *  LPSTR - Pointer to string to format
 *  ...   - variable argument list
 */

void CDECL LogIt( LPSTR Filename, char * lpszFormat, ... )
{
    FILE *  fp;
    va_list pArgs;
    char    szLogStr[1024];    
    int     i;

    if ( !LoggingMode )
        return;
    
    va_start( pArgs, lpszFormat);
    vsprintf(szLogStr, lpszFormat, pArgs);
    va_end(pArgs);

    i = strlen( szLogStr);
    szLogStr[i] = '\n';
    szLogStr[i+1] = '\0';


    if ( LineCount > 50000 )
    {
        fp = fopen( Filename, "w" );
        LineCount = 0;
    }
    else
    {
        fp = fopen( Filename, "a" );
    }
    if( fp)
    {   // if we can't open file, do nothing
        fprintf( fp, szLogStr );
        LineCount++;
        fclose( fp );
    }
}


void LogTime( LPSTR Filename )
{
    struct  tm  *newtime;
    char    am_pm[] = "a.m.";

    if ( !LoggingMode )
        return;

    // Get time and date information

    long_time = time( NULL);        /* Get time as long integer. */
    newtime = localtime( &long_time ); /* Convert to local time. */

    if ( !newtime )
        return;

    if( newtime->tm_hour > 12 )    /* Set up extension. */
        am_pm[0] = 'p';
    if( newtime->tm_hour > 12 )    /* Convert from 24-hour */
        newtime->tm_hour -= 12;    /*   to 12-hour clock.  */
    if( newtime->tm_hour == 0 )    /*Set hour to 12 if midnight. */
        newtime->tm_hour = 12;

    // Write out a header to file

    LogIt( Filename, "DNS CLIENT API" );
    LogIt( Filename, "System Time Information" );
    LogIt( Filename, "****************************************************" );
    LogIt( Filename, "\tTime: %d:%02d %s\n\tDate: %s %d, 19%d",
           newtime->tm_hour, newtime->tm_min, am_pm,
           month[newtime->tm_mon], newtime->tm_mday,
           newtime->tm_year );
    LogIt( Filename, "****************************************************" );
    LogIt( Filename, "" );
}


DWORD LogIn( LPSTR Filename, char * string )
{
    LogIt( Filename, "%s", string );
    return GetTickCount();
}


void LogOut( LPSTR Filename, char * string, DWORD InTime )
{
    LogIt( Filename, "%s  ---  Duration: %ld milliseconds",
           string, GetTickCount() - InTime );
}


// #endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\iplist9x.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    iplist9x.c

Abstract:

    Domain Name System (DNS) Library

    NT4 version of routines to get IP addresses of stack.

    Contents:
        Dns_GetIpAddressesWin9X
        Dns_GetLocalIpAddressArrayWin9X

Author:

    Glenn A. Curtis (glennc) 05-May-1997

Revision History:

    05-May-1997 glennc
        Copied from the (NT4 SP3) winsock2 directory

--*/

//
// includes
//

#include "local.h"

#define WIN95_TCPIP_PARAMETERS_KEY       "System\\CurrentControlSet\\Services\\VxD\\MSTCP"
#define WIN95_DHCP_KEY                   "System\\CurrentControlSet\\Services\\VxD\\DHCP"
#define WIN95_NET_TRANS_KEY              "System\\CurrentControlSet\\Services\\Class\\NetTrans"
#define DHCP_IP_ADDRESS_VALUE_WIN95      "DhcpIPAddress"
#define DHCP_SUBNET_VALUE_WIN95          "DhcpSubnetMask"
#define STATIC_ADDRESS_VALUE             "IPAddress"
#define STATIC_SUBNET_VALUE              "IPMask"
#define DHCP_INFO_VALUE                  "DhcpInfo"
#define DRIVER_DESCRIPTION_VALUE         "DriverDesc"
#define TCPIP_DRIVER_DESCRIPTION         "TCP/IP"
#define NDISWAN_DRIVER_DESCRIPTION       "NDISWAN"
#define KEY_CONNECT                      "\\"
#define KEY_CONNECT_CHAR                 '\\'
#define DHCP_IP_ADDRESS_VALUE_TYPE_WIN95 REG_DWORD
#define DHCP_SUBNET_VALUE_TYPE_WIN95     REG_DWORD
#define STATIC_ADDRESS_VALUE_TYPE        REG_SZ
#define STATIC_SUBNET_VALUE_TYPE         REG_SZ
#define DHCP_INFO_VALUE_TYPE             REG_BINARY
#define DRIVER_DESCRIPTION_VALUE_TYPE    REG_SZ

typedef DWORD IP_ADDRESS, *PIP_ADDRESS;

typedef struct _ADAPTER_INFO_
{
    BOOL        IsDhcpEnabled;
    PIP_ARRAY   pipAddresses;
    PIP_ARRAY   pipSubnetMasks;

} ADAPTER_INFO, *LPADAPTER_INFO;


//
//  Heap operations
//

#define ALLOCATE_HEAP(size)         Dns_AllocZero( size )
#define REALLOCATE_HEAP(p,size)     Dns_Realloc( (p), (size) )
#define FREE_HEAP(p)                Dns_Free( p )
#define ALLOCATE_HEAP_ZERO(size)    Dns_AllocZero( size )


//
// functions
//

PIP_ARRAY
GetIpArray(
    BOOL  IsMultiSzString,
    LPSTR IpAddressString )
{
    DWORD      NumberOfAddresses;
    DWORD      StringLen;
    LPSTR      StringPtr;
    DWORD      iter;
    PIP_ARRAY  pIpArray = NULL;

    //
    // determine number of strings in IpAddressString, that many
    // addresses are assigned.
    //

    StringPtr = IpAddressString;
    NumberOfAddresses = 0;
    while ( ( StringLen = strlen( StringPtr ) ) != 0 )
    {
        //
        // found another NET.
        //
        NumberOfAddresses++;
        if ( IsMultiSzString )
            StringPtr += (StringLen + 1);
        else
            StringPtr += StringLen;
    }

    //
    // allocate memory for the ADAPTER_INFO array.
    //

    pIpArray =
        ALLOCATE_HEAP_ZERO( sizeof(IP_ADDRESS) * NumberOfAddresses +
                            sizeof(IP_ARRAY) );

    if( pIpArray == NULL )
    {
        return NULL;
    }

    //
    // enum the addresses.
    //

    StringPtr = IpAddressString;
    NumberOfAddresses = 0;

    while ( ( StringLen = strlen( StringPtr ) ) != 0 )
    {
        IP_ADDRESS ip;

        ip = inet_addr( StringPtr );

        if( ip != INADDR_ANY && ip != INADDR_NONE )
        {
            pIpArray->AddrArray[NumberOfAddresses] = ip;
            NumberOfAddresses++;
        }

        if ( IsMultiSzString )
            StringPtr += (StringLen + 1);
        else
            StringPtr += StringLen;
    }

    pIpArray->AddrCount = NumberOfAddresses;

    if ( pIpArray->AddrCount == 0 )
    {
        FREE_HEAP( pIpArray );
        pIpArray = NULL;
    }

    return pIpArray;
}


PIP_ARRAY
GetMaskArray(
    BOOL  IsMultiSzString,
    LPSTR SubnetMaskString )
{
    DWORD      NumberOfAddresses;
    DWORD      StringLen;
    LPSTR      StringPtr;
    DWORD      iter;
    PIP_ARRAY  pIpArray = NULL;

    //
    // determine number of strings in SubnetMaskString, that many
    // addresses are assigned.
    //

    StringPtr = SubnetMaskString;
    NumberOfAddresses = 0;
    while ( ( StringLen = strlen( StringPtr ) ) != 0 )
    {
        //
        // found another NET.
        //
        NumberOfAddresses++;
        if ( IsMultiSzString )
            StringPtr += (StringLen + 1);
        else
            StringPtr += StringLen;
    }

    //
    // allocate memory for the ADAPTER_INFO array.
    //

    pIpArray =
        ALLOCATE_HEAP_ZERO( sizeof(IP_ADDRESS) * NumberOfAddresses +
                            sizeof(IP_ARRAY) );

    if( pIpArray == NULL )
    {
        return NULL;
    }

    //
    // enum the addresses.
    //

    StringPtr = SubnetMaskString;
    NumberOfAddresses = 0;

    while ( ( StringLen = strlen( StringPtr ) ) != 0 )
    {
        IP_ADDRESS ip;

        ip = inet_addr( StringPtr );

        if( ip != INADDR_ANY )
        {
            pIpArray->AddrArray[NumberOfAddresses] = ip;
            NumberOfAddresses++;
        }

        if ( IsMultiSzString )
            StringPtr += (StringLen + 1);
        else
            StringPtr += StringLen;
    }

    pIpArray->AddrCount = NumberOfAddresses;

    if ( pIpArray->AddrCount == 0 )
    {
        FREE_HEAP( pIpArray );
        pIpArray = NULL;
    }

    return pIpArray;
}


/*******************************************************************************
 *
 *  Dns_GetIpAddressesWin9X
 *
 *  Retrieves all active IP addresses from all active adapters on this machine.
 *  Returns them as an array
 *
 *  ENTRY   IpAddressList   - pointer to array of IP addresses
 *          ListCount       - number of IP address IpAddressList can hold
 *
 *  EXIT    IpAddressList   - filled with retrieved IP addresses
 *
 *  RETURNS number of IP addresses retrieved, or 0 if error
 *
 *  ASSUMES 1. an IP address can be represented in a DWORD
 *          2. ListCount > 0
 *
 ******************************************************************************/

DWORD
Dns_GetIpAddressesWin9X(
    IN OUT PDNS_ADDRESS_INFO IpAddressInfoList,
    IN     DWORD             ListCount
    )
{
    DWORD          status = NO_ERROR;
    DWORD          addressCount = 0;
    DWORD          iter, iter2;
    DWORD          TotalNumberOfNets;
    HKEY           AdapterKeyHandle = NULL;
    LPADAPTER_INFO AdapterInfoList = NULL;

    RtlZeroMemory( IpAddressInfoList, sizeof( DNS_ADDRESS_INFO ) * 10 );

    //
    // allocate memory for the ADAPTER_INFO array.
    //

    AdapterInfoList =
        ALLOCATE_HEAP( sizeof(ADAPTER_INFO) * 10 );

    if( !AdapterInfoList )
        return 0;

    //
    // enum the static and WAN networks.
    //

    TotalNumberOfNets = 0;

    for ( iter = 0; iter < 10; iter++ )
    {
        char   AdapterParamKey[256];
        DWORD  dwFlags = 0;
        char   szCount[4];
        LPSTR  DriverDescription = NULL;
        LPSTR  IpAddressString = NULL;

        //
        // open Parameter key of the adapter that is bound to TCPIP.
        //
        sprintf( szCount, "%d", iter );

        strcpy( AdapterParamKey, WIN95_NET_TRANS_KEY );
        strcat( AdapterParamKey, "\\000" );
        strcat( AdapterParamKey, szCount );

        status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                               AdapterParamKey,
                               0,
                               KEY_QUERY_VALUE,
                               &AdapterKeyHandle );

        if ( status != ERROR_SUCCESS )
        {
            AdapterKeyHandle = NULL;
            goto Skip1;
        }

        //
        // See if this is a TCPIP adapter
        //
        status = GetRegistryValue( AdapterKeyHandle,
                                   TRUE,
                                   DRIVER_DESCRIPTION_VALUE,
                                   DRIVER_DESCRIPTION_VALUE_TYPE,
                                   (LPBYTE)&DriverDescription );

        if ( status != ERROR_SUCCESS || !DriverDescription )
            goto Skip1;

        if ( DriverDescription &&
             strlen( DriverDescription ) == 0 )
        {
            FREE_HEAP( DriverDescription );
            goto Skip1;
        }

        if ( strcmp( DriverDescription, TCPIP_DRIVER_DESCRIPTION ) )
        {
            FREE_HEAP( DriverDescription );
            goto Skip1;
        }

        FREE_HEAP( DriverDescription );

        //
        // This is a TCP/IP adapter, now see if there is an address
        // assigned to it
        //
        status = GetRegistryValue( AdapterKeyHandle,
                                   TRUE,
                                   STATIC_ADDRESS_VALUE,
                                   STATIC_ADDRESS_VALUE_TYPE,
                                   (LPBYTE)&IpAddressString );

        if ( status != ERROR_SUCCESS )
            goto Skip1;

        AdapterInfoList[TotalNumberOfNets].IsDhcpEnabled = FALSE;
        AdapterInfoList[TotalNumberOfNets].pipAddresses =
            GetIpArray( FALSE, IpAddressString );

        FREE_HEAP( IpAddressString );
        IpAddressString = NULL;

        if ( !AdapterInfoList[TotalNumberOfNets].pipAddresses )
            goto Skip1;

        status = GetRegistryValue( AdapterKeyHandle,
                                   TRUE,
                                   STATIC_SUBNET_VALUE,
                                   STATIC_SUBNET_VALUE_TYPE,
                                   (LPBYTE)&IpAddressString );

        if ( status != ERROR_SUCCESS )
        {
            FREE_HEAP( AdapterInfoList[TotalNumberOfNets].pipAddresses );
            AdapterInfoList[TotalNumberOfNets].pipAddresses = NULL;
            goto Skip1;
        }

        AdapterInfoList[TotalNumberOfNets].pipSubnetMasks =
            GetMaskArray( FALSE, IpAddressString );

        FREE_HEAP( IpAddressString );
        IpAddressString = NULL;

        if ( !AdapterInfoList[TotalNumberOfNets].pipSubnetMasks )
        {
            FREE_HEAP( AdapterInfoList[TotalNumberOfNets].pipAddresses );
            AdapterInfoList[TotalNumberOfNets].pipAddresses = NULL;
            goto Skip1;
        }

        TotalNumberOfNets++;

Skip1 :

        status = ERROR_SUCCESS;

        if ( AdapterKeyHandle )
        {
            RegCloseKey( AdapterKeyHandle );
            AdapterKeyHandle = NULL;
        }
    }

    if ( TotalNumberOfNets )
        goto Exit;

    //
    // Loop through each DHCP binding to read the adapter information.
    //
    for ( iter = 0; iter < 8; iter++ )
    {
        char   AdapterParamKey[256];
        DWORD  dwFlags = 0;
        char   szCount[4];
        DWORD  IpAddress = 0;
        DWORD  SubnetMask = 0;

        //
        // open Parameter key of the adapter that is bound to DHCP.
        //
        sprintf( szCount, "0%d", iter );

        strcpy( AdapterParamKey, WIN95_DHCP_KEY );
        strcat( AdapterParamKey, "\\DhcpInfo" );
        strcat( AdapterParamKey, szCount );

        status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                               AdapterParamKey,
                               0,
                               KEY_QUERY_VALUE,
                               &AdapterKeyHandle );

        if ( status != ERROR_SUCCESS )
        {
            AdapterKeyHandle = NULL;
            goto Skip2;
        }

        status = GetRegistryValue( AdapterKeyHandle,
                                   TRUE,
                                   DHCP_IP_ADDRESS_VALUE_WIN95,
                                   DHCP_IP_ADDRESS_VALUE_TYPE_WIN95,
                                   (LPBYTE)&IpAddress );

        if ( status != ERROR_SUCCESS )
            IpAddress = 0;

        if ( IpAddress == 0xffffffff )
            IpAddress = 0;

        if ( IpAddress )
        {
            //
            // It is active, now read the subnet mask
            //
            status = GetRegistryValue( AdapterKeyHandle,
                                       TRUE,
                                       DHCP_SUBNET_VALUE_WIN95,
                                       DHCP_SUBNET_VALUE_TYPE_WIN95,
                                       (LPBYTE)&SubnetMask );

            if ( status != ERROR_SUCCESS )
                SubnetMask = 0;
        }
        else
        {
            LPBYTE DhcpInfo = NULL;

            //
            // This may be a Win95 machine, the adapter IP address
            // is stored in the DhcpInfo blob.
            //
            status = GetRegistryValue( AdapterKeyHandle,
                                       TRUE,
                                       DHCP_INFO_VALUE,
                                       DHCP_INFO_VALUE_TYPE,
                                       (LPBYTE)&DhcpInfo );

            if ( status != ERROR_SUCCESS )
                goto Skip2;

            if ( !DhcpInfo )
                goto Skip2;

            IpAddress = *((LPDWORD)(DhcpInfo+sizeof(DWORD)));
            SubnetMask = *((LPDWORD)(DhcpInfo+sizeof(DWORD)+sizeof(DWORD)));
            FREE_HEAP( DhcpInfo );
        }

        if ( IpAddress == 0x00000000 || IpAddress == 0xffffffff )
            goto Skip2;

        AdapterInfoList[TotalNumberOfNets].IsDhcpEnabled = TRUE;
        AdapterInfoList[TotalNumberOfNets].pipAddresses =
            Dns_CreateIpArray( 1 );

        if ( !AdapterInfoList[TotalNumberOfNets].pipAddresses )
            goto Skip2;

        AdapterInfoList[TotalNumberOfNets].pipAddresses->AddrArray[0] =
            IpAddress;

        AdapterInfoList[TotalNumberOfNets].pipSubnetMasks =
            Dns_CreateIpArray( 1 );

        if ( !AdapterInfoList[TotalNumberOfNets].pipSubnetMasks )
        {
            FREE_HEAP( AdapterInfoList[TotalNumberOfNets].pipAddresses );
            AdapterInfoList[TotalNumberOfNets].pipAddresses = NULL;
            goto Skip2;
        }

        AdapterInfoList[TotalNumberOfNets].pipSubnetMasks->AddrArray[0] =
            SubnetMask;

        TotalNumberOfNets++;

Skip2 :

        status = ERROR_SUCCESS;

        if ( AdapterKeyHandle )
        {
            RegCloseKey( AdapterKeyHandle );
            AdapterKeyHandle = NULL;
        }
    }

Exit :

    //
    // We now have a data structure that represents the current
    // net adapters and assigned IP addresses based on the binding
    // order described by the adapter protocol bindings for TCPIP.
    //
    // Now stuff as many as we can into the users buffer provided.
    //

    //
    // Start by putting the first address from each adapter into the
    // IP list.
    //
    for ( iter = 0; iter < TotalNumberOfNets && ListCount; iter++ )
    {
        IpAddressInfoList[addressCount].ipAddress =
            AdapterInfoList[iter].pipAddresses->AddrArray[0];
        IpAddressInfoList[addressCount++].subnetMask =
            AdapterInfoList[iter].pipSubnetMasks->AddrArray[0];
        ListCount--;
    }

    for ( iter = 0; iter < TotalNumberOfNets && ListCount; iter++ )
    {
        for ( iter2 = 1;
              iter2 < AdapterInfoList[iter].pipAddresses->AddrCount;
              iter2++ )
        {
            IpAddressInfoList[addressCount].ipAddress =
                AdapterInfoList[iter].pipAddresses->AddrArray[iter2];
            IpAddressInfoList[addressCount++].subnetMask =
                AdapterInfoList[iter].pipSubnetMasks->AddrArray[iter2];
            ListCount--;
        }
    }

    if( AdapterKeyHandle )
        RegCloseKey( AdapterKeyHandle );

    for ( iter = 0; iter < TotalNumberOfNets; iter++ )
    {
        if( AdapterInfoList[iter].pipAddresses )
            FREE_HEAP( AdapterInfoList[iter].pipAddresses );

        if( AdapterInfoList[iter].pipSubnetMasks )
            FREE_HEAP( AdapterInfoList[iter].pipSubnetMasks );
    }

    FREE_HEAP( AdapterInfoList );

    AdapterInfoList = NULL;

    return addressCount;
}

//
//  End iplist9x.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\logit.h ===
/*
 -  L O G I T . H
 -
 *  Purpose:
 *      Function and Macro definitions for logging module activity.
 *
 *  Author: Glenn A. Curtis
 *
 *  Comments:
 *      10/28/93    glennc     original file.
 *
 */

#ifndef LOGIT_H
#define LOGIT_H

#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <time.h>

// #if DBG
   void  LogInit(LPSTR Filename);
   void  CDECL LogIt( LPSTR Filename, char *, ... );
   void  LogTime(LPSTR Filename);
   DWORD LogIn( LPSTR Filename, char * );
   void  LogOut( LPSTR Filename, char *, DWORD );
// #else
// #undef ENABLE_DEBUG_LOGGING
// #endif // DBG


/***********************************************************************
 *              Logging macros for source file dnsapi.c                *
 ***********************************************************************/

#ifdef ENABLE_DEBUG_LOGGING
#define DNSAPI_INIT() LogInit( "dnsapi.log" )
#else
#define DNSAPI_INIT() 
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSAPI_TIME() LogTime( "dnsapi.log" )
#else
#define DNSAPI_TIME() 
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSAPI_F1( a ) LogIt( "dnsapi.log", a )
#else
#define DNSAPI_F1( a )
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSAPI_F2( a, b ) LogIt( "dnsapi.log", a, b )
#else
#define DNSAPI_F2( a, b )
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSAPI_F3( a, b, c ) LogIt( "dnsapi.log", a, b, c )
#else
#define DNSAPI_F3( a, b, c )
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSAPI_F4( a, b, c, d ) LogIt( "dnsapi.log", a, b, c, d )
#else
#define DNSAPI_F4( a, b, c, d ) 
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSAPI_F5( a, b, c, d, e ) LogIt( "dnsapi.log", a, b, c, d, e )
#else
#define DNSAPI_F5( a, b, c, d, e ) 
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSAPI_F6( a, b, c, d, e, f ) LogIt( "dnsapi.log", a, b, c, d, e, f )
#else
#define DNSAPI_F6( a, b, c, d, e, f )
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSAPI_IN( a ) LogIn( "dnsapi.log", a )
#else
#define DNSAPI_IN( a )
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSAPI_OUT( a, b ) LogOut( "dnsapi.log", a, b )
#else
#define DNSAPI_OUT( a, b )
#endif                 


/***********************************************************************
 *             Logging macros for source file asyncreg.c               *
 ***********************************************************************/

#ifdef ENABLE_DEBUG_LOGGING
#define ASYNCREG_INIT() LogInit( "asyncreg.log" )
#else
#define ASYNCREG_INIT()
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define ASYNCREG_TIME() LogTime( "asyncreg.log" )
#else
#define ASYNCREG_TIME()
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define ASYNCREG_F1( a ) LogIt( "asyncreg.log", a )
#else
#define ASYNCREG_F1( a )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define ASYNCREG_F2( a, b ) LogIt( "asyncreg.log", a, b )
#else
#define ASYNCREG_F2( a, b )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define ASYNCREG_F3( a, b, c ) LogIt( "asyncreg.log", a, b, c )
#else
#define ASYNCREG_F3( a, b, c )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define ASYNCREG_F4( a, b, c, d ) LogIt( "asyncreg.log", a, b, c, d )
#else
#define ASYNCREG_F4( a, b, c, d )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define ASYNCREG_F5( a, b, c, d, e ) LogIt( "asyncreg.log", a, b, c, d, e )
#else
#define ASYNCREG_F5( a, b, c, d, e )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define ASYNCREG_F6( a, b, c, d, e, f ) LogIt( "asyncreg.log", a, b, c, d, e, f )
#else
#define ASYNCREG_F6( a, b, c, d, e, f )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define ASYNCREG_IN( a ) LogIn( "asyncreg.log", a )
#else
#define ASYNCREG_IN( a )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define ASYNCREG_OUT( a, b ) LogOut( "asyncreg.log", a, b )
#else
#define ASYNCREG_OUT( a, b )
#endif


/***********************************************************************
 *              Logging macros for source file dynreg.c                *
 ***********************************************************************/

#ifdef ENABLE_DEBUG_LOGGING
#define DYNREG_INIT() LogInit( "dynreg.log" )
#else
#define DYNREG_INIT()
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define DYNREG_TIME() LogTime( "dynreg.log" )
#else
#define DYNREG_TIME()
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define DYNREG_F1( a ) LogIt( "dynreg.log", a )
#else
#define DYNREG_F1( a )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define DYNREG_F2( a, b ) LogIt( "dynreg.log", a, b )
#else
#define DYNREG_F2( a, b )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define DYNREG_F3( a, b, c ) LogIt( "dynreg.log", a, b, c )
#else
#define DYNREG_F3( a, b, c )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define DYNREG_F4( a, b, c, d ) LogIt( "dynreg.log", a, b, c, d )
#else
#define DYNREG_F4( a, b, c, d )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define DYNREG_F5( a, b, c, d, e ) LogIt( "dynreg.log", a, b, c, d, e )
#else
#define DYNREG_F5( a, b, c, d, e )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define DYNREG_F6( a, b, c, d, e, f ) LogIt( "dynreg.log", a, b, c, d, e, f )
#else
#define DYNREG_F6( a, b, c, d, e, f )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define DYNREG_IN( a ) LogIn( "dynreg.log", a )
#else
#define DYNREG_IN( a )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define DYNREG_OUT( a, b ) LogOut( "dynreg.log", a, b )
#else
#define DYNREG_OUT( a, b )
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\local.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    local.h

Abstract:

    Domain Name System (DNS) API

    Dns API local include file

Author:

    Jim Gilroy (jamesg)     May 1997

Revision History:

--*/


#ifndef _DNSAPILOCAL_INCLUDED_
#define _DNSAPILOCAL_INCLUDED_

//  should just build as unicode
//#define UNICODE 1

#include <nt.h>           // build for Win95 compatibility
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

//  headers are messed up
//  neither ntdef.h nor winnt.h brings in complete set, so depending
//  on whether you include nt.h or not you end up with different set

#define MINCHAR     0x80
#define MAXCHAR     0x7f
#define MINSHORT    0x8000
#define MAXSHORT    0x7fff
#define MINLONG     0x80000000
#define MAXLONG     0x7fffffff
#define MAXBYTE     0xff
#define MAXUCHAR    0xff
#define MAXWORD     0xffff
#define MAXUSHORT   0xffff
#define MAXDWORD    0xffffffff
#define MAXULONG    0xffffffff

#include <winsock2.h>
#include <ws2tcpip.h>
#include <basetyps.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <align.h>          //  Alignment macros
#include <windns.h>         //  SDK DNS definitions

#define  DNSAPI_INTERNAL  1
#include <dnsapi.h>
#include "dnsrslvr.h"       //  Resolver RPC definitions
#include <rpcasync.h>       //  Exception filter
#include "dnslibp.h"        //  DNS library

#include "registry.h"
#include "message.h"        //  dnslib message def

//#include "dnsrslvr.h"     //  Resolver RPC definitions
#include "dnsapip.h"        //  Private DNS definitions
#include "queue.h"
#include "rtlstuff.h"       //  Handy macros from NT RTL
#include "trace.h"
#include "heapdbg.h"        //  dnslib debug heap


//
//  Build sanity check
//      - we still have a few private structs that need RPC
//      exposed in dnslib.h;  make sure they are in sync
//

C_ASSERT( sizeof(DNSLIB_SEARCH_NAME)  == sizeof(RPC_SEARCH_NAME) );
C_ASSERT( sizeof(DNSLIB_SEARCH_LIST)  == sizeof(RPC_SEARCH_LIST) );
C_ASSERT( sizeof(DNSLIB_SERVER_INFO)  == sizeof(RPC_DNS_SERVER_INFO) );
C_ASSERT( sizeof(DNSLIB_ADAPTER)      == sizeof(RPC_DNS_ADAPTER) );
C_ASSERT( sizeof(DNSLIB_NETINFO)      == sizeof(RPC_DNS_NETINFO) );


//
//  Use winsock2
//

#define DNS_WINSOCK_VERSION    (0x0202)    //  Winsock 2.2


//
//  Dll instance handle
//

extern HINSTANCE    g_hInstanceDll;

//
//  General CS
//  protects initialization and available for other random needs
//

CRITICAL_SECTION    g_GeneralCS;

#define LOCK_GENERAL()      EnterCriticalSection( &g_GeneralCS )
#define UNLOCK_GENERAL()    LeaveCriticalSection( &g_GeneralCS )


//
//  Init Levels
//

#define INITLEVEL_ZERO              (0)
#define INITLEVEL_BASE              (0x00000001)
#define INITLEVEL_DEBUG             (0x00000010)
#define INITLEVEL_QUERY             (0x00000100)
#define INITLEVEL_REGISTRATION      (0x00001000)
#define INITLEVEL_SECURE_UPDATE     (0x00010000)

//  Combined

#define INITLEVEL_ALL               (0xffffffff)


//
//  Limit on update adapters
//

#define UPDATE_ADAPTER_LIMIT 100

//
//  Network info defs
//
//  Empty (not-set) ServerIndex field in adapter info

#define EMPTY_SERVER_INDEX          ((DWORD)(-1))


//
//  Event logging
//      - currently set to disable in any code we pick up from server
//

VOID
DnsLogEvent (
    DWORD MessageId,
    WORD  EventType,
    DWORD NumberOfSubStrings,
    LPSTR *SubStrings,
    DWORD ErrorCode );

#define DNS_LOG_EVENT(a,b,c,d)

//
//  Debug
//

#ifdef ASSERT
#undef ASSERT
#endif
#define ASSERT(a)  DNS_ASSERT(a)

//  standard -- unflagged ASSERT()
//      - defintion directly from ntrtl.h
//      this should have been plain vanilla ASSERT(), but
//      it is used too often

#if DBG
#define RTL_ASSERT(exp)  \
        ((!(exp)) ? \
            (RtlAssert( #exp, __FILE__, __LINE__, NULL ),FALSE) : \
            TRUE)
#else
#define RTL_ASSERT(exp)
#endif

//
//  Single async socket for internal use
//
//  If want async socket i/o then can create single async socket, with
//  corresponding event and always use it.  Requires winsock 2.2
//

extern  SOCKET      DnsSocket;
extern  OVERLAPPED  DnsSocketOverlapped;
extern  HANDLE      hDnsSocketEvent;


//
//  App shutdown flag
//

extern  BOOLEAN     fApplicationShutdown;


//
//  Global config -- From DnsLib
//      -- set in DnsRegInit()
//          OR in DnsReadRegistryGlobals()
//      -- declaration in registry.h
//


//
//  Runtime globals (dnsapi.c)
//

extern  DWORD       g_NetFailureTime;
extern  DNS_STATUS  g_NetFailureStatus;

extern  IP_ADDRESS  g_LastDNSServerUpdated;


//
//  Global critical sections
//

extern  CRITICAL_SECTION    g_RegistrationListCS;
extern  CRITICAL_SECTION    g_RegistrationThreadCS;
extern  CRITICAL_SECTION    g_QueueCS;
extern  CRITICAL_SECTION    g_NetFailureCS;


//
//  Heap operations
//

#define ALLOCATE_HEAP(size)         Dns_AllocZero( size )
#define ALLOCATE_HEAP_ZERO(size)    Dns_AllocZero( size )
#define REALLOCATE_HEAP(p,size)     Dns_Realloc( (p), (size) )
#define FREE_HEAP(p)                Dns_Free( p )


//
//  Winsock stop\stop
//

DNS_STATUS
Dnsp_InitializeWinsock(
    VOID
    );

VOID
Dnsp_CleanupWinsock(
    VOID
    );


//
//  RPC Exception filters
//

#if 0
#define DNS_RPC_EXCEPTION_FILTER                                           \
              (((RpcExceptionCode() != STATUS_ACCESS_VIOLATION) &&         \
                (RpcExceptionCode() != STATUS_DATATYPE_MISALIGNMENT) &&    \
                (RpcExceptionCode() != STATUS_PRIVILEGED_INSTRUCTION) &&   \
                (RpcExceptionCode() != STATUS_ILLEGAL_INSTRUCTION))        \
                ? 0x1 : EXCEPTION_CONTINUE_SEARCH )
#endif

#define DNS_RPC_EXCEPTION_FILTER    I_RpcExceptionFilter( RpcExceptionCode() )



//
//  During setup need to cleanup after winsock
//

#define GUI_MODE_SETUP_WS_CLEANUP( _mode )  \
        {                                   \
            if ( _mode )                    \
            {                               \
                Dns_CleanupWinsock();       \
            }                               \
        }

//
//  Dummy server status codes (server states)
//
//  Note:  how this works
//      - these are BIT flags, but designed to be distinguishabled
//          from any real status code by the high 0xf
//      - they are OR'd together as send\timeout state progresses
//      - do NOT test equality for any of these but NEW
//      - test for state by traditional (flag&state == state) method
//
//  The alternative here is to add a separate "state" field along
//  with status to each server.  Since real status is easy to
//  distinguish, this seems acceptable.
//

#define DNSSS_NEW               (0xf0000000)
#define DNSSS_SENT              (0xf1000000)
#define DNSSS_SENT_OPT          (0xf1100000)
#define DNSSS_TIMEOUT_OPT       (0xf1300000)
#define DNSSS_SENT_NON_OPT      (0xf1010000)
#define DNSSS_TIMEOUT_NON_OPT   (0xf1030000)

#define TEST_DNSSS_NEW(status)              ((status) == DNSSS_NEW)
#define TEST_SERVER_STATUS_NEW(pserver)     ((pserver)->Status == DNSSS_NEW)

#define TEST_DNSSS_STATUS(status, state)    (((status) & (state)) == (state))
#define TEST_SERVER_STATUS(pserver, state)  (((pserver)->Status & (state)) == (state))
#define SET_SERVER_STATUS(pserver, state)   ((pserver)->Status |= state)

#define TEST_DNSSS_VALID_RECV(status)       ((LONG)status >= 0 )
#define TEST_SERVER_VALID_RECV(status)      ((LONG)(pserver)->Status >= 0 )




//
//  Local Prototypes
//
//  Routines shared between dnsapi.dll modules, but not exported
//
//  Note, i've included some other functions in here because the external
//  definition seems help "encourage" the creation of symbols in retail
//  builds
//


//
//  Config stuff
//

BOOL
DnsApiInit(
    IN      DWORD           InitLevel
    );

DWORD
Reg_ReadRegistryGlobal(
    IN      DNS_REGID       GlobalId
    );

//
//  Query (query.c)
//

DNS_STATUS
DoQuickQueryEx(
    IN OUT PDNS_MSG_BUF *,
    OUT    PDNS_RECORD *,
    IN     LPSTR,
    IN     WORD,
    IN     DWORD,
    IN     PDNS_NETINFO,
    IN     BOOL
    );

BOOL
IsEmptyDnsResponse(
    IN      PDNS_RECORD     pRecordList
    );

BOOL
ValidateQueryTld(
    IN      PSTR            pTld
    );

BOOL
ValidateQueryName(
    IN      PQUERY_BLOB     pBlob,
    IN      PSTR            pName,
    IN      PSTR            pDomain
    );

PSTR
getNextQueryName(
    OUT     PSTR            pNameBuffer,
    IN      DWORD           QueryCount,
    IN      PSTR            pszName,
    IN      DWORD           NameLength,
    IN      DWORD           NameAttributes,
    IN      PDNS_NETINFO    pNetInfo,
    OUT     PDWORD          pSuffixFlags
    );

PSTR
Query_GetNextName(
    IN OUT  PQUERY_BLOB     pBlob
    );


//
//  Update FAZ utilities (faz.c)
//

DNS_STATUS
DoQuickFAZ(
    OUT     PDNS_NETINFO *      ppNetworkInfo,
    IN      LPSTR               pszName,
    IN      PIP_ARRAY           aipServerList OPTIONAL
    );

DWORD
GetDnsServerListsForUpdate(
    IN OUT  PIP_ARRAY *     DnsServerListArray,
    IN      DWORD           ArrayLength,
    IN      DWORD           Flags
    );

DNS_STATUS
CollapseDnsServerListsForUpdate(
    IN OUT  PIP_ARRAY *         DnsServerListArray,
    OUT     PDNS_NETINFO *      NetworkInfoArray,
    IN OUT  PDWORD              pNetCount,
    IN      LPSTR               pszUpdateName
    );

PIP_ARRAY
GetNameServersListForDomain(
    IN     LPSTR            pDomainName,
    IN     PIP_ARRAY        aipServers
    );

BOOL
ValidateZoneNameForUpdate(
    IN      LPSTR           pszZone
    );


//
//  Status (dnsapi.c)
//

BOOL
IsKnownNetFailure(
    VOID
    );

VOID
SetKnownNetFailure(
    IN      DNS_STATUS      Status
    );

BOOL
IsLocalIpAddress(
    IN      IP_ADDRESS      IpAddress
    );

PDNS_NETINFO     
GetAdapterListFromCache(
    VOID
    );


//
//  IP Help API (iphelp.c)
//

VOID
IpHelp_Cleanup(
    VOID
    );

DNS_STATUS
IpHelp_GetAdaptersInfo(
    OUT     PIP_ADAPTER_INFO *  ppAdapterInfo
    );

DNS_STATUS
IpHelp_GetPerAdapterInfo(
    IN      DWORD                   AdapterIndex,
    OUT     PIP_PER_ADAPTER_INFO  * ppPerAdapterInfo
    );

DNS_STATUS
IpHelp_GetBestInterface(
    IN      IP4_ADDRESS     Ip4Addr,
    OUT     PDWORD          pdwInterfaceIndex
    );

DNS_STATUS
IpHelp_ParseIpAddressString(
    IN OUT  PIP_ARRAY       pIpArray,
    IN      PIP_ADDR_STRING pIpAddrString,
    IN      BOOL            fGetSubnetMask,
    IN      BOOL            fReverse
    );


//
//  Environment variable reading (regfig.c)
//

BOOL
Reg_ReadDwordEnvar(
    IN      DWORD               dwFlag,
    OUT     PENVAR_DWORD_INFO   pEnvar
    );


//
//  Hosts file reading (hostfile.c)
//

BOOL
QueryHostFile(
    IN OUT  PQUERY_BLOB     pBlob
    );

//
//  Resolver (resolver.c)
//

BOOL
WINAPI
DnsFlushResolverCacheEntry_UTF8(
    IN      PSTR            pszName
    );

//
//  Heap (memory.c)
//

VOID
Heap_Initialize(
    VOID
    );

VOID
Heap_Cleanup(
    VOID
    );


//
//  Network info (netinfo.c)
//

VOID
InitNetworkInfo(
    VOID
    );

VOID
CleanupNetworkInfo(
    VOID
    );

PSTR
SearchList_GetNextName(
    IN OUT  PSEARCH_LIST    pSearchList,
    IN      BOOL            fReset,
    OUT     PDWORD          pdwSuffixFlags  OPTIONAL
    );

PIP_ARRAY
NetInfo_ConvertToIpArray(
    IN      PDNS_NETINFO    pNetworkInfo
    );

PDNS_NETINFO     
NetInfo_CreateForUpdate(
    IN      PSTR            pszZone,
    IN      PSTR            pszServerName,
    IN      PIP_ARRAY       pServerArray,
    IN      DWORD           dwFlags
    );

PSTR
NetInfo_UpdateZoneName(
    IN      PDNS_NETINFO    pNetInfo
    );

PSTR
NetInfo_UpdateServerName(
    IN      PDNS_NETINFO    pNetInfo
    );

BOOL
NetInfo_IsForUpdate(
    IN      PDNS_NETINFO    pNetInfo
    );

PDNS_NETINFO     
NetInfo_CreateFromIpArray(
    IN      PIP4_ARRAY      pDnsServers,
    IN      IP4_ADDRESS     ServerIp,
    IN      BOOL            fSearchInfo,
    IN      PDNS_NETINFO    pNetInfo        OPTIONAL
    );

VOID
NetInfo_MarkDirty(
    VOID
    );

PDNS_NETINFO     
NetInfo_Get(
    IN      BOOL            fForce,
    IN      BOOL            fGetIpAddresses
    );

#define GetNetworkInfo()    NetInfo_Get( FALSE, TRUE )

PIP4_ARRAY
GetDnsServerList(
    IN      BOOL            fForce
    );


//  Private but used in servlist.c

PDNS_ADAPTER     
AdapterInfo_Copy(
    IN      PDNS_ADAPTER    pAdapter
    );

PDNS_NETINFO
NetInfo_Alloc(
    IN      DWORD           AdapterCount
    );

BOOL
NetInfo_AddAdapter(
    IN OUT  PDNS_NETINFO    pNetInfo,
    IN      PDNS_ADAPTER    pAdapter
    );

//
//  Old routines
//

VOID
Dns_ResetNetworkInfo(
    IN      PDNS_NETINFO    pNetworkInfo
    );

BOOL
Dns_DisableTimedOutAdapters(
    IN      PDNS_NETINFO    pNetworkInfo
    );

BOOL
Dns_ShouldNameErrorBeCached(
    IN      PDNS_NETINFO    pNetworkInfo
    );

BOOL
Dns_PingAdapterServers(
    IN      PDNS_ADAPTER    pAdapterInfo
    );


//
//  Internal routines for system public config (dnsapi.c)
//

PDNS_NETWORK_INFORMATION
WINAPI
GetNetworkInformation(
    VOID
    );

PDNS_SEARCH_INFORMATION
WINAPI
GetSearchInformation(
    VOID
    );

VOID
WINAPI
FreeAdapterInformation(
    IN OUT  PDNS_ADAPTER_INFORMATION    pAdapterInformation
    );

VOID
WINAPI
FreeSearchInformation(
    IN OUT  PDNS_SEARCH_INFORMATION     pSearchInformation
    );

VOID
WINAPI
FreeNetworkInformation(
    IN OUT  PDNS_NETWORK_INFORMATION    pNetworkInformation
    );


//
//  local IP info (localip.c)
//

PIP4_ARRAY
LocalIp_GetIp4Array(
    VOID
    );


#endif //   _DNSAPILOCAL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\localip.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    localip.c

Abstract:

    Local IP address routines.

Author:

    Jim Gilroy      October 2000

Revision History:

--*/


#include "local.h"

//
//  TTL on local records
//
//  Use registration TTL
//

#define LOCAL_IP_TTL    (g_RegistrationTtl)




PDNS_ADDR_ARRAY
GetLocalAddrArrayFromResolver(
    VOID
    )
/*++

Routine Description:

    Get local address info from resolver.

Arguments:

    None

Return Value:

    Ptr to address info array from resolver.
    NULL on failure.

--*/
{
    DNS_STATUS          rpcStatus;
    PDNS_ADDR_ARRAY     paddrArray = NULL;
    ENVAR_DWORD_INFO    filterInfo;

    //
    //  get config including environment variable
    //

    Reg_ReadDwordEnvar(
       RegIdFilterClusterIp,
       &filterInfo );

    //
    //  query resolver
    //

    RpcTryExcept
    {
        rpcStatus = NO_ERROR;
        R_ResolverGetLocalAddrInfoArray(
            NULL,
            & paddrArray,
            filterInfo
            );
    }
    RpcExcept( DNS_RPC_EXCEPTION_FILTER )
    {
        rpcStatus = RpcExceptionCode();
    }
    RpcEndExcept

    //  return array

    DNS_ASSERT( !rpcStatus || !paddrArray );

    return  paddrArray;
}



PIP4_ARRAY
LocalIp_GetIp4Array(
    VOID
    )
/*++

Routine Description:

    Get local IP4 address array.

Arguments:

    None

Return Value:

    Ptr to IP4 addresses.
    NULL on failure.

--*/
{
    PDNS_ADDR_ARRAY     paddrArray = NULL;
    PIP4_ARRAY          pipArray = NULL;
    DWORD               count;
    DWORD               i;

    //
    //  addr info array from resolver
    //      => build IP array from IPs
    //

    paddrArray = GetLocalAddrArrayFromResolver();
    if ( paddrArray )
    {
        count = paddrArray->AddrCount;
        if ( count > 0 )
        {
            pipArray = (PIP4_ARRAY) DnsCreateIpArray( count );
            if ( pipArray )
            {
                for ( i=0; i < count; i++ )
                {
                    pipArray->AddrArray[i] = paddrArray->AddrArray[i].IpAddr;
                }
                goto Done;
            }
        }
    }

    //
    //  no array from resolver -- build directly
    //      - no chance to filter
    //

    count = 0;
    pipArray = (PIP4_ARRAY) Dns_GetLocalIpAddressArray();
    if ( pipArray )
    {
        count = pipArray->AddrCount;
        if ( count == 0 )
        {
            FREE_HEAP( pipArray );
            pipArray = NULL;
        }
    }
    
Done:

    //  free blob from resolver

    if ( paddrArray )
    {
        FREE_HEAP( paddrArray );
    }

    //  set out param

    return( pipArray );
}



DWORD
DnsGetIpAddressInfoList(
    OUT     PDNS_ADDRESS_INFO * ppAddrInfo
    )
/*++

Routine Description:

    Get local IP4 address info -- include IP and subnet mask.

    DCR:  good to get rid of old DNS_ADDRESS_INFO function

    Only use of this function is in DHCP, which is calling here rather
    than IP help API for some reason.

Arguments:

    ppAddrInfo -- addr to recv ptr to addr info array;
        caller must free

Return Value:

    Count of IP addresses in array.
    Zero on failure.

--*/
{
    PDNS_ADDR_ARRAY     paddrArray = NULL;
    PDNS_ADDRESS_INFO   pnew = NULL;
    PDNS_ADDRESS_INFO   pinfo;
    DWORD               count;
    DNS_ADDRESS_INFO    infoBuffer[256];

    //
    //  addr info array from resolver
    //      => build IP array from IPs
    //
    //  DCR_WARNING:  ADDR_INFO to ADDRESS_INFO conversion
    //      if keep this function and change ADDR_INFO for IP6
    //      then this quicky hack breaks
    //

    paddrArray = GetLocalAddrArrayFromResolver();
    if ( paddrArray )
    {
        count = paddrArray->AddrCount;
        pinfo = (PDNS_ADDRESS_INFO) paddrArray->AddrArray;
    }

    //
    //  no array from resolver -- build directly
    //

    else
    {
        count = Dns_GetIpAddresses( infoBuffer, 256 );
        pinfo = infoBuffer;
    }

    //
    //  allocate result buffer
    //  copy addr info array to buffer
    //

    if ( count )
    {
        DWORD   size = count * sizeof(DNS_ADDRESS_INFO);

        pnew = (PDNS_ADDRESS_INFO) ALLOCATE_HEAP( size );
        if ( !pnew )
        {
            count = 0;
            goto Done;
        }
        RtlCopyMemory(
            pnew,
            pinfo,
            size );
    }

Done:

    //  free blob from resolver

    if ( paddrArray )
    {
        FREE_HEAP( paddrArray );
    }

    //  set out param

    *ppAddrInfo = pnew;
    return( count );
}



PDNS_ADDR_ARRAY
DnsGetLocalAddrArray(
    VOID
    )
/*++

Routine Description:

    Get local address info array.

Arguments:

    None.

Return Value:

    Ptr to new addr info array.  Caller MUST free.
    NULL on error.

--*/
{
    PDNS_ADDR_ARRAY     paddrArray;

    DNSDBG( TRACE, ( "DnsGetLocalAddrArray()\n" ));

    //
    //  addr info array from resolver
    //      => build IP array from IPs
    //

    paddrArray = GetLocalAddrArrayFromResolver();
    if ( paddrArray )
    {
        return  paddrArray;
    }

    //
    //  no array from resolver -- build directly
    //

    return DnsGetLocalAddrArrayDirect();
}




//
//  Direct routines -- build the IP info
//

PDNS_ADDR_ARRAY
DnsGetLocalAddrArrayDirect(
    VOID
    )
/*++

Routine Description:

    Get local address info array.

Arguments:

    None.

Return Value:

    Ptr to addr info array.
    NULL on failure.

--*/
{
    PDNS_ADDRESS_INFO   pqueryBuf;
    PDNS_ADDR_ARRAY     pnew = NULL;
    DWORD               count;
    DWORD               size;

    DNSDBG( TRACE, ( "DnsGetLocalAddrArrayDirect()\n" ));

    //
    //  create big buffer IP help call
    //

    pqueryBuf = ALLOCATE_HEAP( sizeof(DNS_ADDRESS_INFO) *
                                DNS_MAX_IP_INTERFACE_COUNT );
    if ( !pqueryBuf )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }

    //
    //  get IP addresses
    //      - if zero, determine is error or really no IPs
    //

    count = Dns_GetIpAddresses(
                    pqueryBuf,
                    DNS_MAX_IP_INTERFACE_COUNT );
#if 0
    //  don't really need this
    //      if can't get count -- it's zero
    //  to use this on Win2K would have to change
    //      Dns_GetIpAddresses() which is in lib
    if ( count == 0 )
    {
        if ( GetLastError() != NO_ERROR )
        {
            goto Cleanup;
        }
    }
#endif

    //
    //  build correctly sized array
    //

    size = SIZE_FOR_ADDR_ARRAY( count );
    
    pnew = (PDNS_ADDR_ARRAY) ALLOCATE_HEAP( size );
    if ( !pnew )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        goto Cleanup;
    }

    pnew->AddrCount = count;

    RtlCopyMemory(
        pnew->AddrArray,
        pqueryBuf,
        count * sizeof(DNS_ADDR_INFO)
        );
    

Cleanup:

    FREE_HEAP( pqueryBuf );

    return( pnew );
}



//
//  Build local records
//

PDNS_RECORD
GetLocalPtrRecord(
    IN OUT  PQUERY_BLOB     pBlob
    )
/*++

Routine Description:

    Get pointer record for local IP.

Arguments:

    pBlob -- query blob

    Uses:
        pNameOrig
        wType
        pNetInfo

    Sets:
        NameBufferWide -- used as local storage

Return Value:

    Ptr to record for query, if query name\type is IP.
    NULL if query not for IP.

--*/
{
    IP_UNION        ipUnion;
    PDNS_RECORD     prr;
    IP4_ADDRESS     ip4;
    PSTR            pnameHost = NULL;
    PSTR            pnameDomain;
    PDNS_ADAPTER    padapter = NULL;
    DWORD           iter;
    DWORD           jter;
    DWORD           bufLength;
    INT             family;
    PSTR            pnameQuery = pBlob->pNameOrigWire;
    PDNS_NETINFO    pnetInfo = pBlob->pNetworkInfo;


    DNSDBG( TRACE, (
        "\nGetLocalPtrRecord( %s )\n",
        pnameQuery ));

    if ( !pnameQuery )
    {
        return  NULL;
    }

    //
    //  convert reverse name to IP
    //

    bufLength = sizeof(IP6_ADDRESS);
    family = 0;

    if ( ! Dns_ReverseNameToAddress_A(
                (PCHAR) & ipUnion.Addr,
                & bufLength,
                pnameQuery,
                & family ) )
    {
        DNSDBG( ANY, (
            "WARNING:  Ptr lookup name %s is not reverse name!\n",
            pnameQuery ));
        return   NULL;
    }
    ipUnion.IsIp6 = (family == AF_INET6 );

    //
    //  check for IP match
    //      - first loopback or any
    //

    if ( ipUnion.IsIp6 )
    {
        if ( IP6_IS_ADDR_UNSPECIFIED( (PIP6_ADDRESS)&ipUnion.Addr ) ||
             IP6_IS_ADDR_LOOPBACK( (PIP6_ADDRESS)&ipUnion.Addr ) )
        {
            goto Matched;
        }

        //  DCR:  no IP6 local addresses

        DNSDBG( QUERY, (
            "Local PTR lookup -- no local IP6 info -- quiting.\n" ));
        return  NULL;
    }

    ip4 = ipUnion.Addr.Ip4;

    if ( ip4 == DNS_NET_ORDER_LOOPBACK ||
         ip4 == 0 )
    {
        DNSDBG( QUERY, (
            "Local PTR lookup matched loopback or any.\n" ));

        goto Matched;
    }

    //
    //  check for cluster match
    //
    //  if cluster match, allow query to go to wire
    //
    //  DCR:  cluster record PTR build for cluster name
    //

    if ( pBlob->pfnIsClusterIp )
    {
        if ( (pBlob->pfnIsClusterIp)(
                pBlob,
                &ipUnion ) )
        {
            return  NULL;
        }
    }

    //
    //  check for specific IP match
    //

    for ( iter = 0;
          iter < pnetInfo->AdapterCount;
          iter ++ )
    {
        PIP_ARRAY       parray;

        padapter = pnetInfo->AdapterArray[iter];
        if ( !padapter )
        {
            continue;
        }
        parray = padapter->pAdapterIPAddresses;
        if ( !parray )
        {
            DNSDBG( QUERY, (
                "Local PTR lookup -- no IPs for adapter name (%s).\n",
                padapter->pszAdapterDomain ));
            continue;
        }

        for ( jter = 0;
              jter < parray->AddrCount;
              jter++ )
        {
            if ( parray->AddrArray[jter] == ip4 )
            {
                goto Matched;
            }
        }
    }

    //  
    //  no IP match
    //

    DNSDBG( QUERY, (
        "Leave local PTR lookup.  No local IP match.\n"
        "\treverse name = %s\n",
        pnameQuery ));

    return  NULL;

Matched:

    //
    //  create hostname
    //  preference order:
    //      - full PDN
    //      - full adapter domain name from adapter with IP
    //      - hostname (single label)
    //      - "localhost"
    //

    {
        PCHAR    pnameBuf = (PCHAR) pBlob->NameBufferWide;

        pnameHost = pnetInfo->pszHostName;
        if ( !pnameHost )
        {
            pnameHost = "localhost";
            goto Build;
        }
        
        pnameDomain = pnetInfo->pszDomainName;
        if ( !pnameDomain )
        {
            //  use the adapter name even if NOT set for registration
            // if ( !padapter ||
            //     !(padapter->InfoFlags & DNS_FLAG_REGISTER_DOMAIN_NAME) )
            if ( !padapter )
            {
                goto Build;
            }
            pnameDomain = padapter->pszAdapterDomain;
            if ( !pnameDomain )
            {
                goto Build;
            }
        }
        
        if ( ! Dns_NameAppend_A(
                    pnameBuf,
                    DNS_MAX_NAME_BUFFER_LENGTH,
                    pnameHost,
                    pnameDomain ) )
        {
            DNS_ASSERT( FALSE );
            goto Build;
        }
        pnameHost = pnameBuf;
        

Build:
        //
        //  create record
        //
        
        prr = Dns_CreatePtrRecordEx(
                    & ipUnion,
                    pnameHost,
                    LOCAL_IP_TTL,
                    DnsCharSetUtf8,
                    DnsCharSetUnicode );
        if ( !prr )
        {
            DNSDBG( ANY, (
                "Local PTR record creation failed for name %s!\n",
                pnameHost ));
            return  NULL;
        }
    }

    DNSDBG( QUERY, (
        "Created local PTR record %p with hostname %s.\n"
        "\treverse name = %S\n",
        prr,
        pnameHost,
        pnameQuery ));

    return  prr;
}



PDNS_RECORD
BuildRecordForLocalIp4(
    IN      PSTR                pszName,
    IN      IP4_ADDRESS         IpAddr,
    IN      IS_CLUSTER_IP_FUNC  pfnIsClusterIp
    )
/*++

Routine Description:

    Build local IP record.

    Wraps up default cluster filtering and record
    building.

Arguments:

    pszName -- name of record

    IpAddr -- IP4 address

    pfnIsClusterIp -- filtering function
    
Return Value:

    TRUE if created record.
    FALSE on error (cluster IP or mem alloc failure).

--*/
{
    PDNS_RECORD     prr;

    DNSDBG( TRACE, (
        "BuildRecordForLocalIp4( %s, %s )\n",
        pszName,
        IP_STRING(IpAddr) ));

    //  filter off cluster IP -- if desired

    if ( pfnIsClusterIp )
    {
        IP_UNION    ipUnion;

        IPUNION_SET_IP4( &ipUnion, IpAddr );

        if ( pfnIsClusterIp(
                NULL,       // no blob required
                &ipUnion ) )
        {
            return  NULL;
        }
    }

    //  create the record

    return  Dns_CreateARecord(
                pszName,
                IpAddr,
                LOCAL_IP_TTL,
                DnsCharSetUtf8,
                DnsCharSetUnicode );
}



PDNS_RECORD
GetLocalAddressRecord(
    IN OUT  PQUERY_BLOB     pBlob
    )
/*++

Routine Description:

    Get address record for local IP.

Arguments:

    pBlob -- query blob

    Uses:
        pNameOrig
        wType
        pNetInfo

    Sets:
        fNoIpLocal
            TRUE -- no IP of type found, defaulted record
            FALSE -- records valid

        NameBufferWide -- used as local storage

Return Value:

    Ptr to record for query, if query name\type is IP.
    NULL if query not for IP.

--*/
{
    IP_UNION        ipUnion;
    IP4_ADDRESS     ip4;
    IP6_ADDRESS     ip6;
    PDNS_RECORD     prr;
    BOOL            fmatchedName = FALSE;
    PSTR            pnameRecord = NULL;
    PWSTR           pnameRecordWide = NULL;
    DWORD           iter;
    DWORD           jter;
    DWORD           bufLength;
    PSTR            pnameDomain;
    DNS_RRSET       rrset;
    WORD            wtype = pBlob->wType;
    PSTR            pnameBuf = (PCHAR) pBlob->NameBufferWide;
    PWSTR           pnameQuery = pBlob->pNameOrig;
    PDNS_NETINFO    pnetInfo = pBlob->pNetworkInfo;
    IS_CLUSTER_IP_FUNC  pfnClusterFilter;


    DNSDBG( TRACE, (
        "GetLocalAddressRecord( %S, %d )\n",
        pnameQuery,
        wtype ));

    //  clear out param

    pBlob->fNoIpLocal = FALSE;

    //
    //  NULL treated as local PDN
    //

    if ( !pnameQuery )
    {
        DNSDBG( QUERY, ( "Local lookup -- no query name, treat as PDN.\n" ));
        goto MatchedPdn;
    }

    //
    //  loopback or localhost
    //

    if ( Dns_NameCompare_W(
            pnameQuery,
            L"loopback" )
            ||
         Dns_NameCompare_W(
            pnameQuery,
            L"localhost" ) )
    {
        pnameRecord = (PSTR) pnameQuery,
        IP6_SET_ADDR_LOOPBACK( &ip6 );
        ip4 = DNS_NET_ORDER_LOOPBACK;
        goto SingleIp;
    }

    //
    //  if no hostname -- done
    //

    if ( !pnetInfo->pszHostName )
    {
        DNSDBG( QUERY, ( "No hostname configured!\n" ));
        return  NULL;
    }

    //
    //  copy wire format name
    //

    if ( ! Dns_NameCopyStandard_A(
                pnameBuf,
                pBlob->pNameOrigWire ) )
    {
        DNSDBG( ANY, (
            "Invalid name %S to local address query.\n",
            pnameQuery ));
        return  NULL;
    }

    //  split query name into hostname and domain name

    pnameDomain = Dns_SplitHostFromDomainName_A( pnameBuf );

    //  must have hostname match

    if ( !Dns_NameCompare_UTF8(
            pnameBuf,
            pnetInfo->pszHostName ) )
    {
        DNSDBG( ANY, (
            "Local lookup, failed hostname match!\n",
            pnameQuery ));
        return  NULL;
    }

    //
    //  hostname's match
    //      - no domain name => PDN equivalent
    //      - match PDN => all addresses
    //      - match adapter name => adapter addresses
    //      - no match
    //
    //  first setup
    //      - RR set builder
    //      - filtering function
    //

    DNS_RRSET_INIT( rrset );

    pfnClusterFilter = pBlob->pfnIsClusterIp;
    if ( pfnClusterFilter &&
         !(pBlob->Flags & DNSP_QUERY_FILTER_CLUSTER) )
    {
        pfnClusterFilter = NULL;
    }

    if ( !pnameDomain )
    {
        DNSDBG( QUERY, ( "Local lookup -- no domain, treat as PDN!\n" ));
        goto MatchedPdn;
    }

    //  check PDN match

    if ( Dns_NameCompare_UTF8(
            pnameDomain,
            pnetInfo->pszDomainName ) )
    {
        DNSDBG( QUERY, ( "Local lookup -- matched PDN!\n" ));
        goto MatchedPdn;
    }

    //
    //  check adapter name match
    //

    for ( iter = 0;
          iter < pnetInfo->AdapterCount;
          iter ++ )
    {
        PDNS_ADAPTER    padapter = pnetInfo->AdapterArray[iter];
        PIP_ARRAY       parray;

        if ( !padapter ||
             !(padapter->InfoFlags & DNS_FLAG_REGISTER_DOMAIN_NAME) )
        {
            continue;
        }
        if ( ! Dns_NameCompare_UTF8(
                    pnameDomain,
                    padapter->pszAdapterDomain ) )
        {
            continue;
        }

        //  build name if we haven't built it before
        //  we stay in the loop in case more than one
        //  adapter has the same domain name

        if ( !fmatchedName )
        {
            DNSDBG( QUERY, (
                "Local lookup -- matched adapter name %s\n",
                padapter->pszAdapterDomain ));

            if ( ! Dns_NameAppend_A(
                        pnameBuf,
                        DNS_MAX_NAME_BUFFER_LENGTH,
                        pnetInfo->pszHostName,
                        padapter->pszAdapterDomain ) )
            {
                DNS_ASSERT( FALSE );
                return  NULL;
            }
            pnameRecord = pnameBuf;
            fmatchedName = TRUE;
        }

        //  build forward records for all IPs in list
        //
        //  DCR:  IP6 addresses missing

        if ( wtype == DNS_TYPE_AAAA )
        {
            goto  NoIp;
        }

        //  no IP for adapter?

        parray = padapter->pAdapterIPAddresses;
        if ( !parray )
        {
            DNSDBG( QUERY, (
                "Local lookup -- no IPs for adapter name (%s) matched!\n",
                padapter->pszAdapterDomain ));
        }

        //  build records for adapter IPs

        for  ( jter = 0;
               jter < parray->AddrCount;
               jter++ )
        {
            prr = BuildRecordForLocalIp4(
                        pnameRecord,
                        parray->AddrArray[jter],
                        pfnClusterFilter );
            if ( prr )
            {
                pnameRecord = NULL;
                DNS_RRSET_ADD( rrset, prr );
            }
        }
    }

    //  done with adapter name
    //  either
    //      - no match
    //      - match but didn't get IPs
    //      - match

    if ( !fmatchedName )
    {
        DNSDBG( QUERY, (
            "Leave GetLocalAddressRecord() => no domain name match.\n" ));
        return  NULL;
    }

    prr = rrset.pFirstRR;
    if ( prr )
    {
        DNSDBG( QUERY, (
            "Leave GetLocalAddressRecord() => %p matched adapter name.\n",
            prr ));
        return  prr;
    }
    goto NoIp;


MatchedPdn:

    //  
    //  matched PDN
    //
    //  must build in specific order
    //      - first IP in each adapter
    //      - remainder of IPs on adapters
    //

    fmatchedName = TRUE;

    if ( ! Dns_NameAppend_A(
                pnameBuf,
                DNS_MAX_NAME_BUFFER_LENGTH,
                pnetInfo->pszHostName,
                pnetInfo->pszDomainName ) )
    {
        DNS_ASSERT( FALSE );
        return  NULL;
    }
    pnameRecord = pnameBuf;

    //  DCR:  IP6 addresses missing

    if ( wtype == DNS_TYPE_AAAA )
    {
        goto  NoIp;
    }

    //  get first IP in each adapter

    for ( iter = 0;
          iter < pnetInfo->AdapterCount;
          iter ++ )
    {
        PDNS_ADAPTER    padapter = pnetInfo->AdapterArray[iter];
        PIP_ARRAY       parray;

        if ( !padapter ||
             !(parray = padapter->pAdapterIPAddresses) )
        {
            continue;
        }
        prr = BuildRecordForLocalIp4(
                    pnameRecord,
                    parray->AddrArray[0],
                    pfnClusterFilter );
        if ( prr )
        {
            pnameRecord = NULL;
            DNS_RRSET_ADD( rrset, prr );
        }
    }

    //  get rest of IPs in each adapter

    for ( iter = 0;
          iter < pnetInfo->AdapterCount;
          iter ++ )
    {
        PDNS_ADAPTER    padapter = pnetInfo->AdapterArray[iter];
        PIP_ARRAY       parray;

        if ( !padapter ||
             !(parray = padapter->pAdapterIPAddresses) )
        {
            continue;
        }
        for  ( jter = 1;
               jter < parray->AddrCount;
               jter++ )
        {
            prr = BuildRecordForLocalIp4(
                        pnameRecord,
                        parray->AddrArray[jter],
                        pfnClusterFilter );
            if ( prr )
            {
                pnameRecord = NULL;
                DNS_RRSET_ADD( rrset, prr );
            }
        }
    }

    //  if successfully built -- done

    prr = rrset.pFirstRR;
    if ( prr )
    {
        DNSDBG( QUERY, (
            "Leave GetLocalAddressRecord() => %p matched PDN name.\n",
            prr ));
        return  prr;
    }

    //  matched name but found no records
    //  fall through to NoIp section
    //
    //goto NoIp;

NoIp:

    //
    //  matched name -- but no IP
    //      use loopback address;  assume this is a lookup prior to
    //      connect which happens to be the local name, rather than an
    //      explict local lookup to get binding IPs
    //
    //  DCR:  fix IP6 hack for local names

    DNSDBG( ANY, (
        "WARNING:  local name match but no IP -- using loopback\n" ));

    IP6_SET_ADDR_LOOPBACK( &ip6 );
    ip4 = DNS_NET_ORDER_LOOPBACK;
    pBlob->fNoIpLocal = TRUE;

    //  fall through to single IP

SingleIp:

    //  single IP
    //      - loopback address and be unicode queried name
    //      - no IP failure (zero IP) and be UTF8 PDN name

    if ( wtype == DNS_TYPE_A )
    {
        IPUNION_SET_IP4( &ipUnion, ip4 );
    }
    else
    {
        IPUNION_SET_IP6( &ipUnion, ip6 );
    }

    prr = Dns_CreateForwardRecord(
                (PSTR) pnameRecord,
                & ipUnion,
                LOCAL_IP_TTL,
                (pnameRecord == (PSTR)pnameQuery)
                    ? DnsCharSetUnicode
                    : DnsCharSetUtf8,
                DnsCharSetUnicode );

    return  prr;
}



DNS_STATUS
GetRecordsForLocalName(
    IN OUT  PQUERY_BLOB     pBlob
    )
/*++

Routine Description:

    Get local address info array.

Arguments:

    pBlob -- query blob

    Uses:
        pNameOrig
        wType
        pNetInfo

    Sets:
        pLocalRecords
        fNoIpLocal if local name without records

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_RCODE_NAME_ERROR on failure.

--*/
{
    WORD            wtype = pBlob->wType;
    PDNS_RECORD     prr = NULL;

    if ( wtype == DNS_TYPE_A ||
         wtype == DNS_TYPE_AAAA )
    {
        prr = GetLocalAddressRecord( pBlob );
    }

    else if ( wtype == DNS_TYPE_PTR )
    {
        prr = GetLocalPtrRecord( pBlob );
    }

    //  set local records
    //      - if not NO IP situation then this
    //      is final query result also

    if ( prr )
    {
        pBlob->pLocalRecords = prr;
        if ( !pBlob->fNoIpLocal )
        {
            pBlob->pRecords = prr;
        }
        return  ERROR_SUCCESS;
    }

    return  DNS_ERROR_RCODE_NAME_ERROR;
}

//
//  End localip.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\netinfo.c ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    netinfo.c

Abstract:

    Domain Name System (DNS) API

    DNS network info routines.

Author:

    Jim Gilroy (jamesg)     March 2000

Revision History:

--*/


#include "local.h"
#include "registry.h"       // Registry reading definitions


//
//  Registry info
//

#define DNS_REG_READ_BUF_SIZE       (1000)

#define LOCALHOST                   "127.0.0.1"


//
//  Netinfo cache
//
//  Do in process caching of netinfo for brief period for perf
//  Currently cache for only 10s
//  Locking currently just using general CS
//

PDNS_NETINFO    g_pNetInfo = NULL;

#define NETINFO_CACHE_TIMEOUT   (10)    // 10 seconds

#define LOCK_NETINFO()          LOCK_GENERAL()
#define UNLOCK_NETINFO()        UNLOCK_GENERAL()




//
//  Adapter info routines
//

DWORD
AdapterInfo_SizeForServerCount(
    IN      DWORD           ServerCount
    )
/*++

Routine Description:

    Size in bytes of adapter info for given server count.

Arguments:

    ServerCount -- max count of servers adapter will hold

Return Value:

    Size in bytes of ADAPTER_INFO blob.

--*/
{
    return  sizeof(DNS_ADAPTER)
                - sizeof(DNS_SERVER_INFO)
                + (sizeof(DNS_SERVER_INFO) * ServerCount);
}



PDNS_ADAPTER     
AdapterInfo_Alloc(
    IN      DWORD           ServerCount
    )
/*++

Routine Description:

    Create uninitialized DNS Server list.

Arguments:

    ServerCount -- count of servers list will hold

Return Value:

    Ptr to uninitialized adapter, if successful
    NULL on failure.

--*/
{
    DNSDBG( TRACE, ( "AdapterInfo_Alloc()\n" ));

    //
    //  allocate blob for adapter info
    //

    return  (PDNS_ADAPTER)
            ALLOCATE_HEAP_ZERO(
                    AdapterInfo_SizeForServerCount( ServerCount ) );
}



VOID
AdapterInfo_Free(
    IN OUT  PDNS_ADAPTER    pAdapter
    )
/*++

Routine Description:

    Free DNS_ADAPTER structure.

Arguments:

    pAdapter -- pointer to adapter blob to free

Return Value:

    None.

--*/
{
    DNSDBG( TRACE, ( "AdapterInfo_Free( %p )\n", pAdapter ));

    if ( !pAdapter )
    {
        return;
    }

    if ( pAdapter->pszAdapterGuidName )
    {
        FREE_HEAP( pAdapter->pszAdapterGuidName );
    }
    if ( pAdapter->pszAdapterDomain )
    {
        FREE_HEAP( pAdapter->pszAdapterDomain );
    }
    if ( pAdapter->pAdapterIPAddresses )
    {
        FREE_HEAP( pAdapter->pAdapterIPAddresses );
    }
    if ( pAdapter->pAdapterIPSubnetMasks )
    {
        FREE_HEAP( pAdapter->pAdapterIPSubnetMasks );
    }
    FREE_HEAP( pAdapter );
}



PDNS_ADAPTER     
AdapterInfo_Copy(
    IN      PDNS_ADAPTER    pAdapter
    )
/*++

Routine Description:

    Create copy of DNS adapter info.

Arguments:

    pAdapter -- DNS adapter to copy

Return Value:

    Ptr to DNS adapter info copy, if successful
    NULL on failure.

--*/
{
    PDNS_ADAPTER        pcopy;

    DNSDBG( TRACE, ( "AdapterInfo_Copy( %p )\n", pAdapter ));

    if ( ! pAdapter )
    {
        return NULL;
    }

    pcopy = AdapterInfo_Alloc( pAdapter->ServerCount );
    if ( ! pcopy )
    {
        return NULL;
    }

    //
    //  copy the whole blob
    //      - reset MaxServerCount to actual allocation

    RtlCopyMemory(
        pcopy,
        pAdapter,
        AdapterInfo_SizeForServerCount( pAdapter->ServerCount ) );

    pcopy->MaxServerCount = pAdapter->ServerCount;

    //  fixup allocated subfields

    pcopy->pszAdapterGuidName = Dns_CreateStringCopy(
                                    pAdapter->pszAdapterGuidName,
                                    0 );

    pcopy->pszAdapterDomain = Dns_CreateStringCopy(
                                    pAdapter->pszAdapterDomain,
                                    0 );

    pcopy->pAdapterIPAddresses = Dns_CreateIpArrayCopy(
                                    pAdapter->pAdapterIPAddresses );

    pcopy->pAdapterIPSubnetMasks = Dns_CreateIpArrayCopy(
                                    pAdapter->pAdapterIPSubnetMasks );
    return( pcopy );
}



PDNS_ADAPTER     
AdapterInfo_Create(
    IN      DWORD           ServerCount,
    IN      DWORD           dwFlags,
    IN      PSTR            pszDomain,
    IN      PSTR            pszGuidName
    )
/*++

Routine Description:

    Create uninitialized DNS Server list.

Arguments:

    ServerCount -- count of servers list will hold

    dwFlags -- flags

    pszAdapterDomain -- the names of the domain associated with this
                        interface

    pszGuidName -- GUID name

Return Value:

    Ptr to adapter info, if successful
    NULL on failure.

--*/
{
    PDNS_ADAPTER        padapter = NULL;

    DNSDBG( TRACE, ( "AdapterInfo_Create()\n" ));

    //
    //  allocate blob for adapter info
    //

    padapter = AdapterInfo_Alloc( ServerCount );
    if ( ! padapter )
    {
        return NULL;
    }

    DNS_ASSERT( padapter->RunFlags == 0 );
    DNS_ASSERT( padapter->ServerCount == 0 );

    padapter->pszAdapterGuidName = Dns_CreateStringCopy( pszGuidName, 0 );
    padapter->pszAdapterDomain = Dns_CreateStringCopy( pszDomain, 0 );

    padapter->MaxServerCount = ServerCount;
    padapter->InfoFlags = dwFlags;

    return padapter;
}



PDNS_ADAPTER     
AdapterInfo_CreateFromIpArray(
    IN      PIP_ARRAY       pServerArray,
    IN      DWORD           dwFlags,
    IN      PSTR            pszDomainName,
    IN      PSTR            pszGuidName
    )
/*++

Routine Description:

    Create copy of IP address array as a DNS Server list.

Arguments:

    pIpArray    -- IP address array to convert

    dwFlags     -- Flags that describe the adapter

    pszDomainName -- The default domain name for the adapter

    pszGuidName -- The registry GUID name for the adapter (if NT)

Return Value:

    Ptr to DNS Server list copy, if successful
    NULL on failure.

--*/
{
    PDNS_ADAPTER    padapter;
    DWORD           i;
    DWORD           count;

    DNSDBG( TRACE, ( "AdapterInfo_CreateFromIpArray()\n" ));

    //
    //  get count of DNS servers
    //

    if ( !pServerArray )
    {
        count = 0;
    }
    else
    {
        count = pServerArray->AddrCount;
    }

    //
    //  create adapter with server list of required size
    //

    padapter = AdapterInfo_Create(
                    count,
                    dwFlags,
                    pszDomainName,
                    pszGuidName );
    if ( !padapter )
    {
        return NULL;
    }

    //
    //  copy DNS server IPs and clear other fields
    //
    //  DCR_QUESTION:  are fields already zero'd?
    //

    for ( i=0; i < count; i++ )
    {
        padapter->ServerArray[i].IpAddress = pServerArray->AddrArray[i];
        padapter->ServerArray[i].Status = NO_ERROR;
        padapter->ServerArray[i].Priority = 0;
    }
    padapter->ServerCount = count;

    return padapter;
}



//
//  Search list routines
//

PSEARCH_LIST    
SearchList_Alloc(
    IN      DWORD           MaxNameCount,
    IN      PSTR            pszName
    )
/*++

Routine Description:

    Create uninitialized search list.

Arguments:

    NameCount -- count of search names list will hold

    pszName -- primary domain name

Return Value:

    Ptr to uninitialized DNS search list, if successful
    NULL on failure.

--*/
{
    PSEARCH_LIST    psearchList = NULL;
    DWORD           length;

    DNSDBG( TRACE, ( "SearchList_Create()\n" ));

    if ( MaxNameCount == 0  &&  !pszName )
    {
        return NULL;
    }

    //
    //  allocate for max entries
    //

    length = sizeof(SEARCH_LIST)
                    - sizeof(SEARCH_NAME)
                    + ( sizeof(SEARCH_NAME) * MaxNameCount );

    psearchList = (PSEARCH_LIST) ALLOCATE_HEAP_ZERO( length );
    if ( ! psearchList )
    {
        return NULL;
    }

    psearchList->MaxNameCount = MaxNameCount;

    if ( pszName )
    {
        psearchList->pszDomainOrZoneName = Dns_CreateStringCopy( pszName, 0 );
        if ( ! psearchList->pszDomainOrZoneName )
        {
            FREE_HEAP( psearchList );
            return NULL;
        }
    }
    return psearchList;
}



VOID
SearchList_Free(
    IN OUT  PSEARCH_LIST    pSearchList
    )
/*++

Routine Description:

    Free SEARCH_LIST structure.

Arguments:

    pSearchList -- ptr to search list to free

Return Value:

    None

--*/
{
    DWORD i;

    DNSDBG( TRACE, ( "SearchList_Free( %p )\n", pSearchList ));

    //
    //  DCR:  eliminate search list DomainOrZoneName
    //

    if ( pSearchList )
    {
        if ( pSearchList->pszDomainOrZoneName )
        {
            FREE_HEAP( pSearchList->pszDomainOrZoneName );
        }

        for ( i=0; i < pSearchList->MaxNameCount; i++ )
        {
            PSTR    pname = pSearchList->SearchNameArray[i].pszName;
            if ( pname )
            {
                FREE_HEAP( pname );
            }
        }

        FREE_HEAP( pSearchList );
    }
}



PSEARCH_LIST    
SearchList_Copy(
    IN      PSEARCH_LIST    pSearchList
    )
/*++

Routine Description:

    Create copy of search list.

Arguments:

    pSearchList -- search list to copy

Return Value:

    Ptr to DNS Search list copy, if successful
    NULL on failure.

--*/
{
    PSEARCH_LIST    pcopy;
    DWORD           i;

    DNSDBG( TRACE, ( "SearchList_Copy()\n" ));

    if ( ! pSearchList )
    {
        return NULL;
    }

    //
    //  create DNS Search list of desired size
    //
    //  since we don't add and delete from search list once
    //  created, size copy only for actual name count
    //

    pcopy = SearchList_Alloc(
                pSearchList->NameCount,
                pSearchList->pszDomainOrZoneName );
    if ( ! pcopy )
    {
        return NULL;
    }

    for ( i=0; i < pSearchList->NameCount; i++ )
    {
        PSTR    pname = pSearchList->SearchNameArray[i].pszName;

        if ( pname )
        {
            pname = Dns_CreateStringCopy(
                        pname,
                        0 );
            if ( pname )
            {
               pcopy->SearchNameArray[i].pszName = pname;
               pcopy->SearchNameArray[i].Flags =
                            pSearchList->SearchNameArray[i].Flags;
               pcopy->NameCount++;
            }
        }
    }

    return pcopy;
}



BOOL
SearchList_ContainsName(
    IN      PSEARCH_LIST    pSearchList,
    IN      PSTR            pszName
    )
/*++

Routine Description:

    Check if name is in search list.

Arguments:

    pSearchList -- ptr to search list being built

    pszName -- name to check

Return Value:

    TRUE if name is in search list.
    FALSE otherwise.

--*/
{
    DWORD   count = pSearchList->NameCount;

    //
    //  check every search list entry for this name
    //

    while ( count-- )
    {
        if ( Dns_NameCompare_UTF8(
                pSearchList->SearchNameArray[ count ].pszName,
                pszName ) )
        {
            return( TRUE );
        }
    }
    return( FALSE );
}



VOID
SearchList_AddName(
    IN OUT  PSEARCH_LIST    pSearchList,
    IN      PSTR            pszName,
    IN      DWORD           Flag
    )
/*++

Routine Description:

    Add name to search list.

Arguments:

    pSearchList -- ptr to search list being built

    pszName -- name to add to search list

    Flag -- flag value

Return Value:

    None.  Name is added to search list, unless memory alloc failure.

--*/
{
    DWORD   count = pSearchList->NameCount;
    PSTR    pallocName;

    DNSDBG( TRACE, ( "Search_AddName()\n" ));

    //
    //  ignore name is already in list
    //  ignore if at list max
    //

    if ( SearchList_ContainsName(
            pSearchList,
            pszName )
                ||
         count >= pSearchList->MaxNameCount )
    {
        return;
    }

    //  copy name and put in list

    pallocName = Dns_CreateStringCopy( pszName, 0 );
    if ( !pallocName )
    {
        return;
    }
    pSearchList->SearchNameArray[count].pszName = pallocName;

    //
    //  set flag -- but first flag always zero (normal timeouts)
    //      this protects against no PDN situation where use adapter
    //      name as PDN;

    if ( count == 0 )
    {
        Flag = 0;
    }
    pSearchList->SearchNameArray[count].Flags = Flag;
    pSearchList->NameCount = ++count;
}



DNS_STATUS
SearchList_Parse(
    IN OUT  PSEARCH_LIST    pSearchList,
    IN      PSTR            pszList
    )
/*++

Routine Description:

    Parse registry search list string into SEARCH_LIST structure.

Arguments:

    pSearchList -- search list array

    pszList -- registry list of search names;
        names are comma or white space separated

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    register    PCHAR pch = pszList;
    CHAR        ch;
    PUCHAR      pnameStart;
    DWORD       countNames = pSearchList->NameCount;

    DNSDBG( NETINFO, (
        "SearchList_Parse( %p, %s )\n",
        pSearchList,
        pszList ));

    //
    //  extract each domain name string in buffer,
    //  and add to search list array
    //

    while( ch = *pch && countNames < DNS_MAX_SEARCH_LIST_ENTRIES )
    {
        //  skip leading whitespace, find start of domain name string

        while( ch == ' ' || ch == '\t' || ch == ',' )
        {
            ch = *++pch;
        }
        if ( ch == 0 )
        {
            break;
        }
        pnameStart = pch;

        //
        //  find end of string and NULL terminate
        //

        ch = *pch;
        while( ch != ' ' && ch != '\t' && ch != '\0' && ch != ',' )
        {
            ch = *++pch;
        }
        *pch = '\0';

        //
        //  end of buffer?
        //

        if ( pch == pnameStart )
        {
            break;
        }

        //
        //  whack any trailing dot on name
        //

        pch--;
        if ( *pch == '.' )
        {
            *pch = '\0';
        }
        pch++;

        //
        //  make copy of the name
        //

        pSearchList->SearchNameArray[ countNames ].pszName =
            Dns_CreateStringCopy( pnameStart, 0 );

        if ( pSearchList->SearchNameArray[ countNames ].pszName )
        {
            pSearchList->SearchNameArray[ countNames ].Flags = 0;
            countNames++;
        }

        //  if more continue

        if ( ch != 0 )
        {
            pch++;
            continue;
        }
        break;
    }

    //  reset name count

    pSearchList->NameCount = countNames;

    return( ERROR_SUCCESS );
}



PSEARCH_LIST    
SearchList_Build(
    IN      PSTR            pszPrimaryDomainName,
    IN      PREG_SESSION    pRegSession,
    IN      HKEY            hKey,
    IN OUT  PDNS_NETINFO    pNetInfo,
    IN      BOOL            fUseDomainNameDevolution,
    IN      BOOL            fUseDotLocalDomain
    )
/*++

Routine Description:

    Build search list.

Arguments:

    pszPrimaryDomainName -- primary domain name

    pRegSession -- registry session

    hKey -- registry key

Return Value:

    Ptr to search list.
    NULL on error or no search list.

--*/
{
    PSEARCH_LIST    ptempList;
    PSTR            pregList = NULL;
    DWORD           status;


    DNSDBG( TRACE, ( "Search_ListBuild()\n" ));

    ASSERT( pRegSession || hKey );

    //
    //  create search list using PDN
    //

    ptempList = SearchList_Alloc(
                    DNS_MAX_SEARCH_LIST_ENTRIES,
                    pszPrimaryDomainName );
    if ( !ptempList )
    {
        return( NULL );
    }

    //
    //  read search list from registry
    //

    ptempList->NameCount = 0;

    status = Reg_GetValue(
                    pRegSession,
                    hKey,
                    RegIdSearchList,
                    REGTYPE_SEARCH_LIST,
                    (PBYTE*) &pregList
                    );

    if ( status == ERROR_SUCCESS )
    {
        ASSERT( pregList != NULL );

        SearchList_Parse(
            ptempList,
            pregList );

        FREE_HEAP( pregList );
    }

    //
    //  if no registry search list -- build one
    //
    //  DCR:  eliminate autobuilt search list
    //

    if ( ! ptempList->NameCount )
    {
        PSTR    pname;
        DWORD   countNames = 0;
        DWORD   iter;

        //
        //  use PDN in first search list slot
        //

        if ( pszPrimaryDomainName )
        {
            SearchList_AddName(
                ptempList,
                pszPrimaryDomainName,
                0 );
        }

        //
        //  add devolved PDN if have NameDevolution
        //

        if ( ptempList->pszDomainOrZoneName &&
             fUseDomainNameDevolution )
        {
            PSTR  ptoken = ptempList->pszDomainOrZoneName;

            ptoken = strchr( ptoken, '.' );

            while ( ptoken )
            {
                ptoken += 1;

                if ( strchr( ptoken, '.' ) )
                {
                    SearchList_AddName(
                        ptempList,
                        ptoken,
                        DNS_QUERY_USE_QUICK_TIMEOUTS );

                    ptoken = strchr( ptoken, '.' );
                    continue;
                }
                break;
            }
        }

        //
        //  add ".local" to search list if enabled
        //

        if ( fUseDotLocalDomain )
        {
            SearchList_AddName(
                ptempList,
                MULTICAST_DNS_LOCAL_DOMAIN,
                DNS_QUERY_MULTICAST_ONLY
                );
        }

        //  indicate this is dummy search list

        if ( pNetInfo )
        {
            pNetInfo->InfoFlags |= DNS_FLAG_DUMMY_SEARCH_LIST;
        }
    }

    return ptempList;
}



PSTR
SearchList_GetNextName(
    IN OUT  PSEARCH_LIST    pSearchList,
    IN      BOOL            fReset,
    OUT     PDWORD          pdwSuffixFlags  OPTIONAL
    )
/*++

Routine Description:

    Gets the next name from the search list.

Arguments:

    pSearchList -- search list

    fReset -- TRUE to reset to beginning of search list

    pdwSuffixFlags -- flags associate with using this suffix

Return Value:

    Ptr to the next search name.  Note, this is a pointer
    to a name in the search list NOT an allocation.  Search
    list structure must stay valid during use.

    NULL when out of search names.

--*/
{
    DWORD   flag = 0;
    PSTR    pname = NULL;
    DWORD   index;


    DNSDBG( TRACE, ( "SearchList_GetNextName()\n" ));

    //  no list

    if ( !pSearchList )
    {
        goto Done;
    }

    //
    //  reset?
    //

    if ( fReset )
    {
        pSearchList->CurrentNameIndex = 0;
    }

    //
    //  if valid name -- retrieve it
    //

    index = pSearchList->CurrentNameIndex;

    if ( index < pSearchList->NameCount )
    {
        pname = pSearchList->SearchNameArray[index].pszName;
        flag = pSearchList->SearchNameArray[index].Flags;
        pSearchList->CurrentNameIndex = ++index;
    }

Done:

    if ( pdwSuffixFlags )
    {
        *pdwSuffixFlags = flag;
    }
    return pname;
}



//
//  Net info routines
//

PDNS_NETINFO
NetInfo_Alloc(
    IN      DWORD           AdapterCount
    )
/*++

Routine Description:

    Allocate network info.

Arguments:

    AdapterCount -- count of net adapters info will hold

Return Value:

    Ptr to uninitialized DNS network info, if successful
    NULL on failure.

--*/
{
    PDNS_NETINFO    pnetInfo;
    DWORD           length;

    DNSDBG( TRACE, ( "NetInfo_Alloc()\n" ));

    //
    //  alloc
    //      - zero to avoid garbage on early free
    //

    length = sizeof(DNS_NETINFO)
                - sizeof(PDNS_ADAPTER)
                + (sizeof(PDNS_ADAPTER) * AdapterCount);

    pnetInfo = (PDNS_NETINFO) ALLOCATE_HEAP_ZERO( length );
    if ( ! pnetInfo )
    {
        return NULL;
    }

    pnetInfo->MaxAdapterCount = AdapterCount;

    return( pnetInfo );
}



VOID
NetInfo_Free(
    IN OUT  PDNS_NETINFO    pNetInfo
    )
/*++

Routine Description:

    Free DNS_NETINFO structure.

Arguments:

    pNetInfo -- ptr to netinfo to free

Return Value:

    None

--*/
{
    DWORD i;

    DNSDBG( TRACE, ( "NetInfo_Free( %p )\n", pNetInfo ));

    if ( ! pNetInfo )
    {
        return;
    }
    IF_DNSDBG( OFF )
    {
        DnsDbg_NetworkInfo(
            "Network Info before free: ",
            pNetInfo );
    }

    //
    //  free
    //      - search list
    //      - domain name
    //      - all the adapter info blobs
    //

    SearchList_Free( pNetInfo->pSearchList );

    if ( pNetInfo->pszDomainName )
    {
        FREE_HEAP( pNetInfo->pszDomainName );
    }
    if ( pNetInfo->pszHostName )
    {
        FREE_HEAP( pNetInfo->pszHostName );
    }

    for ( i=0; i < pNetInfo->AdapterCount; i++ )
    {
        AdapterInfo_Free( pNetInfo->AdapterArray[i] );
    }

    FREE_HEAP( pNetInfo );
}



PDNS_NETINFO     
NetInfo_Copy(
    IN      PDNS_NETINFO    pNetInfo
    )
/*++

Routine Description:

    Create copy of DNS Network info.

Arguments:

    pNetInfo -- DNS Network info to copy

Return Value:

    Ptr to DNS Network info copy, if successful
    NULL on failure.

--*/
{
    PDNS_NETINFO    pcopy;
    DWORD           adapterCount;
    DWORD           i;

    DNSDBG( TRACE, ( "NetInfo_Copy( %p )\n", pNetInfo ));

    if ( ! pNetInfo )
    {
        return NULL;
    }

    IF_DNSDBG( NETINFO2 )
    {
        DnsDbg_NetworkInfo(
            "Netinfo to copy: ",
            pNetInfo );
    }

    //
    //  create network info struct of desired size
    //

    pcopy = NetInfo_Alloc( pNetInfo->AdapterCount );
    if ( ! pcopy )
    {
        return NULL;
    }

    //
    //  copy flat fields
    //      - must reset MaxAdapterCount to actual allocation
    //      - AdapterCount reset below

    RtlCopyMemory(
        pcopy,
        pNetInfo,
        (PBYTE) &pcopy->AdapterArray[0] - (PBYTE)pcopy );

    pcopy->MaxAdapterCount = pNetInfo->AdapterCount;

    //
    //  copy subcomponents
    //      - domain name
    //      - search list
    //      - adapter info for each adapter
    //

    pcopy->pszDomainName = Dns_CreateStringCopy(
                                    pNetInfo->pszDomainName,
                                    0 );
    pcopy->pszHostName = Dns_CreateStringCopy(
                                    pNetInfo->pszHostName,
                                    0 );

    pcopy->pSearchList = SearchList_Copy( pNetInfo->pSearchList );

    adapterCount = 0;
    for ( i=0; i < pNetInfo->AdapterCount; i++ )
    {
        PDNS_ADAPTER pnew = AdapterInfo_Copy( pNetInfo->AdapterArray[i] );
        if ( pnew )
        {
            pcopy->AdapterArray[ adapterCount++ ] = pnew;
        }
    }
    pcopy->AdapterCount = adapterCount;

    IF_DNSDBG( NETINFO2 )
    {
        DnsDbg_NetworkInfo(
            "Netinfo copy: ",
            pcopy );
    }
    return pcopy;
}
    


BOOL
NetInfo_AddAdapter(
    IN OUT  PDNS_NETINFO    pNetInfo,
    IN      PDNS_ADAPTER    pAdapter
    )
/*++

Routine Description:

    Add adapter info to network info.

Arguments:

    pNetInfo -- netinfo to add to

    pAdapter -- actual adapter to add (it is plugged in NOT copied)

Return Value:

    TRUE if successful.
    FALSE if list full.

--*/
{
    DWORD   i;

    DNSDBG( TRACE, ( "NetInfo_AddAdapter( %p )\n", pNetInfo ));

    //
    //  find first open slot
    //

    for ( i = 0; i < pNetInfo->MaxAdapterCount; i++ )
    {
        if ( ! pNetInfo->AdapterArray[i] )
        {
            pNetInfo->AdapterArray[i] = pAdapter;
            pNetInfo->AdapterCount++;
            return( TRUE );
        }
    }

    IF_DNSDBG( NETINFO )
    {
        DnsDbg_NetworkInfo(
            "Network info failed adapter add: ",
            pNetInfo );
    }
    return( FALSE );
}



VOID
NetInfo_Clean(
    IN OUT  PDNS_NETINFO    pNetInfo,
    IN      DWORD           ClearLevel
    )
/*++

Routine Description:

    Clean network info.

    Removes all query specific info and restores to
    state that is "fresh" for next query.

Arguments:

    pNetInfo -- DNS network info

    ClearLevel -- level of runtime flag cleaning
        
Return Value:

    None

--*/
{
    DWORD   i;

    DNSDBG( TRACE, (
        "Enter NetInfo_Clean( %p, %08x )\n",
        pNetInfo,
        ClearLevel ));

    IF_DNSDBG( NETINFO2 )
    {
        DnsDbg_NetworkInfo(
            "Cleaning network info:",
            pNetInfo
            );
    }

    //
    //  clean up info
    //      - clear status fields
    //      - clear RunFlags
    //      - clear temp bits on InfoFlags
    //
    //  note, runtime flags are wiped depending on level
    //      specified in call
    //      - all (includes disabled\timedout adapter info)
    //      - query (all query info)
    //      - name (all info for single name query)
    //
    //  finally we set NETINFO_PREPARED flag so that we can
    //  can check for and do this initialization in the send
    //  code if not previously done;
    //
    //  in the standard query path we can
    //      - do this init
    //      - disallow adapters based on query name
    //      - send without the info getting wiped
    //
    //  in other send paths
    //      - send checks that NETINFO_PREPARED is not set
    //      - does basic init
    //

    pNetInfo->ReturnFlags &= ClearLevel;
    pNetInfo->ReturnFlags |= RUN_FLAG_NETINFO_PREPARED;

    for( i=0; i<pNetInfo->AdapterCount; i++ )
    {
        PDNS_ADAPTER    padapter;
        DWORD           j;

        padapter = pNetInfo->AdapterArray[i];

        padapter->Status = 0;
        padapter->RunFlags &= ClearLevel;
        padapter->ServerIndex = EMPTY_SERVER_INDEX;

        //  clear server status fields

        for ( j=0; j<padapter->ServerCount; j++ )
        {
            padapter->ServerArray[j].Status = DNSSS_NEW;
        }
    }
}



VOID
NetInfo_ResetServerPriorities(
    IN OUT  PDNS_NETINFO    pNetInfo,
    IN      BOOL            fLocalDnsOnly
    )
/*++

Routine Description:

    Resets the DNS server priority values for the DNS servers.

Arguments:

    pNetInfo -- pointer to a DNS network info structure.

    fLocalDnsOnly - TRUE to reset priority ONLY on local DNS servers
        Note that this requires that the network info contain the IP address
        list for each adapter so that the IP address list can be compared
        to the DNS server list.

Return Value:

    Nothing

--*/
{
    DWORD   i;
    DWORD   j;

    DNSDBG( TRACE, ( "NetInfo_ResetServerPriorities( %p )\n", pNetInfo ));

    if ( ! pNetInfo )
    {
        return;
    }

    //
    //  reset priorities on server
    //  when
    //      - not do local only OR
    //      - server IP matches one of adapter IPs
    //
    //  DCR:  local DNS check needs IP6 fixups
    //

    for ( i = 0; i < pNetInfo->AdapterCount; i++ )
    {
        PDNS_ADAPTER    padapter = pNetInfo->AdapterArray[i];

        for ( j=0; j < padapter->ServerCount; j++ )
        {
            PDNS_SERVER_INFO  pserver = &padapter->ServerArray[j];

            if ( !fLocalDnsOnly ||
                 Dns_IsAddressInIpArray(
                    padapter->pAdapterIPAddresses,
                    pserver->IpAddress ) ||
                 pserver->IpAddress == DNS_NET_ORDER_LOOPBACK )
            {
                pserver->Priority = 0;
            }
        }
    }
}



PIP_ARRAY
NetInfo_ConvertToIpArray(
    IN      PDNS_NETINFO    pNetInfo
    )
/*++

Routine Description:

    Create IP array of DNS servers from network info.

Arguments:

    pNetInfo -- DNS net adapter list to convert

Return Value:

    Ptr to IP array, if successful
    NULL on failure.

--*/
{
    PIP_ARRAY   parray;
    DWORD       i;
    DWORD       j;
    DWORD       countServers = 0;

    DNSDBG( TRACE, ( "NetInfo_ConvertToIpArray( %p )\n", pNetInfo ));

    if ( ! pNetInfo )
    {
        return NULL;
    }

    //
    //  count up all the servers in list, create IP array of desired size
    //

    for ( i = 0;
          i < pNetInfo->AdapterCount;
          i++ )
    {
        countServers += pNetInfo->AdapterArray[i]->ServerCount;
    }
    parray = Dns_CreateIpArray( countServers );
    if ( !parray )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }
    DNS_ASSERT( parray->AddrCount == countServers );

    //
    //  read all servers into IP array
    //

    countServers = 0;
    for ( i = 0;
          i < pNetInfo->AdapterCount;
          i++ )
    {
        PDNS_ADAPTER    padapter = pNetInfo->AdapterArray[i];

        for ( j = 0;
              j < padapter->ServerCount;
              j++ )
        {
            parray->AddrArray[ countServers++ ]
                    = padapter->ServerArray[j].IpAddress;
        }
    }

    DNS_ASSERT( parray->AddrCount == countServers );
    return( parray );
}



PDNS_NETINFO     
NetInfo_CreateForUpdate(
    IN      PSTR            pszZone,
    IN      PSTR            pszServerName,
    IN      PIP_ARRAY       pServerArray,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Create network info suitable for update.

Arguments:

    pszZone -- target zone name

    pszServerName -- target server name

    pServerArray -- IP array with target server IP

    dwFlags -- flags


Return Value:

    Ptr to resulting update compatible network info.
    NULL on failure.

--*/
{
    PSEARCH_LIST    psearchList;
    PDNS_ADAPTER    padapter;
    PDNS_NETINFO    pnetworkInfo;

    DNSDBG( TRACE, ( "NetInfo_BuildForUpdate()\n" ));

    //
    //  allocate
    //

    pnetworkInfo = NetInfo_Alloc( 1 );
    if ( !pnetworkInfo )
    {
        return NULL;
    }

    //
    //  make search list from desired zone
    //

    if ( pszZone )
    {
        psearchList = SearchList_Alloc( 0, pszZone );
        if ( ! psearchList )
        {
            goto Fail;
        }
        pnetworkInfo->pSearchList = psearchList;
    }

    //
    //  convert IP array and server name to server list
    //

    padapter = AdapterInfo_CreateFromIpArray(
                    pServerArray,
                    dwFlags,
                    pszServerName,
                    NULL );
    if ( ! padapter )
    {
        goto Fail;
    }
    pnetworkInfo->AdapterArray[0] = padapter;
    pnetworkInfo->AdapterCount = 1;

    IF_DNSDBG( NETINFO2 )
    {
        DnsDbg_NetworkInfo(
            "Update network info is: ",
            pnetworkInfo );
    }
    return pnetworkInfo;

Fail:

    NetInfo_Free( pnetworkInfo );
    return NULL;
}



PSTR
NetInfo_UpdateZoneName(
    IN      PDNS_NETINFO    pNetInfo
    )
/*++

Routine Description:

    Retrieve update zone name.

Arguments:

    pNetInfo -- blob to check

Return Value:

    Ptr to update zone name.
    NULL on error.

--*/
{
    return  pNetInfo->pSearchList->pszDomainOrZoneName;

    //  return pNetInfo->AdapterArray[0]-pszAdapterGuidName;
    //  return pNetInfo->pszDomainName;
}



PSTR
NetInfo_UpdateServerName(
    IN      PDNS_NETINFO    pNetInfo
    )
/*++

Routine Description:

    Retrieve update servere name.

Arguments:

    pNetInfo -- blob to check

Return Value:

    Ptr to update zone name.
    NULL on error.

--*/
{
    return  pNetInfo->AdapterArray[0]->pszAdapterDomain;
}



BOOL
NetInfo_IsForUpdate(
    IN      PDNS_NETINFO    pNetInfo
    )
/*++

Routine Description:

    Check if network info blob if "update capable".

    This means whether it is the result of a FAZ and
    can be used to send updates.

Arguments:

    pNetInfo -- blob to check

Return Value:

    TRUE if update network info.
    FALSE otherwise.

--*/
{
    DNSDBG( TRACE, ( "NetInfo_IsForUpdate()\n" ));

    return  (   pNetInfo &&
                pNetInfo->pSearchList &&
                pNetInfo->pSearchList->pszDomainOrZoneName &&
                pNetInfo->AdapterCount == 1 &&
                pNetInfo->AdapterArray[0] );
}



PDNS_NETINFO     
NetInfo_CreateFromIpArray(
    IN      PIP4_ARRAY      pDnsServers,
    IN      IP4_ADDRESS     ServerIp,
    IN      BOOL            fSearchInfo,
    IN      PDNS_NETINFO    pNetInfo        OPTIONAL
    )
/*++

Routine Description:

    Create network info given DNS server list.

Arguments:

    pDnsServers -- IP array of DNS servers

    ServerIp -- single IP in list

    fSearchInfo -- TRUE if need search info

    pNetInfo -- current network info blob to copy search info
        from;  this field is only relevant if fSearchInfo is TRUE

Return Value:

    Ptr to resulting network info.
    NULL on failure.

--*/
{
    PDNS_NETINFO    pnetInfo;
    IP4_ARRAY       ipArray;
    PIP4_ARRAY      parray = pDnsServers;   
    PSEARCH_LIST    psearchList;
    PSTR            pdomainName;
    DWORD           flags = 0;

    //
    //  DCR:  eliminate search list form this routine
    //      i believe this routine is only used for query of
    //      FQDNs (usually in update) and doesn't require
    //      any default search info
    //
    //  DCR:  possibly combine with "BuildForUpdate" routine
    //      where search info included tacks this on
    //

    //
    //  if given single IP, ONLY use it
    //

    if ( ServerIp )
    {
        ipArray.AddrCount = 1;
        ipArray.AddrArray[0] = ServerIp;
        parray = &ipArray;
    }

    //
    //  convert server IPs into network info blob
    //      - simply use update function above to avoid duplicate code
    //

    pnetInfo = NetInfo_CreateForUpdate(
                    NULL,           // no zone
                    NULL,           // no server name
                    parray,
                    0               // no flags
                    );
    if ( !pnetInfo )
    {
        return( NULL );
    }

    //
    //  get search list and primary domain info
    //      - copy from passed in network info
    //          OR
    //      - cut directly out of new netinfo
    //

    if ( fSearchInfo )
    {
        if ( pNetInfo )
        {
            flags       = pNetInfo->InfoFlags;
            psearchList = SearchList_Copy( pNetInfo->pSearchList );
            pdomainName = Dns_CreateStringCopy(
                                pNetInfo->pszDomainName,
                                0 );

        }
        else
        {
            PDNS_NETINFO    ptempNetInfo = GetNetworkInfo();
    
            if ( ptempNetInfo )
            {
                flags       = ptempNetInfo->InfoFlags;
                psearchList = ptempNetInfo->pSearchList;
                pdomainName = ptempNetInfo->pszDomainName;
    
                ptempNetInfo->pSearchList = NULL;
                ptempNetInfo->pszDomainName = NULL;
                NetInfo_Free( ptempNetInfo );
            }
            else
            {
                psearchList = NULL;
                pdomainName = NULL;
            }
        }

        //  plug search info into new netinfo blob

        pnetInfo->pSearchList   = psearchList;
        pnetInfo->pszDomainName = pdomainName;
        pnetInfo->InfoFlags    |= (flags & DNS_FLAG_DUMMY_SEARCH_LIST);
    }
    
    return( pnetInfo );
}



//
//  DNS server reachability routines
//
//  These are used to build netinfo that has unreachable DNS
//  servers screened out of the list.
//

BOOL
IsReachableDnsServer(
    IN      PDNS_NETINFO    pNetInfo,
    IN      PDNS_ADAPTER    pAdapter,
    IN      IP4_ADDRESS     Ip4Addr
    )
/*++

Routine Description:

    Determine if DNS server is reachable.

Arguments:

    pNetInfo -- network info blob

    pAdapter -- struct with list of DNS servers

    Ip4Addr -- DNS server address to test for reachability

Return Value:

    TRUE if DNS server is reachable.
    FALSE otherwise.

--*/
{
    DWORD       interfaceIndex;
    DNS_STATUS  status;

    DNSDBG( NETINFO, (
        "Enter IsReachableDnsServer( %p, %p, %08x )\n",
        pNetInfo,
        pAdapter,
        Ip4Addr ));

    DNS_ASSERT( pNetInfo && pAdapter );

    //
    //  DCR:  should do reachablity once on netinfo build
    //
    //  DCR:  reachability test can be smarter
    //      - reachable if same subnet as adapter IP
    //      question:  multiple IPs?
    //      - reachable if same subnet as previous reachable IP
    //      question:  can tell if same subnet?
    //
    //  DCR:  reachability on multi-homed connected
    //      - if send on another interface, does that interface
    //      "seem" to be connected
    //      probably see if
    //          - same subnet as this inteface
    //          question:  multiple IPs
    //          - or share DNS servers in common
    //          question:  just let server go, this doesn't work if
    //          the name is not the same
    //


    //
    //  if only one interface, assume reachability
    //

    if ( pNetInfo->AdapterCount <= 1 )
    {
        DNSDBG( SEND, (
            "One interface, assume reachability!\n" ));
        return( TRUE );
    }

    //
    //  check if server IP is reachable on its interface
    //

    status = IpHelp_GetBestInterface(
                Ip4Addr,
                & interfaceIndex );

    if ( status != NO_ERROR )
    {
        DNS_ASSERT( FALSE );
        DNSDBG( ANY, (
            "GetBestInterface() failed! %d\n",
            status ));
        return( TRUE );
    }

    if ( pAdapter->InterfaceIndex != interfaceIndex )
    {
        DNSDBG( NETINFO, (
            "IP %s on interface %d is unreachable!\n"
            "\tsend would be on interface %d\n",
            IP_STRING( Ip4Addr ),
            pAdapter->InterfaceIndex,
            interfaceIndex ));

        return( FALSE );
    }

    return( TRUE );
}



BOOL
IsDnsReachableOnAlternateInterface(
    IN      PDNS_NETINFO    pNetInfo,
    IN      DWORD           InterfaceIndex,
    IN      IP4_ADDRESS     Ip4Addr
    )
/*++

Routine Description:

    Determine if IP address is reachable on adapter.

    This function determines whether DNS IP can be reached
    on the interface that the stack indicates, when that
    interface is NOT the one containing the DNS server.

    We need this so we catch the multi-homed CONNECTED cases
    where a DNS server is still reachable even though the
    interface the stack will send on is NOT the interface for
    the DNS server.

Arguments:

    pNetInfo -- network info blob

    Interface -- interface stack will send to IP on

    Ip4Addr -- DNS server address to test for reachability

Return Value:

    TRUE if DNS server is reachable.
    FALSE otherwise.

--*/
{
    PDNS_ADAPTER    padapter;
    DWORD           i;
    PIP4_ARRAY      pipArray;
    PIP4_ARRAY      psubnetArray;
    DWORD           ipCount;

    DNSDBG( NETINFO, (
        "Enter IsDnsReachableOnAlternateInterface( %p, %d, %08x )\n",
        pNetInfo,
        InterfaceIndex,
        Ip4Addr ));

    //
    //  find DNS adapter for interface
    //

    for( i=0; i<pNetInfo->AdapterCount; i++ )
    {
        padapter = pNetInfo->AdapterArray[i];

        if ( padapter->InterfaceIndex != InterfaceIndex )
        {
            padapter = NULL;
            continue;
        }
        break;
    }

    if ( !padapter )
    {
        DNSDBG( ANY, (
            "WARNING:  indicated send inteface %d NOT in netinfo!\n",
            InterfaceIndex ));
        return  FALSE;
    }

    //
    //  two success conditions:
    //      1)  our IP matches IP of DNS server for this interface
    //      2)  our IP is on subnet of IP on this interface
    //
    //  if either of these is TRUE then either
    //      - there is misconfiguration (not our problem)
    //      OR
    //      - these interfaces are connected and we can safely send on
    //      them
    //
    //  DCR:  it would be cool to save the default gateway for the interface
    //          and use it?

    for ( i=0; i<padapter->ServerCount; i++ )
    {
        if ( Ip4Addr == padapter->ServerArray[i].IpAddress )
        {
            DNSDBG( NETINFO, (
                "DNS server %08x also DNS server on send interface %d\n",
                Ip4Addr,
                InterfaceIndex ));
            return( TRUE );
        }
    }

    //  test for subnet match

    pipArray = padapter->pAdapterIPAddresses;
    psubnetArray = padapter->pAdapterIPSubnetMasks;

    if ( !pipArray ||
         !psubnetArray ||
         (ipCount = pipArray->AddrCount) != psubnetArray->AddrCount )
    {
        DNSDBG( ANY, ( "WARNING:  missing or invalid interface IP\\subnet info!\n" ));
        DNS_ASSERT( FALSE );
        return( FALSE );
    }

    for ( i=0; i<ipCount; i++ )
    {
        IP4_ADDRESS subnet = psubnetArray->AddrArray[i];

        if ( (subnet & Ip4Addr) == (subnet & pipArray->AddrArray[i]) )
        {
            DNSDBG( NETINFO, (
                "DNS server %08x on subnet of IP for send interface %d\n"
                "\tip = %08x, subnet = %08x\n",
                Ip4Addr,
                InterfaceIndex,
                pipArray->AddrArray[i],
                subnet ));

            return( TRUE );
        }
    }

    return( FALSE );
}



DNS_STATUS
StrikeOutUnreachableDnsServers(
    IN OUT  PDNS_NETINFO    pNetInfo
    )
/*++

Routine Description:

    Eliminate unreachable DNS servers from the list.

Arguments:

    pNetInfo    -- DNS netinfo to fix up

Return Value:

    ERROR_SUCCESS if successful

--*/
{
    DNS_STATUS      status;
    DWORD           validServers;
    PDNS_ADAPTER    padapter;
    DWORD           adapterIfIndex;
    DWORD           serverIfIndex;
    DWORD           i;
    DWORD           j;


    DNSDBG( NETINFO, (
        "Enter StrikeOutUnreachableDnsServers( %p )\n",
        pNetInfo ));

    DNS_ASSERT( pNetInfo );

    //
    //  if only one interface, assume reachability
    //

    if ( pNetInfo->AdapterCount <= 1 )
    {
        DNSDBG( NETINFO, (
            "One interface, assume reachability!\n" ));
        return( TRUE );
    }

    //
    //  loop through adapters
    //

    for( i=0; i<pNetInfo->AdapterCount; i++ )
    {
        padapter = pNetInfo->AdapterArray[i];

        //  ignore this adapter because there are no DNS
        //      servers configured?

        if ( padapter->InfoFlags & DNS_FLAG_IGNORE_ADAPTER )
        {
            continue;
        }

        //
        //  test all adapter's DNS servers for reachability
        //      
        //  note:  currently save no server specific reachability,
        //      so if any server reachable, proceed;
        //  also if iphelp fails just assume reachability and proceed,
        //      better timeouts then not reaching server we can reach
        //

        adapterIfIndex = padapter->InterfaceIndex;
        validServers = 0;

        for ( j=0; j<padapter->ServerCount; j++ )
        {
            IP4_ADDRESS dnsIp = padapter->ServerArray[j].IpAddress;

            status = IpHelp_GetBestInterface(
                            dnsIp,
                            & serverIfIndex );
        
            if ( status != NO_ERROR )
            {
                DNS_ASSERT( FALSE );
                DNSDBG( ANY, (
                    "GetBestInterface() failed! %d\n",
                    status ));
                validServers++;
                break;
                //continue;
            }

            //  server is reachable
            //      - queried on its adapter?
            //      - reachable through loopback
            //
            //  DCR:  tag unreachable servers individually

            if ( serverIfIndex == adapterIfIndex ||
                 serverIfIndex == 1 )
            {
                validServers++;
                break;
                //continue;
            }

            //  server can be reached on query interface

            if ( IsDnsReachableOnAlternateInterface(
                    pNetInfo,
                    serverIfIndex,
                    dnsIp ) )
            {
                validServers++;
                break;
                //continue;
            }
        }

        //
        //  disable adapter if no servers found
        //
        //  DCR:  alternative to ignoring unreachable
        //      - tag as unreachable
        //      - don't send to it on first pass
        //      - don't continue name error on unreachable
        //          (it would count as "heard from" when send.c routine
        //          works back through)

        if ( validServers == 0 )
        {
            padapter->InfoFlags |= (DNS_FLAG_IGNORE_ADAPTER |
                                    DNS_FLAG_SERVERS_UNREACHABLE);

            DNSDBG( NETINFO, (
                "No reachable servers on interface %d\n"
                "\tthis adapter (%p) ignored in DNS list!\n",
                adapterIfIndex,
                padapter ));
        }
    }

    return  ERROR_SUCCESS;
}



//
//  Main netinfo build routine
//

PDNS_NETINFO     
NetInfo_Build(
    IN      BOOL            fGetIpAddrs
    )
/*++

Routine Description:

    Build network info blob from registry.

    This is the FULL recreate function.

Arguments:

    fGetIpAddrs -- TRUE to include local IP addrs for each adapter

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    REG_SESSION         regSession;
    PREG_SESSION        pregSession = NULL;
    PDNS_NETINFO        pnetInfo = NULL;
    PDNS_ADAPTER        padapter = NULL;
    PIP_ARRAY           ptempArray = NULL;
    PIP_ARRAY           plocalIpArray = NULL;
    PIP_ARRAY           psubnetIpArray = NULL;
    PIP_ARRAY           pserverIpArray = NULL;
    DNS_STATUS          status = NO_ERROR;
    DWORD               count;
    PIP_ADAPTER_INFO    pipAdapterInfo = NULL;
    PIP_ADAPTER_INFO    pipAdapter = NULL;
    DWORD               value;
    PREG_GLOBAL_INFO    pregInfo = NULL;
    REG_GLOBAL_INFO     regInfo;
    REG_ADAPTER_INFO    regAdapterInfo;


    DNSDBG( TRACE, (
        "NetInfo_Build( %d )\n",
        fGetIpAddrs ));

    //
    //  always get IP addresses
    //      - for multi-adapter need for routing
    //      - need for local lookups
    //          (might as well just include)
    //
    //  DCR:  could skip include when RPCing to client for
    //      query\update that does not require
    //

    fGetIpAddrs = TRUE;

    //
    //  get adapters info from IP help
    //

    status = IpHelp_GetAdaptersInfo( &pipAdapterInfo );
    if ( status != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    //  open the registry
    //

    pregSession = &regSession;

    status = Reg_OpenSession(
                pregSession,
                0,
                0 );
    if ( status != ERROR_SUCCESS )
    {
        status = DNS_ERROR_NO_DNS_SERVERS;
        goto Cleanup;
    }

    //
    //  read global registry info
    //

    pregInfo = &regInfo;

    status = Reg_ReadGlobalInfo(
                pregSession,
                pregInfo
                );
    if ( status != ERROR_SUCCESS )
    {
        status = DNS_ERROR_NO_DNS_SERVERS;
        goto Cleanup;
    }

    //
    //  build adapter information
    //

    //  count up the active adapters

    pipAdapter = pipAdapterInfo;
    count = 0;

    while ( pipAdapter )
    {
        count++;
        pipAdapter = pipAdapter->Next;
    }

    //
    //  allocate net info blob
    //  allocate DNS server IP array
    //

    pnetInfo = NetInfo_Alloc( count );

    ptempArray = Dns_CreateIpArray( DNS_MAX_IP_INTERFACE_COUNT );

    if ( !pnetInfo ||
         !ptempArray )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Cleanup;
    }

    //
    //  set network info flags
    //
    //  DCR:  can use globals
    //

    if ( regInfo.fUseMulticast )
    {
        pnetInfo->InfoFlags |= DNS_FLAG_ALLOW_MULTICAST;
    }
    if ( regInfo.fUseMulticastOnNameError )
    {
        pnetInfo->InfoFlags |= DNS_FLAG_MULTICAST_ON_NAME_ERROR;
    }

    //
    //  loop through adapters -- build network info for each
    //

    pipAdapter = pipAdapterInfo;

    while ( pipAdapter )
    {
        DWORD                   adapterFlags = 0;
        PIP_PER_ADAPTER_INFO    pperAdapterInfo = NULL;
        PSTR                    padapterDomainName = NULL;

        //
        //  read adapter registry info
        //

        status = Reg_ReadAdapterInfo(
                    pipAdapter->AdapterName,
                    pregSession,
                    & regInfo,          // policy adapter info
                    & regAdapterInfo    // receives reg info read
                    );

        if ( status != NO_ERROR )
        {
            goto Skip;
        }

        //  translate results into flags

        if ( regAdapterInfo.fRegistrationEnabled )
        {
            adapterFlags |= DNS_FLAG_REGISTER_IP_ADDRESSES;
        }
        if ( regAdapterInfo.fRegisterAdapterName )
        {
            adapterFlags |= DNS_FLAG_REGISTER_DOMAIN_NAME;
        }

        //  use domain name?
        //      - if disable on per adapter basis, then it's dead

        if ( regAdapterInfo.fQueryAdapterName )
        {
            padapterDomainName = regAdapterInfo.pszAdapterDomainName;
        }
        
        //  set flag on DHCP adapters

        if ( pipAdapter->DhcpEnabled )
        {
            adapterFlags |= DNS_FLAG_IS_DHCP_CFG_ADAPTER;
        }

        //
        //  get adapter's IP addresses
        //
        //  DCR_FIX:  why get IPs if aren't going to use
        //

        ptempArray->AddrCount = 0;
        status = IpHelp_ParseIpAddressString(
                        ptempArray,
                        & pipAdapter->IpAddressList,
                        FALSE,                  //  Get the ip address(es)
                        TRUE                    //  Reverse the order because
                        );                      //      of broken iphlpapi!

        if ( ( status == NO_ERROR ) &&
             ( fGetIpAddrs || g_IsDnsServer ) )
        {
            plocalIpArray = Dns_CreateIpArrayCopy( ptempArray );

            //
            // Go the subnet mask(s)
            //
            //  DCR_QUESTION:  why failure case on getting subnets
            //      if doesn't work then IP help gave bad info and
            //      we should just agree we are dead
            //
            //  DCR_FIX:  default subnetting is class B!
            //

            ptempArray->AddrCount = 0;
            status = IpHelp_ParseIpAddressString(
                            ptempArray,
                            &pipAdapter->IpAddressList,
                            TRUE,           // Get the subnet mask(s)
                            TRUE );         // Reverse the order because
                                            //      of broken iphlpapi!
            if ( status == NO_ERROR )
            {
                psubnetIpArray = Dns_CreateIpArrayCopy( ptempArray );
            }
            else
            {
                psubnetIpArray = Dns_CreateIpArrayCopy( plocalIpArray );
                if ( psubnetIpArray )
                {
                    DWORD i;
    
                    for ( i=0;
                          i < psubnetIpArray->AddrCount;
                          i++ )
                    {
                        psubnetIpArray->AddrArray[i] = 0x0000ffff;
                    }
                    status = NO_ERROR;
                }
            }
        }

        if ( status != NO_ERROR )
        {
            goto Skip;
        }

        //
        //  get per-adapter information from the iphlpapi.dll.
        //      -- autonet
        //      -- DNS server list
        //

        status = IpHelp_GetPerAdapterInfo(
                        pipAdapter->Index,
                        & pperAdapterInfo );

        if ( status == NO_ERROR )
        {
            if ( pperAdapterInfo->AutoconfigEnabled &&
                 pperAdapterInfo->AutoconfigActive )
            {
                adapterFlags |= DNS_FLAG_IS_AUTONET_ADAPTER;
            }
        }

        //
        //  build DNS servers list for adapter
        //      - if policy override use it
        //      - otherwise use IP help list
        //

        if ( regInfo.pDnsServerArray )
        {
            pserverIpArray = regInfo.pDnsServerArray;
        }

        else if ( status == NO_ERROR )
        {
            //  parse DNS servers from IP help
            //
            //  DCR:  must be able to get IPv6

            pserverIpArray = ptempArray;

            ptempArray->AddrCount = 0;
            status = IpHelp_ParseIpAddressString(
                            ptempArray,
                            &pperAdapterInfo->DnsServerList,
                            FALSE,      //  get IP addresses
                            FALSE       //  no reverse
                            );

            if ( status != ERROR_SUCCESS )
            {
                //
                //  if no DNS servers found -- write loopback if on DNS server
                //
                //  DCR:  should we bother to write -- why not just use in
                //      memory?
                //

                if ( g_IsDnsServer &&
                     !(adapterFlags & DNS_FLAG_IS_DHCP_CFG_ADAPTER) &&
                     plocalIpArray &&
                     psubnetIpArray )
                {
                    Reg_WriteLoopbackDnsServerList(
                            pipAdapter->AdapterName,
                            pregSession );
                    
                    ptempArray->AddrCount = 1;
                    ptempArray->AddrArray[0] = DNS_NET_ORDER_LOOPBACK;
                }
                else    // no DNS servers
                {
                    pserverIpArray = NULL;
                    goto Skip;
                }
            }
        }

        //
        //  build adapter info
        //
        //  optionally add IP and subnet list;  note this is
        //  direct add of data (not alloc\copy) so clear pointers
        //  after to skip free
        //

        padapter = AdapterInfo_CreateFromIpArray(
                            pserverIpArray,
                            adapterFlags,
                            padapterDomainName,
                            pipAdapter->AdapterName );
        if ( padapter )
        {
            padapter->InterfaceIndex = pipAdapter->Index;

            if ( fGetIpAddrs &&
                 plocalIpArray &&
                 psubnetIpArray )
            {
                padapter->pAdapterIPAddresses = plocalIpArray;
                plocalIpArray = NULL;
                padapter->pAdapterIPSubnetMasks = psubnetIpArray;
                psubnetIpArray = NULL;
            }

            NetInfo_AddAdapter(
                    pnetInfo,
                    padapter );
        }

Skip:
        //
        //  cleanup adapter specific data
        //
        //  note:  no free of pserverIpArray, it IS the
        //      ptempArray buffer that we free at the end
        //

        Reg_FreeAdapterInfo(
            &regAdapterInfo,
            FALSE               // don't free blob, it is on stack
            );

        if ( pperAdapterInfo )
        {
            FREE_HEAP( pperAdapterInfo );
            pperAdapterInfo = NULL;
        }
        if ( plocalIpArray )
        {
            FREE_HEAP( plocalIpArray );
            plocalIpArray = NULL;
        }
        if ( psubnetIpArray )
        {
            FREE_HEAP( psubnetIpArray );
            psubnetIpArray = NULL;
        }

        //  get next adapter
        //  reset status, so failure on the last adapter is not
        //      seen as global failure

        pipAdapter = pipAdapter->Next;

        status = ERROR_SUCCESS;
    }

    //
    //  eliminate unreachable DNS servers
    //

    if ( g_ScreenUnreachableServers )
    {
        StrikeOutUnreachableDnsServers( pnetInfo );
    }

    //
    //  build search list for network info
    //      - skip if no active adapters found
    //
    //  DCR:  shouldn't build search list?
    //
    //  DCR:  only build if actually read search list 
    //

    if ( pnetInfo->AdapterCount )
    {
        pnetInfo->pSearchList = SearchList_Build(
                                        regInfo.pszPrimaryDomainName,
                                        pregSession,
                                        NULL,           // no explicit key
                                        pnetInfo,
                                        regInfo.fUseNameDevolution,
                                        regInfo.fUseDotLocalDomain
                                        );
    }

    //
    //  host and domain name info
    //

    pnetInfo->pszDomainName = Dns_CreateStringCopy(
                                    regInfo.pszPrimaryDomainName,
                                    0 );
    pnetInfo->pszHostName = Dns_CreateStringCopy(
                                    regInfo.pszHostName,
                                    0 );

    //  timestamp

    pnetInfo->TimeStamp = Dns_GetCurrentTimeInSeconds();


Cleanup:                                           

    //  free allocated reg info

    Reg_FreeGlobalInfo(
        pregInfo,
        FALSE       // don't free blob, it is on stack
        );

    if ( pipAdapterInfo )
    {
        FREE_HEAP( pipAdapterInfo );
    }
    if ( ptempArray )
    {
        FREE_HEAP( ptempArray );
    }
    if ( pnetInfo &&
         pnetInfo->AdapterCount == 0 )
    {
        status = DNS_ERROR_NO_DNS_SERVERS;
    }

    //  close registry session

    Reg_CloseSession( pregSession );

    if ( status != ERROR_SUCCESS )
    {
        NetInfo_Free( pnetInfo );

        DNSDBG( TRACE, (
            "Leave:  NetInfo_Build()\n"
            "\tstatus = %d\n",
            status ));

        SetLastError( status );
        return( NULL );
    }

    DNSDBG( TRACE, (
        "Leave:  NetInfo_Build()\n"
        "\treturning fresh built network info (%p)\n",
        pnetInfo ));

    return( pnetInfo );
}



//
//  Network info caching\state routines
//

VOID
InitNetworkInfo(
    VOID
    )
/*++

Routine Description:

    Initialize network info.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    //  currently using general CS as netinfo cache lock
    //      so no real init here
    //

    //    InitializeCriticalSection( &csNetworkInfo );
    g_pNetInfo = NULL;
}


VOID
CleanupNetworkInfo(
    VOID
    )
/*++

Routine Description:

    Initialize network info.

Arguments:

    None

Return Value:

    None

--*/
{
    DNS_NETINFO pold;

    LOCK_NETINFO();

    NetInfo_Free( g_pNetInfo );
    g_pNetInfo = NULL;

    UNLOCK_NETINFO();
}



//
//  Read config from resolver
//

PDNS_NETINFO         
UpdateDnsConfig(
    VOID
    )
/*++

Routine Description:

    Update DNS configuration.

    This includes entire config
        - flat registry DWORD\BOOL globals
        - netinfo list

Arguments:

    None

Return Value:

    Ptr to network info blob.

--*/
{
    DNS_STATUS          status = ERROR_SUCCESS;
    PDNS_NETINFO        pnetworkInfo = NULL;
    PDNS_GLOBALS_BLOB   pglobalsBlob = NULL;

    DNSDBG( TRACE, ( "UpdateDnsConfig()\n" ));

#if DNSBUILDOLD
    if ( !g_IsWin2000 )
    {
        return  NULL;
    }
#endif


    //  DCR_CLEANUP:  RPC TryExcept should be in RPC client library

    RpcTryExcept
    {
        R_ResolverGetConfig(
            NULL,               // default handle
            g_ConfigCookie,
            & pnetworkInfo,
            & pglobalsBlob
            );
    }
    RpcExcept( DNS_RPC_EXCEPTION_FILTER )
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    if ( status != ERROR_SUCCESS )
    {
        DNSDBG( RPC, (
            "R_ResolverGetConfig()  RPC failed status = %d\n",
            status ));
        return  NULL;
    }

    //
    //  DCR:  save other config info here
    //      - flat memcpy of DWORD globals
    //      - save off cookie (perhaps include as one of them
    //      - save global copy of pnetworkInfo?
    //          (the idea being that we just copy it if
    //          RPC cookie is valid)
    //
    //      - maybe return flags?
    //          memcpy is cheap but if more expensive config
    //          then could alert what needs update?
    //

    //
    //  DCR:  once move, single "update global network info"
    //      then call it here to save global copy
    //      but global copy doesn't do much until RPC fails
    //      unless using cookie
    //


    //  QUESTION:  not sure about forcing global build here
    //      q:  is this to be "read config" all
    //          or just "update config" and then individual
    //          routines for various pieces of config can
    //          determine what to do?
    //
    //      note, doing eveything is fine if going to always
    //      read entire registry on cache failure;  if so
    //      reasonable to push here
    //
    //      if cache-on required for "real time" config, then
    //      should protect registry DWORD read with reasonable time
    //      (say read every five\ten\fifteen minutes?)
    //
    //      perhaps NO read here, but have DWORD reg read update
    //      routine that called before registry reread when
    //      building adapter list in registry;  then skip this
    //      step in cache
    //

    //
    //  copy in config
    //

    if ( pglobalsBlob )
    {
        RtlCopyMemory(
            & DnsGlobals,
            pglobalsBlob,
            sizeof(DnsGlobals) );

        MIDL_user_free( pglobalsBlob );
    }
    
    IF_DNSDBG( RPC )
    {
        DnsDbg_NetworkInfo(
            "Network Info returned from cache:",
            pnetworkInfo );
    }

    return  pnetworkInfo;
}



//
//  Public netinfo routine
//

PDNS_NETINFO     
NetInfo_Get(
    IN      BOOL            fForce,
    IN      BOOL            fGetIpAddresses
    )
/*++

Routine Description:

    Read DNS network info from registry.

    This is in process, limited caching version.
    Note, this is macro'd as GetNetworkInfo() with parameters
        NetInfo_Get( FALSE, TRUE ) throughout dnsapi code.

Arguments:

    fForce -- force reread from registry

    fGetIpAddresses -- keep the local IP addresses for each adapter
                       and store within the structure.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PDNS_NETINFO    pnetInfo;
    PDNS_NETINFO    poldNetInfo = NULL;
    BOOL            flocked = FALSE;
    BOOL            fcacheable = TRUE;

    DNSDBG( NETINFO, ( "NetInfo_Get()\n" ));


    //
    //  hold lock while accessing cached network info
    //
    //  try
    //      - very recent local cached copy
    //      - RPC copy from resolver
    //      - build new
    //

    if ( ! fForce &&
         ! g_DnsTestMode )
    {
        LOCK_NETINFO();
        flocked = TRUE;

        //  check if valid copy cached in process

        if ( g_pNetInfo &&
            (g_pNetInfo->TimeStamp + NETINFO_CACHE_TIMEOUT)
                > Dns_GetCurrentTimeInSeconds() ) 
        {
            pnetInfo = NetInfo_Copy( g_pNetInfo );
            if ( pnetInfo )
            {
                DNSDBG( TRACE, (
                    "Netinfo found in process cache.\n" ));
                goto Unlock;
            }
        }

        //  check RPC to resolver
        //
        //  DCR:  this could present "cookie" of existing netinfo
        //      and only get new if "cookie" is old, though the
        //      cost of that versus local copy seems small since
        //      still must do RPC and allocations -- only the copy
        //      for RPC on the resolver side is saved

        pnetInfo = UpdateDnsConfig();
        if ( pnetInfo )
        {
            DNSDBG( TRACE, (
                "Netinfo read from resolver.\n" ));
            goto CacheCopy;
        }
    }

    //
    //  build fresh network info
    //      - if successful clear "dirty" flag
    //
    //  Note:  we call down unlocked.  Ideally we'd have only one thread
    //  in the process building at a given time, and let other threads
    //  wait for completion.  However during call down, iphlpapi RPCs
    //  to MPR (router service) which can result in deadlock through
    //  a PPP call back to our DnsSetDwordConfig() => NetInfo_MarkDirty.
    //
    //  Here's the deadlock scenario: 
    //  1.  RtrMgr calls GetHostByName() which ends up in a
    //      iphlpapi!GetBestInterface call which in turn calls
    //      Mprapi!IsRouterRunning (which is an RPC to mprdim).
    //  2.  Mprdim is blocked on a CS which is held by a thread waiting
    //      for a demand-dial disconnect to complete - this is completely
    //      independent of 1.
    //  3.  Demand-dial disconnect is waiting for ppp to finish graceful
    //      termination.
    //  4.  PPP is waiting for dnsto return from DnsSetConfigDword, hence
    //      the deadlock.
    //
    //  This gave us a deadlock because NetInfo_MarkDirty() also waits
    //  on this lock.  MarkDirty could skip the lock -- one method would be
    //  to have this function clear the dirty flag, then call down again
    //  IF it got done and the flag was again dirty.  But that method could
    //  result if something is bogus down below.  And even if MarkDirty is
    //  fixed cleanly we still have the possibility that some service that
    //  IpHlpApi RPCs to, will issue name resolution and come back to the
    //  lock on a different thread.  (Because our many services in process
    //  model is busted.)
    //
    //  So best solution is not to do anything this big while holding a lock.
    //  (We could do hacking stuff here like have an event and wait for a
    //  second or so before figuring we were part of a deadlock and proceeding.)
    //
    //  Finally note that the perf hit is negligible because usually the netinfo
    //  is grabbed from the resolver.
    //

    if ( flocked )
    {
        UNLOCK_NETINFO();
        flocked = FALSE;
    }
    pnetInfo = NetInfo_Build( fGetIpAddresses );
    if ( !pnetInfo )
    {
        goto Unlock;
    }
    fcacheable = fGetIpAddresses;


CacheCopy:

    //
    //  update cached copy
    //      - but not if built without local IPs;
    //      resolver copy always contains local IPs
    //

    if ( fcacheable )
    {
        if ( !flocked )
        {
            LOCK_NETINFO();
            flocked = TRUE;
        }
        poldNetInfo = g_pNetInfo;
        g_pNetInfo = NetInfo_Copy( pnetInfo );
    }


Unlock:

    if ( flocked )
    {
        UNLOCK_NETINFO();
    }

    NetInfo_Free( poldNetInfo );

    DNSDBG( TRACE, (
        "Leave:  NetInfo_Get( %p )\n",
        pnetInfo ));

    return( pnetInfo );
}



VOID
NetInfo_MarkDirty(
    VOID
    )
/*++

Routine Description:

    Mark netinfo dirty so force reread.

Arguments:

    None

Return Value:

    None

--*/
{
    PDNS_NETINFO    pold;

    DNSDBG( NETINFO, ( "NetInfo_MarkDirty()\n" ));

    //
    //  dump global network info to force reread
    //
    //  since the resolve is always notified by DnsSetDwordConfig()
    //  BEFORE entering this function, the resolve should always be
    //  providing before we are in this function;  all we need to do
    //  is insure that cached copy is dumped
    //

    LOCK_NETINFO();

    pold = g_pNetInfo;
    g_pNetInfo = NULL;

    UNLOCK_NETINFO();

    NetInfo_Free( pold );
}



//
//  DNS server list
//

PIP4_ARRAY
GetDnsServerList(
    IN      BOOL            fForce
    )
/*++

Routine Description:

    Get DNS server list as IP array.

Arguments:

    fForce -- force reread from registry

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PDNS_NETINFO    pnetInfo = NULL;
    PIP_ARRAY       pserverIpArray = NULL;

    DNSDBG( TRACE, ( "GetDnsServerList()" ));

    //
    //  get network info to make list from
    //      - don't need IP address lists
    //

    pnetInfo = NetInfo_Get(
                    fForce,     // force registry read
                    FALSE       // no IP address lists
                    );
    if ( !pnetInfo )
    {
        SetLastError( DNS_ERROR_NO_DNS_SERVERS );
        return( NULL );
    }

    //
    //  convert network info to IP_ARRAY
    //

    pserverIpArray = NetInfo_ConvertToIpArray( pnetInfo );

    NetInfo_Free( pnetInfo );

    if ( !pserverIpArray )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }

    //  if no servers read, return

    if ( pserverIpArray->AddrCount == 0 )
    {
        FREE_HEAP( pserverIpArray );
        DNS_PRINT((
            "Dns_GetDnsServerList() failed:  no DNS servers found\n"
            "\tstatus = %d\n" ));
        SetLastError( DNS_ERROR_NO_DNS_SERVERS );
        return( NULL );
    }

    IF_DNSDBG( NETINFO )
    {
        DnsDbg_IpArray(
            "DNS server list",
            "server",
            pserverIpArray );
    }

    return( pserverIpArray );
}

//
//  End netinfo.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\memory.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    Domain Name System (DNS) Library

    Memory allocation routines for DNS library.

Author:

    Jim Gilroy (jamesg)    January, 1997

Revision History:

--*/


#include "local.h"


//
//  Private default dnsapi heap.
//
//  Use non-process heap just so i don't have to debug a stress
//  failure every time some yahoo corrupts their heap.
//

HEAP_BLOB   g_DnsApiHeap;


//
//  Heap flags
//

#if DBG
#define DNS_HEAP_FLAGS                          \
            (   HEAP_GROWABLE |                 \
                HEAP_TAIL_CHECKING_ENABLED |    \
                HEAP_FREE_CHECKING_ENABLED |    \
                HEAP_CREATE_ALIGN_16 |          \
                HEAP_CLASS_1 )
#else
#define DNS_HEAP_FLAGS                          \
            (   HEAP_GROWABLE |                 \
                HEAP_CREATE_ALIGN_16 |          \
                HEAP_CLASS_1 )
#endif



VOID
Heap_Initialize(
    VOID
    )
/*++

Routine Description:

    Initialize heap routines.

    MUST call this in dnsapi.dll attach.
    Note this doesn't actually create the heap.  For perf, don't
    do that until we actually get called.

Arguments:

    None.

Return Value:

    None.

--*/
{
#ifdef PRIVATE_DNSHEAP
    //
    //  use dnslib debug heap as private heap
    //

    LOCK_GENERAL();

    Dns_HeapInitialize(
        & g_DnsApiHeap,
        NULL,               // no existing heap handle
        DNS_HEAP_FLAGS,     // create flags
#if DBG
        TRUE,               // use debug headers
#else
        FALSE,              // no debug headers
#endif
        TRUE,               // dnslib uses this heap
        TRUE,               // full heap checks
        0,                  // no exception
        0,                  // no default flags
        "dnslib",           // bogus file
        0                   // bogus line no
        );

    UNLOCK_GENERAL();
#endif
}



VOID
Heap_Cleanup(
    VOID
    )
/*++

Routine Description:

    Delete heap.

    Need this to allow restart.

Arguments:

    None.

Return Value:

    None.

--*/
{
#ifdef PRIVATE_DNSHEAP
    //
    //  delete private heap
    //

    DNSDBG( ANY, ( "Heap_Cleanup()\n" ));

    Dns_HeapCleanup( &g_DnsApiHeap );
#endif
}




//
//  Exported routines
//

VOID
DnsApiHeapReset(
    IN  DNS_ALLOC_FUNCTION      pAlloc,
    IN  DNS_REALLOC_FUNCTION    pRealloc,
    IN  DNS_FREE_FUNCTION       pFree
    )
/*++

Routine Description:

    Resets heap routines used by dnsapi.dll routines.

    DnsApi.dll allocates memory using the dnslib.lib heap
    routines.  This simply resets those routines to use pointers
    to users heap routines.

Arguments:

    pAlloc      -- ptr to desired alloc function
    pRealloc    -- ptr to desired realloc function
    pFree       -- ptr to desired free function

Return Value:

    None.

--*/
{
    //  redirect heap for dnslib

    Dns_LibHeapReset( pAlloc, pRealloc, pFree );
}



//
//  External access to DNS memory routines.
//
//  Modules that use DNS API memory and can be called in the context
//  of DNS server or other process which points dnsapi.dll at another
//  heap, should use these routines rather than LocalAlloc\Free().
//
//  Note:  that these routines can simply call the dnslib routines.
//  This is because dnsapi ALWAYS keeps its heap in sync with dnslib
//  whether it is default heap or has been redirected.  Since dnslib
//  heap routines have the redirection check, we can just call them
//  and they'll do the right thing, we don't need a redirection check
//  ourselves.
//

PVOID
DnsApiAlloc(
    IN      INT             iSize
    )
{
    return  Dns_Alloc( iSize );
}

PVOID
DnsApiRealloc(
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    )
{
    return  Dns_Realloc( pMem, iSize );
}

VOID
DnsApiFree(
    IN OUT  PVOID           pMem
    )
{
    Dns_Free( pMem );
}



//
//  SDK public free
//
//  Extensions to DNS_FREE_TYPE enum in windns.h to handle
//  system-public structures.
//  These are only used if freeing with DnsFree(), if using
//  DnsFreeConfigStructure() then use the ConfigId directly.
//
//  For convenience free type is the same as the config id.
//  If this changes must change DnsFreeConfigStructure()
//  to do mapping.
//

//  These conflict with old function defs, so must undef
#undef  DnsFreeNetworkInformation
#undef  DnsFreeSearchInformation
#undef  DnsFreeAdapterInformation

#define DnsFreeNetworkInformation       (DNS_FREE_TYPE)DnsConfigNetworkInformation
#define DnsFreeSearchInformation        (DNS_FREE_TYPE)DnsConfigSearchInformation
#define DnsFreeAdapterInformation       (DNS_FREE_TYPE)DnsConfigAdapterInformation
#define DnsFreeNetInfo                  (DNS_FREE_TYPE)DnsConfigNetInfo

VOID
WINAPI
DnsFree(
    IN OUT  PVOID           pData,
    IN      DNS_FREE_TYPE   FreeType
    )
/*++

Routine Description:

    Generic DNS data free.

Arguments:

    pData -- data to free

    FreeType -- free type

Return Value:

    None

--*/
{
    DNSDBG( TRACE, (
        "DnsFree( %p, %d )\n",
        pData,
        FreeType ));

    if ( !pData )
    {
        return;
    }

    //
    //  free appropriate type
    //

    switch ( FreeType )
    {
    case  DnsFreeFlat:

        DnsApiFree( pData );
        break;

    case  DnsFreeRecordList:

        Dns_RecordListFree( (PDNS_RECORD)pData );
        break;

    case  DnsFreeNetworkInformation:

        FreeNetworkInformation( pData );
        break;

    case  DnsFreeSearchInformation:

        FreeSearchInformation( pData );
        break;

    case  DnsFreeAdapterInformation:

        FreeAdapterInformation( pData );
        break;

    case  DnsFreeNetInfo:

        NetInfo_Free( pData );
        break;

    default:

        ASSERT( FALSE );
        DnsApiFree( pData );
        break;
    }
}

//
//  End memory.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\queue.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    queue.c

Abstract:

    Domain Name System (DNS) Server
    Queue functionality specific to Dynamic DNS registration.

Author:

    Ram Viswanathan (ramv)  March 27 1997

Revision History:

--*/


#include "local.h"

extern DWORD g_MainQueueCount;


//
//  Queue allocations in dnslib heap
//

#define QUEUE_ALLOC_HEAP(Size)      Dns_Alloc(Size)
#define QUEUE_ALLOC_HEAP_ZERO(Size) Dns_AllocZero(Size)
#define QUEUE_FREE_HEAP(pMem)       Dns_Free(pMem)


//
// helper functions
//

PQELEMENT
DequeueNoCrit(
    PDYNDNSQUEUE  pQueue
    );

DWORD
AddToTimedOutQueueNoCrit(
    PQELEMENT     pNewElement,
    PDYNDNSQUEUE  pRetryQueue,
    DWORD         dwRetryTime
    );

DWORD
HostAddrCmp(
    REGISTER_HOST_ENTRY HostAddr1,
    REGISTER_HOST_ENTRY HostAddr2
    )
{
    //
    //  DCR:  Ram's HostAddrCmp will need update for IPv6
    //
    //  returns 0 if the two hostaddresses are the same. Else we simply
    //  return (DWORD)-1
    //

    if ( (HostAddr1.dwOptions == HostAddr2.dwOptions)  &&
         (HostAddr1.Addr.ipAddr == HostAddr2.Addr.ipAddr))
    {

        return(0);

    } else {
        return( (DWORD)-1);
    }

    return ( (DWORD) -1);

}

VOID
DeleteListEntry(
    PDYNDNSQUEUE  pQueue,
    PQELEMENT*    ppQElement
    );


DWORD
InitializeQueues(
    PDYNDNSQUEUE * ppQueue,
    PDYNDNSQUEUE * ppTimedOutQueue
    )
/*
  InitializeQueue()

  This function initializes the queue system. This is invoked for the first
  time when you create the main queue and timed out queue

  Allocates appropriate memory etc

*/
{

    DWORD  dwRetval = ERROR_SUCCESS;

    *ppQueue = (PDYNDNSQUEUE) QUEUE_ALLOC_HEAP_ZERO( sizeof(DYNDNSQUEUE) );

    if (!*ppQueue){
        dwRetval = GetLastError();
        goto Exit;
    }

    *ppTimedOutQueue = (PDYNDNSQUEUE) QUEUE_ALLOC_HEAP_ZERO( sizeof(DYNDNSQUEUE) );

    if (!*ppTimedOutQueue){
        dwRetval = GetLastError();
        goto Exit;
    }


    (*ppQueue)->pHead = NULL;
    (*ppQueue)->pTail = NULL;

    (*ppTimedOutQueue)->pHead = NULL;
    (*ppTimedOutQueue)->pTail = NULL;

Exit:

    if (dwRetval)
    {
        if ( *ppQueue )
            QUEUE_FREE_HEAP( *ppQueue );

        if ( *ppTimedOutQueue )
            QUEUE_FREE_HEAP( *ppTimedOutQueue );
    }

    return(dwRetval);
}


DWORD
FreeQueue(
    PDYNDNSQUEUE  pQueue
    )
/*
  FreeQueue()

  Frees the queue object. If there exist any entries in the queue, we
  just blow them away

*/
{
    PQELEMENT pQElement;
    DWORD dwRetval = ERROR_SUCCESS;

    EnterCriticalSection(&g_QueueCS);
    if (!pQueue){
        dwRetval = ERROR_SUCCESS;
        goto Exit;
    }


    while (pQueue->pHead){
        pQElement = DequeueNoCrit(pQueue);

        DNS_ASSERT(pQElement);
        if ( pQElement->pszName )
            QUEUE_FREE_HEAP( pQElement->pszName );
        if ( pQElement->DnsServerList )
            QUEUE_FREE_HEAP( pQElement->DnsServerList );
        QUEUE_FREE_HEAP( pQElement );
        pQElement = NULL;
    }

    QUEUE_FREE_HEAP( pQueue );

Exit:
    LeaveCriticalSection(&g_QueueCS);
    return(ERROR_SUCCESS);

}

DWORD
Enqueue(
    PQELEMENT     pNewElement,
    PDYNDNSQUEUE  pQueue,
    PDYNDNSQUEUE  pTimedOutQueue
    )


/*
   Enqueue()

   Adds new element to queue

   Arguments:

   Return Value:

    is 0 if Success. and (DWORD)-1 if failure.

*/

{
    // add to tail of queue

    PQELEMENT  pIterator = NULL;
    DWORD      dwRetval = 0;
    DWORD      dwRetryTime = 0;

    pNewElement->pFLink = NULL;
    pNewElement->pBLink = NULL;

    pNewElement->dwRetryTime = 0; // unnecessary for this queue

    pNewElement->dwRetryCount = 0;
    EnterCriticalSection(&g_QueueCS);

    if (!pQueue || !pTimedOutQueue){
        dwRetval = (DWORD)-1;
        goto Exit;
    }

    dwRetryTime = ProcessQDependencies(pTimedOutQueue, pNewElement);

    if (dwRetryTime){

        //
        // we have dependents in timed out queue. Add to timed out queue
        // insert this element at the appropriate position
        //

        AddToTimedOutQueueNoCrit(pNewElement, pTimedOutQueue, dwRetryTime+1);


    } else {
        ProcessQDependencies(pQueue, pNewElement);


        if ( pQueue->pTail )
        {
            DNS_ASSERT(!pQueue->pTail->pBLink);
            pQueue->pTail->pBLink = pNewElement;
            pNewElement->pFLink = pQueue->pTail;
            pNewElement->pBLink = NULL;
            pQueue->pTail = pNewElement;

        }
        else
        {
            //
            // no tail element means no head element either
            //
            pQueue->pTail = pNewElement;
            pQueue->pHead = pNewElement;
            pNewElement->pBLink = NULL;
            pNewElement->pFLink = NULL;
        }

        g_MainQueueCount++;
    }

Exit:
    LeaveCriticalSection(&g_QueueCS);

    return (dwRetval);

}

PQELEMENT
DequeueNoCrit(
    PDYNDNSQUEUE  pQueue
    )

/*
   DequeueNoCrit()

   Removes an element from a queue. No Critical Section Used by freequeue
   and by Dequeue

   Arguments:

   Return Value:

    is the element at head of queue if Success. and NULL if failure.

*/


{

    PQELEMENT  pQueuePtr = NULL;
    PQELEMENT  pRet = NULL;

    if (!pQueue || !pQueue->pHead){
        goto Exit;
    }

    pRet = pQueue->pHead;

    pQueuePtr= pRet->pBLink;

    if (pQueuePtr){

        pQueuePtr->pFLink = NULL;
        pQueue->pHead = pQueuePtr;
    } else {
        //
        // no more elements in the Queue
        //

        pQueue->pHead = pQueue->pTail = NULL;
    }

    pRet->pFLink = NULL;
    pRet->pBLink = NULL;

Exit:
    return (pRet);

}




PQELEMENT
Dequeue(
    PDYNDNSQUEUE  pQueue
    )


/*
   Dequeue()

   Removes an element from a queue.

   Arguments:

   Return Value:

    is the element at head of queue if Success. and NULL if failure.

*/

{

    PQELEMENT pQElement = NULL;

    EnterCriticalSection(&g_QueueCS);

    pQElement = DequeueNoCrit(pQueue);

    LeaveCriticalSection(&g_QueueCS);

    return (pQElement);
}



DWORD
AddToTimedOutQueueNoCrit(
    PQELEMENT     pNewElement,
    PDYNDNSQUEUE  pRetryQueue,
    DWORD         dwRetryTime
    )


/*
   AddToTimedOutQueueNoCrit()

   Adds new element to timedout queue. Now the new element is added in a list
   of elements sorted according to decreasing order of Retry Times. An
   insertion sort type of algorithm is used.

   Arguments:

   Return Value:

   is 0 if Success. and (DWORD)-1 if failure.

*/

{
    DWORD       dwRetval = ERROR_SUCCESS;
    PQELEMENT   pTraverse = NULL;
    DWORD       dwVal = 0;
    //
    // parameter validation
    //

    if(!pNewElement || !pRetryQueue){
        dwRetval = (DWORD)-1;
        goto Exit;
    }

    // retry again in dwRetryTime
    pNewElement->dwRetryTime = dwRetryTime;

    pNewElement->dwRetryCount++;

    //
    // check to see if there are any dependencies
    //

    dwVal = ProcessQDependencies (
                pRetryQueue,
                pNewElement
                );

    //
    // ignore return values because we are inserting in the new queue
    // at a position determined by dwRetryTime
    //
    if (!pRetryQueue->pTail){
        //
        // the queue has no elements
        // no tail element means no head element either
        //
        pRetryQueue->pTail = pNewElement;
        pRetryQueue->pHead = pNewElement;
        dwRetval = 0;
        goto Exit;
    }


    //
    // elements must be added in decreasing order of timeouts.
    // go in and scan the list from the head.
    //

    pTraverse = pRetryQueue->pHead;


    while ( pTraverse !=NULL &&
            pTraverse->dwRetryTime <= pNewElement->dwRetryTime){

        pTraverse = pTraverse->pBLink;
    }

    if (pTraverse == NULL){

        // Now adding to the tail of the list

        pNewElement->pFLink = pRetryQueue->pTail;
        pNewElement->pBLink = NULL;
        pRetryQueue->pTail->pBLink = pNewElement;
        pRetryQueue->pTail = pNewElement;

    } else {
        //
        // insert in place
        //
        pNewElement->pBLink = pTraverse;
        pNewElement->pFLink = pTraverse->pFLink;
        if (pTraverse->pFLink){
            pTraverse->pFLink->pBLink = pNewElement;
        }
        pTraverse->pFLink = pNewElement;
    }


Exit:
    return (dwRetval);
}



DWORD
AddToTimedOutQueue(
    PQELEMENT     pNewElement,
    PDYNDNSQUEUE  pRetryQueue,
    DWORD         dwRetryTime
    )

{
    DWORD dwRetval = ERROR_SUCCESS;

    EnterCriticalSection(&g_QueueCS);

    dwRetval = AddToTimedOutQueueNoCrit(
                   pNewElement,
                   pRetryQueue,
                   dwRetryTime
                   );

    LeaveCriticalSection(&g_QueueCS);

    return (dwRetval);

}


DWORD
GetEarliestRetryTime(
    PDYNDNSQUEUE pRetryQueue
    )

/*
   GetEarliestRetryTime()

   Checks to see if there is any element at the head of the queue
   and gets the retry time for this element

   Arguments:

   Return Value:

    is retrytime if success and DWORD(-1) if there is no element or other
    failure

*/
{
    DWORD dwRetryTime ;

    EnterCriticalSection(&g_QueueCS);


    dwRetryTime = pRetryQueue && pRetryQueue->pHead ?
        (pRetryQueue->pHead->dwRetryTime):
        (DWORD)-1;

    LeaveCriticalSection(&g_QueueCS);

    return dwRetryTime;

}

/*
VOID
ProcessMainQDependencies(
    PDYNDNSQUEUE pQueue,
    PQELEMENT    pQElement
    )
{

    //
    // when you are adding an element to a main queue, you
    // just care about the case where all elements aren't
    // FORWARD_ONLY
    //

    BOOL fDelThisTime = FALSE;
    PQELEMENT pIterator = pQueue->pTail;

    while (pIterator!= NULL){

        fDelThisTime = FALSE;
        if (!HostAddrCmp(pIterator->HostAddr, pQElement->HostAddr)){
            //
            // ip addresses matched
            //

            if ((pIterator->dwOperation & DYNDNS_ADD_ENTRY) &&
                (pQElement->dwOperation & DYNDNS_DELETE_ENTRY)) {

                if ( pIterator->pszName &&
                     pQElement->pszName &&
                     !wcsicmp_ThatWorks( pIterator->pszName,
                                         pQElement->pszName ) )
                {
                    //
                    // blow away earlier entry entirely
                    //

                    DeleteListEntry(pQueue, &pIterator);
                    fDelThisTime = TRUE;

                }
                //
                // if names are not the same do nothing.
                // Issue:  Will we hit this code at all? Put
                // soft ASSERTS in this.
                //
            }
            else if ((pIterator->dwOperation & DYNDNS_DELETE_ENTRY) &&
                (pQElement->dwOperation & DYNDNS_ADD_ENTRY)) {


                if ( pIterator->pszName &&
                     pQElement->pszName &&
                     !wcsicmp_ThatWorks( pIterator->pszName,
                                         pQElement->pszName ) )
                {
                    //
                    // blow away earlier entry entirely
                    //
                    DeleteListEntry(pQueue, &pIterator);
                    fDelThisTime = TRUE;
                } else {
                    //
                    // replace iterator element with just the forward
                    // delete

                    if (!pIterator->fDoForward) {
                        //
                        // there is no forward that is requested
                        // blow away this entry
                        //

                        DeleteListEntry(pQueue, &pIterator);
                        fDelThisTime = TRUE;
                    } else {
                        //
                        // if you want to do a forward. Then just do
                        // the forward. Ignore reverses
                        //
                        pIterator ->fDoForwardOnly = TRUE;
                    }
                }

            }
            else if ((pIterator->dwOperation & DYNDNS_ADD_ENTRY) &&
                     (pQElement->dwOperation & DYNDNS_ADD_ENTRY)) {

                // replace the old entry with a forward delete.
                // this is an error. Need to replace earlier add
                // forward with an explicit Delete
                //

                if ( pIterator->pszName &&
                     pQElement->pszName &&
                     !wcsicmp_ThatWorks( pIterator->pszName,
                                         pQElement->pszName ) )
                {
                    DeleteListEntry(pQueue, &pIterator);
                    fDelThisTime = TRUE;
                } else {
                    //
                    // Log entries into this area. This should
                    // be a soft assert if you are here
                    // Names dont match, so you need to replace earlier
                    // add with a delete forward only
                    //

                    if (!pIterator->fDoForward) {
                        //
                        // there is no forward add requested
                        // blow away this entry
                        //

                        DeleteListEntry(pQueue, &pIterator);
                        fDelThisTime = TRUE;
                    } else {
                        //
                        // if you want to *explicitly* delete old
                        // forward and then add the new forward/reverse.
                        //
                        pIterator ->fDoForwardOnly = TRUE;
                        pIterator ->dwOperation &=
                            ~(DYNDNS_ADD_ENTRY) & DYNDNS_DELETE_ENTRY;
                    }

                }
            }
            else if ((pIterator->dwOperation & DYNDNS_DELETE_ENTRY) &&
                     (pQElement->dwOperation & DYNDNS_DELETE_ENTRY)) {

                //
                // if both are deletes.
                //

                if ( pIterator->pszName &&
                     pQElement->pszName &&
                     !wcsicmp_ThatWorks( pIterator->pszName,
                                         pQElement->pszName ) )
                {
                    //
                    // blow away earlier entry. An optimization
                    //
                    DeleteListEntry(pQueue, &pIterator);
                    fDelThisTime = TRUE;
                }
                //
                // if names dont match, do nothing. (To paraphrase,
                // the DNS Server needs to do both!!
                //

            }
        }

        if (pIterator && !fDelThisTime) {

            // pIterator may have changed because of blowing away an entry

            pIterator = pIterator->pFLink;
        }
    }
}

*/

DWORD
ProcessQDependencies(
    PDYNDNSQUEUE pTimedOutQueue,
    PQELEMENT    pQElement
    )

/*
  This function returns the retry time of the last element that you
  needed to blow out, 0 if no element needed to be removed

*/
{
    PQELEMENT pIterator = pTimedOutQueue->pTail;
    DWORD   dwRetryTime = 0;
    BOOL    fDelThisTime = FALSE;

    while (pIterator) {

        fDelThisTime = FALSE;

        if (!pIterator->fDoForwardOnly && !pQElement->fDoForwardOnly){
            //
            // both elements are not forward only, check on ip addresses
            //
            if (!HostAddrCmp(pIterator->HostAddr, pQElement->HostAddr)){
                //
                // ip addresses matched
                //

                if ((pIterator->dwOperation & DYNDNS_ADD_ENTRY) &&
                    (pQElement->dwOperation & DYNDNS_DELETE_ENTRY)) {

                    if ( pIterator->pszName &&
                         pQElement->pszName &&
                         !wcsicmp_ThatWorks( pIterator->pszName,
                                             pQElement->pszName ) )
                    {
                        //
                        // blow away earlier entry entirely
                        //
                        dwRetryTime = pIterator -> dwRetryTime;
                        DeleteListEntry(pTimedOutQueue, &pIterator);
                        fDelThisTime = TRUE;
                    }
                    //
                    // if names are not the same do nothing.
                    //
                    // Issue:  Will we hit this code at all? Put
                    // soft ASSERTS in this.
                    //

                }else if ((pIterator->dwOperation & DYNDNS_DELETE_ENTRY) &&
                         (pQElement->dwOperation & DYNDNS_ADD_ENTRY)) {


                    if ( pIterator->pszName &&
                         pQElement->pszName &&
                         !wcsicmp_ThatWorks( pIterator->pszName,
                                             pQElement->pszName ) )
                    {
                        //
                        // blow away earlier entry entirely
                        //
                        dwRetryTime = pIterator -> dwRetryTime;
                        DeleteListEntry(pTimedOutQueue, &pIterator);
                        fDelThisTime = TRUE;
                    } else {

                        // replace iterator element with just the forward

                        dwRetryTime = pIterator -> dwRetryTime;
                        pIterator -> fDoForwardOnly = TRUE;
                    }

                }else if ((pIterator->dwOperation & DYNDNS_ADD_ENTRY) &&
                         (pQElement->dwOperation & DYNDNS_ADD_ENTRY)) {

                    // replace the old entry with a forward delete.
                    // this is an error. Need to replace earlier add
                    // forward with an explicit Delete
                    //

                    if ( pIterator->pszName &&
                         pQElement->pszName &&
                         !wcsicmp_ThatWorks( pIterator->pszName,
                                             pQElement->pszName ) )
                    {
                        DeleteListEntry(pTimedOutQueue, &pIterator);
                        fDelThisTime = TRUE;
                    } else {
                        //
                        // Log entries into this area. This should
                        // be a soft assert if you are here
                        // Names dont match, so you need to replace earlier
                        // add with a delete forward only
                        //

                        if (!pIterator->fDoForward) {
                            //
                            // there is no forward add requested
                            // blow away this entry
                            //

                            DeleteListEntry(pTimedOutQueue, &pIterator);
                            fDelThisTime = TRUE;
                        } else {
                            //
                            // if you want to *explicitly* delete old
                            // forward and then add the new forward/reverse.
                            //
                            pIterator ->fDoForwardOnly = TRUE;
                            pIterator ->dwOperation &=
                                ~(DYNDNS_ADD_ENTRY) & DYNDNS_DELETE_ENTRY;
                        }
                    }

                }

                else if ((pIterator->dwOperation & DYNDNS_DELETE_ENTRY) &&
                         (pQElement->dwOperation & DYNDNS_DELETE_ENTRY)) {

                    //
                    // if both are deletes.
                    //

                    if ( pIterator->pszName &&
                         pQElement->pszName &&
                         !wcsicmp_ThatWorks( pIterator->pszName,
                                             pQElement->pszName ) )
                    {
                        //
                        // blow away earlier entry. An optimization
                        //
                        DeleteListEntry(pTimedOutQueue, &pIterator);
                        fDelThisTime = TRUE;
                    }
                    //
                    // if names dont match, do nothing. (To paraphrase,
                    // the DNS Server needs to do both!!
                    //

                }
            }
        } else if (pIterator->fDoForwardOnly) {

            if ( pIterator->pszName &&
                 pQElement->pszName &&
                 !wcsicmp_ThatWorks( pIterator->pszName,
                                     pQElement->pszName ) )
            {
                if ((pIterator->dwOperation & DYNDNS_ADD_ENTRY) &&
                    (pQElement->dwOperation & DYNDNS_ADD_ENTRY)) {

                    if (!HostAddrCmp(pIterator->HostAddr, pQElement->HostAddr))
                    {
                        //
                        // optimization blow away earlier entry
                        //
                        DeleteListEntry(pTimedOutQueue, &pIterator);
                        fDelThisTime = TRUE;
                    }
                    //
                    // if names dont match, do nothing
                    //
                }
                else if ((pIterator->dwOperation & DYNDNS_ADD_ENTRY) &&
                         (pQElement->dwOperation & DYNDNS_DELETE_ENTRY)) {

                    if (!HostAddrCmp(pIterator->HostAddr, pQElement->HostAddr)){
                        //
                        // blow away earlier entry
                        //
                        dwRetryTime = pIterator -> dwRetryTime;
                        DeleteListEntry(pTimedOutQueue, &pIterator);
                        fDelThisTime = TRUE;

                    }
                    //
                    // if addresses dont match, do nothing
                    //

                } else if ((pIterator->dwOperation & DYNDNS_DELETE_ENTRY) &&
                           (pQElement->dwOperation & DYNDNS_ADD_ENTRY)) {


                    if (!HostAddrCmp(pIterator->HostAddr, pQElement->HostAddr)){
                        //
                        // blow away earlier entry
                        //

                        dwRetryTime = pIterator -> dwRetryTime;
                        DeleteListEntry(pTimedOutQueue, &pIterator);
                        fDelThisTime = TRUE;

                    }
                    //
                    // if addresses dont match, then dont do anything
                    //
                } else {
                    // both are deletes
                    // do nothing here. i.e. DNS Server does both
                }
            }
        } else if (!pIterator->fDoForwardOnly && pQElement->fDoForwardOnly) {

            //
            // new element is forward only
            //

            //
            // if both elements are forwards, we cannot whack anything
            // out in any case, do nothing
            //

        }

        if (!fDelThisTime && pIterator){
            pIterator = pIterator ->pFLink;
        }

    }
    return (dwRetryTime);
}




VOID
DeleteListEntry(
    PDYNDNSQUEUE  pQueue,
    PQELEMENT*    ppIterator
    )
{

    PQELEMENT        pPrev, pNext;
    PQELEMENT        pIterator = *ppIterator;
    DHCP_CALLBACK_FN pfnDhcpCallBack = NULL;
    PVOID            pvData = NULL;

    pPrev = pIterator ->pBLink;
    pNext = pIterator ->pFLink;

    if (pPrev) {
        pPrev->pFLink = pNext;
    }

    if (pNext) {
        pNext ->pBLink = pPrev;
    }

    if (pIterator == pQueue ->pHead) {
        pQueue->pHead = pIterator ->pBLink;
    }

    if (pIterator == pQueue ->pTail) {
        pQueue->pTail = pIterator ->pFLink;
    }

    *ppIterator = pIterator ->pFLink;

    pfnDhcpCallBack = pIterator->pfnDhcpCallBack;
    pvData = pIterator->pvData;

    // blow away entry

    if ( pIterator -> pszName )
        QUEUE_FREE_HEAP( pIterator->pszName );

    if ( pIterator -> DnsServerList )
        QUEUE_FREE_HEAP( pIterator->DnsServerList );

    if ( pfnDhcpCallBack )
        (*pfnDhcpCallBack)(DNSDHCP_SUPERCEDED, pvData);
    
    QUEUE_FREE_HEAP( pIterator );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\query.c ===
/*++

Copyright (c) 1997-2001 Microsoft Corporation

Module Name:

    query.c

Abstract:

    Domain Name System (DNS) API

    Query routines.

Author:

    Jim Gilroy (jamesg)     January, 1997

Revision History:

--*/


#include "local.h"


//
//  TTL for answering IP string queries
//      (use a week)
//

#define IPSTRING_RECORD_TTL  (604800)


//
//  Max number of server's we'll ever bother to extract from packet
//  (much more and you're out of UDP packet space anyway)
//

#define MAX_NAME_SERVER_COUNT (20)

            
            

//
//  Query utilities
//
//  DCR:  move to library packet stuff
//

BOOL
IsEmptyDnsResponse(
    IN      PDNS_RECORD     pRecordList
    )
/*++

Routine Description:

    Check for no-answer response.

Arguments:

    pRecordList -- record list to check

Return Value:

    TRUE if no-answers
    FALSE if answers

--*/
{
    PDNS_RECORD prr = pRecordList;
    BOOL        fempty = TRUE;

    while ( prr )
    {
        if ( prr->Flags.S.Section == DNSREC_ANSWER )
        {
            fempty = FALSE;
            break;
        }
        prr = prr->pNext;
    }

    return fempty;
}



BOOL
IsEmptyDnsResponseFromResolver(
    IN      PDNS_RECORD     pRecordList
    )
/*++

Routine Description:

    Check for no-answer response.

Arguments:

    pRecordList -- record list to check

Return Value:

    TRUE if no-answers
    FALSE if answers

--*/
{
    PDNS_RECORD prr = pRecordList;
    BOOL        fempty = TRUE;

    //
    //  resolver sends every thing back as ANSWER section
    //      or section==0 for host file
    //
    //
    //  DCR:  this is lame because the query interface to the
    //          resolver is lame
    //

    while ( prr )
    {
        if ( prr->Flags.S.Section == DNSREC_ANSWER ||
             prr->Flags.S.Section == 0 )
        {
            fempty = FALSE;
            break;
        }
        prr = prr->pNext;
    }

    return fempty;
}



VOID
FixupNameOwnerPointers(
    IN OUT  PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PDNS_RECORD prr = pRecord;
    PTSTR       pname = pRecord->pName;

    DNSDBG( TRACE, ( "FixupNameOwnerPointers()\n" ));

    while ( prr )
    {
        if ( prr->pName == NULL )
        {
            prr->pName = pname;
        }
        else
        {
            pname = prr->pName;
        }

        prr = prr->pNext;
    }
}



BOOL
IsCacheableNameError(
    IN      PDNS_NETINFO        pNetInfo
    )
/*++

Routine Description:

    Determine if name error is cacheable.

    To this is essentially a check that DNS received results on
    all networks.

Arguments:

    pNetInfo -- pointer to network info used in query

Return Value:

    TRUE if name error cacheable.
    FALSE otherwise (some network did not respond)

--*/
{
    DWORD           iter;
    PDNS_ADAPTER    padapter;

    DNSDBG( TRACE, ( "IsCacheableNameError()\n" ));

    if ( !pNetInfo )
    {
        ASSERT( FALSE );
        return TRUE;
    }

    //
    //  check each adapter
    //      - any that are capable of responding (have DNS servers)
    //      MUST have responded in order for response to be
    //      cacheable
    //
    //  DCR:  return flags DCR
    //      - adapter queried flag
    //      - got response flag (valid response flag?)
    //      - explict negative answer flag
    //
    //  DCR:  cachable negative should come back directly from query
    //      perhaps in netinfo as flag -- "negative on all adapters"
    //

    for ( iter = 0; iter < pNetInfo->AdapterCount; iter++ )
    {
        padapter = pNetInfo->AdapterArray[iter];

        if ( ( padapter->InfoFlags & DNS_FLAG_IGNORE_ADAPTER ) ||
             ( padapter->RunFlags & RUN_FLAG_STOP_QUERY_ON_ADAPTER ) )
        {
            continue;
        }

        //  if negative answer on adapter -- fine

        if ( padapter->Status == DNS_ERROR_RCODE_NAME_ERROR ||
             padapter->Status == DNS_INFO_NO_RECORDS )
        {
            ASSERT( padapter->RunFlags & RUN_FLAG_STOP_QUERY_ON_ADAPTER );
            continue;
        }

        //  note, the above should map one-to-one with query stop

        ASSERT( !(padapter->RunFlags & RUN_FLAG_STOP_QUERY_ON_ADAPTER) );

        //  if adapter has no DNS server -- fine
        //      in this case PnP before useful, and the PnP event
        //      will flush the cache

        if ( padapter->ServerCount == 0 )
        {
            continue;
        }

        //  otherwise, this adapter was queried but could not produce a response

        DNSDBG( TRACE, (
            "IsCacheableNameError() -- FALSE\n"
            "\tadapter %d (%S) did not receive response\n"
            "\treturn status = %d\n"
            "\treturn flags  = %08x\n",
            iter,
            padapter->pszAdapterGuidName,
            padapter->Status,
            padapter->RunFlags ));

        return FALSE;
    }
    
    return TRUE;
}



//
//  Query name building utils
//

BOOL
ValidateQueryTld(
    IN      PSTR            pTld
    )
/*++

Routine Description:

    Validate query TLD

Arguments:

    pTld -- TLD to validate

Return Value:

    TRUE if valid
    FALSE otherwise

--*/
{
    //
    //  numeric
    //

    if ( g_ScreenBadTlds & DNS_TLD_SCREEN_NUMERIC )
    {
        if ( Dns_IsNameNumeric_A( pTld ) )
        {
            return  FALSE;
        }
    }

    //
    //  bogus TLDs
    //

    if ( g_ScreenBadTlds & DNS_TLD_SCREEN_WORKGROUP )
    {
        if ( Dns_NameCompare_UTF8(
                "workgroup",
                pTld ))
        {
            return  FALSE;
        }
    }

    //  not sure about these
    //  probably won't turn on screening by default

    if ( g_ScreenBadTlds & DNS_TLD_SCREEN_DOMAIN )
    {
        if ( Dns_NameCompare_UTF8(
                "domain",
                pTld ))
        {
            return  FALSE;
        }
    }
    if ( g_ScreenBadTlds & DNS_TLD_SCREEN_OFFICE )
    {
        if ( Dns_NameCompare_UTF8(
                "office",
                pTld ))
        {
            return  FALSE;
        }
    }
    if ( g_ScreenBadTlds & DNS_TLD_SCREEN_HOME )
    {
        if ( Dns_NameCompare_UTF8(
                "home",
                pTld ))
        {
            return  FALSE;
        }
    }

    return  TRUE;
}



BOOL
ValidateQueryName(
    IN      PQUERY_BLOB     pBlob,
    IN      PSTR            pName,
    IN      PSTR            pDomain
    )
/*++

Routine Description:

    Validate name for wire query.

Arguments:

    pBlob -- query blob

    pName -- name;  may be any sort of name

    pDomain -- domain name to append

Return Value:

    TRUE if name query will be valid.
    FALSE otherwise.

--*/
{
    WORD    wtype;
    PSTR    pnameTld;
    PSTR    pdomainTld;

    //  no screening -- bail

    if ( g_ScreenBadTlds == 0 )
    {
        return  TRUE;
    }

    //  only screening for standard types
    //      - A, AAAA, SRV

    wtype = pBlob->wType;
    if ( wtype != DNS_TYPE_A    &&
         wtype != DNS_TYPE_AAAA &&
         wtype != DNS_TYPE_SRV )
    {
        return  TRUE;
    }

    //  get name TLD

    pnameTld = Dns_GetTldForName( pName );

    //
    //  if no domain appended
    //      - exclude single label
    //      - exclude bad TLD (numeric, bogus domain)
    //      - but allow root queries
    //
    //  DCR:  MS DCS screening
    //  screen
    //      _msdcs.<name>
    //      will probably be unappended query
    //

    if ( !pDomain )
    {
        if ( !pnameTld ||
             !ValidateQueryTld( pnameTld ) )
        {
            goto Failed;
        }
        return  TRUE;
    }

    //
    //  domain appended
    //      - exclude bad TLD (numeric, bogus domain)
    //      - exclude matching TLD 
    //

    pdomainTld = Dns_GetTldForName( pDomain );
    if ( !pdomainTld )
    {
        pdomainTld = pDomain;
    }

    if ( !ValidateQueryTld( pdomainTld ) )
    {
        goto Failed;
    }

    //  screen repeated TLD

    if ( g_ScreenBadTlds & DNS_TLD_SCREEN_REPEATED )
    {
        if ( Dns_NameCompare_UTF8(
                pnameTld,
                pdomainTld ) )
        {
            goto Failed;
        }
    }

    return  TRUE;

Failed:

    DNSDBG( QUERY, (
        "Failed invalid query name:\n"
        "\tname     %s\n"
        "\tdomain   %s\n",
        pName,
        pDomain ));

    return  FALSE;
}



PSTR
GetNextAdapterDomainName(
    IN OUT  PDNS_NETINFO        pNetInfo
    )
/*++

Routine Description:

    Get next adapter domain name to query.

Arguments:

    pNetInfo -- DNS Network info for query;
        adapter data will be modified (InfoFlags field)
        to indicate which adapter to query and which
        to skip query on

Return Value:

    Ptr to domain name (UTF8) to query.
    NULL if no more domain names to query.

--*/
{
    DWORD   iter;
    PSTR    pqueryDomain = NULL;

    DNSDBG( TRACE, ( "GetNextAdapterDomainName()\n" ));

    if ( ! pNetInfo )
    {
        ASSERT( FALSE );
        return NULL;
    }

    IF_DNSDBG( OFF )
    {
        DnsDbg_NetworkInfo(
            "Net info to get adapter domain name from: ",
            pNetInfo );
    }

    //
    //  check each adapter
    //      - first unqueried adapter with name is chosen
    //      - other adapters with
    //          - matching name => included in query
    //          - non-matching => turned OFF for query
    //
    //  DCR:  query on\off should use adapter dynamic flags
    //

    for ( iter = 0; iter < pNetInfo->AdapterCount; iter++ )
    {
        PDNS_ADAPTER    padapter;
        PSTR            pdomain;

        padapter = pNetInfo->AdapterArray[iter];

        //  netinfo should come in with name specific flags clean

        DNS_ASSERT( !(padapter->RunFlags & RUN_FLAG_SINGLE_NAME_MASK) );

        //
        //  ignore
        //      - ignored adapter OR
        //      - previously queried adapter domain
        //      note:  it can't match any "fresh" domain we come up with
        //      as we always collect all matches 

        if ( (padapter->InfoFlags & DNS_FLAG_IGNORE_ADAPTER)
                ||
             (padapter->RunFlags & RUN_FLAG_QUERIED_ADAPTER_DOMAIN) )
        {
            padapter->RunFlags |= RUN_FLAG_STOP_QUERY_ON_ADAPTER;
            continue;
        }

        //  no domain name -- always off

        pdomain = padapter->pszAdapterDomain;
        if ( !pdomain )
        {
            padapter->RunFlags |= (RUN_FLAG_QUERIED_ADAPTER_DOMAIN |
                                   RUN_FLAG_STOP_QUERY_ON_ADAPTER);
            continue;
        }

        //  first "fresh" domain name -- save, turn on and flag as used

        if ( !pqueryDomain )
        {
            pqueryDomain = pdomain;
            padapter->RunFlags |= RUN_FLAG_QUERIED_ADAPTER_DOMAIN;
            continue;
        }

        //  other "fresh" domain names
        //      - if matches query domain => on for query
        //      - no match => off

        if ( Dns_NameCompare_UTF8(
                pqueryDomain,
                pdomain ) )
        {
            padapter->RunFlags |= RUN_FLAG_QUERIED_ADAPTER_DOMAIN;
            continue;
        }
        else
        {
            padapter->RunFlags |= RUN_FLAG_STOP_QUERY_ON_ADAPTER;
            continue;
        }
    }

    //
    //  if no adapter domain name -- clear STOP flag
    //      - all adapters participate in other names (name devolution)
    //

    if ( !pqueryDomain )
    {
        for ( iter = 0; iter < pNetInfo->AdapterCount; iter++ )
        {
            PDNS_ADAPTER    padapter = pNetInfo->AdapterArray[iter];
    
            padapter->RunFlags &= (~RUN_FLAG_SINGLE_NAME_MASK );
        }

        DNSDBG( INIT2, (
            "GetNextAdapterDomainName out of adapter names.\n" ));

        pNetInfo->ReturnFlags |= RUN_FLAG_QUERIED_ADAPTER_DOMAIN;
    }

    IF_DNSDBG( INIT2 )
    {
        if ( pqueryDomain )
        {
            DnsDbg_NetworkInfo(
                "Net info after adapter name select: ",
                pNetInfo );
        }
    }

    DNSDBG( INIT2, (
        "Leaving GetNextAdapterDomainName() => %s\n",
        pqueryDomain ));

    return pqueryDomain;
}



PSTR
GetNextDomainNameToAppend(
    IN OUT  PDNS_NETINFO        pNetInfo,
    OUT     PDWORD              pSuffixFlags
    )
/*++

Routine Description:

    Get next adapter domain name to query.

Arguments:

    pNetInfo -- DNS Network info for query;
        adapter data will be modified (RunFlags field)
        to indicate which adapter to query and which
        to skip query on

    pSuffixFlags -- flags associated with the use of this suffix

Return Value:

    Ptr to domain name (UTF8) to query.
    NULL if no more domain names to query.

--*/
{
    PSTR    psearchName;
    PSTR    pdomain;

    //
    //  search list if real search list  
    //
    //  if suffix flags zero, then this is REAL search list
    //  or is PDN name
    //

    psearchName = SearchList_GetNextName(
                        pNetInfo->pSearchList,
                        FALSE,              // not reset
                        pSuffixFlags );

    if ( psearchName && (*pSuffixFlags == 0) )
    {
        //  found regular search name -- done

        DNSDBG( INIT2, (
            "getNextDomainName from search list => %s, %d\n",
            psearchName,
            *pSuffixFlags ));
        return( psearchName );
    }

    //
    //  try adapter domain names
    //
    //  but ONLY if search list is dummy;  if real we only
    //  use search list entries
    //
    //  DCR_CLEANUP:  eliminate bogus search list
    //

    if ( pNetInfo->InfoFlags & DNS_FLAG_DUMMY_SEARCH_LIST
            &&
         ! (pNetInfo->ReturnFlags & RUN_FLAG_QUERIED_ADAPTER_DOMAIN) )
    {
        pdomain = GetNextAdapterDomainName( pNetInfo );
        if ( pdomain )
        {
            *pSuffixFlags = DNS_QUERY_USE_QUICK_TIMEOUTS;
    
            DNSDBG( INIT2, (
                "getNextDomainName from adapter domain name => %s, %d\n",
                pdomain,
                *pSuffixFlags ));

            //  back the search list up one tick
            //  we queried through it above, so if it was returing
            //  a name, we need to get that name again on next query

            if ( psearchName )
            {
                ASSERT( pNetInfo->pSearchList->CurrentNameIndex > 0 );
                pNetInfo->pSearchList->CurrentNameIndex--;
            }
            return( pdomain );
        }
    }

    //
    //  DCR_CLEANUP:  remove devolution from search list and do explicitly
    //      - its cheap (or do it once and save, but store separately)
    //

    //
    //  finally use and devolved search names (or other nonsense)
    //

    *pSuffixFlags = DNS_QUERY_USE_QUICK_TIMEOUTS;

    DNSDBG( INIT2, (
        "getNextDomainName from devolution\\other => %s, %d\n",
        psearchName,
        *pSuffixFlags ));

    return( psearchName );
}



PSTR
GetNextQueryName(
    IN OUT  PQUERY_BLOB         pBlob
    )
/*++

Routine Description:

    Get next name to query.

Arguments:

    pBlob - blob of query information

    Uses:
        NameOriginalWire
        NameAttributes
        QueryCount
        pNetworkInfo

    Sets:
        NameWire -- set with appended wire name
        pNetworkInfo -- runtime flags set to indicate which adapters are
            queried
        NameFlags -- set with properties of name
        fAppendedName -- set when name appended

Return Value:

    Ptr to name to query with.
        - will be orginal name on first query if name is multilabel name
        - otherwise will be NameWire buffer which will contain appended name
            composed of pszName and some domain name
    NULL if no more names to append

--*/
{
    PSTR    pnameOrig   = pBlob->NameOriginalWire;
    PSTR    pdomainName = NULL;
    PSTR    pnameBuf;
    DWORD   queryCount  = pBlob->QueryCount;
    DWORD   nameAttributes = pBlob->NameAttributes;


    DNSDBG( TRACE, (
        "GetNextQueryName( %p )\n",
        pBlob ));


    //  default suffix flags

    pBlob->NameFlags = 0;


    //
    //  FQDN
    //      - send FQDN only
    //

    if ( nameAttributes & DNS_NAME_IS_FQDN )
    {
        if ( queryCount == 0 )
        {
#if 0
            //  currently won't even validate FQDN
            if ( ValidateQueryName(
                    pBlob,
                    pnameOrig,
                    NULL ) )
            {
                return  pnameOrig;
            }
#endif
            return  pnameOrig;
        }
        DNSDBG( QUERY, (
            "No append for FQDN name %s -- end query.\n",
            pnameOrig ));
        return  NULL;
    }

    //
    //  multilabel
    //      - first pass on name itself -- if valid
    //
    //  DCR:  intelligent choice on multi-label whether append first
    //      or go to wire first  (example foo.ntdev) could append
    //      first
    //

    if ( nameAttributes & DNS_NAME_MULTI_LABEL )
    {
        if ( queryCount == 0 )
        {
            if ( ValidateQueryName(
                    pBlob,
                    pnameOrig,
                    NULL ) )
            {
                return  pnameOrig;
            }
        }

        if ( !g_AppendToMultiLabelName )
        {
            DNSDBG( QUERY, (
                "No append allowed on multi-label name %s -- end query.\n",
                pnameOrig ));
            return  NULL;
        }

        //  falls through to appending on multi-label names
    }

    //
    //  not FQDN -- append a domain name
    //      - next search name (if available)
    //      - otherwise next adapter domain name
    //

    pnameBuf = pBlob->NameWire;

    while ( 1 )
    {
        pdomainName = GetNextDomainNameToAppend(
                            pBlob->pNetworkInfo,
                            & pBlob->NameFlags );
        if ( !pdomainName )
        {
            DNSDBG( QUERY, (
                "No more domain names to append -- end query\n" ));
            return  NULL;
        }

        if ( !ValidateQueryName(
                pBlob,
                pnameOrig,
                pdomainName ) )
        {
            continue;
        }

        //  append domain name to name

        if ( Dns_NameAppend_A(
                pnameBuf,
                DNS_MAX_NAME_BUFFER_LENGTH,
                pnameOrig,
                pdomainName ) )
        {
            pBlob->fAppendedName = TRUE;
            break;
        }
    }

    DNSDBG( QUERY, (
        "GetNextQueryName() result => %s\n",
        pnameBuf ));

    return pnameBuf;
}



DNS_STATUS
QueryDirectEx(
    IN OUT  PDNS_MSG_BUF *      ppMsgResponse,
    OUT     PDNS_RECORD *       ppResponseRecords,
    IN      PDNS_HEADER         pHeader,
    IN      BOOL                fNoHeaderCounts,
    IN      PDNS_NAME           pszQuestionName,
    IN      WORD                wQuestionType,
    IN      PDNS_RECORD         pRecords,
    IN      DWORD               dwFlags,
    IN      PIP_ARRAY           aipDnsServers,
    IN OUT  PDNS_NETINFO        pNetInfo
    )
/*++

Routine Description:

    Query.

Arguments:

    ppMsgResponse -- addr to recv ptr to response buffer;  caller MUST
        free buffer

    ppResponseRecord -- address to receive ptr to record list returned from query

    pHead -- DNS header to send

    fNoHeaderCounts - do NOT include record counts in copying header

    pszQuestionName -- DNS name to query;
        Unicode string if dwFlags has DNSQUERY_UNICODE_NAME set.
        ANSI string otherwise.

    wType -- query type

    pRecords -- address to receive ptr to record list returned from query

    dwFlags -- query flags

    aipDnsServers -- specific DNS servers to query;
        OPTIONAL, if specified overrides normal list associated with machine

    pDnsNetAdapters -- DNS servers to query;  if NULL get current list


Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PDNS_MSG_BUF    psendMsg;
    DNS_STATUS      status = DNS_ERROR_NO_MEMORY;

    DNSDBG( QUERY, (
        "QueryDirectEx()\n"
        "\tname         %s\n"
        "\ttype         %d\n"
        "\theader       %p\n"
        "\t - counts    %d\n"
        "\trecords      %p\n"
        "\tflags        %08x\n"
        "\trecv msg     %p\n"
        "\trecv records %p\n"
        "\tserver IPs   %p\n"
        "\tadapter list %p\n",
        pszQuestionName,
        wQuestionType,
        pHeader,
        fNoHeaderCounts,
        pRecords,
        dwFlags,
        ppMsgResponse,
        ppResponseRecords,
        aipDnsServers,
        pNetInfo ));

    //
    //  build send packet
    //

    psendMsg = Dns_BuildPacket(
                    pHeader,
                    fNoHeaderCounts,
                    pszQuestionName,
                    wQuestionType,
                    pRecords,
                    dwFlags,
                    FALSE       // query, not an update
                    );
    if ( !psendMsg )
    {
        status = ERROR_INVALID_NAME;
        goto Cleanup;
    }

#if MULTICAST_ENABLED

    //
    //  QUESTION:  mcast test is not complete here
    //      - should first test that we actually do it
    //      including whether we have DNS servers
    //  FIXME:  then when we do do it -- encapsulate it
    //      ShouldMulicastQuery()
    //
    // Check to see if name is for something in the multicast local domain.
    // If so, set flag to multicast this query only.
    //

    if ( Dns_NameCompareEx( pszQuestionName,
                            ( dwFlags & DNSQUERY_UNICODE_NAME ) ?
                              (LPSTR) MULTICAST_DNS_LOCAL_DOMAIN_W :
                              MULTICAST_DNS_LOCAL_DOMAIN,
                            0,
                            ( dwFlags & DNSQUERY_UNICODE_NAME ) ?
                              DnsCharSetUnicode :
                              DnsCharSetUtf8 ) ==
                            DnsNameCompareRightParent )
    {
        dwFlags |= DNS_QUERY_MULTICAST_ONLY;
    }
#endif

    //
    //  send query and receive response
    //

    Trace_LogQueryEvent(
        psendMsg,
        wQuestionType );

    status = Dns_SendAndRecv(
                psendMsg,
                ppMsgResponse,
                ppResponseRecords,
                dwFlags,
                aipDnsServers,
                pNetInfo );

    Trace_LogResponseEvent(
        psendMsg,
        ( ppResponseRecords && *ppResponseRecords )
            ? (*ppResponseRecords)->wType
            : 0,
        status );

Cleanup:

    FREE_HEAP( psendMsg );

    DNSDBG( QUERY, (
        "Leaving QueryDirectEx(), status = %s (%d)\n",
        Dns_StatusString(status),
        status ));

    return( status );
}



DNS_STATUS
Query_SingleName(
    IN OUT  PQUERY_BLOB         pBlob
    )
/*++

Routine Description:

    Query single name.

Arguments:

    pBlob - query blob

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PDNS_MSG_BUF    psendMsg = NULL;
    DNS_STATUS      status = DNS_ERROR_NO_MEMORY;
    DWORD           flags = pBlob->Flags;

    DNSDBG( QUERY, (
        "Query_SingleName( %p )\n",
        pBlob ));

    IF_DNSDBG( QUERY )
    {
        DnsDbg_QueryBlob(
            "Enter Query_SingleName()",
            pBlob );
    }

    //
    //  cache\hostfile callback on appended name
    //      - note that queried name was already done
    //      (in resolver or in Query_Main())
    //

    if ( pBlob->pfnQueryCache  &&  pBlob->fAppendedName )
    {
        if ( (pBlob->pfnQueryCache)( pBlob ) )
        {
            status = pBlob->Status;
            goto Cleanup;
        }
    }

    //
    //  if wire disallowed -- stop here
    //

    if ( flags & DNS_QUERY_NO_WIRE_QUERY )
    {
        status = DNS_ERROR_NAME_NOT_FOUND_LOCALLY;
        pBlob->Status = status;
        goto Cleanup;
    }

    //
    //  build send packet
    //

    psendMsg = Dns_BuildPacket(
                    NULL,           // no header
                    0,              // no header counts
                    pBlob->pNameWire,
                    pBlob->wType,
                    NULL,           // no records
                    flags,
                    FALSE           // query, not an update
                    );
    if ( !psendMsg )
    {
        status = DNS_ERROR_INVALID_NAME;
        goto Cleanup;
    }


#if MULTICAST_ENABLED

    //
    //  QUESTION:  mcast test is not complete here
    //      - should first test that we actually do it
    //      including whether we have DNS servers
    //  FIXME:  then when we do do it -- encapsulate it
    //      ShouldMulicastQuery()
    //
    // Check to see if name is for something in the multicast local domain.
    // If so, set flag to multicast this query only.
    //

    if ( Dns_NameCompareEx(
                pBlob->pName,
                ( flags & DNSQUERY_UNICODE_NAME )
                    ? (LPSTR) MULTICAST_DNS_LOCAL_DOMAIN_W
                    : MULTICAST_DNS_LOCAL_DOMAIN,
                0,
                ( flags & DNSQUERY_UNICODE_NAME )
                    ? DnsCharSetUnicode
                    : DnsCharSetUtf8 )
            == DnsNameCompareRightParent )
    {
        flags |= DNS_QUERY_MULTICAST_ONLY;
    }
#endif

    //
    //  send query and receive response
    //

    Trace_LogQueryEvent(
        psendMsg,
        pBlob->wType );

    status = Dns_SendAndRecv(
                psendMsg,
                (flags & DNS_QUERY_RETURN_MESSAGE)
                    ? &pBlob->pRecvMsg
                    : NULL,
                & pBlob->pRecords,
                flags,
                pBlob->pDnsServers,
                pBlob->pNetworkInfo
                );

    Trace_LogResponseEvent(
        psendMsg,
        ( pBlob->pRecords )
            ? (pBlob->pRecords)->wType
            : 0,
        status );

Cleanup:

    FREE_HEAP( psendMsg );

    DNSDBG( QUERY, (
        "Leaving Query_SingleName(), status = %s (%d)\n",
        Dns_StatusString(status),
        status ));

    IF_DNSDBG( QUERY )
    {
        DnsDbg_QueryBlob(
            "Blob leaving Query_SingleName()",
            pBlob );
    }
    return( status );
}



DNS_STATUS
Query_Main(
    IN OUT  PQUERY_BLOB     pBlob
    )
/*++

Routine Description:

    Main query routine.

    Does all the query processing
        - local lookup
        - name appending
        - cache\hostfile lookup on appended name
        - query to server

Arguments:

    pBlob -- query info blob

Return Value:

    ERROR_SUCCESS if successful response.
    DNS_INFO_NO_RECORDS on no records for type response.
    DNS_ERROR_RCODE_NAME_ERROR on name error.
    DNS_ERROR_INVALID_NAME on bad name.
    None

--*/
{
    DNS_STATUS          status = DNS_ERROR_NAME_NOT_FOUND_LOCALLY;
    PSTR                pdomainName = NULL;
    PDNS_RECORD         precords;
    DWORD               queryFlags;
    DWORD               suffixFlags = 0;
    DWORD               nameAttributes;
    DNS_STATUS          bestQueryStatus = ERROR_SUCCESS;
    BOOL                fcacheNegative = TRUE;

    DWORD               flagsIn = pBlob->Flags;
    PDNS_NETINFO        pnetInfo = pBlob->pNetworkInfo;
    DWORD               nameLength;
    DWORD               bufLength;
    DWORD               queryCount;


    DNSDBG( TRACE, (
        "Query_Main( %p )\n"
        "\t%S, f=%08x, type=%d, time = %d\n",
        pBlob,
        pBlob->pNameOrig,
        flagsIn,
        pBlob->wType,
        Dns_GetCurrentTimeInSeconds()
        ));

    //
    //  clear out params
    //

    pBlob->pRecords         = NULL;
    pBlob->pLocalRecords    = NULL;
    pBlob->fCacheNegative   = FALSE;
    pBlob->fNoIpLocal       = FALSE;
    pBlob->NetFailureStatus = ERROR_SUCCESS;

    //
    //  convert name to wire format
    //

    bufLength = DNS_MAX_NAME_BUFFER_LENGTH;

    nameLength = Dns_NameCopy(
                    pBlob->NameOriginalWire,
                    & bufLength,
                    (PSTR) pBlob->pNameOrig,
                    0,                  // name is NULL terminated
                    DnsCharSetUnicode,
                    DnsCharSetWire );

    if ( nameLength == 0 )
    {
        return DNS_ERROR_INVALID_NAME;
    }
    nameLength--;
    pBlob->NameLength = nameLength;
    pBlob->pNameOrigWire = pBlob->NameOriginalWire;

    //
    //  determine name properties
    //      - determines number and order of name queries
    //

    nameAttributes = Dns_GetNameAttributes( pBlob->NameOriginalWire );

    if ( flagsIn & DNS_QUERY_TREAT_AS_FQDN )
    {
        nameAttributes |= DNS_NAME_IS_FQDN;
    }
    pBlob->NameAttributes = nameAttributes;

    //
    //  hostfile lookup
    //      - called in process
    //      - hosts file lookup allowed
    //      -> then must do hosts file lookup before appending\queries
    //
    //  note:  this matches the hostsfile\cache lookup in resolver
    //      before call;  hosts file queries to appended names are
    //      handled together by callback in Query_SingleName()
    //
    //      we MUST make this callback here, because it must PRECEDE
    //      the local name call, as some customers specifically direct
    //      some local mappings in the hosts file
    //

    if ( pBlob->pfnQueryCache == QueryHostFile
            &&
         ! (flagsIn & DNS_QUERY_NO_HOSTS_FILE) )
    {
        pBlob->pNameWire = pBlob->pNameOrigWire;

        if ( QueryHostFile( pBlob ) )
        {
            status = pBlob->Status;
            goto Done;
        }
    }

    //
    //  check for local name
    //      - if successful, skip wire query
    //

    if ( ! (flagsIn & DNS_QUERY_NO_LOCAL_NAME) )
    {
        status = GetRecordsForLocalName( pBlob );

        if ( status == ERROR_SUCCESS  &&
             !pBlob->fNoIpLocal )
        {
            DNS_ASSERT( pBlob->pRecords &&
                        pBlob->pRecords == pBlob->pLocalRecords );
            goto Done;
        }
    }

    //
    //  query until
    //      - successfull
    //      - exhaust names to query with
    //

    queryCount = 0;

    while ( 1 )
    {
        PSTR    pqueryName;

        //  clean name specific info from list

        if ( queryCount != 0 )
        {
            NetInfo_Clean(
                pnetInfo,
                CLEAR_LEVEL_SINGLE_NAME );
        }

        //
        //  next query name
        //

        pqueryName = GetNextQueryName( pBlob );
        if ( !pqueryName )
        {
            if ( queryCount == 0 )
            {
                status = DNS_ERROR_INVALID_NAME;
            }
            break;
        }
        pBlob->QueryCount = ++queryCount;
        pBlob->pNameWire = pqueryName;

        DNSDBG( QUERY, (
            "Query %d is for name %s\n",
            queryCount,
            pqueryName ));

        //
        //  set flags
        //      - passed in flags
        //      - unicode results
        //      - flags for this particular suffix

        pBlob->Flags = flagsIn | pBlob->NameFlags;

        //
        //  clear any previously received records (shouldn't be any)
        //

        if ( pBlob->pRecords )
        {
            DNS_ASSERT( FALSE );
            Dns_RecordListFree( pBlob->pRecords );
            pBlob->pRecords = NULL;
        }

        //
        //  do the query for name
        //  includes
        //      - cache or hostfile lookup
        //      - wire query
        //

        status = Query_SingleName( pBlob );

        //
        //  clean out records on "non-response"
        //
        //  DCR:  need to fix record return
        //      - should keep records on any response (best response)
        //      just make sure NO_RECORDS rcode is mapped
        //
        //  the only time we keep them is FAZ
        //      - ALLOW_EMPTY_AUTH flag set
        //      - sending FQDN (or more precisely doing single query)
        //

        precords = pBlob->pRecords;

        if ( precords )
        {
            if ( IsEmptyDnsResponse( precords ) )
            {
                if ( (flagsIn & DNS_QUERY_ALLOW_EMPTY_AUTH_RESP)
                        &&
                     ( (nameAttributes & DNS_NAME_IS_FQDN)
                            ||
                       ((nameAttributes & DNS_NAME_MULTI_LABEL) &&
                            !g_AppendToMultiLabelName ) ) )
                {
                    //  stop here as caller (probably FAZ code)
                    //  wants to get the authority records

                    DNSDBG( QUERY, (
                        "Returning empty query response with authority records.\n" ));
                    break;
                }
                else
                {
                    Dns_RecordListFree( precords );
                    pBlob->pRecords = NULL;
                    if ( status == NO_ERROR )
                    {
                        status = DNS_INFO_NO_RECORDS;
                    }
                }
            }
        }

        //  successful query -- done

        if ( status == ERROR_SUCCESS )
        {
            RTL_ASSERT( precords );
            break;
        }

#if 0
        //
        //  DCR_FIX0:  lost adapter timeout from early in multi-name query
        //      - callback here or some other approach
        //
        //  this is resolver version
        //

        //  reset server priorities on failures
        //  do here to avoid washing out info in retry with new name
        //

        if ( status != ERROR_SUCCESS &&
             (pnetInfo->ReturnFlags & DNS_FLAG_RESET_SERVER_PRIORITY) )
        {
            if ( g_AdapterTimeoutCacheTime &&
                 Dns_DisableTimedOutAdapters( pnetInfo ) )
            {
                fadapterTimedOut = TRUE;
                SetKnownTimedOutAdapter();
            }
        }

        //
        //  DCR_CLEANUP:  lost intermediate timed out adapter deal
        //

        if ( status != NO_ERROR &&
             (pnetInfo->ReturnFlags & DNS_FLAG_RESET_SERVER_PRIORITY) )
        {
            Dns_DisableTimedOutAdapters( pnetInfo );
        }
#endif

        //
        //  save first query error (for some errors)
        //

        if ( queryCount == 1 &&
             ( status == DNS_ERROR_RCODE_NAME_ERROR ||
               status == DNS_INFO_NO_RECORDS ||
               status == DNS_ERROR_INVALID_NAME ||
               status == DNS_ERROR_RCODE_SERVER_FAILURE ||
               status == DNS_ERROR_RCODE_FORMAT_ERROR ) )
        {
            DNSDBG( QUERY, (
                "Saving bestQueryStatus %d\n",
                status ));
            bestQueryStatus = status;
        }

        //
        //  continue with other queries on some errors
        //
        //  on NAME_ERROR or NO_RECORDS response
        //      - check if this negative result will be
        //      cacheable, if it holds up
        //
        //  note:  the reason we check every time is that when the
        //      query involves several names, one or more may fail
        //      with one network timing out, YET the final name
        //      queried indeed is a NAME_ERROR everywhere;  hence
        //      we can not do the check just once on the final
        //      negative response;
        //      in short, every negative response must be determinative
        //      in order for us to cache
        //
    
        if ( status == DNS_ERROR_RCODE_NAME_ERROR ||
             status == DNS_INFO_NO_RECORDS )
        {
            if ( fcacheNegative )
            {
                fcacheNegative = IsCacheableNameError( pnetInfo );
            }
            if ( status == DNS_INFO_NO_RECORDS )
            {
                DNSDBG( QUERY, (
                    "Saving bestQueryStatus %d\n",
                    status ));
                bestQueryStatus = status;
            }
            continue;
        }
    
        //  server failure may indicate intermediate or remote
        //      server timeout and hence also makes any final
        //      name error determination uncacheable
    
        else if ( status == DNS_ERROR_RCODE_SERVER_FAILURE )
        {
            fcacheNegative = FALSE;
            continue;
        }
    
        //  busted name errors
        //      - just continue with next query
    
        else if ( status == DNS_ERROR_INVALID_NAME ||
                  status == DNS_ERROR_RCODE_FORMAT_ERROR )
        {
            continue;
        }
        
        //
        //  other errors -- ex. timeout and winsock -- are terminal
        //

        else
        {
            fcacheNegative = FALSE;
            break;
        }
    }


    DNSDBG( QUERY, (
        "Query_Main() -- name loop termination\n"
        "\tstatus       = %d\n"
        "\tquery count  = %d\n",
        status,
        queryCount ));

    //
    //  if no queries then invalid name
    //      - either name itself is invalid
    //      OR
    //      - single part name and don't have anything to append
    //

    DNS_ASSERT( queryCount != 0 ||
                status == DNS_ERROR_INVALID_NAME );

    //
    //  success -- prioritize record data
    //
    //  to prioritize
    //      - prioritize is set
    //      - have more than one A record
    //      - can get IP list
    //
    //  note:  need the callback because resolver uses directly
    //      local copy of IP address info, whereas direct query
    //      RPC's a copy over from the resolver
    //
    //      alternative would be some sort of "set IP source"
    //      function that resolver would call when there's a
    //      new list;  then could have common function that
    //      picks up source if available or does RPC
    //

    if ( status == ERROR_SUCCESS )
    {
        if ( g_PrioritizeRecordData &&
             Dns_RecordListCount( precords, DNS_TYPE_A ) > 1  &&
             pBlob->pfnGetAddrArray )
        {
            PDNS_ADDR_ARRAY   paddrArray = (pBlob->pfnGetAddrArray)();

            if ( paddrArray )
            {
                pBlob->pRecords = Dns_PrioritizeRecordSetEx(
                                        precords,
                                        paddrArray );
                FREE_HEAP( paddrArray );
            }
        }
    }

    //
    //  no-op common negative response
    //  doing this for perf to skip extensive status code check below
    //

    else if ( status == DNS_ERROR_RCODE_NAME_ERROR ||
              status == DNS_INFO_NO_RECORDS )
    {
        // no-op
    }

    //
    //  timeout indicates possible network problem
    //  winsock errors indicate definite network problem
    //

    else if (
        status == ERROR_TIMEOUT     ||
        status == WSAEFAULT         ||
        status == WSAENOTSOCK       ||
        status == WSAENETDOWN       ||
        status == WSAENETUNREACH    ||
        status == WSAEPFNOSUPPORT   ||
        status == WSAEAFNOSUPPORT   ||
        status == WSAEHOSTDOWN      ||
        status == WSAEHOSTUNREACH )
    {
        pBlob->NetFailureStatus = status;
    }

#if 0
        //
        //  DCR:  not sure when to free message buffer
        //
        //      - it is reused in Dns_QueryLib call, so no leak
        //      - point is when to return it
        //      - old QuickQueryEx() would dump when going around again?
        //          not sure of the point of that
        //

        //
        //   going around again -- free up message buffer
        //

        if ( ppMsgResponse && *ppMsgResponse )
        {
            FREE_HEAP( *ppMsgResponse );
            *ppMsgResponse = NULL;
        }
#endif

    //
    //  use NO-IP local name?
    //
    //  if matched local name but had no IPs (IP6 currently)
    //  then use default here if not successful wire query
    //

    if ( pBlob->fNoIpLocal )
    {
        if ( status != ERROR_SUCCESS )
        {
            Dns_RecordListFree( pBlob->pRecords );
            pBlob->pRecords = pBlob->pLocalRecords;
            status = ERROR_SUCCESS;
            pBlob->Status = status;
        }
        else
        {
            Dns_RecordListFree( pBlob->pLocalRecords );
            pBlob->pLocalRecords = NULL;
        }
    }

    //
    //  if error, use "best" error
    //  this is either
    //      - original query response
    //      - or NO_RECORDS response found later
    //

    if ( status != ERROR_SUCCESS  &&  bestQueryStatus )
    {
        status = bestQueryStatus;
        pBlob->Status = status;
    }

    //
    //  set negative response cacheability
    //

    pBlob->fCacheNegative = fcacheNegative;


Done:

    DNS_ASSERT( !pBlob->pLocalRecords ||
                pBlob->pLocalRecords == pBlob->pRecords );

    DNSDBG( TRACE, (
        "Leave Query_Main()\n"
        "\tstatus       = %d\n"
        "\ttime         = %d\n",
        status,
        Dns_GetCurrentTimeInSeconds()
        ));
    IF_DNSDBG( QUERY )
    {
        DnsDbg_QueryBlob(
            "Blob leaving Query_Main()",
            pBlob );
    }

    //
    //  DCR_HACK:  remove me
    //
    //  must return some records on success query
    //
    //  not sure this is true on referral -- if so it's because we flag
    //      as referral
    //

    ASSERT( status != ERROR_SUCCESS || pBlob->pRecords != NULL );

    return status;
}



DNS_STATUS
Query_InProcess(
    IN OUT  PQUERY_BLOB     pBlob
    )
/*++

Routine Description:

    Main direct in-process query routine.

Arguments:

    pBlob -- query info blob

Return Value:

    ERROR_SUCCESS if successful.
    DNS RCODE error for RCODE response.
    DNS_INFO_NO_RECORDS for no records response.
    ERROR_TIMEOUT on complete lookup failure.
    ErrorCode on local failure.

--*/
{
    DNS_STATUS          status = NO_ERROR;
    PDNS_NETINFO        pnetInfo;
    PDNS_NETINFO        pnetInfoLocal = NULL;
    PDNS_NETINFO        pnetInfoOriginal;
    DNS_STATUS          statusNetFailure = NO_ERROR;


    DNSDBG( TRACE, (
        "Query_InProcess( %p )\n",
        pBlob ));

    //
    //  skip queries in "net down" situation
    //

    if ( IsKnownNetFailure() )
    {
        status = GetLastError();
        goto Cleanup;
    }

    //
    //  get network info
    //

    pnetInfo = pnetInfoOriginal = pBlob->pNetworkInfo;

    //
    //  explicit DNS server list -- build into network info
    //      - requires info from current list for search list or PDN
    //      - then dump current list and use private version
    //

    if ( pBlob->pDnsServers )
    {
        pnetInfo = NetInfo_CreateFromIpArray(
                            pBlob->pDnsServers,
                            0,          // no specific server
                            TRUE,       // build search info
                            pnetInfo    // use existing netinfo
                            );
        if ( !pnetInfo )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Cleanup;
        }
        pnetInfoLocal = pnetInfo;
    }

    //
    //  no network info -- get it
    //

    else if ( !pnetInfo )
    {
        pnetInfoLocal = pnetInfo = GetNetworkInfo();
        if ( ! pnetInfo )
        {
            status = DNS_ERROR_NO_DNS_SERVERS;
            goto Cleanup;
        }
    }

    pBlob->pNetworkInfo = pnetInfo;

    //
    //  make actual query to DNS servers
    //

    pBlob->pfnQueryCache    = QueryHostFile;
    pBlob->pfnGetAddrArray  = DnsGetLocalAddrArray;

    status = Query_Main( pBlob );

    //
    //  save net failure
    //      - but not if passed in network info
    //      only meaningful if its standard info
    //
    //  DCR:  fix statusNetFailure mess
    //

    if ( statusNetFailure )
    {
        if ( !pBlob->pDnsServers )
        {
            SetKnownNetFailure( status );
        }
    }

    //
    //  cleanup
    //

Cleanup:

    NetInfo_Free( pnetInfoLocal );
    pBlob->pNetworkInfo = pnetInfoOriginal;

    GUI_MODE_SETUP_WS_CLEANUP( g_InNTSetupMode );

    return status;
}



//
//  Query utilities
//

DNS_STATUS
GetDnsServerRRSet(
    OUT     PDNS_RECORD *   ppRecord,
    IN      BOOLEAN         fUnicode
    )
/*++

Routine Description:

    Create record list of None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PDNS_NETINFO    pnetInfo;
    DWORD           iter;
    PDNS_RECORD     prr;
    DNS_RRSET       rrSet;
    DNS_CHARSET     charSet = fUnicode ? DnsCharSetUnicode : DnsCharSetUtf8;


    DNSDBG( QUERY, (
        "GetDnsServerRRSet()\n" ));

    DNS_RRSET_INIT( rrSet );

    pnetInfo = GetNetworkInfo();
    if ( !pnetInfo )
    {
        goto Done;
    }

    //
    //  loop through all adapters build record for each DNS server
    //

    for ( iter = 0;
          iter < pnetInfo->AdapterCount;
          iter++ )
    {
        PDNS_ADAPTER    padapter = pnetInfo->AdapterArray[iter];
        PSTR            pname;
        DWORD           jiter;

        if ( !padapter )
        {
            continue;
        }

        //  DCR:  goofy way to expose aliases
        //
        //  if register the adapter's domain name, make it record name
        //  this 

        pname = padapter->pszAdapterDomain;
        if ( !pname ||
             !( padapter->InfoFlags & DNS_FLAG_REGISTER_DOMAIN_NAME ) )
        {
            pname = ".";
        }

        for ( jiter = 0; jiter < padapter->ServerCount; jiter++ )
        {
            //  DCR:  IP6 DNS servers

            IP_UNION    ipUnion;

            IPUNION_SET_IP4( &ipUnion, padapter->ServerArray[jiter].IpAddress );

            prr = Dns_CreateForwardRecord(
                        pname,
                        & ipUnion,
                        0,                  //  no TTL
                        DnsCharSetUtf8,     //  name is UTF8
                        charSet             //  result set
                        );
            if ( prr )
            {
                prr->Flags.S.Section = DNSREC_ANSWER;
                DNS_RRSET_ADD( rrSet, prr );
            }
        }
    }

Done:

    NetInfo_Free( pnetInfo );

    *ppRecord = prr = rrSet.pFirstRR;

    DNSDBG( QUERY, (
        "Leave  GetDnsServerRRSet() => %d\n",
        (prr ? ERROR_SUCCESS : DNS_ERROR_NO_DNS_SERVERS) ));

    return (prr ? ERROR_SUCCESS : DNS_ERROR_NO_DNS_SERVERS);
}



//
//  DNS Query API
//

DNS_STATUS
WINAPI
privateNarrowToWideQuery(
    IN      PCSTR           pszName,
    IN      WORD            wType,
    IN      DWORD           Options,
    IN      PIP_ARRAY       pDnsServers OPTIONAL,
    OUT     PDNS_RECORD *   ppResultSet OPTIONAL,
    IN OUT  PDNS_MSG_BUF *  ppMessageResponse OPTIONAL,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Convert narrow to wide query.

    This routine simple avoids duplicate code in ANSI
    and UTF8 query routines.

Arguments:

    pszName -- name to query

    wType -- type of query

    Options -- flags to query

    pDnsServers -- array of DNS servers to use in query

    ppResultSet -- addr to receive result DNS records

    ppMessageResponse -- addr to receive response message

    CharSet -- char set of original query

Return Value:

    ERROR_SUCCESS on success.
    DNS RCODE error on query with RCODE
    DNS_INFO_NO_RECORDS on no records response.
    ErrorCode on failure.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    PDNS_RECORD     prrList = NULL;
    PWSTR           pwideName = NULL;
    WORD            nameLength;

    if ( !pszName )
    {
        return ERROR_INVALID_PARAMETER;
    }

    nameLength = (WORD) strlen( pszName );

    pwideName = ALLOCATE_HEAP( (nameLength + 1) * sizeof(WCHAR) );
    if ( !pwideName )
    {
        return DNS_ERROR_NO_MEMORY;
    }

    if ( !Dns_NameCopy(
                (PSTR) pwideName,
                NULL,
                (PSTR) pszName,
                nameLength,
                CharSet,
                DnsCharSetUnicode ) )
    {
        status = ERROR_INVALID_NAME;
        goto Done;
    }

    status = DnsQuery_W(
                    pwideName,
                    wType,
                    Options,
                    pDnsServers,
                    ppResultSet ? &prrList : NULL,
                    ppMessageResponse
                    );

    //
    //  convert result records back to ANSI (or UTF8)
    //

    if ( ppResultSet && prrList )
    {
        *ppResultSet = Dns_RecordSetCopyEx(
                                    prrList,
                                    DnsCharSetUnicode,
                                    CharSet
                                    );
        if ( ! *ppResultSet )
        {
            status = DNS_ERROR_NO_MEMORY;
        }
        Dns_RecordListFree( prrList );
    }

    //
    //  cleanup
    //

Done:

    FREE_HEAP( pwideName );

    return status;
}



DNS_STATUS
WINAPI
DnsQuery_UTF8(
    IN      PCSTR           pszName,
    IN      WORD            wType,
    IN      DWORD           Options,
    IN      PIP_ARRAY       pDnsServers OPTIONAL,
    OUT     PDNS_RECORD *   ppResultSet OPTIONAL,
    IN OUT  PDNS_MSG_BUF *  ppMessageResponse OPTIONAL
    )
/*++

Routine Description:

    Public UTF8 query.

Arguments:

    pszName -- name to query

    wType -- type of query

    Options -- flags to query

    pDnsServers -- array of DNS servers to use in query

    ppResultSet -- addr to receive result DNS records

    ppMessageResponse -- addr to receive response message

Return Value:

    ERROR_SUCCESS on success.
    DNS RCODE error on query with RCODE
    DNS_INFO_NO_RECORDS on no records response.
    ErrorCode on failure.

--*/
{
    return  privateNarrowToWideQuery(
                pszName,
                wType,
                Options,
                pDnsServers,
                ppResultSet,
                ppMessageResponse,
                DnsCharSetUtf8
                );
}



DNS_STATUS
WINAPI
DnsQuery_A(
    IN      PCSTR           pszName,
    IN      WORD            wType,
    IN      DWORD           Options,
    IN      PIP_ARRAY       pDnsServers         OPTIONAL,
    OUT     PDNS_RECORD *   ppResultSet         OPTIONAL,
    IN OUT  PDNS_MSG_BUF *  ppMessageResponse   OPTIONAL
    )
/*++

Routine Description:

    Public ANSI query.

Arguments:

    pszName -- name to query

    wType -- type of query

    Options -- flags to query

    pDnsServers -- array of DNS servers to use in query

    ppResultSet -- addr to receive result DNS records

    ppMessageResponse -- addr to receive resulting message

Return Value:

    ERROR_SUCCESS on success.
    DNS RCODE error on query with RCODE
    DNS_INFO_NO_RECORDS on no records response.
    ErrorCode on failure.

--*/
{
    return  privateNarrowToWideQuery(
                pszName,
                wType,
                Options,
                pDnsServers,
                ppResultSet,
                ppMessageResponse,
                DnsCharSetAnsi
                );
}



DNS_STATUS
WINAPI
DnsQuery_W(
    IN      PCWSTR          pwsName,
    IN      WORD            wType,
    IN      DWORD           Options,
    IN      PIP_ARRAY       pDnsServers OPTIONAL,
    IN OUT  PDNS_RECORD *   ppResultSet OPTIONAL,
    IN OUT  PDNS_MSG_BUF *  ppMessageResponse OPTIONAL
    )
/*++

Routine Description:

    Public unicode query API

    Note, this unicode version is the main routine.
    The other public API call back through it.

Arguments:

    pszName -- name to query

    wType -- type of query

    Options -- flags to query

    pDnsServers -- array of DNS servers to use in query

    ppResultSet -- addr to receive result DNS records

    ppMessageResponse -- addr to receive resulting message

Return Value:

    ERROR_SUCCESS on success.
    DNS RCODE error on query with RCODE
    DNS_INFO_NO_RECORDS on no records response.
    ErrorCode on failure.

--*/
{
    DNS_STATUS          status = NO_ERROR;
    PDNS_NETINFO        pnetInfo = NULL;
    PDNS_RECORD         prpcRecord = NULL;
    DWORD               rpcStatus = NO_ERROR;
    PQUERY_BLOB         pblob;
    PWSTR               pnameLocal = NULL;


    DNSDBG( TRACE, (
        "\n\nDnsQuery_W()\n"
        "\tName         = %S\n"
        "\twType        = %d\n"
        "\tOptions      = %08x\n"
        "\tpDnsServers  = %p\n"
        "\tppMessage    = %p\n",
        pwsName,
        wType,
        Options,
        pDnsServers,
        ppMessageResponse ));

    //
    //  must ask for some kind of results
    //

    if ( !ppResultSet && !ppMessageResponse )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  NULL name indicates localhost lookup
    //
    //  DCR:  NULL name lookup for localhost could be improved
    //      - support NULL all the way through to wire
    //      - have local IP routines just accept it
    //

    if ( !pwsName )
    {
        pnameLocal = (PWSTR) Reg_GetHostName( DnsCharSetUnicode );
        if ( !pnameLocal )
        {
            return  DNS_ERROR_NAME_NOT_FOUND_LOCALLY;
        }
        pwsName = (PCWSTR) pnameLocal;
        Options |= DNS_QUERY_CACHE_ONLY;
    }

    //  clear OUT params

    if ( ppResultSet )
    {
        *ppResultSet = NULL;
    }

    if ( ppMessageResponse )
    {
        *ppMessageResponse = NULL;
    }

    //
    //  IP string queries
    //

    if ( ppResultSet )
    {
        PDNS_RECORD prr;

        prr = Dns_CreateRecordForIpString_W(
                    pwsName,
                    wType,
                    IPSTRING_RECORD_TTL );
        if ( prr )
        {
            *ppResultSet = prr;
            status = ERROR_SUCCESS;
            goto Done;
        }
    }

    //
    //  empty type A query get DNS servers
    //
    //  DCR_CLEANUP:  DnsQuery empty name query for DNS servers?
    //      need better\safer approach to this
    //      is this SDK doc'd
    //

    if ( ppResultSet &&
         !ppMessageResponse &&
         wType == DNS_TYPE_A &&
         ( !wcscmp( pwsName, L"" ) ||
           !wcscmp( pwsName, DNS_SERVER_QUERY_NAME ) ) )
    {
        status = GetDnsServerRRSet(
                    ppResultSet,
                    TRUE    // unicode
                    );
        goto Done;
    }

    //
    //  BYPASS_CACHE
    //      - required if want message buffer or specify server
    //          list -- just set flag
    //      - incompatible with CACHE_ONLY
    //      - required to get EMPTY_AUTH_RESPONSE
    //

    if ( ppMessageResponse ||
         pDnsServers ||
         (Options & DNS_QUERY_ALLOW_EMPTY_AUTH_RESP) )
    {
        Options |= DNS_QUERY_BYPASS_CACHE;
        //Options |= DNS_QUERY_NO_CACHE_DATA;
    }

    //
    //  do direct query?
    //      - not RPC-able type
    //      - want message buffer
    //      - specifying DNS servers
    //      - want EMPTY_AUTH response records
    //
    //  DCR:  currently by-passing for type==ALL
    //      this may be too common to do that;   may want to
    //      go to cache then determine if security records
    //      or other stuff require us to query in process
    //
    //  DCR:  not clear what the EMPTY_AUTH benefit is
    //
    //  DCR:  currently BYPASSing whenever BYPASS is set
    //      because otherwise we miss the hosts file
    //      if fix so lookup in cache, but screen off non-hosts
    //      data, then could resume going to cache
    //

    if ( !Dns_IsRpcRecordType(wType) &&
         !(Options & DNS_QUERY_CACHE_ONLY) )
    {
        goto  InProcessQuery;
    }

    if ( Options & DNS_QUERY_BYPASS_CACHE )
#if 0
    if ( (Options & DNS_QUERY_BYPASS_CACHE) &&
         ( ppMessageResponse ||
           pDnsServers ||
           (Options & DNS_QUERY_ALLOW_EMPTY_AUTH_RESP) ) )
#endif
    {
        if ( Options & DNS_QUERY_CACHE_ONLY )
        {
            status = ERROR_INVALID_PARAMETER;
            goto Done;
        }
        goto  InProcessQuery;
    }

    //
    //  querying through cache
    //      - get cluster-filtering info
    //

    if ( g_IsServer )
    {
        ENVAR_DWORD_INFO    filterInfo;

        Reg_ReadDwordEnvar(
           RegIdFilterClusterIp,
           &filterInfo );

        if ( filterInfo.fFound && filterInfo.Value )
        {
            Options |= DNSP_QUERY_FILTER_CLUSTER;
        }
    }

    rpcStatus = NO_ERROR;

    RpcTryExcept
    {
        status = R_ResolverQuery(
                    NULL,
                    (PWSTR) pwsName,
                    wType,
                    Options,
                    &prpcRecord );
        
    }
    RpcExcept( DNS_RPC_EXCEPTION_FILTER )
    {
        rpcStatus = RpcExceptionCode();
    }
    RpcEndExcept

    //
    //  cache unavailable
    //      - bail if just querying cache
    //      - otherwise query direct

    if ( rpcStatus != NO_ERROR )
    {
        DNSDBG( TRACE, (
            "DnsQuery_W()  RPC failed status = %d\n",
            rpcStatus ));
        goto InProcessQuery;
    }
    if ( status == DNS_ERROR_NO_TCPIP )
    {
        DNSDBG( TRACE, (
            "DnsQuery_W()  NO_TCPIP error!\n"
            "\tassume resolver security problem -- query in process!\n"
            ));
        RTL_ASSERT( !prpcRecord );
        goto InProcessQuery;
    }

    //
    //  return records
    //      - screen out empty-auth responses
    //
    //  DCR_FIX1:  cache should convert and return NO_RECORDS response
    //      directly (no need to do this here)
    //
    //  DCR:  UNLESS we allow return of these records
    //

    if ( prpcRecord )
    {
        FixupNameOwnerPointers( prpcRecord );

        if ( IsEmptyDnsResponseFromResolver( prpcRecord ) )
        {
            Dns_RecordListFree( prpcRecord );
            prpcRecord = NULL;
            if ( status == NO_ERROR )
            {
                status = DNS_INFO_NO_RECORDS;
            }
        }
        *ppResultSet = prpcRecord;
    }
    RTL_ASSERT( status!=NO_ERROR || prpcRecord );
    goto Done;

    //
    //  query directly -- either skipping cache or it's unavailable
    //

InProcessQuery:

    DNSDBG( TRACE, (
        "DnsQuery_W()  -- doing in process query\n"
        "\tpname = %S\n"
        "\ttype  = %d\n",
        pwsName,
        wType ));

    //
    //  load query blob
    //
    //  DCR:  set some sort of "want message buffer" flag if ppMessageResponse
    //          exists
    //

    pblob = ALLOCATE_HEAP_ZERO( sizeof(*pblob) );
    if ( !pblob )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    pblob->pNameOrig    = (PWSTR) pwsName;
    pblob->wType        = wType;
    pblob->Flags        = Options | DNSQUERY_UNICODE_OUT;
    pblob->pDnsServers  = pDnsServers;

    //  
    //  query
    //      - then set OUT params

    status = Query_InProcess( pblob );

    if ( ppResultSet )
    {
        *ppResultSet = pblob->pRecords;
        RTL_ASSERT( status!=NO_ERROR || *ppResultSet );
    }
    else
    {
        Dns_RecordListFree( pblob->pRecords );
    }

    if ( ppMessageResponse )
    {
        *ppMessageResponse = pblob->pRecvMsg;
    }

    FREE_HEAP( pblob );

Done:

    //  sanity check

    if ( status==NO_ERROR &&
         ppResultSet &&
         !*ppResultSet )
    {
        RTL_ASSERT( FALSE );
        status = DNS_INFO_NO_RECORDS;
    }

    if ( pnameLocal )
    {
        FREE_HEAP( pnameLocal );
    }

    DNSDBG( TRACE, (
        "Leave DnsQuery_W()\n"
        "\tstatus       = %d\n"
        "\tresult set   = %p\n\n\n",
        status,
        *ppResultSet ));

    return( status );
}



//
//  DnsQueryEx()  routines
//

DNS_STATUS
WINAPI
ShimDnsQueryEx(
    IN OUT  PDNS_QUERY_INFO pQueryInfo
    )
/*++

Routine Description:

    Query DNS -- shim for main SDK query routine.

Arguments:

    pQueryInfo -- blob describing query

Return Value:

    ERROR_SUCCESS if successful query.
    Error code on failure.

--*/
{
    PDNS_RECORD prrResult;
    WORD        type = pQueryInfo->Type;
    DNS_STATUS  status;
    DNS_LIST    listAnswer;
    DNS_LIST    listAlias;
    DNS_LIST    listAdditional;
    DNS_LIST    listAuthority;

    DNSDBG( TRACE, ( "ShimDnsQueryEx()\n" ));

    //
    //  DCR:  temp hack is to pass this to DNSQuery
    //

    status = DnsQuery_W(
                (PWSTR) pQueryInfo->pName,
                type,
                pQueryInfo->Flags,
                pQueryInfo->pDnsServers,
                & prrResult,
                NULL );

    pQueryInfo->Status = status;

    //
    //  cut result records appropriately
    //

    pQueryInfo->pAnswerRecords      = NULL;
    pQueryInfo->pAliasRecords       = NULL;
    pQueryInfo->pAdditionalRecords  = NULL;
    pQueryInfo->pAuthorityRecords   = NULL;

    if ( prrResult )
    {
        PDNS_RECORD     prr;
        PDNS_RECORD     pnextRR;

        DNS_LIST_STRUCT_INIT( listAnswer );
        DNS_LIST_STRUCT_INIT( listAlias );
        DNS_LIST_STRUCT_INIT( listAdditional );
        DNS_LIST_STRUCT_INIT( listAuthority );

        //
        //  break list into section specific lists
        //      - section 0 for hostfile records
        //      - note, this does pull RR sets apart, but
        //      they, being in same section, should immediately
        //      be rejoined
        //

        pnextRR = prrResult;
        
        while ( prr = pnextRR )
        {
            pnextRR = prr->pNext;
            prr->pNext = NULL;
        
            if ( prr->Flags.S.Section == 0 ||
                 prr->Flags.S.Section == DNSREC_ANSWER )
            {
                if ( prr->wType == DNS_TYPE_CNAME &&
                     type != DNS_TYPE_CNAME )
                {
                    DNS_LIST_STRUCT_ADD( listAlias, prr );
                    continue;
                }
                else
                {
                    DNS_LIST_STRUCT_ADD( listAnswer, prr );
                    continue;
                }
            }
            else if ( prr->Flags.S.Section == DNSREC_ADDITIONAL )
            {
                DNS_LIST_STRUCT_ADD( listAdditional, prr );
                continue;
            }
            else
            {
                DNS_LIST_STRUCT_ADD( listAuthority, prr );
                continue;
            }
        }

        //  pack stuff back into blob

        pQueryInfo->pAnswerRecords      = listAnswer.pFirst;
        pQueryInfo->pAliasRecords       = listAlias.pFirst;
        pQueryInfo->pAuthorityRecords   = listAuthority.pFirst;
        pQueryInfo->pAdditionalRecords  = listAdditional.pFirst;
        //pQueryInfo->pSigRecords         = listSig.pFirst;

        //
        //  convert result records back to ANSI (or UTF8)
        //      - convert each result set
        //      - then paste back into query blob
        //
        //  DCR_FIX0:  handle issue of failure on conversion
        //

        if ( pQueryInfo->CharSet != DnsCharSetUnicode )
        {
            PDNS_RECORD     prr;
            PDNS_RECORD *   prrSetPtr;

            prrSetPtr = & pQueryInfo->pAnswerRecords;
        
            for ( prrSetPtr = & pQueryInfo->pAnswerRecords;
                  prrSetPtr <= & pQueryInfo->pAdditionalRecords;
                  prrSetPtr++ )
            {
                prr = *prrSetPtr;
        
                *prrSetPtr = Dns_RecordSetCopyEx(
                                    prr,
                                    DnsCharSetUnicode,
                                    pQueryInfo->CharSet
                                    );
        
                Dns_RecordListFree( prr );
            }
        }
    }

    //
    //  replace name for originally narrow queries
    //

    if ( pQueryInfo->CharSet != DnsCharSetUnicode )
    {
        ASSERT( pQueryInfo->CharSet != 0 );
        ASSERT( pQueryInfo->pReservedName != NULL );

        FREE_HEAP( pQueryInfo->pName );
        pQueryInfo->pName = (LPTSTR) pQueryInfo->pReservedName;
        pQueryInfo->pReservedName = NULL;
    }

    //
    //  indicate return if async
    //

    if ( pQueryInfo->hEvent )
    {
        SetEvent( pQueryInfo->hEvent );
    }

    return( status );
}



DNS_STATUS
WINAPI
CombinedQueryEx(
    IN OUT  PDNS_QUERY_INFO pQueryInfo,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Convert narrow to wide query.

    This routine simple avoids duplicate code in ANSI
    and UTF8 query routines.

Arguments:

    pQueryInfo -- query info blob

    CharSet -- char set of original query

Return Value:

    ERROR_SUCCESS on success.
    DNS RCODE error on query with RCODE
    DNS_INFO_NO_RECORDS on no records response.
    ErrorCode on failure.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    PWSTR           pwideName = NULL;
    HANDLE          hthread;
    DWORD           threadId;

    DNSDBG( TRACE, (
        "CombinedQueryEx( %S%s, type=%d, flag=%08x, event=%p )\n",
        PRINT_STRING_WIDE_CHARSET( pQueryInfo->pName, CharSet ),
        PRINT_STRING_ANSI_CHARSET( pQueryInfo->pName, CharSet ),
        pQueryInfo->Type,
        pQueryInfo->Flags,
        pQueryInfo->hEvent ));

    //
    //  set CharSet
    //

    pQueryInfo->CharSet = CharSet;

    if ( CharSet == DnsCharSetUnicode )
    {
        pQueryInfo->pReservedName = 0;
    }

    //
    //  if narrow name
    //      - allocate wide name copy
    //      - swap in wide name and make query wide
    //
    //  DCR:  allow NULL name?  for local machine name?
    //

    else if ( CharSet == DnsCharSetAnsi ||
              CharSet == DnsCharSetUtf8 )
    {
        WORD    nameLength;
        PSTR    pnameNarrow;

        pnameNarrow = pQueryInfo->pName;
        if ( !pnameNarrow )
        {
            return ERROR_INVALID_PARAMETER;
        }
    
        nameLength = (WORD) strlen( pnameNarrow );
    
        pwideName = ALLOCATE_HEAP( (nameLength + 1) * sizeof(WCHAR) );
        if ( !pwideName )
        {
            return DNS_ERROR_NO_MEMORY;
        }
    
        if ( !Dns_NameCopy(
                    (PSTR) pwideName,
                    NULL,
                    pnameNarrow,
                    nameLength,
                    CharSet,
                    DnsCharSetUnicode ) )
        {
            status = ERROR_INVALID_NAME;
            goto Failed;
        }

        pQueryInfo->pName = (LPTSTR) pwideName;
        pQueryInfo->pReservedName = pnameNarrow;
    }

    //
    //  async?
    //      - if event exists we are async
    //      - spin up thread and call it
    //

    if ( pQueryInfo->hEvent )
    {
        hthread = CreateThread(
                        NULL,           // no security
                        0,              // default stack
                        ShimDnsQueryEx,
                        pQueryInfo,     // param
                        0,              // run immediately
                        & threadId
                        );
        if ( !hthread )
        {
            DNS_STATUS  status = GetLastError();

            DNSDBG( ANY, (
                "Failed to create thread = %d\n",
                status ));

            if ( status == ERROR_SUCCESS )
            {
                status = DNS_ERROR_NO_MEMORY;
            }
            goto Failed;
        }

        CloseHandle( hthread );
        return( ERROR_IO_PENDING );
    }

    //      
    //  otherwise make direct async call
    //

    return   ShimDnsQueryEx( pQueryInfo );


Failed:

    FREE_HEAP( pwideName );
    return( status );
}



DNS_STATUS
WINAPI
DnsQueryExW(
    IN OUT  PDNS_QUERY_INFO pQueryInfo
    )
/*++

Routine Description:

    Query DNS -- main SDK query routine.

Arguments:

    pQueryInfo -- blob describing query

Return Value:

    ERROR_SUCCESS if successful query.
    ERROR_IO_PENDING if successful async start.
    Error code on failure.

--*/
{
    DNSDBG( TRACE, (
        "DnsQueryExW( %S, type=%d, flag=%08x, event=%p )\n",
        pQueryInfo->pName,
        pQueryInfo->Type,
        pQueryInfo->Flags,
        pQueryInfo->hEvent ));

    return  CombinedQueryEx( pQueryInfo, DnsCharSetUnicode );
}



DNS_STATUS
WINAPI
DnsQueryExA(
    IN OUT  PDNS_QUERY_INFO pQueryInfo
    )
/*++

Routine Description:

    Query DNS -- main SDK query routine.

Arguments:

    pQueryInfo -- blob describing query

Return Value:

    ERROR_SUCCESS if successful query.
    ERROR_IO_PENDING if successful async start.
    Error code on failure.

--*/
{
    DNSDBG( TRACE, (
        "DnsQueryExA( %s, type=%d, flag=%08x, event=%p )\n",
        pQueryInfo->pName,
        pQueryInfo->Type,
        pQueryInfo->Flags,
        pQueryInfo->hEvent ));

    return  CombinedQueryEx( pQueryInfo, DnsCharSetAnsi );
}



DNS_STATUS
WINAPI
DnsQueryExUTF8(
    IN OUT  PDNS_QUERY_INFO pQueryInfo
    )
/*++

Routine Description:

    Query DNS -- main SDK query routine.

Arguments:

    pQueryInfo -- blob describing query

Return Value:

    ERROR_SUCCESS if successful query.
    ERROR_IO_PENDING if successful async start.
    Error code on failure.

--*/
{
    DNSDBG( TRACE, (
        "DnsQueryExUTF8( %s, type=%d, flag=%08x, event=%p )\n",
        pQueryInfo->pName,
        pQueryInfo->Type,
        pQueryInfo->Flags,
        pQueryInfo->hEvent ));

    return  CombinedQueryEx( pQueryInfo, DnsCharSetUtf8 );
}



//
//  Name collision API
//
//  DCR_QUESTION:  name collision -- is there any point to this?
//

DNS_STATUS
WINAPI
DnsCheckNameCollision_UTF8(
    IN      PCSTR           pszName,
    IN      DWORD           Options
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DNS_STATUS  status = NO_ERROR;
    PDNS_RECORD prrList = NULL;
    PDNS_RECORD prr = NULL;
    DWORD       iter;
    BOOL        fmatch = FALSE;
    WORD        wtype = DNS_TYPE_A;

    if ( !pszName )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( Options & DNS_CHECK_AGAINST_HOST_ANY )
    {
        wtype = DNS_TYPE_ANY;
    }

    status = DnsQuery_UTF8( pszName,
                            wtype,
                            DNS_QUERY_BYPASS_CACHE,
                            NULL,
                            &prrList,
                            NULL );

    if ( status == DNS_ERROR_RCODE_NAME_ERROR ||
         status == DNS_INFO_NO_RECORDS )
    {
        Dns_RecordListFree( prrList );
        return NO_ERROR;
    }

    if ( status == NO_ERROR &&
         Options == DNS_CHECK_AGAINST_HOST_ANY )
    {
        Dns_RecordListFree( prrList );
        return DNS_ERROR_RCODE_YXRRSET;
    }

    if ( status == NO_ERROR &&
         Options == DNS_CHECK_AGAINST_HOST_DOMAIN_NAME )
    {
        char  TestName[DNS_MAX_NAME_LENGTH * 2];
        PSTR  pszHostName = Reg_GetHostName( DnsCharSetUtf8 );
        PSTR  pszPrimaryDomain = Reg_GetPrimaryDomainName( DnsCharSetUtf8 );

        fmatch = TRUE;

        strcpy( TestName, pszHostName );

        if ( pszPrimaryDomain )
        {
            strcat( TestName, "." );
            strcat( TestName, pszPrimaryDomain );
        }

        if ( Dns_NameCompare_UTF8( pszHostName, (PSTR)pszName ) )
        {
            fmatch = TRUE;
        }

        if ( !fmatch &&
             pszPrimaryDomain &&
             Dns_NameCompare_UTF8( TestName, (PSTR)pszName ) )
        {
            fmatch = TRUE;
        }

        if ( !fmatch )
        {
            PDNS_NETINFO pNetInfo = GetNetworkInfo();

            if ( pNetInfo )
            {
                for ( iter = 0; iter < pNetInfo->AdapterCount; iter++ )
                {
                    PSTR  pszDomain = pNetInfo->AdapterArray[iter]->
                                                        pszAdapterDomain;
                    if ( pszDomain )
                    {
                        strcpy( TestName, pszHostName );
                        strcat( TestName, "." );
                        strcat( TestName, pszDomain );

                        if ( Dns_NameCompare_UTF8( TestName, (PSTR)pszName ) )
                            fmatch = TRUE;
                    }
                }
            }

            NetInfo_Free( pNetInfo );
        }

        FREE_HEAP( pszHostName );
        FREE_HEAP( pszPrimaryDomain );

        if ( fmatch )
        {
            Dns_RecordListFree( prrList );
            return DNS_ERROR_RCODE_YXRRSET;
        }
    }

    if ( status == NO_ERROR )
    {
        PDNS_ADDRESS_INFO pAddressInfo = NULL;
        DWORD             Count = DnsGetIpAddressInfoList( &pAddressInfo );

        if ( Count == 0 )
        {
            Dns_RecordListFree( prrList );
            return DNS_ERROR_RCODE_YXRRSET;
        }

        prr = prrList;

        while ( prr )
        {
            fmatch = FALSE;

            if ( prr->Flags.S.Section != DNSREC_ANSWER )
            {
                prr = prr->pNext;
                continue;
            }

            if ( prr->wType == DNS_TYPE_CNAME )
            {
                FREE_HEAP( pAddressInfo );
                Dns_RecordListFree( prrList );
                return DNS_ERROR_RCODE_YXRRSET;
            }

            for ( iter = 0; iter < Count; iter++ )
            {
                if ( prr->Data.A.IpAddress == pAddressInfo[iter].ipAddress )
                {
                    fmatch = TRUE;
                }
            }

            if ( !fmatch )
            {
                FREE_HEAP( pAddressInfo );
                Dns_RecordListFree( prrList );
                return DNS_ERROR_RCODE_YXRRSET;
            }

            prr = prr->pNext;
        }

        FREE_HEAP( pAddressInfo );
        Dns_RecordListFree( prrList );
        return NO_ERROR;
    }

    return status;
}



DNS_STATUS
WINAPI
DnsCheckNameCollision_A(
    IN      PCSTR           pszName,
    IN      DWORD           Options
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PSTR       pUtf8Name = NULL;
    DNS_STATUS status = NO_ERROR;

    //
    //  DCR_CLEANUP:  fix unnecessary alloc
    //  DCR_PERF:   eliminate alloc
    //

    if ( !pszName )
    {
        return ERROR_INVALID_PARAMETER;
    }

    pUtf8Name = Dns_NameCopyAllocate(
                    (PSTR) pszName,
                    0,
                    DnsCharSetAnsi,
                    DnsCharSetUtf8 );
    if ( !pUtf8Name )
    {
        return DNS_ERROR_NO_MEMORY;
    }

    status = DnsCheckNameCollision_UTF8( pUtf8Name, Options );

    FREE_HEAP( pUtf8Name );

    return status;
}



DNS_STATUS
WINAPI
DnsCheckNameCollision_W(
    IN      PCWSTR          pszName,
    IN      DWORD           Options
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  DCR_CLEANUP:  fix unnecessary alloc
    //  DCR_PERF:   eliminate alloc
    //

    DNS_STATUS status = NO_ERROR;
    PSTR       lpTempName = NULL;
    WORD       nameLength;

    if ( !pszName )
    {
        return ERROR_INVALID_PARAMETER;
    }

    nameLength = (WORD)wcslen( pszName );

    lpTempName = ALLOCATE_HEAP( (nameLength + 1) * sizeof(WCHAR) );

    if ( lpTempName == NULL )
    {
        return DNS_ERROR_NO_MEMORY;
    }

    Dns_NameCopy( lpTempName,
                  NULL,
                  (PSTR) pszName,
                  0,
                  DnsCharSetUnicode,
                  DnsCharSetUtf8 );

    status = DnsCheckNameCollision_UTF8( lpTempName, Options );

    FREE_HEAP( lpTempName );

    return status;
}



//
//  Roll your own query utilities
//

BOOL
WINAPI
DnsWriteQuestionToBuffer_W(
    IN OUT  PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN OUT  LPDWORD             pdwBufferSize,
    IN      PWSTR               pszName,
    IN      WORD                wType,
    IN      WORD                Xid,
    IN      BOOL                fRecursionDesired
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  DCR_CLEANUP:  duplicate code with routine below ... surprise!
    //      - eliminate duplicate
    //      - probably can just pick up library routine
    //

    PCHAR pch;
    PCHAR pbufferEnd = NULL;

    if ( *pdwBufferSize >= DNS_MAX_UDP_PACKET_BUFFER_LENGTH )
    {
        pbufferEnd = (PCHAR)pDnsBuffer + *pdwBufferSize;

        //  clear header

        RtlZeroMemory( pDnsBuffer, sizeof(DNS_HEADER) );

        //  set for rewriting

        pch = pDnsBuffer->MessageBody;

        //  write question name

        pch = Dns_WriteDottedNameToPacket(
                    pch,
                    pbufferEnd,
                    (PCHAR) pszName,
                    NULL,
                    0,
                    TRUE );

        if ( !pch )
        {
            return FALSE;
        }

        //  write question structure

        *(UNALIGNED WORD *) pch = htons( wType );
        pch += sizeof(WORD);
        *(UNALIGNED WORD *) pch = DNS_RCLASS_INTERNET;
        pch += sizeof(WORD);

        //  set question RR section count

        pDnsBuffer->MessageHead.QuestionCount = htons( 1 );
        pDnsBuffer->MessageHead.RecursionDesired = (BOOLEAN)fRecursionDesired;
        pDnsBuffer->MessageHead.Xid = htons( Xid );

        *pdwBufferSize = (DWORD)(pch - (PCHAR)pDnsBuffer);

        return TRUE;
    }
    else
    {
        *pdwBufferSize = DNS_MAX_UDP_PACKET_BUFFER_LENGTH;
        return FALSE;
    }
}



BOOL
WINAPI
DnsWriteQuestionToBuffer_UTF8(
    IN OUT  PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN OUT  PDWORD              pdwBufferSize,
    IN      PSTR                pszName,
    IN      WORD                wType,
    IN      WORD                Xid,
    IN      BOOL                fRecursionDesired
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PCHAR pch;
    PCHAR pbufferEnd = NULL;

    if ( *pdwBufferSize >= DNS_MAX_UDP_PACKET_BUFFER_LENGTH )
    {
        pbufferEnd = (PCHAR)pDnsBuffer + *pdwBufferSize;

        //  clear header

        RtlZeroMemory( pDnsBuffer, sizeof(DNS_HEADER) );

        //  set for rewriting

        pch = pDnsBuffer->MessageBody;

        //  write question name

        pch = Dns_WriteDottedNameToPacket(
                    pch,
                    pbufferEnd,
                    pszName,
                    NULL,
                    0,
                    FALSE );

        if ( !pch )
        {
            return FALSE;
        }

        //  write question structure

        *(UNALIGNED WORD *) pch = htons( wType );
        pch += sizeof(WORD);
        *(UNALIGNED WORD *) pch = DNS_RCLASS_INTERNET;
        pch += sizeof(WORD);

        //  set question RR section count

        pDnsBuffer->MessageHead.QuestionCount = htons( 1 );
        pDnsBuffer->MessageHead.RecursionDesired = (BOOLEAN)fRecursionDesired;
        pDnsBuffer->MessageHead.Xid = htons( Xid );

        *pdwBufferSize = (DWORD)(pch - (PCHAR)pDnsBuffer);

        return TRUE;
    }
    else
    {
        *pdwBufferSize = DNS_MAX_UDP_PACKET_BUFFER_LENGTH;
        return FALSE;
    }
}



//
//  Record list to\from results
//

VOID
CombineRecordsInBlob(
    IN      PDNS_RESULTS    pResults,
    OUT     PDNS_RECORD *   ppRecords
    )
/*++

Routine Description:

    Query DNS -- shim for main SDK query routine.

Arguments:

    pQueryInfo -- blob describing query

Return Value:

    ERROR_SUCCESS if successful query.
    Error code on failure.

--*/
{
    PDNS_RECORD prr;

    DNSDBG( TRACE, ( "CombineRecordsInBlob()\n" ));

    //
    //  combine records back into one list
    //
    //  note, working backwards so only touch records once
    //

    prr = Dns_RecordListAppend(
            pResults->pAuthorityRecords,
            pResults->pAdditionalRecords
            );

    prr = Dns_RecordListAppend(
            pResults->pAnswerRecords,
            prr
            );

    prr = Dns_RecordListAppend(
            pResults->pAliasRecords,
            prr
            );

    *ppRecords = prr;
}



VOID
BreakRecordsIntoBlob(
    OUT     PDNS_RESULTS    pResults,
    IN      PDNS_RECORD     pRecords,
    IN      WORD            wType
    )
/*++

Routine Description:

    Break single record list into results pblob->

Arguments:

    pResults -- results to fill in

    pRecords -- record list

Return Value:

    None

--*/
{
    PDNS_RECORD     prr;
    PDNS_RECORD     pnextRR;
    DNS_LIST        listAnswer;
    DNS_LIST        listAlias;
    DNS_LIST        listAdditional;
    DNS_LIST        listAuthority;

    DNSDBG( TRACE, ( "BreakRecordsIntoBlob()\n" ));

    //
    //  clear blob
    //

    RtlZeroMemory(
        pResults,
        sizeof(*pResults) );

    //
    //  init building lists
    //

    DNS_LIST_STRUCT_INIT( listAnswer );
    DNS_LIST_STRUCT_INIT( listAlias );
    DNS_LIST_STRUCT_INIT( listAdditional );
    DNS_LIST_STRUCT_INIT( listAuthority );

    //
    //  break list into section specific lists
    //      - note, this does pull RR sets apart, but
    //      they, being in same section, should immediately
    //      be rejoined
    //
    //      - note, hostfile records made have section=0
    //      this is no longer the case but preserve until
    //      know this is solid and determine what section==0
    //      means
    //

    pnextRR = pRecords;
    
    while ( prr = pnextRR )
    {
        pnextRR = prr->pNext;
        prr->pNext = NULL;
    
        if ( prr->Flags.S.Section == 0 ||
             prr->Flags.S.Section == DNSREC_ANSWER )
        {
            if ( prr->wType == DNS_TYPE_CNAME &&
                 wType != DNS_TYPE_CNAME )
            {
                DNS_LIST_STRUCT_ADD( listAlias, prr );
                continue;
            }
            else
            {
                DNS_LIST_STRUCT_ADD( listAnswer, prr );
                continue;
            }
        }
        else if ( prr->Flags.S.Section == DNSREC_ADDITIONAL )
        {
            DNS_LIST_STRUCT_ADD( listAdditional, prr );
            continue;
        }
        else
        {
            DNS_LIST_STRUCT_ADD( listAuthority, prr );
            continue;
        }
    }

    //  pack stuff into blob

    pResults->pAnswerRecords      = listAnswer.pFirst;
    pResults->pAliasRecords       = listAlias.pFirst;
    pResults->pAuthorityRecords   = listAuthority.pFirst;
    pResults->pAdditionalRecords  = listAdditional.pFirst;
}



//
//  Random discontinued
//

#if 0
IP_ADDRESS
findHostIpInRecordList(
    IN      PDNS_RECORD     pRecord,
    IN      PDNS_NAME       pszHostName
    )
/*++

Routine Description:

    Find IP for hostname, if its A record is in list.

Arguments:

    pRecord - incoming RR set

    pszHostName - hostname to find

Return Value:

    IP address matching hostname, if A record for hostname found.
    Zero if not found.

--*/
{
    //
    //  DCR:  find best A record for name
    //      currently only finds first;  this is harmless but in
    //      disjoint net situation would need sorted to find best
    //

    while ( pRecord )
    {
        if ( pRecord->wType == DNS_TYPE_A &&
                Dns_NameCompare(
                    pRecord->pName,
                    pszHostName ) )
        {
            return( pRecord->Data.A.IpAddress );
        }
        pRecord = pRecord->pNext;
    }
    return( 0 );
}
#endif


//
//  End query.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\packet.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    packet.c

Abstract:

    Domain Name System (DNS) API

    Packet writing utilities.

Author:

    Jim Gilroy (jamesg)     October, 1996

Environment:

    User Mode - Win32

Revision History:

--*/


#include "local.h"


//
//  Global XID counter, to generate unique XIDs
//

WORD    gwTransactionId = 1;

//
//  Receive buffer size
//      - use 16K, max size where compression useful
//      other choices would be ethernet UDP frag size
//          (1472 or 1280 depending on who you talk to)
//

DWORD   g_RecvBufSize = 0x4000;


//
//  Class values for UPDATE packets
//  (Key concept here -- designed by committee)
//
//  These arrays are indexed by
//      !wDataLength -- row
//      Delete flag -- column
//

WORD    PrereqClassArray[2][2] =
{
    DNS_RCLASS_INTERNET,    //  data != 0, no delete
    0,                      //  data != 0, delete => ERROR
    DNS_RCLASS_ANY,         //  no data, no delete
    DNS_RCLASS_NONE,        //  no data, delete
};

WORD    UpdateClassArray[2][2] =
{
    DNS_RCLASS_INTERNET,    //  data != 0, no delete
    DNS_RCLASS_NONE,        //  data != 0, delete
    0,                      //  no data, no delete => ERROR
    DNS_RCLASS_ANY,         //  no data, delete
};



PDNS_MSG_BUF
Dns_AllocateMsgBuf(
    IN      WORD            wBufferLength   OPTIONAL
    )
/*++

Routine Description:

    Allocate message buffer.

Arguments:

    wBufferLength - optional length of message buffer;  default is MAX
        UDP size

Return Value:

    Ptr to message buffer.
    NULL on error.

--*/
{
    PDNS_MSG_BUF    pmsg;
    BOOL            ftcp = FALSE;
    WORD            allocLength;

    //
    //  default allocation to "classical" UDP max buffer length
    //      this is good enough for writing questions
    //      recv size buffers should request larger size
    //

    if ( wBufferLength < DNS_RFC_MAX_UDP_PACKET_LENGTH )
    {
        allocLength = DNS_RFC_MAX_UDP_PACKET_LENGTH;
    }
    else if ( wBufferLength == MAXWORD )
    {
        allocLength = (WORD) g_RecvBufSize;
    }
    else
    {
        allocLength = wBufferLength;
        ftcp = TRUE;
    }

    pmsg = ALLOCATE_HEAP( SIZEOF_MSG_BUF_OVERHEAD + allocLength );
    if ( !pmsg )
    {
        return( NULL );
    }

    //
    //  limit UDP sends to classical RFC UDP limit (512 bytes)
    //      regardless of actual allocation
    //  write routines use pBufferEnd to determine writeability
    //
    //  DCR:  allow big UDP send buffers for update?
    //      problem is that must roll back NOT just OPT, but also
    //      big buffer
    //
    //  DCR:  not really necessary as if write exceeds 512, can
    //      just flip to TCP anyway
    //

    pmsg->BufferLength = allocLength;

    if ( !ftcp )
    {
        allocLength = DNS_RFC_MAX_UDP_PACKET_LENGTH;
    }
    pmsg->pBufferEnd = (PCHAR)&pmsg->MessageHead + allocLength;
    pmsg->fTcp = (BOOLEAN)ftcp;

    //
    //  init -- this follows fTcp set as flag is used to set fields
    //

    Dns_InitializeMsgBuf( pmsg );

    return( pmsg );
}



VOID
Dns_InitializeMsgBuf(
    IN OUT  PDNS_MSG_BUF    pMsg
    )
/*++

Routine Description:

    Initialize message buffer to "clean" state.

Arguments:

    pMsg -- message to init

Return Value:

    Ptr to message buffer.
    NULL on error.

--*/
{
    //  clear info + header
    //
    //  DCR_CLEANUP:  can't take this approach without reworking Allocate
    //      function which sets BufferLength and pBufferEnd
    //      if this function is NOT independently used, then we can fix
    //      it to clean and completely
    //
    // RtlZeroMemory(
    //    pMsg,
    //    ((PBYTE)&pMsg->MessageBody - (PBYTE)pMsg) );


    //  setup addressing info

    pMsg->Socket = 0;
    pMsg->RemoteAddressLength = sizeof(SOCKADDR_IN);

    //  set for packet reception

    if ( pMsg->fTcp )
    {
        SET_MESSAGE_FOR_TCP_RECV( pMsg );
    }
    else
    {
        SET_MESSAGE_FOR_UDP_RECV( pMsg );
    }

    //  clear header

    RtlZeroMemory(
        (PBYTE) &pMsg->MessageBody,
        sizeof(DNS_HEADER) );

    //  set for rewriting

    pMsg->pCurrent = pMsg->MessageBody;
    pMsg->pPreOptEnd = NULL;
}



//
//  Writing to packet
//

PCHAR
_fastcall
Dns_WriteDottedNameToPacket(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      LPSTR           pszName,
    IN      LPSTR           pszDomain,      OPTIONAL
    IN      WORD            wDomainOffset,  OPTIONAL
    IN      BOOL            fUnicodeName
    )
/*++

Routine Description:

    Write lookup name to packet.

Arguments:

    pch -- ptr to current position in packet buffer

    pchStop -- end of packet buffer

    pszName - dotted FQDN to write

    pszDomain - domain name already in packet (OPTIONAL);  note this is
        a fragment of the SAME STRING as pszName;  i.e. ptr compare
        NOT strcmp is done to determine if at domain name

    wDomainOffset - offset in packet of domain name;  MUST include this
        if pszDomain is given

    fUnicodeName -- pszName is unicode string
        TRUE -- name is unicode
        FALSE -- name is UTF8

Return Value:

    Ptr to next position in packet buffer.
    NULL on error.

--*/
{
    CHAR    ch;
    PCHAR   pchlabelStart;
    UCHAR   countLabel = 0;
    ULONG   countName = 0;
    PSTR    pnameWire;
    PWSTR   pnameUnicode;
    CHAR    nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    WCHAR   nameWideBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];


    //  protect message buffer overrun

    if ( pch >= pchStop )
    {
        return( NULL );
    }

    //  allow root to be indicated by NULL

    if ( !pszName )
    {
        *pch++ = 0;
        return( pch );
    }

    //
    //  protect stack buffers from bogus names
    //

    if ( fUnicodeName )
    {
        countName = wcslen( (LPWSTR) pszName );
    }
    else
    {
        countName = strlen( pszName );
    }
    if ( countName >= DNS_MAX_NAME_BUFFER_LENGTH )
    {
        return NULL;
    }
    countName = 0;

    //
    //  UTF8 name with extended chars?
    //      - then must go up to unicode for canonicalizing
    //
    //  DCR:  shouldn't be sending in un-canonical UTF8
    //      should
    //          - stay in unicode all the way
    //          - using canon unicode all the way
    //          - use canon wire names all the way
    //

    if ( !fUnicodeName )
    {
        if ( !Dns_IsStringAscii( pszName ) )
        {
            DWORD bufLength = DNS_MAX_NAME_BUFFER_LENGTH_UNICODE;

            if ( ! Dns_NameCopy(
                        (PCHAR) nameWideBuffer,
                        & bufLength,
                        pszName,
                        0,          // length unknown
                        DnsCharSetUtf8,
                        DnsCharSetUnicode
                        ) )
            {
                return( NULL );
            }
            if ( ! Dns_MakeCanonicalNameInPlaceW(
                        nameWideBuffer,
                        0 ) )
            {
                return( NULL );
            }
            pnameUnicode = (PWSTR) nameWideBuffer;
            fUnicodeName = TRUE;
        }
    }

    //
    //  unicode name -- if extended, canonicalize first
    //
    //  DCR_FIX0:  should functionalize -- raw unicode to wire
    //

    else
    {
        pnameUnicode = (PWSTR) pszName;

        if ( !Dns_IsWideStringAscii( pnameUnicode ) )
        {
            if ( ! Dns_MakeCanonicalNameW(
                        nameWideBuffer,
                        //DNS_MAX_NAME_BUFFER_LENGTH_UNICODE,
                        DNS_MAX_NAME_BUFFER_LENGTH,
                        pnameUnicode,
                        0 ) )
            {
                return  NULL;
            }
            pnameUnicode = nameWideBuffer;
        }
    }

    //
    //  convert unicode name to UTF8
    //      - if extended chars, then downcase before hit the wire
    //

    if ( fUnicodeName )
    {
        if ( ! Dns_NameCopyUnicodeToWire(
                    nameBuffer,
                    pnameUnicode ) )
        {
            return( NULL );
        }
        pnameWire = nameBuffer;
    }
    else
    {
        pnameWire = pszName;
    }

    //
    //  special case "." root name
    //      - allows us to fail all other zero length labels cleanly
    //

    if ( *pnameWire == '.' )
    {
        if ( *(pnameWire+1) != 0 )
        {
            return( NULL );
        }
        *pch++ = 0;
        return( pch );
    }

    //
    //  write lookup name
    //      - leave

    pchlabelStart = pch++;

    while( ch = *pnameWire++ )
    {
        //  out of space

        if ( pch >= pchStop )
        {
            return( NULL );
        }

        //  not at end of label -- just copy character

        if ( ch != '.' )
        {
            *pch++ = ch;
            countLabel++;
            countName++;
            continue;
        }

        //
        //  at end of label
        //      - write label count
        //      - reset counter
        //      - if reached domain name, write compression and quit
        //

        if ( countLabel > DNS_MAX_LABEL_LENGTH ||
             countLabel == 0 ||
             countName > DNS_MAX_NAME_LENGTH )
        {
            return( NULL );
        }
        *pchlabelStart = countLabel;
        countLabel = 0;
        countName++;
        pchlabelStart = pch++;

        if ( pnameWire == pszDomain )
        {
            if ( ++pch >= pchStop )
            {
                return( NULL );
            }
            *(UNALIGNED WORD *)pchlabelStart =
                    htons( (WORD)(wDomainOffset | (WORD)0xC000) );
            return( pch );
        }
    }

    if ( countLabel > DNS_MAX_LABEL_LENGTH ||
         countName > DNS_MAX_NAME_LENGTH )
    {
        return( NULL );
    }

    //
    //  NULL terminate
    //      - if no terminating ".", do end of label processing also
    //      - return ptr to char after terminating NULL

    if ( countLabel )
    {
        *pchlabelStart = countLabel;
        *pch++ = 0;
    }
    else
    {
        DNS_ASSERT( pch == pchlabelStart + 1 );
        *pchlabelStart = 0;
    }
    return( pch );
}



PCHAR
_fastcall
Dns_WriteStringToPacket(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PSTR            pszString,
    IN      BOOL            fUnicodeString
    )
/*++

Routine Description:

    Write string to packet.

Arguments:

    pch -- ptr to current position in packet buffer

    pchStop -- end of packet buffer

    pszString - string to write

    fUnicodeString -- pszString is unicode string

Return Value:

    Ptr to next position in packet buffer.
    NULL on error.

--*/
{
    DWORD    length;

    //
    //  handle NULL string
    //

    if ( !pszString )
    {
        if ( pch >= pchStop )
        {
            return( NULL );
        }
        *pch++ = 0;
        return( pch );
    }

    //
    //  get string length
    //      - get required buf length, then whack whack off space
    //      for terminating NULL
    //      - zero error case, becomes very large number and is
    //      caught by length>MAXCHAR test
    //

    length = Dns_GetBufferLengthForStringCopy(
                pszString,
                0,
                fUnicodeString ? DnsCharSetUnicode : DnsCharSetUtf8,
                DnsCharSetUtf8 );
    length--;

    //
    //  set length byte
    //

    if ( length > MAXUCHAR )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    *pch++ = (UCHAR) length;

    if ( pch + length > pchStop )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }

    //
    //  copy string
    //
    //  note unicode conversion will write NULL terminator, so
    //  test again for space in packet
    //

    if ( fUnicodeString )
    {
        if ( pch + length + 1 > pchStop )
        {
            SetLastError( ERROR_MORE_DATA );
            return( NULL );
        }
        Dns_StringCopy(
            pch,
            NULL,
            pszString,
            length,
            DnsCharSetUnicode,
            DnsCharSetUtf8 );
    }
    else
    {
        memcpy(
            pch,
            pszString,
            length );
    }

    return( pch+length );
}



PCHAR
Dns_WriteQuestionToMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PDNS_NAME       pszName,
    IN      WORD            wType,
    IN      BOOL            fUnicodeName
    )
/*++

Routine Description:

    Write question to packet.

    Note:  Routine DOES NOT clear message info or message header.
    This is optimized for use immediately following Dns_CreateMessage().

Arguments:

    pMsg - message info

    pszName - DNS name of question

    wType - question type

    fUnicodeName - name is in unicode

Return Value:

    Ptr to next char in buffer, if successful.
    NULL if error writing question name.

--*/
{
    PCHAR   pch;

    //  use recursion, as default

    pMsg->MessageHead.RecursionDesired = TRUE;

    //  restart write at message header

    pch = pMsg->MessageBody;

    //  write question name

    pch = Dns_WriteDottedNameToPacket(
                pch,
                pMsg->pBufferEnd,
                pszName,
                NULL,
                0,
                fUnicodeName );
    if ( !pch )
    {
        return( NULL );
    }

    //  write question structure

    *(UNALIGNED WORD *) pch = htons( wType );
    pch += sizeof(WORD);
    *(UNALIGNED WORD *) pch = DNS_RCLASS_INTERNET;
    pch += sizeof(WORD);

    //  set question RR section count

    pMsg->MessageHead.QuestionCount = 1;

    //  header fields in host order

    pMsg->fSwapped = FALSE;

    //  reset current ptr

    pMsg->pCurrent = pch;

    IF_DNSDBG( INIT )
    {
        DnsDbg_Message(
            "Packet after question write:",
            pMsg );
    }
    return( pch );
}



DNS_STATUS
Dns_WriteRecordStructureToMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      WORD            wType,
    IN      WORD            wClass,
    IN      DWORD           dwTtl,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    No data RR cases:

    This includes prereqs and deletes except for specific record cases.

Arguments:

    pch - ptr to next byte in packet buffer

    pchStop - end of packet buffer

    wClass - class

    wType - desired RR type

    dwTtl - time to live

    wDataLength - data length

Return Value:

    Ptr to next postion in buffer, if successful.
    NULL on error.

--*/
{
    PDNS_WIRE_RECORD    pdnsRR;
    PCHAR               pchdata;

    IF_DNSDBG( WRITE2 )
    {
        DNS_PRINT(( "Dns_WriteRecordStructureToMessage(%p).\n", pMsg ));
    }

    //
    //  out of space
    //

    pdnsRR = (PDNS_WIRE_RECORD) pMsg->pCurrent;
    pchdata = (PCHAR) pdnsRR + sizeof( DNS_WIRE_RECORD );

    if ( pchdata + wDataLength >= pMsg->pBufferEnd )
    {
        DNS_PRINT(( "ERROR  out of space writing record to packet.\n" ));
        return( ERROR_MORE_DATA );
    }

    //
    //  write RR wire structure
    //

    *(UNALIGNED WORD *) &pdnsRR->RecordType  = htons( wType );
    *(UNALIGNED WORD *) &pdnsRR->RecordClass = htons( wClass );
    *(UNALIGNED DWORD *) &pdnsRR->TimeToLive = htonl( dwTtl );
    *(UNALIGNED WORD *) &pdnsRR->DataLength  = htons( wDataLength );

    //
    //  update current ptr
    //

    pMsg->pCurrent = pchdata;

    return( ERROR_SUCCESS );
}



DNS_STATUS
Dns_WriteRecordStructureToPacket(
    IN OUT  PCHAR           pchBuf,
    IN      PDNS_RECORD     pRecord,
    IN      BOOL            fUpdatePacket
    )
/*++

Routine Description:

    Write wire record structure for given record.

Arguments:

    pchBuf - ptr to next byte in packet buffer

    pRecord - record to write

    fUpdatePacket -- TRUE if building update message;
        for update the section flags in the pRecords are interpreted
        for update;  otherwise query semantics are used

Return Value:

    None

--*/
{
    PDNS_WIRE_RECORD    pwireRecord;
    WORD                class;
    DWORD               ttl;

    IF_DNSDBG( WRITE2 )
    {
        DNS_PRINT((
            "Writing RR struct (%p) to packet buffer at %p.\n",
            pRecord,
            pchBuf
            ));
        DnsDbg_Record(
            "Record being written:",
            pRecord );
    }

    //
    //  get TTL, it will be set to zero for several of the update cases
    //

    ttl = pRecord->dwTtl;

    //
    //  determine class
    //      - class variable is in net order (for perf)
    //      - default is class IN, but may be ANY or NONE for certain updates
    //

    if ( fUpdatePacket )
    {
        switch( pRecord->Flags.S.Section )
        {
        case DNSREC_PREREQ:

            class = PrereqClassArray
                    [ pRecord->wDataLength == 0 ][ pRecord->Flags.S.Delete ];
            ttl = 0;
            break;

        case DNSREC_UPDATE:
        case DNSREC_ADDITIONAL:

            class = UpdateClassArray
                    [ pRecord->wDataLength == 0 ][ pRecord->Flags.S.Delete ];

            if ( class != DNS_RCLASS_INTERNET )
            {
                ttl = 0;
            }
            break;

        default:
            DNS_PRINT(( "ERROR:  invalid RR section.\n" ));
            return( ERROR_INVALID_DATA );
        }
        if ( class == 0 )
        {
            DNS_PRINT(( "ERROR:  no update class corresponding to RR flags.\n" ));
            return( ERROR_INVALID_DATA );
        }
    }
    else
    {
        class = DNS_RCLASS_INTERNET;
    }

    //
    //  write RR wire structure
    //      - zero datalength to handle no data case
    //

    pwireRecord = (PDNS_WIRE_RECORD) pchBuf;

    *(UNALIGNED WORD *) &pwireRecord->RecordType  = htons( pRecord->wType );
    *(UNALIGNED WORD *) &pwireRecord->RecordClass = class;
    *(UNALIGNED DWORD *) &pwireRecord->TimeToLive = htonl( ttl );
    *(UNALIGNED WORD *) &pwireRecord->DataLength = 0;

    return( ERROR_SUCCESS );
}



PCHAR
Dns_WriteRecordStructureToPacketEx(
    IN OUT  PCHAR           pchBuf,
    IN      WORD            wType,
    IN      WORD            wClass,
    IN      DWORD           dwTtl,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Write wire record structure for given record.

Arguments:

    pchBuf - ptr to next byte in packet buffer

Return Value:

    Ptr to data section of record.

--*/
{
    PDNS_WIRE_RECORD    pwireRecord;

    //  DCR_PERF:  optimize RR write to packet?

    pwireRecord = (PDNS_WIRE_RECORD) pchBuf;

    *(UNALIGNED WORD *) &pwireRecord->RecordType  = htons( wType );
    *(UNALIGNED WORD *) &pwireRecord->RecordClass = htons( wClass );
    *(UNALIGNED DWORD *) &pwireRecord->TimeToLive = htonl( dwTtl );
    *(UNALIGNED WORD *) &pwireRecord->DataLength  = htons( wDataLength );

    return( pchBuf + sizeof(DNS_WIRE_RECORD) );
}



VOID
Dns_SetRecordDatalength(
    IN OUT  PDNS_WIRE_RECORD    pRecord,
    IN      WORD                wDataLength
    )
/*++

Routine Description:

    Reset record datalength.

Arguments:

    pRecord - wire record to reset

    wDataLength - data length

Return Value:

    Ptr to data section of record.

--*/
{
    WORD  flippedWord;

    INLINE_WORD_FLIP( flippedWord, wDataLength );

    *(UNALIGNED WORD *) &pRecord->DataLength = flippedWord;
}



DNS_STATUS
Dns_WriteOptToMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      WORD            wPayload,
    IN      DWORD           Rcode,
    IN      BYTE            Version,
    IN      PBYTE           pData,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Write OPT record to message.

Arguments:

    pMsg        -- message

    wPayload    -- max length client can receive in UDP

    Rcode       -- RCODE, if extended some of this ends up in OPT

    Version     -- EDNS version

    pData       -- ptr to data buffer of OPT data

    wDataLength -- length of pData

Return Value:

    ERROR_SUCCESS if successfully writen.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status;
    PCHAR       pstart;

    //
    //  DCR:  use variable OPT fields
    //

    //
    //  save existing pCurrent
    //      - this allows dual wire write
    //

    ASSERT( !pMsg->pPreOptEnd );

    pstart = pMsg->pCurrent;

    //
    //  write OPT record name (root)
    //

    *pstart = 0;
    pMsg->pCurrent++;

    //
    //  write OPT -- basic info, no options
    //      - if OPT didn't fit, clear pPreOptEnd pointer
    //      which serves as signal that OPT exists
    //

    status = Dns_WriteRecordStructureToMessage(
                    pMsg,
                    DNS_TYPE_OPT,
                    (WORD) g_RecvBufSize,   //  recv buffer size (in Class)
                    0,                      //  no flags\extended RCODE (in TTL)
                    0                       //  no data length
                    );

    if ( status == ERROR_SUCCESS )
    {
        //  increment message record count

        SET_TO_WRITE_ADDITIONAL_RECORDS(pMsg);
        CURRENT_RR_COUNT_FIELD(pMsg)++;

        pMsg->pPreOptEnd = pstart;
    }
    else
    {
        //  on failure, reset current

        pMsg->pCurrent = pstart;
    }

    return( status );
}



DNS_STATUS
Dns_WriteStandardRequestOptToMessage(
    IN OUT  PDNS_MSG_BUF    pMsg
    )
/*++

Routine Description:

    Write standard OPT record to message.

    This contains just the buffer size and version info,
    no error code or options.

Arguments:

    pMsg -- message

Return Value:

    ERROR_SUCCESS if successfully writen.
    ErrorCode on failure.

--*/
{
    if ( g_UseEdns == 0 )
    {
        return( ERROR_REQUEST_REFUSED );
    }

    return  Dns_WriteOptToMessage(
                pMsg,
                (WORD) g_RecvBufSize,
                0,              // no rcode
                0,              // standard version
                NULL,           // no data
                0               // no data length
                );
}



DNS_STATUS
Dns_AddRecordsToMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PDNS_RECORD     pRecord,
    IN      BOOL            fUpdateMessage
    )
/*++

Routine Description:

    Add record or list of records to message.No data RR cases:

    This includes prereqs and deletes except for specific record cases.

Arguments:

    pMsg - message buffer to write to

    pRecord - ptr to record (or first of list of records) to write to packet

    fUpdateMessage -- If TRUE, the message is going to contain an update.
                      Therefore the section flags in the pRecord
                      should be interpreted for update. Otherwise this is
                      for a query message and section flags should be
                      interpreted for query.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PCHAR               pch = pMsg->pCurrent;
    PCHAR               pendBuffer = pMsg->pBufferEnd;
    WORD                currentSection = 0;
    WORD                section;
    PDNS_NAME           pnamePrevious = NULL;
    WORD                compressedPreviousName;
    WORD                offsetPreviousName;
    PDNS_WIRE_RECORD    pwireRecord;
    PCHAR               pchnext;
    WORD                index;
    DNS_STATUS          status = ERROR_SUCCESS;

    //
    //  write each record in list
    //

    while ( pRecord )
    {
        //
        //  determine section for record
        //      - may not write to previous section

        section = (WORD) pRecord->Flags.S.Section;
        if ( section < currentSection )
        {
            DNS_PRINT((
                "ERROR:  Attempt to write record at %p, with section %d\n"
                "\tless than previous section written %d.\n",
                pRecord,
                pRecord->Flags.S.Section,
                currentSection ));
            return( ERROR_INVALID_DATA );
        }
        else if ( section > currentSection )
        {
            currentSection = section;
            SET_CURRENT_RR_COUNT_SECTION( pMsg, section );
        }

        //
        //  write record name
        //      - if same as previous, write compressed name
        //      - if first write from pRecord
        //          - write full name
        //          - clear reserved field for offsetting
        //

        if ( pnamePrevious && !strcmp( pnamePrevious, pRecord->pName ) )
        {
            //  compression should always be BACK ptr

            DNS_ASSERT( offsetPreviousName < pch - (PCHAR)&pMsg->MessageHead );

            if ( pendBuffer <= pch + sizeof(WORD) )
            {
                return( ERROR_MORE_DATA );
            }
            if ( ! compressedPreviousName )
            {
                compressedPreviousName =
                                htons( (WORD)(0xC000 | offsetPreviousName) );
            }
            *(UNALIGNED WORD *)pch = compressedPreviousName;
            pch += sizeof( WORD );
        }
        else
        {
            offsetPreviousName = (WORD)(pch - (PCHAR)&pMsg->MessageHead);
            compressedPreviousName = 0;
            pnamePrevious = pRecord->pName;

            pch = Dns_WriteDottedNameToPacket(
                    pch,
                    pendBuffer,
                    pnamePrevious,
                    NULL,
                    0,
                    ( RECORD_CHARSET(pRecord) == DnsCharSetUnicode ) );

            if ( !pch )
            {
                //  DCR:  distinguish out of space errors from name errors during write
                return( DNS_ERROR_INVALID_NAME );
            }
        }

        //
        //  write record structure
        //

        if ( pch + sizeof(DNS_WIRE_RECORD) >= pendBuffer )
        {
            return( ERROR_MORE_DATA );
        }

        status = Dns_WriteRecordStructureToPacket(
                    pch,
                    pRecord,
                    fUpdateMessage );
        if ( status != ERROR_SUCCESS )
        {
            return( status );
        }

        pwireRecord = (PDNS_WIRE_RECORD) pch;
        pch += sizeof( DNS_WIRE_RECORD );

        //
        //  record data
        //

        if ( pRecord->wDataLength )
        {
            index = INDEX_FOR_TYPE( pRecord->wType );
            DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

            if ( index && RRWriteTable[ index ] )
            {
                pchnext = RRWriteTable[ index ](
                                pRecord,
                                pch,
                                pendBuffer
                                );
                if ( ! pchnext )
                {
                    status = GetLastError();
                    DNS_PRINT((
                        "ERROR:  Record write routine failure for record type %d.\n\n"
                        "\tstatus = %d\n",
                        pRecord->wType,
                        status ));
                    return( status );
                }
            }
            else
            {
                //  write unknown types -- as RAW data only

                DNS_PRINT((
                    "WARNING:  Writing unknown type %d to message\n",
                    pRecord->wType ));

                if ( pendBuffer - pch <= pRecord->wDataLength )
                {
                    return( ERROR_MORE_DATA );
                }
                memcpy(
                    pch,
                    (PCHAR) &pRecord->Data,
                    pRecord->wDataLength );
                pchnext = pch + pRecord->wDataLength;
            }

            //
            //  set packet record data length
            //

            DNS_ASSERT( (pchnext - pch) < MAXWORD );
            *(UNALIGNED WORD *) &pwireRecord->DataLength =
                                                htons( (WORD)(pchnext - pch) );
            pch = pchnext;
        }

        //  increment message record count

        CURRENT_RR_COUNT_FIELD(pMsg)++;

        pRecord = pRecord->pNext;
    }

    //
    //  resest message current ptr
    //

    pMsg->pCurrent = pch;

    IF_DNSDBG( INIT )
    {
        DnsDbg_Message(
            "Packet after adding records:",
            pMsg );
    }

    return( status );
}



PDNS_MSG_BUF
Dns_BuildPacket(
    IN      PDNS_HEADER     pHeader,
    IN      BOOL            fNoHeaderCounts,
    IN      LPSTR           pszQuestionName,
    IN      WORD            wQuestionType,
    IN      PDNS_RECORD     pRecords,
    IN      DWORD           dwFlags,
    IN      BOOL            fUpdatePacket
    )
/*++

Routine Description:

    Build packet.

Arguments:

    pHeader -- DNS header to send

    fNoHeaderCounts - do NOT include record counts in copying header

    pszName -- DNS name to query

    wType -- query type

    pRecords -- address to receive ptr to record list returned from query

    dwFlags -- query flags

    fUpdatePacket -- If TRUE, the packet is going to contain an update.
                     Therefore the section flags in the pRecords
                     should be interpreted for update. Otherwise this is
                     for a query and section flags will be interpreted for
                     query.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PDNS_MSG_BUF    pmsg;
    DWORD           length;
    DNS_STATUS      status;

    DNSDBG( WRITE, (
        "Dns_BuildPacket()\n"
        "\tname          %s\n"
        "\ttype          %d\n"
        "\theader        %p\n"
        "\t - counts     %d\n"
        "\trecords       %p\n"
        "\tflags         %08x\n"
        "\tfUpdatePacket %d\n",
        pszQuestionName,
        wQuestionType,
        pHeader,
        fNoHeaderCounts,
        pRecords,
        dwFlags,
        fUpdatePacket ));

    //
    //  allocate packet
    //      - if just a question, standard UDP will do it
    //      - if contains records, then use TCP buffer
    //

    length = 0;
    if ( pRecords )
    {
        length = DNS_TCP_DEFAULT_PACKET_LENGTH;
    }
    pmsg = Dns_AllocateMsgBuf( (WORD)length );
    if ( !pmsg )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Failed;
    }

    //
    //  write question?
    //

    if ( pszQuestionName )
    {
        if ( ! Dns_WriteQuestionToMessage(
                    pmsg,
                    pszQuestionName,
                    wQuestionType,
                    (BOOL)!!(dwFlags & DNSQUERY_UNICODE_NAME)
                    ) )
        {
            status = ERROR_INVALID_NAME;
            goto Failed;
        }
    }

    //
    //  build packet records
    //

    if ( pRecords )
    {
        status = Dns_AddRecordsToMessage(
                    pmsg,
                    pRecords,
                    fUpdatePacket );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR:  failure writing records to message.\n" ));
            goto Failed;
        }
    }

    //
    //  append standard request OPT -- if possible
    //
    //  DCR:  currently no OPT for update
    //

    if ( !fUpdatePacket )
    {
        Dns_WriteStandardRequestOptToMessage( pmsg );
    }

    //
    //  overwrite header?
    //

    if ( pHeader )
    {
        length = sizeof(DNS_HEADER);
        if ( fNoHeaderCounts )
        {
            length = sizeof(DWORD);
        }
        RtlCopyMemory(
            & pmsg->MessageHead,
            pHeader,
            length );
    }

    //  override recursion default, if desired

    if ( dwFlags & DNS_QUERY_NO_RECURSION )
    {
        pmsg->MessageHead.RecursionDesired = FALSE;
    }

    //  init XID if not set

    if ( pmsg->MessageHead.Xid == 0 )
    {
        pmsg->MessageHead.Xid = gwTransactionId++;
    }

    return( pmsg );

Failed:

    SetLastError( status );
    FREE_HEAP( pmsg );
    return( NULL );
}



//
//  Reading from packet
//

PCHAR
_fastcall
Dns_SkipPacketName(
    IN      PCHAR       pch,
    IN      PCHAR       pchEnd
    )
/*++

Routine Description:

    Skips over name in packet

Arguments:

    pch - ptr to start of name to skip

    pchEnd - ptr to byte after end of packet

Return Value:

    Ptr to next byte in buffer
    NULL if bad name

--*/
{
    register UCHAR  cch;
    register UCHAR  cflag;

    //
    //  Loop until end of name
    //

    while ( pch < pchEnd )
    {
        cch = *pch++;
        cflag = cch & 0xC0;

        //
        //  normal label
        //      - skip to next label and continue
        //      - stop only if at 0 (root) label
        //

        if ( cflag == 0 )
        {
            if ( cch )
            {
                pch += cch;
                continue;
            }
            return( pch );
        }

        //
        //  compression
        //      - skip second byte in compression and return
        //

        else if ( cflag == 0xC0 )
        {
            pch++;
            return( pch );
        }
        else
        {
            DNSDBG( READ, (
                "ERROR:  bad packet name label byte %02 at 0x%p\n",
                cch,
                pch - 1 ));

            return( NULL );
        }
    }

    DNSDBG( READ, (
        "ERROR:  packet name at %p reads past end of packet at %p\n",
        pch,
        pchEnd ));

    return( NULL );
}



BOOL
Dns_IsSamePacketQuestion(
    IN      PDNS_MSG_BUF    pMsg1,
    IN      PDNS_MSG_BUF    pMsg2
    )
/*++

Routine Description:

    Compares questions in two messages.

Arguments:

    pMsg1 -- first message

    pMsg2 -- second message

Return Value:

    TRUE if message questions equal.
    FALSE if questions not equal.

--*/
{
    PCHAR   pquestion1;
    PCHAR   pquestion2;
    PCHAR   pnameEnd;
    DWORD   questionLength;

    //
    //  validate and size the question fields
    //      - size must match
    //

    pquestion1 = pMsg1->MessageBody;

    pnameEnd = Dns_SkipPacketName(
                    pquestion1,
                    pMsg1->pBufferEnd );
    if ( !pnameEnd )
    {
        return  FALSE;
    }
    questionLength = (DWORD)( pnameEnd - pquestion1 );

    pquestion2 = pMsg2->MessageBody;

    pnameEnd = Dns_SkipPacketName(
                    pquestion2,
                    pMsg2->pBufferEnd );

    if ( !pnameEnd ||
         questionLength != (DWORD)(pnameEnd - pquestion2) )
    {
        return  FALSE;
    }

    //
    //  for speed, first do flat mem compare
    //      - this will hit 99% case as rarely would
    //      a server rewrite the question name
    //

    if ( RtlEqualMemory(
            pquestion1,
            pquestion2,
            questionLength ) )
    {
        return  TRUE;
    }

    //
    //  then do case sensitive compare
    //      - note, we do simple ANSI casing
    //      assume UTF8 extended chars MUST be downcased on the
    //      wire per spec
    //

    return  !_strnicmp( pquestion1, pquestion2, questionLength );
}



PCHAR
_fastcall
Dns_SkipPacketRecord(
    IN      PCHAR           pchRecord,
    IN      PCHAR           pchMsgEnd
    )
/*++

Routine Description:

    Skips over packet RR.
    This is RR structure and data, not the owner name.

Arguments:

    pchRecord - ptr to start of RR structure.

    pchMsgEnd - end of message

Return Value:

    Ptr to next record in packet.
    NULL if RR outside packet or invalid.

--*/
{
    //
    //  skip RR struct
    //

    pchRecord += sizeof(DNS_WIRE_RECORD);
    if ( pchRecord > pchMsgEnd )
    {
        return( NULL );
    }

    //  read datalength and skip data
    //  datalength field is a WORD, at end of record header

    pchRecord += InlineFlipUnalignedWord( pchRecord - sizeof(WORD) );

    if ( pchRecord > pchMsgEnd )
    {
        return( NULL );
    }

    return( pchRecord );
}



PCHAR
Dns_SkipToRecord(
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgEnd,
    IN      INT             iCount
    )
/*++

Routine Description:

    Skips over some number of DNS records.

Arguments:

    pMsgHead    -- ptr to begining of DNS message.

    pMsgEnd     -- ptr to end of DNS message

    iCount      -- if > 0, number of records to skip
                    if <= 0, number of records from end of packet

Return Value:

    Ptr to next
    NULL if bad packet.

--*/
{
    PCHAR   pch;
    INT     i;
    WORD    recordCount;

    //
    //  determine how many records to skip
    //

    recordCount = pMsgHead->QuestionCount
                + pMsgHead->AnswerCount
                + pMsgHead->NameServerCount
                + pMsgHead->AdditionalCount;

    //  iCount > 0 is skip count, MUST not be larger than
    //      actual count

    if ( iCount > 0 )
    {
        if ( iCount > recordCount )
        {
            return( NULL );
        }
    }

    //  iCount <= 0 then (-iCount) is number of records
    //  from the last record

    else
    {
        iCount += recordCount;
        if ( iCount < 0 )
        {
            return( NULL );
        }
    }

    //  skip message header

    pch = (PCHAR) (pMsgHead + 1);
    if ( iCount == 0 )
    {
        return( pch );
    }

    //
    //  skip records
    //

    for ( i=0; i<iCount; i++ )
    {
        pch = Dns_SkipPacketName( pch, pMsgEnd );
        if ( !pch )
        {
            return pch;
        }

        //  skip question or RR

        if ( i < pMsgHead->QuestionCount )
        {
            pch += sizeof(DNS_WIRE_QUESTION);
            if ( pch > pMsgEnd )
            {
                return( NULL );
            }
        }
        else
        {
            pch = Dns_SkipPacketRecord( pch, pMsgEnd );
            if ( !pch )
            {
                return pch;
            }
        }
    }

    DNSDBG( READ, (
        "Leaving SkipToRecord, current ptr = %p, offset = %04x\n"
        "\tskipped %d records\n",
        pch,
        (WORD) (pch - (PCHAR)pMsgHead),
        iCount ));

    return( pch );
}



PCHAR
_fastcall
Dns_ReadPacketName(
    IN OUT  PCHAR       pchNameBuffer,
    OUT     PWORD       pwNameLength,
    IN OUT  PWORD       pwNameOffset,           OPTIONAL
    OUT     PBOOL       pfNameSameAsPrevious,   OPTIONAL
    IN      PCHAR       pchName,
    IN      PCHAR       pchStart,
    IN      PCHAR       pchEnd
    )
/*++

Routine Description:

    Reads packet name and converts it to DNS-dotted format.

Arguments:

    pchNameBuffer - buffer to write name into;  contains previous name, if any

    pwNameLength - length of name written to buffer;  does not include
        terminating NULL

    pwNameOffset - addr with previous names offset (zero if no previous name);
        on return, contains this name's offset
        OPTIONAL but must exist if fNameSameAsPrevious exists

    pfNameSameAsPrevious - addr of flag set if this name is same as previous;
        OPTIONAL but must exist if pwNameOffset exists

    pchName  - ptr to name in packet

    pchStart - start of DNS message

    pchEnd   - ptr to byte after end of DNS message

Return Value:

    Ptr to next byte in packet.
    NULL on error.

--*/
{
    register PUCHAR pch = pchName;
    register UCHAR  cch;
    register UCHAR  cflag;
    PCHAR           pchdotted;
    PCHAR           pbufferEnd;
    PCHAR           pchreturn = NULL;

    DNS_ASSERT( pch > pchStart && pchEnd > pchStart );
    DNS_ASSERT( (pwNameOffset && pfNameSameAsPrevious) ||
            (!pwNameOffset && !pfNameSameAsPrevious) );


    //
    //  read through labels and/or compression until reach end of name
    //

    pbufferEnd = pchNameBuffer + DNS_MAX_NAME_LENGTH;
    pchdotted = pchNameBuffer;

    while ( pch < pchEnd )
    {
        cch = *pch++;

        //
        //  at root label
        //      - if root name, write single '.'
        //      - otherwise strip trailing dot from last label
        //      - save length written
        //      - NULL teminate name
        //      - set same as previous FALSE
        //      - save packet offset to this name
        //      - return next byte in buffer
        //

        if ( cch == 0 )
        {
            if ( pchdotted == pchNameBuffer )
            {
                *pchdotted++ = '.';
            }
            else
            {
                pchdotted--;
            }
            *pwNameLength = (WORD)(pchdotted - pchNameBuffer);
            *pchdotted = 0;
            if ( pwNameOffset )
            {
                *pfNameSameAsPrevious = FALSE;
                *pwNameOffset = (WORD)(pchName - pchStart);
            }
            return( pchreturn ? pchreturn : pch );
        }

        cflag = cch & 0xC0;

        //
        //  regular label
        //      - copy label to buffer
        //      - jump to next label

        if ( cflag == 0 )
        {
            PCHAR   pchnext = pch + cch;

            if ( pchnext >= pchEnd )
            {
                DNS_PRINT((
                    "ERROR:  Packet name at %p extends past end of buffer\n",
                    pchName ));
                goto Failed;
            }
            if ( pchdotted + cch + 1 >= pbufferEnd )
            {
                DNS_PRINT((
                    "ERROR:  Packet name at %p exceeds max length\n",
                    pchName ));
                goto Failed;
            }
            memcpy(
                pchdotted,
                pch,
                cch );

            pchdotted += cch;
            *pchdotted++ = '.';
            pch = pchnext;
            continue;
        }

        //
        //  offset
        //      - get offset
        //      - if offset at start of name compare to previous name offset
        //      - otherwise follow offset to build new name
        //

        if ( cflag == 0xC0 )
        {
            WORD    offset;
            PCHAR   pchoffset;

            offset = (cch ^ 0xC0);
            offset <<= 8;
            offset |= *pch;
            pchoffset = --pch;

            //
            //  first offset
            //      - save return pointer
            //
            //  if name is entirely offset
            //      - same as previous offset -- done
            //      - if not still save this offset rather than offset
            //      to name itself (first answer is usually just offset
            //      to question, subsequent answer RRs continue to reference
            //      question offset, not first answer)
            //

            if ( !pchreturn )
            {
                DNS_ASSERT( pch >= pchName );
                pchreturn = pch+2;

                if ( pchoffset == pchName && pwNameOffset )
                {
                    if ( *pwNameOffset == offset )
                    {
                        *pfNameSameAsPrevious = TRUE;
                        return( pchreturn );
                    }
                    else
                    {
                        //  save offset that comprises name
                        //  then kill out copy of return ptr so don't
                        //  return offset to pchName when finish copy

                        *pwNameOffset = offset;
                        *pfNameSameAsPrevious = FALSE;
                        pwNameOffset = NULL;
                    }
                }
            }

            //
            //  make jump to new bytes and continue
            //      - verify offset is BEFORE current name
            //          and BEFORE current ptr

            pch = pchStart + offset;

            if ( pch >= pchName || pch >= pchoffset )
            {
                DNS_PRINT((
                    "ERROR:  Bogus name offset %d, encountered at %p\n"
                    "\tto location %p past current position or original name.\n",
                    offset,
                    pchoffset,
                    pch ));
                goto Failed;
            }
            continue;
        }

        //  any other label byte is bogus

        else
        {
            DNS_PRINT((
                "ERROR:  bogus name label byte %02x at %p\n",
                cch,
                pch - 1 ));
            goto Failed;
        }
    }

    DNS_PRINT((
        "ERROR:  packet name at %p reads to ptr %p past end of packet at %p\n",
        pchName,
        pch,
        pchEnd ));

    //
    //  failed
    //      - return NULL
    //      - set OUT params, keeps prefix happy on higher level calls
    //

Failed:

    *pwNameLength = 0;
    if ( pwNameOffset )
    {
        *pwNameOffset = 0;
    }
    if ( pfNameSameAsPrevious )
    {
        *pfNameSameAsPrevious = FALSE;
    }
    return ( NULL );
}



PCHAR
_fastcall
Dns_ReadPacketNameAllocate(
    IN OUT  PCHAR *         ppchName,
    OUT     PWORD           pwNameLength,
    IN OUT  PWORD           pwPrevNameOffset,       OPTIONAL
    OUT     PBOOL           pfNameSameAsPrevious,   OPTIONAL
    IN      PCHAR           pchPacketName,
    IN      PCHAR           pchStart,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Reads packet name and creates (allocates) a copy in DNS-dotted format.

Arguments:

    ppchName - addr to recv resulting name ptr

    pwNameLength - length of name written to buffer

    pwNameOffset - addr with previous names offset (zero if no previous name);
        on return, contains this name's offset
        OPTIONAL but must exist if fNameSameAsPrevious exists

    fNameSameAsPrevious - addr of flag set if this name is same as previous;
        OPTIONAL but must exist if pwNameOffset exists

    pchPacketName - pch to name in packet

    pchStart - start of DNS message

    pchEnd - ptr to byte after end of DNS message

Return Value:

    Ptr to next byte in packet.
    NULL on error.

--*/
{
    PCHAR   pch;
    PCHAR   pallocName;
    CHAR    nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    WORD    nameLength = DNS_MAX_NAME_BUFFER_LENGTH;

    //
    //  read packet name into buffer
    //

    pch = Dns_ReadPacketName(
            nameBuffer,
            & nameLength,
            pwPrevNameOffset,
            pfNameSameAsPrevious,
            pchPacketName,
            pchStart,
            pchEnd );
    if ( !pch )
    {
        return( pch );
    }

    //
    //  allocate buffer for packet name
    //      - nameLength does not include terminating NULL
    //

    nameLength++;
    pallocName = (PCHAR) ALLOCATE_HEAP( nameLength );
    if ( !pallocName )
    {
        return( NULL );
    }

    RtlCopyMemory(
        pallocName,
        nameBuffer,
        nameLength );

    *ppchName = pallocName;
    *pwNameLength = --nameLength;

    DNSDBG( READ, (
        "Allocated copy of packet name %s length %d\n",
        pallocName,
        nameLength ));

    return( pch );
}



DNS_STATUS
Dns_ExtractRecordsFromMessage(
    IN      PDNS_MSG_BUF    pMsg,
    IN      BOOL            fUnicode,
    OUT     PDNS_RECORD *   ppRecord
    )
/*++

Routine Description:

    Extract records from packet.

Arguments:

    pMsg - message buffer to write to

    fUnicode - flag indicating strings in record should be unicode

Return Value:

    Ptr to parsed record list if any.
    NULL if no record list or error.

--*/
{
    PDNS_MESSAGE_BUFFER pDnsBuffer = (PDNS_MESSAGE_BUFFER) &pMsg->MessageHead;

    return Dns_ExtractRecordsFromBuffer(
                pDnsBuffer,
                pMsg->MessageLength,
                fUnicode,
                ppRecord );
}



DNS_STATUS
Dns_ParseMessage(
    OUT     PDNS_PARSED_MESSAGE pParse,
    IN      PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN      WORD                wMessageLength,
    IN      DWORD               Flags,
    IN      DNS_CHARSET         OutCharSet
    )
/*++

Routine Description:

    Parse DNS message.

Arguments:

    pParse - ptr to blob to receive parsed message

    pDnsBuffer - message buffer to read from

    wMessageLength -- message length

    Flags - parsing options

    OutCharSet - DNS character set;  only UTF8 and unicode supported

Return Value:

    RCODE error status on successful parse (including NO_ERROR)
    DNS_INFO_NO_RECORDS -- on auth-empty response
    //  referral
    DNS_ERROR_BAD_PACKET -- on bad packet

    Note:  even on failure caller must free data

--*/
{
    register PCHAR      pch;
    PDNS_HEADER         pwireMsg = (PDNS_HEADER) pDnsBuffer;
    PCHAR               pchpacketEnd;
    DNS_PARSED_RR       parsedRR;
    LPSTR               pnameOwner;
    LPSTR               pnameNew = NULL;
    PWORD               pCurrentCountField = NULL;
    WORD                countRR;
    WORD                countSection;
    WORD                typePrevious = 0;
    WORD                nameOffset = 0;
    WORD                nameLength;
    WORD                type;
    WORD                index;
    BYTE                section;
    BOOL                fnameSameAsPrevious;
    PDNS_RECORD         pnewRR;
    DNS_RRSET           rrset;
    DNS_RRSET           rrsetAlias;
    DNS_RRSET           rrsetSig;
    DNS_STATUS          status;
    DNS_STATUS          rcodeStatus;
    CHAR                nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    DNS_RECORD          recordTemp;

    DNSDBG( READ, (
        "Dns_ParseMessage( %p, len=%d )\n",
        pDnsBuffer,
        wMessageLength
        ));

    //
    //  clear parsing blob
    //

    RtlZeroMemory(
        pParse,
        sizeof(DNS_PARSED_MESSAGE) );

    //
    //  only UTF8 or unicode is supported directly
    //

    if ( OutCharSet != DnsCharSetUnicode &&
         OutCharSet != DnsCharSetUtf8 )
    {
        ASSERT( FALSE );
        return( ERROR_INVALID_PARAMETER );
    }

    //
    //  error code
    //      - map RCODE to DNS error
    //      - if other than NAME_ERROR, don't bother parsing
    //
    //  DCR:  option to parse with other errors
    //

    rcodeStatus = pwireMsg->ResponseCode;
    if ( rcodeStatus != 0 )
    {
        rcodeStatus = Dns_MapRcodeToStatus( pwireMsg->ResponseCode );

        if ( rcodeStatus != DNS_ERROR_RCODE_NAME_ERROR  &&
             !(Flags & DNS_PARSE_FLAG_RCODE_ALL) )
        {
            DNSDBG( READ, (
                "No records extracted from response\n"
                "\tresponse code = %d\n",
                pwireMsg->ResponseCode ));
            return( rcodeStatus );
        }
    }

    //
    //  clear record holders
    //      - do now so safe in bad packet cleanup
    //

    DNS_RRSET_INIT( rrset );
    DNS_RRSET_INIT( rrsetAlias );
    DNS_RRSET_INIT( rrsetSig );

    //
    //  copy message header
    //

    RtlCopyMemory(
        & pParse->Header,
        pwireMsg,
        sizeof(DNS_HEADER) );

    //
    //  read RRs in list of records
    //
    //  loop through all resource records
    //      - skip question
    //      - build DNS_RECORD structure for other records
    //

    pchpacketEnd = (PCHAR)pwireMsg + wMessageLength;
    pch = pDnsBuffer->MessageBody;

    section = DNSREC_QUESTION;
    pCurrentCountField = &pwireMsg->QuestionCount;
    countSection = pwireMsg->QuestionCount;
    countRR = 0;

    while( 1 )
    {
        //
        //  changing sections
        //  save section number and RR count for current section
        //  note need immediate loop back to handle empty section
        //

        countRR++;
        if ( countRR > countSection )
        {
            if ( section == DNSREC_QUESTION )
            {
                // no-op
            }
            else if ( section == DNSREC_ANSWER )
            {
                pParse->pAnswerRecords = rrset.pFirstRR;
            }
            else if ( section == DNSREC_AUTHORITY )
            {
                pParse->pAuthorityRecords = rrset.pFirstRR;
            }
            else if ( section == DNSREC_ADDITIONAL )
            {
                pParse->pAdditionalRecords = rrset.pFirstRR;
                break;
            }
            section++;
            pCurrentCountField++;
            countSection = *(pCurrentCountField);
            countRR = 0;
            typePrevious = 0;       // force new RR set
            DNS_RRSET_INIT( rrset );
            continue;
        }

        //  validity check next RR

        if ( pch >= pchpacketEnd )
        {
            DNS_PRINT((
                "ERROR:  reading bad packet %p.\n"
                "\tat end of packet length with more records to process\n"
                "\tpacket length = %ld\n"
                "\tcurrent offset = %ld\n",
                wMessageLength,
                pch - (PCHAR)pwireMsg
                ));
            goto PacketError;
        }

        //
        //  read name, determining if same as previous name
        //

        IF_DNSDBG( READ2 )
        {
            DnsDbg_Lock();
            DNS_PRINT((
                "Reading record at offset %x\n",
                (WORD)(pch - (PCHAR)pwireMsg) ));

            DnsDbg_PacketName(
                "Record name ",
                pch,
                pwireMsg,
                pchpacketEnd,
                "\n" );
            DnsDbg_Unlock();
        }
        pch = Dns_ReadPacketName(
                    nameBuffer,
                    & nameLength,
                    & nameOffset,
                    & fnameSameAsPrevious,
                    pch,
                    (PCHAR) pwireMsg,
                    pchpacketEnd );
        if ( ! pch )
        {
            DNS_PRINT(( "ERROR:  bad packet name.\n" ));
            goto PacketError;
        }
        IF_DNSDBG( READ2 )
        {
            DNS_PRINT((
                "Owner name of record %s\n"
                "\tlength = %d\n"
                "\toffset = %d\n"
                "\tfSameAsPrevious = %d\n",
                nameBuffer,
                nameLength,
                nameOffset,
                fnameSameAsPrevious ));
        }

        //
        //  question
        //

        if ( section == DNSREC_QUESTION )
        {
            PSTR pnameQuestion = NULL;

            if ( !(Flags & DNS_PARSE_FLAG_NO_QUESTION) )
            {
                pnameQuestion = Dns_NameCopyAllocate(
                                        nameBuffer,
                                        (UCHAR) nameLength,
                                        DnsCharSetUtf8,     // UTF8 in
                                        OutCharSet
                                        );
            }
            pParse->pQuestionName = (LPTSTR) pnameQuestion;

            if ( pch + sizeof(DNS_WIRE_QUESTION) > pchpacketEnd )
            {
                DNS_PRINT(( "ERROR:  question exceeds packet length.\n" ));
                goto PacketError;
            }
            pParse->QuestionType = InlineFlipUnalignedWord( pch );
            pch += sizeof(WORD);
            pParse->QuestionClass = InlineFlipUnalignedWord( pch );
            pch += sizeof(WORD);

            if ( Flags & DNS_PARSE_FLAG_ONLY_QUESTION )
            {
                break;
            }
            continue;
        }

        //
        //  extract RR info, type, datalength
        //      - verify RR within message
        //

        pch = Dns_ReadRecordStructureFromPacket(
                   pch,
                   pchpacketEnd,
                   & parsedRR );
        if ( !pch )
        {
            DNS_PRINT(( "ERROR:  bad RR struct out of packet.\n" ));
            goto PacketError;
        }
        type = parsedRR.Type;

        //
        //  type change -- then have new RR set
        //      - setup for new name
        //      - check and see if first non-alias answer
        //

        if ( type != typePrevious )
        {
            fnameSameAsPrevious = FALSE;
            typePrevious = type;
        }

        //
        //  screen out OPT
        //
        //  DCR:  make screening configurable for API
        //

        if ( type == DNS_TYPE_OPT )
        {
            continue;
        }

        //
        //  screen out SIGs -- if not desired
        //
#if 0
        if ( type == DNS_TYPE_SIG &&
             flag & NOSIG )
        {
            continue;
        }
#endif

        //
        //  make copy of new name
        //
        //  DCR_FIX0:   name same as previous
        //      flag indicates only that name not compressed to previous
        //      name (or previous compression)
        //      actually need abolute ingnore case compare
        //      with last records name to be sure that name not previous
        //

        if ( !fnameSameAsPrevious )
        {
            pnameNew = Dns_NameCopyAllocate(
                            nameBuffer,
                            (UCHAR) nameLength,
                            DnsCharSetUtf8,     // UTF8 string in
                            OutCharSet
                            );
            if ( !pnameNew )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Failed;
            }
            pnameOwner = pnameNew;
            DNSDBG( OFF, (
                "Copy of owner name of record being read from packet %s\n",
                nameBuffer ));
        }
        DNS_ASSERT( pnameOwner );
        DNS_ASSERT( pnameNew || fnameSameAsPrevious );

        //
        //  TSIG record requires owner name for versioning
        //

        recordTemp.pName = pnameOwner;

        //
        //  read RR data for type
        //

        index = INDEX_FOR_TYPE( type );
        DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

        if ( !index || !RRReadTable[ index ] )
        {
            //  unknown types -- index to NULL type to use
            //  FlatRecordRead()

            DNS_PRINT((
                "WARNING:  Reading unknown record type %d from message\n",
                parsedRR.Type ));

            index = DNS_TYPE_NULL;
        }

        pnewRR = RRReadTable[ index ](
                        &recordTemp,
                        OutCharSet,
                        (PCHAR) pDnsBuffer,
                        parsedRR.pchData,
                        pch                 // end of record data
                        );
        if ( ! pnewRR )
        {
            status = GetLastError();
            ASSERT( status != ERROR_SUCCESS );

            DNS_PRINT((
                "ERROR:  RRReadTable routine failure for type %d.\n"
                "\tstatus   = %d\n"
                "\tpchdata  = %p\n"
                "\tpchend   = %p\n",
                parsedRR.Type,
                status,
                parsedRR.pchData,
                pch ));

            if ( status == ERROR_SUCCESS )
            {
                status = DNS_ERROR_NO_MEMORY;
            }
            goto Failed;
        }

        //
        //  write record info
        //      - first RR in set gets new name allocation
        //      and is responsible for cleanup
        //      - no data cleanup necessary as all data is
        //      contained in the RR allocation
        //

        pnewRR->pName = pnameOwner;
        pnewRR->wType = type;
        pnewRR->dwTtl = parsedRR.Ttl;
        pnewRR->Flags.S.Section = section;
        pnewRR->Flags.S.CharSet = OutCharSet;
        FLAG_FreeOwner( pnewRR ) = !fnameSameAsPrevious;
        FLAG_FreeData( pnewRR ) = FALSE;

        //
        //  add RR to list
        //

        if ( type == DNS_TYPE_SIG )
        {
            DNS_RRSET_ADD( rrsetSig, pnewRR );
        }
        else if ( type == DNS_TYPE_CNAME &&
                  pParse->QuestionType != DNS_TYPE_ALL &&
                  pParse->QuestionType != DNS_TYPE_CNAME &&
                  section == DNSREC_ANSWER )
        {
            DNS_RRSET_ADD( rrsetAlias, pnewRR );
        }
        else
        {
            DNS_RRSET_ADD( rrset, pnewRR );
        }

        //  clear new ptr, as name now part of record
        //  this is strictly used to determine when pnameOwner
        //  must be cleaned up on failure

        pnameNew = NULL;

    }   //  end loop through packet's records

    //
    //  set response info
    //
    //  DCR:  if don't want single SIG, easy to break out by section
    //

    pParse->pAliasRecords = rrsetAlias.pFirstRR;

    pParse->pSigRecords = rrsetSig.pFirstRR;

    //
    //  break out various query NO_ERROR responses
    //      - empty response
    //      - referral
    //      - garbage
    //

    if ( pwireMsg->AnswerCount == 0  &&
         rcodeStatus == 0  &&
         pwireMsg->Opcode == DNS_OPCODE_QUERY &&
         pwireMsg->IsResponse )
    {
        PDNS_RECORD prrAuth = pParse->pAuthorityRecords;

        if ( (prrAuth && prrAuth->wType == DNS_TYPE_SOA) ||
             (!prrAuth && pwireMsg->Authoritative) )
        {
            rcodeStatus = DNS_INFO_NO_RECORDS;
            DNSDBG( READ, ( "Empty-auth response at %p.\n", pwireMsg ));
        }
        else if ( prrAuth &&
                  prrAuth->wType == DNS_TYPE_NS &&
                  !pwireMsg->Authoritative &&
                  (!pwireMsg->RecursionAvailable || !pwireMsg->RecursionDesired) )
        {
            rcodeStatus = DNS_ERROR_REFERRAL_RESPONSE;
            DNSDBG( READ, ( "Referral response at %p.\n", pwireMsg ));
        }
        else
        {
            rcodeStatus = DNS_ERROR_BAD_PACKET;
            DNSDBG( ANY, ( "Bogus NO_ERROR response at %p.\n", pwireMsg ));
            DNS_ASSERT( FALSE );
        }
    }

    //  verify never turn RCODE result into SUCCESS

    ASSERT( pwireMsg->ResponseCode == 0 || rcodeStatus != ERROR_SUCCESS );
    ASSERT( pnameNew == NULL );

    pParse->Status = rcodeStatus;

    IF_DNSDBG( RECV )
    {
        DnsDbg_ParsedMessage(
            "Parsed message:\n",
            pParse );
    }
    return( rcodeStatus );


PacketError:

    DNS_PRINT(( "ERROR:  bad packet in buffer.\n" ));
    status = DNS_ERROR_BAD_PACKET;

Failed:

    FREE_HEAP( pnameNew );

    Dns_RecordListFree( rrset.pFirstRR );
    Dns_RecordListFree( rrsetAlias.pFirstRR );
    Dns_RecordListFree( rrsetSig.pFirstRR );

    pParse->Status = status;

    return( status );
}



VOID
Dns_FreeParsedMessageFields(
    IN OUT  PDNS_PARSED_MESSAGE pParse
    )
/*++

Routine Description:

    Free a parsed DNS message struct.

Arguments:

    pParse - ptr to blob to receive parsed message

Return Value:

    None

--*/
{
    DNSDBG( TRACE, (
        "Dns_FreeParsedMessageFields( %p )\n",
        pParse ));

    //  question name

    FREE_HEAP( pParse->pQuestionName );

    //  records

    Dns_RecordListFree( pParse->pAliasRecords );
    Dns_RecordListFree( pParse->pAnswerRecords );
    Dns_RecordListFree( pParse->pAdditionalRecords );
    Dns_RecordListFree( pParse->pAuthorityRecords );
    Dns_RecordListFree( pParse->pSigRecords );

    //  clear to avoid confusion or double free

    RtlZeroMemory(
        pParse,
        sizeof(DNS_PARSED_MESSAGE) );
}



DNS_STATUS
Dns_ExtractRecordsFromBuffer(
    IN      PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN      WORD                wMessageLength,
    IN      BOOL                fUnicode,
    OUT     PDNS_RECORD *       ppRecord
    )
/*++

Routine Description:

    Extract records from packet buffer.

Arguments:

    pDnsBuffer - message buffer to read from

    fUnicode - flag indicating strings in record should be unicode

Return Value:

    Ptr to parsed record list if any.
    NULL if no record list or error.

--*/
{
    PDNS_RECORD         prr;
    DNS_STATUS          status;
    DNS_PARSED_MESSAGE  parseBlob;

    DNSDBG( READ, (
        "Dns_ExtractRecordsFromBuffer( %p, len=%d )\n",
        pDnsBuffer,
        wMessageLength
        ));

    //
    //  call real parsing function
    //

    status = Dns_ParseMessage(
                & parseBlob,
                pDnsBuffer,
                wMessageLength,
                DNS_PARSE_FLAG_NO_QUESTION,
                fUnicode
                    ? DnsCharSetUnicode
                    : DnsCharSetUtf8
                );

    //
    //  concatentate into one blob
    //      - work backwards so only touch each record once
    //

    prr = Dns_RecordListAppend(
            parseBlob.pAuthorityRecords,
            parseBlob.pAdditionalRecords
            );

    prr = Dns_RecordListAppend(
            parseBlob.pAnswerRecords,
            prr
            );

    prr = Dns_RecordListAppend(
            parseBlob.pAliasRecords,
            prr
            );

    *ppRecord = prr;

    IF_DNSDBG( RECV )
    {
        DnsDbg_RecordSet(
            "Extracted records:\n",
            prr );
    }

    return( status );
}




#if 0
DNS_STATUS
Dns_ExtractRecordsFromBuffer(
    IN      PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN      WORD                wMessageLength,
    IN      BOOL                fUnicode,
    OUT     PDNS_RECORD *       ppRecord
    )
/*++

Routine Description:

    Extract records from packet buffer.

Arguments:

    pDnsBuffer - message buffer to read from

    fUnicode - flag indicating strings in record should be unicode

Return Value:

    Ptr to parsed record list if any.
    NULL if no record list or error.

--*/
{
    register PCHAR      pch;
    PDNS_HEADER         pwireMsg = (PDNS_HEADER) pDnsBuffer;
    PCHAR               pchpacketEnd;
    DNS_PARSED_RR       parsedRR;
    LPSTR               pnameOwner;
    LPSTR               pnameNew = NULL;
    DNS_CHARSET         outCharSet;
    WORD                countRR;
    WORD                countSection;
    WORD                typePrevious = 0;
    WORD                nameOffset = 0;
    WORD                nameLength;
    WORD                index;
    BYTE                section;
    BOOL                fnameSameAsPrevious;
    PDNS_RECORD         pnewRR;
    DNS_RRSET           rrset;
    DNS_STATUS          status;
    DNS_STATUS          rcodeStatus;
    CHAR                nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    DNS_RECORD          recordTemp;
    PWORD               pCurrentCountField = NULL;

    DNSDBG( READ, (
        "Dns_ExtractRecordsFromBuffer( %p, len=%d )\n",
        pDnsBuffer,
        wMessageLength
        ));

    //
    //  error code
    //      - map RCODE to DNS error
    //      - if other than NAME_ERROR, don't bother parsing
    //

    rcodeStatus = pwireMsg->ResponseCode;
    if ( rcodeStatus != 0 )
    {
        rcodeStatus = Dns_MapRcodeToStatus( pwireMsg->ResponseCode );
        if ( rcodeStatus != DNS_ERROR_RCODE_NAME_ERROR )
        {
            DNSDBG( READ, (
                "No records extracted from response\n"
                "\tresponse code = %d\n",
                pwireMsg->ResponseCode ));
            return( rcodeStatus );
        }
    }

    DNS_RRSET_INIT( rrset );

    //
    //  detemine char set
    //

    if ( fUnicode )
    {
        outCharSet = DnsCharSetUnicode;
    }
    else
    {
        outCharSet = DnsCharSetUtf8;
    }

    //
    //  read RRs in list of records
    //
    //  loop through all resource records
    //      - skip question
    //      - build DNS_RECORD structure for other records
    //

    pchpacketEnd = (PCHAR)pwireMsg + wMessageLength;
    pch = pDnsBuffer->MessageBody;

    section = DNSREC_QUESTION;
    pCurrentCountField = &pwireMsg->QuestionCount;
    countSection = pwireMsg->QuestionCount;
    countRR = 0;

    while( 1 )
    {
        //
        //  changing sections
        //  save section number and RR count for current section
        //  note need immediate loop back to handle empty section
        //

        countRR++;
        if ( countRR > countSection )
        {
            if ( section == DNSREC_ADDITIONAL )
            {
                break;
            }
            section++;
            pCurrentCountField++;
            countSection = *(pCurrentCountField);
            countRR = 0;
            continue;
        }

        //  validity check next RR

        if ( pch >= pchpacketEnd )
        {
            DNS_PRINT((
                "ERROR:  reading bad packet %p.\n"
                "\tat end of packet length with more records to process\n"
                "\tpacket length = %ld\n"
                "\tcurrent offset = %ld\n",
                pDnsBuffer,
                wMessageLength,
                pch - (PCHAR)pwireMsg
                ));
            goto PacketError;
        }

        //
        //  skip question
        //

        if ( section == DNSREC_QUESTION )
        {
            pch = Dns_SkipPacketName(
                        pch,
                        pchpacketEnd );
            if ( !pch )
            {
                DNS_PRINT(( "ERROR:  bad question name.\n" ));
                goto PacketError;
            }
            pch += sizeof(DNS_WIRE_QUESTION);
            if ( pch > pchpacketEnd )
            {
                DNS_PRINT(( "ERROR:  question exceeds packet length.\n" ));
                goto PacketError;
            }
            continue;
        }

        //
        //  read name, determining if same as previous name
        //

        IF_DNSDBG( READ2 )
        {
            DnsDbg_Lock();
            DNS_PRINT((
                "Reading record at offset %x\n",
                (WORD)(pch - (PCHAR)pwireMsg) ));

            DnsDbg_PacketName(
                "Record name ",
                pch,
                pwireMsg,
                pchpacketEnd,
                "\n" );
            DnsDbg_Unlock();
        }
        pch = Dns_ReadPacketName(
                    nameBuffer,
                    & nameLength,
                    & nameOffset,
                    & fnameSameAsPrevious,
                    pch,
                    (PCHAR) pwireMsg,
                    pchpacketEnd );
        if ( ! pch )
        {
            DNS_PRINT(( "ERROR:  bad packet name.\n" ));
            goto PacketError;
        }
        IF_DNSDBG( READ2 )
        {
            DNS_PRINT((
                "Owner name of record %s\n"
                "\tlength = %d\n"
                "\toffset = %d\n"
                "\tfSameAsPrevious = %d\n",
                nameBuffer,
                nameLength,
                nameOffset,
                fnameSameAsPrevious ));
        }

        //
        //  extract RR info, type, datalength
        //      - verify RR within message
        //

        pch = Dns_ReadRecordStructureFromPacket(
                   pch,
                   pchpacketEnd,
                   & parsedRR );
        if ( !pch )
        {
            DNS_PRINT(( "ERROR:  bad RR struct out of packet.\n" ));
            goto PacketError;
        }

        //
        //  on type change, always have new RR set
        //      - setup for new name
        //

        if ( parsedRR.Type != typePrevious )
        {
            fnameSameAsPrevious = FALSE;
            typePrevious = parsedRR.Type;
        }

        //
        //  screen out OPT
        //
        //  DCR:  make screening configurable for API
        //

        if ( parsedRR.Type == DNS_TYPE_OPT )
        {
            continue;
        }

        //
        //  make copy of new name
        //
        //  DCR_FIX0:   name same as previous
        //      flag indicates only that name not compressed to previous
        //      name (or previous compression)
        //      actually need abolute ingnore case compare
        //      with last records name to be sure that name not previous
        //

        if ( !fnameSameAsPrevious )
        {
            pnameNew = Dns_NameCopyAllocate(
                            nameBuffer,
                            (UCHAR) nameLength,
                            DnsCharSetUtf8,     // UTF8 string in
                            outCharSet
                            );
            pnameOwner = pnameNew;
            DNSDBG( READ2, (
                "Copy of owner name of record being read from packet %s\n",
                pnameOwner ));
        }
        DNS_ASSERT( pnameOwner );
        DNS_ASSERT( pnameNew || fnameSameAsPrevious );

        //
        //  TSIG record requires owner name for versioning
        //

        recordTemp.pName = pnameOwner;

        //
        //  read RR data for type
        //

        index = INDEX_FOR_TYPE( parsedRR.Type );
        DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

        if ( !index || !RRReadTable[ index ] )
        {
            //  unknown types -- index to NULL type to use
            //  FlatRecordRead()

            DNS_PRINT((
                "WARNING:  Reading unknown record type %d from message\n",
                parsedRR.Type ));

            index = DNS_TYPE_NULL;
        }

        pnewRR = RRReadTable[ index ](
                        &recordTemp,
                        outCharSet,
                        (PCHAR) pDnsBuffer,
                        parsedRR.pchData,
                        pch                 // end of record data
                        );
        if ( ! pnewRR )
        {
            status = GetLastError();
            ASSERT( status != ERROR_SUCCESS );

            DNS_PRINT((
                "ERROR:  RRReadTable routine failure for type %d.\n"
                "\tstatus   = %d\n"
                "\tpchdata  = %p\n"
                "\tpchend   = %p\n",
                parsedRR.Type,
                status,
                parsedRR.pchData,
                pch ));

            if ( status == ERROR_SUCCESS )
            {
                status = DNS_ERROR_NO_MEMORY;
            }
            goto Failed;
        }

        //
        //  write record info
        //      - first RR in set gets new name allocation
        //      and is responsible for cleanup
        //      - no data cleanup necessary as all data is
        //      contained in the RR allocation
        //

        pnewRR->pName = pnameOwner;
        pnewRR->wType = parsedRR.Type;
        pnewRR->dwTtl = parsedRR.Ttl;
        pnewRR->Flags.S.Section = section;
        pnewRR->Flags.S.CharSet = outCharSet;
        FLAG_FreeOwner( pnewRR ) = !fnameSameAsPrevious;
        FLAG_FreeData( pnewRR ) = FALSE;

        //  add RR to list

        DNS_RRSET_ADD( rrset, pnewRR );

        //  clear new ptr, as name now part of record
        //  this is strictly used to determine when pnameOwner
        //  must be cleaned up on failure

        pnameNew = NULL;

    }   //  end loop through packet's records

    //
    //  return parsed record list
    //      - return DNS error for RCODE
    //      - set special return code to differentiate empty response
    //
    //  DCR:  should have special REFERRAL response
    //      - could overload NOTAUTH rcode
    //  DCR:  should have special EMPTY_AUTH response
    //      - could have empty-auth overload NXRRSET
    //
    //  DCR:  best check on distinguishing EMPTY_AUTH from REFERRAL
    //

    if ( pwireMsg->AnswerCount == 0  &&  rcodeStatus == 0 )
    {
        if ( !rrset.pFirstRR || rrset.pFirstRR->wType == DNS_TYPE_SOA )
        {
            rcodeStatus = DNS_INFO_NO_RECORDS;
            DNSDBG( READ, ( "Empty-auth response at %p.\n", pwireMsg ));
        }
#if 0
        else if ( rrset.pFirstRR->wType == DNS_TYPE_NS &&
                !pwireMsg->Authoritative )
        {
            rcodeStatus = DNS_INFO_REFERRAL;
            DNSDBG( READ, ( "Referral response at %p.\n", pwireMsg ));
        }
        else
        {
            rcodeStatus = DNS_ERROR_BAD_PACKET;
            DNSDBG( READ, ( "Bogus NO_ERROR response at %p.\n", pwireMsg ));
        }
#endif
    }

    //  verify never turn RCODE result into SUCCESS

    ASSERT( pwireMsg->ResponseCode == 0 || rcodeStatus != ERROR_SUCCESS );
    ASSERT( pnameNew == NULL );

    *ppRecord = rrset.pFirstRR;

    IF_DNSDBG( RECV )
    {
        DnsDbg_RecordSet(
            "Extracted records:\n",
            *ppRecord );
    }
    return( rcodeStatus );


PacketError:

    DNS_PRINT(( "ERROR:  bad packet in buffer.\n" ));
    status = DNS_ERROR_BAD_PACKET;

Failed:

    FREE_HEAP( pnameNew );

    Dns_RecordListFree( rrset.pFirstRR );

    return( status );
}
#endif



VOID
Dns_NormalizeAllRecordTtls(
    IN OUT  PDNS_RECORD         pRecord
    )
/*++

Routine Description:

    Finds the lowest TTL value in RR set and the sets all
    records to that value.

Arguments:

    pRecord - record set to normalize ttl values of.

Return Value:

    None

--*/
{
    PDNS_RECORD pTemp = pRecord;
    DWORD       dwTtl;
    WORD        wType;

    //
    // Get the Ttl of the first record (if there is one)
    //
    if ( pTemp )
    {
        dwTtl = pTemp->dwTtl;
        wType = pTemp->wType;
        pTemp = pTemp->pNext;
    }

    //
    // Walk any remaining records looking for an even lower ttl value
    //
    while ( pTemp &&
            pTemp->wType == wType &&
            pTemp->Flags.S.Section == DNSREC_ANSWER )
    {
        if ( pTemp->dwTtl < dwTtl )
        {
            dwTtl = pTemp->dwTtl;
        }

        pTemp = pTemp->pNext;
    }

    //
    // Set all records to this lowest ttl value
    //
    pTemp = pRecord;

    while ( pTemp &&
            pTemp->wType == wType &&
            pTemp->Flags.S.Section == DNSREC_ANSWER )
    {
        pTemp->dwTtl = dwTtl;
        pTemp = pTemp->pNext;
    }
}



PCHAR
Dns_ReadRecordStructureFromPacket(
    IN      PCHAR           pchPacket,
    IN      PCHAR           pchMsgEnd,
    IN OUT  PDNS_PARSED_RR  pParsedRR
    )
/*++

Routine Description:

    Read record structure from packet.

Arguments:

    pchPacket - ptr to record structure in packet

    pchMsgEnd - end of message

    pParsedRR - ptr to struct to receive parsed RR

Return Value:

    Ptr to next record in packet -- based on datalength.
    Null on error.

--*/
{
    PCHAR   pch = pchPacket;

    DNSDBG( READ2, (
        "Dns_ReadRecordStructureFromPacket(%p).\n",
        pch ));

    //
    //  verify record structure within packet
    //

    if ( pch + sizeof(DNS_WIRE_RECORD) > pchMsgEnd )
    {
        DNS_PRINT((
            "ERROR:  record structure at %p is not within packet!.\n",
            pchPacket ));
        return( 0 );
    }

    //
    //  flip fields and write to aligned struct
    //

    pParsedRR->pchRR = pch;

    pParsedRR->Type       = InlineFlipUnalignedWord( pch );
    pch += sizeof(WORD);
    pParsedRR->Class      = InlineFlipUnalignedWord( pch );
    pch += sizeof(WORD);
    pParsedRR->Ttl        = InlineFlipUnalignedDword( pch );
    pch += sizeof(DWORD);
    pParsedRR->DataLength = InlineFlipUnalignedWord( pch );
    pch += sizeof(WORD);

    pParsedRR->pchData = pch;

    //
    //  verify datalength does not extend beyond packet end
    //

    pch += pParsedRR->DataLength;
    pParsedRR->pchNextRR = pch;

    if ( pch > pchMsgEnd )
    {
        DNS_PRINT((
            "ERROR:  record data at %p (length %d) is not within packet!.\n",
            pch - pParsedRR->DataLength,
            pParsedRR->DataLength ));
        return( 0 );
    }

    //
    //  return ptr to next record in packet
    //

    return( pch );
}



PCHAR
Dns_ParsePacketRecord(
    IN      PCHAR           pchPacket,
    IN      PCHAR           pchMsgEnd,
    IN OUT  PDNS_PARSED_RR  pParsedRR
    )
/*++

Routine Description:

    Read record from packet.

Arguments:

    pchPacket - ptr to record structure in packet

    pchMsgEnd - end of message

    pParsedRR - ptr to struct to receive parsed RR

Return Value:

    Ptr to next record in packet -- based on datalength.
    Null on error.

--*/
{
    PCHAR   pch;

    DNSDBG( READ2, (
        "Dns_ParsePacketRecord().\n"
        "\tpRecordStart = %p\n"
        "\tpMsgEnd      = %p\n",
        pchPacket,
        pchMsgEnd ));

    //
    //  save and skip name
    //

    pch = Dns_SkipPacketName(
                pchPacket,
                pchMsgEnd );
    if ( !pch )
    {
        return( pch );
    }
    pParsedRR->pchName = pchPacket;

    //
    //  parse record structure
    //

    pch = Dns_ReadRecordStructureFromPacket(
                pch,
                pchMsgEnd,
                pParsedRR );

    return( pch );
}



//
//  Random packet utilities
//

WORD
Dns_GetRandomXid(
    IN      PVOID           pSeed
    )
/*++

Routine Description:

    Generate "random" XID.

Arguments:

    pSeed -- seed ptr;  from stack or heap, provides differentiation beyond time

Return Value:

    XID generated

--*/
{
    SYSTEMTIME  systemTime;

    //
    //  may have multiple sessions to different processes\threads
    //
    //  use system time hashed in with seed pointer
    //  ptr is first pushed down to count 64-bit boundaries, so lack of
    //      randomness in last 6bits is not preserved
    //

    GetSystemTime( &systemTime );

    //  hash millisecs with arbitrary stack location after knocking off any
    //      64-bit boundary constraints

    return  (WORD)( systemTime.wMilliseconds * (PtrToUlong(pSeed) >> 6) );
}

//
//  End packet.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\regfig.c ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    regfig.c

Abstract:

    Domain Name System (DNS) API 

    Configuration routines.

Author:

    Jim Gilroy (jamesg)     September 1999

Revision History:

--*/


#include "local.h"


//
//  Table for quick lookup of DWORD\BOOL reg values
//
//  DCR:  read directly to config BLOB with regID indexes
//      you can't screw that up
//      

#define     DWORD_PTR_ARRAY_END   ((PDWORD) (DWORD_PTR)(-1))

PDWORD RegDwordPtrArray[] =
{
    //  basic -- not DWORDs

    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    //  query

    (PDWORD) &g_QueryAdapterName,
    (PDWORD) &g_UseNameDevolution,
    (PDWORD) &g_PrioritizeRecordData,
    (PDWORD) &g_AllowUnqualifiedQuery,
    (PDWORD) &g_AppendToMultiLabelName,
    (PDWORD) &g_ScreenBadTlds,
    (PDWORD) &g_ScreenUnreachableServers,
    (PDWORD) &g_FilterClusterIp,
    (PDWORD) &g_WaitForNameErrorOnAll,
    (PDWORD) &g_UseEdns,

    //  update

    (PDWORD) &g_RegistrationEnabled,
    (PDWORD) &g_RegisterPrimaryName,
    (PDWORD) &g_RegisterAdapterName,
    (PDWORD) &g_RegisterReverseLookup,
    (PDWORD) &g_RegisterWanAdapters,
    (PDWORD) &g_RegistrationOverwritesInConflict,
    (PDWORD) &g_RegistrationTtl,
    (PDWORD) &g_RegistrationRefreshInterval,
    (PDWORD) &g_RegistrationMaxAddressCount,
    (PDWORD) &g_UpdateSecurityLevel,
    (PDWORD) &g_UpdateZoneExcludeFile,
    (PDWORD) &g_UpdateTopLevelDomains,

    //  backcompat

    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    //  micellaneous

    NULL,   //g_InNTSetupMode,      // not in standard location
    (PDWORD) &g_DnsTestMode,
    NULL,                           // remote resolver not a DWORD

    //  resolver

    (PDWORD) &g_MaxCacheSize,
    (PDWORD) &g_MaxCacheTtl,
    (PDWORD) &g_MaxNegativeCacheTtl,
    (PDWORD) &g_AdapterTimeoutLimit,
    (PDWORD) &g_ServerPriorityTimeLimit,
    (PDWORD) &g_MaxCachedSockets,

    //  multicast resolver

    (PDWORD) &g_UseMulticast,
    (PDWORD) &g_MulticastOnNameError,
    (PDWORD) &g_UseDotLocalDomain,
    (PDWORD) &g_ListenOnMulticast,

    //  termination

    DWORD_PTR_ARRAY_END
};

//
//  Array indicating which registry values
//      were read versus defaulted
//

DWORD   RegValueWasReadArray[ RegIdValueCount ];


//
//  Check for empty reg value (string)
//
//  DCR:  consider more detailed white space check
//

#define IS_EMPTY_STRING(psz)            (*(psz)==0)




//
//  General registry\config utils
//

VOID
PrintConfigGlobals(
    IN      PSTR            pszHeader
    )
/*++

Routine Description:

    Print config globals.

Arguments:

    pszHeader -- header to print with

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DWORD   propId;

    //
    //  print each property
    //

    DnsDbg_Lock();

    DnsDbg_Printf(
        "%s\n",
        pszHeader ? pszHeader : "Registry Globals:" );

    propId = 0;

    for( propId=0; propId<=RegIdValueMax; propId++ )
    {
        PDWORD  pdword = RegDwordPtrArray[propId];

        //  separators

        if ( propId == RegIdQueryAdapterName )
        {
            DnsDbg_Printf( "\t-- Query:\n" );
        }
        else if ( propId == RegIdRegistrationEnabled )
        {
            DnsDbg_Printf( "\t-- Update:\n" );
        }
        else if ( propId == RegIdSetupMode )
        {
            DnsDbg_Printf( "\t-- Miscellaneous:\n" );
        }
        else if ( propId == RegIdMaxCacheSize )
        {
            DnsDbg_Printf( "\t-- Resolver\n" );
        }

        //  NULL indicates not DWORD or not standard

        if ( !pdword )
        {
            continue;
        }

        //  terminate on bogus ptr

        if ( pdword == DWORD_PTR_ARRAY_END )
        {
            ASSERT( FALSE );
            break;
        }

        DnsDbg_Printf(
            "\t%-36S= %8d (read=%d)\n",
            REGPROP_NAME( propId ),
            * pdword,
            RegValueWasReadArray[ propId ] );
    }

    DnsDbg_Printf(
        "\t-- Random:\n"
        "\tIsDnsServer                      = %d\n"
        "\tInNTSetupMode                    = %d\n"
        "\tDnsTestMode                      = %08x\n\n",
        g_IsDnsServer,
        g_InNTSetupMode,
        g_DnsTestMode
        );

    DnsDbg_Unlock();
}



DNS_STATUS
Reg_ReadGlobalsEx(
    IN      DWORD           dwFlag,
    IN      PVOID           pRegSession     OPTIONAL
    )
/*++

Routine Description:

    Read globals from registry.

Arguments:

    dwFlag -- flag indicating read level

    //
    //  DCR:  reg read flag unimplemented
    //
    //  note:  should have option to NOT read some registry
    //          values for case when cache off, then could
    //          skip useless cache info when building local
    //          networkinfo blob
    //

    pRegSession -- ptr to existing registry session

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DWORD               propId;
    REG_SESSION         regSession;
    PREG_SESSION        psession;
    DNS_STATUS          status;


    DNSDBG( TRACE, (
        "Dns_ReadRegistryGlobals( %08x, %p )\n",
        dwFlag,
        pRegSession ));

    //
    //  basic registry init
    //      - includes system global
    //

    Reg_Init();

    //
    //  code validity check
    //  property table should have entry for every reg value plus an
    //      extra one for the terminator
    //

#if DBG
    DNS_ASSERT( (RegIdValueCount+1)*sizeof(PDWORD) ==
                sizeof(RegDwordPtrArray) );
#endif

    //
    //  open registry session -- if not passed in
    //

    psession = (PREG_SESSION) pRegSession;

    if ( !psession )
    {
        psession = &regSession;
        status = Reg_OpenSession( psession, 0, 0 );
        if ( status != ERROR_SUCCESS )
        {
            return( status );
        }
    }

    //
    //  clear "value was read" array
    //

    RtlZeroMemory(
        RegValueWasReadArray,
        sizeof( RegValueWasReadArray ) );

    //
    //  MS DNS?
    //

    g_IsDnsServer = Reg_IsMicrosoftDnsServer();

    //
    //  remote resolver?
    //      - not currently enabled
    //

    //g_pwsRemoteResolver = DnsGetResolverAddress();
    g_pwsRemoteResolver = NULL;


    //
    //  read\set each DWORD\BOOL registry value
    //      

    propId = 0;

    for( propId=0; propId<=RegIdValueMax; propId++ )
    {
        PDWORD  pdword = RegDwordPtrArray[propId];

        //  NULL indicates not DWORD or not standard

        if ( !pdword )
        {
            continue;
        }

        //  terminate on bogus ptr

        if ( pdword == DWORD_PTR_ARRAY_END )
        {
            ASSERT( FALSE );
            break;
        }

        status = Reg_GetDword(
                    psession,       // reg session
                    NULL,           // no key
                    NULL,           // standard location
                    propId,         // index is property id
                    pdword );

        //  set fRead flag if value found in registry

        if ( status == ERROR_SUCCESS )
        {
            RegValueWasReadArray[propId] = TRUE;
        }
    }

    //
    //  registration refresh defaults are different for DC
    //

    if ( !RegValueWasReadArray[ RegIdRegistrationRefreshInterval ] )
    {
        if ( g_IsDomainController )
        {
            g_RegistrationRefreshInterval = REGDEF_REGISTRATION_REFRESH_INTERVAL_DC;
        }
        ELSE_ASSERT( g_RegistrationRefreshInterval == REGDEF_REGISTRATION_REFRESH_INTERVAL );
    }

    //
    //  non-standard registry values
    //      - setup mode
    //

    Reg_GetDword(
        psession,
        NULL,               // no key
        REGKEY_SETUP_MODE_LOCATION,
        RegIdSetupMode,
        (PDWORD) &g_InNTSetupMode );

    //
    //  DCR:  flip in policy globals and do single read here
    //      or since they are only relevant to adapter
    //      list and registration, keep separate
    //
    //      fundamentally the question is how separate is the
    //      adapter list read from other globals?
    //


    //  close local session registry handles

    if ( psession == &regSession )
    {
        Reg_CloseSession( psession );
    }

    IF_DNSDBG( INIT )
    {
        PrintConfigGlobals( "Read Registry Globals" );
    }

    return( ERROR_SUCCESS );
}



DNS_STATUS
Reg_RefreshUpdateConfig(
    VOID
    )
/*++

Routine Description:

    Read\refresh update config.

    This routine encapsulates getting all update config info
    current before any update operation.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    //
    //  read all global DWORDs if haven't been read "recently"
    //
    //  note:  adapter specific stuff is read building network config;
    //      here were are just insuring that we have top level globals
    //      current;  specifically test was blocked because the
    //      update TLD flag was not being reread
    //
    //  DCR:  when have change\notify this should just tie into
    //          global config read
    //

    return  Reg_ReadGlobalsEx( 0, NULL );
}



//
//  Special DNS property routines
//

DNS_STATUS
Reg_ReadPrimaryDomainName(
    IN      PREG_SESSION    pRegSession,    OPTIONAL
    IN      HKEY            hRegKey,        OPTIONAL
    OUT     PSTR *          ppPrimaryDomainName
    )
/*++

Routine Description:

    Read primary domain name.

Arguments:


    pRegSession -- ptr to registry session, OPTIONAL

    hRegKey     -- handle to open regkey OPTIONAL (currently unimplemented)

    ppPrimaryDomainName -- addr to recv ptr to PDN

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS          status;
    REG_SESSION         session;
    PREG_SESSION        psession = NULL;
    LPSTR               pdomainName = NULL;

    DNSDBG( TRACE, ( "Reg_ReadPrimaryDomainName()\n" ));

    ASSERT( !hRegKey );

    //
    //  open reg handle if not open
    //
    //  note:  worth doing here, because if we default the open
    //      in the calls below, we will make unnecessary reg calls
    //      -- won't be able to screen for policy existence
    //          so policy PDN name will be looked for in TCPIP
    //      -- the second call for the TCPIP domain name, will also
    //          check in the policy area (if exists)
    //      

    psession = pRegSession;

    if ( !psession )
    {
        psession = &session;
        status = Reg_OpenSession(
                        psession,
                        0,          // standard level
                        0           // no specific value, open both
                        );
        if ( status != ERROR_SUCCESS )
        {
            goto Done;
        }
    }
              //
    //  try policy
    //      - no policy pickup for DCs
    //      - first try new WindowsNT policy
    //      - if not found, try policy used in Win2K
    //

    if ( !g_IsDomainController )
    {
        HKEY    holdPolicyKey = NULL;
        HKEY    hkeyPolicy = psession->hPolicy;

        if ( hkeyPolicy )
        {
            status = Reg_GetValue(
                        NULL,               // don't send whole session
                        hkeyPolicy,         // use explicit policy key
                        RegIdPrimaryDomainName,
                        REGTYPE_DNS_NAME,
                        (PBYTE *) &pdomainName
                        );
            if ( pdomainName )
            {
                goto Found;
            }
        }

        //
        //  not found in new, open old policy
        //
              
        status = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    DNS_POLICY_WIN2K_KEY,
                    0,
                    KEY_QUERY_VALUE,
                    & holdPolicyKey );

        if ( holdPolicyKey )
        {
            status = Reg_GetValue(
                        NULL,               // don't send whole session
                        holdPolicyKey,      // use explicit policy key
                        RegIdPrimaryDnsSuffix,
                        REGTYPE_DNS_NAME,
                        (PBYTE *) &pdomainName
                        );

            RegCloseKey( holdPolicyKey );
            if ( pdomainName )
            {
                goto Found;
            }
        }
    }

    //
    //  no policy name
    //      - try DNS client
    //      - try standard TCPIP location
    //          note under TCPIP it's "Domain"
    //

#ifdef DNSCLIENTKEY
    if ( psession->hClient )
    {
        status = Reg_GetValue(
                    NULL,                       // don't send whole session
                    psession->hClient,          // send client key explicitly
                    RegIdPrimaryDomainName,
                    REGTYPE_DNS_NAME,
                    (PBYTE *) &pdomainName );
        if ( pdomainName )
        {
            goto Found;
        }
    }
#endif

    status = Reg_GetValue(
                NULL,                       // don't send whole session
                psession->hTcpip,           // send TCPIP key explicitly
                RegIdDomainName,
                REGTYPE_DNS_NAME,
                (PBYTE *) &pdomainName );


Found:

    //  dump name if empty\useless

    if ( pdomainName &&
         ( strlen( pdomainName ) == 0 ) )
    {
        FREE_HEAP( pdomainName );
        pdomainName = NULL;
    }


Done:

    DNSDBG( TRACE, ( "Read PDN = %s\n", pdomainName ));

    //  set domain name OUT param

    *ppPrimaryDomainName = pdomainName;

    //  cleanup any regkey's opened

    if ( psession == &session )
    {
        Reg_CloseSession( psession );
    }

    return( status );
}



BOOL
Reg_IsMicrosoftDnsServer(
    VOID
    )
/*++

Routine Description:

    Read registry to determine if MS DNS server.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DWORD   status = NO_ERROR;
    HKEY    hkey = NULL;

    //
    //  open services key to determine whether the DNS server is installed.
    //
    //  DCR:  read DNS server only once
    //      - however need some sort of callback so we can pick this up
    //      after install
    //

    status = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                DNS_SERVER_KEY,
                0,
                KEY_QUERY_VALUE,
                &hkey );

    if ( status != ERROR_SUCCESS )
    {
        return FALSE;
    }

    RegCloseKey( hkey );

    return TRUE;
}



//
//  Reg info read.
//  These are read routines for info beyond flat globals.
//
//  Three types of info:
//      - global
//      - adapter specific
//      - update
//

DNS_STATUS
Reg_ReadGlobalInfo(
    IN      PREG_SESSION        pRegSession,
    OUT     PREG_GLOBAL_INFO    pRegInfo
    )
/*++

Routine Description:

    Read DNS registry info, not read in flat read.

    This covers all the allocated stuff, plus policy
    stuff for adapter info.

        -- primary domain name
        -- adapter policy
            - domain name
            - DNS servers
            - flag overrides

Arguments:

    pRegSession -- registry session

    pRegInfo -- blob to hold reg info

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS          status;
    REG_SESSION         regSession;
    PREG_SESSION        pregSession = pRegSession;
    HKEY                hkeyPolicy = NULL;

    DNSDBG( TRACE, (
        "Dns_ReadRegInfo( %p, %p )\n",
        pRegSession,
        pRegInfo ));

    //
    //  clear reg info blob
    //

    RtlZeroMemory(
        pRegInfo,
        sizeof( *pRegInfo ) );

    //
    //  open the registry
    //

    if ( !pregSession )
    {
        pregSession = &regSession;
    
        status = Reg_OpenSession(
                    pregSession,
                    0,
                    0 );
        if ( status != ERROR_SUCCESS )
        {
            return( status );
        }
    }

    //
    //  if not read force registry read
    //

    status = Reg_ReadGlobalsEx(
                0,              // no flag, read it all
                pregSession
                );

    //
    //  primary domain name
    //

    Reg_ReadPrimaryDomainName(
        pregSession,
        NULL,           // no specific key
        & pRegInfo->pszPrimaryDomainName
        );

    //
    //  host name
    //

    Reg_GetValue(
        pregSession,
        NULL,           // no key
        RegIdHostName,
        REGTYPE_DNS_NAME,
        & pRegInfo->pszHostName
        );

    //
    //  pick up required registry values from globals
    //

    pRegInfo->fUseNameDevolution        = g_UseNameDevolution;
    pRegInfo->fUseMulticast             = g_UseMulticast;
    pRegInfo->fUseMulticastOnNameError  = g_MulticastOnNameError;
    pRegInfo->fUseDotLocalDomain        = g_UseDotLocalDomain;

    //
    //  policy overrides for adapter info
    //      - enable adapter registration
    //      - DNS servers
    //      - domain name
    //
    //  note, we need both value and found\not-found flag
    //      as value overrides only when it exists
    //

    hkeyPolicy = pregSession->hPolicy;
    if ( !hkeyPolicy )
    {
        goto Done;
    }

    //
    //  policy for register adapter name?
    //

    status = Reg_GetDword(
                NULL,                   // no session
                hkeyPolicy,             // policy
                NULL,                   // no adapter
                RegIdRegisterAdapterName,
                & pRegInfo->fRegisterAdapterName
                );
    if ( status == ERROR_SUCCESS )
    {
        pRegInfo->fPolicyRegisterAdapterName = TRUE;
    }

    //
    //  policy for adapter domain name?
    //

    status = Reg_GetValue(
                NULL,                   // no session
                hkeyPolicy,
                RegIdAdapterDomainName,
                REGTYPE_DNS_NAME,
                (PBYTE *) &pRegInfo->pszAdapterDomainName
                );

    //
    //  policy for adapter DNS server lists
    //

    status = Reg_GetIpArray(
                NULL,                   // no session
                hkeyPolicy,
                NULL,                   // no adapter
                RegIdDnsServers,
                REG_SZ,
                &pRegInfo->pDnsServerArray
                );

Done:

    //  if opened session -- close

    if ( pregSession  &&  !pRegSession )
    {
        Reg_CloseSession( pregSession );
    }

    DNSDBG( TRACE, (
        "Leave Reg_ReadGlobalInfo()\n"
        "\tPDN          = %s\n"
        "\tPolicy:\n"
        "\t\tRegister Adapter   = %d\n"
        "\t\tAdapterName        = %s\n"
        "\t\tDNS servers        = %p\n",
        pRegInfo->pszPrimaryDomainName,
        pRegInfo->fRegisterAdapterName,
        pRegInfo->pszAdapterDomainName,
        pRegInfo->pDnsServerArray
        ));

    return  ERROR_SUCCESS;
}



VOID
Reg_FreeGlobalInfo(
    IN OUT  PREG_GLOBAL_INFO    pRegInfo,
    IN      BOOL                fFreeBlob
    )
/*++

Routine Description:

    Free registry adapter policy info blob.

Arguments:

    pRegInfo -- adapter policy blob to free

    fFreeBlob -- flag to free blob itself
        FALSE -- just free allocated data fields
        TRUE  -- also free blob itself

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNSDBG( TRACE, (
        "Reg_FreeGlobalInfo( %p )\n",
        pRegInfo ));

    //  allow sloppy cleanup

    if ( !pRegInfo )
    {
        return;
    }

    //
    //  free data
    //      - primary DNS name
    //      - policy adapter name
    //      - policy DNS server list
    //

    if ( pRegInfo->pszPrimaryDomainName )
    {
        FREE_HEAP( pRegInfo->pszPrimaryDomainName );
    }
    if ( pRegInfo->pszHostName )
    {
        FREE_HEAP( pRegInfo->pszHostName );
    }
    if ( pRegInfo->pszAdapterDomainName )
    {
        FREE_HEAP( pRegInfo->pszAdapterDomainName );
    }
    if ( pRegInfo->pDnsServerArray )
    {
        FREE_HEAP( pRegInfo->pDnsServerArray );
    }

    //  free blob itself

    if ( fFreeBlob )
    {
        FREE_HEAP( pRegInfo );
    }
}



DNS_STATUS
Reg_ReadAdapterInfo(
    IN      PSTR                    pszAdapterName,
    IN      PREG_SESSION            pRegSession,
    IN      PREG_GLOBAL_INFO        pRegInfo,
    OUT     PREG_ADAPTER_INFO       pBlob
    )
/*++

Routine Description:

    Read adapter registry info.

Arguments:

    pszAdapterName -- adapter name (registry name)

    pRegSession -- registry session

    pRegInfo    -- registry global info

    pBlob       -- adapter info blob to fill in

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS  status;
    HKEY        hkeyAdapter = NULL;
    PSTR        padapterDomainName = NULL;
    CHAR        adapterParamKey[ MAX_PATH ];

    DNSDBG( TRACE, (
        "ReadRegAdapterInfo( %s, %p, %p, %p )\n",
        pszAdapterName,
        pRegSession,
        pRegInfo,
        pBlob ));

    //
    //  clear adapter blob
    //

    RtlZeroMemory(
        pBlob,
        sizeof(*pBlob) );

    //
    //  bail if no adapter
    //
    //  note:  this check\bail is only in place to allow call to
    //      Reg_ReadUpdateInfo() to be made in asyncreg.c without
    //      specifying an adapter;  this allows us to make the call
    //      before the adapter check and therefore skip a separate
    //      registry op to get current g_IsDnsServer global; 
    //      no actual use will be made of REG_ADAPTER_INFO blob

    if ( !pszAdapterName )
    {
        return  ERROR_SUCCESS;
    }

    //
    //  open adapter key for read
    //

    strcpy( adapterParamKey, TCPIP_INTERFACES_KEY_A );
    strcat( adapterParamKey, pszAdapterName );

    status = RegOpenKeyExA(
                HKEY_LOCAL_MACHINE,
                adapterParamKey,
                0,
                KEY_READ,
                &hkeyAdapter );

    if ( status != NO_ERROR )
    {
        return( status );
    }

    //
    //  query with adapter name
    //      - OFF global overrides
    //

    pBlob->fQueryAdapterName = g_QueryAdapterName;

    if ( g_QueryAdapterName )
    {
        Reg_GetDword(
            NULL,           // no session,
            hkeyAdapter,    // explicit key
            NULL,           // no adapter name
            RegIdQueryAdapterName,
            & pBlob->fQueryAdapterName );
    }

    //
    //  check if adapter IPs get registered
    //      - OFF global overrides
    //

    pBlob->fRegistrationEnabled = g_RegistrationEnabled;

    if ( g_RegistrationEnabled )
    {
        Reg_GetDword(
            NULL,           // no session,
            hkeyAdapter,    // explicit key
            NULL,           // no adapter name
            RegIdRegistrationEnabled,
            & pBlob->fRegistrationEnabled );
    }

    //
    //  adapter name registration
    //      - policy may override
    //      - OFF global overrides
    //      - then adapter
    //

    if ( pRegInfo->fPolicyRegisterAdapterName )
    {
        pBlob->fRegisterAdapterName = pRegInfo->fRegisterAdapterName;
    }
    else
    {
        pBlob->fRegisterAdapterName = g_RegisterAdapterName;

        if ( g_RegisterAdapterName )
        {
            Reg_GetDword(
                NULL,               // no open session,
                hkeyAdapter,        // open key
                NULL,               // no adapter name
                RegIdRegisterAdapterName,
                & pBlob->fRegisterAdapterName );
        }
    }

    //
    //  max addresses to register
    //
    //  DCR:  RegistrationAddrCount -- adapter or global sets high\low?
    //

    if ( pBlob->fRegistrationEnabled )
    {
        Reg_GetDword(
            NULL,           // no session,
            hkeyAdapter,    // explicit key
            NULL,           // no adapter name
            RegIdRegistrationMaxAddressCount,
            & pBlob->RegistrationMaxAddressCount );
#if 0
        if ( g_RegistrationMaxAddressCount >
             pBlob->RegistrationMaxAddressCount )
        {
            pBlob->RegistrationMaxAddressCount = g_RegistrationMaxAddressCount;
        }
#endif
    }

    //
    //  get adapter name
    //     - policy may override AND
    //     allow policy to override with NULL string to kill domain name
    //

    if ( pRegInfo->pszAdapterDomainName )
    {
        if ( IS_EMPTY_STRING( pRegInfo->pszAdapterDomainName ) )
        {
            padapterDomainName = NULL;
        }
        else
        {
            padapterDomainName = DnsCreateStringCopy(
                                    pRegInfo->pszAdapterDomainName,
                                    0 );
        }
    }
    else
    {
        //
        //  static domain name set on adapter?
        //

        status = Reg_GetValueEx(
                    NULL,           // no session
                    hkeyAdapter,
                    NULL,           // no adapter name
                    RegIdStaticDomainName,
                    REGTYPE_DNS_NAME,
                    DNSREG_FLAG_DUMP_EMPTY,     // dump empty string
                    (PBYTE *) &padapterDomainName
                    );
    
        if ( status != ERROR_SUCCESS )
        {
            DNS_ASSERT( padapterDomainName == NULL );
            padapterDomainName = NULL;
        }

        //
        //  if no static name, use DHCP name
        //
    
        if ( ! padapterDomainName )
        {
            status = Reg_GetValueEx(
                            NULL,           // no session
                            hkeyAdapter,
                            NULL,           // no adapter
                            RegIdDhcpDomainName,
                            REGTYPE_DNS_NAME,
                            DNSREG_FLAG_DUMP_EMPTY,     // dump if empty string
                            (PBYTE *) &padapterDomainName );
    
            if ( status != ERROR_SUCCESS )
            {
                DNS_ASSERT( padapterDomainName == NULL );
                padapterDomainName = NULL;
            }
        }
    }

    //
    //  set adapter name in info blob
    //

    pBlob->pszAdapterDomainName = padapterDomainName;

    //
    //  cleanup
    //

    if ( hkeyAdapter )
    {
        RegCloseKey( hkeyAdapter );
    }

    DNSDBG( TRACE, (
        "Leave Dns_ReadRegAdapterInfo()\n"
        "\tDomainName           = %s\n"
        "\tQueryAdapterName     = %d\n"
        "\tRegistrationEnabled  = %d\n"
        "\tRegisterAdapterName  = %d\n"
        "\tRegisterAddrCount    = %d\n",
        pBlob->pszAdapterDomainName,
        pBlob->fQueryAdapterName,
        pBlob->fRegistrationEnabled,
        pBlob->fRegisterAdapterName,
        pBlob->RegistrationMaxAddressCount
        ));

    return  ERROR_SUCCESS;
}



VOID
Reg_FreeAdapterInfo(
    IN OUT  PREG_ADAPTER_INFO   pRegAdapterInfo,
    IN      BOOL                fFreeBlob
    )
/*++

Routine Description:

    Free registry adapter info blob.

Arguments:

    pRegAdapterInfo -- adapter registry info blob to free

    fFreeBlob -- flag to free blob itself
        FALSE -- just free allocated data fields
        TRUE  -- also free blob itself

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNSDBG( TRACE, (
        "FreeRegAdapterInfo( %p )\n",
        pRegAdapterInfo ));

    //
    //  free data
    //      - adapter domain name
    //

    if ( pRegAdapterInfo->pszAdapterDomainName )
    {
        FREE_HEAP( pRegAdapterInfo->pszAdapterDomainName );
        pRegAdapterInfo->pszAdapterDomainName = NULL;
    }

    //  free blob itself

    if ( fFreeBlob )
    {
        FREE_HEAP( pRegAdapterInfo );
    }
}



DNS_STATUS
Reg_ReadUpdateInfo(
    IN      PSTR                pszAdapterName,
    OUT     PREG_UPDATE_INFO    pUpdateInfo
    )
/*++

Routine Description:

    Read update info.

    //
    //  DCR:  shouldn't need this routine, just get NETINFO
    //      this blob is just mix of global stuff and
    //      mostly adapter stuff
    //      even if want in single blob for update routines --
    //      ok, but not ideal -- 
    //      should be getting blob from resolver and reformatting
    //      info;
    //      reg read should happen just once producing network
    //      info in resolver
    //

Arguments:

    pszAdapterName -- adapter name

    pUpdateInfo -- blob to hold reg info

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS          status;
    REG_SESSION         regSession;
    PREG_SESSION        pregSession;
    REG_GLOBAL_INFO     regInfo;
    REG_ADAPTER_INFO    regAdapterInfo;
    BOOL                freadRegInfo = FALSE;
    BOOL                freadRegAdapterInfo = FALSE;

    DNSDBG( TRACE, (
        "Dns_ReadUpdateInfo( %s, %p )\n",
        pszAdapterName,
        pUpdateInfo ));

    //
    //  clear update info blob
    //

    RtlZeroMemory(
        pUpdateInfo,
        sizeof( *pUpdateInfo ) );

    //
    //  open the registry
    //

    pregSession = &regSession;
    
    status = Reg_OpenSession(
                pregSession,
                0,
                0 );
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    //
    //  read registry
    //      - global DWORDs
    //      - global info
    //      - adapter specific info
    //
    //  DCR_PERF:  global read should be RPC
    //  DCR_REG:  fix this with reg read
    //      have flag for IN caching resolver process (skip RPC)
    //      have cookie for last read
    //

#if 0
    //  Reg_ReadGlobalInfo() calls Reg_ReadGlobalsEx()
    status = Reg_ReadGlobalsEx(
                0,              // no flag, update variables desired
                pregSession
                );
#endif

    status = Reg_ReadGlobalInfo(
                pregSession,
                & regInfo );

    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }
    freadRegInfo = TRUE;

    status = Reg_ReadAdapterInfo(
                pszAdapterName,
                pregSession,
                & regInfo,
                & regAdapterInfo );

    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }
    freadRegAdapterInfo = TRUE;

    //
    //  alternate computer name
    //

    Reg_GetValue(
        pregSession,
        NULL,           // no key
        RegIdAlternateNames,
        REGTYPE_ALTERNATE_NAMES,
        & pUpdateInfo->pmszAlternateNames
        );

    //
    //  set update results
    //      - PDN always needed
    //      - adapter domain if policy override
    //      - DNS servers if policy override
    //
    //  note, in all cases we don't realloc, we steal the
    //  info and NULL it out so not freed on cleanup
    //

    pUpdateInfo->pszPrimaryDomainName = regInfo.pszPrimaryDomainName;
    regInfo.pszPrimaryDomainName = NULL;

    pUpdateInfo->pszAdapterDomainName = regInfo.pszAdapterDomainName;
    regInfo.pszAdapterDomainName = NULL;
                
    pUpdateInfo->pDnsServerArray = regInfo.pDnsServerArray;
    regInfo.pDnsServerArray = NULL;

    pUpdateInfo->pDnsServerIp6Array = regInfo.pDnsServerIp6Array;
    regInfo.pDnsServerIp6Array = NULL;

    //  update flags

    pUpdateInfo->fRegistrationEnabled = regAdapterInfo.fRegistrationEnabled;
    pUpdateInfo->fRegisterAdapterName = regAdapterInfo.fRegisterAdapterName;
    pUpdateInfo->RegistrationMaxAddressCount =
                                regAdapterInfo.RegistrationMaxAddressCount;

Done:

    //
    //  cleanup
    //

    if ( pregSession )
    {
        Reg_CloseSession( pregSession );
    }

    //  don't free blobs -- they're on stack

    if ( freadRegInfo )
    {
        Reg_FreeGlobalInfo( &regInfo, FALSE );
    }
    if ( freadRegAdapterInfo )
    {
        Reg_FreeAdapterInfo( &regAdapterInfo, FALSE );
    }

    DNSDBG( TRACE, (
        "Leave Dns_ReadUpdateInfo()\n"
        "\tPDN                  = %s\n"
        "\tAlternateNames       = %s\n"
        "\tAdapterName          = %s\n"
        "\tDNS servers          = %p\n"
        "\tDNS servers IP6      = %p\n"
        "\tRegister             = %d\n"
        "\tRegisterAdapterName  = %d\n"
        "\tRegisterAddrCount    = %d\n",

        pUpdateInfo->pszPrimaryDomainName,
        pUpdateInfo->pmszAlternateNames,
        pUpdateInfo->pszAdapterDomainName,
        pUpdateInfo->pDnsServerArray,
        pUpdateInfo->pDnsServerIp6Array,
        pUpdateInfo->fRegistrationEnabled,
        pUpdateInfo->fRegisterAdapterName,
        pUpdateInfo->RegistrationMaxAddressCount
        ));

    return  ERROR_SUCCESS;
}



VOID
Reg_FreeUpdateInfo(
    IN OUT  PREG_UPDATE_INFO    pUpdateInfo,
    IN      BOOL                fFreeBlob
    )
/*++

Routine Description:

    Free registry update info blob.

Arguments:

    pUpdateInfo -- update registry info blob to free

    fFreeBlob -- flag to free blob itself
        FALSE -- just free allocated data fields
        TRUE  -- also free blob itself

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNSDBG( TRACE, (
        "FreeRegUpdateInfo( %p )\n",
        pUpdateInfo ));

    //
    //  free data
    //      - PDN
    //      - adapter domain name
    //      - DNS server lists
    //

    if ( pUpdateInfo->pszPrimaryDomainName )
    {
        FREE_HEAP( pUpdateInfo->pszPrimaryDomainName );
    }
    if ( pUpdateInfo->pmszAlternateNames )
    {
        FREE_HEAP( pUpdateInfo->pmszAlternateNames );
    }
    if ( pUpdateInfo->pszAdapterDomainName )
    {
        FREE_HEAP( pUpdateInfo->pszAdapterDomainName );
    }
    if ( pUpdateInfo->pDnsServerArray )
    {
        FREE_HEAP( pUpdateInfo->pDnsServerArray );
    }
    if ( pUpdateInfo->pDnsServerIp6Array )
    {
        FREE_HEAP( pUpdateInfo->pDnsServerIp6Array );
    }

    //  free blob itself

    if ( fFreeBlob )
    {
        FREE_HEAP( pUpdateInfo );
    }
}



//
//  Special
//

DNS_STATUS
Reg_WriteLoopbackDnsServerList(
    IN      PSTR            pszAdapterName,
    IN      PREG_SESSION    pRegSession
    )
/*++

Routine Description:

    Write loopback IP as DNS server list.

Arguments:

    pszAdapterName -- adapter name (registry name)

    pRegSession -- registry session

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS  status;
    HKEY        hkeyAdapter = NULL;
    CHAR        adapterParamKey[ MAX_PATH ];
    CHAR        nameServerString[ IP4_ADDRESS_STRING_LENGTH+1 ];

    DNSDBG( TRACE, (
        "WriteLookupbackDnsServerList( %s )\n",
        pszAdapterName ));

    //
    //  open adapter key for write
    //

    strcpy( adapterParamKey, TCPIP_INTERFACES_KEY_A );
    strcat( adapterParamKey, pszAdapterName );

    status = RegOpenKeyExA(
                HKEY_LOCAL_MACHINE,
                adapterParamKey,
                0,
                KEY_READ | KEY_WRITE,
                & hkeyAdapter );

    if ( status != NO_ERROR )
    {
        return( status );
    }

    //
    //  write loopback address
    //

    strcpy( nameServerString, "127.0.0.1" );

    status = RegSetValueExA(
                hkeyAdapter,
                STATIC_NAME_SERVER_VALUE_A,
                0,
                REGTYPE_DNS_SERVER,
                (PBYTE) nameServerString,
                (strlen(nameServerString)+1) * sizeof(CHAR) );

    RegCloseKey( hkeyAdapter );

    return( status );
}



//
//  PDN Query
//

PSTR 
WINAPI
Reg_GetPrimaryDomainName(
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Get primary domain name (PDN).

Arguments:

    CharSet -- desired char set.

Return Value:

    Ptr to primary domain name in desired charset.

--*/
{
    DNS_STATUS  status;
    PSTR        pnameWire = NULL;
    PSTR        pnameReturn;

    status = Reg_ReadPrimaryDomainName(
                NULL,           // no session
                NULL,           // no regkey
                &pnameWire );

    if ( !pnameWire )
    {
        SetLastError( status );
        return  NULL;
    }

    //
    //  convert to desired char set
    //

    if ( CharSet == DnsCharSetWire )
    {
        return  pnameWire;
    }
    else
    {
        pnameReturn = Dns_NameCopyAllocate(
                            pnameWire,
                            0,
                            DnsCharSetWire,
                            CharSet );

        FREE_HEAP( pnameWire );
        return  pnameReturn;
    }
}



//
//  Hostname query
//

PSTR 
WINAPI
Reg_GetHostName(
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Get host name.

Arguments:

    CharSet -- desired char set.

Return Value:

    Ptr to host name in desired charset.

--*/
{
    PSTR        pnameWire = NULL;
    PSTR        pnameReturn;
    DNS_STATUS  status;

    //
    //  get hostname from registry
    //

    status = Reg_GetValue(
                NULL,           // no session
                NULL,           // no key
                RegIdHostName,
                REGTYPE_DNS_NAME,
                (PBYTE *) &pnameWire
                );

    if ( !pnameWire )
    {
        SetLastError( status );
        return  NULL;
    }

    //
    //  convert to desired char set
    //

    if ( CharSet == DnsCharSetWire )
    {
        return  pnameWire;
    }
    else
    {
        pnameReturn = Dns_NameCopyAllocate(
                            pnameWire,
                            0,
                            DnsCharSetWire,
                            CharSet );

        FREE_HEAP( pnameWire );
        return  pnameReturn;
    }
}



PSTR 
WINAPI
Reg_GetFullHostName(
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Get full host name.

Arguments:

    CharSet -- desired char set.

Return Value:

    Ptr to full host name in desired charset.

--*/
{
    PSTR        pnameWire = NULL;
    PSTR        pdomainWire = NULL;
    PSTR        presult = NULL;
    DNS_STATUS  status;
    CHAR        nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH+4 ];

    //
    //  get hostname from registry
    //

    status = Reg_GetValue(
                NULL,           // no session
                NULL,           // no key
                RegIdHostName,
                REGTYPE_DNS_NAME,
                (PBYTE *) &pnameWire
                );

    if ( !pnameWire )
    {
        SetLastError( status );
        return  NULL;
    }

    //
    //  get domain name from registry
    //

    status = Reg_ReadPrimaryDomainName(
                NULL,           // no session
                NULL,           // no regkey
                &pdomainWire );

    if ( !pdomainWire )
    {
        SetLastError( status );
        return  NULL;
    }

    //
    //  create appended name
    //      - wire format is narrow
    //
    //  allocate result in desired char set
    //

    if ( Dns_NameAppend_A(
            nameBuffer,
            DNS_MAX_NAME_BUFFER_LENGTH,
            pnameWire,
            pdomainWire ) )
    {
        presult = Dns_NameCopyAllocate(
                     nameBuffer,
                     0,
                     DnsCharSetWire,
                     CharSet );
    }

    //
    //  free registry allocations
    //

    FREE_HEAP( pnameWire );
    FREE_HEAP( pdomainWire );

    return  presult;
}



//
//  DWORD Get\Set
//

DWORD
Reg_ReadDwordValueFromGlobal(
    IN      DWORD           PropId
    )
/*++

Routine Description:

    Read DWORD from global.

    This is direct access to global through RegId,
    rather than by name.  

Arguments:

    PropId -- property ID of desired value

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDWORD  pdword;

    //
    //  validate PropId -- within DWORD array
    //

    if ( PropId > RegIdValueMax )
    {
        DNS_ASSERT( FALSE );
        return( 0 );
    }

    //
    //  get DWORD ptr and read value (if exists)
    //      

    pdword = RegDwordPtrArray[ PropId ];

    if ( !pdword )
    {
        DNS_ASSERT( FALSE );
        return( 0 );
    }

    return( *pdword );
}



DWORD
Reg_ReadDwordProperty(
    IN      DNS_REGID       RegId,
    IN      PWSTR           pwsAdapterName  OPTIONAL
    )
/*++

Routine Description:

    Read through to registry for DWORD\BOOL value.

    Simplified interface for DWORD reads.

Arguments:

    RegId -- registry ID of value

    pwsAdapterName -- adapter name if adapter specific registration
        value is desired
                              
Return Value:

    Value for global -- from registry or defaulted

--*/
{
    DWORD   value;

    //
    //  read value
    //

    Reg_GetDword(
        NULL,               // no session
        NULL,               // no key given
        pwsAdapterName,
        RegId,
        & value );

    return( value );
}



DNS_STATUS
WINAPI
Reg_SetDwordPropertyAndAlertCache(
    IN      PWSTR           pwsKey,
    IN      DWORD           RegId,
    IN      DWORD           dwValue
    )
/*++

Routine Description:

    Write DWORD property -- cause cache to reload config.

Arguments:

    pwsRey -- key or adapater name to set

    RegId -- reg id

    dwValue -- value to set

Return Value:

    None.

--*/
{
    DNS_STATUS  status;

    //  set value

    status = Reg_SetDwordValue(
                NULL,       // reserved
                NULL,       // no open key
                pwsKey,
                RegId,
                dwValue );

    //
    //  if reg write successful
    //      - poke cache
    //      - mark any local netinfo dirty
    //      

    if ( status == NO_ERROR )
    {
        DnsNotifyResolverEx(
            POKE_OP_UPDATE_NETINFO,
            0,
            POKE_COOKIE_UPDATE_NETINFO,
            NULL );

        NetInfo_MarkDirty();
    }

    return  status;
}



//
//  Environment variable configuration
//

BOOL
Reg_ReadDwordEnvar(
    IN      DWORD               Id,
    OUT     PENVAR_DWORD_INFO   pEnvar
    )
/*++

Routine Description:

    Read DWORD environment variable.

    Note:  this function read environment variables that allow
    per process control of registry configurable params.
    The environment variable is assumed to be the same
    as the regkey with Dns prepended ( Dns<regvalue name> ).

    Ex.  FilterClusterIp controlled with envar DnsFilterClusterIp.

Arguments:

    Id -- registry ID (registry.h) of environment value to read

    pEnvar -- ptr to blob to hold results

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DWORD   count;
    PWSTR   pnameBuffer;
    PWSTR   pvarBuffer;
    BOOL    found = FALSE;

    DNSDBG( TRACE, (
        "Dns_ReadDwordEnvar( %d, %p )\n",
        Id,
        pEnvar ));

    if ( Id > RegIdValueMax )
    {
        DNS_ASSERT( FALSE );
        return  FALSE;
    }

    //
    //  init struct (for not found)
    //

    pEnvar->Id    = Id;
    pEnvar->Value = 0;

    //
    //  prepend "Dns" to reg value name to create environment var name
    //

    pnameBuffer = (PWSTR) ALLOCATE_HEAP( 2 * (sizeof(WCHAR) * MAX_PATH) );
    if ( !pnameBuffer )
    {
        return  FALSE;
    }

    pvarBuffer = pnameBuffer + MAX_PATH;

    wcscpy( pnameBuffer, L"Dns" );
    wcscpy( &pnameBuffer[3], REGPROP_NAME(Id) );

    //
    //  lookup 
    //
    //  note:  no handling of values greater than MAX_PATH
    //      assuming busted string
    //
    //  DCR:  could add base discrimination (scan for non-digit)
    //      or try decimal first
    //      

    DNSDBG( TRACE, (
        "Dns_ReadDwordEnvar() looking up %S.\n",
        pnameBuffer ));

    count = GetEnvironmentVariableW(
                pnameBuffer,
                pvarBuffer,
                MAX_PATH );

    if ( count && count < MAX_PATH )
    {
        pEnvar->Value = wcstoul( pvarBuffer, NULL, 10 );
        found = TRUE;
    }

    pEnvar->fFound = found;

    FREE_HEAP( pnameBuffer );

    return  found;
}



#if 0
//
//  Remote resolver not currently supported
//

PWSTR
Reg_GetResolverAddress(
    VOID
    )
/*++

Routine Description:

    Get address (string form) of remote resolver.

Arguments:

    None

Return Value:

    Ptr to string of remote resolver name.

--*/
{
    PWSTR pnameResolver = NULL;

    Reg_GetValueEx(
        NULL,                   // no session
        NULL,                   // no key
        NULL,                   // no adapter
        RegIdRemoteResolver,
        REGTYPE_DNS_NAME,
        DNSREG_FLAG_GET_UNICODE | DNSREG_FLAG_DUMP_EMPTY,
        (PBYTE *) &pnameResolver
        );

    return pnameResolver;
}
#endif


//
//  End regfig.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\registry.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Domain Name System (DNS) API 

    Registry management routines.

Author:

    Jim Gilroy (jamesg)     March, 2000

Revision History:

--*/


#include "local.h"
#include "registry.h"


//
//  Globals
//
//  DWORD globals blob
//
//  g_IsRegReady protects needs init and protects (requires)
//  global init.
//
//  See registry.h for discussion of how these globals are
//  exposed both internal to the DLL and external.
//

DNS_GLOBALS_BLOB    DnsGlobals;

BOOL    g_IsRegReady = FALSE;

PWSTR   g_pwsRemoteResolver = NULL;


//
//  Property table
//

//
//  WARNING:  table must be in sync with DNS_REGID definitions
//
//  For simplicity I did not provide a separate index field and
//  a lookup function (or alternatively a function that returned
//  all the properties or a property pointer).
//
//  The DNS_REGID values ARE the INDEXES!
//  Hence the table MUST be in sync or the whole deal blows up
//  If you make a change to either -- you must change the other!
//

REG_PROPERTY    RegPropertyTable[] =
{
    //  Basic

    HOST_NAME                                   ,
        0                                       ,   // Default FALSE
            0                                   ,   // No policy
            1                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache

    DOMAIN_NAME                                 ,
        0                                       ,   // Default FALSE
            1                                   ,   // Policy
            0                                   ,   // No Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache

    DHCP_DOMAIN_NAME                            ,
        0                                       ,   // Default FALSE
            1                                   ,   // Policy
            0                                   ,   // No Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache

    ADAPTER_DOMAIN_NAME                         ,
        0                                       ,   // Default FALSE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            0                                   ,   // No Cache

    PRIMARY_DOMAIN_NAME                         ,
        0                                       ,   // Default FALSE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            0                                   ,   // No Cache

    PRIMARY_SUFFIX                              ,
        0                                       ,   // Default FALSE
            1                                   ,   // Policy
            1                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache

    ALTERNATE_NAMES                             ,
        0                                       ,   // Default NULL
            0                                   ,   // No Policy
            0                                   ,   // No Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache

    DNS_SERVERS                                 ,
        0                                       ,   // Default FALSE
            1                                   ,   // Policy
            0                                   ,   // Client
            0                                   ,   // TcpIp 
            0                                   ,   // No Cache

    SEARCH_LIST_KEY                             ,
        0                                       ,   // Default FALSE
            1                                   ,   // Policy
            1                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache

    UPDATE_ZONE_EXCLUSIONS                      ,
        0                                       ,   // Default 
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            0                                   ,   // No Cache

    //  Query

    QUERY_ADAPTER_NAME                          ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache
    USE_DOMAIN_NAME_DEVOLUTION                  ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            1                                   ,   // TcpIp 
            1                                   ,   // Cache
    PRIORITIZE_RECORD_DATA                      ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            1                                   ,   // TcpIp 
            1                                   ,   // Cache
    ALLOW_UNQUALIFIED_QUERY                     ,
        0                                       ,   // Default FALSE
            1                                   ,   // Policy
            1                                   ,   // Client
            1                                   ,   // TcpIp 
            1                                   ,   // Cache
    APPEND_TO_MULTI_LABEL_NAME                  ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache
    SCREEN_BAD_TLDS                             ,
        DNS_TLD_SCREEN_DEFAULT                  ,   // Default
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache
    SCREEN_UNREACHABLE_SERVERS                  ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache
    FILTER_CLUSTER_IP                           ,
        0                                       ,   // Default FALSE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache
    WAIT_FOR_NAME_ERROR_ON_ALL                  ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache
    USE_EDNS                                    ,
        //REG_EDNS_TRY                            ,   // Default TRY EDNS
        0                                       ,   // Default FALSE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache

    //  Update

    REGISTRATION_ENABLED                        ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // No Cache
    REGISTER_PRIMARY_NAME                       ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // No Cache
    REGISTER_ADAPTER_NAME                       ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // No Cache
    REGISTER_REVERSE_LOOKUP                     ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // No Cache
    REGISTER_WAN_ADAPTERS                       ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // No Cache
    REGISTRATION_OVERWRITES_IN_CONFLICT         ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // No Cache
    REGISTRATION_TTL                            ,
        REGDEF_REGISTRATION_TTL                 ,
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // No Cache
    REGISTRATION_REFRESH_INTERVAL               ,
        REGDEF_REGISTRATION_REFRESH_INTERVAL    ,
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // No Cache
    REGISTRATION_MAX_ADDRESS_COUNT              ,
        1                                       ,   // Default register 1 address
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // No Cache
    UPDATE_SECURITY_LEVEL                       ,
        DNS_UPDATE_SECURITY_USE_DEFAULT         ,
            1                                   ,   // Policy
            1                                   ,   // Client
            1                                   ,   // TcpIp 
            1                                   ,   // No Cache
    UPDATE_ZONE_EXCLUDE_FILE                    ,
        1                                       ,   // Default ON
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // No Cache
    UPDATE_TOP_LEVEL_DOMAINS                    ,
        0                                       ,   // Default OFF
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // No Cache

    //
    //  Backcompat
    //
    //  DCR:  once policy fixed, policy should be OFF on all backcompat
    //

    DISABLE_ADAPTER_DOMAIN_NAME                 ,
        0                                       ,   // Default FALSE
            0                                   ,   // Policy
            0                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache
    DISABLE_DYNAMIC_UPDATE                      ,
        0                                       ,   // Default FALSE
            0                                   ,   // Policy
            0                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache
    ENABLE_ADAPTER_DOMAIN_NAME_REGISTRATION     ,
        0                                       ,   // Default TRUE
            0                                   ,   // Policy
            0                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache
    DISABLE_REVERSE_ADDRESS_REGISTRATIONS       ,
        0                                       ,   // Default FALSE
            0                                   ,   // Policy
            0                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache
    DISABLE_WAN_DYNAMIC_UPDATE                  ,
        0                                       ,   // Default FALSE
            0                                   ,   // Policy OFF
            0                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache
    ENABLE_WAN_UPDATE_EVENT_LOG                 ,
        0                                       ,   // Default FALSE
            0                                   ,   // Policy OFF
            0                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache
    DISABLE_REPLACE_ADDRESSES_IN_CONFLICTS      ,
        0                                       ,   // Default FALSE
            0                                   ,   // Policy
            0                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache
    DEFAULT_REGISTRATION_TTL                    ,
        REGDEF_REGISTRATION_TTL                 ,
            0                                   ,   // Policy OFF
            0                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache
    DEFAULT_REGISTRATION_REFRESH_INTERVAL       ,
        REGDEF_REGISTRATION_REFRESH_INTERVAL    ,
            0                                   ,   // Policy
            0                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache
    MAX_NUMBER_OF_ADDRESSES_TO_REGISTER         ,
        1                                       ,   // Default register 1 address
            0                                   ,   // Policy
            0                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache


    //  Micellaneous

    NT_SETUP_MODE                               ,
        0                                       ,   // Default FALSE
            0                                   ,   // No policy
            0                                   ,   // Client
            0                                   ,   // No TcpIp 
            0                                   ,   // No Cache

    DNS_TEST_MODE                               ,
        0                                       ,   // Default FALSE
            0                                   ,   // No policy
            0                                   ,   // No Client
            0                                   ,   // No TcpIp 
            1                                   ,   // In Cache

    REMOTE_DNS_RESOLVER                         ,
        0                                       ,   // Default FALSE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // In Cache

    //  Resolver

    MAX_CACHE_SIZE                              ,
        1000                                    ,   // Default 1000 record sets
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache

    MAX_CACHE_TTL                               ,
        86400                                   ,   // Default 1 day
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache

    MAX_NEGATIVE_CACHE_TTL                      ,
        900                                     ,   // Default 15 minutes
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache

    ADAPTER_TIMEOUT_LIMIT                       ,
        600                                     ,   // Default 10 minutes
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache

    SERVER_PRIORITY_TIME_LIMIT                  ,
        //3600                                    ,   // Default 1 hour
        //  DCR:  change once registry change notify
        //      while no change-notify, this is essentially registry
        //      check time so use 15 minutes
        900                                     ,   // Default 15 minutes
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache

    MAX_CACHED_SOCKETS                          ,
        10                                      ,   // Default 10
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache

    //  Multicast

    USE_MULTICAST                               ,
        0                                       ,   // Default OFF
        //1                                       ,   // Default ON
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache

    MULTICAST_ON_NAME_ERROR                     ,
        0                                       ,   // Default OFF
        //1                                       ,   // Default ON
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache

    USE_DOT_LOCAL_DOMAIN                        ,
        0                                       ,   // Default OFF
        //1                                       ,   // Default ON
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache

    LISTEN_ON_MULTICAST                         ,
        0                                       ,   // Default OFF
        //1                                       ,   // Default ON
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache

    //  Termination

    NULL,  0,  0, 0, 0, 0
};


//
//  Backward compatibility list
//
//  Maps new reg id to old reg id.
//  Flag fReverse indicates need to reverse (!) the value.
//

#define NO_BACK_VALUE   ((DWORD)(0xffffffff))

typedef struct _Backpat
{
    DWORD       NewId;
    DWORD       OldId;
    BOOL        fReverse;
}
BACKPAT;

BACKPAT BackpatArray[] =
{
    RegIdQueryAdapterName,
    RegIdDisableAdapterDomainName,
    TRUE,

    RegIdRegistrationEnabled,
    RegIdDisableDynamicUpdate,
    TRUE,

    RegIdRegisterAdapterName,
    RegIdEnableAdapterDomainNameRegistration,
    FALSE,
    
    RegIdRegisterReverseLookup,
    RegIdDisableReverseAddressRegistrations,
    TRUE,

    RegIdRegisterWanAdapters,
    RegIdDisableWanDynamicUpdate,
    TRUE,

    RegIdRegistrationOverwritesInConflict,
    RegIdDisableReplaceAddressesInConflicts,
    TRUE,

    RegIdRegistrationTtl,
    RegIdDefaultRegistrationTTL,
    FALSE,
    
    RegIdRegistrationRefreshInterval,
    RegIdDefaultRegistrationRefreshInterval,
    FALSE,

    RegIdRegistrationMaxAddressCount,
    RegIdMaxNumberOfAddressesToRegister,
    FALSE,

    NO_BACK_VALUE, 0, 0
};





VOID
Reg_Init(
    VOID
    )
/*++

Routine Description:

    Init DNS registry stuff.

    Essentially this means get system version info.

Arguments:

    None.

Globals:

    Sets the system info globals above:
        g_IsWin9X
        g_IsWin2000
        g_IsNT4
        g_IsWorkstation
        g_IsServer
        g_IsDomainController
        g_IsRegReady

Return Value:

    None.

--*/
{
    OSVERSIONINFOEX osvi;
    BOOL            bversionInfoEx;

    //
    //  do this just once
    //

    if ( g_IsRegReady )
    {
        return;
    }

    //
    //  code validity check
    //  property table should have entry for every reg value plus an
    //      extra one for the terminator
    //

#if DBG
    DNS_ASSERT( (RegIdValueCount+1)*sizeof(REG_PROPERTY) ==
            sizeof(RegPropertyTable) );
#endif

    //
    //  clear globals blob
    //
    //  DCR:  warning clearing DnsGlobals but don't read them all
    //      this is protected by read-once deal but still kind of
    //

    RtlZeroMemory(
        & DnsGlobals,
        sizeof(DnsGlobals) );

    //
    //  get version info
    //      - Win2000 supports OSVERSIONINFOEX
    //      try first with it, then fail back to standard
    //

    ZeroMemory( &osvi, sizeof(OSVERSIONINFOEX) );

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    bversionInfoEx = GetVersionEx( (OSVERSIONINFO*) &osvi );
    if ( !bversionInfoEx)
    {
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        if ( ! GetVersionEx( (OSVERSIONINFO *) &osvi ) )
        {
            DNS_ASSERT( FALSE );
            return;
        }
    }

#if DNSBUILDOLD
    //
    //  suck out system info
    //
    //  if Win9x -- that's it done
    //

    if ( osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS )
    {
        g_IsWin9X = TRUE;
        goto Done;
    }

    //
    //  assume anything else is NT, this gets around WIN32 tag
    //  leaving in Win64 versions
    //
    //  DCR:  WinCE issue here?
    //  DCR:  Win64 issue here?
    //

    DNS_ASSERT( osvi.dwPlatformId == VER_PLATFORM_WIN32_NT );

    if ( osvi.dwMajorVersion >= 5 )
    {
        g_IsWin2000 = TRUE;
    }
    else
    {
        g_IsNT4 = TRUE;
    }
#else

    //  set Win2K flag
    //      - easier to keep this flag then to #ifdef the remaining uses
          
    g_IsWin2000 = TRUE;
#endif

    //
    //  get system type -- workstation, server, DC
    //

    if ( bversionInfoEx )
    {
        if ( osvi.wProductType == VER_NT_WORKSTATION )
        {
            g_IsWorkstation = TRUE;
        }
        else if ( osvi.wProductType == VER_NT_SERVER )
        {
            g_IsServer = TRUE;
        }
        else if ( osvi.wProductType == VER_NT_DOMAIN_CONTROLLER )
        {
            g_IsServer = TRUE;
            g_IsDomainController = TRUE;
        }
        ELSE_ASSERT( FALSE );
    }

#if DNSNT4
    //
    //  no osviEX (NT4), must suck product from registry
    //

    else
    {
        HKEY    hkey = NULL;
        CHAR    productType[MAX_PATH] = "0";
        DWORD   bufLength = MAX_PATH;

        RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                L"SYSTEM\\CurrentControlSet\\Control\\ProductOptions",
                0,
                KEY_QUERY_VALUE,
                & hkey );

        if ( !hkey )
        {
            DNS_ASSERT( FALSE );
            goto Done;
        }

        RegQueryValueExA(
                hkey,
                "ProductType",
                NULL,
                NULL,
                (LPBYTE) productType,
                & bufLength );

        RegCloseKey( hkey );

        if ( lstrcmpi( "WINNT", productType) == 0 )
        {
            g_IsWorkstation = TRUE;
        }
        else if ( lstrcmpi( "SERVERNT", productType) == 0 )
        {
            g_IsServer = TRUE;
        }
        else if ( lstrcmpi( "LANMANNT", productType) == 0 )
        {
            g_IsDomainController = TRUE;
        }
    }

Done:
#endif
    
    g_IsRegReady = TRUE;

#if DNSBUILDOLD
    DNSDBG( REGISTRY, (
        "DNS API registry init:\n"
        "\tWin9X    = %d\n"
        "\tNT4      = %d\n"
        "\tWin2000  = %d\n"
        "\tWorksta  = %d\n"
        "\tServer   = %d\n"
        "\tDC       = %d\n",
        g_IsWin9X,
        g_IsNT4,
        g_IsWin2000,
        g_IsWorkstation,
        g_IsServer,
        g_IsDomainController ));
#endif
    DNSDBG( REGISTRY, (
        "DNS registry init:\n"
        "\tWin2000  = %d\n"
        "\tWorksta  = %d\n"
        "\tServer   = %d\n"
        "\tDC       = %d\n",
        g_IsWin2000,
        g_IsWorkstation,
        g_IsServer,
        g_IsDomainController ));
}





//
//  Registry table routines
//

PSTR 
regValueNameForId(
    IN      DWORD           RegId
    )
/*++

Routine Description:

    Return registry value name for reg ID

Arguments:

    RegId     -- ID for value

Return Value:

    Ptr to reg value name.
    NULL on error.

--*/
{
    DNSDBG( REGISTRY, (
        "regValueNameForId( id=%d )\n",
        RegId ));

    //
    //  validate ID
    //

    if ( RegId > RegIdValueMax )
    {
        return( NULL );
    }

    //
    //  index into table
    //

    return( (PSTR)REGPROP_NAME(RegId) );
}


DWORD
checkBackCompat(
    IN      DWORD           NewId,
    OUT     PBOOL           pfReverse
    )
/*++

Routine Description:

    Check if have backward compatible regkey.

Arguments:

    NewId -- id to check for old backward compatible id

    pfReverse -- addr to receive reverse flag

Return Value:

    Reg Id of old backward compatible value.
    NO_BACK_VALUE if no old value.

--*/
{
    DWORD   i = 0;
    DWORD   id;

    //
    //  loop through backcompat list looking for value
    //

    while ( 1 )
    {
        id = BackpatArray[i].NewId;

        if ( id == NO_BACK_VALUE )
        {
            return( NO_BACK_VALUE );
        }
        if ( id != NewId )
        {
            i++;
            continue;    
        }

        //  found value in backcompat array

        break;
    }

    *pfReverse = BackpatArray[i].fReverse;

    return  BackpatArray[i].OldId;
}



//
//  Registry session handle
//

DNS_STATUS
WINAPI
Reg_OpenSession(
    OUT     PREG_SESSION    pRegSession,
    IN      DWORD           Level,
    IN      DWORD           RegId
    )
/*++

Routine Description:

    Open registry for DNS client info.

Arguments:

    pRegSession -- ptr to unitialize reg session blob

    Level -- level of access to get

    RegId -- ID of value we're interested in

Return Value:

    None.

--*/
{
    DWORD           status = NO_ERROR;
    HKEY            hkey = NULL;
    DWORD           disposition;

    //  auto init

    Reg_Init();

    //
    //  clear handles
    //

    RtlZeroMemory(
        pRegSession,
        sizeof( REG_SESSION ) );


    //
    //  DCR:  handle multiple access levels   
    //
    //  For know assume that if getting access to "standard"
    //  section we'll need both policy and regular.
    //  

    //
    //  Win95
    //      - TCP/IP location slightly different than NT
    //
    //  Devnote:  we could collapse these using all _A calls
    //      (all key names are ANSI) but we gain some perf
    //      by calling NT wide;  and since we currently have
    //      to do that, it seems worth it
    //

#if DNSWIN9X
    if ( g_IsWin9X )
    {
        status = RegCreateKeyExA(
                        HKEY_LOCAL_MACHINE,
                        WIN95_TCPIP_KEY_A,
                        0,
                        "Class",
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ,
                        NULL,
                        &hkey,
                        &disposition );
    }
    else
#endif

    //
    //  NT
    //  - Win2000
    //      - open TCPIP
    //      note, always open TCPIP as may not be any policy
    //      for some or all of our desired reg values, even
    //      if policy key is available
    //      - open policy (only if standard successful)
    //
    //  - NT4
    //      - open TCPIP (no policy)
    //

    {
        status = RegCreateKeyExW(
                        HKEY_LOCAL_MACHINE,
                        TCPIP_PARAMETERS_KEY,
                        0,
                        L"Class",
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ,
                        NULL,
                        &hkey,
                        &disposition );

        if ( !g_IsWin2000  ||  status != ERROR_SUCCESS )
        {
            goto Done;
        }

#ifdef DNSCLIENTKEY
        //  open DNS client key
        //
        //  DCR:  currently no DNSClient regkey

        RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            DNS_CLIENT_KEY,
            0,
            KEY_READ,
            & pRegSession->hClient );
#endif

        //  open DNS cache key

        RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            DNS_CACHE_KEY,
            0,
            KEY_READ,
            & pRegSession->hCache );

        //  open DNS policy key

        RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            DNS_POLICY_KEY,
            0,
            KEY_READ,
            & pRegSession->hPolicy );
    }

Done:

    //
    //  all OS versions return TCP/IP key
    //

    if ( status == ERROR_SUCCESS )
    {
        pRegSession->hTcpip = hkey;
    }
    else
    {
        Reg_CloseSession( pRegSession );
    }

    DNSDBG( TRACE, (
        "Leave:  Reg_OpenSession( s=%d, t=%p, p=%p, c=%p )\n",
        status,
        pRegSession->hTcpip,
        pRegSession->hPolicy,
        pRegSession->hClient ));

    return( status );
}



VOID
WINAPI
Reg_CloseSession(
    IN OUT  PREG_SESSION    pRegSession
    )
/*++

Routine Description:

    Close registry session handle.

    This means close underlying regkeys.

Arguments:

    pSessionHandle -- ptr to registry session handle

Return Value:

    None.

--*/
{
    //
    //  allow sloppy cleanup
    //

    if ( !pRegSession )
    {
        return;
    }

    //
    //  close any non-NULL handles
    //

    if ( pRegSession->hPolicy )
    {
        RegCloseKey( pRegSession->hPolicy );
    }
    if ( pRegSession->hTcpip )
    {
        RegCloseKey( pRegSession->hTcpip );
    }
#ifdef DNSCLIENTKEY
    if ( pRegSession->hClient )
    {
        RegCloseKey( pRegSession->hClient );
    }
#endif
    if ( pRegSession->hCache )
    {
        RegCloseKey( pRegSession->hCache );
    }

    //
    //  clear handles (just for safety)
    //

    RtlZeroMemory(
        pRegSession,
        sizeof(REG_SESSION) );
}



//
//  Registry reading routines
//

DNS_STATUS
Reg_GetDword(
    IN      PREG_SESSION    pRegSession,    OPTIONAL
    IN      HKEY            hRegKey,        OPTIONAL
    IN      PWSTR           pwsKeyName,     OPTIONAL
    IN      DWORD           RegId,
    OUT     PDWORD          pResult
    //OUT     PDWORD          pfRead
    )
/*++

Routine Description:

    Read REG_DWORD value from registry.

    //
    //  DCR:  do we need to expose location result?
    //      (explicit, policy, defaulted)
    //

Arguments:

    pRegSession -- ptr to reg session already opened (OPTIONAL)

    hRegKey     -- explicit regkey

    pwsKeyName  -- key name OR dummy key 

    RegId     -- ID for value

    pResult     -- addr of DWORD to recv result

    pfRead      -- addr to recv result of how value read
                0 -- defaulted
                1 -- read
        Currently just use ERROR_SUCCESS to mean read rather
        than defaulted.

Return Value:

    ERROR_SUCCESS on success.
    ErrorCode on failure -- value is then defaulted.

--*/
{
    DNS_STATUS      status;
    REG_SESSION     session;
    PREG_SESSION    psession = pRegSession;
    PBYTE           pname;
    DWORD           regType = REG_DWORD;
    DWORD           dataLength = sizeof(DWORD);
    HKEY            hkey;
    HKEY            hlocalKey = NULL;


    DNSDBG( REGISTRY, (
        "Reg_GetDword( s=%p, k=%p, a=%p, id=%d )\n",
        pRegSession,
        hRegKey,
        pwsKeyName,
        RegId ));

    //  auto init

    Reg_Init();

    //
    //  clear result for error case
    //

    *pResult = 0;

    //
    //  get proper regval name
    //      - wide for NT
    //      - narrow for 9X
    //

    pname = regValueNameForId( RegId );
    if ( !pname )
    {
        DNS_ASSERT( FALSE );
        return( ERROR_INVALID_PARAMETER );
    }

    //
    //  DCR:  can use function pointers for wide narrow
    //

    //
    //  three paradigms
    //
    //  1) specific key (adapter or something else)
    //      => use it
    //
    //  2) specific key name (adapter or dummy key location)
    //      => open key
    //      => use it
    //      => close 
    //
    //  3) session -- passed in or created (default)
    //      => use pRegSession or open new
    //      => try policy first then TCPIP parameters
    //      => close if open
    //

    if ( hRegKey )
    {
        hkey = hRegKey;
    }

    else if ( pwsKeyName )
    {
        hkey = Reg_CreateKey(
                    pwsKeyName,
                    FALSE       // read access
                    );
        if ( !hkey )
        {
            status = GetLastError();
            goto Done;
        }
        hlocalKey = hkey;
    }

    else
    {
        //  open reg handle if not open
    
        if ( !psession )
        {
            status = Reg_OpenSession(
                            &session,
                            0,              // standard level
                            RegId         // target key
                            );
            if ( status != ERROR_SUCCESS )
            {
                goto Done;
            }
            psession = &session;
        }

        //  try policy section -- if available

        hkey = psession->hPolicy;

        if ( hkey && REGPROP_POLICY(RegId) )
        {
            //status = DnsShimRegQueryValueExW(
            status = RegQueryValueExW(
                        hkey,
                        (PWSTR) pname,
                        0,
                        & regType,
                        (PBYTE) pResult,
                        & dataLength
                        );
            if ( status == ERROR_SUCCESS )
            {
                goto DoneSuccess;
            }
        }

        //  unsuccessful -- try DnsClient

#ifdef DNSCLIENTKEY
        hkey = psession->hClient;
        if ( hkey && REGPROP_CLIENT(RegId) )
        {
            //status = DnsShimRegQueryValueExW(
            status = RegQueryValueExW(
                        hkey,
                        (PWSTR) pname,
                        0,
                        & regType,
                        (PBYTE) pResult,
                        & dataLength
                        );
            if ( status == ERROR_SUCCESS )
            {
                goto DoneSuccess;
            }
        }
#endif

        //  unsuccessful -- try DnsCache

        hkey = psession->hCache;
        if ( hkey && REGPROP_CACHE(RegId) )
        {
            //status = DnsShimRegQueryValueExW(
            status = RegQueryValueExW(
                        hkey,
                        (PWSTR) pname,
                        0,
                        & regType,
                        (PBYTE) pResult,
                        & dataLength
                        );
            if ( status == ERROR_SUCCESS )
            {
                goto DoneSuccess;
            }
        }

        //  unsuccessful -- try TCPIP key
        //      - if have open session it MUST include TCPIP key

        hkey = psession->hTcpip;
        if ( hkey && REGPROP_TCPIP(RegId) )
        {
            //status = DnsShimRegQueryValueExW(
            status = RegQueryValueExW(
                        hkey,
                        (PWSTR) pname,
                        0,
                        & regType,
                        (PBYTE) pResult,
                        & dataLength
                        );
            if ( status == ERROR_SUCCESS )
            {
                goto DoneSuccess;
            }
        }

        status = ERROR_FILE_NOT_FOUND;
        goto Done;
    }

    //
    //  explict key (passed in or from name)
    //

    if ( hkey )
    {
        //status = DnsShimRegQueryValueExW(
        status = RegQueryValueExW(
                    hkey,
                    (PWSTR) pname,
                    0,
                    & regType,
                    (PBYTE) pResult,
                    & dataLength
                    );
    }
    ELSE_ASSERT_FALSE;

Done:

    //
    //  if value not found, check for backward compatibility value
    //

    if ( status != ERROR_SUCCESS )
    {
        DWORD   oldId;
        BOOL    freverse;

        oldId = checkBackCompat( RegId, &freverse );

        if ( oldId != NO_BACK_VALUE )
        {
            DWORD   backValue;

            status = Reg_GetDword(
                        psession,
                        ( psession ) ? NULL : hkey,
                        ( psession ) ? NULL : pwsKeyName,
                        oldId,
                        & backValue );

            if ( status == ERROR_SUCCESS )
            {
                if ( freverse )
                {
                    backValue = !backValue;
                }
                *pResult = backValue;
            }
        }
    }

    //  default the value if read failed
    
    if ( status != ERROR_SUCCESS )
    {
        *pResult = REGPROP_DEFAULT( RegId );
    }

DoneSuccess:

    //  cleanup any regkey's opened

    if ( psession == &session )
    {
        Reg_CloseSession( psession );
    }

    else if ( hlocalKey )
    {
        RegCloseKey( hlocalKey );
    }

    return( status );
}



//
//  DCR_CLEANUP:  cleanup Reg_ReadValue()
//      this is a slightly altered version of Glenn's
//      routine to "do it all" -- stripped of the
//      unnecessary Win9x flag;
//      it does not do policy or use the RegHandle yet
//
//  DCR_PERF:  it also makes a bunch of unnecessary
//      heap allocations
//

DNS_STATUS
privateRegReadValue(
    IN      HKEY            hKey,
    IN      DWORD           RegId,
    IN      DWORD           Flag,
    OUT     PBYTE *         ppBuffer,
    OUT     PDWORD          pBufferLength
    )
/*++

Routine Description:

Arguments:

    hKey -- handle of the key whose value field is retrieved.

    RegId -- reg value ID, assumed to be validated (in table)

    ppBuffer -- ptr to address to receive buffer ptr

    pBufferLength -- addr to receive buffer length

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DWORD   status;
    PSTR    pname;
    DWORD   valueType = 0;      // prefix
    DWORD   valueSize = 0;      // prefix
    PBYTE   pdataBuffer;
    PBYTE   pallocBuffer = NULL;


    //
    //  query for buffer size
    //

    pname = (PSTR) REGPROP_NAME( RegId );

    //status = DnsShimRegQueryValueExW(
    status = RegQueryValueExW(
                hKey,
                (PWSTR) pname,
                0,
                &valueType,
                NULL,
                &valueSize );
    
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    //
    //  setup result buffer   
    //

    switch( valueType )
    {
    case REG_DWORD:
        pdataBuffer = (PBYTE) ppBuffer;
        break;

    case REG_SZ:
    case REG_MULTI_SZ:
    case REG_EXPAND_SZ:
    case REG_BINARY:

        //  if size is zero, still allocate empty string
        //      - min alloc DWORD
        //          - can't possibly alloc smaller
        //          - good clean init to zero includes MULTISZ zero
        //          - need at least WCHAR string zero init
        //          and much catch small regbinary (1,2,3)
        
        if ( valueSize <= sizeof(DWORD) )
        {
            valueSize = sizeof(DWORD);
        }

        pallocBuffer = pdataBuffer = ALLOCATE_HEAP( valueSize );
        if ( !pdataBuffer )
        {
            return( DNS_ERROR_NO_MEMORY );
        }

        *(PDWORD)pdataBuffer = 0;
        break;

    default:
        return( ERROR_INVALID_PARAMETER );
    }

    //
    //  query for data
    //

    //status = DnsShimRegQueryValueExW(
    status = RegQueryValueExW(
                hKey,
                (PWSTR) pname,
                0,
                &valueType,
                pdataBuffer,
                &valueSize );

    //
    //  setup return buffer
    //

    switch( valueType )
    {
    case REG_DWORD:
    case REG_BINARY:
        break;

    case REG_SZ:
    case REG_EXPAND_SZ:
    case REG_MULTI_SZ:

        //
        //  dump empty strings?
        //
        //  note:  we always allocate at least a DWORD and
        //  set it NULL, so rather than a complex test for
        //  different reg types and char sets, can just test
        //  if that DWORD is still NULL
        //
        //  DCR:  do we want to screen whitespace-empty strings
        //      - example blank string
        //

        if ( Flag & DNSREG_FLAG_DUMP_EMPTY )
        {
            if ( valueSize==0 ||
                 *(PDWORD)pdataBuffer == 0 )
            {
                status = ERROR_INVALID_DATA;
                goto Cleanup;
            }
        }

        //
        //  by default we return strings as UTF8
        //
        //  if flagged, return in unicode
        //

        if ( Flag & DNSREG_FLAG_GET_UNICODE )
        {
            // no-op, keep unicode string
        }

        //
        //  do default convert to UTF8
        //

        else
        {
            PBYTE putf8Buffer = ALLOCATE_HEAP( valueSize * 2 );
            if ( !putf8Buffer )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Cleanup;
            }

            if ( !Dns_UnicodeToUtf8(
                        (PWSTR) pdataBuffer,
                        valueSize / sizeof(WCHAR),
                        putf8Buffer,
                        valueSize * 2 ) )
            {
                FREE_HEAP( putf8Buffer );
                status = ERROR_INVALID_DATA;
                goto Cleanup;
            }
            FREE_HEAP( pallocBuffer );
            pallocBuffer = NULL;
            pdataBuffer = putf8Buffer;
        }
        break;

    default:
        break;
    }

Cleanup:

    //
    //  set return
    //      - REG_DWORD writes DWORD to ppBuffer directly
    //      - otherwise ppBuffer set to allocated buffer ptr
    //  or cleanup
    //      - on failure dump allocated buffer
    //

    if ( status == ERROR_SUCCESS )
    {
        if ( valueType != REG_DWORD )
        {
            *ppBuffer = pdataBuffer;
        }
        *pBufferLength = valueSize;
    }
    else
    {
        *ppBuffer = NULL;
        *pBufferLength = 0;
        FREE_HEAP( pallocBuffer );
    }

    return( status );
}



DNS_STATUS
Reg_GetValueEx(
    IN      PREG_SESSION    pRegSession,    OPTIONAL
    IN      HKEY            hRegKey,        OPTIONAL
    IN      LPSTR           pwsAdapter,     OPTIONAL
    IN      DWORD           RegId,
    IN      DWORD           ValueType,
    IN      DWORD           Flag,
    OUT     PBYTE *         ppBuffer
    )
/*++

Routine Description:

Arguments:

    pRegSession -- ptr to registry session, OPTIONAL

    hRegKey     -- handle to open regkey OPTIONAL

    pwsAdapter  -- name of adapter to query under OPTIONAL

    RegId     -- value ID

    ValueType   -- reg type of value

    Flag        -- flags with tweaks to lookup

    ppBuffer    -- addr to receive buffer ptr

        Note, for REG_DWORD, DWORD data is written directly to this
        location instead of a buffer being allocated and it's ptr
        being written.

Return Value:

    ERROR_SUCCESS if successful.
    Registry error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_FILE_NOT_FOUND;
    REG_SESSION     session;
    PREG_SESSION    psession = pRegSession;
    PBYTE           pname;
    DWORD           regType = REG_DWORD;
    DWORD           dataLength;
    HKEY            hkey;
    HKEY            hadapterKey = NULL;


    DNSDBG( REGISTRY, (
        "Reg_GetValueEx( s=%p, k=%p, id=%d )\n",
        pRegSession,
        hRegKey,
        RegId ));

    ASSERT( !pwsAdapter );

    //  auto init

    Reg_Init();

    //
    //  get proper regval name
    //      - wide for NT
    //      - narrow for 9X
    //

    pname = regValueNameForId( RegId );
    if ( !pname )
    {
        DNS_ASSERT( FALSE );
        status = ERROR_INVALID_PARAMETER;
        goto FailedDone;
    }

    //
    //  DCR:  can use fucntion pointers for wide narrow
    //

    //
    //  two paradigms
    //
    //  1) specific key (adapter or something else)
    //      => use it
    //      => open adapter subkey if necessary
    //
    //  2) standard
    //      => try policy first, then DNSCache, then TCPIP
    //      => use pRegSession or open it
    //

    if ( hRegKey )
    {
        hkey = hRegKey;

        //  need to open adapter subkey

        if ( pwsAdapter )
        {
            status = RegOpenKeyExA(
                        hkey,
                        (PCSTR) pwsAdapter,
                        0,
                        KEY_QUERY_VALUE,
                        & hadapterKey );

            if ( status != ERROR_SUCCESS )
            {
                goto FailedDone;
            }
        }
    }

    else
    {
        //  open reg handle if not open
    
        if ( !pRegSession )
        {
            status = Reg_OpenSession(
                            &session,
                            0,            // standard level
                            RegId         // target key
                            );
            if ( status != ERROR_SUCCESS )
            {
                goto FailedDone;
            }
            psession = &session;
        }

        //  try policy section -- if available

        hkey = psession->hPolicy;

        if ( hkey && REGPROP_POLICY(RegId) )
        {
            status = privateRegReadValue(
                            hkey,
                            RegId,
                            Flag,
                            ppBuffer,
                            & dataLength
                            );
            if ( status == ERROR_SUCCESS )
            {
                goto Done;
            }
        }

        //  try DNS cache -- if available

        hkey = psession->hCache;

        if ( hkey && REGPROP_CACHE(RegId) )
        {
            status = privateRegReadValue(
                            hkey,
                            RegId,
                            Flag,
                            ppBuffer,
                            & dataLength
                            );
            if ( status == ERROR_SUCCESS )
            {
                goto Done;
            }
        }

        //  unsuccessful -- use TCPIP key

        hkey = psession->hTcpip;
        if ( !hkey )
        {
            goto Done;
        }
    }

    //
    //  explict key OR standard key case
    //

    status = privateRegReadValue(
                    hkey,
                    RegId,
                    Flag,
                    ppBuffer,
                    & dataLength
                    );
    if ( status == ERROR_SUCCESS )
    {
        goto Done;
    }

FailedDone:

    //
    //  if failed
    //      - for REG_DWORD, default the value
    //      - for strings, ensure NULL return buffer
    //      this takes care of cases where privateRegReadValue()
    //      never got called
    //

    if ( status != ERROR_SUCCESS )
    {
        if ( ValueType == REG_DWORD )
        {
            *(PDWORD) ppBuffer = REGPROP_DEFAULT( RegId );
        }
        else
        {
            *ppBuffer = NULL;
        }
    }

Done:

    //  cleanup any regkey's opened

    if ( psession == &session )
    {
        Reg_CloseSession( psession );
    }

    if ( hadapterKey )
    {
        RegCloseKey( hadapterKey );
    }

    return( status );
}




DNS_STATUS
Reg_GetIpArray(
    IN      PREG_SESSION    pRegSession,    OPTIONAL
    IN      HKEY            hRegKey,        OPTIONAL
    IN      LPSTR           pwsAdapter,     OPTIONAL
    IN      DWORD           RegId,
    IN      DWORD           ValueType,
    OUT     PIP_ARRAY *     ppIpArray
    )
/*++

Routine Description:

Arguments:

    pRegSession -- ptr to registry session, OPTIONAL

    hRegKey     -- handle to open regkey OPTIONAL

    pwsAdapter  -- name of adapter to query under OPTIONAL

    RegId     -- value ID

    ValueType   -- currently ignored, but could later use
                    to distinguish REG_SZ from REG_MULTI_SZ
                    processing

    ppIpArray   -- addr to receive IP array ptr
                    - array is allocated with Dns_Alloc(),
                    caller must free with Dns_Free()

Return Value:

    ERROR_SUCCESS if successful.
    Registry error code on failure.

--*/
{
    DNS_STATUS      status;
    PSTR            pstring = NULL;

    DNSDBG( REGISTRY, (
        "Reg_GetIpArray( s=%p, k=%p, id=%d )\n",
        pRegSession,
        hRegKey,
        RegId ));

    //
    //  make call to get IP array as string
    //

    status = Reg_GetValueEx(
                pRegSession,
                hRegKey,
                pwsAdapter,
                RegId,
                REG_SZ,         // only supported type is REG_SZ
                0,              // no flag
                & pstring );

    if ( status != ERROR_SUCCESS )
    {
        ASSERT( pstring == NULL );
        return( status );
    }

    //
    //  convert from string to IP array
    //
    //  note:  this call is limited to a parsing limit
    //      but it is a large number suitable for stuff
    //      like DNS server lists
    //
    //  DCR:  use IP array builder for local IP address
    //      then need Dns_CreateIpArrayFromMultiIpString()
    //      to use count\alloc method when buffer overflows
    //

    status = Dns_CreateIpArrayFromMultiIpString(
                    pstring,
                    ppIpArray );

    //  cleanup

    if ( pstring )
    {
        FREE_HEAP( pstring );
    }

    return( status );
}




//
//  Registry writing routines
//

HKEY
WINAPI
Reg_CreateKey(
    IN      PWSTR           pwsKeyName,
    IN      BOOL            bWrite
    )
/*++

Routine Description:

    Open registry key.

    The purpose of this routine is simply to functionalize
    opening with\without an adapter name.
    So caller can pass through adapter name argument instead
    of building key name or doing two opens for adapter
    present\absent.

    This is NT only.

Arguments:

    pwsKeyName -- key "name"
        this is one of the REGKEY_X from registry.h
        OR
        adapter name

    bWrite -- TRUE for write access, FALSE for read

Return Value:

    New opened key.

--*/
{
    HKEY    hkey = NULL;
    DWORD   disposition;
    DWORD   status;
    PWSTR   pnameKey;
    WCHAR   nameBuffer[ MAX_PATH ];

    //
    //  don't bother for Win9x
    //
    //  DCR_QUESTION:  any need for use with Win9x
    //

#if DNSWIN9X
    if ( g_IsWin9X )
    {
        ASSERT( FALSE );
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
    }
#endif

    //
    //  determine key name
    //
    //  this is either DNSKEY_X dummy pointer from registry.h
    //      OR
    //  is an adapter name; 
    //
    //      - if adapter given, open under it
    //          adapters are under TCPIP\Interfaces
    //      - any other specific key
    //      - default is TCPIP params key
    //
    //  note:  if if grows too big, turn into table
    //

    if ( pwsKeyName <= REGKEY_DNS_MAX )
    {
        if ( pwsKeyName == REGKEY_TCPIP_PARAMETERS )
        {
            pnameKey = TCPIP_PARAMETERS_KEY;
        }
        else if ( pwsKeyName == REGKEY_DNS_CACHE )
        {
            pnameKey = DNS_CACHE_KEY;
        }
        else if ( pwsKeyName == REGKEY_DNS_POLICY )
        {
            pnameKey = DNS_POLICY_KEY;
        }
        else if ( pwsKeyName == REGKEY_SETUP_MODE_LOCATION )
        {
            pnameKey = NT_SETUP_MODE_KEY;
        }
        else
        {
            pnameKey = TCPIP_PARAMETERS_KEY;
        }
    }

    else    // adapter name
    {
        wcscpy( nameBuffer, TCPIP_INTERFACES_KEY );
        wcscat( nameBuffer, pwsKeyName );

        pnameKey = nameBuffer;
    }

    //
    //  create\open key
    //

    if ( bWrite )
    {
        status = RegCreateKeyExW(
                        HKEY_LOCAL_MACHINE,
                        pnameKey,
                        0,
                        L"Class",
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        & hkey,
                        & disposition );
    }
    else
    {
        status = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    pnameKey,
                    0,
                    KEY_QUERY_VALUE,
                    & hkey );
    }

    if ( status != ERROR_SUCCESS )
    {
        SetLastError( status );
    }
    ELSE_ASSERT( hkey != NULL );

    return( hkey );
}



DNS_STATUS
WINAPI
Reg_SetDwordValueByName(
    IN      PVOID           pReserved,
    IN      HKEY            hRegKey,
    IN      PWSTR           pwsNameKey,     OPTIONAL
    IN      PWSTR           pwsNameValue,   OPTIONAL
    IN      DWORD           dwValue
    )
/*++

Routine Description:

    Set DWORD regkey.

Arguments:

    pReserved   -- reserved (may become session)

    hRegKey     -- existing key to set under OPTIONAL

    pwsNameKey  -- name of key or adapter to set under

    pwsNameValue -- name of reg value to set

    dwValue     -- value to set

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    HKEY        hkey;
    DNS_STATUS  status;

    //
    //  don't bother for Win9x
    //
#if DNSWIN9X
    if ( g_IsWin9X )
    {
        ASSERT( FALSE );
        return( ERROR_INVALID_PARAMETER );
    }
#endif

    //
    //  open key, if not provided
    //      - if adapter given, open under it
    //      - otherwise TCPIP params key
    //

    hkey = hRegKey;

    if ( !hkey )
    {
        hkey = Reg_CreateKey(
                    pwsNameKey,
                    TRUE            // open for write
                    );
        if ( !hkey )
        {
            return( GetLastError() );
        }
    }

    //
    //  write back value
    //

    status = RegSetValueExW(
                hkey,
                pwsNameValue,
                0,
                REG_DWORD,
                (LPBYTE) &dwValue,
                sizeof(DWORD) );

    if ( !hRegKey )
    {
        RegCloseKey( hkey );
    }

    return  status;
}



DNS_STATUS
WINAPI
Reg_SetDwordValue(
    IN      PVOID           pReserved,
    IN      HKEY            hRegKey,
    IN      PWSTR           pwsNameKey,     OPTIONAL
    IN      DWORD           RegId,
    IN      DWORD           dwValue
    )
/*++

Routine Description:

    Set DWORD regkey.

Arguments:

    pReserved   -- reserved (may become session)

    hRegKey     -- existing key to set under OPTIONAL

    pwsNameKey  -- name of key or adapter to set under

    RegId     -- id of value to set

    dwValue     -- value to set

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //
    //  write back value using name of id
    //

    return  Reg_SetDwordValueByName(
                pReserved,
                hRegKey,
                pwsNameKey,
                REGPROP_NAME( RegId ),
                dwValue );
}




#if DNSWIN9X
//
//  Removed with Win95 support
//  Further Win95 support is doubtful -- but this works if needed.
//

//
//  Registry shims
//  Win9x in not providing wide reg calls.
//

PCHAR
standardWideToAnsiConvert(
    IN      PWSTR           pWide,
    OUT     PCHAR           pAnsiBuf
    )
/*++

Routine Description:

    Standard conversion of wide to narron for shimming registry calls.

Arguments:

    pWide -- parameter in wide call

    pAnsiBuf -- buffer to hold ANSI param;  assumed to be max path

Return Value:

    Ptr to converted buffer.
    NULL if pWide NULL or error in conversion.

--*/
{
    DWORD   length;
    DWORD   result;

    //  no wide param, no ANSI param

    if ( !pWide )
    {
        return NULL;
    }

    //  copy\convert to ANSI buf

    length = MAX_PATH;

    result = Dns_StringCopy(
                pAnsiBuf,
                &length,
                (PSTR) pWide,
                0,              // calc length
                DnsCharSetUnicode,
                DnsCharSetAnsi
                );

    if ( result == 0 )
    {
        return( NULL );
    }
    else
    {
        return( pAnsiBuf );
    }
}



//WINADVAPI
LONG
WINAPI
DnsShimRegCreateKeyExW(
    IN      HKEY                    hKey,
    IN      LPCWSTR                 lpSubKey,
    IN      DWORD                   Reserved,
    IN      LPWSTR                  lpClass,
    IN      DWORD                   dwOptions,
    IN      REGSAM                  samDesired,
    IN      LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
    OUT     PHKEY                   phkResult,
    OUT     LPDWORD                 lpdwDisposition
    )
/*++

Routine Description:

    Shim RegCreateKeyExW()

Arguments:

    See SDK doc.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    //  for NT it's a dumb stub

    if ( !g_IsWin9X )
    {
        return  RegCreateKeyExW(
                        hKey,
                        lpSubKey,
                        Reserved,
                        lpClass,
                        dwOptions,
                        samDesired,
                        lpSecurityAttributes,
                        phkResult,
                        lpdwDisposition );
    }

    //  for Win9x, convert to ANSI and call

    else
    {
        PCHAR   pclass;
        PCHAR   psubKey;
        CHAR    class[ MAX_PATH ];
        CHAR    subKey[ MAX_PATH ];

        psubKey = standardWideToAnsiConvert(
                        (PWSTR) lpSubKey,
                        subKey );
        if ( !psubKey )
        {
            return  ERROR_INVALID_PARAMETER;
        }

        pclass = standardWideToAnsiConvert(
                        (PWSTR) lpClass,
                        class );

        return  RegCreateKeyExA(
                        hKey,
                        (LPCSTR) psubKey,
                        Reserved,
                        pclass,
                        dwOptions,
                        samDesired,
                        lpSecurityAttributes,
                        phkResult,
                        lpdwDisposition );
    }
}



//WINADVAPI
LONG
WINAPI
DnsShimRegOpenKeyExW(
    IN      HKEY            hKey,
    IN      LPCWSTR         lpSubKey,
    IN      DWORD           dwOptions,
    IN      REGSAM          samDesired,
    OUT     PHKEY           phkResult
    )
/*++

Routine Description:

    Shim RegOpenKeyExW()

Arguments:

    See SDK doc.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    //  for NT it's a dumb stub

    if ( !g_IsWin9X )
    {
        return  RegOpenKeyExW(
                        hKey,
                        lpSubKey,
                        dwOptions,
                        samDesired,
                        phkResult );
    }

    //  for Win9x, convert to ANSI and call

    else
    {
        PCHAR   psubKey;
        CHAR    subKey[ MAX_PATH ];

        psubKey = standardWideToAnsiConvert(
                        (PWSTR) lpSubKey,
                        subKey );

        return  RegOpenKeyExA(
                        hKey,
                        (LPCSTR) psubKey,
                        dwOptions,
                        samDesired,
                        phkResult );
    }
}



LONG
WINAPI
DnsShimRegQueryValueExW(
    IN      HKEY            hKey,
    IN      LPCWSTR         lpValueName,
    IN      LPDWORD         lpReserved,
    IN      LPDWORD         lpType,
    IN      LPBYTE          lpData,
    IN      LPDWORD         lpcbData
    )
/*++

Routine Description:

    Shim RegQueryValueExW()

Arguments:

    See SDK doc.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    //  for NT it's a dumb stub

    if ( !g_IsWin9X )
    {
        return  RegQueryValueExW(
                        hKey,
                        lpValueName,
                        lpReserved,
                        lpType,
                        lpData,
                        lpcbData );
    }

    //  for Win9x, convert to ANSI and call

    else
    {
        LONG    status;
        DWORD   type = 0;
        DWORD   length = 0;
        PDWORD  plength = &length;
        PCHAR   pvalueName;
        CHAR    valueName[ MAX_PATH ];

        //  convert value name

        pvalueName = standardWideToAnsiConvert(
                        (PWSTR) lpValueName,
                        valueName );

        //  use start length

        if ( lpcbData )
        {
            length = *lpcbData;
            plength = NULL;
        }

        //  make ANSI call

        status = RegQueryValueExA(
                        hKey,
                        pvalueName,
                        lpReserved,
                        & type,
                        lpData,
                        plength );

        //  return type

        if ( lpType )
        {
            *lpType = type;
        }

        //
        //  setup length\data return
        //      - no length call => just status
        //      - no data return or non-string data => set length
        //      - string data => convert
        //

        if ( !lpcbData )
        {
            //  no-op, this kind of call just gets status
        }

        //
        //  no data conversion -- set length
        //      - unicode length required at twice ANSI length
        //      - DWORD and binary length unchanged

        else if ( !lpData ||
                  status != ERROR_SUCCESS ||
                  type == REG_DWORD ||
                  type == REG_BINARY )
        {
            if ( type == REG_DWORD || type == REG_BINARY )
            {
                *lpcbData = length;
            }
            else
            {
                *lpcbData = length * 2;
            }
        }

        //
        //  convert ANSI data to unicode
        //

        else
        {
            PBYTE   pdataUnicode;
            DWORD   unicodeLength;

            pdataUnicode = (PBYTE) ALLOCATE_HEAP( *lpcbData );
            if ( !pdataUnicode )
            {
                return( DNS_ERROR_NO_MEMORY );
            }

            unicodeLength = Dns_StringCopy(
                                pdataUnicode,
                                lpcbData,
                                lpData,             // ANSI data
                                length,             // ANSI length
                                DnsCharSetAnsi,
                                DnsCharSetUnicode );

            if ( unicodeLength == 0 )
            {
                status = GetLastError();
                ASSERT( status != ERROR_SUCCESS );
                unicodeLength = length * 2;
            }

            *lpcbData = unicodeLength;

            FREE_HEAP( pdataUnicode );
        }

        return( status );
    }
}
#endif  // Win95 registry shims

//
//  End registry.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\resolver.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    resolver.c

Abstract:

    Domain Name System (DNS) API

    Resolver control.

Author:

    Jim Gilroy (jamesg)     March 2000

Revision History:

--*/


#include "local.h"



//
//  Flush cache routines
//

BOOL
WINAPI
DnsFlushResolverCache(
    VOID
    )
/*++

Routine Description:

    Flush resolver cache.

Arguments:

    None

Return Value:

    TRUE if successful.
    FALSE otherwise.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;

    DNSDBG( TRACE, ( "DnsFlushResolverCache()\n" ));

    RpcTryExcept
    {
        R_ResolverFlushCache( NULL );
    }
    RpcExcept( DNS_RPC_EXCEPTION_FILTER )
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    if ( status )
    {
        DNSDBG( RPC, (
            "DnsFlushResolverCache()  RPC failed status = %d\n",
            status ));
        return FALSE;
    }
    return TRUE;
}



BOOL
WINAPI
DnsFlushResolverCacheEntry_W(
    IN      PWSTR           pszName
    )
/*++

Routine Description:

    Flush resolver cache entry.

Arguments:

    pszName -- name of entry to flush in unicode

Return Value:

    TRUE if entry non-existant or flushed.
    FALSE on error.

--*/
{
    DWORD   status;

    DNSDBG( TRACE, (
        "DnsFlushResolverCacheEntry_W( %S )\n",
        pszName ));

    if ( !pszName )
    {
        return FALSE;
    }

    RpcTryExcept
    {
        status = R_ResolverFlushCacheEntry(
                    NULL,       // dummy handle
                    pszName,
                    0           // flush all types
                    );
    }
    RpcExcept( DNS_RPC_EXCEPTION_FILTER )
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    if ( status != ERROR_SUCCESS )
    {
        DNSDBG( RPC, (
            "DnsFlushResolverCacheEntry()  RPC failed status = %d\n",
            status ));
        return FALSE;
    }
    
    return TRUE;
}



BOOL
WINAPI
FlushResolverCacheEntryNarrow(
    IN      PSTR            pszName,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Flush resolver cache entry with narrow string name.

    Handles flush for _A and _UTF8

Arguments:

    pszName -- name of entry to flush

    CharSet -- char set of name

Return Value:

    TRUE if entry non-existant or flushed.
    FALSE on error.

--*/
{
    WCHAR   wideNameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    DWORD   bufLength = DNS_MAX_NAME_BUFFER_LENGTH * sizeof(WCHAR);
    BOOL    flag = TRUE;

    DNSDBG( TRACE, (
        "FlushResolverCacheEntryNarrow( %s )\n",
        pszName ));

    //  must have name

    if ( !pszName )
    {
        //  return  ERROR_INVALID_NAME;
        return FALSE;
    }

    //
    //  convert name to unicode
    //      - bail if name too long or conversion error

    if ( ! Dns_NameCopy(
                (PBYTE) wideNameBuffer,
                & bufLength,
                pszName,
                0,              // name is string
                CharSet,
                DnsCharSetUnicode ))
    {
        //  return  ERROR_INVALID_NAME;
        return  FALSE;
    }

    //  flush cache entry

    return  DnsFlushResolverCacheEntry_W( wideNameBuffer );
}


BOOL
WINAPI
DnsFlushResolverCacheEntry_A(
    IN      PSTR            pszName
    )
{
    return  FlushResolverCacheEntryNarrow(
                pszName,
                DnsCharSetAnsi );
}

BOOL
WINAPI
DnsFlushResolverCacheEntry_UTF8(
    IN      PSTR            pszName
    )
{
    return  FlushResolverCacheEntryNarrow(
                pszName,
                DnsCharSetUtf8 );
}



//
//  Resolver poke
//

VOID
DnsNotifyResolverEx(
    IN      DWORD           Id,
    IN      DWORD           Flag,
    IN      DWORD           Cookie,
    IN      PVOID           pReserved
    )
/*++

Routine Description:

    Notify resolver of cluster IP coming on\offline.

Arguments:

    ClusterIp -- cluster IP

    fAdd -- TRUE if coming online;  FALSE if offline.

Return Value:

    None

--*/
{
    RpcTryExcept
    {
        R_ResolverPoke(
                NULL,           // RPC handle
                Cookie,
                Id );
    }
    RpcExcept( DNS_RPC_EXCEPTION_FILTER )
    {
    }
    RpcEndExcept
}



//
//  Cluster interface
//

DNS_STATUS
DnsRegisterClusterAddress(
    IN      DWORD           Tag,
    IN      PWSTR           pwsName,
    IN      PSOCKADDR       pSockaddr,
    IN      DWORD           Flag
    )
/*++

Routine Description:

    Register cluster addresses with resolver.

Arguments:

    pwsName -- cluster name

    pSockaddr -- sockaddr for cluster address

    fAdd -- TRUE if coming online;  FALSE if offline.

    Tag -- cluster add tag

Return Value:

    None

--*/
{
    IP_UNION    ipUnion;
    DNS_STATUS  status;

    DNSDBG( TRACE, (
        "DnsRegisterClusterAddress()\n"
        "\tTag          = %08x\n"
        "\tpName        = %S\n"
        "\tpSockaddr    = %p (fam=%d)\n"
        "\tFlag         = %d\n",
        Tag,
        pwsName,
        pSockaddr,  pSockaddr->sa_family,
        Flag ));

    //
    //  DCR:  write cluster key
    //
    //  DCR:  check that we are on cluster machime
    //

    if ( !g_IsServer )
    {
        return  ERROR_ACCESS_DENIED;
    }

    //
    //  convert to our private IP union
    //

    if ( ! Dns_SockaddrToIpUnion(
                &ipUnion,
                pSockaddr ))
    {
        DNSDBG( ANY, (
            "ERROR:  failed converting sockaddr to IP Union!\n" ));
        return  ERROR_INVALID_PARAMETER;
    }

    //
    //  notify resolver of cluster IP
    //

    RpcTryExcept
    {
        status = R_ResolverRegisterCluster(
                    NULL,           // RPC handle
                    Tag,
                    pwsName,
                    (PRPC_IP_UNION) &ipUnion,
                    Flag );
    }
    RpcExcept( DNS_RPC_EXCEPTION_FILTER )
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept


    DNSDBG( TRACE, (
        "Leave  DnsRegisterClusterAddress( %S ) => %d\n",
        pwsName,
        status ));

    return  status;
}

//
//  End resolver.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\registry.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    registry.h

Abstract:

    Domain Name System (DNS) API 

    Registry routines header.

Author:

    Jim Gilroy (jamesg)     March, 2000

Revision History:

--*/


#ifndef _DNSREGISTRY_INCLUDED_
#define _DNSREGISTRY_INCLUDED_


//
//  Registry keys
//

#define TCPIP_PARAMETERS_KEY        L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters"
#define TCPIP_RAS_KEY               L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Transient"
#define TCPIP_INTERFACES_KEY        L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\"
#define TCPIP_INTERFACES_KEY_A      "System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\"

#define DNS_POLICY_KEY              L"Software\\Policies\\Microsoft\\Windows NT\\DnsClient"
#define DNS_POLICY_WIN2K_KEY        L"Software\\Policies\\Microsoft\\System\\DNSClient"

//#define DNS_POLICY_INTERFACES_KEY   L"Software\\Policies\\Microsoft\\Windows NT\\DNS Client\\Interfaces"
#define POLICY_INTERFACES_SUBKEY    L"Interfaces"

#define DNS_CLIENT_KEY              L"Software\\Microsoft\\Windows NT\\CurrentVersion\\DNSClient"
#define DNS_CACHE_KEY               L"System\\CurrentControlSet\\Services\\DnsCache\\Parameters"
#define DNS_SERVER_KEY              L"System\\CurrentControlSet\\Services\\DNS"

#define NT_SETUP_MODE_KEY           L"System\\Setup"

//  General

//#define ITERFACES_KEY_PATH          L"\\Interfaces\\"


//
//  Registry values
//
//  note:  _KEY appended on SEARCH_LIST_KEY to avoid conflicting
//      with structure name -- don't remove
//

#define HOST_NAME                                   L"Hostname"
#define DOMAIN_NAME                                 L"Domain"
#define DHCP_DOMAIN_NAME                            L"DhcpDomain"
#define ADAPTER_DOMAIN_NAME                         L"AdapterDomainName"
#define PRIMARY_DOMAIN_NAME                         L"PrimaryDomainName"
#define PRIMARY_SUFFIX                              L"PrimaryDNSSuffix"
#define ALTERNATE_NAMES                             L"AlternateComputerNames"
#define DNS_SERVERS                                 L"NameServer"
#define SEARCH_LIST_KEY                             L"SearchList"
#define UPDATE_ZONE_EXCLUSIONS                      L"UpdateZoneExclusions"

//  Query

#define QUERY_ADAPTER_NAME                          L"QueryAdapterName"
#define USE_DOMAIN_NAME_DEVOLUTION                  L"UseDomainNameDevolution"
#define PRIORITIZE_RECORD_DATA                      L"PrioritizeRecordData"
#define ALLOW_UNQUALIFIED_QUERY                     L"AllowUnqualifiedQuery"
#define APPEND_TO_MULTI_LABEL_NAME                  L"AppendToMultiLabelName"
#define SCREEN_BAD_TLDS                             L"ScreenBadTlds"
#define SCREEN_UNREACHABLE_SERVERS                  L"ScreenUnreachableServers"
#define FILTER_CLUSTER_IP                           L"FilterClusterIp"
#define WAIT_FOR_NAME_ERROR_ON_ALL                  L"WaitForNameErrorOnAll"
#define USE_EDNS                                    L"UseEdns"

//  Update

#define REGISTRATION_ENABLED                        L"RegistrationEnabled"
#define REGISTER_PRIMARY_NAME                       L"RegisterPrimaryName"
#define REGISTER_ADAPTER_NAME                       L"RegisterAdapterName"
#define REGISTER_REVERSE_LOOKUP                     L"RegisterReverseLookup"
#define REGISTER_WAN_ADAPTERS                       L"RegisterWanAdapters"
#define REGISTRATION_OVERWRITES_IN_CONFLICT         L"RegistrationOverwritesInConflict"
#define REGISTRATION_TTL                            L"RegistrationTtl"
#define REGISTRATION_REFRESH_INTERVAL               L"RegistrationRefreshInterval"
#define REGISTRATION_MAX_ADDRESS_COUNT              L"RegistrationMaxAddressCount"
#define UPDATE_SECURITY_LEVEL                       L"UpdateSecurityLevel"
#define UPDATE_ZONE_EXCLUDE_FILE                    L"UpdateZoneExcludeFile"
#define UPDATE_TOP_LEVEL_DOMAINS                    L"UpdateTopLevelDomainZones"

//  Backcompat

#define DISABLE_ADAPTER_DOMAIN_NAME                 L"DisableAdapterDomainName"
#define DISABLE_DYNAMIC_UPDATE                      L"DisableDynamicUpdate"
#define ENABLE_ADAPTER_DOMAIN_NAME_REGISTRATION     L"EnableAdapterDomainNameRegistration"
#define DISABLE_REVERSE_ADDRESS_REGISTRATIONS       L"DisableReverseAddressRegistrations"
#define DISABLE_WAN_DYNAMIC_UPDATE                  L"DisableWanDynamicUpdate"
#define ENABLE_WAN_UPDATE_EVENT_LOG                 L"EnableWanDynamicUpdateEventLog"
#define DISABLE_REPLACE_ADDRESSES_IN_CONFLICTS      L"DisableReplaceAddressesInConflicts"
#define DEFAULT_REGISTRATION_TTL                    L"DefaultRegistrationTTL"
#define DEFAULT_REGISTRATION_REFRESH_INTERVAL       L"DefaultRegistrationRefreshInterval"
#define MAX_NUMBER_OF_ADDRESSES_TO_REGISTER         L"MaxNumberOfAddressesToRegister"

//  Micellaneous

#define NT_SETUP_MODE                               L"SystemSetupInProgress"
#define DNS_TEST_MODE                               L"DnsTest"
#define REMOTE_DNS_RESOLVER                         L"RemoteDnsResolver"

//  Cache

#define MAX_CACHE_SIZE                              L"MaxCacheSize"
#define MAX_CACHE_TTL                               L"MaxCacheTtl"
#define MAX_NEGATIVE_CACHE_TTL                      L"MaxNegativeCacheTtl"
#define ADAPTER_TIMEOUT_LIMIT                       L"AdapterTimeoutLimit"
#define SERVER_PRIORITY_TIME_LIMIT                  L"ServerPriorityTimeLimit"
#define MAX_CACHED_SOCKETS                          L"MaxCachedSockets"

#define USE_MULTICAST                               L"UseMulticast"
#define MULTICAST_ON_NAME_ERROR                     L"MulticastOnNameError"
#define USE_DOT_LOCAL_DOMAIN                        L"UseDotLocalDomain"
#define LISTEN_ON_MULTICAST                         L"ListenOnMulticast"


//
//  ANSI keys and values
//

#define STATIC_NAME_SERVER_VALUE_A      "NameServer"
#define PRIMARY_DOMAIN_NAME_A           "PrimaryDomainName"

#if DNSWIN95
//  Win95 Keys

#define WIN95_TCPIP_KEY_A               "System\\CurrentControlSet\\Services\\VxD\\MSTCP"
#define WIN95_DHCP_KEY_A                "System\\CurrentControlSet\\Services\\VxD\\DHCP"

//  Value

#define USE_DOMAIN_NAME_DEVOLUTION_A    "UseDomainNameDevolution"

//  More

#define DHCP_NAME_SERVER_VALUE_A        "DhcpNameServer"
#define SEARCH_LIST_VALUE_A             "SearchList"
#define DHCP_DOMAIN_NAME_VALUE_A        "DhcpDomain"
#define DOMAIN_NAME_VALUE_A             "Domain"
#define STATIC_DOMAIN_NAME_VALUE_A      "Domain"
#define DHCP_IP_ADDRESS_VALUE_WIN95_A   "DhcpIPAddress"
#define DHCP_INFO_VALUE_A               "DhcpInfo"
#define DHCP_OPTION_INFO_VALUE_A        "OptionInfo"
#endif


//
//  Reg types of keys
//

#define REGTYPE_BIND                        REG_MULTI_SZ
#define REGTYPE_EXPORT                      REG_MULTI_SZ

#define REGTYPE_STATIC_IP_ADDRESS           REG_MULTI_SZ
#define REGTYPE_STATIC_SUBNET_MASK          REG_MULTI_SZ
#define REGTYPE_UPDATE_ZONE_EXCLUSIONS      REG_MULTI_SZ
#define REGTYPE_ALTERNATE_NAMES             REG_MULTI_SZ

#define REGTYPE_DNS_NAME                    REG_SZ
#define REGTYPE_SEARCH_LIST                 REG_SZ
#define REGTYPE_DNS_SERVER                  REG_SZ

#define REGTYPE_DHCP_IP_ADDRESS             REG_SZ
#define REGTYPE_DHCP_SUBNET_MASK            REG_SZ
#define REGTYPE_DHCP_INFO                   REG_BINARY
#define REGTYPE_DHCP_OPTION_INFO            REG_BINARY
#define REGTYPE_DHCP_IP_ADDRESS_WIN95       REG_DWORD




//
//  Registry key dummy ptrs
//
//  Use these when we want to access registry at
//      EITHER adapter name
//      OR one of these default locations
//

#define REGKEY_TCPIP_PARAMETERS     ((PWSTR)(UINT_PTR)(0x1))
#define REGKEY_DNS_CACHE            ((PWSTR)(UINT_PTR)(0x2))
#define REGKEY_DNS_POLICY           ((PWSTR)(UINT_PTR)(0x3))
#define REGKEY_SETUP_MODE_LOCATION  ((PWSTR)(UINT_PTR)(0x4))

#define REGKEY_DNS_MAX              REGKEY_SETUP_MODE_LOCATION


//
//  Registry value IDs
//

typedef enum
{
    //  basic
    RegIdHostName = 0,
    RegIdDomainName,
    RegIdDhcpDomainName,
    RegIdAdapterDomainName,
    RegIdPrimaryDomainName,
    RegIdPrimaryDnsSuffix,
    RegIdAlternateNames,
    RegIdDnsServers,
    RegIdSearchList,
    RegIdUpdateZoneExclusions,

    //  query
    RegIdQueryAdapterName,
    RegIdUseNameDevolution,
    RegIdPrioritizeRecordData,
    RegIdAllowUnqualifiedQuery,
    RegIdAppendToMultiLabelName,
    RegIdScreenBadTlds,
    RegIdScreenUnreachableServers,
    RegIdFilterClusterIp,
    RegIdWaitForNameErrorOnAll,
    RegIdUseEdns,

    //  update
    RegIdRegistrationEnabled,
    RegIdRegisterPrimaryName,
    RegIdRegisterAdapterName,
    RegIdRegisterReverseLookup,
    RegIdRegisterWanAdapters,
    RegIdRegistrationOverwritesInConflict,
    RegIdRegistrationTtl,
    RegIdRegistrationRefreshInterval,
    RegIdRegistrationMaxAddressCount,
    RegIdUpdateSecurityLevel,
    RegIdUpdateZoneExcludeFile,
    RegIdUpdateTopLevelDomains,

    //  backcompat
    RegIdDisableAdapterDomainName,
    RegIdDisableDynamicUpdate,                
    RegIdEnableAdapterDomainNameRegistration, 
    RegIdDisableReverseAddressRegistrations,  
    RegIdDisableWanDynamicUpdate,             
    RegIdEnableWanDynamicUpdateEventLog,      
    RegIdDisableReplaceAddressesInConflicts,  
    RegIdDefaultRegistrationTTL,              
    RegIdDefaultRegistrationRefreshInterval,  
    RegIdMaxNumberOfAddressesToRegister,

    //  micellaneous
    RegIdSetupMode,
    RegIdTestMode,
    RegIdRemoteResolver,

    //  resolver
    RegIdMaxCacheSize,
    RegIdMaxCacheTtl,
    RegIdMaxNegativeCacheTtl,
    RegIdAdapterTimeoutLimit,
    RegIdServerPriorityTimeLimit,
    RegIdMaxCachedSockets,

    //  multicast resolver
    RegIdUseMulticast,
    RegIdMulticastOnNameError,
    RegIdUseDotLocalDomain,
    RegIdListenOnMulticast,
}
DNS_REGID;

//
//  ID validity mark -- keep in sync
//

#define RegIdValueMax      RegIdListenOnMulticast
#define RegIdValueCount    (RegIdValueMax+1)

//
//  Duplicates -- lots reads are just for "Domain"
//
//  Note:  can make separate entries for these if the
//      flags need to be different
//

#define RegIdStaticDomainName          RegIdDomainName
#define RegIdRasDomainName             RegIdDomainName


//
//  Default values
//
//  Note, put here as non-fixed default like refresh interval
//  is reset in config.c
//

#define REGDEF_REGISTRATION_TTL                 (1200)      // 20 minutes

#define REGDEF_REGISTRATION_REFRESH_INTERVAL    (86400)     // 1 day
#define REGDEF_REGISTRATION_REFRESH_INTERVAL_DC (86400)     // 1 day

//
//  EDNS values
//

#define REG_EDNS_OFF    (0)
#define REG_EDNS_TRY    (1)
#define REG_EDNS_ALWAYS (2)

//
//  TLD screening values
//      - these are bit flags
//  

#define DNS_TLD_SCREEN_NUMERIC      (0x00000001)
#define DNS_TLD_SCREEN_REPEATED     (0x00000010)
#define DNS_TLD_SCREEN_BAD_MSDC     (0x00000100)

#define DNS_TLD_SCREEN_TOO_LONG     (0x10000000)
#define DNS_TLD_SCREEN_WORKGROUP    (0x00100000)
#define DNS_TLD_SCREEN_DOMAIN       (0x00200000)
#define DNS_TLD_SCREEN_HOME         (0x00400000)
#define DNS_TLD_SCREEN_OFFICE       (0x00800000)
#define DNS_TLD_SCREEN_LOCAL        (0x01000000)

#define DNS_TLD_SCREEN_BOGUS_ALL    (0xfff00000)

#define DNS_TLD_SCREEN_DEFAULT      \
        (   DNS_TLD_SCREEN_NUMERIC   | \
            DNS_TLD_SCREEN_REPEATED  )

//
//  Test mode flags
//

#define TEST_MODE_READ_REG      (0x00000001)
#define TEST_MODE_SOCK_FAIL     (0x00100000)


//
//  Access to registry property table (registry.c)
//

typedef struct _RegProperty
{
    PWSTR       pwsName;
    DWORD       dwDefault;
    BOOLEAN     bPolicy;
    BOOLEAN     bClient;
    BOOLEAN     bTcpip;
    BOOLEAN     bCache;
}
REG_PROPERTY;

extern REG_PROPERTY    RegPropertyTable[];

#define REGPROP_NAME(index)         (RegPropertyTable[index].pwsName)
#define REGPROP_DEFAULT(index)      (RegPropertyTable[index].dwDefault)
#define REGPROP_POLICY(index)       (RegPropertyTable[index].bPolicy)
#define REGPROP_CLIENT(index)       (RegPropertyTable[index].bClient)
#define REGPROP_CACHE(index)        (RegPropertyTable[index].bCache)
#define REGPROP_TCPIP(index)        (RegPropertyTable[index].bTcpip)




//
//  Config globals as structure for RPC 
//

typedef struct _DnsGlobals
{
    DWORD       ConfigCookie;
    DWORD       TimeStamp;

    BOOL        InResolver;
    BOOL        IsWin2000;                       
#if DNSBUILDOLD
    BOOL        IsWin9X;                         
    BOOL        IsNT4;
#endif
    BOOL        IsWorkstation;                   
    BOOL        IsServer;                        
    BOOL        IsDnsServer;                     
    BOOL        IsDomainController;              
    BOOL        InNTSetupMode;                   
    DWORD       DnsTestMode;
                                                 
    BOOL        QueryAdapterName;                
    BOOL        UseNameDevolution;               
    BOOL        PrioritizeRecordData;            
    BOOL        AllowUnqualifiedQuery;           
    BOOL        AppendToMultiLabelName;
    BOOL        ScreenBadTlds;
    BOOL        ScreenUnreachableServers;
    BOOL        FilterClusterIp;
    BOOL        WaitForNameErrorOnAll;
    DWORD       UseEdns;                         
                                                 
    BOOL        RegistrationEnabled;             
    BOOL        RegisterPrimaryName;             
    BOOL        RegisterAdapterName;             
    BOOL        RegisterReverseLookup;           
    BOOL        RegisterWanAdapters;             
    BOOL        RegistrationOverwritesInConflict;
    DWORD       RegistrationMaxAddressCount;     
    DWORD       RegistrationTtl;                 
    DWORD       RegistrationRefreshInterval;     
    DWORD       UpdateSecurityLevel;             
    BOOL        UpdateZoneExcludeFile;           
    BOOL        UpdateTopLevelDomains;

    //
    //  Cache stuff
    //
    //  Not needed unless switch to this for actual registry read,
    //  but convient to just export one global rather than several.
    //  This way it's all the same.
    //

    DWORD       MaxCacheSize;                    
    DWORD       MaxCacheTtl;                     
    DWORD       MaxNegativeCacheTtl;             
    DWORD       AdapterTimeoutLimit;             
    DWORD       ServerPriorityTimeLimit;
    DWORD       MaxCachedSockets;
    BOOL        UseMulticast;                    
    BOOL        MulticastOnNameError;            
    BOOL        UseDotLocalDomain;               
    BOOL        ListenOnMulticast;

}
DNS_GLOBALS_BLOB, *PDNS_GLOBALS_BLOB;


//
//  no MIDL pass on rest of file
//
//  This file is included in MIDL pass for resolver
//  in order to pick up the DNS_GLOBALS_BLOB defintion
//  on the theory that it is better to have it right
//  here with the other registry config.  But all the
//  function definitions and other struct defs are
//  of no interest during the pass.
//

#ifndef MIDL_PASS



//
//  Config globals -- macros for globals
//
//  There are two basic approaches here:
//
//  1) Single config blob -- but no fixed memory.
//  All callers must drop down blob to receive config blob.
//  Note, that this still requires macros for each individual global
//  but the form can be the same inside and outside the dll, and
//  nothing need be exported.
//  
//  2) Create a single config blob and export that.
//  Individual globals then become macros into the blob.  Still the
//  form of the macro will be different inside and outside the
//  dll.
//
//  3) Use macros to expose each individual global.
//  Form of macro will be different inside versus outside the dll.
//  Advantage here is that globals are preserved and available for
//  symbolic debugging.
//


#ifdef DNSAPI_INTERNAL

//
//  Internal to dnsapi.dll
//
    
extern  DNS_GLOBALS_BLOB    DnsGlobals;
    
#else
    
//
//  External to dnsapi.dll
//
    
__declspec(dllimport)   DNS_GLOBALS_BLOB    DnsGlobals;

#endif

//
//  Macros to globals
//

#define g_ConfigCookie                      (DnsGlobals.ConfigCookie)
#define g_InResolver                        (DnsGlobals.InResolver)
#define g_IsWin2000                         (DnsGlobals.IsWin2000)                        
#define g_IsWin9X                           (DnsGlobals.IsWin9X)                          
#define g_IsNT4                             (DnsGlobals.IsNT4)                            
#define g_IsWorkstation                     (DnsGlobals.IsWorkstation)                    
#define g_IsServer                          (DnsGlobals.IsServer)                         
#define g_IsDnsServer                       (DnsGlobals.IsDnsServer)                      
#define g_IsDomainController                (DnsGlobals.IsDomainController)               
#define g_InNTSetupMode                     (DnsGlobals.InNTSetupMode)                    
#define g_DnsTestMode                       (DnsGlobals.DnsTestMode)                    
#define g_QueryAdapterName                  (DnsGlobals.QueryAdapterName)                 
#define g_UseNameDevolution                 (DnsGlobals.UseNameDevolution)                
#define g_PrioritizeRecordData              (DnsGlobals.PrioritizeRecordData)             
#define g_AllowUnqualifiedQuery             (DnsGlobals.AllowUnqualifiedQuery)            
#define g_AppendToMultiLabelName            (DnsGlobals.AppendToMultiLabelName)           
#define g_ScreenBadTlds                     (DnsGlobals.ScreenBadTlds)
#define g_ScreenUnreachableServers          (DnsGlobals.ScreenUnreachableServers)
#define g_FilterClusterIp                   (DnsGlobals.FilterClusterIp)           
#define g_WaitForNameErrorOnAll             (DnsGlobals.WaitForNameErrorOnAll)           
#define g_UseEdns                           (DnsGlobals.UseEdns)                          
#define g_RegistrationEnabled               (DnsGlobals.RegistrationEnabled)              
#define g_RegisterPrimaryName               (DnsGlobals.RegisterPrimaryName)              
#define g_RegisterAdapterName               (DnsGlobals.RegisterAdapterName)              
#define g_RegisterReverseLookup             (DnsGlobals.RegisterReverseLookup)            
#define g_RegisterWanAdapters               (DnsGlobals.RegisterWanAdapters)              
#define g_RegistrationOverwritesInConflict  (DnsGlobals.RegistrationOverwritesInConflict) 
#define g_RegistrationMaxAddressCount       (DnsGlobals.RegistrationMaxAddressCount)      
#define g_RegistrationTtl                   (DnsGlobals.RegistrationTtl)                  
#define g_RegistrationRefreshInterval       (DnsGlobals.RegistrationRefreshInterval)      
#define g_UpdateSecurityLevel               (DnsGlobals.UpdateSecurityLevel)              
#define g_UpdateZoneExcludeFile             (DnsGlobals.UpdateZoneExcludeFile)            
#define g_UpdateTopLevelDomains             (DnsGlobals.UpdateTopLevelDomains)
#define g_MaxCacheSize                      (DnsGlobals.MaxCacheSize)                     
#define g_MaxCacheTtl                       (DnsGlobals.MaxCacheTtl)                      
#define g_MaxNegativeCacheTtl               (DnsGlobals.MaxNegativeCacheTtl)              
#define g_AdapterTimeoutLimit               (DnsGlobals.AdapterTimeoutLimit)              
#define g_ServerPriorityTimeLimit           (DnsGlobals.ServerPriorityTimeLimit)          
#define g_MaxCachedSockets                  (DnsGlobals.MaxCachedSockets)                     
#define g_UseMulticast                      (DnsGlobals.UseMulticast)                     
#define g_MulticastOnNameError              (DnsGlobals.MulticastOnNameError)             
#define g_UseDotLocalDomain                 (DnsGlobals.UseDotLocalDomain)                
#define g_ListenOnMulticast                 (DnsGlobals.ListenOnMulticast)

//
//  Macros for old functions
//
//  These values are read on DLL attach and can't change so
//  they don't require registry refresh.
//

#define Dns_IsMicrosoftNTServer()           g_IsServer
#define Dns_IsMicrosoftNTDomainController() g_IsDomainController



//
//  Non-exported config globals
//

extern PWSTR    g_pwsRemoteResolver;


//
//  Registry call flags
//

#define DNSREG_FLAG_GET_UNICODE     (0x0001)    // return string in unicode
#define DNSREG_FLAG_DUMP_EMPTY      (0x0010)    // dump empty data\strings -- return NULL


//
//  Registry Session
//

typedef struct _RegSession
{
    HKEY        hPolicy;
    HKEY        hClient;
    HKEY        hTcpip;
    HKEY        hCache;
}
REG_SESSION, *PREG_SESSION;



//
//  Policy adapter info read
//
//  DCR:  might be better to just include in config and
//      bring the whole baby across
//
//  DCR:  get to global\per adapter reads with reg_blob
//      then build global blob (flat) and network info(allocated)
//
//  DCR:  exposed config info should provide levels
//          - all
//          - adapter info (given domain name)
//          - global info
//

typedef struct _RegGlobalInfo
{
    //  Global data

    PSTR        pszPrimaryDomainName;
    PSTR        pszHostName;

    //  Global flags needed to build network info

    BOOL        fUseNameDevolution;
    BOOL        fUseMulticast;
    BOOL        fUseMulticastOnNameError;
    BOOL        fUseDotLocalDomain;

    //  Adapter policy overrides

    PIP_ARRAY   pDnsServerArray;
    PVOID       pDnsServerIp6Array;
    PSTR        pszAdapterDomainName;
    BOOL        fRegisterAdapterName;

    //  Read\not-read from policy

    BOOL        fPolicyRegisterAdapterName;

    //  DCR:  DWORD blob read here
}
REG_GLOBAL_INFO, *PREG_GLOBAL_INFO;


//
//  Registry adapter info read
//

typedef struct _RegAdapterInfo
{
    PSTR        pszAdapterDomainName;
    BOOL        fQueryAdapterName;
    BOOL        fRegistrationEnabled;
    BOOL        fRegisterAdapterName;
    DWORD       RegistrationMaxAddressCount;
}
REG_ADAPTER_INFO, *PREG_ADAPTER_INFO;  


//
//  Registry update info
//
//  DCR:  should be able to get from global read
//

typedef struct _RegUpdateInfo
{
    PSTR        pszPrimaryDomainName;
    PSTR        pmszAlternateNames;

    //  policy overrides

    PSTR        pszAdapterDomainName;
    PIP_ARRAY   pDnsServerArray;
    PVOID       pDnsServerIp6Array;

    //  update flags (policy, global or adapter)

    BOOL        fRegistrationEnabled;
    BOOL        fRegisterAdapterName;
    DWORD       RegistrationMaxAddressCount;
}
REG_UPDATE_INFO, *PREG_UPDATE_INFO;  


//
//  Registry routines
//

VOID
Reg_Init(
    VOID
    );

//
//  Registry shims (hide Win9x wide char issue)
//

LONG
WINAPI
DnsShimRegCreateKeyExW(
    IN      HKEY                    hKey,
    IN      LPCWSTR                 lpSubKey,
    IN      DWORD                   Reserved,
    IN      LPWSTR                  lpClass,
    IN      DWORD                   dwOptions,
    IN      REGSAM                  samDesired,
    IN      LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
    OUT     PHKEY                   phkResult,
    OUT     LPDWORD                 lpdwDisposition
    );

LONG
WINAPI
DnsShimRegOpenKeyExW(
    IN      HKEY            hKey,
    IN      LPCWSTR         lpSubKey,
    IN      DWORD           dwOptions,
    IN      REGSAM          samDesired,
    OUT     PHKEY           phkResult
    );

LONG
WINAPI
DnsShimRegQueryValueExW(
    IN      HKEY            hKey,
    IN      LPCWSTR         lpValueName,
    IN      LPDWORD         lpReserved,
    IN      LPDWORD         lpType,
    IN      LPBYTE          lpData,
    IN      LPDWORD         lpcbData
    );


//
//  Query routines
//

DNS_STATUS
WINAPI
Reg_OpenSession(
    OUT     PREG_SESSION    pRegSession,
    IN      DWORD           Level,
    IN      DWORD           ValueId
    );

VOID
WINAPI
Reg_CloseSession(
    IN OUT  PREG_SESSION    pRegSession
    );

DNS_STATUS
Reg_GetDword(
    IN      PREG_SESSION    pRegSession,    OPTIONAL
    IN      HKEY            hRegKey,        OPTIONAL
    IN      PWSTR           pwsKeyName,     OPTIONAL
    IN      DWORD           ValueId,
    OUT     PDWORD          pResult
    );

DNS_STATUS
Reg_GetValueEx(
    IN      PREG_SESSION    pRegSession,    OPTIONAL
    IN      HKEY            hRegKey,        OPTIONAL
    IN      LPSTR           pwsAdapter,     OPTIONAL
    IN      DWORD           ValueId,
    IN      DWORD           ValueType,
    IN      DWORD           Flag,
    OUT     PBYTE *         ppBuffer
    );

#define Reg_GetValue(s, k, id, t, pb ) \
        Reg_GetValueEx(s, k, NULL, id, t, 0, pb )

DNS_STATUS
Reg_GetIpArray(
    IN      PREG_SESSION    pRegSession,    OPTIONAL
    IN      HKEY            hRegKey,        OPTIONAL
    IN      LPSTR           pwsAdapter,     OPTIONAL
    IN      DWORD           ValueId,
    IN      DWORD           ValueType,
    OUT     PIP_ARRAY *     ppIpArray
    );

//
//  Set routines
//

HKEY
WINAPI
Reg_CreateKey(
    IN      PWSTR           pwsKeyName,
    IN      BOOL            bWrite
    );

DNS_STATUS
WINAPI
Reg_SetDwordValueByName(
    IN      PVOID           pReserved,
    IN      HKEY            hKey,
    IN      PWSTR           pwsNameKey,     OPTIONAL
    IN      PWSTR           pwsNameValue,   OPTIONAL
    IN      DWORD           dwValue
    );

DNS_STATUS
WINAPI
Reg_SetDwordValue(
    IN      PVOID           pReserved,
    IN      HKEY            hRegKey,
    IN      PWSTR           pwsNameKey,     OPTIONAL
    IN      DWORD           ValueId,
    IN      DWORD           dwValue
    );

//
//  Special type routines (regfig.c)
//

DNS_STATUS
Reg_ReadPrimaryDomainName(
    IN      PREG_SESSION    pRegSession,    OPTIONAL
    IN      HKEY            hRegKey,        OPTIONAL
    OUT     PSTR *          ppPrimaryDomainName
    );

BOOL
Reg_IsMicrosoftDnsServer(
    VOID
    );

DNS_STATUS
Reg_WriteLoopbackDnsServerList(
    IN      PSTR            pszAdapterName,
    IN      PREG_SESSION    pRegSession
    );

//
//  Main reg config read (config.c)
//

DNS_STATUS
Reg_ReadGlobalsEx(
    IN      DWORD           dwFlag,
    IN      PVOID           pRegSession
    );

//
//  DNS Config info access (regfig.c)
//

DNS_STATUS
Reg_ReadGlobalInfo(
    IN      PREG_SESSION        pRegSession,
    OUT     PREG_GLOBAL_INFO    pRegInfo
    );

VOID
Reg_FreeGlobalInfo(
    IN OUT  PREG_GLOBAL_INFO    pRegInfo,
    IN      BOOL                fFreeBlob
    );

DNS_STATUS
Reg_ReadAdapterInfo(
    IN      PSTR                pszAdapterName,
    IN      PREG_SESSION        pRegSession,
    IN      PREG_GLOBAL_INFO    pRegInfo,
    OUT     PREG_ADAPTER_INFO   pBlob
    );

VOID
Reg_FreeAdapterInfo(
    IN OUT  PREG_ADAPTER_INFO   pRegAdapterInfo,
    IN      BOOL                fFreeBlob
    );

DNS_STATUS
Reg_ReadUpdateInfo(
    IN      PSTR                pszAdapterName,
    OUT     PREG_UPDATE_INFO    pUpdateInfo
    );

VOID
Reg_FreeUpdateInfo(
    IN OUT  PREG_UPDATE_INFO    pUpdateInfo,
    IN      BOOL                fFreeBlob
    );

//
//  Insure fressh update config (regfig.c)
//

DNS_STATUS
Reg_RefreshUpdateConfig(
    VOID
    );


//
//  Simplified special type access
//

PSTR 
WINAPI
Reg_GetPrimaryDomainName(
    IN      DNS_CHARSET     CharSet
    );

PSTR 
WINAPI
Reg_GetHostName(
    IN      DNS_CHARSET     CharSet
    );

PSTR 
WINAPI
Reg_GetFullHostName(
    IN      DNS_CHARSET     CharSet
    );


//
//  Simple reg DWORD access
//

DWORD
Reg_ReadDwordProperty(
    IN      DNS_REGID       RegId,
    IN      PWSTR           pwsAdapterName  OPTIONAL
    );

DNS_STATUS
WINAPI
Reg_SetDwordPropertyAndAlertCache(
    IN      PWSTR           pwsKey,
    IN      DWORD           RegId,
    IN      DWORD           dwValue
    );

//
//  Configuration\registry 
//

#if 0
#define DnsEnableMulticastResolverThread()          \
        Reg_SetDwordPropertyAndAlertCache(          \
            REGKEY_DNS_CACHE,                       \
            ALLOW_MULTICAST_RESOLVER_OPERATION,     \
            TRUE )      
        
#define DnsDisableMulticastResolverThread()         \
        Reg_SetDwordPropertyAndAlertCache(          \
            REGKEY_DNS_CACHE,                       \
            ALLOW_MULTICAST_RESOLVER_OPERATION,     \
            FALSE )
#endif


#endif  // no MIDL_PASS

#endif  _DNSREGISTRY_INCLUDED_

//
//  End registry.h
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\rtlstuff.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    rtlstuff.h

Abstract:

    Domain Name System (DNS) Libary

    Macros from NT RTL headers.
    Copied here from ntrtl.h so we can build free of any NT specific headers.

Author:

    Jim Gilroy (jamesg)     May 1997

Revision History:

--*/


#ifndef _RTLSTUFF_INCLUDED_
#define _RTLSTUFF_INCLUDED_


//
//  Doubly-linked list manipulation routines.
//  Implemented as macros but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)


//
//  RTL memory routines
//

#if !defined(_WIN64)
#define RtlEqualMemory(Destination,Source,Length) (!memcmp((Destination),(Source),(Length)))
#endif

#define RtlCompareMemory(Destination,Source,Length) memcmp((Destination),(Source),(Length))

#define RtlMoveMemory(Destination,Source,Length) memmove((Destination),(Source),(Length))
#define RtlCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))

#define RtlFillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#define RtlZeroMemory(Destination,Length) memset((Destination),0,(Length))


#endif  // RTLSTUFF_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\queue.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    queue.h

Abstract:

    Domain Name System (DNS) Server
    Queue functionality specific to Dynamic DNS registration.
    
    

Author:

    Ram Viswanathan (ramv)  March 27 1997

Revision History:

    Ram Viswanathan (ramv) March 27 1997   Created

--*/


typedef struct _QELEMENT {
    REGISTER_HOST_ENTRY  HostAddr;
    LPWSTR               pszName;
    DWORD                dwTTL;
    BOOL                 fDoForward;
    BOOL                 fDoForwardOnly;
    DWORD                dwOperation; // what operation needs to be performed
    DWORD                dwRetryTime; //used by timed out queue (in secs)
    DWORD                dwRetryCount;
    DHCP_CALLBACK_FN     pfnDhcpCallBack; // call back function to call
    PVOID                pvData;
    PIP_ARRAY            DnsServerList;
    struct _QELEMENT*    pFLink;
    struct _QELEMENT*    pBLink;     //doubly linked list

}  QELEMENT, *PQELEMENT;


typedef struct _DynDnsQueue {
    PQELEMENT  pHead;  // pointer to the queue Head, where you take elements
    // off of the queue

    PQELEMENT pTail;  // pointer to tail, where producer adds elements
    
} DYNDNSQUEUE, *PDYNDNSQUEUE;

//
// methods to manipulate queue
//

DWORD 
InitializeQueues(
    PDYNDNSQUEUE * ppQueue,
    PDYNDNSQUEUE * ppTimedOutQueue
    );
/*
  InitializeQueue()

  This function initializes the queue object. This is invoked for the first
  time when you create the main queue and timed out queue

  Allocates appropriate memory variables etc

*/


DWORD 
FreeQueue(
    PDYNDNSQUEUE  pqueue
    );
/*
  FreeQueue()

  Frees the queue object. If there exist any entries in the queue, we
  just blow them away

*/

DWORD 
Enqueue(
    PQELEMENT     pNewElement,
    PDYNDNSQUEUE  pQueue,
    PDYNDNSQUEUE  pTimedOutQueue
    );


/*
   Enqueue()

   Adds new element to queue. If there is a dependency, this moves into
   the timedout queue.

   Arguments:

   Return Value:

    is 0 if Success. and (DWORD)-1 if failure.

*/
    


PQELEMENT 
Dequeue(
    PDYNDNSQUEUE  pQueue
    );


/*
   Dequeue()

   Removes an element from a queue, either the main queue or the timed
   out queue

   Arguments:

   Return Value:

    is the element at head of queue if Success. and NULL if failure.

*/
  
DWORD
AddToTimedOutQueue(    
    PQELEMENT     pNewElement,
    PDYNDNSQUEUE  pRetryQueue,
    DWORD         dwRetryTime
    );


/*
   AddToTimedOutQueue()

   Adds new element to timedout queue. Now the new element is added in a list
   of elements sorted according to decreasing order of Retry Times. An
   insertion sort type of algorithm is used.

   Arguments:

   dwRetryTime is in seconds
   Return Value:

    is 0 if Success. and (DWORD)-1 if failure.

*/
    
DWORD
GetEarliestRetryTime(
    PDYNDNSQUEUE pRetryQueue
    );

/*

   GetEarliestRetryTime()

   Checks to see if there is any element at the head of the queue
   and gets the retry time for this element

   Arguments:

   Return Value:

    is retrytime if success and INFINITE if there is no element or other
    failure

*/

/*
VOID
ProcessMainQDependencies(
    PDYNDNSQUEUE pQueue,
    PQELEMENT    pQElement
    );

    */
DWORD
ProcessQDependencies(
    PDYNDNSQUEUE pTimedOutQueue,
    PQELEMENT    pQElement
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\servlist.c ===
/*++

Copyright (c) 1997-2001 Microsoft Corporation

Module Name:

    servlist.c

Abstract:

    Domain Name System (DNS) API

    DNS network info routines.

Author:

    Jim Gilroy (jamesg)     January, 1997
    Glenn Curtis (glennc)   May, 1997

Revision History:

    Jim Gilroy (jamesg)     March 2000      slowly cleaning up

--*/


#include "local.h"
#include "registry.h"       // Registry reading definitions


//
//  Keep copy of DNS server/network info
//


#define CURRENT_ADAPTER_LIST_TIMEOUT    (10)    // 10 seconds


//
//  Registry info
//

#define DNS_REG_READ_BUF_SIZE       (1000)

#define LOCALHOST                   "127.0.0.1"




DNS_STATUS
ParseNameServerList(
    IN OUT  PIP_ARRAY       aipServers,
    IN      LPSTR           pBuffer,
    IN      BOOL            IsMultiSzString
    )
/*++

Routine Description:

    Parse DNS server list from registry into IP address array.

Arguments:

    aipServers -- IP array of DNS servers

    pBuffer -- buffer with IP addresses in dotted format

    IsMultiSzString -- Determines how to interpret data in buffer

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DWORD       stringLength;
    LPSTR       pstring;
    DWORD       cchBufferSize = 0;
    CHAR        ch;
    PUCHAR      pchIpString;
    IP_ADDRESS  ip;
    DWORD       countServers = aipServers->AddrCount;

    DNSDBG( NETINFO, (
        "Parsing name server list %s\n",
        pBuffer ));

    //
    //  MULTI_SZ string
    //
    //  IPs are given as individual strings with double NULL termination
    //

    if ( IsMultiSzString )
    {
        pstring = pBuffer;

        while ( ( stringLength = strlen( pstring ) ) != 0 &&
                countServers < DNS_MAX_NAME_SERVERS )
        {
            ip = inet_addr( pstring );

            if ( ip != INADDR_ANY && ip != INADDR_NONE )
            {
                aipServers->AddrArray[ countServers ] = ip;
                countServers++;
            }
            pstring += (stringLength + 1);
        }
    }
    else
    {
        //
        //  extract each IP string in buffer, convert to IP address,
        //  and add to server IP array
        //

        cchBufferSize = strlen( pBuffer );

        while( ch = *pBuffer && countServers < DNS_MAX_NAME_SERVERS )
        {
            //  skip leading whitespace, find start of IP string

            while( cchBufferSize > 0 &&
                   ( ch == ' ' || ch == '\t' || ch == ',' ) )
            {
                ch = *++pBuffer;
                cchBufferSize--;
            }
            pchIpString = pBuffer;

            //
            //  find end of string and NULL terminate
            //

            ch = *pBuffer;
            while( cchBufferSize > 0 &&
                   ( ch != ' ' && ch != '\t' && ch != '\0' && ch != ',' ) )
            {
                ch = *++pBuffer;
                cchBufferSize--;
            }
            *pBuffer = '\0';

            //  at end of buffer

            if ( pBuffer == pchIpString )
            {
                DNS_ASSERT( cchBufferSize == 1 || cchBufferSize == 0 );
                break;
            }

            //
            //  get IP address for string
            //      - zero or broadcast addresses are bogus
            //

            ip = inet_addr( pchIpString );
            if ( ip == INADDR_ANY || ip == INADDR_NONE )
            {
                break;
            }
            aipServers->AddrArray[ countServers ] = ip;
            countServers++;

            //  if more continue

            if ( cchBufferSize > 0 )
            {
                pBuffer++;
                cchBufferSize--;
                continue;
            }
            break;
        }
    }

    //  reset server count

    aipServers->AddrCount = countServers;

    if ( aipServers->AddrCount )
    {
        return( ERROR_SUCCESS );
    }
    else
    {
        return( DNS_ERROR_NO_DNS_SERVERS );
    }
}



//
//  Network info structure routines
//

#if 0
PSEARCH_LIST
Dns_GetDnsSearchList(
    IN      LPSTR             pszPrimaryDomainName,
    IN      HKEY              hKey,
    IN      PDNS_NETINFO      pNetworkInfo,
    IN      BOOL              fUseDomainNameDevolution,
    IN      BOOL              fUseDotLocalDomain
    )
/*++

    Dumb stub because this function is exposed in dnslib.h
        and in stmpdns\servlist.cpp in iis project

    DCR:  eliminate this routine (stupid)

--*/
{
    return  SearchList_Build(
                pszPrimaryDomainName,
                NULL,       // no reg session
                hKey,
                pNetworkInfo,
                fUseDomainNameDevolution,
                fUseDotLocalDomain );
}
#endif


VOID
Dns_ResetNetworkInfo(
    IN      PDNS_NETINFO      pNetworkInfo
    )
/*++

Routine Description:

    Clear the flags for each adapter.

Arguments:

    pNetworkInfo -- pointer to a DNS network info structure.

Return Value:

    Nothing

--*/
{
    DWORD iter;

    DNSDBG( TRACE, ( "Dns_ResetNetworkInfo()\n" ));

    if ( ! pNetworkInfo )
    {
        return;
    }

    for ( iter = 0; iter < pNetworkInfo->AdapterCount; iter++ )
    {
        pNetworkInfo->AdapterArray[iter]->RunFlags = 0;
    }

    pNetworkInfo->ReturnFlags = 0;
}



BOOL
Dns_DisableTimedOutAdapters(
    IN OUT  PDNS_NETINFO        pNetworkInfo
    )
/*++

Routine Description:

    For each adapter with status ERROR_TIMEOUT, disable it from
    further retry queries till Dns_ResetNetworkInfo is called.

Arguments:

    pNetworkInfo -- pointer to a DNS network info structure.

Return Value:

    True if a timed out adapter was found and disabled

--*/
{
    DWORD             iter;
    PDNS_ADAPTER      padapter;
    BOOL              fSetAdapter = FALSE;

    DNSDBG( TRACE, ( "Dns_DisableTimedOutAdapters()\n" ));

    if ( ! pNetworkInfo )
    {
        return FALSE;
    }

    for ( iter = 0; iter < pNetworkInfo->AdapterCount; iter++ )
    {
        padapter = pNetworkInfo->AdapterArray[iter];

        if ( padapter->Status == ERROR_TIMEOUT )
        {
            //
            // See if the given adapters are really timing out or not.
            // 
            // Sometimes a given name query will take a long time and
            // we timeout waiting for the response, though the server
            // will quicky respond to other name queries. Other times
            // the default gateway doesn't let us reach the DNS servers
            // on a given adapter, or they are plain dead.
            //
            // Pinging the given DNS servers to see if they can respond
            // to a simple query helps to avoid the confusion.
            //

            if ( !Dns_PingAdapterServers( padapter ) )
            {
                padapter->RunFlags |= RUN_FLAG_IGNORE_ADAPTER;
                padapter->RunFlags |= RUN_FLAG_RESET_SERVER_PRIORITY;
                fSetAdapter = TRUE;
            }
        }
    }

    if ( fSetAdapter )
    {
        pNetworkInfo->ReturnFlags = RUN_FLAG_RESET_SERVER_PRIORITY;
    }

    return fSetAdapter;
}


BOOL
Dns_ShouldNameErrorBeCached(
    IN      PDNS_NETINFO      pNetworkInfo
    )
/*++

Routine Description:

    This routine is used in conjuction with a given query's NAME_ERROR
    response to see if the error was one that occured on all adapters.
    This is used to decide if the name error response should be cached
    or not. If the machine was multihomed, and one of the adapters had
    a timeout error, then the name error should not be cached as a
    negative response.

Arguments:

    pNetworkInfo -- pointer to a DNS network info structure.

Return Value:

    False if a timed out adapter was found, and name error should not
    be negatively cached.

--*/
{
    DWORD             iter;
    PDNS_ADAPTER      padapter;

    DNSDBG( TRACE, ( "Dns_DidNameErrorOccurEverywhere()\n" ));

    if ( ! pNetworkInfo )
    {
        return TRUE;
    }

    if ( pNetworkInfo->ReturnFlags & RUN_FLAG_RESET_SERVER_PRIORITY )
    {
        for ( iter = 0; iter < pNetworkInfo->AdapterCount; iter++ )
        {
            padapter = pNetworkInfo->AdapterArray[iter];

            if ( !( padapter->InfoFlags & DNS_FLAG_IGNORE_ADAPTER ) &&
                 padapter->Status == ERROR_TIMEOUT )
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}


BOOL
Dns_PingAdapterServers(
    IN      PDNS_ADAPTER        pAdapterInfo
    )
//
//  DCR:  Dns_PingAdapterServers() is stupid
//          why are we doing this?
//
{
    BOOL              fPing = TRUE;
    PDNS_NETINFO      pnetworkInfo = NULL;
    PDNS_ADAPTER      padapterCopy = NULL;
    DNS_STATUS        Status = NO_ERROR;

    DNSDBG( TRACE, ( "Dns_PingAdapterServers()\n" ));

    pnetworkInfo = NetInfo_Alloc( 1 );
    if ( !pnetworkInfo )
    {
        return FALSE;
    }

    padapterCopy = AdapterInfo_Copy( pAdapterInfo );
    if ( !padapterCopy )
    {
        NetInfo_Free( pnetworkInfo );
        return FALSE;
    }

    padapterCopy->InfoFlags = DNS_FLAG_IS_AUTONET_ADAPTER;
    
    NetInfo_AddAdapter(
            pnetworkInfo,
            padapterCopy );

    //
    //  query adapter's DNS servers
    //      - query for loopback which always exists
    //

    Status = QueryDirectEx(
                    NULL,       // no message
                    NULL,       // no results
                    NULL,       // no header
                    0,          // no header counts
                    "1.0.0.127.in-addr.arpa.",
                    DNS_TYPE_PTR,
                    NULL,       // no input records
                    DNS_QUERY_ACCEPT_PARTIAL_UDP |
                        DNS_QUERY_NO_RECURSION,
                    NULL,       // no server list
                    pnetworkInfo );

    NetInfo_Free( pnetworkInfo );

    if ( Status == ERROR_TIMEOUT )
    {
        fPing = FALSE;
    }

    return fPing;
}



#if 0
    //
    //  this is some stuff Glenn wrote for the case where you
    //      don't have a DNS server list and will get it through mcast
    //
    //  it was in the middle of the NetworkInfo building routine
    //
    else
    {
        //
        //  DCR:  functionalize multicast query attempt
        //
        //
        // See if we can find a DNS server address to put on this
        // adapter by multicasting for it . . .
        //

        // LevonE is still debating this method for
        // server detection. If this is ultimately utilized, it
        // might be better to direct the multicast query out the
        // specific adapter IP address to try to get an address
        // relevant to the specific adapter's network. This
        // could be done by building a dummy pNetworkInfo
        // parameter to pass down to Dns_QueryLib. The helper
        // routine Dns_SendAndRecvMulticast could be revised to
        // support specific adapter multicasting, etc.

        PDNS_RECORD pServer = NULL;

        status = Dns_QueryLib(
                    NULL,
                    &pServer,
                    (PDNS_NAME) MULTICAST_DNS_SRV_RECORD_NAME,
                    DNS_TYPE_SRV,
                    DNS_QUERY_MULTICAST_ONLY,
                    NULL,
                    NULL, // May want to specify network!
                    0 );

        if ( status )
        {
            //
            // This adapter is not going to have any configured
            // DNS servers. No point trying any DNS queries on
            // it then.
            //
            adapterFlags |= DNS_FLAG_IGNORE_ADAPTER;
        }
        else
        {
            if ( pServer &&
                 pServer->Flags.S.Section == DNSREC_ANSWER &&
                 pServer->wType == DNS_TYPE_SRV &&
                 pServer->Data.SRV.wPort == DNS_PORT_HOST_ORDER )
            {
                PDNS_RECORD pNext = pServer->pNext;

                while ( pNext )
                {
                    if ( pNext->Flags.S.Section == DNSREC_ADDITIONAL &&
                         pNext->wType == DNS_TYPE_A &&
                         Dns_NameCompare( pServer ->
                                          Data.SRV.pNameTarget,
                                          pNext->pName ) )
                    {
                        pserverIpArray->AddrCount = 1;
                        pserverIpArray->AddrArray[0] = 
                            pNext->Data.A.IpAddress;
                        adapterFlags |= DNS_FLAG_AUTO_SERVER_DETECTED;
                        break;
                    }

                    pNext = pNext->pNext;
                }
            }

            Dns_RecordListFree( pServer );

            if ( pserverIpArray->AddrCount == 0 )
            {
                //
                // This adapter is not going to have any configured
                // DNS servers. No point trying any DNS queries on
                // it then.
                //
                adapterFlags |= DNS_FLAG_IGNORE_ADAPTER;
            }
        }
    }
#endif      //  multicast attempt

//
//  End servlist.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\send.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    send.c

Abstract:

    Domain Name System (DNS) API

    Send response routines.

Author:

    Jim Gilroy (jamesg)     October, 1996

Revision History:

--*/


#include "local.h"

//
//  Disjoint name space
//
//  If DNS name space is disjoint then NAME_ERROR response from one
//  adapter does NOT necessarily mean that name does not exist.  Rather
//  must continue on other adapters.
//
//  This flag should be set if name space is disjoint, off otherwise.
//
//  DCR_PERF:  auto-detect disjoint name space (really cool)
//  DCR_ENHANCE:  auto-detect disjoint name space (really cool)
//      initially continue trying on other adapters and if they always
//      coincide, then conclude non-disjoint (and turn off)
//
//  DCR_ENHANCE:  registry turn off of disjoint name space
//
//  Note:  should consider that name spaces often disjoint in that
//  Intranet is hidden from Internet
//

BOOL fDisjointNameSpace = TRUE;

//
//  Query \ response IP matching.
//
//  Some resolvers (Win95) have required matching between DNS server IP
//  queried and response.  This flag allows this matching to be turned on.
//  Better now than requiring SP later.
//
//  DCR_ENHANCE:  registry enable query\response IP matching.
//

BOOL fQueryIpMatching = FALSE;


//
//  Timeouts
//

#define HARD_TIMEOUT_LIMIT      16    // 16 seconds, total of 31 seconds
#define INITIAL_UPDATE_TIMEOUT   2    // 3 seconds
#define MAX_UPDATE_TIMEOUT      24    // 24 seconds
#define DNS_MAX_QUERY_TIMEOUTS  10    // 10
#define ONE_HOUR_TIMEOUT        60*60 // One hour

//  TCP timeout 10 seconds to come back

#define DEFAULT_TCP_TIMEOUT     10


//  Retry limits

#define MAX_SINGLE_SERVER_RETRY     (3)


#define NT_TCPIP_REG_LOCATION       "System\\CurrentControlSet\\Services\\Tcpip\\Parameters"
#define WIN95_TCPIP_REG_LOCATION    "System\\CurrentControlSet\\Services\\VxD\\MSTCP"
#define DNS_QUERY_TIMEOUTS              "DnsQueryTimeouts"
#define DNS_QUICK_QUERY_TIMEOUTS        "DnsQuickQueryTimeouts"
#define DNS_MULTICAST_QUERY_TIMEOUTS    "DnsMulticastQueryTimeouts"

//
//  Timeouts
//  MUST have terminating 0, this signals end of timeouts.
//  This is better than a timeout limit as different query types can
//  have different total retries.
//

DWORD   QueryTimeouts[] =
{
    1,      //  NT5 1,
    1,      //      2,
    2,      //      2,
    4,      //      4,
    7,      //      8,
    0       
};

DWORD   RegistryQueryTimeouts[DNS_MAX_QUERY_TIMEOUTS + 1];
LPDWORD g_QueryTimeouts = QueryTimeouts;

DWORD   QuickQueryTimeouts[] =
{
    1,
    2,
    2,
    0
};

DWORD   RegistryQuickQueryTimeouts[DNS_MAX_QUERY_TIMEOUTS + 1];
LPDWORD g_QuickQueryTimeouts = QuickQueryTimeouts;

//
//  Update timeouts.
//  Must be long enough to handle zone lock on primary for XFR
//  or time required for DS write.
//

DWORD   UpdateTimeouts[] =
{
    5,
    10,
    20,
    0
};

//
//  Multicast Query timeouts.
//  Local only.  1sec timeout, three retries.
//

DWORD   MulticastQueryTimeouts[] =
{
    1,
    1,
    1,
    0
};

DWORD   RegistryMulticastQueryTimeouts[DNS_MAX_QUERY_TIMEOUTS + 1];
LPDWORD g_MulticastQueryTimeouts = MulticastQueryTimeouts;


//
//  Failure priority boosts
//

#define TIMEOUT_PRIORITY_DROP           (10)
#define SERVER_FAILURE_PRIORITY_DROP    (1)
#define NO_DNS_PRIORITY_DROP            (200)


//
//  Query flag
//
//  Flags that terminate query on adapter

#define RUN_FLAG_COMBINED_IGNORE_ADAPTER \
        (RUN_FLAG_IGNORE_ADAPTER | RUN_FLAG_STOP_QUERY_ON_ADAPTER)

//
//  Return flags
//
//  Flags that are not cleaned up

#define DNS_FLAGS_NOT_RESET     (DNS_FLAG_IGNORE_ADAPTER)


//
//  Authoritative empty response
//      - map to NXRRSET for tracking in send code
//

#define DNS_RCODE_AUTH_EMPTY_RESPONSE       (DNS_RCODE_NXRRSET)




//
//  Dummy no-send-to-this-server error code
//

#define DNS_ERROR_NO_SEND   ((DWORD)(-100))

//
//  ServerInfo address type check
//  Current server info address setup (a mistake) is
//          IP4_ADDRESS IpAddress
//          DWORD       Reserved[3]
//  Check that reserved DWORDs are zero is check that have
//  IP4 address
//

#if 0
//
//  This test is not working on IA64 -- not sure why
//
//  For quickie BVT fix we'll just rule out IA64 sends
//

IP6_ADDRESS g_Ip6EmptyAddress = { 0, 0, 0, 0 };
DWORD       g_Empty[4] = { 0, 0, 0, 0 };

#define IS_SERVER_INFO_ADDRESS_IP4( pIp )   \
        RtlEqualMemory(                     \
            (PDWORD)(pIp)+1,                \
            g_Empty,                        \
            sizeof(DWORD) * 3 )
#endif

#define IS_SERVER_INFO_ADDRESS_IP4( pIp )   TRUE



//
//  OPT failure tracking
//

BOOL
Dns_IsServerOptExclude(
    IN      IP4_ADDRESS     IpAddress
    );

VOID
Dns_SetServerOptExclude(
    IN      IP4_ADDRESS     IpAddress
    );


//
//  Private protos
//

DNS_STATUS
SendMessagePrivate(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PCHAR           pSendIp,
    IN      BOOL            fIp4,
    IN      BOOL            fNoOpt
    );




VOID
TimeoutDnsServers(
    IN      PDNS_NETINFO        pNetInfo,
    IN      DWORD               dwTimeout
    )
/*++

Routine Description:

    Mark a DNS server that timed out.

Arguments:

    pNetInfo -- struct with list of DNS servers

    dwTimeout -- timeout in seconds

Return Value:

    None.

--*/
{
    PDNS_ADAPTER        padapter;
    PDNS_SERVER_INFO    pserver;
    DWORD               lastSendIndex;
    DWORD               i;

    DNSDBG( SEND, (
        "Enter TimeoutDnsServers( %p, timeout=%d )\n",
        pNetInfo,
        dwTimeout ));

    DNS_ASSERT( pNetInfo );

    //
    //  find DNS server in list,
    //      -- drop its priority based on timeout
    //      -- if already has RCODE, then did not time out
    //
    //  if change a priority, then set flag at top of adapter list, so
    //  that global copy may be updated
    //

    for( i=0; i<pNetInfo->AdapterCount; i++ )
    {
        padapter = pNetInfo->AdapterArray[i];
        DNS_ASSERT( padapter );

        lastSendIndex = padapter->ServerIndex;

        if ( lastSendIndex == EMPTY_SERVER_INDEX ||
             lastSendIndex >= padapter->ServerCount )
        {
            continue;
        }

        //
        //  found last send DNS server
        //      - if it responded with status, then it didn't timeout
        //      (if responded with success, then query completed and
        //      we wouldn't be in this function)
        //
        //      - go "easy" on OPT sends;
        //          don't drop priority, just note timeout
        //

        pserver = &padapter->ServerArray[lastSendIndex];

        if ( TEST_DNSSS_STATUS(pserver->Status, DNSSS_SENT) )
        {
            DNSDBG( SEND, (
                "Timeout on server index=%d (padapter=%p)\n",
                lastSendIndex,
                padapter ));

            if ( TEST_DNSSS_STATUS(pserver->Status, DNSSS_SENT_NON_OPT) )
            {
                SET_SERVER_STATUS( pserver, DNSSS_TIMEOUT_NON_OPT );

                pserver->Priority += dwTimeout + TIMEOUT_PRIORITY_DROP;
                padapter->RunFlags |= RUN_FLAG_RESET_SERVER_PRIORITY;
                pNetInfo->ReturnFlags |= RUN_FLAG_RESET_SERVER_PRIORITY;
            }
            else
            {
                DNSDBG( SEND, (
                    "Timeout on server index=%d OPT only\n",
                    lastSendIndex ));

                SET_SERVER_STATUS( pserver, DNSSS_TIMEOUT_OPT );
            }
        }
    }
}



VOID
resetOnFinalTimeout(
    IN      PDNS_NETINFO        pNetInfo
    )
/*++

Routine Description:

    Markup network info on final timeout.

Arguments:

    pNetInfo -- struct with list of DNS servers

    dwTimeout -- timeout in seconds

Return Value:

    None.

--*/
{
    DWORD         i;
    PDNS_ADAPTER  padapter;

    //
    // We've timed out against all DNS server for a least
    // one of the adapters. Update adapter status to show
    // time out error.
    //
    //  DCR:  is final timeout correct
    //      - worried about timeout on some but not all servers
    //      case;  adapter shouldn't show timeout should it?
    //

    for ( i = 0; i < pNetInfo->AdapterCount; i++ )
    {
        padapter = pNetInfo->AdapterArray[i];

        if ( padapter->Status == NO_ERROR &&
             padapter->ServerIndex &&
             padapter->RunFlags & RUN_FLAG_RESET_SERVER_PRIORITY )
        {
            padapter->Status = ERROR_TIMEOUT;
        }
    }
}



DNS_STATUS
ResetDnsServerPriority(
    IN      PDNS_NETINFO        pNetInfo,
    IN      IP4_ADDRESS         IpDns,
    //IN      IP6_ADDRESS         IpDns,
    //IN      PIP6_ADDRESS         pIpDns,
    IN      DNS_STATUS          Status
    )
/*++

Routine Description:

    Reset priority on DNS server that sent response.

    // DCR:  needs IP6 entry

Arguments:

    pNetInfo -- struct with list of DNS servers

    IpDns -- IP address of DNS that responded

    Status -- RCODE of response

Return Value:

    ERROR_SUCCESS if continue query.
    DNS_ERROR_RCODE_NAME_ERROR if all (valid) adapters have name-error or auth-empty response.

--*/
{
    PDNS_ADAPTER      padapter;
    PDNS_SERVER_INFO  pserver;
    DWORD             i;
    DWORD             j;
    DNS_STATUS        result = DNS_ERROR_RCODE_NAME_ERROR;
#if DBG
    BOOL              freset = FALSE;
#endif

    DNSDBG( SEND, (
        "Enter ResetDnsServerPriority( %p, %s rcode=%d)\n",
        pNetInfo,
        IP_STRING(IpDns),
        Status ));

    DNS_ASSERT( pNetInfo );

    //
    //  find DNS server in list, clear its priority field
    //
    //  note:  going through full list here after found DNS
    //  this is to avoid starving DNS by failing to clear priority field;
    //  if have guaranteed non-overlapping lists, then can terminate
    //      loop on find
    //

    for( i=0; i<pNetInfo->AdapterCount; i++ )
    {
        padapter = pNetInfo->AdapterArray[i];

        for ( j=0; j<padapter->ServerCount; j++ )
        {
            pserver = & padapter->ServerArray[j];

            if ( IpDns != pserver->IpAddress )
            //if ( IpDns != *(PIP6_ADDRESS)&pserver->IpAddress )
            {
                continue;
            }

            pserver->Status = Status;
#if DBG
            freset = TRUE;
#endif
            //
            //  no DNS running
            //
            //  WSAECONNRESET reported for reception of ICMP unreachable, so
            //  no DNS is currently running on the IP;  that's a severe
            //  priority drop, worse than just TIMEOUT
            //

            if ( Status == WSAECONNRESET )
            {
                pserver->Priority += NO_DNS_PRIORITY_DROP;
                padapter->RunFlags |= RUN_FLAG_RESET_SERVER_PRIORITY;
                pNetInfo->ReturnFlags |= RUN_FLAG_RESET_SERVER_PRIORITY;
                break;
            }

            //  if SERVER_FAILURE rcode, may or may not indicate problem,
            //      (may be simply unable to contact remote DNS)
            //      but it certainly suggests trying other DNS servers in
            //      the list first
            //
            //  DCR_FIX:  SEVRFAIL response priority reset
            //      the explicitly correct approach would be to flag the
            //      SERVER_FAILURE error, but NOT reset the priority unless
            //      at the end of the query, we find another server in the list
            //      got a useful response

            if ( Status == DNS_ERROR_RCODE_SERVER_FAILURE )
            {
                pserver->Priority += SERVER_FAILURE_PRIORITY_DROP;
                padapter->RunFlags |= RUN_FLAG_RESET_SERVER_PRIORITY;
                pNetInfo->ReturnFlags |= RUN_FLAG_RESET_SERVER_PRIORITY;
                break;
            }

            //
            //  other status code indicates functioning DNS server,
            //      - reset the server's priority

            if ( pserver->Priority )
            {
                pserver->Priority = 0;
                padapter->RunFlags |= RUN_FLAG_RESET_SERVER_PRIORITY;
                pNetInfo->ReturnFlags |= RUN_FLAG_RESET_SERVER_PRIORITY;
            }

            //
            //  NAME_ERROR or AUTH-EMPTY response
            //      - save to server list for adapter to eliminate all
            //        further retries on this adapter's list
            //      - if not waiting for all adapters, then
            //        NAME_ERROR or no-records is terminal

            if ( Status == DNS_ERROR_RCODE_NAME_ERROR ||
                 Status == DNS_INFO_NO_RECORDS )
            {
                padapter->Status = Status;
                padapter->RunFlags |= RUN_FLAG_STOP_QUERY_ON_ADAPTER;

                if ( !g_WaitForNameErrorOnAll )
                {
                    result = DNS_ERROR_RCODE_NAME_ERROR;
                    goto Done;
                }
            }
            break;
        }

        //
        //  do running check that still adapter worth querying
        //      - not ignoring in first place
        //      - hasn't received NAME_ERROR or AUTH_EMPTY response
        //
        //  this is "at recv" check -- only trying to determine if we
        //  should stop query RIGHT NOW as a result of this receive;
        //  this does NOT check on whether there are any other servers
        //  worth querying as that is done when go back for next send
        //
        //  note how this works -- result starts as NAME_ERROR, when find
        //      ANY adapter that hasn't gotten terminal response, then
        //      result shifts (and stays) at ERROR_SUCCESS
        //
        //  note, if we fix the twice through list issue above, then have to
        //  change this so don't skip adapter lists after IP is found
        //

        if ( !(padapter->RunFlags & RUN_FLAG_COMBINED_IGNORE_ADAPTER) )
        {
            result = ERROR_SUCCESS;
        }
    }

Done:

#if DBG
    if ( !freset )
    {
        DNSDBG( ANY, (
            "ERROR:  DNS server %s not in list.\n", IP_STRING(IpDns) ));
        DNS_ASSERT( FALSE );
    }
#endif
    return( result );
}



PDNS_SERVER_INFO
bestDnsServerForNextSend(
    IN      PDNS_ADAPTER     pAdapter
    )
/*++

Routine Description:

    Get best DNS server IP address from list.

Arguments:

    pAdapter -- struct with list of DNS servers

Return Value:

    Ptr to server info of best send.
    NULL if no server on adapter is worth sending to;  this is
        the case if all servers have received a response.

--*/
{
    PDNS_SERVER_INFO    pserver;
    DWORD               i;
    DWORD               status;
    DWORD               priority;
    DWORD               priorityBest = MAXDWORD;
    PDNS_SERVER_INFO    pbestServer = NULL;
    DWORD               bestIndex = EMPTY_SERVER_INDEX;


    DNSDBG( SEND, (
        "Enter bestDnsServerForNextSend( %p )\n",
        pAdapter ));

    if ( !pAdapter || !pAdapter->ServerCount )
    {
        DNSDBG( SEND, (
            "WARNING:  Leaving bestDnsServerForNextSend, no server list\n" ));
        return( NULL );
    }

    //
    //  if already received name error on server in this list, done
    //

    if ( pAdapter->Status == DNS_ERROR_RCODE_NAME_ERROR ||
         pAdapter->Status == DNS_INFO_NO_RECORDS )
    {
        DNSDBG( SEND, (
            "Leaving bestDnsServerForNextSend, NAME_ERROR already received\n"
            "\ton server in server list %p\n",
            pAdapter ));
        return( NULL );
    }

    //
    //  check each server in list
    //

    for ( i=0; i<pAdapter->ServerCount; i++ )
    {
        pserver = & pAdapter->ServerArray[i];

        //  if server has already recieved a response, then skip it

        status = pserver->Status;

        if ( TEST_DNSSS_VALID_RECV(status) )
        {
            //  NAME_ERROR or EMPTY_AUTH then adapter should have been
            //      marked as "done" and we shouldn't be here
            //  NO_ERROR should have exited immediately

            DNS_ASSERT( status != NO_ERROR &&
                        status != DNS_ERROR_RCODE_NAME_ERROR &&
                        status != DNS_INFO_NO_RECORDS );
            continue;
        }

        //  return first "clean" server
        //  or return one with lowest dings
        //
        //  DCR:  skip NO_DNS server for a while
        //        skip timeout server for a little while
        //      perhaps this should be done be ignoring these
        //      when list is sent down?
        
        priority = pserver->Priority;

        if ( priority < priorityBest )
        {
            bestIndex = i;
            pbestServer = pserver;

            if ( priority == 0 )
            {
                break;
            }
        }
    }

    //  save off IP of server we are using

    if ( pbestServer )
    {
        pAdapter->ServerIndex = bestIndex;
    }
    return( pbestServer );
}




DNS_STATUS
SendUsingServerInfo(
    IN OUT  PDNS_MSG_BUF        pMsg,
    IN OUT  PDNS_SERVER_INFO    pServInfo
    )
/*++

Routine Description:

    Send DNS message using server info.

    This function encapsulates the process of checking
    server info for validity, sending (as appropriate)
    and marking servinfo result.

    Note:  right now this is UDP only;  may need to expand

Arguments:

    pMsg - message info for message to send

    pServInfo - info of server to send to

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on send failure.
    

--*/
{
    DNS_STATUS      status;
    BOOL            fnoOpt;
    BOOL            fip4;
    IP4_ADDRESS     ip4;

    DNSDBG( SEND, (
        "SendUsingServerInfo( msg=%p, servinfo=%p )\n",
        pMsg ));

    //
    //  check that haven't already completed send\recv
    //

    if ( TEST_DNSSS_VALID_RECV( pServInfo->Status ) )
    {
        return  DNS_ERROR_NO_SEND;
    }

    //
    //  check OPT status
    //      - previous OPT send that timed OUT, then send non-OPT
    //
    //  DCR:  known OPT-ok list could screen wasted send

    fnoOpt = TEST_DNSSS_STATUS( pServInfo->Status, DNSSS_SENT_OPT );

    //
    //  send
    //

    status = SendMessagePrivate(
                pMsg,
                (PCHAR) &pServInfo->IpAddress,
                IS_SERVER_INFO_ADDRESS_IP4( &pServInfo->IpAddress ),
                fnoOpt );

    if ( status == ERROR_SUCCESS )
    {
        DNS_ASSERT( !fnoOpt || !pMsg->fLastSendOpt );

        SET_SERVER_STATUS(
            pServInfo,
            pMsg->fLastSendOpt
                ? DNSSS_SENT_OPT
                : DNSSS_SENT_NON_OPT);
    }

    return  status;
}



DNS_STATUS
SendUdpToNextDnsServers(
    IN OUT  PDNS_MSG_BUF        pMsgSend,
    IN OUT  PDNS_NETINFO        pNetInfo,
    IN      DWORD               cRetryCount,
    IN      DWORD               dwTimeout,
    OUT     PDWORD              pSendCount
    )
/*++

Routine Description:

    Sends to next DNS servers in list.

Arguments:

    pMsgSend        -- message to send

    pNetInfo    -- per adapter DNS info

    cRetryCount     -- retry for this send

    dwTimeout       -- timeout on last send, if timed out

    pSendCount      -- addr to receive send count

Return Value:

    ERROR_SUCCESS if successful send.
    ERROR_TIMEOUT if no DNS servers left to send to.
    Winsock error code on send failure.

--*/
{
    DWORD               i;
    DWORD               j;
    DWORD               sendCount = 0;
    PDNS_ADAPTER        padapter;
    PDNS_SERVER_INFO    pserver;
    DNS_STATUS          status = ERROR_TIMEOUT;

    DNSDBG( SEND, (
        "Enter SendUdpToNextDnsServers()\n"
        "\tretry = %d\n",
        cRetryCount ));


    //
    //  if netinfo not initialized for send, init
    //

    if ( !(pNetInfo->ReturnFlags & RUN_FLAG_NETINFO_PREPARED) )
    {
        DNSDBG( SEND, ( "Netinfo not prepared for send -- preparing now.\n" ));

        NetInfo_Clean(
            pNetInfo,
            CLEAR_LEVEL_QUERY );
    }

#if DBG
    //
    //  verify i'm getting a clean list on start
    //

    if ( cRetryCount == 0 )
    {
        for( i=0; i<pNetInfo->AdapterCount; i++ )
        {
            padapter = pNetInfo->AdapterArray[i];

            //  ignore this adapter because there are no DNS
            //  servers configured?

            if ( padapter->InfoFlags & DNS_FLAG_IGNORE_ADAPTER )
            {
                continue;
            }

            DNS_ASSERT( padapter->ServerIndex == EMPTY_SERVER_INDEX );
            DNS_ASSERT( padapter->Status == 0 );

            for ( j=0; j<padapter->ServerCount; j++ )
            {
                DNS_ASSERT( padapter->ServerArray[j].Status == DNSSS_NEW );
            }
        }
    }
#endif

    //
    //  if previous send timed out, update adapter list
    //      - but ONLY do this when sending to individual servers in list
    //      - timeout on all servers just produces an unnecessary copy and
    //      can only change ordering relative to servers which have already
    //      responded with RCODE;  since its a timeout, this isn't going to
    //      lower these server's priority so no point
    //

    if ( dwTimeout  &&  cRetryCount  &&  cRetryCount < MAX_SINGLE_SERVER_RETRY )
    {
        TimeoutDnsServers( pNetInfo, dwTimeout );
    }

    //
    //  send on DNS server(s) for adapter(s)
    //

    for( i=0; i<pNetInfo->AdapterCount; i++ )
    {
        padapter = pNetInfo->AdapterArray[i];

        //  ignore this adapter
        //      - no DNS servers
        //      - not querying this adapter name
        //      - already responded to this name

        if ( ( padapter->InfoFlags & DNS_FLAG_IGNORE_ADAPTER ) ||
             ( padapter->RunFlags & RUN_FLAG_STOP_QUERY_ON_ADAPTER ) )
        {
            continue;
        }

        //
        //  first three attempts, we only go to one DNS on a given adapter
        //
        //      - first time through ONLY to first server in first adapter list
        //      - on subsequent tries go to best server in all lists
        //

        if ( cRetryCount < MAX_SINGLE_SERVER_RETRY )
        {
            pserver = bestDnsServerForNextSend( padapter );
            if ( !pserver )
            {
                continue;
            }

            status = SendUsingServerInfo(
                        pMsgSend,
                        pserver );

            if ( status == ERROR_SUCCESS )
            {
                sendCount++;
                if ( cRetryCount == 0 )
                {
                    break;
                }
                continue;
            }
            if ( status == DNS_ERROR_NO_SEND )
            {
                continue;
            }

            //  quit on send error

            break;
        }

        //
        //  after first three tries, send to all servers that
        //  have not already responded (have RCODE, as if NO_ERROR) we
        //  already finished
        //

        else
        {
            for ( j=0; j<padapter->ServerCount; j++ )
            {
                status = SendUsingServerInfo(
                            pMsgSend,
                            &padapter->ServerArray[j] );

                if ( status == ERROR_SUCCESS )
                {
                    sendCount++;
                    continue;
                }
                if ( status == DNS_ERROR_NO_SEND )
                {
                    continue;
                }
                break;
            }
        }
    }

    //
    //  if sent packet, success
    //

    *pSendCount = sendCount;

    DNSDBG( SEND, (
        "Leave SendUdpToNextDnsServers()\n"
        "\tsends = %d\n",
        sendCount ));

    if ( sendCount )
    {
        return( ERROR_SUCCESS );
    }

    //  if no packets sent, alert caller we're done
    //      - this is possible if servers have responded uselessly
    //      (NAME_ERROR, SERVER_FAILURE)

    if ( status == ERROR_SUCCESS )
    {
        status = ERROR_TIMEOUT;
    }
    return( status );
}




//
//  Send routines
//

VOID
SetMsgRemoteSockaddr(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PIP6_ADDRESS    pIpAddr,
    IN      BOOL            fIp4
    )
/*++

Routine Description:

    Initialize remote sockaddr.

    Note:  this handles IP4 or IP6
    This could be changed to simply test for IP4_MAPPED
    and simply pass address pointer.

Arguments:

    pMsg - message to send

    fIp4 - TRUE if IP4

    pIp6Addr - IP address to send

Return Value:

    None.

--*/
{
    //  zero

    RtlZeroMemory(
        & pMsg->RemoteAddress,
        sizeof( pMsg->RemoteAddress ) );

    //
    //  fill in for IP4 or IP6
    //
    //  DCR:  just pass in IP6_ADDRESS
    //      then test for V4 mapped
    //      if ( IN6_IS_ADDR_V4MAPPED(IpAddress) )
    //

    if ( fIp4 )
    {
        pMsg->RemoteAddress.In4.sin_family    = AF_INET;
        pMsg->RemoteAddress.In4.sin_port      = DNS_PORT_NET_ORDER;
        pMsg->RemoteAddress.In4.sin_addr.s_addr = *(PIP4_ADDRESS) pIpAddr;

        pMsg->RemoteAddressLength = sizeof(SOCKADDR_IN);
    }
    else
    {
        pMsg->RemoteAddress.In6.sin6_family    = AF_INET6;
        pMsg->RemoteAddress.In6.sin6_port      = DNS_PORT_NET_ORDER;

        RtlCopyMemory(
            (PIP6_ADDRESS) &pMsg->RemoteAddress.In6.sin6_addr,
            pIpAddr,
            sizeof(IP6_ADDRESS) );

        pMsg->RemoteAddressLength = sizeof(SOCKADDR_IN6);
    }
}



VOID
Dns_InitializeMsgRemoteSockaddr(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      IP4_ADDRESS     IpAddr
    )
/*++

Routine Description:

    Initialize remote sockaddr.

    Note:  EXPORTED function

    //  DCR:  EXPORTED may remove when clean

Arguments:

    pMsg - message to send

    IpAddr - IP4 address to send to

Return Value:

    None.

--*/
{
    IP4_ADDRESS ip4 = IpAddr;

    SetMsgRemoteSockaddr(
        pMsg,
        (PIP6_ADDRESS) &ip4,
        TRUE                    // IP4
        );
}



DNS_STATUS
SendMessagePrivate(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PCHAR           pSendIp,
    IN      BOOL            fIp4,
    IN      BOOL            fNoOpt
    )
/*++

Routine Description:

    Send a DNS packet.

    This is the generic send routine used for ANY send of a DNS message.

    It assumes nothing about the message type, but does assume:
        - pCurrent points at byte following end of desired data
        - RR count bytes are in HOST byte order

Arguments:

    pMsg - message info for message to send

    pSendIp - ptr to IP address to send to
        OPTIONAL, required only if UDP and message sockaddr not set

    fIp4 -- TRUE if IP4, FALSE for IP6

    fNoOpt - TRUE if OPT send is forbidden

Return Value:

    TRUE if successful.
    FALSE on send error.

--*/
{
    PDNS_HEADER pmsgHead;
    INT         err;
    WORD        sendLength;
    BOOL        fexcludedOpt = FALSE;

    DNSDBG( SEND, (
        "SendMessagePrivate()\n"
        "\tpMsg         = %p\n"
        "\tpSendIp      = %p\n"
        "\tIs IP4       = %d\n"
        "\tNo OPT       = %d\n",
        pMsg,
        pSendIp,
        fIp4,
        fNoOpt ));

    //
    //  set header flags
    //
    //  note:  since route sends both queries and responses
    //      caller must set these flags
    //

    pmsgHead = &pMsg->MessageHead;
    pmsgHead->Reserved = 0;

    //
    //  set send IP (if given)
    //

    if ( pSendIp )
    {
        SetMsgRemoteSockaddr(
            pMsg,
            (PIP6_ADDRESS) pSendIp,
            fIp4 );
    }

    //
    //  set message length and OPT inclusion
    //
    //  OPT approach is
    //      - write to pCurrent packet end
    //          - handles NO OPT written and using OPT
    //      - unless HAVE written OPT, and specifically excluding
    //          note, that zero IP (TCP previously connected) gets
    //          excluded
    //
    //  DCR:  we haven't handled OPT for TCP connected and not-aware of IP
    //      case here
    //
    //  DCR:  for now excluding OPT on updates, because harder to detect on
    //      the recv end why the reason for the failure
    //

    {
        PCHAR   pend = pMsg->pCurrent;

        if ( pMsg->pPreOptEnd
                &&
             ( fNoOpt 
                    ||
               g_UseEdns == 0
                    ||
               pMsg->MessageHead.Opcode == DNS_OPCODE_UPDATE
                    ||
               Dns_IsServerOptExclude( MSG_REMOTE_IP4(pMsg) ) ) )
        {
            ASSERT( pMsg->pPreOptEnd > (PCHAR)pmsgHead );
            ASSERT( pMsg->pPreOptEnd < pend );

            pend = pMsg->pPreOptEnd;
            pmsgHead->AdditionalCount--;
            fexcludedOpt = TRUE;
        }

        sendLength = (WORD)(pend - (PCHAR)pmsgHead);

        pMsg->fLastSendOpt = (pMsg->pPreOptEnd && (pend != pMsg->pPreOptEnd));
    }

    IF_DNSDBG( SEND )
    {
        pMsg->MessageLength = sendLength;
        DnsDbg_Message(
            "Sending packet",
            pMsg );
    }

    //
    //  flip header count bytes
    //

    DNS_BYTE_FLIP_HEADER_COUNTS( pmsgHead );

    //
    //  TCP -- send until all info transmitted
    //

    if ( pMsg->fTcp )
    {
        PCHAR   psend;

        //
        //  TCP message always begins with bytes being sent
        //
        //      - send length = message length plus two byte size
        //      - flip bytes in message length
        //      - send starting at message length
        //

        pMsg->MessageLength = htons( sendLength );

        sendLength += sizeof(WORD);

        psend = (PCHAR) &pMsg->MessageLength;

        while ( sendLength )
        {
            err = send(
                    pMsg->Socket,
                    psend,
                    (INT) sendLength,
                    0 );

            if ( err == 0 || err == SOCKET_ERROR )
            {
                err = GetLastError();

                //
                //  WSAESHUTDOWN is ok, client got timed out connection and
                //      closed
                //
                //  WSAENOTSOCK may also occur if FIN recv'd and connection
                //      closed by TCP receive thread before the send
                //

                if ( err == WSAESHUTDOWN )
                {
                    IF_DNSDBG( ANY )
                    {
                        DNS_PRINT((
                            "WARNING:  send() failed on shutdown socket %d.\n"
                            "\tpMsgInfo at %p\n",
                            pMsg->Socket,
                            pMsg ));
                    }
                }
                else if ( err == WSAENOTSOCK )
                {
                    IF_DNSDBG( ANY )
                    {
                        DNS_PRINT((
                            "ERROR:  send() on closed socket %d.\n"
                            "\tpMsgInfo at %p\n",
                            pMsg->Socket,
                            pMsg ));
                    }
                }
                else
                {
                    DNS_LOG_EVENT(
                        DNS_EVENT_SEND_CALL_FAILED,
                        0,
                        NULL,
                        err );

                    IF_DNSDBG( ANY )
                    {
                        DNS_PRINT(( "ERROR:  TCP send() failed, err = %d.\n" ));
                    }
                }
                goto Done;
            }
            sendLength -= (WORD)err;
            psend += err;
        }
    }

    //
    //  UDP
    //

    else
    {
        DNS_ASSERT( sendLength <= DNS_RFC_MAX_UDP_PACKET_LENGTH );

        err = sendto(
                    pMsg->Socket,
                    (PCHAR) pmsgHead,
                    sendLength,
                    0,
                    (PSOCKADDR) &pMsg->RemoteAddress,
                    pMsg->RemoteAddressLength
                    );

        if ( err == SOCKET_ERROR )
        {
            err = GetLastError();

            DNS_LOG_EVENT(
                DNS_EVENT_SENDTO_CALL_FAILED,
                0,
                NULL,
                err );

            IF_DNSDBG( ANY )
            {
                DNS_PRINT(( "ERROR:  UDP sendto() failed.\n" ));

                DnsDbg_SockaddrIn(
                    "sendto() failed sockaddr\n",
                    (PSOCKADDR_IN) &pMsg->RemoteAddress,
                    pMsg->RemoteAddressLength );

                DnsDbg_Message(
                    "sendto() failed message",
                    pMsg );
            }
            goto Done;
        }
    }

    err = ERROR_SUCCESS;

Done:

    DNS_BYTE_FLIP_HEADER_COUNTS( pmsgHead );

    //  restore OPT in count if required

    if ( fexcludedOpt )
    {
        pmsgHead->AdditionalCount++;
    }

    Trace_LogSendEvent( pMsg, err );

    return( (DNS_STATUS)err );
}



DNS_STATUS
Dns_SendEx(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      IP4_ADDRESS     SendIp,     OPTIONAL
    IN      BOOL            fNoOpt
    )
/*++

Routine Description:

    Send a DNS packet.

    This is the generic send routine used for ANY send of a DNS message.

    It assumes nothing about the message type, but does assume:
        - pCurrent points at byte following end of desired data
        - RR count bytes are in HOST byte order

    Note:  EXPORTED function

    DCR:  Remove Dns_SendEx() from export when ICS fixed

Arguments:

    pMsg - message info for message to send

    SendIp - IP to send to;  OPTIONAL, required only if UDP
                and message sockaddr not set

    fNoOpt - TRUE if OPT send is forbidden

Return Value:

    TRUE if successful.
    FALSE on send error.

--*/
{
    IP4_ADDRESS     ip4 = SendIp;

    return SendMessagePrivate(
                pMsg,
                (PCHAR) &ip4,
                TRUE,       // sending IP4
                fNoOpt
                );
}



//
//  UDP routines
//

VOID
Dns_SendMultipleUdp(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PIP_ARRAY       aipSendAddrs
    )
/*++

Routine Description:

    Send a DNS packet to multiple destinations.

    Assumes packet is in same state as normal send
        - host order count and XID
        - pCurrent pointing at byte after desired data

Arguments:

    pMsg - message info for message to send and reuse

    aipSendAddrs - IP array of addrs to send to

Return Value:

    None.

--*/
{
    DWORD   i;

    //
    //  no targets
    //

    if ( !aipSendAddrs )
    {
        return;
    }

    //
    //  send the to each address specified in IP array
    //

    for ( i=0; i < aipSendAddrs->AddrCount; i++ )
    {
        SendMessagePrivate(
            pMsg,
            (PCHAR) &aipSendAddrs->AddrArray[i],
            TRUE,       // IP4
            0 );
    }
}



DNS_STATUS
Dns_RecvUdp(
    IN 