 ultflag. This is the routine that actually does the work for both
*       _mktime64() and _mkgmtime64().
*
*Entry:
*       struct tm *tb - pointer to a tm time structure to convert and
*                       normalize
*       int ultflag   - use local time flag. the tb structure is assumed
*                       to represent a local date/time if ultflag > 0.
*                       otherwise, UTC is assumed.
*
*Exit:
*       If successful, _mktime64 returns the specified calender time encoded
*       as a __time64_t value. Otherwise, (__time64_t)(-1) is returned to
*       indicate an error.
*
*Exceptions:
*       None.
*
*******************************************************************************/

static __time64_t __cdecl _make__time64_t (
        struct tm *tb,
        int ultflag
        )
{
        __time64_t tmptm1, tmptm2, tmptm3;
        struct tm *tbtemp;

        /*
         * First, make sure tm_year is reasonably close to being in range.
         */
        if ( ((tmptm1 = tb->tm_year) < _BASE_YEAR - 1) || (tmptm1 > _MAX_YEAR64
          + 1) )
            goto err_mktime;


        /*
         * Adjust month value so it is in the range 0 - 11.  This is because
         * we don't know how many days are in months 12, 13, 14, etc.
         */

        if ( (tb->tm_mon < 0) || (tb->tm_mon > 11) ) {

            tmptm1 += (tb->tm_mon / 12);

            if ( (tb->tm_mon %= 12) < 0 ) {
                tb->tm_mon += 12;
                tmptm1--;
            }

            /*
             * Make sure year count is still in range.
             */
            if ( (tmptm1 < _BASE_YEAR - 1) || (tmptm1 > _MAX_YEAR64 + 1) )
                goto err_mktime;
        }

        /***** HERE: tmptm1 holds number of elapsed years *****/

        /*
         * Calculate days elapsed minus one, in the given year, to the given
         * month. Check for leap year and adjust if necessary.
         */
        tmptm2 = _days[tb->tm_mon];
        if ( _IS_LEAP_YEAR(tmptm1) && (tb->tm_mon > 1) )
                tmptm2++;

        /*
         * Calculate elapsed days since base date (midnight, 1/1/70, UTC)
         *
         *
         * 365 days for each elapsed year since 1970, plus one more day for
         * each elapsed leap year. no danger of overflow because of the range
         * check (above) on tmptm1.
         */
        tmptm3 = (tmptm1 - _BASE_YEAR) * 365 + _ELAPSED_LEAP_YEARS(tmptm1);

        /*
         * elapsed days to current month (still no possible overflow)
         */
        tmptm3 += tmptm2;

        /*
         * elapsed days to current date.
         */
        tmptm1 = tmptm3 + (tmptm2 = (__time64_t)(tb->tm_mday));

        /***** HERE: tmptm1 holds number of elapsed days *****/

        /*
         * Calculate elapsed hours since base date
         */
        tmptm2 = tmptm1 * 24;

        tmptm1 = tmptm2 + (tmptm3 = (__time64_t)tb->tm_hour);

        /***** HERE: tmptm1 holds number of elapsed hours *****/

        /*
         * Calculate elapsed minutes since base date
         */

        tmptm2 = tmptm1 * 60;

        tmptm1 = tmptm2 + (tmptm3 = (__time64_t)tb->tm_min);

        /***** HERE: tmptm1 holds number of elapsed minutes *****/

        /*
         * Calculate elapsed seconds since base date
         */

        tmptm2 = tmptm1 * 60;

        tmptm1 = tmptm2 + (tmptm3 = (__time64_t)tb->tm_sec);

        /***** HERE: tmptm1 holds number of elapsed seconds *****/

        if  ( ultflag ) {

            /*
             * Adjust for timezone. No need to check for overflow since
             * localtime() will check its arg value
             */

#ifdef _POSIX_
            tzset();
#else
            __tzset();
#endif

            tmptm1 += _timezone;

            /*
             * Convert this second count back into a time block structure.
             * If localtime returns NULL, return an error.
             */
            if ( (tbtemp = _localtime64(&tmptm1)) == NULL )
                goto err_mktime;

            /*
             * Now must compensate for DST. The ANSI rules are to use the
             * passed-in tm_isdst flag if it is non-negative. Otherwise,
             * compute if DST applies. Recall that tbtemp has the time without
             * DST compensation, but has set tm_isdst correctly.
             */
            if ( (tb->tm_isdst > 0) || ((tb->tm_isdst < 0) &&
              (tbtemp->tm_isdst > 0)) ) {
#ifdef _POSIX_
                tmptm1 -= _timezone;
                tmptm1 += _dstoffset;
#else
                tmptm1 += _dstbias;
#endif
                tbtemp = _localtime64(&tmptm1); /* reconvert, can't get NULL */
            }

        } 
        else {
            if ( (tbtemp = _gmtime64(&tmptm1)) == NULL )
                goto err_mktime;
        }

        /***** HERE: tmptm1 holds number of elapsed seconds, adjusted *****/
        /*****       for local time if requested                      *****/

        *tb = *tbtemp;
        return tmptm1;

err_mktime:
        /*
         * All errors come to here
         */
        return (__time64_t)(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\mktime.c ===
/***
*mktime.c - Convert struct tm value to time_t value.
*
*       Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines mktime() and _mkgmtime(), routines to converts a time value
*       in a tm structure (possibly incomplete) into a time_t value, then
*       update (all) the structure fields with "normalized" values.
*
*Revision History:
*       01-14-87  JCR   Module created
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       06-15-89  PHG   Now allows negative values and does DST by ANSI rules
*       11-06-89  KRS   Added (unsigned) to handle years 2040-2099 correctly.
*       03-20-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and fixed the copyright. Also, cleaned
*                       up the formatting a bit.
*       10-04-90  GJF   New-style function declarator. Also, rewrote expr.
*                       to avoid using casts as lvalues.
*       10-26-90  GJF   Added ulscount to avoid overflows. Ugly, temporary
*                       hack (whole function needs to be revised for ANSI
*                       conformance).
*       01-22-91  GJF   ANSI naming.
*       03-24-93  GJF   Propagated changes from 16-bit tree. Modified to
*                       expose _mkgmtime() routine.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-15-93  GJF   Replaced _tzset() call with __tzset() call.
*       09-13-93  GJF   Merged NT SDK and Cuda versions (amounted to picking
*                       up MattBr's changes to the Posix build made last
*                       April).
*       02-10-95  GJF   Conditionally call _tzset instead of __tzset for Mac
*                       builds (probably temporary change).
*       05-09-95  GJF   Properly handle initial tm_mon values from -11 to -1.
*       08-31-95  GJF   Use _dstbias for Daylight Saving Time bias instead of
*                       -3600L.
*       05-17-99  PML   Remove all Macintosh support.
*       08-30-99  PML   long -> time_t in a few casts.
*
*******************************************************************************/

#include <cruntime.h>
#include <stddef.h>
#include <ctime.h>
#include <time.h>
#include <internal.h>

/*
 * ChkAdd evaluates to TRUE if dest = src1 + src2 has overflowed
 */
#define ChkAdd(dest, src1, src2)   ( ((src1 >= 0L) && (src2 >= 0L) \
    && (dest < 0L)) || ((src1 < 0L) && (src2 < 0L) && (dest >= 0L)) )

/*
 * ChkMul evaluates to TRUE if dest = src1 * src2 has overflowed
 */
#define ChkMul(dest, src1, src2)   ( src1 ? (dest/src1 != src2) : 0 )


/*
 * Core function for both mktime() and _mkgmtime()
 */
static time_t __cdecl _make_time_t( struct tm *, int);


/***
*time_t mktime(tb) - Normalize user time block structure
*
*Purpose:
*       Mktime converts a time structure, passed in as an argument, into a
*       calendar time value in internal format (time_t). It also completes
*       and updates the fields the of the passed in structure with 'normalized'
*       values. There are three practical uses for this routine:
*
*       (1) Convert broken-down time to internal time format (time_t).
*       (2) To have mktime fill in the tm_wday, tm_yday, or tm_isdst fields.
*       (3) To pass in a time structure with 'out of range' values for some
*           fields and have mktime "normalize" them (e.g., pass in 1/35/87 and
*           get back 2/4/87).
*Entry:
*       struct tm *tb - pointer to a tm time structure to convert and
*                       normalize
*
*Exit:
*       If successful, mktime returns the specified calender time encoded as
*       a time_t value. Otherwise, (time_t)(-1) is returned to indicate an
*       error.
*
*Exceptions:
*       None.
*
*******************************************************************************/


time_t __cdecl mktime (
        struct tm *tb
        )
{
        return( _make_time_t(tb, 1) );
}


/***
*time_t _mkgmtime(tb) - Convert broken down UTC time to time_t
*
*Purpose:
*       Convert a tm structure, passed in as an argument, containing a UTC
*       time value to internal format (time_t). It also completes and updates
*       the fields the of the passed in structure with 'normalized' values.

*Entry:
*       struct tm *tb - pointer to a tm time structure to convert and
*                       normalize
*
*Exit:
*       If successful, _mkgmtime returns the calender time encoded as time_t
*       Otherwise, (time_t)(-1) is returned to indicate an error.
*
*Exceptions:
*       None.
*
*******************************************************************************/

time_t __cdecl _mkgmtime (
        struct tm *tb
        )
{
        return( _make_time_t(tb, 0) );
}


/***
*static time_t make_time_t(tb, ultflag) -
*
*Purpose:
*       Converts a struct tm value to a time_t value, then updates the struct
*       tm value. Either local time or UTC is supported, based on ultflag.
*       This is the routine that actually does the work for both mktime() and
*       _mkgmtime().
*
*Entry:
*       struct tm *tb - pointer to a tm time structure to convert and
*                       normalize
*       int ultflag   - use local time flag. the tb structure is assumed
*                       to represent a local date/time if ultflag > 0.
*                       otherwise, UTC is assumed.
*
*Exit:
*       If successful, mktime returns the specified calender time encoded as
*       a time_t value. Otherwise, (time_t)(-1) is returned to indicate an
*       error.
*
*Exceptions:
*       None.
*
*******************************************************************************/

static time_t __cdecl _make_time_t (
        struct tm *tb,
        int ultflag
        )
{
        time_t tmptm1, tmptm2, tmptm3;
        struct tm *tbtemp;

        /*
         * First, make sure tm_year is reasonably close to being in range.
         */
        if ( ((tmptm1 = tb->tm_year) < _BASE_YEAR - 1) || (tmptm1 > _MAX_YEAR
          + 1) )
            goto err_mktime;


        /*
         * Adjust month value so it is in the range 0 - 11.  This is because
         * we don't know how many days are in months 12, 13, 14, etc.
         */

        if ( (tb->tm_mon < 0) || (tb->tm_mon > 11) ) {

            /*
             * no danger of overflow because the range check above.
             */
            tmptm1 += (tb->tm_mon / 12);

            if ( (tb->tm_mon %= 12) < 0 ) {
                tb->tm_mon += 12;
                tmptm1--;
            }

            /*
             * Make sure year count is still in range.
             */
            if ( (tmptm1 < _BASE_YEAR - 1) || (tmptm1 > _MAX_YEAR + 1) )
                goto err_mktime;
        }

        /***** HERE: tmptm1 holds number of elapsed years *****/

        /*
         * Calculate days elapsed minus one, in the given year, to the given
         * month. Check for leap year and adjust if necessary.
         */
        tmptm2 = _days[tb->tm_mon];
        if ( !(tmptm1 & 3) && (tb->tm_mon > 1) )
                tmptm2++;

        /*
         * Calculate elapsed days since base date (midnight, 1/1/70, UTC)
         *
         *
         * 365 days for each elapsed year since 1970, plus one more day for
         * each elapsed leap year. no danger of overflow because of the range
         * check (above) on tmptm1.
         */
        tmptm3 = (tmptm1 - _BASE_YEAR) * 365L + ((tmptm1 - 1L) >> 2)
          - _LEAP_YEAR_ADJUST;

        /*
         * elapsed days to current month (still no possible overflow)
         */
        tmptm3 += tmptm2;

        /*
         * elapsed days to current date. overflow is now possible.
         */
        tmptm1 = tmptm3 + (tmptm2 = (time_t)(tb->tm_mday));
        if ( ChkAdd(tmptm1, tmptm3, tmptm2) )
            goto err_mktime;

        /***** HERE: tmptm1 holds number of elapsed days *****/

        /*
         * Calculate elapsed hours since base date
         */
        tmptm2 = tmptm1 * 24L;
        if ( ChkMul(tmptm2, tmptm1, 24L) )
            goto err_mktime;

        tmptm1 = tmptm2 + (tmptm3 = (time_t)tb->tm_hour);
        if ( ChkAdd(tmptm1, tmptm2, tmptm3) )
            goto err_mktime;

        /***** HERE: tmptm1 holds number of elapsed hours *****/

        /*
         * Calculate elapsed minutes since base date
         */

        tmptm2 = tmptm1 * 60L;
        if ( ChkMul(tmptm2, tmptm1, 60L) )
            goto err_mktime;

        tmptm1 = tmptm2 + (tmptm3 = (time_t)tb->tm_min);
        if ( ChkAdd(tmptm1, tmptm2, tmptm3) )
            goto err_mktime;

        /***** HERE: tmptm1 holds number of elapsed minutes *****/

        /*
         * Calculate elapsed seconds since base date
         */

        tmptm2 = tmptm1 * 60L;
        if ( ChkMul(tmptm2, tmptm1, 60L) )
            goto err_mktime;

        tmptm1 = tmptm2 + (tmptm3 = (time_t)tb->tm_sec);
        if ( ChkAdd(tmptm1, tmptm2, tmptm3) )
            goto err_mktime;

        /***** HERE: tmptm1 holds number of elapsed seconds *****/

        if  ( ultflag ) {

            /*
             * Adjust for timezone. No need to check for overflow since
             * localtime() will check its arg value
             */

#ifdef _POSIX_
            tzset();
#else
            __tzset();
#endif

            tmptm1 += _timezone;

            /*
             * Convert this second count back into a time block structure.
             * If localtime returns NULL, return an error.
             */
            if ( (tbtemp = localtime(&tmptm1)) == NULL )
                goto err_mktime;

            /*
             * Now must compensate for DST. The ANSI rules are to use the
             * passed-in tm_isdst flag if it is non-negative. Otherwise,
             * compute if DST applies. Recall that tbtemp has the time without
             * DST compensation, but has set tm_isdst correctly.
             */
            if ( (tb->tm_isdst > 0) || ((tb->tm_isdst < 0) &&
              (tbtemp->tm_isdst > 0)) ) {
#ifdef _POSIX_
                tmptm1 -= _timezone;
                tmptm1 += _dstoffset;
#else
                tmptm1 += _dstbias;
#endif
                tbtemp = localtime(&tmptm1);    /* reconvert, can't get NULL */
            }

        } 
        else {
            if ( (tbtemp = gmtime(&tmptm1)) == NULL )
                goto err_mktime;
        }

        /***** HERE: tmptm1 holds number of elapsed seconds, adjusted *****/
        /*****       for local time if requested                      *****/

        *tb = *tbtemp;
        return (time_t)tmptm1;

err_mktime:
        /*
         * All errors come to here
         */
        return (time_t)(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\localtim.c ===
/***
*localtim.c - Convert time_t value to time structure
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts time stored as a time_t value to a structure of type
*       struct tm expressed as local time.
*
*Revision History:
*       01-??-84  RLB   Module created
*       05-??-84  DCW   split off from the rest of the ctime routines
*       02-18-87  JCR   made localtime work when gmtime returns null
*       03-31-87  JCR   fixed bug pertaining to uninitialized _isindst(tb)
*       04-10-87  JCR   changed long declaration to time_t and added const
*       11-10-87  SKS   Removed IBMC20 switch
*       11-18-87  SKS   Change tzset() to __tzset()
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-06-89  KRS   Added (unsigned) to handle years 2040-2099 correctly.
*       03-20-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h>, removed #include <register.h> and
*                       fixed the copyright. Also, cleaned up the formatting
*                       a bit.
*       10-04-90  GJF   New-style function declarator. Also, rewrote expr.
*                       to avoid using cast as lvalue.
*       01-21-91  GJF   ANSI naming.
*       08-10-92  PBS   Posix support (TZ stuff).
*       03-24-93  GJF   Ported C8-16 version and adapted for exotic Daylight
*                       Savings Time conversions which are legal under POSIX.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-15-93  GJF   Replaced _tzset() call with __tzset() call.
*       09-20-93  GJF   Merged NT SDK and Cuda version (amount to picking up
*                       fixes to Posix build).
*       11-04-93  GJF   Picked up a fix for the Posix build.
*       02-13-95  GJF   Call _tzset for Mac builds (temp change?). Also,
*                       picked up bug fix from Mac version (setting of
*                       tm_yday field in underflow case).
*       08-31-95  GJF   Use _dstbias as the Daylight Saving Time bias and
*                       all for the beginning or end of the Epoch to be in a
*                       DST.
*       02-07-98  GJF   Changes for Win64: replaced long type with time_t, 
*                       added some int casts where required, also use __int64
*                       max value for bounds checking.
*       09-25-98  GJF   Set tm_isdst, when appropriate, at beginning/end of the
*                       Epoch
*       05-17-99  PML   Remove all Macintosh support.
*       11-03-99  RDL   Win64 POSIX warning fix.
*
*******************************************************************************/

#include <cruntime.h>
#include <limits.h>
#include <time.h>
#include <stddef.h>
#include <ctime.h>
#include <internal.h>

/***
*struct tm *localtime(ptime) - convert time_t value to tm structure
*
*Purpose:
*       Convert a value in internal (time_t) format to a tm struct
*       containing the corresponding local time.
*
* NOTES:
*       (1) gmtime must be called before _isindst to ensure that the tb time
*           structure is initialized.
*       (2) gmtime and localtime use a single statically allocated buffer.
*           Each call to one of these routines destroys the contents of the
*           previous call.
*       (3) It is assumed that time_t is a 32-bit long integer representing
*           the number of seconds since 00:00:00, 01-01-70 (UTC) (i.e., the
*           Posix/Unix Epoch. Only non-negative values are supported.
*       (4) It is assumed that the maximum adjustment for local time is
*           less than three days (include Daylight Savings Time adjustment).
*           This only a concern in Posix where the specification of the TZ
*           environment restricts the combined offset for time zone and
*           Daylight Savings Time to 2 * (24:59:59), just under 50 hours.
*
*Entry:
*       time_t *ptime - pointer to a long time value
*
*Exit:
*       If *ptime is non-negative, returns a pointer to the tm structure.
*       Otherwise, returns NULL.
*
*Exceptions:
*       See items (3) and (4) in the NOTES above. If these assumptions are
*       violated, behavior is undefined.
*
*******************************************************************************/

struct tm * __cdecl localtime (
        const time_t *ptime
        )
{
        REG1 struct tm *ptm;
        time_t ltime;

        /*
         * Check for illegal time_t value
         */
        if ( *ptime < 0 )
                return( NULL );

#ifdef  _POSIX_
        tzset();
#else
        __tzset();
#endif

#ifdef  _WIN64
        if ( (*ptime > 3 * _DAY_SEC) && (*ptime < _I64_MAX - 3 * _DAY_SEC) ) {
#else
        if ( (*ptime > 3 * _DAY_SEC) && (*ptime < LONG_MAX - 3 * _DAY_SEC) ) {
#endif
                /*
                 * The date does not fall within the first three, or last
                 * three, representable days of the Epoch. Therefore, there
                 * is no possibility of overflowing or underflowing the
                 * time_t representation as we compensate for timezone and
                 * Daylight Savings Time.
                 */

                ltime = *ptime - _timezone;
                ptm = gmtime( &ltime );

                /*
                 * Check and adjust for Daylight Saving Time.
                 */
                if ( _daylight && _isindst( ptm ) ) {
#ifdef  _POSIX_
                        ltime -= _dstoffset - _timezone;
#else
                        ltime -= _dstbias;
#endif
                        ptm = gmtime( &ltime );
                        ptm->tm_isdst = 1;
                }
        }
        else {
                ptm = gmtime( ptime );

                /*
                 * The date falls with the first three, or last three days
                 * of the Epoch. It is possible the time_t representation
                 * would overflow or underflow while compensating for
                 * timezone and Daylight Savings Time. Therefore, make the
                 * timezone and Daylight Savings Time adjustments directly
                 * in the tm structure. The beginning of the Epoch is
                 * 00:00:00, 01-01-70 (UTC) and the last representable second
                 * in the Epoch is 03:14:07, 01-19-2038 (UTC). This will be
                 * used in the calculations below.
                 *
                 * First, adjust for the timezone.
                 */
#ifdef  _POSIX_
                ltime = (time_t)ptm->tm_sec - _timezone;
#else
                if ( _daylight && _isindst(ptm) ) {
                        ltime = (time_t)ptm->tm_sec - (_timezone + _dstbias);
                        ptm->tm_isdst = 1;
                }
                else
                        ltime = (time_t)ptm->tm_sec - _timezone;
#endif
                ptm->tm_sec = (int)(ltime % 60);
                if ( ptm->tm_sec < 0 ) {
                        ptm->tm_sec += 60;
                        ltime -= 60;
                }

                ltime = (time_t)ptm->tm_min + ltime/60;
                ptm->tm_min = (int)(ltime % 60);
                if ( ptm->tm_min < 0 ) {
                        ptm->tm_min += 60;
                        ltime -= 60;
                }

                ltime = (time_t)ptm->tm_hour + ltime/60;
                ptm->tm_hour = (int)(ltime % 24);
                if ( ptm->tm_hour < 0 ) {
                        ptm->tm_hour += 24;
                        ltime -=24;
                }

                ltime /= 24;

                if ( ltime > 0 ) {
                        /*
                         * There is no possibility of overflowing the tm_mday
                         * and tm_yday fields since the date can be no later
                         * than January 19.
                         */
                        ptm->tm_wday = (ptm->tm_wday + (int)ltime) % 7;
                        ptm->tm_mday += (int)ltime;
                        ptm->tm_yday += (int)ltime;
                }
                else if ( ltime < 0 ) {
                        /*
                         * It is possible to underflow the tm_mday and tm_yday
                         * fields. If this happens, then adjusted date must
                         * lie in December 1969.
                         */
                        ptm->tm_wday = (ptm->tm_wday + 7 + (int)ltime) % 7;
                        if ( (ptm->tm_mday += (int)ltime) <= 0 ) {
                                ptm->tm_mday += 31;
                                ptm->tm_yday = 364;
                                ptm->tm_mon = 11;
                                ptm->tm_year--;
                        }
                        else {
                                ptm->tm_yday += (int)ltime;
                        }
                }

#ifdef  _POSIX_
                /*
                 * In Posix, it is possible either the first or last three
                 * days of the Epoch might lie with Daylight Savings Time in
                 * certain time zones.
                 */
                if ( _isindst(ptm) ) {

                        ltime = (long)ptm->tm_sec + _dstoffset;
                        ptm->tm_sec = (int)(ltime % 60);
                        if ( ptm->tm_sec < 0 ) {
                                ptm->tm_sec += 60;
                                ltime -= 60;
                        }

                        ltime = (long)ptm->tm_min + ltime/60;
                        ptm->tm_min = (int)(ltime % 60);
                        if ( ptm->tm_min < 0 ) {
                                ptm->tm_min += 60;
                                ltime -= 60;
                        }

                        ltime = (long)ptm->tm_hour + ltime/60;
                        ptm->tm_hour = (int)(ltime % 24);
                        if ( ptm->tm_hour < 0 ) {
                                ptm->tm_hour += 24;
                                ltime -=24;
                        }

                        ltime /= 24;

                        if ( ltime > 0L ) {
                                /*
                                 * There is no possibility of overflowing the
                                 * tm_mday and tm_yday fields since the date
                                 * can be no later than January 19.
                                 */
                                ptm->tm_wday = (int)((ptm->tm_wday + ltime) % 7);
                                ptm->tm_mday += (int)ltime;
                                ptm->tm_yday += (int)ltime;
                        }
                        else if ( ltime < 0L ) {
                                /*
                                 * It is possible to underflow the tm_mday
                                 * and tm_yday fields. If this happens, then
                                 * adjusted date must lie in December 1969.
                                 */
                                ptm->tm_wday = (int)((ptm->tm_wday + 7 + ltime) % 7);
                                if ( (ptm->tm_mday += (int)ltime) <= 0 ) {
                                        ptm->tm_mday += 31;
                                        ptm->tm_yday = 364;
                                        ptm->tm_mon = 11;
                                        ptm->tm_year--;
                                }
                                else {
                                        ptm->tm_yday += (int)ltime;
                                }
                        }
                }

#endif

        }


        return(ptm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\strtime.c ===
/***
*strtime.c - contains the function "_strtime()"
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains the function _strtime()
*
*Revision History:
*       06-07-89  PHG   Module created, based on asm version
*       03-20-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and fixed the copyright. Also, cleaned
*                       up the formatting a bit.
*       07-25-90  SBM   Removed '32' from API names
*       10-04-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       05-19-92  DJM   ifndef for POSIX build.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-01-93  CFW   Enable Unicode variant, rip out Cruiser.
*       02-10-95  GJF   Merged in Mac version.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <time.h>
#include <tchar.h>
#include <oscalls.h>


/***
*_TSCHAR *_strtime(buffer) - return time in string form
*
*Purpose:
*       _strtime() returns a string containing the time in "HH:MM:SS" form
*
*Entry:
*       _TSCHAR *buffer = the address of a 9-byte user buffer
*
*Exit:
*       returns buffer, which contains the time in "HH:MM:SS" form
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _tstrtime (
        _TSCHAR *buffer
        )
{
        int hours, minutes, seconds;
        SYSTEMTIME dt;                       /* Win32 time structure */
        GetLocalTime(&dt);

        hours = dt.wHour;
        minutes = dt.wMinute;
        seconds = dt.wSecond;

        /* store the components of the time into the string */
        /* store separators */
        buffer[2] = buffer[5] = _T(':');
        /* store end of string */
        buffer[8] = _T('\0');
        /* store tens of hour */
        buffer[0] = (_TSCHAR) (hours   / 10 + _T('0'));
        /* store units of hour */
        buffer[1] = (_TSCHAR) (hours   % 10 + _T('0'));
        /* store tens of minute */
        buffer[3] = (_TSCHAR) (minutes / 10 + _T('0'));
        /* store units of minute */
        buffer[4] = (_TSCHAR) (minutes % 10 + _T('0'));
        /* store tens of second */
        buffer[6] = (_TSCHAR) (seconds / 10 + _T('0'));
        /* store units of second */
        buffer[7] = (_TSCHAR) (seconds % 10 + _T('0'));

        return buffer;
}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\strftime.c ===
/***
*strftime.c - String Format Time
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       03-09-89  JCR   Initial version.
*       03-15-89  JCR   Changed day/month strings from all caps to leading cap
*       06-20-89  JCR   Removed _LOAD_DGROUP code
*       03-20-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h>, removed #include <register.h> and
*                       removed some leftover 16-bit support. Also, fixed
*                       the copyright.
*       03-23-90  GJF   Made static functions _CALLTYPE4.
*       07-23-90  SBM   Compiles cleanly with -W3 (removed unreferenced
*                       variable)
*       08-13-90  SBM   Compiles cleanly with -W3 with new build of compiler
*       10-04-90  GJF   New-style function declarators.
*       01-22-91  GJF   ANSI naming.
*       08-15-91  MRM   Calls tzset() to set timezone info in case of %z.
*       08-16-91  MRM   Put appropriate header file for tzset().
*       10-10-91  ETC   Locale support under _INTL switch.
*       12-18-91  ETC   Use localized time strings structure.
*       02-10-93  CFW   Ported to Cuda tree, change _CALLTYPE4 to _CRTAPI3.
*       02-16-93  CFW   Massive changes: bug fixes & enhancements.
*       03-08-93  CFW   Changed _expand to _expandtime.
*       03-09-93  CFW   Handle string literals inside format strings.
*       03-09-93  CFW   Alternate form cleanup.
*       03-17-93  CFW   Change *count > 0, to *count != 0, *count is unsigned.
*       03-22-93  CFW   Change "C" locale time format specifier to 24-hour.
*       03-30-93  GJF   Call _tzset instead of __tzset (which no longer
*                       exists).
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-14-93  CFW   Disable _alternate_form for 'X' specifier, fix count bug.
*       04-28-93  CFW   Fix bug in '%c' handling.
*       07-15-93  GJF   Call __tzset() in place of _tzset().
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       04-11-94  GJF   Made definitions of __lc_time_c, _alternate_form and
*                       _no_lead_zeros conditional on ndef DLL_FOR_WIN32S.
*       09-06-94  CFW   Remove _INTL switch.
*       02-13-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       02-22-96  JWM   Merge in PlumHall mods.
*       06-17-96  SKS   Enable new Plum-Hall code for _MAC as well as _WIN32
*       07-10-97  GJF   Made __lc_time_c selectany. Also, removed unnecessary
*                       init to 0 for globals, cleaned up the formatting a bit,
*                       added a few __cdecls and detailed old (and no longer
*                       used as of 6/17/96 change) Mac version.
*       08-21-97  GJF   Added support for AM/PM type suffix to time string.
*       09-10-98  GJF   Added support for per-thread locale info.
*       03-04-99  GJF   Added refcount field to __lc_time_c.
*       05-17-99  PML   Remove all Macintosh support.
*       08-30-99  PML   Don't overflow buffer on leadbyte in _store_winword.
*       03-17-00  PML   Corrected _Gettnames to also copy ww_timefmt (VS7#9374)
*       09-07-00  PML   Remove dependency on libcp.lib/xlocinfo.h (vs7#159463)
*       03-25-01  PML   Use GetDateFormat/GetTimeFormat in _store_winword for
*                       calendar types other than the basic type 1, localized
*                       Gregorian (vs7#196892)  Also fix formatting for leading
*                       zero suppression in fields, which was busted for %c,
*                       %x, %X.
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <mtdll.h>
#include <time.h>
#include <locale.h>
#include <setlocal.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <dbgint.h>
#include <malloc.h>

/* Prototypes for local routines */
static void __cdecl _expandtime(
#ifdef  _MT
        pthreadlocinfo ptloci,
#endif
        char specifier,
        const struct tm *tmptr,
        char **out,
        size_t *count,
        struct __lc_time_data *lc_time,
        unsigned alternate_form);

static void __cdecl _store_str (char *in, char **out, size_t *count);

static void __cdecl _store_num (int num, int digits, char **out, size_t *count,
        unsigned no_lead_zeros);

static void __cdecl _store_number (int num, char **out, size_t *count);

static void __cdecl _store_winword (
#ifdef  _MT
        pthreadlocinfo ptloci,
#endif
        int field_code,
        const struct tm *tmptr,
        char **out,
        size_t *count,
        struct __lc_time_data *lc_time);

size_t __cdecl _Strftime (
        char *string,
        size_t maxsize,
        const char *format,
        const struct tm *timeptr,
        void *lc_time_arg
        );

#ifdef  _MT
size_t __cdecl _Strftime_mt (pthreadlocinfo ptloci, char *string, size_t maxsize,
        const char *format, const struct tm *timeptr, void *lc_time_arg);
#endif

/* LC_TIME data for local "C" */

__declspec(selectany) struct __lc_time_data __lc_time_c = {

        {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"},

        {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
                "Friday", "Saturday", },

        {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug",
                "Sep", "Oct", "Nov", "Dec"},

        {"January", "February", "March", "April", "May", "June",
                "July", "August", "September", "October",
                "November", "December"},

        {"AM", "PM"},

        { "MM/dd/yy" },
        { "dddd, MMMM dd, yyyy" },
        { "HH:mm:ss" },

        0x0409,
        1,

#ifdef  _MT
        0
#endif
        };

/* Pointer to the current LC_TIME data structure. */

struct __lc_time_data *__lc_time_curr = &__lc_time_c;

/* Codes for __lc_time_data ww_* fields for _store_winword */

#define WW_SDATEFMT     0
#define WW_LDATEFMT     1
#define WW_TIMEFMT      2

#define TIME_SEP        ':'

/*      get a copy of the current day names */
char * __cdecl _Getdays (
        void
        )
{
        const struct __lc_time_data *pt = __lc_time_curr;
        size_t n, len = 0;
        char *p;

        for (n = 0; n < 7; ++n)
            len += strlen(pt->wday_abbr[n]) + strlen(pt->wday[n]) + 2;
        p = (char *)_malloc_crt(len + 1);

        if (p != 0) {
            char *s = p;

            for (n = 0; n < 7; ++n) {
                *s++ = TIME_SEP;
                s += strlen(strcpy(s, pt->wday_abbr[n]));
                *s++ = TIME_SEP;
                s += strlen(strcpy(s, pt->wday[n]));
            }
            *s++ = '\0';
        }

        return (p);
}

/*      get a copy of the current month names */
char * __cdecl _Getmonths (
        void
        )
{
        const struct __lc_time_data *pt = __lc_time_curr;
        size_t n, len = 0;
        char *p;

        for (n = 0; n < 12; ++n)
            len += strlen(pt->month_abbr[n]) + strlen(pt->month[n]) + 2;
        p = (char *)_malloc_crt(len + 1);

        if (p != 0) {
            char *s = p;

            for (n = 0; n < 12; ++n) {
                *s++ = TIME_SEP;
                s += strlen(strcpy(s, pt->month_abbr[n]));
                *s++ = TIME_SEP;
                s += strlen(strcpy(s, pt->month[n]));
            }
            *s++ = '\0';
        }

        return (p);
}

/*      get a copy of the current time locale information */
void * __cdecl _Gettnames (
        void
        )
{
        const struct __lc_time_data *pt = __lc_time_curr;
        size_t n, len = 0;
        void *p;

        for (n = 0; n < 7; ++n)
            len += strlen(pt->wday_abbr[n]) + strlen(pt->wday[n]) + 2;
        for (n = 0; n < 12; ++n)
            len += strlen(pt->month_abbr[n]) + strlen(pt->month[n]) + 2;
        len += strlen(pt->ampm[0]) + strlen(pt->ampm[1]) + 2;
        len += strlen(pt->ww_sdatefmt) + 1;
        len += strlen(pt->ww_ldatefmt) + 1;
        len += strlen(pt->ww_timefmt) + 1;
        p = _malloc_crt(sizeof (*pt) + len);

        if (p != 0) {
            struct __lc_time_data *pn = (struct __lc_time_data *)p;
            char *s = (char *)p + sizeof (*pt);

            memcpy(p, __lc_time_curr, sizeof (*pt));
            for (n = 0; n < 7; ++n) {
                pn->wday_abbr[n] = s;
                s += strlen(strcpy(s, pt->wday_abbr[n])) + 1;
                pn->wday[n] = s;
                s += strlen(strcpy(s, pt->wday[n])) + 1;
            }
            for (n = 0; n < 12; ++n) {
                pn->month_abbr[n] = s;
                s += strlen(strcpy(s, pt->month_abbr[n])) + 1;
                pn->month[n] = s;
                s += strlen(strcpy(s, pt->month[n])) + 1;
            }
            pn->ampm[0] = s;
            s += strlen(strcpy(s, pt->ampm[0])) + 1;
            pn->ampm[1] = s;
            s += strlen(strcpy(s, pt->ampm[1])) + 1;
            pn->ww_sdatefmt = s;
            s += strlen(strcpy(s, pt->ww_sdatefmt)) + 1;
            pn->ww_ldatefmt = s;
            s += strlen(strcpy(s, pt->ww_ldatefmt)) + 1;
            pn->ww_timefmt = s;
            strcpy(s, pt->ww_timefmt);
        }

        return (p);
}


/***
*size_t strftime(string, maxsize, format, timeptr) - Format a time string
*
*Purpose:
*       Place characters into the user's output buffer expanding time
*       format directives as described in the user's control string.
*       Use the supplied 'tm' structure for time data when expanding
*       the format directives.
*       [ANSI]
*
*Entry:
*       char *string = pointer to output string
*       size_t maxsize = max length of string
*       const char *format = format control string
*       const struct tm *timeptr = pointer to tb data structure
*
*Exit:
*       !0 = If the total number of resulting characters including the
*       terminating null is not more than 'maxsize', then return the
*       number of chars placed in the 'string' array (not including the
*       null terminator).
*
*       0 = Otherwise, return 0 and the contents of the string are
*       indeterminate.
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl strftime (
        char *string,
        size_t maxsize,
        const char *format,
        const struct tm *timeptr
        )
{
        return (_Strftime(string, maxsize, format, timeptr, 0));
}

/***
*size_t _Strftime(string, maxsize, format,
*       timeptr, lc_time) - Format a time string for a given locale
*
*Purpose:
*       Place characters into the user's output buffer expanding time
*       format directives as described in the user's control string.
*       Use the supplied 'tm' structure for time data when expanding
*       the format directives. use the locale information at lc_time.
*       [ANSI]
*
*Entry:
*       char *string = pointer to output string
*       size_t maxsize = max length of string
*       const char *format = format control string
*       const struct tm *timeptr = pointer to tb data structure
*               struct __lc_time_data *lc_time = pointer to locale-specific info
*                       (passed as void * to avoid type mismatch with C++)
*
*Exit:
*       !0 = If the total number of resulting characters including the
*       terminating null is not more than 'maxsize', then return the
*       number of chars placed in the 'string' array (not including the
*       null terminator).
*
*       0 = Otherwise, return 0 and the contents of the string are
*       indeterminate.
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl _Strftime (
        char *string,
        size_t maxsize,
        const char *format,
        const struct tm *timeptr,
        void *lc_time_arg
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return _Strftime_mt(ptloci, string, maxsize, format, timeptr,
                            lc_time_arg);
}

size_t __cdecl _Strftime_mt (
        pthreadlocinfo ptloci,
        char *string,
        size_t maxsize,
        const char *format,
        const struct tm *timeptr,
        void *lc_time_arg
        )
{
#endif
        unsigned alternate_form;
        struct __lc_time_data *lc_time;
        size_t left;                    /* space left in output string */
#ifdef  _MT
        lc_time = lc_time_arg == 0 ? ptloci->lc_time_curr :
#else
        lc_time = lc_time_arg == 0 ? __lc_time_curr :
#endif
                  (struct __lc_time_data *)lc_time_arg;

        /* Copy maxsize into temp. */
        left = maxsize;

        /* Copy the input string to the output string expanding the format
        designations appropriately.  Stop copying when one of the following
        is true: (1) we hit a null char in the input stream, or (2) there's
        no room left in the output stream. */

        while (left > 0)
        {
            switch(*format)
            {

            case('\0'):

                /* end of format input string */
                goto done;

            case('%'):

                /* Format directive.  Take appropriate action based
                on format control character. */

                format++;                       /* skip over % char */

                /* process flags */
                alternate_form = 0;
                if (*format == '#')
                {
                    alternate_form = 1;
                    format++;
                }
#ifdef  _MT
                _expandtime (ptloci, *format, timeptr, &string,
#else
                _expandtime (*format, timeptr, &string,
#endif
                             &left,lc_time, alternate_form);
                format++;                       /* skip format char */
                break;


            default:

                /* store character, bump pointers, dec the char count */
                if (isleadbyte((int)(*format)) && left > 1)
                {
                    *string++ = *format++;
                    left--;
                }
                *string++ = *format++;
                left--;
                break;
            }
        }


        /* All done.  See if we terminated because we hit a null char or because
        we ran out of space */

        done:

        if (left > 0) {

            /* Store a terminating null char and return the number of chars
            we stored in the output string. */

            *string = '\0';
            return(maxsize-left);
        }

        else
            return(0);

}


/***
*_expandtime() - Expand the conversion specifier
*
*Purpose:
*       Expand the given strftime conversion specifier using the time struct
*       and store it in the supplied buffer.
*
*       The expansion is locale-dependent.
*
*       *** For internal use with strftime() only ***
*
*Entry:
*       char specifier = strftime conversion specifier to expand
*       const struct tm *tmptr = pointer to time/date structure
*       char **string = address of pointer to output string
*       size_t *count = address of char count (space in output area)
*       struct __lc_time_data *lc_time = pointer to locale-specific info
*
*Exit:
*       none
*
*Exceptions:
*
*******************************************************************************/

static void __cdecl _expandtime (
#ifdef  _MT
        pthreadlocinfo ptloci,
#endif
        char specifier,
        const struct tm *timeptr,
        char **string,
        size_t *left,
        struct __lc_time_data *lc_time,
        unsigned alternate_form
        )
{
        unsigned temp;                  /* temps */
        int wdaytemp;

        /* Use a copy of the appropriate __lc_time_data pointer.  This
        should prevent the necessity of locking/unlocking in mthread
        code (if we can guarantee that the various __lc_time data
        structures are always in the same segment). contents of time
        strings structure can now change, so thus we do use locking */

        switch(specifier) {             /* switch on specifier */

        case('a'):              /* abbreviated weekday name */
            _store_str((char *)(lc_time->wday_abbr[timeptr->tm_wday]),
                     string, left);
            break;

        case('A'):              /* full weekday name */
            _store_str((char *)(lc_time->wday[timeptr->tm_wday]),
                     string, left);
            break;

        case('b'):              /* abbreviated month name */
            _store_str((char *)(lc_time->month_abbr[timeptr->tm_mon]),
                     string, left);
            break;

        case('B'):              /* full month name */
            _store_str((char *)(lc_time->month[timeptr->tm_mon]),
                     string, left);
            break;

        case('c'):              /* date and time display */
            if (alternate_form)
            {
                _store_winword(
#ifdef  _MT
                               ptloci,
#endif
                               WW_LDATEFMT, timeptr, string, left, lc_time);
                if (*left == 0)
                    return;
                *(*string)++=' ';
                (*left)--;
                _store_winword(
#ifdef  _MT
                               ptloci,
#endif
                               WW_TIMEFMT, timeptr, string, left, lc_time);
            }
            else {
                _store_winword(
#ifdef  _MT
                               ptloci,
#endif
                               WW_SDATEFMT, timeptr, string, left, lc_time);
                if (*left == 0)
                    return;
                *(*string)++=' ';
                (*left)--;
                _store_winword(
#ifdef  _MT
                               ptloci,
#endif
                               WW_TIMEFMT, timeptr, string, left, lc_time);
            }
            break;

        case('d'):              /* mday in decimal (01-31) */
            /* pass alternate_form as the no leading zeros flag */
            _store_num(timeptr->tm_mday, 2, string, left, 
                       alternate_form);
            break;

        case('H'):              /* 24-hour decimal (00-23) */
            /* pass alternate_form as the no leading zeros flag */
            _store_num(timeptr->tm_hour, 2, string, left,
                       alternate_form);
            break;

        case('I'):              /* 12-hour decimal (01-12) */
            if (!(temp = timeptr->tm_hour%12))
                temp=12;
            /* pass alternate_form as the no leading zeros flag */
            _store_num(temp, 2, string, left, alternate_form);
            break;

        case('j'):              /* yday in decimal (001-366) */
            /* pass alternate_form as the no leading zeros flag */
            _store_num(timeptr->tm_yday+1, 3, string, left,
                       alternate_form);
            break;

        case('m'):              /* month in decimal (01-12) */
            /* pass alternate_form as the no leading zeros flag */
            _store_num(timeptr->tm_mon+1, 2, string, left,
                       alternate_form);
            break;

        case('M'):              /* minute in decimal (00-59) */
            /* pass alternate_form as the no leading zeros flag */
            _store_num(timeptr->tm_min, 2, string, left,
                       alternate_form);
            break;

        case('p'):              /* AM/PM designation */
            if (timeptr->tm_hour <= 11)
                _store_str((char *)(lc_time->ampm[0]), string, left);
            else
                _store_str((char *)(lc_time->ampm[1]), string, left);
            break;

        case('S'):              /* secs in decimal (00-59) */
            /* pass alternate_form as the no leading zeros flag */
            _store_num(timeptr->tm_sec, 2, string, left,
                       alternate_form);
            break;

        case('U'):              /* sunday week number (00-53) */
            wdaytemp = timeptr->tm_wday;
            goto weeknum;   /* join common code */

        case('w'):              /* week day in decimal (0-6) */
            /* pass alternate_form as the no leading zeros flag */
            _store_num(timeptr->tm_wday, 1, string, left,
                       alternate_form);
            break;

        case('W'):              /* monday week number (00-53) */
            if (timeptr->tm_wday == 0)  /* monday based */
                wdaytemp = 6;
            else
                wdaytemp = timeptr->tm_wday-1;
        weeknum:
            if (timeptr->tm_yday < wdaytemp)
                temp = 0;
            else {
                temp = timeptr->tm_yday/7;
                if ((timeptr->tm_yday%7) >= wdaytemp)
                    temp++;
            }
            /* pass alternate_form as the no leading zeros flag */
            _store_num(temp, 2, string, left, alternate_form);
            break;

        case('x'):              /* date display */
            if (alternate_form)
            {
                _store_winword(
#ifdef  _MT
                               ptloci,
#endif
                               WW_LDATEFMT, timeptr, string, left, lc_time);
            }
            else
            {
                _store_winword(
#ifdef  _MT
                               ptloci,
#endif
                               WW_SDATEFMT, timeptr, string, left, lc_time);
            }
            break;

        case('X'):              /* time display */
            _store_winword(
#ifdef  _MT
                           ptloci,
#endif
                           WW_TIMEFMT, timeptr, string, left, lc_time);
            break;

        case('y'):              /* year w/o century (00-99) */
            temp = timeptr->tm_year%100;
            /* pass alternate_form as the no leading zeros flag */
            _store_num(temp, 2, string, left, alternate_form);
            break;

        case('Y'):              /* year w/ century */
            temp = (((timeptr->tm_year/100)+19)*100) +
                   (timeptr->tm_year%100);
            /* pass alternate_form as the no leading zeros flag */
            _store_num(temp, 4, string, left, alternate_form);
            break;

        case('Z'):              /* time zone name, if any */
        case('z'):              /* time zone name, if any */
#ifdef _POSIX_
            tzset();        /* Set time zone info */
            _store_str(tzname[((timeptr->tm_isdst)?1:0)],
                     string, left);
#else
            __tzset();      /* Set time zone info */
            _store_str(_tzname[((timeptr->tm_isdst)?1:0)],
                     string, left);
#endif
            break;

        case('%'):              /* percent sign */
            *(*string)++ = '%';
            (*left)--;
            break;

        default:                /* unknown format directive */
            /* ignore the directive and continue */
            /* [ANSI: Behavior is undefined.]    */
            break;

        }       /* end % switch */
}


/***
*_store_str() - Copy a time string
*
*Purpose:
*       Copy the supplied time string into the output string until
*       (1) we hit a null in the time string, or (2) the given count
*       goes to 0.
*
*       *** For internal use with strftime() only ***
*
*Entry:
*       char *in = pointer to null terminated time string
*       char **out = address of pointer to output string
*       size_t *count = address of char count (space in output area)
*
*Exit:
*       none
*Exceptions:
*
*******************************************************************************/

static void __cdecl _store_str (
        char *in,
        char **out,
        size_t *count
        )
{

        while ((*count != 0) && (*in != '\0')) {
            *(*out)++ = *in++;
            (*count)--;
        }
}


/***
*_store_num() - Convert a number to ascii and copy it
*
*Purpose:
*       Convert the supplied number to decimal and store
*       in the output buffer.  Update both the count and
*       buffer pointers.
*
*       *** For internal use with strftime() only ***
*
*Entry:
*       int num                 = pointer to integer value
*       int digits              = # of ascii digits to put into string
*       char **out              = address of pointer to output string
*       size_t *count           = address of char count (space in output area)
*       unsigned no_lead_zeros  = flag indicating that padding by leading
*                                 zeros is not necessary
*
*Exit:
*       none
*Exceptions:
*
*******************************************************************************/

static void __cdecl _store_num (
        int num,
        int digits,
        char **out,
        size_t *count,
        unsigned no_lead_zeros
        )
{
        int temp = 0;

        if (no_lead_zeros) {
            _store_number (num, out, count);
            return;
        }

        if ((size_t)digits < *count)  {
            for (digits--; (digits+1); digits--) {
                (*out)[digits] = (char)('0' + num % 10);
                num /= 10;
                temp++;
            }
            *out += temp;
            *count -= temp;
        }
        else
            *count = 0;
}

/***
*_store_number() - Convert positive integer to string
*
*Purpose:
*       Convert positive integer to a string and store it in the output
*       buffer with no null terminator.  Update both the count and
*       buffer pointers.
*
*       Differs from _store_num in that the precision is not specified,
*       and no leading zeros are added.
*
*       *** For internal use with strftime() only ***
*
*       Created from xtoi.c
*
*Entry:
*       int num = pointer to integer value
*       char **out = address of pointer to output string
*       size_t *count = address of char count (space in output area)
*
*Exit:
*       none
*
*Exceptions:
*       The buffer is filled until it is out of space.  There is no
*       way to tell beforehand (as in _store_num) if the buffer will
*       run out of space.
*
*******************************************************************************/

static void __cdecl _store_number (
        int num,
        char **out,
        size_t *count
        )
{
        char *p;                /* pointer to traverse string */
        char *firstdig;         /* pointer to first digit */
        char temp;              /* temp char */

        p = *out;

        /* put the digits in the buffer in reverse order */
        if (*count > 1)
        {
            do {
                *p++ = (char) (num % 10 + '0');
                (*count)--;
            } while ((num/=10) > 0 && *count > 1);
        }

        firstdig = *out;                /* firstdig points to first digit */
        *out = p;                       /* return pointer to next space */
        p--;                            /* p points to last digit */

        /* reverse the buffer */
        do {
            temp = *p;
            *p-- = *firstdig;
            *firstdig++ = temp;     /* swap *p and *firstdig */
        } while (firstdig < p);         /* repeat until halfway */
}


/***
*_store_winword() - Store date/time in WinWord format
*
*Purpose:
*       Format the date/time in the supplied WinWord format
*       and store it in the supplied buffer.
*
*       *** For internal use with strftime() only ***
*
*       For simple localized Gregorian calendars (calendar type 1), the WinWord
*       format is converted token by token to strftime conversion specifiers.
*       _expandtime is then called to do the work.  The WinWord format is
*       expected to be a character string (not wide-chars).
*
*       For other calendar types, the Win32 APIs GetDateFormat/GetTimeFormat
*       are instead used to do all formatting, so that this routine doesn't
*       have to know about era/period strings, year offsets, etc.
*
*
*Entry:
*       int field_code = code for ww_* field with format 
*       const struct tm *tmptr = pointer to time/date structure
*       char **out = address of pointer to output string
*       size_t *count = address of char count (space in output area)
*       struct __lc_time_data *lc_time = pointer to locale-specific info
*
*Exit:
*       none
*
*Exceptions:
*
*******************************************************************************/

static void __cdecl _store_winword (
#ifdef  _MT
        pthreadlocinfo ptloci,
#endif
        int field_code,
        const struct tm *tmptr,
        char **out,
        size_t *count,
        struct __lc_time_data *lc_time
        )
{
        const char *format;
        char specifier;
        const char *p;
        int repeat;
        char *ampmstr;
        unsigned no_lead_zeros;

        switch (field_code)
        {
        case WW_SDATEFMT:
            format = lc_time->ww_sdatefmt;
            break;
        case WW_LDATEFMT:
            format = lc_time->ww_ldatefmt;
            break;
        case WW_TIMEFMT:
        default:
            format = lc_time->ww_timefmt;
            break;
        }

        if (lc_time->ww_caltype != 1)
        {
            /* We have something other than the basic Gregorian calendar */

            SYSTEMTIME SystemTime;
            int cch;
            int (WINAPI * FormatFunc)(LCID, DWORD, const SYSTEMTIME *,
                                      LPCSTR, LPSTR, int);

            if (field_code != WW_TIMEFMT)
                FormatFunc = GetDateFormat;
            else
                FormatFunc = GetTimeFormat;

            SystemTime.wYear   = (WORD)(tmptr->tm_year + 1900);
            SystemTime.wMonth  = (WORD)(tmptr->tm_mon + 1);
            SystemTime.wDay    = (WORD)(tmptr->tm_mday);
            SystemTime.wHour   = (WORD)(tmptr->tm_hour);
            SystemTime.wMinute = (WORD)(tmptr->tm_min);
            SystemTime.wSecond = (WORD)(tmptr->tm_sec);
            SystemTime.wMilliseconds = 0;

            /* Find buffer size required */
            cch = FormatFunc(lc_time->ww_lcid, 0, &SystemTime,
                             format, NULL, 0);

            if (cch != 0)
            {
                int malloc_flag = 0;
                char *buffer;

                /* Allocate buffer, first try stack, then heap */
                __try
                {
                    buffer = (char *)_alloca(cch);
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                    _resetstkoflw();
                    buffer = NULL;
                }

                if (buffer == NULL)
                {
                    buffer = (char *)_malloc_crt(cch);
                    if (buffer != NULL)
                        malloc_flag = 1;
                }

                if (buffer != NULL)
                {
                    /* Do actual date/time formatting */
                    cch = FormatFunc(lc_time->ww_lcid, 0, &SystemTime,
                                     format, buffer, cch);

                    /* Copy to output buffer */
                    p = buffer;
                    while (--cch > 0 && *count > 0) {
                        *(*out)++ = *p++;
                        (*count)--;
                    }

                    if (malloc_flag)
                        _free_crt(buffer);
                    return;
                }
            }

            /* In case of error, just fall through to localized Gregorian */
        }

        while (*format && *count != 0)
        {
            specifier = 0;          /* indicate no match */
            no_lead_zeros = 0;      /* default is print leading zeros */

            /* count the number of repetitions of this character */
            for (repeat=0, p=format; *p++ == *format; repeat++);
            /* leave p pointing to the beginning of the next token */
            p--;

            /* switch on ascii format character and determine specifier */
            switch (*format)
            {
            case 'M':
                switch (repeat)
                {
                case 1: no_lead_zeros = 1;  /* fall thru */
                case 2: specifier = 'm'; break;
                case 3: specifier = 'b'; break;
                case 4: specifier = 'B'; break;
                } break;
            case 'd':
                switch (repeat)
                {
                case 1: no_lead_zeros = 1;  /* fall thru */
                case 2: specifier = 'd'; break;
                case 3: specifier = 'a'; break;
                case 4: specifier = 'A'; break;
                } break;
            case 'y':
                switch (repeat)
                {
                case 2: specifier = 'y'; break;
                case 4: specifier = 'Y'; break;
                } break;
            case 'h':
                switch (repeat)
                {
                case 1: no_lead_zeros = 1;  /* fall thru */
                case 2: specifier = 'I'; break;
                } break;
            case 'H':
                switch (repeat)
                {
                case 1: no_lead_zeros = 1;  /* fall thru */
                case 2: specifier = 'H'; break;
                } break;
            case 'm':
                switch (repeat)
                {
                case 1: no_lead_zeros = 1;  /* fall thru */
                case 2: specifier = 'M'; break;
                } break;
            case 's': /* for compatibility; not strictly WinWord */
                switch (repeat)
                {
                case 1: no_lead_zeros = 1;  /* fall thru */
                case 2: specifier = 'S'; break;
                } break;
            case 'A':
            case 'a':
                if (!__ascii_stricmp(format, "am/pm"))
                    p = format + 5;
                else if (!__ascii_stricmp(format, "a/p"))
                    p = format + 3;
                specifier = 'p';
                break;
            case 't': /* t or tt time marker suffix */
                if ( tmptr->tm_hour <= 11 )
                    ampmstr = lc_time->ampm[0];
                else
                    ampmstr = lc_time->ampm[1];

                if ( (repeat == 1) && (*count > 0) ) {
                    if (
#ifdef  _MT
                    __isleadbyte_mt(ptloci, (int)*ampmstr) &&
#else
                    isleadbyte((int)*ampmstr) &&
#endif
                         (*count > 1) )
                    {
                        *(*out)++ = *ampmstr++;
                        (*count)--;
                    }
                    *(*out)++ = *ampmstr++;
                    (*count)--;
                } else {
                    while (*ampmstr != 0 && *count > 0) {
                        if (isleadbyte((int)*ampmstr) && *count > 1) {
                            *(*out)++ = *ampmstr++;
                            (*count)--;
                        }
                        *(*out)++ = *ampmstr++;
                        (*count)--;
                    }
                }
                format = p;
                continue;

            case '\'': /* literal string */
                if (repeat & 1) /* odd number */
                {
                    format += repeat;
                    while (*format && *count != 0)
                    {
                        if (*format == '\'')
                        {
                            format++;
                            break;
                        }
#ifdef  _MT
                        if ( __isleadbyte_mt(ptloci, (int)*format) &&
#else
                        if ( isleadbyte((int)*format) &&
#endif
                             (*count > 1) )
                        {
                            *(*out)++ = *format++;
                            (*count)--;
                        }
                        *(*out)++ = *format++;
                        (*count)--;
                    }
                }
                else { /* even number */
                    format += repeat;
                }
                continue;

            default: /* non-control char, print it */
                break;
            } /* switch */

            /* expand specifier, or copy literal if specifier not found */
            if (specifier)
            {
                _expandtime(
#ifdef  _MT
                            ptloci,
#endif
                            specifier, tmptr, out, count,
                            lc_time, no_lead_zeros);
                format = p; /* bump format up to the next token */
            } else {
#ifdef  _MT
                if (__isleadbyte_mt(ptloci, (int)*format) &&
#else
                if (isleadbyte((int)*format) &&
#endif
                    (*count > 1))
                {
                    *(*out)++ = *format++;
                    (*count)--;
                }
                *(*out)++ = *format++;
                (*count)--;
            }
        } /* while */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\systime.c ===
/***
*systime.c - _getsystime and _setsystime
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _getsystime() and _setsystime()
*
*Revision History:
*       08-22-91  BWM   Wrote module.
*       05-19-92  DJM   ifndef for POSIX build.
*       09-25-92  SKS   Use SetLocalTime(), not SetSystemTime().
*                       Fix bug: daylight flag must be initialized to -1.
*                       Replace C++ comments with C-style comments
*       11-10-93  GJF   Resurrected from from crt32 (for compatibility with
*                       the NT SDK release) and cleaned up.
*       08-30-99  PML   Fix function header comment in _getsystime(), detab.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <oscalls.h>
#include <time.h>

/***
*unsigned _getsystime(timestruc) - Get current system time
*
*Purpose:
*
*Entry:
*       struct tm * ptm - time structure
*
*Exit:
*       milliseconds of current time
*
*Exceptions:
*
*******************************************************************************/

unsigned __cdecl _getsystime(struct tm * ptm)
{
    SYSTEMTIME  st;

    GetLocalTime(&st);

    ptm->tm_isdst       = -1;   /* mktime() computes whether this is */
                                /* during Standard or Daylight time. */
    ptm->tm_sec         = (int)st.wSecond;
    ptm->tm_min         = (int)st.wMinute;
    ptm->tm_hour        = (int)st.wHour;
    ptm->tm_mday        = (int)st.wDay;
    ptm->tm_mon         = (int)st.wMonth - 1;
    ptm->tm_year        = (int)st.wYear - 1900;
    ptm->tm_wday        = (int)st.wDayOfWeek;

    /* Normalize uninitialized fields */
    mktime(ptm);

    return (st.wMilliseconds);
}

/***
*unsigned _setsystime(timestruc, milliseconds) - Set new system time
*
*Purpose:
*
*Entry:
*       struct tm * ptm - time structure
*       unsigned milliseconds - milliseconds of current time
*
*Exit:
*       0 if succeeds
*       system error if fails
*
*Exceptions:
*
*******************************************************************************/

unsigned __cdecl _setsystime(struct tm * ptm, unsigned uMilliseconds)
{
    SYSTEMTIME  st;

    /* Normalize uninitialized fields */
    mktime(ptm);

    st.wYear            = (WORD)(ptm->tm_year + 1900);
    st.wMonth           = (WORD)(ptm->tm_mon + 1);
    st.wDay             = (WORD)ptm->tm_mday;
    st.wHour            = (WORD)(ptm->tm_hour);
    st.wMinute          = (WORD)ptm->tm_min;
    st.wSecond          = (WORD)ptm->tm_sec;
    st.wMilliseconds    = (WORD)uMilliseconds;

    if (!SetLocalTime(&st)) {
        return ((int)GetLastError());
    }

    return (0);
}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\strdate.c ===
/***
*strdate.c - contains the function "_strdate()"
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains the function _strdate()
*
*Revision History:
*       06-07-89  PHG   Module created, base on asm version
*       03-20-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and fixed the copyright. Also, cleaned
*                       up the formatting a bit.
*       07-25-90  SBM   Removed '32' from API names
*       10-04-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       05-19-92  DJM   ifndef for POSIX build.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-01-93  CFW   Enable Unicode variant, rip out Cruiser.
*       02-10-95  GJF   Merged in Mac version.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <tchar.h>
#include <time.h>
#include <oscalls.h>


/***
*_TSCHAR *_strdate(buffer) - return date in string form
*
*Purpose:
*       _strdate() returns a string containing the date in "MM/DD/YY" form
*
*Entry:
*       _TSCHAR *buffer = the address of a 9-byte user buffer
*
*Exit:
*       returns buffer, which contains the date in "MM/DD/YY" form
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _tstrdate (
        _TSCHAR *buffer
        )
{
        int month, day, year;
        SYSTEMTIME dt;                  /* Win32 time structure */

        GetLocalTime(&dt);
        month = dt.wMonth;
        day = dt.wDay;
        year = dt.wYear % 100;          /* change year into 0-99 value */

        /* store the components of the date into the string */
        /* store seperators */
        buffer[2] = buffer[5] = _T('/');
        /* store end of string */
        buffer[8] = _T('\0');
        /* store tens of month */
        buffer[0] = (_TSCHAR) (month / 10 + _T('0'));
        /* store units of month */
        buffer[1] = (_TSCHAR) (month % 10 + _T('0'));
        /* store tens of day */
        buffer[3] = (_TSCHAR) (day   / 10 + _T('0'));
        /* store units of day */
        buffer[4] = (_TSCHAR) (day   % 10 + _T('0'));
        /* store tens of year */
        buffer[6] = (_TSCHAR) (year  / 10 + _T('0'));
        /* store units of year */
        buffer[7] = (_TSCHAR) (year  % 10 + _T('0'));

        return buffer;
}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\time.c ===
/***
*time.c - get current system time
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines time() - gets the current system time and converts it to
*                        internal (time_t) format time.
*
*Revision History:
*       06-07-89  PHG   Module created, based on asm version
*       03-20-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and fixed the copyright. Also, cleaned
*                       up the formatting a bit.
*       07-25-90  SBM   Removed '32' from API names
*       10-04-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       05-19-92  DJM   ifndef for POSIX build.
*       03-30-93  GJF   Replaced dtoxtime() reference by __gmtotime_t. Also
*                       purged Cruiser support.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-21-93  GJF   Converted from using __gmtotime_t and GetSystemTime,
*                       to using __loctotime_t and GetLocalTime.
*       02-13-95  GJF   Merged in Mac version.
*       09-22-95  GJF   Obtain and use Win32's DST flag.
*       10-24-95  GJF   GetTimeZoneInformation is *EXPENSIVE* on NT. Use a
*                       cache to minimize calls to this API.
*       12-13-95  GJF   Optimization above wasn't working because I had 
*                       switched gmt and gmt_cache (thanks PhilipLu!)
*       10-11-96  GJF   More elaborate test needed to determine if current
*                       time is a DST time.
*       05-20-98  GJF   Get UTC time directly from the system.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <time.h>
#include <internal.h>
#include <windows.h>

/*
 * Number of 100 nanosecond units from 1/1/1601 to 1/1/1970
 */
#define EPOCH_BIAS  116444736000000000i64

/*
 * Union to facilitate converting from FILETIME to unsigned __int64
 */
typedef union {
        unsigned __int64 ft_scalar;
        FILETIME ft_struct;
        } FT;

/***
*time_t time(timeptr) - Get current system time and convert to time_t value.
*
*Purpose:
*       Gets the current date and time and stores it in internal (time_t)
*       format. The time is returned and stored via the pointer passed in
*       timeptr. If timeptr == NULL, the time is only returned, not stored in
*       *timeptr. The internal (time_t) format is the number of seconds since
*       00:00:00, Jan 1 1970 (UTC).
*
*       Note: We cannot use GetSystemTime since its return is ambiguous. In
*       Windows NT, in return UTC. In Win32S, probably also Win32C, it
*       returns local time.
*
*Entry:
*       time_t *timeptr - pointer to long to store time in.
*
*Exit:
*       returns the current time.
*
*Exceptions:
*
*******************************************************************************/

time_t __cdecl time (
        time_t *timeptr
        )
{
        time_t tim;
        FT nt_time;

        GetSystemTimeAsFileTime( &(nt_time.ft_struct) );

        tim = (time_t)((nt_time.ft_scalar - EPOCH_BIAS) / 10000000i64);

        if (timeptr)
                *timeptr = tim;         /* store time if requested */

        return tim;
}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\timeset.c ===
/***
*timeset.c - contains defaults for timezone setting
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the timezone values for default timezone.
*       Also contains month and day name three letter abbreviations.
*
*Revision History:
*       12-03-86  JMB   added Japanese defaults and module header
*       09-22-87  SKS   fixed declarations, include <time.h>
*       02-21-88  SKS   Clean up ifdef-ing, change IBMC20 to IBMC2
*       07-05-89  PHG   Remove _NEAR_ for 386
*       08-15-89  GJF   Fixed copyright, indents. Got rid of _NEAR.
*       03-20-90  GJF   Added #include <cruntime.h> and fixed the copyright.
*       05-18-90  GJF   Added _VARTYPE1 to publics to match declaration in
*                       time.h (picky 6.0 front-end!).
*       01-21-91  GJF   ANSI naming.
*       08-10-92  PBS   Posix support(TZ stuff).
*       04-06-93  SKS   Remove _VARTYPE1
*       06-08-93  KRS   Tie JAPAN switch to _KANJI switch.
*       09-13-93  GJF   Merged NT SDK and Cuda versions.
*       04-08-94  GJF   Made non-POSIX definitions of _timezone, _daylight
*                       and _tzname conditional on ndef DLL_FOR_WIN32S.
*       10-04-94  CFW   Removed #ifdef _KANJI
*       02-13-95  GJF   Fixed def of tzname[] so that string constants would
*                       not get overwritten (dangerous if string-pooling is
*                       turned on in build). Made it big enough to hold
*                       timezone names which work with Posix. Also, made
*                       __mnames[] and __dnames[] const.
*       03-01-95  BWT   Fix POSIX by including limits.h
*       08-30-95  GJF   Added _dstbias for Win32. Also increased limit on
*                       timezone strings to 63.
*       05-13-99  PML   Remove Win32s
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <time.h>
#include <internal.h>

#ifndef _POSIX_

long _timezone = 8 * 3600L; /* Pacific Time Zone */
int _daylight = 1;          /* Daylight Saving Time (DST) in timezone */
long _dstbias = -3600L;     /* DST offset in seconds */

/* note that NT Posix's TZNAME_MAX is only 10 */

static char tzstd[64] = { "PST" };
static char tzdst[64] = { "PDT" };

char *_tzname[2] = { tzstd, tzdst };

#else   /* _POSIX_ */

#include <limits.h>

long _timezone = 8*3600L;   /* Pacific Time */
int _daylight = 1;          /* Daylight Savings Time */
                            /* when appropriate */

static char tzstd[TZNAME_MAX + 1] = { "PST" };
static char tzdst[TZNAME_MAX + 1] = { "PDT" };

char *tzname[2] = { tzstd, tzdst };

char *_rule;
long _dstoffset = 3600L;

#endif  /* _POSIX_ */

/*  Day names must be Three character abbreviations strung together */

const char __dnames[] = {
        "SunMonTueWedThuFriSat"
};

/*  Month names must be Three character abbreviations strung together */

const char __mnames[] = {
        "JanFebMarAprMayJunJulAugSepOctNovDec"
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\tzset.c ===
/***
*tzset.c - set timezone information and see if we're in daylight time
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _tzset() - set timezone and daylight saving time vars
*
*Revision History:
*       03-??-84  RLB   initial version
*       03-26-86  TC    added minus capability to time difference w.r.t GMT
*       03-27-86  TC    fixed daylight davings time calculation, off by a day
*                       error
*       12-03-86  SKS   daylight savings time is different starting april 1987
*                       Fixed off-by-1 errors when either Apr 30 or Oct 31 is
*                       Sat. Simplified leap year check: this works for
*                       1970-2099 only!
*       11-19-87  SKS   Add __tzset() which calls tzset only the first time
*                       Made _isindst() a near procedure
*       11-25-87  WAJ   Added calls to _lock and _unlock
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       01-27-88  SKS   Made _isindst() and _dtoxtime() are no longer near (for
*                       QC)
*       05-24-88  PHG   Merged DLL and normal versions
*       03-20-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h>, removed #include <register.h>, removed
*                       some leftover 16-bit support and fixed the copyright.
*                       Also, cleaned up the formatting a bit.
*       03-23-90  GJF   Made static functions _CALLTYPE4.
*       07-30-90  SBM   Added void to empty function arg lists to create
*                       prototypes
*       10-04-90  GJF   New-style function declarators.
*       01-21-91  GJF   ANSI naming.
*       08-10-92  PBS   Posix Support (TZ stuff).
*       03-30-93  GJF   Ported C8-16 version to Win32.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-07-93  SKS   Replace strdup() with ANSI conformant _strdup()
*       06-28-93  GJF   Limited support for system's notion of time zone
*                       in Windows NT.
*       07-15-93  GJF   Resurrected __tzset().
*       04-22-94  GJF   Made definitions of lastTZ and first_time conditonal
*                       on DLL_FOR_WIN32S.
*       01-10-95  CFW   Debug CRT allocs.
*       02-13-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s.
*       04-07-95  JCF   Change gmtFlags with u. Due to Changes in macos\osutils.h
*       06-28-95  CFW   Mac: when TZ not set, _tzname[0,1]="" not "???";
*       08-30-95  GJF   Complete support for Win32's notion of time zones.
*       11-08-95  GJF   Fixed isindst() to release lock.
*       11-15-95  GJF   Ensure dststart, dstend get recomputed after _tzset.
*       01-18-96  GJF   Ensure _tzname[] strings are null-terminated.
*       03-22-96  GJF   Zero out _dstbias if there is no DST. This works
*                       around a bug in NT's GetTimeZoneInformation API.
*       07-25-96  RDK   Removed PMAC init ptr here to clock.c.
*       10-11-96  GJF   Return value of TIME_ZONE_ID_UNKNOWN from 
*                       GetTimeZoneInformation does NOT mean there is no time
*                       zone info (it may simply mean there is no DST).
*       08-28-97  GJF   Fixed underflow adjustment in cvtdate. Also, deleted
*                       some old Win32S support and detab-ed.
*       01-28-98  GJF   Use WideCharToMultiByte API instead of mbstowcs so
*                       that the host's default ANSI codepage is used when we
*                       are in the C locale.
*       02-09-98  GJF   Changes for Win64: removing unnecessary typing of vars
*                       and constants as long.
*       05-11-98  GJF   Use more general leap determination to support time
*                       values past 2099. 
*       05-11-98  GJF   Merged in crt.ia64 and crt.ia64 versions.
*       08-27-98  GJF   Copy __lc_codepage, a global, to a local var for 
*                       multithread safety.
*       09-25-98  GJF   Minor bug in transition day calculation.
*       04-28-99  GJF   Changed dwFlags arg value to 0 in WideCharToMultiByte
*                       calls to avoid problems with codepage 1258 on NT 5.0.
*       05-17-99  PML   Remove all Macintosh support.
*       06-08-99  GJF   Fixed handling of empty TZ environment variable.
*       09-28-99  PML   Fixed double free of lastTZ (ntbug#390281)
*
*******************************************************************************/

#include <cruntime.h>
#include <ctype.h>
#include <ctime.h>
#include <time.h>
#include <stdlib.h>
#include <internal.h>
#ifdef  _POSIX_
#include <limits.h>
#else
#include <mtdll.h>
#include <windows.h>
#endif
#include <setlocal.h>
#include <string.h>
#include <dbgint.h>

#ifndef _POSIX_

/*
 * Number of milliseconds in one day
 */
#define DAY_MILLISEC    (24 * 60 * 60 * 1000)

/*
 * Pointer to a saved copy of the TZ value obtained in the previous call
 * to tzset() set (if any).
 */
static char * lastTZ = NULL;

/*
 * Flag indicating that time zone information came from GetTimeZoneInformation
 * API call.
 */
static int tzapiused;

static TIME_ZONE_INFORMATION tzinfo;

/*
 * Structure used to represent DST transition date/times.
 */
typedef struct {
        int  yr;        /* year of interest */
        int  yd;        /* day of year */
        int  ms;        /* milli-seconds in the day */
        } transitiondate;

/*
 * DST start and end structs.
 */
static transitiondate dststart = { -1, 0, 0 };
static transitiondate dstend   = { -1, 0, 0 };

static int __cdecl _isindst_lk(struct tm *);

#endif


/***
*void tzset() - sets timezone information and calc if in daylight time
*
*Purpose:
*       Sets the timezone information from the TZ environment variable
*       and then sets _timezone, _daylight, and _tzname. If we're in daylight
*       time is automatically calculated.
*
*Entry:
*       None, reads TZ environment variable.
*
*Exit:
*       sets _daylight, _timezone, and _tzname global vars, no return value
*
*Exceptions:
*
*******************************************************************************/

#ifndef _POSIX_

#ifdef  _MT
static void __cdecl _tzset_lk(void);
#else
#define _tzset_lk _tzset
#endif

void __cdecl __tzset(void)
{
        static int first_time = 0;

        if ( !first_time ) {

            _mlock( _TIME_LOCK );

            if ( !first_time ) {
                _tzset_lk();
                first_time++;
            }

            _munlock(_TIME_LOCK );

        }
}


#ifdef  _MT     /* multi-thread; define both tzset and _tzset_lk */
void __cdecl _tzset (
        void
        )
{
        _mlock( _TIME_LOCK );

        _tzset_lk();

        _munlock( _TIME_LOCK );
}


static void __cdecl _tzset_lk (

#else   /* non multi-thread; only define tzset */

void __cdecl _tzset (

#endif  /* rejoin common code */

        void
        )
{
        char *TZ;
        int defused;
        int negdiff = 0;
        unsigned int lc_cp;

        _mlock(_ENV_LOCK);

        /*
         * Copy codepage to local (only really necessary for multithread case)
         */
        lc_cp = __lc_codepage;

        /*
         * Clear the flag indicated whether GetTimeZoneInformation was used.
         */
        tzapiused = 0;

        /*
         * Set year fields of dststart and dstend structures to -1 to ensure
         * they are recomputed as after this 
         */
        dststart.yr = dstend.yr = -1;

        /*
         * Fetch the value of the TZ environment variable.
         */
        if ( ((TZ = _getenv_lk("TZ")) == NULL) || (*TZ =='\0') ) {

            /*
             * There is no TZ environment variable, try to use the time zone
             * information from the system.
             */

            /*
             * If there is a lastTZ, discard it
             */
            if ( lastTZ != NULL ) {
                _free_crt(lastTZ);
		lastTZ = NULL;
	    }

            _munlock(_ENV_LOCK);

            if ( GetTimeZoneInformation( &tzinfo ) != 0xFFFFFFFF ) {
                /*
                 * Note that the API was used.
                 */
                tzapiused = 1;

                /*
                 * Derive _timezone value from Bias and StandardBias fields.
                 */
                _timezone = tzinfo.Bias * 60;

                if ( tzinfo.StandardDate.wMonth != 0 )
                    _timezone += (tzinfo.StandardBias * 60);

                /*
                 * Check to see if there is a daylight time bias. Since the
                 * StandardBias has been added into _timezone, it must be 
                 * compensated for in the value computed for _dstbias.
                 */
                if ( (tzinfo.DaylightDate.wMonth != 0) &&
                     (tzinfo.DaylightBias != 0) )
                {
                    _daylight = 1;
                    _dstbias = (tzinfo.DaylightBias - tzinfo.StandardBias) *
                               60;
                }
                else {
                        _daylight = 0;

                    /*
                     * Set daylight bias to 0 because GetTimeZoneInformation 
                     * may return TIME_ZONE_ID_DAYLIGHT even though there is
                     * no DST (in NT 3.51, just turn off the automatic DST
                     * adjust in the control panel)!
                     */
                    _dstbias = 0;
                }

                /*
                 * Try to grab the name strings for both the time zone and the
                 * daylight zone. Note the wide character strings in tzinfo
                 * must be converted to multibyte characters strings. The 
                 * locale codepage, __lc_codepage, is used for this. Note that
                 * if setlocale() with LC_ALL or LC_CTYPE has not been called,
                 * then __lc_codepage will be 0 (_CLOCALECP), which is CP_ACP
                 * (which means use the host's default ANSI codepage).
                 */
                if ( (WideCharToMultiByte( lc_cp,
                                           0,
                                           tzinfo.StandardName,
                                           -1,
                                           _tzname[0],
                                           63,
                                           NULL, 
                                           &defused ) != 0) &&
                     (!defused) )
                    _tzname[0][63] = '\0';
                else
                    _tzname[0][0] = '\0';

                if ( (WideCharToMultiByte( lc_cp,
                                           0,
                                           tzinfo.DaylightName,
                                           -1,
                                           _tzname[1],
                                           63,
                                           NULL, 
                                           &defused ) != 0) &&
                     (!defused) )
                    _tzname[1][63] = '\0';
                else
                    _tzname[1][0] = '\0';

            }

            /*
             * Time zone information is unavailable, just return.
             */
            return;
        }


        if ( (lastTZ != NULL) && (strcmp(TZ, lastTZ) == 0) )
        {
            /*
             * TZ is unchanged from a earlier call (to this function). Just
             * return.
             */
            _munlock(_ENV_LOCK);
            return;
        }

        /*
         * Update lastTZ
         */
        if ( lastTZ != NULL )
            _free_crt(lastTZ);

        if ((lastTZ = _malloc_crt(strlen(TZ)+1)) == NULL)
        {
            _munlock(_ENV_LOCK);
            return;
        }
        strcpy(lastTZ, TZ);

        _munlock(_ENV_LOCK);

        /*
         * Process TZ value and update _tzname, _timezone and _daylight.
         */

        strncpy(_tzname[0], TZ, 3);
        _tzname[0][3] = '\0';

        /*
         * time difference is of the form:
         *
         *      [+|-]hh[:mm[:ss]]
         *
         * check minus sign first.
         */
        if ( *(TZ += 3) == '-' ) {
            negdiff++;
            TZ++;
        }

        /*
         * process, then skip over, the hours
         */
        _timezone = atol(TZ) * 3600;

        while ( (*TZ == '+') || ((*TZ >= '0') && (*TZ <= '9')) ) TZ++;

        /*
         * check if minutes were specified
         */
        if ( *TZ == ':' ) {
            /*
             * process, then skip over, the minutes
             */
            _timezone += atol(++TZ) * 60;
            while ( (*TZ >= '0') && (*TZ <= '9') ) TZ++;

            /*
             * check if seconds were specified
             */
            if ( *TZ == ':' ) {
                /*
                 * process, then skip over, the seconds
                 */
                _timezone += atol(++TZ);
                while ( (*TZ >= '0') && (*TZ <= '9') ) TZ++;
            }
        }

        if ( negdiff )
            _timezone = -_timezone;

        /*
         * finally, check for a DST zone suffix
         */
        if ( _daylight = *TZ ) {
            strncpy(_tzname[1], TZ, 3);
            _tzname[1][3] = '\0';
        }
        else
            *_tzname[1] = '\0';

}

/***
*static void cvtdate( trantype, datetype, year, month, week, dayofweek,
*                     date, hour, min, second, millisec ) - convert 
*       transition date format
*
*Purpose:
*       Convert the format of a transition date specification to a value of
*       a transitiondate structure.
*
*Entry:
*       int trantype    - 1, if it is the start of DST
*                         0, if is the end of DST (in which case the date is
*                            is a DST date)
*       int datetype    - 1, if a day-in-month format is specified.
*                         0, if an absolute date is specified.
*       int year        - year for which the date is being converted (70 ==
*                         1970)
*       int month       - month (0 == January)
*       int week        - week of month, if datetype == 1 (note that 5== last
*                         week of month), 
*                         0, otherwise.
*       int dayofweek   - day of week (0 == Sunday), if datetype == 1.
*                         0, otherwise.
*       int date        - date of month (1 - 31)
*       int hour        - hours (0 - 23)
*       int min         - minutes (0 - 59)
*       int sec         - seconds (0 - 59)
*       int msec        - milliseconds (0 - 999)
*
*Exit:
*       dststart or dstend is filled in with the converted date.
*
*******************************************************************************/

static void __cdecl cvtdate (
        int trantype,
        int datetype,
        int year,
        int month,
        int week,
        int dayofweek,
        int date,
        int hour,
        int min,
        int sec,
        int msec
        )
{
        int yearday;
        int monthdow;

        if ( datetype == 1 ) {

            /*
             * Transition day specified in day-in-month format.
             */

            /*
             * Figure the year-day of the start of the month.
             */
            yearday = 1 + (_IS_LEAP_YEAR(year) ? _lpdays[month - 1] :
                      _days[month - 1]);

            /* 
             * Figure the day of the week of the start of the month.
             */
            monthdow = (yearday + ((year - 70) * 365) +
                        _ELAPSED_LEAP_YEARS(year) + _BASE_DOW) % 7;

            /*
             * Figure the year-day of the transition date
             */
            if ( monthdow <= dayofweek )
                yearday += (dayofweek - monthdow) + (week - 1) * 7;
            else
                yearday += (dayofweek - monthdow) + week * 7;

            /*
             * May have to adjust the calculation above if week == 5 (meaning
             * the last instance of the day in the month). Check if year falls
             * beyond after month and adjust accordingly.
             */
            if ( (week == 5) && 
                 (yearday > (_IS_LEAP_YEAR(year) ? _lpdays[month] :
                             _days[month])) )
            {
                yearday -= 7;
            }
        }
        else {
            /* 
             * Transition day specified as an absolute day
             */
            yearday = _IS_LEAP_YEAR(year) ? _lpdays[month - 1] :
                      _days[month - 1];

            yearday += date;
        }

        if ( trantype == 1 ) {
            /*
             * Converted date was for the start of DST
             */
            dststart.yd = yearday;
            dststart.ms = msec + (1000 * (sec + 60 * (min + 60 * hour)));
            /*
             * Set year field of dststart so that unnecessary calls to
             * cvtdate() may be avoided.
             */
            dststart.yr = year;
        }
        else {
            /*
             * Converted date was for the end of DST
             */
            dstend.yd = yearday;
            dstend.ms = msec + (1000 * (sec + 60 * (min + 60 * hour)));
            /*
             * The converted date is still a DST date. Must convert to a 
             * standard (local) date while being careful the millisecond field
             * does not overflow or underflow.
             */
            if ( (dstend.ms += (_dstbias * 1000)) < 0 ) {
                dstend.ms += DAY_MILLISEC;
                dstend.yd--;
            }
            else if ( dstend.ms >= DAY_MILLISEC ) {
                dstend.ms -= DAY_MILLISEC;
                dstend.yd++;
            }

            /*
             * Set year field of dstend so that unnecessary calls to cvtdate()
             * may be avoided.
             */
            dstend.yr = year;
        }

        return;
}

/***
*int _isindst(tb) - determine if broken-down time falls in DST
*
*Purpose:
*       Determine if the given broken-down time falls within daylight saving
*       time (DST). The DST rules are either obtained from Win32 (tzapiused !=
*       TRUE) or assumed to be USA rules, post 1986.
*
*       If the DST rules are obtained from Win32's GetTimeZoneInformation API,
*       the transition dates to/from DST can be specified in either of two
*       formats. First, a day-in-month format, similar to the way USA rules 
*       are specified, can be used. The transition date is given as the n-th 
*       occurence of a specified day of the week in a specified month. Second,
*       an absolute date can be specified. The two cases are distinguished by
*       the value of wYear field in the SYSTEMTIME structure (0 denotes a
*       day-in-month format).
*
*       USA rules for DST are that a time is in DST iff it is on or after 
*       02:00 on the first Sunday in April, and before 01:00 on the last 
*       Sunday in October.
*
*Entry:
*       struct tm *tb - structure holding broken-down time value
*
*Exit:
*       1, if time represented is in DST
*       0, otherwise
*
*******************************************************************************/

int __cdecl _isindst (
        struct tm *tb
        )
#ifdef  _MT
{
        int retval;

        _mlock( _TIME_LOCK );
        retval = _isindst_lk( tb );
        _munlock( _TIME_LOCK );

        return retval;
}

static int __cdecl _isindst_lk (
        struct tm *tb
        )
#endif  /* _MT */
{
        long ms;

        if ( _daylight == 0 )
            return 0;

        /*
         * Compute (recompute) the transition dates for daylight saving time
         * if necessary.The yr (year) fields of dststart and dstend is 
         * compared to the year of interest to determine necessity.
         */
        if ( (tb->tm_year != dststart.yr) || (tb->tm_year != dstend.yr) ) {
            if ( tzapiused ) {
                /*
                 * Convert the start of daylight saving time to dststart.
                 */
                if ( tzinfo.DaylightDate.wYear == 0 ) 
                    cvtdate( 1, 
                             1,             /* day-in-month format */
                             tb->tm_year, 
                             tzinfo.DaylightDate.wMonth,
                             tzinfo.DaylightDate.wDay,
                             tzinfo.DaylightDate.wDayOfWeek,
                             0,
                             tzinfo.DaylightDate.wHour,
                             tzinfo.DaylightDate.wMinute,
                             tzinfo.DaylightDate.wSecond,
                             tzinfo.DaylightDate.wMilliseconds );
                else
                    cvtdate( 1,
                             0,             /* absolute date */
                             tb->tm_year,
                             tzinfo.DaylightDate.wMonth,
                             0,
                             0,
                             tzinfo.DaylightDate.wDay,
                             tzinfo.DaylightDate.wHour,
                             tzinfo.DaylightDate.wMinute,
                             tzinfo.DaylightDate.wSecond,
                             tzinfo.DaylightDate.wMilliseconds );
                /*
                 * Convert start of standard time to dstend.
                 */
                if ( tzinfo.StandardDate.wYear == 0 ) 
                    cvtdate( 0, 
                             1,             /* day-in-month format */
                             tb->tm_year, 
                             tzinfo.StandardDate.wMonth,
                             tzinfo.StandardDate.wDay,
                             tzinfo.StandardDate.wDayOfWeek,
                             0,
                             tzinfo.StandardDate.wHour,
                             tzinfo.StandardDate.wMinute,
                             tzinfo.StandardDate.wSecond,
                             tzinfo.StandardDate.wMilliseconds );
                else
                    cvtdate( 0, 
                             0,             /* absolute date */
                             tb->tm_year, 
                             tzinfo.StandardDate.wMonth,
                             0,
                             0,
                             tzinfo.StandardDate.wDay,
                             tzinfo.StandardDate.wHour,
                             tzinfo.StandardDate.wMinute,
                             tzinfo.StandardDate.wSecond,
                             tzinfo.StandardDate.wMilliseconds );

            }
            else {
                /*
                 * GetTimeZoneInformation API was NOT used, or failed. USA 
                 * daylight saving time rules are assumed.
                 */
                cvtdate( 1, 
                         1,
                         tb->tm_year, 
                         4,                 /* April */
                         1,                 /* first... */
                         0,                 /* ...Sunday */
                         0,
                         2,                 /* 02:00 (2 AM) */
                         0,
                         0,
                         0 );

                cvtdate( 0, 
                         1,
                         tb->tm_year, 
                         10,                /* October */
                         5,                 /* last... */
                         0,                 /* ...Sunday */
                         0,
                         2,                 /* 02:00 (2 AM) */
                         0,
                         0,
                         0 );
            }
        }

        /* 
         * Handle simple cases first.
         */
        if ( dststart.yd < dstend.yd ) {
            /*
             * Northern hemisphere ordering
             */
            if ( (tb->tm_yday < dststart.yd) || (tb->tm_yday > dstend.yd) )
                return 0;           
            if ( (tb->tm_yday > dststart.yd) && (tb->tm_yday < dstend.yd) )
                return 1;
        }
        else { 
            /*
             * Southern hemisphere ordering
             */
            if ( (tb->tm_yday < dstend.yd) || (tb->tm_yday > dststart.yd) )
                return 1;
            if ( (tb->tm_yday > dstend.yd) && (tb->tm_yday < dststart.yd) )
                return 0;
        }

        ms = 1000 * (tb->tm_sec + 60 * tb->tm_min + 3600 * tb->tm_hour);

        if ( tb->tm_yday == dststart.yd ) {
            if ( ms >= dststart.ms )
                return 1;
            else
                return 0;
        }
        else {
            /* 
             * tb->tm_yday == dstend.yd
             */
            if ( ms < dstend.ms )
                return 1;
            else
                return 0;
        }

}

#else   /* _POSIX_ */

/*
 *  The following is an implementation of the TZ grammar specified in the
 *  document:
 *
 *       8.1.1 Extension to Time Functions
 *       IEEE Std 1003.1 - 1990
 *       Page 152 - 153
 *
 *  The TZ grammar looks like:
 *
 *          stdoffset[dst[offset][,start[/time],end[/time]]]
 *
 *  Variables used in code:
 *
 *      tzname[0] ==> std
 *      _timezone  ==> offset(the one after 'std')
 *      tzname[1] ==> dst
 *      _dstoffset ==> offset(the one after 'dst')
 *      _startdate ==> start
 *      _starttime ==> time(the one after 'start')
 *      _enddate   ==> end
 *      _endtime   ==> time(the one after 'end')
 *
 */

/*
 *  Refer to the document for the detailed description of fields of _DSTDATE.
 *  Two of Jn, n, and Mm are -1, indicating the one(not -1) is a vaild value.
 */

typedef struct _DSTDATE {
        int Jn; /* -1 or [1, 365](year day and leap day shall not be counted) */
        int n;  /* -1 or [0, 365](year day and leap day shall be counted) */
        int Mm; /* -1 or [1, 12](month) */
        int Mn; /* [1, 5] if Mm != -1 (week) */
        int Md; /* [0, 6] if Mm != -1 (weekday, Sunday == 0) */
} DSTDATE, *PDSTDATE;

#define SEC_PER_HOUR    (60 * 60)
#define SEC_PER_DAY     (SEC_PER_HOUR * 24)


/*
 *  The default TZ in tzset() should look like:
 *
 *       TZ = "PST8PDT,M4.1.0/2:00,M10.5.0/2:00";
 */

/* Day light saving start/end date and default vaules */
static DSTDATE _startdate = { -1, -1, 4, 1, 0};
static DSTDATE _enddate = {-1, -1, 10, 5, 0};


/* Seconds since midnight on _startdate/_enddate with default values.
 * _endtime is 1am instead of 2am because the DST end time is 2am
 * local time, which by default is 1am standard time.
 */
long  _starttime = 7200L, _endtime = 7200L;

/*
 * If we are only interested in years between 1901 and 2099, we could use this:
 *
 *      #define IS_LEAP_YEAR(y)  (y % 4 == 0)
 */

#define IS_LEAP_YEAR(y)  ((y % 4 == 0 && y % 100 != 0) || y % 400 == 0)


/*
 *  ParsePosixStdOrDst - parse the std or dst element in TZ.
 *
 *  ENTRY   pch - beginning of the substring in TZ.
 *
 *  RETURN  pointer to one position after the std or dst element parsed,
 *          or NULL if failed.
 */


static  char * __cdecl
ParsePosixStdOrDst(
        REG1 char *pch
        )
{
#define UNWANTED(x) (isdigit(x) || x=='\0' || x==',' || x=='-' || x=='+')
        int i;

        /*
         *  Check against the rule.
         */

        if(*pch == ':' || UNWANTED(*pch)) {
                return NULL;
        }

        /*
         *  Get a valid std or dst(i.e. 3 <= lenth_of(std | dst) <= TZNAME_MAX).
         */

        for(i=1, ++pch; (i < TZNAME_MAX) && !UNWANTED(*pch); i++, pch++) {
                ;
        }

        /*
         *  pch now point to 1 position after the valid std or dst.
         */

        return (i >= 3) ? pch : NULL;
}


/*
 *  ParsePosixOffset - parse the offset element in TZ. The format of time is:
 *
 *                   [- | +]hh[:mm[:ss]]
 *
 *  ENTRY   pch - beginning of the substring in TZ.
 *
 *          ptime - pointer to a variable(_timezone or _dstoffset) storing the
 *                  time(in seconds) parsed.
 *
 *  RETURN  pointer to one position after the end of the offset element parsed.
 */


static  char * __cdecl
ParsePosixOffset(
        REG1 char *pch,
        REG2 long *poffset
        )
{
        int  fNegative;
        long offset;

        if((fNegative = (*pch == '-')) || *pch == '+') {
                pch++;
        }

        offset = atol(pch)*3600L; /* hh */

        while(*pch && isdigit(*pch)) {
                pch++;
        }

        if(*pch == ':') {
                offset += atol(++pch)*60L; /* mm */
                while(*pch && isdigit(*pch)) {
                        pch++;
                }

                if(*pch == ':') {
                        offset += atol(++pch); /* ss */
                        while(*pch && isdigit(*pch)) {
                                pch++;
                        }
                }
        }

        *poffset = fNegative ? -offset : offset;

        return pch;
}



/*
 *  ParsePosixDate - parse the date element in TZ. The format of date is one
 *                   of following:
 *
 *                   Jn, n, and Mm.n.d
 *
 *  ENTRY   pch - beginning of the substring in TZ.
 *
 *          pDstDate - pointer to _startdate or _enddate storing the result.
 *
 *  RETURN  pointer to one position after the end of the date element parsed,
 *          or NULL if failed.
 */

static  char * __cdecl
ParsePosixDate(
        REG1 char *pch,
        REG2 PDSTDATE pDstDate
        )
{
        pDstDate->Jn = -1;
        pDstDate->n = -1;
        pDstDate->Mn = -1;

        /*
         *  Two out of the three -1's will remain.
         */

        if(*pch == 'J') {                        /* Jn */
                pDstDate->Jn = atoi(++pch);
        } else if(*pch != 'M') {                 /* n */
                pDstDate->n = atoi(pch);
        } else {                                 /* Mm.n.d */

                pDstDate->Mm = atoi(++pch);

                if(*++pch != '.') {
                        pch++;
                }
                pDstDate->Mn = atoi(++pch);

                if(*++pch != '.') {
                        pch++;
                }
                pDstDate->Md = atoi(++pch);
        }

        while(*pch && isdigit(*pch)) {
                pch++;
        }

#define IN_RANGE(x, a, b)    (x >= a && x <= b)

        return ((pDstDate->Jn != -1 && IN_RANGE(pDstDate->Jn, 1, 365)) ||
                (pDstDate->n != -1 && IN_RANGE(pDstDate->n, 0, 365)) ||
                (pDstDate->Mm != -1 && IN_RANGE(pDstDate->Mm, 1, 12) &&
                IN_RANGE(pDstDate->Mn, 1, 5) && IN_RANGE(pDstDate->Md, 0, 6)))
                ? pch : NULL;
}

/*
 *  ParsePosixTime - parse the time element in TZ. The format of time is:
 *
 *                   hh[:mm[:ss]]
 *
 *  ENTRY   pch - beginning of the substring in TZ.
 *
 *          ptime - pointer to a variable(_starttime or _endtime) storing the
 *                  time(in seconds) parsed.
 *
 *  RETURN  pointer to one position after the end of the time element parsed.
 */

static  char * __cdecl
ParsePosixTime(
        REG1 char *pch,
        REG2 long *ptime
        )
{
        long time;

        time = atol(pch)*SEC_PER_HOUR; /* hh */

        while(*pch && isdigit(*pch)) {
                pch++;
        }

        if(*pch == ':') {

                time += atol(++pch)*60L; /* mm */
                while(*pch && isdigit(*pch)) {
                        pch++;
                }

                if(*pch == ':') {

                        time += atol(++pch); /* ss */
                        while(*pch && isdigit(*pch)) {
                                pch++;
                        }
                }
        }

        *ptime = time;

        return pch;
}

/*
 *  tzset -  sets the timezone information from the TZ environment variable.
 *           Global tzname[], _timezone, _daylight, and _dstoffset will be
 *           set. Static _startdate, _enddate, _starttime, and _endtime will
 *           also be set. TZ string looks like:
 *
 *                stdoffset[dst[offset][,start[/time],end[/time]]]
 *
 *  In form of variables: tzname[0]_timezone[tzname[1][_dstoffset]
 *                        [,_startdate[/_starttime],_enddate[/_endtime]]]
 *
 *  ENTRY   none.
 *
 *  RETURN  none.
 */

void __cdecl tzset(
        void
        )
{
        /* pch points to the beginning of an element to be parsed. */
        REG1 char *pch;

        /* pchCurr points to one position after the end of last element parsed. */
        REG2 char *pchCurr;

        char *TZ;

        _endtime = 7200L;
        _starttime = 7200L;

        if (!(TZ = getenv("TZ")) || !*TZ) {
                TZ = "PST8PDT7,M4.1.0/2:00,M10.5.0/2:00"; /* use default */
        }

        if((pchCurr = ParsePosixStdOrDst(pch=TZ)) == NULL) {
                return;
        }

        memcpy(tzname[0], pch, (int)(pchCurr-pch));
        tzname[0][(int)(pchCurr-pch)] = '\0';

        if((pchCurr = ParsePosixOffset(pch=pchCurr, &_timezone)) == NULL) {
                return;
        }

        _daylight = (*pchCurr != '\0');

        if(!_daylight) {
                return;
        }

        if((pchCurr = ParsePosixStdOrDst(pch=pchCurr)) == NULL) {
                return;
        }

        memcpy(tzname[1], pch, (int)(pchCurr-pch));
        tzname[1][(int)(pchCurr-pch)] = '\0';

        if(isdigit(*pchCurr) || *pchCurr == '-' || *pchCurr == '+') {
                if((pchCurr = ParsePosixOffset(pch=pchCurr, &_dstoffset)) == NULL) {
                        return;
                }
        } else {
                /* default: 1 hour ahead of standard time */
                _dstoffset = _timezone - SEC_PER_HOUR;
        }

        if(*pchCurr == ',') { /* ,start[/time],end[/time] */

                if((pchCurr = ParsePosixDate(pchCurr+1, &_startdate)) == NULL) {
                        goto out;
                }

                if(*pchCurr == '/') {
                        if(!(pchCurr = ParsePosixTime(pchCurr+1, &_starttime))) {
                                goto out;
                        }
                }

                if(*pchCurr != ',') {
                        goto out;
                }

                if ((pchCurr = ParsePosixDate(pchCurr+1, &_enddate)) == NULL) {
                        goto out;
                }

                if (*pchCurr == '/') {
                        if(!(pchCurr = ParsePosixTime(pchCurr+1, &_endtime))) {
                                goto out;
                        }
                }
        }
out:
        /*
         * Adjust the _endtime to account for the fact that
         * dst ends at _endtime local time, rather than
         * standard time.
         */

        _endtime -= (_timezone - _dstoffset);
}


#define DAY1    (4)             /* Jan 1 1970 was a Thursday */

/*
 *  GetDstStartOrEndYearDay - Converts day info from DSTDATE into 0-based
 *                            year-day.
 *
 *  ENTRY   tm_year - the year concerned(tb->tm_year).
 *
 *          pDstDate - pointer to either _startdate or _enddate.
 *
 *  RETURN  the year-day calculated.
 */

static int __cdecl
GetDstStartOrEndYearDay(
        REG1 int tm_year,
        REG2 PDSTDATE pDstDate
        )
{
        REG1 int yday; /* year-day */
        REG2 int theyear;

        theyear = tm_year + 1900;

        if(pDstDate->Jn != -1) {

                /*
                 *  Jn is in [1, 365] and leap day is not counted.
                 *  Convert Jn to 0-based yday; Note: 60 is March 1.
                 */


                yday = (IS_LEAP_YEAR(theyear) && (pDstDate->Jn >= 60))
                        ? pDstDate->Jn : pDstDate->Jn - 1;

        } else if(pDstDate->n != -1) {

                /*
                 *  n is in [0, 365] and leap day is counted.
                 */

                yday = pDstDate->n;

        } else { /* Mm.n.d */

                int *ptrday;
                int years;
                int wday;

                /*
                 *  We first need to calculate year-day(yday) and week-day
                 *  (wday) of 1st day of month pDstDate->Mm. We then figure
                 *  out year-day(yday) of Md day of week Mn of month Mm.
                 */

                ptrday = IS_LEAP_YEAR(theyear) ? _lpdays : _days;

                yday = ptrday[pDstDate->Mm-1] + 1; /* ptrday[i] are all by -1 off */

                years = tm_year - 70;

                /*
                 *  Here constant Day1 is the week-day of Jan 1, 1970.
                 *  (years+1)/4 is for correcting the leap years.
                 */

                wday = (yday + 365*years + (years+1)/4 + DAY1) % 7;

                /*
                 *  Calculate yday of Md day of week 1 of month Mm.
                 */

                yday += pDstDate->Md - wday;
                if(pDstDate->Md < wday) {
                        yday += 7;
                }

                /*
                 *  Calculate yday of Md day of week Mn of month Mm.
                 */

                yday += (pDstDate->Mn-1)*7;

                /*
                 *  Adjust if yday goes beyond the end of the month.
                 */

                if(pDstDate->Md == 5 && yday >= ptrday[pDstDate->Mm] + 1) {
                        yday -= 7;
                }

        }

        return yday;
}

/*
 *  _isindst - Tells whether Xenix-type time value falls under DST.
 *
 *  ENTRY   tb - 'time' structure holding broken-down time value.
 *
 *  RETURN  1 if time represented is in DST, else 0.
 */

int __cdecl _isindst (
        REG1 struct tm *tb
        )
{
        int st_yday, end_yday;
        int st_sec, end_sec;

        int check_time;

        /*
         * We need start/end year-days of DST in syday/eyday which are converted
         * from one of the format Jn, n, and Mm.n.d. We already have start/end
         * time (in seconds) of DST in _starttime/_endtime.
         */

        st_yday = GetDstStartOrEndYearDay(tb->tm_year, &_startdate);
        end_yday = GetDstStartOrEndYearDay(tb->tm_year, &_enddate);

        st_sec = st_yday * SEC_PER_DAY + _starttime;
        end_sec = end_yday * SEC_PER_DAY + _endtime;

        check_time = tb->tm_yday * SEC_PER_DAY + tb->tm_hour * SEC_PER_HOUR
                + tb->tm_min * 60 + tb->tm_sec;

        if (check_time >= st_sec && check_time < end_sec)
                return 1;

        return 0;
}

/*
 *  _isskiptime - Tells whether the given time is skipped at the
 *      dst change.  For instance, we set our clocks forward one
 *      hour at 2am to 3am...  This function returns true for
 *      the times between 1:59:59 and 3:00:00.
 *
 *  ENTRY   tb - 'time' structure holding broken-down time value.
 *
 *  RETURN  1 if time represented is in the skipped period, 0
 *      otherwise.
 */

int __cdecl _isskiptime (
        REG1 struct tm *tb
        )
{
        int st_yday;
        int st_sec;
        int check_time;

        st_yday = GetDstStartOrEndYearDay(tb->tm_year, &_startdate);
        st_sec = st_yday * SEC_PER_DAY + _starttime;

        check_time = tb->tm_yday * SEC_PER_DAY + tb->tm_hour * SEC_PER_HOUR
                + tb->tm_min * 60 + tb->tm_sec;

        if (check_time >= st_sec && check_time < st_sec - _dstoffset) {
                return 1;
        }
        return 0;
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\time64.c ===
/***
*time64.c - get current system time
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _time64() - gets the current system time and converts it to
*       internal (__time64_t) format time.
*
*Revision History:
*       05-20-98  GJF   Created.
*
*******************************************************************************/

#include <cruntime.h>
#include <time.h>
#include <internal.h>
#include <windows.h>

/*
 * Number of 100 nanosecond units from 1/1/1601 to 1/1/1970
 */
#define EPOCH_BIAS  116444736000000000i64

/*
 * Union to facilitate converting from FILETIME to unsigned __int64
 */
typedef union {
        unsigned __int64 ft_scalar;
        FILETIME ft_struct;
        } FT;


/***
*__time64_t _time64(timeptr) - Get current system time and convert to a
*       __time64_t value.
*
*Purpose:
*       Gets the current date and time and stores it in internal 64-bit format
*       (__time64_t). The time is returned and stored via the pointer passed in
*       timeptr. If timeptr == NULL, the time is only returned, not stored in
*       *timeptr. The internal (__time64_t) format is the number of seconds 
*       since 00:00:00, Jan 1 1970 (UTC).
*
*Entry:
*       __time64_t *timeptr - pointer to long to store time in.
*
*Exit:
*       returns the current time.
*
*Exceptions:
*
*******************************************************************************/

__time64_t __cdecl _time64 (
        __time64_t *timeptr
        )
{
        __time64_t tim;
        FT nt_time;

        GetSystemTimeAsFileTime( &(nt_time.ft_struct) );

        tim = (__time64_t)((nt_time.ft_scalar - EPOCH_BIAS) / 10000000i64);


        if (timeptr)
                *timeptr = tim;         /* store time if requested */

        return tim;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\wasctime.c ===
/***
*wasctime.c - convert date/time structure to ASCII string (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Contains _wasctime() - convert a date/time structure to wide ASCII string.
*
*Revision History:
*	11-01-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-09-95  GJF	Removed obsolete WPRFLAG
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "asctime.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\utime64.c ===
/***
*utime64.c - set modification time for a file
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets the access/modification times for a file.
*
*Revision History:
*       05-28-98  GJF   Created.
*
*******************************************************************************/

#ifndef _POSIX_
#include <cruntime.h>
#include <sys/types.h>
#include <sys/utime.h>
#include <msdos.h>
#include <time.h>
#include <fcntl.h>
#include <io.h>
#include <dos.h>
#include <oscalls.h>
#include <errno.h>
#include <stddef.h>
#include <internal.h>

#include <stdio.h>
#include <tchar.h>

/***
*int _utime64(pathname, time) - set modification time for file
*
*Purpose:
*       Sets the modification time for the file specified by pathname.
*       Only the modification time from the _utimbuf structure is used
*       under MS-DOS.
*
*Entry:
*       struct __utimbuf64 *time - new modification date
*
*Exit:
*       returns 0 if successful
*       returns -1 and sets errno if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tutime64 (
        const _TSCHAR *fname,
        struct __utimbuf64 *times
        )
{
        int fh;
        int retval;

        /* open file, fname, since filedate system call needs a handle.  Note
         * _utime definition says you must have write permission for the file
         * to change its time, so open file for write only.  Also, must force
         * it to open in binary mode so we dont remove ^Z's from binary files.
         */


        if ((fh = _topen(fname, _O_RDWR | _O_BINARY)) < 0)
                return(-1);

        retval = _futime64(fh, times);

        _close(fh);
        return(retval);
}

#ifndef _UNICODE

/***
*int __futime64(fh, time) - set modification time for open file
*
*Purpose:
*       Sets the modification time for the open file specified by fh.
*       Only the modification time from the _utimbuf64 structure is used
*       under MS-DOS.
*
*Entry:
*       struct __utimbuf64 *time - new modification date
*
*Exit:
*       returns 0 if successful
*       returns -1 and sets errno if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _futime64 (
        int fh,
        struct __utimbuf64 *times
        )
{
        struct tm *tmb;

        SYSTEMTIME SystemTime;
        FILETIME LocalFileTime;
        FILETIME LastWriteTime;
        FILETIME LastAccessTime;
        struct __utimbuf64 deftimes;

        if (times == NULL) {
                _time64(&deftimes.modtime);
                deftimes.actime = deftimes.modtime;
                times = &deftimes;
        }

        if ((tmb = _localtime64(&times->modtime)) == NULL) {
                errno = EINVAL;
                return(-1);
        }

        SystemTime.wYear   = (WORD)(tmb->tm_year + 1900);
        SystemTime.wMonth  = (WORD)(tmb->tm_mon + 1);
        SystemTime.wDay    = (WORD)(tmb->tm_mday);
        SystemTime.wHour   = (WORD)(tmb->tm_hour);
        SystemTime.wMinute = (WORD)(tmb->tm_min);
        SystemTime.wSecond = (WORD)(tmb->tm_sec);
        SystemTime.wMilliseconds = 0;

        if ( !SystemTimeToFileTime( &SystemTime, &LocalFileTime ) ||
             !LocalFileTimeToFileTime( &LocalFileTime, &LastWriteTime ) )
        {
                errno = EINVAL;
                return(-1);
        }

        if ((tmb = _localtime64(&times->actime)) == NULL) {
                errno = EINVAL;
                return(-1);
        }

        SystemTime.wYear   = (WORD)(tmb->tm_year + 1900);
        SystemTime.wMonth  = (WORD)(tmb->tm_mon + 1);
        SystemTime.wDay    = (WORD)(tmb->tm_mday);
        SystemTime.wHour   = (WORD)(tmb->tm_hour);
        SystemTime.wMinute = (WORD)(tmb->tm_min);
        SystemTime.wSecond = (WORD)(tmb->tm_sec);
        SystemTime.wMilliseconds = 0;

        if ( !SystemTimeToFileTime( &SystemTime, &LocalFileTime ) ||
             !LocalFileTimeToFileTime( &LocalFileTime, &LastAccessTime ) )
        {
                errno = EINVAL;
                return(-1);
        }

        /* set the date via the filedate system call and return. failing
         * this call implies the new file times are not supported by the
         * underlying file system.
         */

        if (!SetFileTime((HANDLE)_get_osfhandle(fh),
                                NULL,
                                &LastAccessTime,
                                &LastWriteTime
                               ))
        {
                errno = EINVAL;
                return(-1);
        }

        return(0);
}

#endif  /* _UNICODE */
#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\utime.c ===
/***
*utime.c - set modification time for a file
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets the access/modification times for a file.
*
*Revision History:
*       03-??-84  RLB   initial version
*       05-17-86  SKS   ported to OS/2
*       08-21-87  JCR   error return if localtime() returns NULL.
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       10-03-88  JCR   386: Change DOS calls to SYS calls
*       10-04-88  JCR   386: Removed 'far' keyword
*       10-10-88  GJF   Made API names match DOSCALLS.H
*       10-11-88  GJF   Made API arg types match DOSCALLS.H
*       04-12-89  JCR   New syscall interface
*       05-01-89  JCR   Corrected OS/2 time/date interpretation
*       05-25-89  JCR   386 OS/2 calls use '_syscall' calling convention
*       08-16-89  PHG   moved date validation above open() so file isn't left
*                       open if the date is invalid
*       03-20-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h>, removed #include <register.h>, removed
*                       some leftover 16-bit support and fixed the copyright.
*                       Also, cleaned up the formatting a bit.
*       07-25-90  SBM   Compiles cleanly with -W3 (added include, removed
*                       unreferenced variable), removed '32' from API names
*       10-04-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-18-91  GJF   ANSI naming.
*       02-14-91  SRW   Fix Mips compile error (_WIN32_)
*       02-26-91  SRW   Fix SetFileTime parameter ordering (_WIN32_)
*       08-21-91  BWM   Add _futime to set time on open file
*       08-26-91  BWM   Change _utime to call _futime
*       05-19-92  DJM   ifndef for POSIX build.
*       08-18-92  SKS   SystemTimeToFileTime now takes UTC/GMT, not local time.
*                       Remove _CRUISER_ conditional
*       04-02-93  GJF   Changed interpretation of error on SetFileTime call.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-09-93  GJF   Have Win32 convert from a local file time value to a
*                       (system) file time value. This is symmetric with
*                       _stat() and a better work-around for the Windows NT
*                       bug in converting file times on FAT (applies DST
*                       offset based on current time rather than the file's
*                       time stamp).
*       11-01-93  CFW   Enable Unicode variant, rip out Cruiser.
*       02-09-95  GJF   Replaced WPRFLAG with _UNICODE.
*       02-13-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s.
*       05-17-99  PML   Remove all Macintosh support.
*       10-27-99  GB    Remove #inlcude <dostypes.h>
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <sys/types.h>
#include <sys/utime.h>
#include <msdos.h>
#include <time.h>
#include <fcntl.h>
#include <io.h>
#include <dos.h>
#include <oscalls.h>
#include <errno.h>
#include <stddef.h>
#include <internal.h>

#include <stdio.h>
#include <tchar.h>

/***
*int _utime(pathname, time) - set modification time for file
*
*Purpose:
*       Sets the modification time for the file specified by pathname.
*       Only the modification time from the _utimbuf structure is used
*       under MS-DOS.
*
*Entry:
*       struct _utimbuf *time - new modification date
*
*Exit:
*       returns 0 if successful
*       returns -1 and sets errno if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tutime (
        const _TSCHAR *fname,
        struct _utimbuf *times
        )
{
        int fh;
        int retval;

        /* open file, fname, since filedate system call needs a handle.  Note
         * _utime definition says you must have write permission for the file
         * to change its time, so open file for write only.  Also, must force
         * it to open in binary mode so we dont remove ^Z's from binary files.
         */


        if ((fh = _topen(fname, _O_RDWR | _O_BINARY)) < 0)
                return(-1);

        retval = _futime(fh, times);

        _close(fh);
        return(retval);
}

#ifndef _UNICODE

/***
*int _futime(fh, time) - set modification time for open file
*
*Purpose:
*       Sets the modification time for the open file specified by fh.
*       Only the modification time from the _utimbuf structure is used
*       under MS-DOS.
*
*Entry:
*       struct _utimbuf *time - new modification date
*
*Exit:
*       returns 0 if successful
*       returns -1 and sets errno if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _futime (
        int fh,
        struct _utimbuf *times
        )
{
        REG1 struct tm *tmb;

        SYSTEMTIME SystemTime;
        FILETIME LocalFileTime;
        FILETIME LastWriteTime;
        FILETIME LastAccessTime;
        struct _utimbuf deftimes;

        if (times == NULL) {
                time(&deftimes.modtime);
                deftimes.actime = deftimes.modtime;
                times = &deftimes;
        }

        if ((tmb = localtime(&times->modtime)) == NULL) {
                errno = EINVAL;
                return(-1);
        }

        SystemTime.wYear   = (WORD)(tmb->tm_year + 1900);
        SystemTime.wMonth  = (WORD)(tmb->tm_mon + 1);
        SystemTime.wDay    = (WORD)(tmb->tm_mday);
        SystemTime.wHour   = (WORD)(tmb->tm_hour);
        SystemTime.wMinute = (WORD)(tmb->tm_min);
        SystemTime.wSecond = (WORD)(tmb->tm_sec);
        SystemTime.wMilliseconds = 0;

        if ( !SystemTimeToFileTime( &SystemTime, &LocalFileTime ) ||
             !LocalFileTimeToFileTime( &LocalFileTime, &LastWriteTime ) )
        {
                errno = EINVAL;
                return(-1);
        }

        if ((tmb = localtime(&times->actime)) == NULL) {
                errno = EINVAL;
                return(-1);
        }

        SystemTime.wYear   = (WORD)(tmb->tm_year + 1900);
        SystemTime.wMonth  = (WORD)(tmb->tm_mon + 1);
        SystemTime.wDay    = (WORD)(tmb->tm_mday);
        SystemTime.wHour   = (WORD)(tmb->tm_hour);
        SystemTime.wMinute = (WORD)(tmb->tm_min);
        SystemTime.wSecond = (WORD)(tmb->tm_sec);
        SystemTime.wMilliseconds = 0;

        if ( !SystemTimeToFileTime( &SystemTime, &LocalFileTime ) ||
             !LocalFileTimeToFileTime( &LocalFileTime, &LastAccessTime ) )
        {
                errno = EINVAL;
                return(-1);
        }

        /* set the date via the filedate system call and return. failing
         * this call implies the new file times are not supported by the
         * underlying file system.
         */

        if (!SetFileTime((HANDLE)_get_osfhandle(fh),
                                NULL,
                                &LastAccessTime,
                                &LastWriteTime
                               ))
        {
                errno = EINVAL;
                return(-1);
        }

        return(0);
}

#endif  /* _UNICODE */

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\wctime.c ===
/***
*wctime.c - convert time argument into ASCII string (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	contains _wctime() - convert time value to wide ASCII string
*
*Revision History:
*	11-01-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-09-95  GJF	Removed obsolete WPRFLAG
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "ctime.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\wcsftime.c ===
/***
*wcsftime.c - String Format Time
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       03-08-93  CFW   Module Created.
*       03-10-93  CFW   Fixed up properly.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       12-16-94  CFW   Format must be wchar_t!
*       01-10-95  CFW   Debug CRT allocs.
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct. Also, use _alloca rather than malloc/free, 
*                       when possible.
*       01-06-99  GJF   Changes for 64-bit size_t.
*       12-10-99  GB    Added support for recovery from stack overflow around 
*                       _alloca().
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <internal.h>
#include <mtdll.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <time.h>
#include <dbgint.h>
#include <malloc.h>
#include <excpt.h>

#ifdef  _MT
size_t __cdecl _Strftime_mt (pthreadlocinfo ptloci, char *string, size_t maxsize,
        const char *format, const struct tm *timeptr, void *lc_time_arg);
#else
size_t __cdecl _Strftime (char *string, size_t maxsize, const char *format, 
        const struct tm *timeptr, void *lc_time_arg);
#endif


/***
*size_t wcsftime(wstring, maxsize, format, timeptr) - Format a time string
*
*Purpose:
*       The wcsftime functions is equivalent to to the strftime function, except
*       that the argument 'wstring' specifies an array of a wide string into
*       which the generated output is to be placed. The wcsftime acts as if
*       strftime were called and the result string converted by mbstowcs().
*       [ISO]
*
*Entry:
*       wchar_t *wstring = pointer to output string
*       size_t maxsize = max length of string
*       const wchar_t *format = format control string
*       const struct tm *timeptr = pointer to tb data structure
*
*Exit:
*       !0 = If the total number of resulting characters including the
*       terminating null is not more than 'maxsize', then return the
*       number of wide chars placed in the 'wstring' array (not including the
*       null terminator).
*
*       0 = Otherwise, return 0 and the contents of the string are
*       indeterminate.
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl wcsftime (
        wchar_t *wstring,
        size_t maxsize,
        const wchar_t *wformat,
        const struct tm *timeptr
        )
{
        size_t retval = 0;
        char *format = NULL;
        char *string = NULL;
        size_t flen = wcslen(wformat) + 1;
        int malloc_flag1 = 0;
        int malloc_flag2 = 0;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();
#endif

        __try {
            string = (char *)_alloca(sizeof(char) * maxsize * 2);
        }
        __except( EXCEPTION_EXECUTE_HANDLER ) {
            _resetstkoflw();
            string = NULL;
        }

        if ( string == NULL ) {
            if ((string = (char *)_malloc_crt(sizeof(char) * maxsize * 2)) == NULL)
                return 0;
            else
                malloc_flag1++;
        }

        __try {
            format = (char *)_alloca(sizeof(char) * flen * 2);
        }
        __except( EXCEPTION_EXECUTE_HANDLER ) {
            _resetstkoflw();
            format = NULL;
        }

        if ( format == NULL ) {
            if ((format = (char *)_malloc_crt(sizeof(char) * flen * 2)) == NULL)
                goto done;
            else
                malloc_flag2++;
        }

#ifdef  _MT
        if (__wcstombs_mt(ptloci, format, wformat, flen * 2) == -1)
#else
        if (wcstombs(format, wformat, flen * 2) == -1)
#endif
            goto done;

#ifdef  _MT
        if (_Strftime_mt(ptloci, string, maxsize * 2, format, timeptr, 0))
#else
        if (_Strftime(string, maxsize * 2, format, timeptr, 0))
#endif
        {
#ifdef  _MT
            if ((retval = __mbstowcs_mt(ptloci, wstring, string, maxsize)) 
                == -1)
#else
            if ((retval = mbstowcs(wstring, string, maxsize)) == -1)
#endif
                retval = 0;
        }

done:
        if ( malloc_flag1 )
            _free_crt(string);

        if ( malloc_flag2 )
            _free_crt(format);

        return retval;
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\wstrdate.c ===
/***
*wstrdate.c - contains the function "_wstrdate()" (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	contains the function _wstrdate()
*
*Revision History:
*	11-01-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-09-95  GJF	Removed obsolete WPRFLAG
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "strdate.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\wctime64.c ===
/***
*wctime64.c - convert time argument into a string (wchar_t version)
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains _wctime64() - convert time value to wide char string
*
*Revision History:
*       05-21-98  GJF   Created.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE    /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "ctime64.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\wstrtime.c ===
/***
*wstrtime.c - contains the function "_wstrtime()"
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	contains the function _wstrtime()
*
*Revision History:
*	11-01-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-09-95  GJF	Removed obsolete WPRFLAG
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "strtime.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\wutime64.c ===
/***
*wutime64.c - set modification time for a file (wchar_t version)
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets the access/modification times for a file.
*
*Revision History:
*       05-28-98  GJF   Created.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE    /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "utime64.c"


#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\wutime.c ===
/***
*wutime.c - set modification time for a file (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Sets the access/modification times for a file.
*
*Revision History:
*	11-01-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-09-95  GJF	Removed obsolete WPRFLAG
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "utime.c"


#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\doc\pjp\makefile.inc ===
PREOBJDIR = $(CPUDIR)\$(BLD_MODEL)_lib

# Here is the target for building LIBCP{,D} / LIBCPMT{,D} / MSVCPRT{,D}.LIB

STDCPP_SRC = stdcpp

_stdcpp_ : \
!if "$(BLD_DLL)"=="1"
        $(OBJDIR)\delop2_s.obj  \
        $(OBJDIR)\newop_s.obj   \
        $(OBJDIR)\newop2_s.obj  \
        $(OBJDIR)\delaop2_s.obj \
        $(OBJDIR)\newaop_s.obj  \
        $(OBJDIR)\newaop2_s.obj \
!endif
        $(OBJDIR)\$(STDCPP_SRC).lib

STDCPP_OBJECTS = \
        $(OBJDIR)\cerr.obj      \
        $(OBJDIR)\cin.obj       \
        $(OBJDIR)\clog.obj      \
        $(OBJDIR)\cout.obj      \
        $(OBJDIR)\delaop2.obj   \
        $(OBJDIR)\delop2.obj    \
        $(OBJDIR)\fiopen.obj    \
!if "$(BLD_DLL)"=="1"
        $(OBJDIR)\instances.obj \
!endif
        $(OBJDIR)\iomanip.obj   \
        $(OBJDIR)\ios.obj       \
        $(OBJDIR)\iosptrs.obj   \
        $(OBJDIR)\iostream.obj  \
        $(OBJDIR)\locale.obj    \
        $(OBJDIR)\locale0.obj   \
        $(OBJDIR)\newaop.obj    \
        $(OBJDIR)\newaop2.obj   \
        $(OBJDIR)\newop.obj     \
        $(OBJDIR)\newop2.obj    \
        $(OBJDIR)\nomemory.obj  \
        $(OBJDIR)\raisehan.obj  \
        $(OBJDIR)\stdhndlr.obj  \
        $(OBJDIR)\stdthrow.obj  \
        $(OBJDIR)\string.obj    \
        $(OBJDIR)\strstrea.obj  \
        $(OBJDIR)\uncaught.obj  \
        $(OBJDIR)\wcerr.obj     \
        $(OBJDIR)\wcin.obj      \
        $(OBJDIR)\wclog.obj     \
        $(OBJDIR)\wcout.obj     \
        $(OBJDIR)\wctrans.obj   \
        $(OBJDIR)\wctype.obj    \
        $(OBJDIR)\wiostrea.obj  \
        $(OBJDIR)\wlocale.obj   \
        $(OBJDIR)\xcosh.obj     \
        $(OBJDIR)\xdnorm.obj    \
        $(OBJDIR)\xdscale.obj   \
        $(OBJDIR)\xdtest.obj    \
        $(OBJDIR)\xexp.obj      \
        $(OBJDIR)\xfcosh.obj    \
        $(OBJDIR)\xfdnorm.obj   \
        $(OBJDIR)\xfdscale.obj  \
        $(OBJDIR)\xfdtest.obj   \
        $(OBJDIR)\xfexp.obj     \
        $(OBJDIR)\xfsinh.obj    \
        $(OBJDIR)\xfvalues.obj  \
        $(OBJDIR)\xlcosh.obj    \
        $(OBJDIR)\xldnorm.obj   \
        $(OBJDIR)\xldscale.obj  \
        $(OBJDIR)\xldtest.obj   \
        $(OBJDIR)\xlexp.obj     \
        $(OBJDIR)\xlocale.obj   \
        $(OBJDIR)\xlock.obj     \
        $(OBJDIR)\xlpoly.obj    \
        $(OBJDIR)\xlsinh.obj    \
        $(OBJDIR)\xlvalues.obj  \
        $(OBJDIR)\xmbtowc.obj   \
        $(OBJDIR)\xpoly.obj     \
        $(OBJDIR)\xsinh.obj     \
        $(OBJDIR)\xstod.obj     \
        $(OBJDIR)\xstrcoll.obj  \
        $(OBJDIR)\xstrxfrm.obj  \
        $(OBJDIR)\xvalues.obj   \
        $(OBJDIR)\xwcscoll.obj  \
        $(OBJDIR)\xwcsxfrm.obj  \
        $(OBJDIR)\xwctomb.obj   \
        $(OBJDIR)\_tolower.obj  \
        $(OBJDIR)\_toupper.obj


$(OBJDIR)\$(STDCPP_SRC).lib: $(STDCPP_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(STDCPP_OBJECTS: =^
)
<<keep
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\doc\pjp\mkclnmkf.c ===
/*
 * MkClnMkf - generates the makefile to cleanse the VC++ v7.0 CRTL sources
 *	in preparation for a Microsoft-internal build of the CRTL.  Those
 *	cleansed sources will also be used for the publicly-released CRTL
 *	source as a part of the VC++ 7.0 retail product.
 *
 * Programmed by Steve Salisbury, 1994-12-07 Wed
 *
 * This program takes 7 arguments:
 *	prefixSrc - path to the raw VC++ 7.0 CRTL sources
 *	prefixDst - path to the partly cleansed VC++ 7.0 CRTL sources
 *	prefixDst2 - path to the final cleansed VC++ 7.0 CRTL sources
 *	inputRaw - a list of raw input files
 *	inputCln - a list of the input files that must be cleansed
 *	output - name of the first output file (may not already exist)
 *	outputRel - name of the second output file (may not already exist)
 *
 * Modified by Steve Salisbury, 1994-12-15 Thu
 *	Restore the crtw32/ and fpw32/ subdirectories
 *	Automate the generation of the directory list
 *
 * Modified 1995-01-16 Mon - take directory list from an input file, too.
 *
 * Modified 1995-01-17 Tue - many changes to make things work when removing
 *	crtw32/ and fpw32/ directories from the target filename paths.
 *
 * Modified 1995-01-18 Wed - The 3 files cleansed with bldmkf.sed should
 *	have that file as an explicit dependency.
 *
 * Modified 1995-01-23 Mon - Add a second output file
 *
 * Modified 1996-06-27 Thu - Fix off by 1 error in list allocation
 *
 * Modified 1997-08-14 Thu (Jamie) - Revved version strings from 4.0 => 6.0
 *
 * Modified 1999-05-16 Sun (PhilipLu) - Removed MAC support
 *
 * Modified 1999-08-02 Mon (PhilipLu) - Revved version strings from 6.0 => 7.0
 *
 * Modified 1999-08-06 Fri (PhilipLu) - Set .RC file names by cmdline switches
 *
 * Modified 1999-10-17 Sun (PhilipLu) - Add -noclean options
 */


/*-
 * Build Version Options
-*/

/* define KEEPDIRS */


/*-
 * Include Header Files
-*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>


/*-
 * Define Constants
-*/

#define MAXARGLEN	128

#define	CRTW32	"crtw32\\"

#define	FPW32	"fpw32\\"


/*-
 * Define VERBOSE to get verbose output makefiles
-*/

#ifdef VERBOSE
#define	AT	""
#else
#define	AT	"@"
#endif


#if	defined(_BUILD_IA64)
#define TOOLDIR "..\\libw32\\tools\\i386"
#define CPUDIR	"ia64"
#elif	defined(_BUILD_ALPHA64)
#define TOOLDIR "..\\libw32\\tools\\alpha"
#define CPUDIR	"alpha64"
#elif	defined(_M_IA64)
#define TOOLDIR "..\\libw32\\tools\\ia64"
#define CPUDIR	"ia64"
#elif	defined(_M_ALPHA64)
#define TOOLDIR "..\\libw32\\tools\\alpha64"
#define CPUDIR	"alpha64"
#elif	defined(_M_IX86)
#define TOOLDIR "..\\libw32\\tools\\i386"
#define CPUDIR	"intel"
#elif	defined(_M_ALPHA)
#define TOOLDIR "..\\libw32\\tools\\alpha"
#define CPUDIR	"alpha"
#elif	defined(_M_MRX000)
#define TOOLDIR "..\\libw32\\tools\\mips"
#define CPUDIR	"mips"
#elif	defined(_M_PPC)
#define TOOLDIR "..\\libw32\\tools\\ppc"
#define CPUDIR	"ppc"
#endif

#define INTEL_DIR	"intel"

/*-
 * Define Global Variables (Constants)
-*/

#ifndef KEEPDIRS
char fmtRaw2 [ ] =
	"%s%s: %s%s %ssrcrel\\bldmkf.sed\n"
	"\t"	AT "echo Copying %s from %s to %s. (using SED.EXE)\n"
	"\t"	AT "if exist %s%s attrib -r %s%s\n"
	"\t"	AT "sed -f %ssrcrel\\bldmkf.sed %s%s > %s%s\n"
	"\t"	AT "attrib +r %s%s\n"
	"\n" ;
#endif /* KEEPDIRS */

char fmtRaw [ ] =
	"%s%s: %s%s\n"
	"\t"	AT "echo Copying %s from %s to %s.\n"
	"\t"	AT "if exist %s%s attrib -r %s%s\n"
	"\t"	AT "copy /b %s%s %s%s >nul\n"
	"\t"	AT "attrib +r %s%s\n"
	"\n" ;

char fmtCln2 [ ] =
	"%s%s: %s%s %ssrcrel\\msvc40.if\n"
	"\t"	AT "echo Cleansing %s%s\n"
	"\t"	AT "if exist %s%s attrib -r %s%s\n"
	"\t"	AT TOOLDIR "\\detab < %s%s | " TOOLDIR "\\trailing > %s%s\n"
	"\t"	AT "rem *\n"
	"\t"	AT "rem * IFSTRIP is NOT used on .INC assembler include files!\n"
	"\t"	AT "rem *\n"
	"\t"	AT "rem " TOOLDIR "\\ifstrip -z -c -t -x.TMP -f %ssrcrel\\msvc40.if %s%s\n"
	"\t"	AT "rem del %s%s\n"
	"\t"	AT "rem ren %s%s.TMP *%s\n"
	"\t"	AT TOOLDIR "\\striphdr -r %s%s\n"
	"\t"	AT "del %s%s\n"
	"\t"	AT "ren %s%s.NEW *%s\n"
	"\t"	AT "attrib +r %s%s\n"
	"\n" ;

char fmtCln [ ] =
	"%s%s: %s%s %ssrcrel\\msvc40.if\n"
	"\t"	AT "echo Cleansing %s%s\n"
	"\t"	AT "if exist %s%s attrib -r %s%s\n"
	"\t"	AT TOOLDIR "\\detab < %s%s | " TOOLDIR "\\trailing > %s%s\n"
	"\t"	AT TOOLDIR "\\ifstrip -z -c -t -x.TMP -f %ssrcrel\\msvc40.if %s%s\n"
	"\t"	AT "del %s%s\n"
	"\t"	AT "ren %s%s.TMP *%s\n"
	"\t"	AT TOOLDIR "\\striphdr -r %s%s\n"
	"\t"	AT "del %s%s\n"
	"\t"	AT "ren %s%s.NEW *%s\n"
	"\t"	AT "attrib +r %s%s\n"
	"\n" ;

const char prefixSrc [ ] = "$(SRC)\\" ;

const char prefixDst [ ] = "$(DST)\\" ;

char * * DirList ;

const char * szRcFiles [ 2 ] [ 2 ] [ 3 ] =
{
	{
		{ "msvcirt.rc"   , "msvcprt.rc"   , "msvcrt.rc"   } ,
		{ "msvcir64.rc"  , "msvcpr64.rc"  , "msvcrt64.rc" }
	} ,
	{
		{ "sysirt.rc"    , "sysprt.rc"    , "syscrt.rc"   } ,
		{ "sysirt64.rc"  , "sysprt64.rc"  , "syscrt64.rc" }
	}
} ;

/*-
 * Function Declarations (Prototypes)
-*/

int main ( int argc , char * * argv ) ;

void Usage ( void ) ;

char * fgetsNL ( char * lineBuf , int lineSize , FILE * fileInput ) ;

void Progress ( int prefix , char * string , int suffix ) ;

char * SkipFirstDir ( char * string ) ;


/*-
 * Function Definitions (Implementations)
-*/

int main ( int argc , char * * argv )
{
	FILE * inputRaw ;
	FILE * inputCln ;
	FILE * inputDir ;
	FILE * output ;
	FILE * output2 ;
	char lineRaw [ MAXARGLEN ] ;
	char lineCln [ MAXARGLEN ] ;
	char * rvRaw ;
	char * rvCln ;
	char * defaultSrc ;
	char * defaultDst ;
	char * defaultDst2 ;
	char * lineSkip ;
	char * * pDirs ;
	time_t timestamp ;
	struct tm localt ;
	char * * nextArg ;
	int fSysCrt = 0;
	int fCrt64 = 0;
	int fNoClean = 0;

	nextArg = ++ argv ;

	while ( * nextArg != NULL && * * nextArg == '-' )
	{
		if ( strcmp ( * nextArg , "-sys" ) == 0 )
		{
			fSysCrt = 1 ;
		}
		else if ( strcmp ( * nextArg , "-64" ) == 0 )
		{
			fCrt64 = 1 ;
		}
		else if ( strcmp ( * nextArg , "-noclean" ) == 0 )
		{
			fNoClean = 1 ;
		}
		else
		{
			Usage ( ) ;
			exit ( 1 ) ;
		}

		nextArg = ++ argv ;
		-- argc ;
	}

	if ( -- argc != 8 )
	{
		Usage ( ) ;
		exit ( 1 ) ;
	}

	defaultSrc = * nextArg ;
	++ nextArg ;
	defaultDst = * nextArg ;
	++ nextArg ;
	defaultDst2 = * nextArg ;
	++ nextArg ;
	
	if ( ( inputRaw = fopen ( * nextArg , "rt" ) ) == NULL )
	{
		fprintf ( stderr , "mkclnmkf: cannot open input file \"%s\"\n" ,
			* nextArg ) ;
		exit ( 1 ) ;
	}
	++ nextArg ;

	if ( ( inputCln = fopen ( * nextArg , "rt" ) ) == NULL )
	{
		fprintf ( stderr , "mkclnmkf: cannot open input file \"%s\"\n" ,
			* nextArg ) ;
		exit ( 1 ) ;
	}
	++ nextArg ;

	if ( ( inputDir = fopen ( * nextArg , "rt" ) ) == NULL )
	{
		fprintf ( stderr , "mkclnmkf: cannot open input file \"%s\"\n" ,
			* nextArg ) ;
		exit ( 1 ) ;
	}
	++ nextArg ;

	if ( ( output = fopen ( * nextArg , "rb" ) ) != NULL )
	{
		fprintf ( stderr , "mkclnmkf: first output file already exists: \"%s\"\n" ,
			* nextArg ) ;
		exit ( 1 ) ;
	}

	if ( ( output = fopen ( * nextArg , "wt" ) ) == NULL )
	{
		fprintf ( stderr , "mkclnmkf: cannot open first output file: \"%s\"\n" ,
			* nextArg ) ;
		exit ( 1 ) ;
	}
	++ nextArg ;

	if ( ( output2 = fopen ( * nextArg , "rb" ) ) != NULL )
	{
		fprintf ( stderr , "mkclnmkf: second output file already exists: \"%s\"\n" ,
			* nextArg ) ;
		exit ( 1 ) ;
	}

	if ( ( output2 = fopen ( * nextArg , "wt" ) ) == NULL )
	{
		fprintf ( stderr , "mkclnmkf: cannot open second output file: \"%s\"\n" ,
			* nextArg ) ;
		exit ( 1 ) ;
	}
	++ nextArg ;

	/*-
	 * Read in the list of directories
	-*/

	{
		int numDirs = 0 ;
		int maxNumDirs = 0 ;
		char nextDir [ MAXARGLEN ] ;
		char * pDir ;

		pDir = fgetsNL ( nextDir , sizeof ( nextDir ) , inputDir ) ;

		while ( pDir )
		{
			if ( numDirs + 1 >= maxNumDirs )
			{
				maxNumDirs += 16 ;
				if ( ! ( DirList = ( char * * ) realloc ( DirList ,
					sizeof ( char * ) * maxNumDirs ) ) )
				{
					fprintf ( stderr ,
						"mkclnmkf: realloc failed (maxNumDirs=%d)\n" ,
							maxNumDirs ) ;

					exit ( 1 ) ;
				}
			}

			DirList [ numDirs ] = _strdup ( nextDir ) ;

			if ( ! DirList [ numDirs ] )
			{
				fprintf ( stderr ,
					"mkclnmkf: strdup failed (nextDir=\"%s\")\n" ,
						nextDir ) ;

				exit ( 1 ) ;
			}

			++ numDirs ;

			pDir = fgetsNL ( nextDir , sizeof ( nextDir ) , inputDir ) ;
		}

		DirList [ numDirs ] = NULL ;

		{
			int i ;

			fprintf ( stderr , "Reading in directory list...\n" ) ;

			for ( i = 0 ; DirList [ i ] ; ++ i )
				Progress ( '(' , DirList [ i ] , ')' ) ;

			Progress ( '(' , NULL , ')' ) ;
		}
	}

	if ( fclose ( inputDir ) )
	{
		fprintf ( stderr ,
			"mkclnmkf: error closing input file \"%s\"\n" ,
			* nextArg ) ;
	}

	/*
	 * Generate MAKEFILE header comment
	 */

	time ( & timestamp ) ;

	localt = * localtime ( & timestamp ) ;

	fprintf ( output ,
	"########\n"
	"#\n"
	"# This is a program-generated Makefile, the purpose of which is to\n"
	"# copy Visual C++ v7.0 C Run-Time Library Source files from the raw\n"
	"# source tree to a directory structure suitable for end user usage\n"
	"# in debugging and modification.  Not all of the VC++ 7.0 CRTL srcs\n"
	"# are provided to end users, but the ones that are 'cleansed' using\n"
	"# an automated process.  Another makefile will copy these cleansed\n"
	"# files to their final directory lay-out.\n"
	"#\n"
	"# This Makefile was generated on\n"
	"#\t\t%.3s %2d %4d at %02d:%02d:%02d\n"
	"#\n"
	"# The program that generated this Makefile was compiled on\n"
	"#\t\t" __DATE__ " at " __TIME__ "\n"
	"\n"
	"!if \"$(SRC)\"==\"\"\n"
	"SRC=%s\n"
	"!endif\n"
	"\n"
	"!if \"$(DST)\"==\"\"\n"
	"DST=%s\n"
	"!endif\n"
	"\n"
	"all:\tdirs files\n"
	"\n"
	"files: \\\n" ,
		localt . tm_mon * 3 + "JanFebMarAprMayJunJulAugSepOctNovDec" ,
		localt . tm_mday , localt . tm_year + 1900 ,
		localt . tm_hour , localt . tm_min , localt . tm_sec ,
		defaultSrc , defaultDst ) ;


	fprintf ( output2 ,
	"########\n"
	"#\n"
	"# This is a program-generated Makefile, the purpose of which is to\n"
	"# copy the cleansed Visual C++ v7.0 C Run-Time Library Source files\n"
	"# to their directory lay-out which will be received by end users.\n"
	"#\n"
	"# This Makefile was generated on\n"
	"#\t\t%.3s %2d %4d at %02d:%02d:%02d\n"
	"#\n"
	"# The program that generated this Makefile was compiled on\n"
	"#\t\t" __DATE__ " at " __TIME__ "\n"
	"\n"
	"!if \"$(SRC)\"==\"\"\n"
	"SRC=%s\n"
	"!endif\n"
	"\n"
	"!if \"$(DST)\"==\"\"\n"
	"DST=%s\n"
	"!endif\n"
	"\n"
	"all:\tdirs files\n"
	"\n"
	"dirs:\n"
	"\t" AT "if not exist %s" CPUDIR "\\NUL mkdire %s" CPUDIR "\n"
#if	defined(_BUILD_IA64)
	"\t" AT "if not exist %s" INTEL_DIR "\\NUL mkdire %s" INTEL_DIR "\n"
#endif
	"\t" AT "if not exist %ssys\\NUL mkdire %ssys\n"
	"\t" AT "if not exist %sbuild\\NUL mkdire %sbuild\n"
	"\t" AT "if not exist %sbuild\\" CPUDIR "\\NUL mkdire %sbuild\\" CPUDIR "\n"
	"\n"
	"files: \\\n"
	"\t%s%s \\\n"
	"\t%smakefile \\\n"
	"\t%smakefile.inc \\\n"
	"\t%smakefile.sub \\\n" ,
		localt . tm_mon * 3 + "JanFebMarAprMayJunJulAugSepOctNovDec" ,
		localt . tm_mday , localt . tm_year + 1900 ,
		localt . tm_hour , localt . tm_min , localt . tm_sec ,
		defaultDst , defaultDst2 ,
		/* if not exist ... CPUDIR */
		prefixDst , prefixDst ,
#if	defined(_BUILD_IA64)
		/* if not exist intel */
		prefixDst , prefixDst ,
#endif
		/* if not exist sys */
		prefixDst , prefixDst ,
		/* if not exist build ... */
		prefixDst , prefixDst ,
		prefixDst , prefixDst ,
		/* RC files... */
		prefixDst , szRcFiles [ fSysCrt ] [ fCrt64 ] [ 1 ] ,
		prefixDst ,
		/* makefile.{,inc,sub} */
		prefixDst , prefixDst , prefixDst ) ;

	/*
	 * Generate default ("all") dependecy
	 */

	/*-
	 * First, files that are just copied
	-*/

	rvRaw = fgetsNL ( lineRaw , sizeof ( lineRaw ) , inputRaw ) ;

	while ( rvRaw )
	{
		lineSkip = lineRaw ;

#ifndef KEEPDIRS
		if ( ! strncmp ( "crtw32\\" , lineSkip , 7 ) )
			lineSkip += 7 ;
		else if ( ! strncmp ( "fpw32\\" , lineSkip , 6 ) )
			lineSkip += 6 ;
#endif /* KEEPDIRS */

		fprintf ( output , "\t%s%s \\\n" ,
			prefixDst , lineSkip ) ;

		if ( ! memcmp ( lineSkip , "stdcpp\\" , 7 )
		  || ! memcmp ( lineSkip , "stdhpp\\" , 7 ) )
		{
			/*
			 * Files in the stdcpp / stdhpp directories are
			 * special cases -- they are not cleansed but are
			 * copied to the crt/src/ directory.
			 */
			fprintf ( output2 , "\t%s%s \\\n" ,
				prefixDst , lineSkip + 7 ) ;
		}

		rvRaw = fgetsNL ( lineRaw , sizeof ( lineRaw ) , inputRaw ) ;
	}
	
	/*-
	 * Second, files that have be cleansed
	-*/

	rvCln = fgetsNL ( lineCln , sizeof ( lineCln ) , inputCln ) ;

	while ( rvCln )
	{
		lineSkip = lineCln ;

#ifndef KEEPDIRS
		if ( ! strncmp ( "crtw32\\" , lineSkip , 7 ) )
			lineSkip += 7 ;
		else if ( ! strncmp ( "fpw32\\" , lineSkip , 6 ) )
			lineSkip += 6 ;
#endif /* KEEPDIRS */

		fprintf ( output , "\t%s%s \\\n" ,
			prefixDst , lineSkip ) ;

		fprintf ( output2 , "\t%s%s \\\n" ,
			prefixDst , SkipFirstDir ( lineSkip ) ) ;

		rvCln = fgetsNL ( lineCln , sizeof ( lineCln ) , inputCln ) ;
	}

	fprintf ( output ,
		"\n\n# Directory Dependencies:\n\ndirs:\n"
		"\t" AT "if not exist %sbuild\\NUL mkdire %sbuild\n" ,
			prefixDst , prefixDst ) ;

#ifdef BLDROOTDIR
	/*
	 * Create Root Directory Component by Component
	 *	NOTE: this code assumes prefixDst resembles:
	 *		\msdev\crt\src\
	 */

	{
		char temp [ MAXARGLEN ] ;
		char * prefixSlash ;
		char * prefixNext ;
		int len ;

		strcpy ( temp , prefixDst ) ;
		len = strlen ( temp ) ;

		if ( temp [ len - 1 ] == '\\' )
			temp [ len - 1 ] == '\0' ;

		prefixNext = prefixDst + 1 ;

		while ( prefixSlash = strchr ( prefixNext , '\\' ) )
		{
			temp [ prefixSlash - prefixDst ] = '\0' ;

			fprintf ( output ,
	"\t" AT "if not exist %s\\NUL mkdire %s\n" ,
				temp , temp ) ;

			prefixNext = prefixSlash + 1 ;
			temp [ prefixSlash - prefixDst ] = '\\' ;
		}
	}
#endif /* BLDROOTDIR */

	/*
	 * Create Directories
	 */

	for ( pDirs = DirList ; * pDirs ; ++ pDirs )
	{
		char * targetDir ;

		targetDir = * pDirs ;

#ifndef KEEPDIRS
		if ( ! strcmp ( "crtw32" , targetDir )
		  || ! strcmp ( "fpw32" , targetDir ) )
			continue ;

		if ( ! strncmp ( "crtw32\\" , targetDir , 7 ) )
			targetDir += 7 ;
		else if ( ! strncmp ( "fpw32\\" , targetDir , 6 ) )
			targetDir += 6 ;
#endif /* KEEPDIRS */

		fprintf ( output ,
	"\t" AT "if not exist %s%s\\NUL mkdire %s%s\n" ,
			prefixDst , targetDir ,
			prefixDst , targetDir ,
			prefixDst , targetDir ) ;
	}

	fprintf ( output , "\n\n#\n# Individual Dependencies:\n#\n\n" ) ;

	/*
	 * Second output makefile has some special targets
	 */

	fprintf ( output2 , "\n\n#\n# Individual Dependencies:\n#\n\n" ) ;
	
	{
		static char * listMkf [ ] =
		{
			"makefile" , "makefile.inc" , "makefile.sub" , NULL
		} ;

		static const char * listSpc [ ] =
		{
			"msvcprt.rc" , NULL
		} ;

		int i ;

		listSpc [ 0 ] = szRcFiles [ fSysCrt ] [ fCrt64 ] [ 0 ] ;
		listSpc [ 1 ] = szRcFiles [ fSysCrt ] [ fCrt64 ] [ 1 ] ;
		listSpc [ 2 ] = szRcFiles [ fSysCrt ] [ fCrt64 ] [ 2 ] ;

		for ( i = 0 ; listSpc [ i ] ; ++ i )
			fprintf ( output2 ,
				"%s%s: %slibw32\\%s\n"
				"\t" AT "echo Copying %s from %s to %s.\n"
				"\t" AT "if exist %s%s attrib -r %s%s\n"
				"\t" AT "copy /b $** $@ >NUL\n"
				"\t" AT "attrib +r %s%s\n"
				"\n" ,
				/* %s%s: %slibw32\\%s */
				prefixDst , listSpc [ i ] ,
				prefixSrc , listSpc [ i ] ,
				/* echo Copying %s from %s to %s. */
				listSpc [ i ] , prefixSrc , prefixDst ,
				/* if exist %s%s attrib -r %s%s */
				prefixDst , listSpc [ i ] ,
				prefixDst , listSpc [ i ] ,
				/* copy /b $** $@ >NUL */
				/* attrib +r %s%s */
				prefixDst , listSpc [ i ] ) ;

		for ( i = 0 ; listMkf [ i ] ; ++ i )
			fprintf ( output2 ,
				"%s%s: %s%s relmkf.sed\n"
				"\t" AT "echo Copying %s from %s to %s. (using SED)\n"
				"\t" AT "if exist %s%s attrib -r %s%s\n"
				"\t" AT "sed -f relmkf.sed %s%s > $@\n"
				"\t" AT "attrib +r %s%s\n"
				"\n" ,
				/* %s%s: %slibw32\\%s */
				prefixDst , listMkf [ i ] ,
				prefixSrc , listMkf [ i ] ,
				/* echo Copying %s from %s to %s. */
				listMkf [ i ] , prefixSrc , prefixDst ,
				/* if exist %s%s attrib -r %s%s */
				prefixDst , listMkf [ i ] ,
				prefixDst , listMkf [ i ] ,
				/* sed -f relmkf.sed %s%s > $@ */
				prefixSrc , listMkf [ i ] ,
				/* attrib +r %s%s */
				prefixDst , listMkf [ i ] ) ;
	}

	/*
	 * Reset input files for another pass: individual dependencies
	 */

	if ( fseek ( inputRaw , 0L , SEEK_SET )
	  || fseek ( inputCln , 0L , SEEK_SET ) )
	{
		fprintf ( stderr , "mkclnmkf: cannot reset input file(s)\n" ) ;
		exit ( 1 ) ;
	}


	/*
	 * Generate individual dependecies for files that are copied as-is
	 */

	fprintf ( stderr , "Producing copied file dependencies...\n" ) ;

	fprintf ( output , "# Copied File Dependencies:\n\n" ) ;

	rvRaw = fgetsNL ( lineRaw , sizeof ( lineRaw ) , inputRaw ) ;

	while ( rvRaw )
	{
		lineSkip = lineRaw ;

#ifndef KEEPDIRS
		/*
		 * strip crtw32\ and fpw32\ from the input string
		 */

		if ( ! strncmp ( "crtw32\\" , lineSkip , 7 ) )
			lineSkip += 7 ;
		else if ( ! strncmp ( "fpw32\\" , lineSkip , 6 ) )
			lineSkip += 6 ;

		if ( ( lineRaw [ 0 ] != 'f'
		  || strcmp ( lineSkip + strlen ( lineSkip ) - 9 , "\\lsources" ) )
		  && strcmp ( "makefile" , lineRaw ) )
#endif /* KEEPDIRS */

			fprintf ( output , fmtRaw ,
				/* %s%s: %s%s */
				prefixDst , lineSkip , prefixSrc , lineRaw ,
				/* echo Copying %s from %s to %s */
				lineSkip , prefixSrc , prefixDst ,
				/* if exist %s%s attrib -r %s%s */
				prefixDst , lineSkip , prefixDst , lineSkip ,
				/* copy /b %s%s %s%s */
				prefixSrc , lineRaw , prefixDst , lineSkip ,
				/* attrib +r %s%s */
				prefixDst , lineSkip ) ;
#ifndef KEEPDIRS
		else
			fprintf ( output , fmtRaw2 ,
				/* %s%s: %s%s %ssrcrel\\bldmkf.sed */
				prefixDst , lineSkip ,
				prefixSrc , lineRaw , prefixSrc ,
				/* echo Copying %s from %s to %s */
				lineSkip , prefixSrc , prefixDst ,
				/* if exist %s%s attrib -r %s%s */
				prefixDst , lineSkip , prefixDst , lineSkip ,
				/* sed -f %ssrcrel\\bldmkf.sed %s%s > %s%s */
				prefixSrc ,
				prefixSrc , lineRaw , prefixDst , lineSkip ,
				/* attrib +r %s%s */
				prefixDst , lineSkip ) ;
#endif /* KEEPDIRS */

		if ( ! memcmp ( lineSkip , "stdcpp\\" , 7 )
		  || ! memcmp ( lineSkip , "stdhpp\\" , 7 ) )
		{
			/*
			 * Files in the stdcpp / stdhpp directories are
			 * special cases -- they are not cleansed but are
			 * copied to the crt/src/ directory.
			 */
			fprintf ( output2 , "%s%s: %s%s\n"
				"\t" AT "echo Copying %s from %s to %s.\n"
				"\t" AT "if exist %s%s attrib -r %s%s\n"
				"\t" AT "copy /b %s%s %s%s\n"
				"\t" AT "attrib +r %s%s\n"
				"\n" ,
				prefixDst , lineSkip + 7 ,
				prefixSrc , lineSkip ,
				lineRaw , prefixSrc , prefixDst ,
				prefixDst , lineSkip + 7 ,
				prefixDst , lineSkip + 7 ,
				prefixSrc , lineSkip ,
				prefixDst , lineSkip + 7 ,
				prefixDst , lineSkip + 7 ) ;
		}

		Progress ( '[' , lineRaw , ']' ) ;

		rvRaw = fgetsNL ( lineRaw , sizeof ( lineRaw ) , inputRaw ) ;
	}

	Progress ( '[' , NULL , ']' ) ;

	/*
	 * Generate individual dependecies for files that are cleansed
	 */

	fprintf ( stderr , "Producing cleansed file dependencies...\n" ) ;

	fprintf ( output , "# Cleansed File Dependencies:\n\n" ) ;

	rvCln = fgetsNL ( lineCln , sizeof ( lineCln ) , inputCln ) ;

	while ( rvCln )
	{
		char * pExt ;
		char pNoExt [ MAXARGLEN ] ;

		lineSkip = lineCln ;

#ifndef KEEPDIRS
		/*
		 * strip crtw32\ and fpw32\ from the input string
		 */

		if ( ! strncmp ( "crtw32\\" , lineSkip , 7 ) )
			lineSkip += 7 ;
		else if ( ! strncmp ( "fpw32\\" , lineSkip , 6 ) )
			lineSkip += 6 ;
#endif /* KEEPDIRS */

		pExt = strrchr ( lineSkip , '.' ) ;

		if ( ! pExt )
		{
			fprintf ( stderr ,
				"Warning: filename has no extension: %s\n" ,
				lineCln ) ;

			pExt = lineSkip + strlen ( pExt ) ;
		}

		strcpy ( pNoExt , lineSkip ) ;
		pNoExt [ pExt - lineSkip ] = '\0' ;

		if ( !fNoClean )

		    /*
		     * .INC files do not get ifstripped - use fmtCln2 for them
		     */

		    fprintf ( output ,
			    strcmp ( ".inc" , pExt ) ? fmtCln : fmtCln2 ,
			    /* %s%s: %scrtw32\%s %ssrcrel\msvc40.if */
			    prefixDst , lineSkip , prefixSrc , lineCln , prefixSrc ,
			    /* echo Cleansing %scrtw32\%s */
			    prefixDst , lineSkip ,
			    /* if exist %s%s attrib -r %s%s */
			    prefixDst , lineSkip , prefixDst , lineSkip ,
			    /* detab < %scrtw32\%s | trailing > ... */
			    prefixSrc , lineCln , prefixDst , lineSkip ,
			    /* ifstrip %s\srcrel\msvc40.if %s%s */
			    prefixSrc , prefixDst , lineSkip ,
			    /* del %s%s */
			    prefixDst , lineSkip ,
			    /* ren %s%s.TMP *%s */
			    prefixDst , pNoExt , pExt ,
			    /* striphdr -r %s%s */
			    prefixDst , lineSkip ,
			    /* del %s%s */
			    prefixDst , lineSkip ,
			    /* ren %s%s.NEW *%s */
			    prefixDst , pNoExt , pExt ,
			    /* attrib +r %s%s */
			    prefixDst , lineSkip ) ;

		else

		    /*
		     * -noclean: Just copy, don't cleanse, for development builds
		     */

		    fprintf ( output , fmtRaw ,
			    /* %s%s: %s%s */
			    prefixDst , lineSkip , prefixSrc , lineCln ,
			    /* echo Copying %s from %s to %s */
			    lineSkip , prefixSrc , prefixDst ,
			    /* if exist %s%s attrib -r %s%s */
			    prefixDst , lineSkip , prefixDst , lineSkip ,
			    /* copy /b %s%s %s%s */
			    prefixSrc , lineCln , prefixDst , lineSkip ,
			    /* attrib +r %s%s */
			    prefixDst , lineSkip ) ;

		/*
		 * Secondary makefile
		 */

		if ( memcmp ( "libw32" , lineCln , 6 ) )
		{
			char * lineSkipFirst = SkipFirstDir ( lineSkip ) ;

			if ( ! strcmp ( ".asm" , pExt ) &&
			   (  ! memcmp ( "mbstring" , lineSkip , 8 )
			   || ! strcmp ( "memmove.asm" , pExt - 7 )
			   || ! strcmp ( "strcspn.asm" , pExt - 7 )
			   || ! strcmp ( "strpbrk.asm" , pExt - 7 ) )
			  || ! strcmp ( ".c" , pExt ) &&
			   (  ! strcmp ( "mbscat.c" , pExt - 6 )
			   || ! strcmp ( "mbsdup.c" , pExt - 6 ) ) )
				fprintf ( output2 ,
					"%s%s: %s%s asmfile.sed\n"
					"\t" AT "echo Copying %s from %s to %s. (using SED.EXE)\n"
					"\t" AT "if exist %s%s attrib -r %s%s\n"
					"\t" AT "sed -f asmfile.sed %s%s > $@\n"
					"\t" AT "attrib +r %s%s\n"
					"\n" ,
					/* %s%s: %s%s asmfile.sed */
					prefixDst , lineSkipFirst ,
					prefixSrc , lineSkip ,
					/* echo Copying %s from %s to %s... */
					lineSkip , prefixSrc , prefixDst ,
					/* if exist %s%s attrib -r %s%s */
					prefixDst , lineSkipFirst ,
					prefixDst , lineSkipFirst ,
					/* sed -f asmfile.sed %s%s > $@ */
					prefixSrc , lineSkip ,
					/* attrib +r %s%s */
					prefixDst , lineSkipFirst ) ;
			else
				fprintf ( output2 ,
					"%s%s: %s%s\n"
					"\t" AT "echo Copying %s from %s to %s.\n"
					"\t" AT "if exist %s%s attrib -r %s%s\n"
					"\t" AT "copy /b $** $@ >NUL\n"
					"\t" AT "attrib +r %s%s\n"
					"\n" ,
					/* %s%s: %s%s */
					prefixDst , lineSkipFirst ,
					prefixSrc , lineSkip ,
					/* Copying %s from %s to %s */
					lineSkip , prefixSrc , prefixDst ,
					/* if exist %s%s attrib -r %s%s */
					prefixDst , lineSkipFirst ,
					prefixDst , lineSkipFirst ,
					/* copy /b $** $@ >NUL */
					/* attrib +r %s%s */
					prefixDst , lineSkipFirst ) ;
		}
	
		/*
		 * Show Progress 
		 */

		Progress ( '{' , lineSkip , '}' ) ;

		rvCln = fgetsNL ( lineCln , sizeof ( lineCln ) , inputCln ) ;
	}

	Progress ( '{' , NULL , '}' ) ;

	return 0 ;
}


/*
 * Usage - print message explaining the arguments to this program
 */

void Usage ( void )
{
	fprintf ( stderr ,
	"Usage: mkclnmkf [opts] prefIn prefOut prefOut2 fRaw fCln dirList mkfOut mkfOut2\n"
	"where\tprefIn is the input prefix (such as \"\\crt\")\n"
	"\tprefOut is the primary output prefix (such as \"\\msdev\\crt\\prebuild\")\n"
	"\tprefOut2 is the secondary output prefix (such as \"\\msdev\\crt\\src\")\n"
	"\tfRaw is a list of files to be copied as-is\n"
	"\tfCln is a list of files to be cleansed\n"
	"\tdirList is a list of the directories to be created\n"
	"\tmkfOut is the primary output makefile (it may not already exist)\n"
	"\tmkfOut2 is the secondary output makefile (it may not already exist)\n\n"
	"\tOptions:\n"
	"\t  -sys\t\tuse system CRT filenames\n"
	"\t  -64\t\tuse Win64 CRT filenames\n"
	"\t  -noclean\tdon't cleanse source files\n"
	) ;
}


/*
 * fgetsNL - same as fgets except final newline character is deleted
 *	Upon EOF or error, make sure the buffer is set to the empty string.
 */

char * fgetsNL ( char * lineBuf , int lineSize , FILE * fileInput )
{
	char * retval = fgets ( lineBuf , lineSize , fileInput ) ;

	if ( retval )
	{
		int len = strlen ( lineBuf ) ;

		if ( len < 1 && lineBuf [ len - 1 ] != '\n' )
		{
			fprintf ( stderr , "mkclnmkf: malformed input line:\n\t%s\n" , lineBuf ) ;
		}
		else
			lineBuf [ len - 1 ] = '\0' ;
	}
	else
		lineBuf [ 0 ] = '\0' ;

	return retval ;
}

void Progress ( int prefix , char * string , int suffix )
{
static	int prevlen = 0 ;
static	int counter = 0 ;

	if ( string == NULL )
	{
		fprintf ( stderr , "%*s\n" , prevlen + 3 , " " )  ;
		prevlen = 0 ;
		counter = 0 ;
	}
	else if ( ++ counter % 100 == 1 )
	{
		int length = strlen ( string ) ;

		fprintf ( stderr , "%c%s%c%*s\r" ,
			prefix , string , suffix ,
			prevlen > length ? prevlen - length : 1 ,
			" " ) ;

		prevlen = length ;
	}
}

char * SkipFirstDir ( char * string )
{
	char * pFile = string ;

	while ( * pFile ++ != '\\' )
		if ( ! * pFile )
		{
			fprintf ( stderr ,
				"mkclnmkf: no \\ in \"%s\"\n" , string ) ;
			exit ( 1 ) ;
		}

	return pFile ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\conv\assrt.c ===
/***
*assrt.c - assertions needed for string conversion routines
*
*	Copyright (c) 1991-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*   Make sure that the data types used by the string conversion
*   routines have the right size. If this file does not compile,
*   the type definitions in cv.h should change appropriately.
*
*Revision History:
*   07-25-91	    GDP     written
*
*******************************************************************************/


#include <cv.h>

static void assertion_test(void)
{
    sizeof(u_char) == 1 ? 0 : 1/0,
    sizeof(u_short)  == 2 ? 0 : 1/0,
    sizeof(u_long) == 4 ? 0 : 1/0,
    sizeof(s_char) == 1 ? 0 : 1/0,
    sizeof(s_short)  == 2 ? 0 : 1/0,
    sizeof(s_long) == 4 ? 0 : 1/0;
#ifdef _LDSUPPORT
    sizeof(long double) == 10 ? 0 : 1/0;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\conv\constpow.c ===
/***
*constpow.c - constant powers of ten
*
*	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Provide powers of ten in long double form:
*   10^(2^i), i=0,1,2,...
*
*Revision History:
*   7-17-91	GDP	Initial version (ported from assembly)
*
*******************************************************************************/


#include <cv.h>

/* Format: A 10 byte long double + 2 bytes of extra precision
 * If the extra precision is desired, the 10-byte long double
 * should be "unrounded" first.
 * This may change in later versions
 */

#ifdef L_END

_LDBL12 _pow10pos[] = {
 /*P0001*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x02,0x40}},
 /*P0002*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x05,0x40}},
 /*P0003*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFA,0x08,0x40}},
 /*P0004*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x9C,0x0C,0x40}},
 /*P0005*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x50,0xC3,0x0F,0x40}},
 /*P0006*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x24,0xF4,0x12,0x40}},
 /*P0007*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x80,0x96,0x98,0x16,0x40}},
 /*P0008*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x20,0xBC,0xBE,0x19,0x40}},
 /*P0016*/ {{0x00,0x00, 0x00,0x00,0x00,0x04,0xBF,0xC9,0x1B,0x8E,0x34,0x40}},
 /*P0024*/ {{0x00,0x00, 0x00,0xA1,0xED,0xCC,0xCE,0x1B,0xC2,0xD3,0x4E,0x40}},
 /*P0032*/ {{0x20,0xF0, 0x9E,0xB5,0x70,0x2B,0xA8,0xAD,0xC5,0x9D,0x69,0x40}},
 /*P0040*/ {{0xD0,0x5D, 0xFD,0x25,0xE5,0x1A,0x8E,0x4F,0x19,0xEB,0x83,0x40}},
 /*P0048*/ {{0x71,0x96, 0xD7,0x95,0x43,0x0E,0x05,0x8D,0x29,0xAF,0x9E,0x40}},
 /*P0056*/ {{0xF9,0xBF, 0xA0,0x44,0xED,0x81,0x12,0x8F,0x81,0x82,0xB9,0x40}},
 /*P0064*/ {{0xBF,0x3C, 0xD5,0xA6,0xCF,0xFF,0x49,0x1F,0x78,0xC2,0xD3,0x40}},
 /*P0128*/ {{0x6F,0xC6, 0xE0,0x8C,0xE9,0x80,0xC9,0x47,0xBA,0x93,0xA8,0x41}},
 /*P0192*/ {{0xBC,0x85, 0x6B,0x55,0x27,0x39,0x8D,0xF7,0x70,0xE0,0x7C,0x42}},
 /*P0256*/ {{0xBC,0xDD, 0x8E,0xDE,0xF9,0x9D,0xFB,0xEB,0x7E,0xAA,0x51,0x43}},
 /*P0320*/ {{0xA1,0xE6, 0x76,0xE3,0xCC,0xF2,0x29,0x2F,0x84,0x81,0x26,0x44}},
 /*P0384*/ {{0x28,0x10, 0x17,0xAA,0xF8,0xAE,0x10,0xE3,0xC5,0xC4,0xFA,0x44}},
 /*P0448*/ {{0xEB,0xA7, 0xD4,0xF3,0xF7,0xEB,0xE1,0x4A,0x7A,0x95,0xCF,0x45}},
 /*P0512*/ {{0x65,0xCC, 0xC7,0x91,0x0E,0xA6,0xAE,0xA0,0x19,0xE3,0xA3,0x46}},
 /*P1024*/ {{0x0D,0x65, 0x17,0x0C,0x75,0x81,0x86,0x75,0x76,0xC9,0x48,0x4D}},
 /*P1536*/ {{0x58,0x42, 0xE4,0xA7,0x93,0x39,0x3B,0x35,0xB8,0xB2,0xED,0x53}},
 /*P2048*/ {{0x4D,0xA7, 0xE5,0x5D,0x3D,0xC5,0x5D,0x3B,0x8B,0x9E,0x92,0x5A}},
 /*P2560*/ {{0xFF,0x5D, 0xA6,0xF0,0xA1,0x20,0xC0,0x54,0xA5,0x8C,0x37,0x61}},
 /*P3072*/ {{0xD1,0xFD, 0x8B,0x5A,0x8B,0xD8,0x25,0x5D,0x89,0xF9,0xDB,0x67}},
 /*P3584*/ {{0xAA,0x95, 0xF8,0xF3,0x27,0xBF,0xA2,0xC8,0x5D,0xDD,0x80,0x6E}},
 /*P4096*/ {{0x4C,0xC9, 0x9B,0x97,0x20,0x8A,0x02,0x52,0x60,0xC4,0x25,0x75}}
};

_LDBL12 _pow10neg[] = {
 /*N0001*/ {{0xCD,0xCC, 0xCD,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xFB,0x3F}},
 /*N0002*/ {{0x71,0x3D, 0x0A,0xD7,0xA3,0x70,0x3D,0x0A,0xD7,0xA3,0xF8,0x3F}},
 /*N0003*/ {{0x5A,0x64, 0x3B,0xDF,0x4F,0x8D,0x97,0x6E,0x12,0x83,0xF5,0x3F}},
 /*N0004*/ {{0xC3,0xD3, 0x2C,0x65,0x19,0xE2,0x58,0x17,0xB7,0xD1,0xF1,0x3F}},
 /*N0005*/ {{0xD0,0x0F, 0x23,0x84,0x47,0x1B,0x47,0xAC,0xC5,0xA7,0xEE,0x3F}},
 /*N0006*/ {{0x40,0xA6, 0xB6,0x69,0x6C,0xAF,0x05,0xBD,0x37,0x86,0xEB,0x3F}},
 /*N0007*/ {{0x33,0x3D, 0xBC,0x42,0x7A,0xE5,0xD5,0x94,0xBF,0xD6,0xE7,0x3F}},
 /*N0008*/ {{0xC2,0xFD, 0xFD,0xCE,0x61,0x84,0x11,0x77,0xCC,0xAB,0xE4,0x3F}},
 /*N0016*/ {{0x2F,0x4C, 0x5B,0xE1,0x4D,0xC4,0xBE,0x94,0x95,0xE6,0xC9,0x3F}},
 /*N0024*/ {{0x92,0xC4, 0x53,0x3B,0x75,0x44,0xCD,0x14,0xBE,0x9A,0xAF,0x3F}},
 /*N0032*/ {{0xDE,0x67, 0xBA,0x94,0x39,0x45,0xAD,0x1E,0xB1,0xCF,0x94,0x3F}},
 /*N0040*/ {{0x24,0x23, 0xC6,0xE2,0xBC,0xBA,0x3B,0x31,0x61,0x8B,0x7A,0x3F}},
 /*N0048*/ {{0x61,0x55, 0x59,0xC1,0x7E,0xB1,0x53,0x7C,0x12,0xBB,0x5F,0x3F}},
 /*N0056*/ {{0xD7,0xEE, 0x2F,0x8D,0x06,0xBE,0x92,0x85,0x15,0xFB,0x44,0x3F}},
 /*N0064*/ {{0x24,0x3F, 0xA5,0xE9,0x39,0xA5,0x27,0xEA,0x7F,0xA8,0x2A,0x3F}},
 /*N0128*/ {{0x7D,0xAC, 0xA1,0xE4,0xBC,0x64,0x7C,0x46,0xD0,0xDD,0x55,0x3E}},
 /*N0192*/ {{0x63,0x7B, 0x06,0xCC,0x23,0x54,0x77,0x83,0xFF,0x91,0x81,0x3D}},
 /*N0256*/ {{0x91,0xFA, 0x3A,0x19,0x7A,0x63,0x25,0x43,0x31,0xC0,0xAC,0x3C}},
 /*N0320*/ {{0x21,0x89, 0xD1,0x38,0x82,0x47,0x97,0xB8,0x00,0xFD,0xD7,0x3B}},
 /*N0384*/ {{0xDC,0x88, 0x58,0x08,0x1B,0xB1,0xE8,0xE3,0x86,0xA6,0x03,0x3B}},
 /*N0448*/ {{0xC6,0x84, 0x45,0x42,0x07,0xB6,0x99,0x75,0x37,0xDB,0x2E,0x3A}},
 /*N0512*/ {{0x33,0x71, 0x1C,0xD2,0x23,0xDB,0x32,0xEE,0x49,0x90,0x5A,0x39}},
 /*N1024*/ {{0xA6,0x87, 0xBE,0xC0,0x57,0xDA,0xA5,0x82,0xA6,0xA2,0xB5,0x32}},
 /*N1536*/ {{0xE2,0x68, 0xB2,0x11,0xA7,0x52,0x9F,0x44,0x59,0xB7,0x10,0x2C}},
 /*N2048*/ {{0x25,0x49, 0xE4,0x2D,0x36,0x34,0x4F,0x53,0xAE,0xCE,0x6B,0x25}},
 /*N2560*/ {{0x8F,0x59, 0x04,0xA4,0xC0,0xDE,0xC2,0x7D,0xFB,0xE8,0xC6,0x1E}},
 /*N3072*/ {{0x9E,0xE7, 0x88,0x5A,0x57,0x91,0x3C,0xBF,0x50,0x83,0x22,0x18}},
 /*N3584*/ {{0x4E,0x4B, 0x65,0x62,0xFD,0x83,0x8F,0xAF,0x06,0x94,0x7D,0x11}},
 /*N4096*/ {{0xE4,0x2D, 0xDE,0x9F,0xCE,0xD2,0xC8,0x04,0xDD,0xA6,0xD8,0x0A}}
};

#endif

#ifdef B_END

_LDBL12 _pow10pos[] = {
 /*P0001*/ {{0x40,0x02,0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0002*/ {{0x40,0x05,0xC8,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0003*/ {{0x40,0x08,0xFA,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0004*/ {{0x40,0x0C,0x9C,0x40,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0005*/ {{0x40,0x0F,0xC3,0x50,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0006*/ {{0x40,0x12,0xF4,0x24,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0007*/ {{0x40,0x16,0x98,0x96,0x80,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0008*/ {{0x40,0x19,0xBE,0xBC,0x20,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0016*/ {{0x40,0x34,0x8E,0x1B,0xC9,0xBF,0x04,0x00,0x00,0x00, 0x00,0x00}},
 /*P0024*/ {{0x40,0x4E,0xD3,0xC2,0x1B,0xCE,0xCC,0xED,0xA1,0x00, 0x00,0x00}},
 /*P0032*/ {{0x40,0x69,0x9D,0xC5,0xAD,0xA8,0x2B,0x70,0xB5,0x9E, 0xF0,0x20}},
 /*P0040*/ {{0x40,0x83,0xEB,0x19,0x4F,0x8E,0x1A,0xE5,0x25,0xFD, 0x5D,0xD0}},
 /*P0048*/ {{0x40,0x9E,0xAF,0x29,0x8D,0x05,0x0E,0x43,0x95,0xD7, 0x96,0x71}},
 /*P0056*/ {{0x40,0xB9,0x82,0x81,0x8F,0x12,0x81,0xED,0x44,0xA0, 0xBF,0xF9}},
 /*P0064*/ {{0x40,0xD3,0xC2,0x78,0x1F,0x49,0xFF,0xCF,0xA6,0xD5, 0x3C,0xBF}},
 /*P0128*/ {{0x41,0xA8,0x93,0xBA,0x47,0xC9,0x80,0xE9,0x8C,0xE0, 0xC6,0x6F}},
 /*P0192*/ {{0x42,0x7C,0xE0,0x70,0xF7,0x8D,0x39,0x27,0x55,0x6B, 0x85,0xBC}},
 /*P0256*/ {{0x43,0x51,0xAA,0x7E,0xEB,0xFB,0x9D,0xF9,0xDE,0x8E, 0xDD,0xBC}},
 /*P0320*/ {{0x44,0x26,0x81,0x84,0x2F,0x29,0xF2,0xCC,0xE3,0x76, 0xE6,0xA1}},
 /*P0384*/ {{0x44,0xFA,0xC4,0xC5,0xE3,0x10,0xAE,0xF8,0xAA,0x17, 0x10,0x28}},
 /*P0448*/ {{0x45,0xCF,0x95,0x7A,0x4A,0xE1,0xEB,0xF7,0xF3,0xD4, 0xA7,0xEB}},
 /*P0512*/ {{0x46,0xA3,0xE3,0x19,0xA0,0xAE,0xA6,0x0E,0x91,0xC7, 0xCC,0x65}},
 /*P1024*/ {{0x4D,0x48,0xC9,0x76,0x75,0x86,0x81,0x75,0x0C,0x17, 0x65,0x0D}},
 /*P1536*/ {{0x53,0xED,0xB2,0xB8,0x35,0x3B,0x39,0x93,0xA7,0xE4, 0x42,0x58}},
 /*P2048*/ {{0x5A,0x92,0x9E,0x8B,0x3B,0x5D,0xC5,0x3D,0x5D,0xE5, 0xA7,0x4D}},
 /*P2560*/ {{0x61,0x37,0x8C,0xA5,0x54,0xC0,0x20,0xA1,0xF0,0xA6, 0x5D,0xFF}},
 /*P3072*/ {{0x67,0xDB,0xF9,0x89,0x5D,0x25,0xD8,0x8B,0x5A,0x8B, 0xFD,0xD1}},
 /*P3584*/ {{0x6E,0x80,0xDD,0x5D,0xC8,0xA2,0xBF,0x27,0xF3,0xF8, 0x95,0xAA}},
 /*P4096*/ {{0x75,0x25,0xC4,0x60,0x52,0x02,0x8A,0x20,0x97,0x9B, 0xC9,0x4C}}
};

_LDBL12 _pow10neg[] = {
 /*N0001*/ {{0x3F,0xFB,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCD, 0xCC,0xCD}},
 /*N0002*/ {{0x3F,0xF8,0xA3,0xD7,0x0A,0x3D,0x70,0xA3,0xD7,0x0A, 0x3D,0x71}},
 /*N0003*/ {{0x3F,0xF5,0x83,0x12,0x6E,0x97,0x8D,0x4F,0xDF,0x3B, 0x64,0x5A}},
 /*N0004*/ {{0x3F,0xF1,0xD1,0xB7,0x17,0x58,0xE2,0x19,0x65,0x2C, 0xD3,0xC3}},
 /*N0005*/ {{0x3F,0xEE,0xA7,0xC5,0xAC,0x47,0x1B,0x47,0x84,0x23, 0x0F,0xD0}},
 /*N0006*/ {{0x3F,0xEB,0x86,0x37,0xBD,0x05,0xAF,0x6C,0x69,0xB6, 0xA6,0x40}},
 /*N0007*/ {{0x3F,0xE7,0xD6,0xBF,0x94,0xD5,0xE5,0x7A,0x42,0xBC, 0x3D,0x33}},
 /*N0008*/ {{0x3F,0xE4,0xAB,0xCC,0x77,0x11,0x84,0x61,0xCE,0xFD, 0xFD,0xC2}},
 /*N0016*/ {{0x3F,0xC9,0xE6,0x95,0x94,0xBE,0xC4,0x4D,0xE1,0x5B, 0x4C,0x2F}},
 /*N0024*/ {{0x3F,0xAF,0x9A,0xBE,0x14,0xCD,0x44,0x75,0x3B,0x53, 0xC4,0x92}},
 /*N0032*/ {{0x3F,0x94,0xCF,0xB1,0x1E,0xAD,0x45,0x39,0x94,0xBA, 0x67,0xDE}},
 /*N0040*/ {{0x3F,0x7A,0x8B,0x61,0x31,0x3B,0xBA,0xBC,0xE2,0xC6, 0x23,0x24}},
 /*N0048*/ {{0x3F,0x5F,0xBB,0x12,0x7C,0x53,0xB1,0x7E,0xC1,0x59, 0x55,0x61}},
 /*N0056*/ {{0x3F,0x44,0xFB,0x15,0x85,0x92,0xBE,0x06,0x8D,0x2F, 0xEE,0xD7}},
 /*N0064*/ {{0x3F,0x2A,0xA8,0x7F,0xEA,0x27,0xA5,0x39,0xE9,0xA5, 0x3F,0x24}},
 /*N0128*/ {{0x3E,0x55,0xDD,0xD0,0x46,0x7C,0x64,0xBC,0xE4,0xA1, 0xAC,0x7D}},
 /*N0192*/ {{0x3D,0x81,0x91,0xFF,0x83,0x77,0x54,0x23,0xCC,0x06, 0x7B,0x63}},
 /*N0256*/ {{0x3C,0xAC,0xC0,0x31,0x43,0x25,0x63,0x7A,0x19,0x3A, 0xFA,0x91}},
 /*N0320*/ {{0x3B,0xD7,0xFD,0x00,0xB8,0x97,0x47,0x82,0x38,0xD1, 0x89,0x21}},
 /*N0384*/ {{0x3B,0x03,0xA6,0x86,0xE3,0xE8,0xB1,0x1B,0x08,0x58, 0x88,0xDC}},
 /*N0448*/ {{0x3A,0x2E,0xDB,0x37,0x75,0x99,0xB6,0x07,0x42,0x45, 0x84,0xC6}},
 /*N0512*/ {{0x39,0x5A,0x90,0x49,0xEE,0x32,0xDB,0x23,0xD2,0x1C, 0x71,0x33}},
 /*N1024*/ {{0x32,0xB5,0xA2,0xA6,0x82,0xA5,0xDA,0x57,0xC0,0xBE, 0x87,0xA6}},
 /*N1536*/ {{0x2C,0x10,0xB7,0x59,0x44,0x9F,0x52,0xA7,0x11,0xB2, 0x68,0xE2}},
 /*N2048*/ {{0x25,0x6B,0xCE,0xAE,0x53,0x4F,0x34,0x36,0x2D,0xE4, 0x49,0x25}},
 /*N2560*/ {{0x1E,0xC6,0xE8,0xFB,0x7D,0xC2,0xDE,0xC0,0xA4,0x04, 0x59,0x8F}},
 /*N3072*/ {{0x18,0x22,0x83,0x50,0xBF,0x3C,0x91,0x57,0x5A,0x88, 0xE7,0x9E}},
 /*N3584*/ {{0x11,0x7D,0x94,0x06,0xAF,0x8F,0x83,0xFD,0x62,0x65, 0x4B,0x4E}},
 /*N4096*/ {{0x0A,0xD8,0xA6,0xDD,0x04,0xC8,0xD2,0xCE,0x9F,0xDE, 0x2D,0xE4}}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\conv\cfin.c ===
/***
*cfin.c - Encode interface for C
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*
*Revision History:
*       07-20-91  GDP   Ported to C from assembly
*       04-30-92  GDP   use __strgtold12 and _ld12tod
*       06-22-92  GDP   use new __strgtold12 interface
*       04-06-93  SKS   Replace _CALLTYPE* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       10-06-99  PML   Copy a DOUBLE, not double, to avoid exceptions
*
*******************************************************************************/

#include <string.h>
#include <cv.h>


#ifndef _MT
static struct _flt ret;
static FLT flt = &ret;
#endif

/* The only three conditions that this routine detects */
#define CFIN_NODIGITS 512
#define CFIN_OVERFLOW 128
#define CFIN_UNDERFLOW 256

/* This version ignores the last two arguments (radix and scale)
 * Input string should be null terminated
 * len is also ignored
 */
#ifdef _MT
FLT __cdecl _fltin2(FLT flt, const char *str, int len_ignore, int scale_ignore, int radix_ignore)
#else
FLT __cdecl _fltin(const char *str, int len_ignore, int scale_ignore, int radix_ignore)
#endif
{
    _LDBL12 ld12;
    DOUBLE x;
    const char *EndPtr;
    unsigned flags;
    int retflags = 0;

    flags = __strgtold12(&ld12, &EndPtr, str, 0, 0, 0, 0);
    if (flags & SLD_NODIGITS) {
        retflags |= CFIN_NODIGITS;
        *(u_long *)&x = 0;
        *((u_long *)&x+1) = 0;
    }
    else {
        INTRNCVT_STATUS intrncvt;

        intrncvt = _ld12tod(&ld12, &x);

        if (flags & SLD_OVERFLOW  ||
            intrncvt == INTRNCVT_OVERFLOW) {
            retflags |= CFIN_OVERFLOW;
        }
        if (flags & SLD_UNDERFLOW ||
            intrncvt == INTRNCVT_UNDERFLOW) {
            retflags |= CFIN_UNDERFLOW;
        }
    }

    flt->flags = retflags;
    flt->nbytes = (int)(EndPtr - str);
    *(DOUBLE *)&flt->dval = *(DOUBLE *)&x;

    return flt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\conv\cfout.c ===
/***
*cfout.c - Encode interface for C
*
*	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*
*Revision History:
*	07-20-91  GDP	Ported to C from assembly
*	04-30-92  GDP	Added _dtold routine (moved here from ldtod.c)
*	05-14-92  GDP	NDIGITS is now 17 (instead of 16)
*	06-18-92  GDP	Use double instead of DOUBLE to remove C8 warning
*	04-06-93  SKS	Replace _CALLTYPE* with __cdecl
*	09-06-94  CFW	Replace MTHREAD with _MT.
*	09-05-00  GB    Changed the defination of fltout functions. Use DOUBLE 
*	                instead of double
*
*******************************************************************************/


#include <string.h>
#include <cv.h>

#define NDIGITS 17

void __dtold(_LDOUBLE *pld, double *px);


#ifndef _MT
static struct _strflt ret;
static FOS fos;
#endif

#ifdef _MT
STRFLT __cdecl _fltout2(DOUBLE x, STRFLT flt, char *resultstr)
{
    _LDOUBLE ld;
    FOS autofos;

    __dtold(&ld, (double *)&x);
    flt->flag =  $I10_OUTPUT(ld,NDIGITS,0,&autofos);
    flt->sign = autofos.sign;
    flt->decpt = autofos.exp;
    strcpy(resultstr,autofos.man);
    flt->mantissa = resultstr;

    return flt;
}

#else

STRFLT __cdecl _fltout(DOUBLE x)
{
    _LDOUBLE ld;

    __dtold(&ld, (double *)&x);
    ret.flag = $I10_OUTPUT(ld,NDIGITS,0,&fos);
    ret.sign = fos.sign;
    ret.decpt = fos.exp;
    ret.mantissa = fos.man;

    return &ret;
}

#endif




/***
* __dtold -	convert a double into a _LDOUBLE
*
*Purpose:  Use together with i10_output() to get string conversion
*   for double
*
*Entry: double *px
*
*Exit: the corresponding _LDOUBLE value is returned in *pld
*
*Exceptions:
*
*******************************************************************************/

void __dtold(_LDOUBLE *pld, double *px)
{
    u_short exp;
    u_short sign;
    u_long manhi, manlo;
    u_long msb = MSB_ULONG;
    u_short ldexp = 0;

    exp = (*U_SHORT4_D(px) & (u_short)0x7ff0) >> 4;
    sign = *U_SHORT4_D(px) & (u_short)0x8000;
    manhi = *UL_HI_D(px) & 0xfffff;
    manlo = *UL_LO_D(px);

    switch (exp) {
    case D_MAXEXP:
	ldexp = LD_MAXEXP;
	break;
    case 0:
	/* check for zero */
	if (manhi == 0 && manlo == 0) {
	    *UL_MANHI_LD(pld) = 0;
	    *UL_MANLO_LD(pld) = 0;
	    *U_EXP_LD(pld) = 0;
	    return;
	}
	/* we have a denormal -- we'll normalize later */
	ldexp = (u_short) ((s_short)exp - D_BIAS + LD_BIAS + 1);
	msb = 0;
	break;
    default:
	exp -= D_BIAS;
	ldexp = (u_short) ((s_short)exp + LD_BIAS);
	break;
    }

    *UL_MANHI_LD(pld) = msb | manhi << 11 | manlo >> 21;
    *UL_MANLO_LD(pld) = manlo << 11;

    /* normalize if necessary */
    while ((*UL_MANHI_LD(pld) & MSB_ULONG) == 0) {
	/* shift left */
	*UL_MANHI_LD(pld) = *UL_MANHI_LD(pld) << 1 |
			    (MSB_ULONG & *UL_MANLO_LD(pld) ? 1: 0);
	(*UL_MANLO_LD(pld)) <<= 1;
	ldexp --;
    }

    *U_EXP_LD(pld) = sign | ldexp;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\conv\fpinit.c ===
/***
*fpinit.c - Initialize floating point
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*
*Revision History:
*       09-29-91  GDP   merged fpmath.c and fltused.asm to produce this file
*       09-30-91  GDP   per thread initialization and termination hooks
*       03-04-92  GDP   removed finit instruction
*       11-06-92  GDP   added __fastflag for FORTRAN libs
*       03-23-93  JWM   added _setdefaultprecision() to _fpmath()
*       12-09-94  JWM   added __adjust_fdiv for Pentium FDIV detection
*       12-12-94  SKS   _adjust_fdiv must be exported in MSVCRT.LIB model
*       02-06-95  JWM   Mac merge
*       04-04-95  JWM   Clear exceptions after FDIV detection (x86 only).
*       11-15-95  BWT   Assume P5 FDIV problem will be handled in the OS.
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/
#include <cv.h>

#ifdef  _M_IX86
#include <testfdiv.h>
#endif

#if     defined(_AMD64_) || defined(_M_IA64)
#include <trans.h>
#endif

int _fltused = 0x9875;
int _ldused = 0x9873;

int __fastflag = 0;


void  _cfltcvt_init(void);
void  _fpmath(void);
void  _fpclear(void);

#if     defined(_M_AMD64) || defined(_M_IX86) || defined(_M_IA64)

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else
#define _CRTIMP
#endif
#endif

_CRTIMP int _adjust_fdiv = 0;

extern void _setdefaultprecision();
#endif

void  (* _FPinit)(void) = _fpmath;
void  (* _FPmtinit)(void) = _fpclear;
void  (* _FPmtterm)(void) = _fpclear;


void _fpmath()
{

    //
    // There is no need for 'finit'
    // since this is done by the OS
    //

    _cfltcvt_init();

#ifdef  _M_IX86
#ifndef NT_BUILD
    _adjust_fdiv = _ms_p5_mp_test_fdiv();
#endif
    _setdefaultprecision();
    _asm {
        fnclex
    }
#elif   defined(_M_IA64)
/*  _setdefaultprecision(); */
    _clrfp();
#endif

    return;
}

void _fpclear()
{
    //
    // There is no need for 'finit'
    // since this is done by the OS
    //

    return;
}

void _cfltcvt_init()
{
    _cfltcvt_tab[0] = (PFV) _cfltcvt;
    _cfltcvt_tab[1] = (PFV) _cropzeros;
    _cfltcvt_tab[2] = (PFV) _fassign;
    _cfltcvt_tab[3] = (PFV) _forcdecpt;
    _cfltcvt_tab[4] = (PFV) _positive;
    /* map long double to double */
    _cfltcvt_tab[5] = (PFV) _cfltcvt;

}


/*
 * Routine to set the fast flag in order to speed up computation
 * of transcendentals at the expense of limiting error checking
 */

int __setfflag(int new)
{
    int old = __fastflag;
    __fastflag = new;
    return old;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\conv\intrncvt.c ===
/***
* intrncvt.c - internal floating point conversions
*
*	Copyright (c) 1992-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*   All fp string conversion routines use the same core conversion code
*   that converts strings into an internal long double representation
*   with an 80-bit mantissa field. The mantissa is represented
*   as an array (man) of 32-bit unsigned longs, with man[0] holding
*   the high order 32 bits of the mantissa. The binary point is assumed
*   to be between the MSB and MSB-1 of man[0].
*
*   Bits are counted as follows:
*
*
*     +-- binary point
*     |
*     v 		 MSB	       LSB
*   ----------------	 ------------------	 --------------------
*   |0 1    .... 31|	 | 32 33 ...	63|	 | 64 65 ...	  95|
*   ----------------	 ------------------	 --------------------
*
*   man[0]		    man[1]		     man[2]
*
*   This file provides the final conversion routines from this internal
*   form to the single, double, or long double precision floating point
*   format.
*
*   All these functions do not handle NaNs (it is not necessary)
*
*
*Revision History:
*   04-29-92	GDP	written
*   06-18-92	GDP	now ld12told returns INTRNCVT_STATUS
*   06-22-92	GDP	use new __strgtold12 interface (FORTRAN support)
*   10-25-92	GDP	_atoldbl bug fix (cuda 1345): if the mantissa overflows
*			set its MSB to 1)
*   06-08-98	JWM	fixed long-standing off-by-1 error in _RoundMan().
*
*******************************************************************************/


#include <cv.h>


#define INTRNMAN_LEN  3	      /* internal mantissa length in int's */

//
//  internal mantissaa representation
//  for string conversion routines
//

typedef u_long *intrnman;


typedef struct {
   int max_exp;      // maximum base 2 exponent (reserved for special values)
   int min_exp;      // minimum base 2 exponent (reserved for denormals)
   int precision;    // bits of precision carried in the mantissa
   int exp_width;    // number of bits for exponent
   int format_width; // format width in bits
   int bias;	     // exponent bias
} FpFormatDescriptor;



static FpFormatDescriptor
DoubleFormat = {
    0x7ff - 0x3ff,  //	1024, maximum base 2 exponent (reserved for special values)
    0x0   - 0x3ff,  // -1023, minimum base 2 exponent (reserved for denormals)
    53, 	    // bits of precision carried in the mantissa
    11, 	    // number of bits for exponent
    64, 	    // format width in bits
    0x3ff,	    // exponent bias
};

static FpFormatDescriptor
FloatFormat = {
    0xff - 0x7f,    //	128, maximum base 2 exponent (reserved for special values)
    0x0  - 0x7f,    // -127, minimum base 2 exponent (reserved for denormals)
    24, 	    // bits of precision carried in the mantissa
    8,		    // number of bits for exponent
    32, 	    // format width in bits
    0x7f,	    // exponent bias
};



//
// function prototypes
//

int _RoundMan (intrnman man, int nbit);
int _ZeroTail (intrnman man, int nbit);
int _IncMan (intrnman man, int nbit);
void _CopyMan (intrnman dest, intrnman src);
void _CopyMan (intrnman dest, intrnman src);
void _FillZeroMan(intrnman man);
void _Shrman (intrnman man, int n);

INTRNCVT_STATUS _ld12cvt(_LDBL12 *pld12, void *d, FpFormatDescriptor *format);

/***
* _ZeroTail - check if a mantissa ends in 0's
*
*Purpose:
*   Return TRUE if all mantissa bits after nbit (including nbit) are 0,
*   otherwise return FALSE
*
*
*Entry:
*   man: mantissa
*   nbit: order of bit where the tail begins
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
int _ZeroTail (intrnman man, int nbit)
{
    int nl = nbit / 32;
    int nb = 31 - nbit % 32;


    //
    //		     |<---- tail to be checked --->
    //
    //	--  ------------------------	       ----
    //	|...	|		  |  ...	  |
    //	--  ------------------------	       ----
    //	^	^    ^
    //	|	|    |<----nb----->
    //	man	nl   nbit
    //



    u_long bitmask = ~(MAX_ULONG << nb);

    if (man[nl] & bitmask)
	return 0;

    nl++;

    for (;nl < INTRNMAN_LEN; nl++)
	if (man[nl])
	    return 0;

    return 1;
}




/***
* _IncMan - increment mantissa
*
*Purpose:
*
*
*Entry:
*   man: mantissa in internal long form
*   nbit: order of bit that specifies the end of the part to be incremented
*
*Exit:
*   returns 1 on overflow, 0 otherwise
*
*Exceptions:
*
*******************************************************************************/

int _IncMan (intrnman man, int nbit)
{
    int nl = nbit / 32;
    int nb = 31 - nbit % 32;

    //
    //	|<--- part to be incremented -->|
    //
    //	--	       ---------------------------     ----
    //	|...		  |			|   ...	  |
    //	--	       ---------------------------     ----
    //	^		  ^		^
    //	|		  |		|<--nb-->
    //	man		  nl		nbit
    //

    u_long one = (u_long) 1 << nb;
    int carry;

    carry = __addl(man[nl], one, &man[nl]);

    nl--;

    for (; nl >= 0 && carry; nl--) {
	carry = (u_long) __addl(man[nl], (u_long) 1, &man[nl]);
    }

    return carry;
}




/***
* _RoundMan -  round mantissa
*
*Purpose:
*   round mantissa to nbit precision
*
*
*Entry:
*   man: mantissa in internal form
*   precision: number of bits to be kept after rounding
*
*Exit:
*   returns 1 on overflow, 0 otherwise
*
*Exceptions:
*
*******************************************************************************/

int _RoundMan (intrnman man, int precision)
{
    int i,rndbit,nl,nb;
    u_long rndmask;
    int nbit;
    int retval = 0;

    //
    // The order of the n'th bit is n-1, since the first bit is bit 0
    // therefore decrement precision to get the order of the last bit
    // to be kept
    //
    nbit = precision - 1;

    rndbit = nbit+1;

    nl = rndbit / 32;
    nb = 31 - rndbit % 32;

    //
    // Get value of round bit
    //

    rndmask = (u_long)1 << nb;

    if ((man[nl] & rndmask) &&
	 !_ZeroTail(man, rndbit)) {

	//
	// round up
	//

	retval = _IncMan(man, nbit);
    }


    //
    // fill rest of mantissa with zeroes
    //

    man[nl] &= MAX_ULONG << nb;
    for(i=nl+1; i<INTRNMAN_LEN; i++) {
	man[i] = (u_long)0;
    }

    return retval;
}


/***
* _CopyMan - copy mantissa
*
*Purpose:
*    copy src to dest
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
void _CopyMan (intrnman dest, intrnman src)
{
    u_long *p, *q;
    int i;

    p = src;
    q = dest;

    for (i=0; i < INTRNMAN_LEN; i++) {
	*q++ = *p++;
    }
}



/***
* _FillZeroMan - fill mantissa with zeroes
*
*Purpose:
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
void _FillZeroMan(intrnman man)
{
    int i;
    for (i=0; i < INTRNMAN_LEN; i++)
	man[i] = (u_long)0;
}



/***
* _IsZeroMan - check if mantissa is zero
*
*Purpose:
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
int _IsZeroMan(intrnman man)
{
    int i;
    for (i=0; i < INTRNMAN_LEN; i++)
	if (man[i])
	    return 0;

    return 1;
}





/***
* _ShrMan - shift mantissa to the right
*
*Purpose:
*  shift man by n bits to the right
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
void _ShrMan (intrnman man, int n)
{
    int i, n1, n2, mask;
    int carry_from_left;

    //
    // declare this as volatile in order to work around a C8
    // optimization bug
    //

    volatile int carry_to_right;

    n1 = n / 32;
    n2 = n % 32;

    mask = ~(MAX_ULONG << n2);


    //
    // first deal with shifts by less than 32 bits
    //

    carry_from_left = 0;
    for (i=0; i<INTRNMAN_LEN; i++) {

	carry_to_right = man[i] & mask;

	man[i] >>= n2;

	man[i] |= carry_from_left;

	carry_from_left = carry_to_right << (32 - n2);
    }


    //
    // now shift whole 32-bit ints
    //

    for (i=INTRNMAN_LEN-1; i>=0; i--) {
	if (i >= n1) {
	    man[i] = man[i-n1];
	}
	else {
	    man[i] = 0;
	}
    }
}




/***
* _ld12tocvt - _LDBL12 floating point conversion
*
*Purpose:
*   convert a internal _LBL12 structure into an IEEE floating point
*   representation
*
*
*Entry:
*   pld12:  pointer to the _LDBL12
*   format: pointer to the format descriptor structure
*
*Exit:
*   *d contains the IEEE representation
*   returns the INTRNCVT_STATUS
*
*Exceptions:
*
*******************************************************************************/
INTRNCVT_STATUS _ld12cvt(_LDBL12 *pld12, void *d, FpFormatDescriptor *format)
{
    u_long man[INTRNMAN_LEN];
    u_long saved_man[INTRNMAN_LEN];
    u_long msw;
    unsigned int bexp;			// biased exponent
    int exp_shift;
    int exponent, sign;
    INTRNCVT_STATUS retval;

    exponent = (*U_EXP_12(pld12) & 0x7fff) - 0x3fff;   // unbias exponent
    sign = *U_EXP_12(pld12) & 0x8000;


    man[0] = *UL_MANHI_12(pld12);
    man[1] = *UL_MANLO_12(pld12);
    man[2] = *U_XT_12(pld12) << 16;


    //
    // bexp is the final biased value of the exponent to be used
    // Each of the following blocks should provide appropriate
    // values for man, bexp and retval. The mantissa is also
    // shifted to the right, leaving space for the exponent
    // and sign to be inserted
    //

    if (exponent == 0 - 0x3fff) {

	// either a denormal or zero
	bexp = 0;

	if (_IsZeroMan(man)) {

	    retval = INTRNCVT_OK;
	}
	else {

	    _FillZeroMan(man);

	    // denormal has been flushed to zero

	    retval = INTRNCVT_UNDERFLOW;
	}
    }
    else {

	// save mantissa in case it needs to be rounded again
	// at a different point (e.g., if the result is a denormal)

	_CopyMan(saved_man, man);

	if (_RoundMan(man, format->precision)) {
	    exponent ++;
	}

	if (exponent < format->min_exp - format->precision ) {

	    //
	    // underflow that produces a zero
	    //

	    _FillZeroMan(man);
	    bexp = 0;
	    retval = INTRNCVT_UNDERFLOW;
	}

	else if (exponent <= format->min_exp) {

	    //
	    // underflow that produces a denormal
	    //
	    //

	    // The (unbiased) exponent will be MIN_EXP
	    // Find out how much the mantissa should be shifted
	    // One shift is done implicitly by moving the
	    // binary point one bit to the left, i.e.,
	    // we treat the mantissa as .ddddd instead of d.dddd
	    // (where d is a binary digit)

	    int shift = format->min_exp - exponent;

	    // The mantissa should be rounded again, so it
	    // has to be restored

	    _CopyMan(man,saved_man);

	    _ShrMan(man, shift);
	    _RoundMan(man, format->precision); // need not check for carry

	    // make room for the exponent + sign

	    _ShrMan(man, format->exp_width + 1);

	    bexp = 0;
	    retval = INTRNCVT_UNDERFLOW;

	}

	else if (exponent >= format->max_exp) {

	    //
	    // overflow, return infinity
	    //

	    _FillZeroMan(man);
	    man[0] |= (1 << 31); // set MSB

	    // make room for the exponent + sign

	    _ShrMan(man, (format->exp_width + 1) - 1);

	    bexp = format->max_exp + format->bias;

	    retval = INTRNCVT_OVERFLOW;
	}

	else {

	    //
	    // valid, normalized result
	    //

	    bexp = exponent + format->bias;


	    // clear implied bit

	    man[0] &= (~( 1 << 31));

	    //
	    // shift right to make room for exponent + sign
	    //

	    _ShrMan(man, (format->exp_width + 1) - 1);

	    retval = INTRNCVT_OK;

	}
    }


    exp_shift = 32 - (format->exp_width + 1);
    msw =  man[0] |
	   (bexp << exp_shift) |
	   (sign ? 1<<31 : 0);

    if (format->format_width == 64) {

	*UL_HI_D(d) = msw;
	*UL_LO_D(d) = man[1];
    }

    else if (format->format_width == 32) {

	*(u_long *)d = msw;

    }

    return retval;
}


/***
* _ld12tod - convert _LDBL12 to double
*
*Purpose:
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
INTRNCVT_STATUS _ld12tod(_LDBL12 *pld12, DOUBLE *d)
{
    return _ld12cvt(pld12, d, &DoubleFormat);
}



/***
* _ld12tof - convert _LDBL12 to float
*
*Purpose:
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
INTRNCVT_STATUS _ld12tof(_LDBL12 *pld12, FLOAT *f)
{
    return _ld12cvt(pld12, f, &FloatFormat);
}


/***
* _ld12told - convert _LDBL12 to 80 bit long double
*
*Purpose:
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
INTRNCVT_STATUS _ld12told(_LDBL12 *pld12, _LDOUBLE *pld)
{

    //
    // This implementation is based on the fact that the _LDBL12 format is
    // identical to the long double and has 2 extra bytes of mantissa
    //

    u_short exp, sign;
    u_long man[INTRNMAN_LEN];
    INTRNCVT_STATUS retval = 0;

    exp = *U_EXP_12(pld12) & (u_short)0x7fff;
    sign = *U_EXP_12(pld12) & (u_short)0x8000;

    man[0] = *UL_MANHI_12(pld12);
    man[1] = *UL_MANLO_12(pld12);
    man[2] = *U_XT_12(pld12) << 16;

    if (_RoundMan(man, 64)) {
	// The MSB of the mantissa is explicit and should be 1
	// since we had a carry, the mantissa is now 0.
	man[0] = MSB_ULONG;
	exp ++;
    }

    if (exp == 0x7fff)
	retval = INTRNCVT_OVERFLOW;

    *UL_MANHI_LD(pld) = man[0];
    *UL_MANLO_LD(pld) = man[1];
    *U_EXP_LD(pld) = sign | exp;

    return retval;
}


void _atodbl(DOUBLE *d, char *str)
{
    const char *EndPtr;
    _LDBL12 ld12;

    __strgtold12(&ld12, &EndPtr, str, 0, 0, 0, 0 );
    _ld12tod(&ld12, d);
}


void _atoldbl(_LDOUBLE *ld, char *str)
{
    const char *EndPtr;
    _LDBL12 ld12;

    __strgtold12(&ld12, &EndPtr, str, 1, 0, 0, 0 );
    _ld12told(&ld12, ld);
}


void _atoflt(FLOAT *f, char *str)
{
    const char *EndPtr;
    _LDBL12 ld12;

    __strgtold12(&ld12, &EndPtr, str, 0, 0, 0, 0 );
    _ld12tof(&ld12, f);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\conv\fltinf.c ===
/***
*fltinf.c - Encode interface for FORTRAN
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       FORTRAN interface for decimal to binary (input) conversion
*
*Revision History:
*       06-22-92  GDP   Modified version of cfin.c for FORTRAN support
*       04-06-93  SKS   Replace _CALLTYPE* with __cdecl
*       10-06-99  PML   Copy a DOUBLE, not double, to avoid exceptions
*
*******************************************************************************/

#include <string.h>
#include <cv.h>

static struct _flt ret;
static FLT flt = &ret;

/* Error codes set by this routine */
#define CFIN_NODIGITS 512
#define CFIN_OVERFLOW 128
#define CFIN_UNDERFLOW 256
#define CFIN_INVALID  64

FLT __cdecl _fltinf(const char *str, int len, int scale, int decpt)
{
    _LDBL12 ld12;
    DOUBLE x;
    const char *EndPtr;
    unsigned flags;
    int retflags = 0;

    flags = __strgtold12(&ld12, &EndPtr, str, 0, scale, decpt, 1);
    if (flags & SLD_NODIGITS) {
        retflags |= CFIN_NODIGITS;
        *(u_long *)&x = 0;
        *((u_long *)&x+1) = 0;
    }
    else {
        INTRNCVT_STATUS intrncvt;

        intrncvt = _ld12tod(&ld12, &x);

        if (flags & SLD_OVERFLOW  ||
            intrncvt == INTRNCVT_OVERFLOW) {
            retflags |= CFIN_OVERFLOW;
        }
        if (flags & SLD_UNDERFLOW ||
            intrncvt == INTRNCVT_UNDERFLOW) {
            retflags |= CFIN_UNDERFLOW;
        }
    }

    flt->nbytes = (int)(EndPtr - str);
    if (len != flt->nbytes)
        retflags |= CFIN_INVALID;
    *(DOUBLE *)&flt->dval = *(DOUBLE *)&x;
    flt->flags = retflags;

    return flt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\conv\cvt.c ===
/*** 
*cvt.c - C floating-point output conversions
*
*	Copyright (c) 1983-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	contains routines for performing %e, %f, and %g output conversions
*	for printf, etc.
*
*	routines include _cfltcvt(), _cftoe(), _cftof(), _cftog(),
*			 _fassign(), _positive(), _cropzeros(), _forcdecpt()
*
*Revision History:
*	04-18-84  RN	author
*	01-15-87  BCM	corrected processing of %g formats (to handle precision
*			as the maximum number of signifcant digits displayed)
*	03-24-87  BCM	Evaluation Issues: (fccvt.obj version for ?LIBFA)
*			------------------
*			SDS - no problem
*			GD/TS :
*				char g_fmt = 0; 		(local,   initialized)
*				int g_magnitude =0;		(local,   initialized)
*				char g_round_expansion = 0;	(local,   initialized)
*				STRFLT g_pflt;				(local, uninitialized)
*			other INIT :
*			ALTMATH __fpmath() initialization (perhaps)
*			TERM - nothing
*	10-22-87  BCM	changes for OS/2 Support Library -
*				    including elimination of g_... static variables
*				    in favor of stack-based variables & function arguments
*				    under MTHREAD switch;  changed interfaces to _cfto? routines
*	01-15-88  BCM	remove IBMC20 switches; use only memmove, not memcpy;
*				    use just MTHREAD switch, not SS_NEQ_DGROUP
*	06-13-88  WAJ	Fixed %.1g processing for small x
*	08-02-88  WAJ	Made changes to _fassign() for new input().
*	03-09-89  WAJ	Added some long double support.
*	06-05-89  WAJ	Made changes for C6. LDOUBLE => long double
*	06-12-89  WAJ	Renamed this file from cvtn.c to cvt.c
*	11-02-89  WAJ	Removed register.h
*	06-28-90  WAJ	Removed fars.
*	11-15-90  WAJ	Added _cdecl where needed. Also "pascal" => "_pascal".
*	09-12-91  GDP	_cdecl=>_CALLTYPE2 _pascal=>_CALLTYPE5 near=>_NEAR
*	04-30-92  GDP	Removed floating point code. Instead used S/W routines
*			(_atodbl, _atoflt _atoldbl), so that to avoid
*			generation of IEEE exceptions from the lib code.
*	03-11-93  JWM	Added minimal support for _INTL decimal point - one byte only!
*	04-06-93  SKS	Replace _CALLTYPE* with __cdecl
*	07-16-93  SRW	ALPHA Merge
*	11-15-93  GJF	Merged in NT SDK version ("ALPHA merge" stuff). Also,
*			dropped support of Alpha acc compier, replaced i386
*			with _M_IX86, replaced MTHREAD with _MT.
*	09-06-94  CFW	Remove _INTL switch.
*	09-05-00  GB    Changed the defination of fltout functions. Use DOUBLE 
*	                instead of double
*
*******************************************************************************/

#include <ctype.h>
#include <string.h>
#include <math.h>
#include <cv.h>
#include <nlsint.h>

#ifdef	_M_IX86
/* Uncomment this for enabling 10-byte long double string conversions */
/* #define LONG_DOUBLE */
#endif


/* this routine resides in the crt32 tree */
extern void _fptostr(char *buf, int digits, STRFLT pflt);


static void _CALLTYPE5 _shift( char *s, int dist );

#ifdef	_MT
    static char * _cftoe2( char * buf, int ndec, int caps, STRFLT pflt, char g_fmt );
    static char * _cftof2( char * buf, int ndec, STRFLT pflt, char g_fmt );

#else	/* not _MT */
    static char * _cftoe_g( double * pvalue, char * buf, int ndec, int caps );
    static char * _cftof_g( double * pvalue, char * buf, int ndec );
#endif	/* not _MT */

/*** 
*_forcdecpt(buffer) - force a decimal point in floating-point output
*Purpose:
*  	force a decimal point in floating point output. we are only called if '#'
*  	flag is given and precision is 0; so we know the number has no '.'. insert
*  	the '.' and move everybody else back one position, until '\0' seen
*
* 	side effects: futzes around with the buffer, trying to insert a '.' 
*	after the initial string of digits. the first char can usually be 
*   skipped since it will be a digit or a '-'.  but in the 0-precision case, 
* 	the number could start with 'e' or 'E', so we'd want the '.' before the 
*	exponent in that case.
*
*Entry:
*	buffer = (char *) pointer to buffer to modify
*
*Exit:
*	returns : (void)
*
*Exceptions:
*******************************************************************************/

void __cdecl _forcdecpt( char * buffer )
{
char	holdchar;
char	nextchar;

    if (tolower(*buffer) != 'e'){
	do {
	    buffer++;
	    }
	while (isdigit(*buffer));
	}

    holdchar = *buffer;
    
	*buffer++ = *__decimal_point;

    do	{
	nextchar = *buffer;
	*buffer = holdchar;
	holdchar = nextchar;
	}

    while(*buffer++);
}


/*** 
*_cropzeros(buffer) - removes trailing zeros from floating-point output
*Purpose:
*	removes trailing zeros (after the '.') from floating-point output;
*	called only when we're doing %g format, there's no '#' flag, and 
*	precision is non-zero.  plays around with the buffer, looking for
*	trailing zeros.  when we find them, then we move everbody else forward
*	so they overlay the zeros.  if we eliminate the entire fraction part,
*	then we overlay the decimal point ('.'), too.	
*
* 	side effects: changes the buffer from
*   	[-] digit [digit...] [ . [digits...] [0...] ] [(exponent part)]
*	to
*		[-] digit [digit...] [ . digit [digits...] ] [(exponent part)]
*	or
*   	[-] digit [digit...] [(exponent part)]
*
*Entry:
*	buffer = (char *) pointer to buffer to modify
*
*Exit:
*	returns : (void)
*
*Exceptions:
*******************************************************************************/

void __cdecl _cropzeros( char * buf )
{
char	*stop;

    while (*buf && *buf != *__decimal_point)
	buf++;

    if (*buf++) {
	while (*buf && *buf != 'e' && *buf != 'E')
	    buf++;

	stop = buf--;

	while (*buf == '0')
	    buf--;

	if (*buf == *__decimal_point)
	    buf--;

	while( (*++buf = *stop++) != '\0' );
	}
}


int __cdecl _positive( double * arg )
{
    return( (*arg >= 0.0) );
}


void  __cdecl _fassign( int flag, char * argument, char * number )
{

    FLOAT floattemp;
    DOUBLE doubletemp;

#ifdef	LONG_DOUBLE

    _LDOUBLE longtemp;

    switch( flag ){
	case 2:
	    _atoldbl( &longtemp, number );
	    *(_LDOUBLE UNALIGNED *)argument = longtemp;
	    break;

	case 1:
	    _atodbl( &doubletemp, number );
	    *(DOUBLE UNALIGNED *)argument = doubletemp;
	    break;

	default:
	    _atoflt( &floattemp, number );
	    *(FLOAT UNALIGNED *)argument = floattemp;
	}

#else	/* not LONG_DOUBLE */

    if (flag) {
	_atodbl( &doubletemp, number );
	*(DOUBLE UNALIGNED *)argument = doubletemp;
    } else {
	_atoflt( &floattemp, number );
	*(FLOAT UNALIGNED *)argument = floattemp;
    }

#endif	/* not LONG_DOUBLE */
}


#ifndef _MT
    static char   g_fmt = 0;
    static int	  g_magnitude = 0;
    static char   g_round_expansion = 0;
    static STRFLT g_pflt;
#endif


/*
 *  Function name:  _cftoe
 *
 *  Arguments:	    pvalue -  double * pointer
 *		    buf    -  char * pointer
 *		    ndec   -  int
 *		    caps   -  int
 *
 *  Description:    _cftoe converts the double pointed to by pvalue to a null
 *		    terminated string of ASCII digits in the c language
 *		    printf %e format, nad returns a pointer to the result.
 *		    This format has the form [-]d.ddde(+/-)ddd, where there
 *		    will be ndec digits following the decimal point.  If
 *		    ndec <= 0, no decimal point will appear.  The low order
 *		    digit is rounded.  If caps is nonzero then the exponent
 *		    will appear as E(+/-)ddd.
 *
 *  Side Effects:   the buffer 'buf' is assumed to have a minimum length
 *		    of CVTBUFSIZE (defined in cvt.h) and the routines will
 *		    not write over this size.
 *
 *  Author:	    written  R.K. Wyss, Microsoft,  Sept. 9, 1983
 *
 *  History:
 *
 */

#ifdef _MT
    static char * _cftoe2( char * buf, int ndec, int caps, STRFLT pflt, char g_fmt )
#else
    char * __cdecl _cftoe( double * pvalue, char * buf, int ndec, int caps )
#endif
{
#ifndef _MT
    STRFLT pflt;
    DOUBLE *pdvalue = (DOUBLE *)pvalue;
#endif

char	*p;
int	exp;

    /* first convert the value */

    /* place the output in the buffer and round.  Leave space in the buffer
     * for the '-' sign (if any) and the decimal point (if any)
     */

    if (g_fmt) {
#ifndef _MT
	pflt = g_pflt;
#endif
	/* shift it right one place if nec. for decimal point */

	p = buf + (pflt->sign == '-');
	_shift(p, (ndec > 0));
		}
#ifndef _MT
    else {
	pflt = _fltout(*pdvalue);
	_fptostr(buf + (pflt->sign == '-') + (ndec > 0), ndec + 1, pflt);
	}
#endif


    /* now fix the number up to be in e format */

    p = buf;

    /* put in negative sign if needed */

    if (pflt->sign == '-')
	*p++ = '-';

    /* put in decimal point if needed.	Copy the first digit to the place
     * left for it and put the decimal point in its place
     */

    if (ndec > 0) {
	*p = *(p+1);
	*(++p) = *__decimal_point;
	}

    /* find the end of the string and attach the exponent field */

    p = strcpy(p+ndec+(!g_fmt), "e+000");

    /* adjust exponent indicator according to caps flag and increment
     * pointer to point to exponent sign
     */

    if (caps)
	*p = 'E';

    p++;

    /* if mantissa is zero, then the number is 0 and we are done; otherwise
     * adjust the exponent sign (if necessary) and value.
     */

    if (*pflt->mantissa != '0') {

	/* check to see if exponent is negative; if so adjust exponent sign and
	 * exponent value.
	 */

	if( (exp = pflt->decpt - 1) < 0 ) {
	    exp = -exp;
	    *p = '-';
	    }

	p++;

	if (exp >= 100) {
	    *p += (char)(exp / 100);
	    exp %= 100;
	    }
	p++;

	if (exp >= 10) {
	    *p += (char)(exp / 10);
	    exp %= 10;
	    }

	*++p += (char)exp;
	}

    return(buf);
}


#ifdef _MT

char * __cdecl _cftoe( double * pvalue, char * buf, int ndec, int caps )
{
struct _strflt retstrflt;
char  resstr[21];
DOUBLE *pdvalue = (DOUBLE *)pvalue;
STRFLT pflt = &retstrflt;

    _fltout2(*pdvalue, (struct _strflt *)&retstrflt,
	      (char *)resstr);
    _fptostr(buf + (pflt->sign == '-') + (ndec > 0), ndec + 1, pflt);
    _cftoe2(buf, ndec, caps, pflt, /* g_fmt = */ 0);

    return( buf );
}

#else	/* not _MT */

static char * _cftoe_g( double * pvalue, char * buf, int ndec, int caps )
{
    char *res;
    g_fmt = 1;
    res = _cftoe(pvalue, buf, ndec, caps);
    g_fmt = 0;
    return (res);
}

#endif	/* not _MT */


#ifdef _MT
static char * _cftof2( char * buf, int ndec, STRFLT pflt, char g_fmt )

#else
char * __cdecl _cftof( double * pvalue, char * buf, int ndec )
#endif

{
#ifndef _MT
STRFLT pflt;
DOUBLE *pdvalue = (DOUBLE *)pvalue;
#endif

char	*p;

#ifdef _MT
int	g_magnitude = pflt->decpt - 1;
#endif


    /* first convert the value */

    /* place the output in the users buffer and round.	Save space for
     * the minus sign now if it will be needed
     */

    if (g_fmt) {
#ifndef _MT
	pflt = g_pflt;
#endif

	p = buf + (pflt->sign == '-');
	if (g_magnitude == ndec) {
	    char *q = p + g_magnitude;
	    *q++ = '0';
	    *q = '\0';
	    /* allows for extra place-holding '0' in the exponent == precision
	     * case of the g format
	     */
	    }
	}
#ifndef _MT
    else {
	pflt = _fltout(*pdvalue);
	_fptostr(buf+(pflt->sign == '-'), ndec + pflt->decpt, pflt);
	}
#endif


    /* now fix up the number to be in the correct f format */

    p = buf;

    /* put in negative sign, if necessary */

    if (pflt->sign == '-')
	*p++ = '-';

    /* insert leading 0 for purely fractional values and position ourselves
     * at the correct spot for inserting the decimal point
     */

    if (pflt->decpt <= 0) {
	_shift(p, 1);
	*p++ = '0';
	}
    else
	p += pflt->decpt;

	/* put in decimal point if required and any zero padding needed */

    if (ndec > 0) {
	_shift(p, 1);
	*p++ = *__decimal_point;

	/* if the value is less than 1 then we may need to put 0's out in
	 * front of the first non-zero digit of the mantissa
	 */

	if (pflt->decpt < 0) {
	    if( g_fmt )
		ndec = -pflt->decpt;
	    else
		ndec = (ndec < -pflt->decpt ) ? ndec : -pflt->decpt;
	    _shift(p, ndec);
	    memset( p, '0', ndec);
	    }
	}

    return( buf);
}


/*
 *  Function name:  _cftof
 *
 *  Arguments:	    value  -  double * pointer
 *		    buf    -  char * pointer
 *		    ndec   -  int
 *
 *  Description:    _cftof converts the double pointed to by pvalue to a null
 *		    terminated string of ASCII digits in the c language
 *		    printf %f format, and returns a pointer to the result.
 *		    This format has the form [-]ddddd.ddddd, where there will
 *		    be ndec digits following the decimal point.  If ndec <= 0,
 *		    no decimal point will appear.  The low order digit is
 *		    rounded.
 *
 *  Side Effects:   the buffer 'buf' is assumed to have a minimum length
 *		    of CVTBUFSIZE (defined in cvt.h) and the routines will
 *		    not write over this size.
 *
 *  Author:	    written  R.K. Wyss, Microsoft,  Sept. 9, 1983
 *
 *  History:
 *
 */

#ifdef _MT

char * __cdecl _cftof( double * pvalue, char * buf, int ndec )
{
    struct _strflt retstrflt;
    char  resstr[21];
    DOUBLE *pdvalue = (DOUBLE *)pvalue;
    STRFLT pflt = &retstrflt;
    _fltout2(*pdvalue, (struct _strflt *) &retstrflt,
				      (char *) resstr);
    _fptostr(buf+(pflt->sign == '-'), ndec + pflt->decpt, pflt);
    _cftof2(buf, ndec, pflt, /* g_fmt = */ 0);

    return( buf );
}

#else	/* not _MT */


static char * _cftof_g( double * pvalue, char * buf, int ndec )
{
    char *res;
    g_fmt = 1;
    res = _cftof(pvalue, buf, ndec);
    g_fmt = 0;
    return (res);
}

#endif	/* not _MT */

/*
 *  Function name:  _cftog
 *
 *  Arguments:	    value  -  double * pointer
 *		    buf    -  char * pointer
 *		    ndec   -  int
 *
 *  Description:    _cftog converts the double pointed to by pvalue to a null
 *		    terminated string of ASCII digits in the c language
 *		    printf %g format, and returns a pointer to the result.
 *		    The form used depends on the value converted.  The printf
 *		    %e form will be used if the magnitude of valude is less
 *		    than -4 or is greater than ndec, otherwise printf %f will
 *		    be used.  ndec always specifies the number of digits
 *		    following the decimal point.  The low order digit is
 *		    appropriately rounded.
 *
 *  Side Effects:   the buffer 'buf' is assumed to have a minimum length
 *		    of CVTBUFSIZE (defined in cvt.h) and the routines will
 *		    not write over this size.
 *
 *  Author:	    written  R.K. Wyss, Microsoft,  Sept. 9, 1983
 *
 *  History:
 *
 */

char * __cdecl _cftog( double * pvalue, char * buf, int ndec, int caps )
{
char *p;
DOUBLE *pdvalue = (DOUBLE *)pvalue;

#ifdef _MT
char g_round_expansion = 0;
STRFLT g_pflt;
int g_magnitude;
struct _strflt retstrflt;
char  resstr[21];

    /* first convert the number */

    g_pflt = &retstrflt;
    _fltout2(*pdvalue, (struct _strflt *)&retstrflt,
		  (char *)resstr);

#else	/* not _MT */

    /* first convert the number */

    g_pflt = _fltout(*pdvalue);
#endif	/* not _MT */

    g_magnitude = g_pflt->decpt - 1;
    p = buf + (g_pflt->sign == '-');

    _fptostr(p, ndec, g_pflt);
    g_round_expansion = (char)(g_magnitude < (g_pflt->decpt-1));


    /* compute the magnitude of value */

    g_magnitude = g_pflt->decpt - 1;

    /* convert value to the c language g format */

    if (g_magnitude < -4 || g_magnitude >= ndec){     /* use e format */
	/*  (g_round_expansion ==>
	 *  extra digit will be overwritten by 'e+xxx')
	 */

#ifdef _MT
	return(_cftoe2(buf, ndec, caps, g_pflt, /* g_fmt = */ 1));
#else
	return(_cftoe_g(pvalue, buf, ndec, caps));
#endif

	}
    else {										     /* use f format */
	if (g_round_expansion) {
	    /* throw away extra final digit from expansion */
	    while (*p++);
	    *(p-2) = '\0';
	    }

#ifdef _MT
	return(_cftof2(buf, ndec, g_pflt, /* g_fmt = */ 1));
#else
	return(_cftof_g(pvalue, buf, ndec));
#endif

	}
}

/*** 
*_cfltcvt(arg, buf, format, precision, caps) - convert floating-point output
*Purpose:
*
*Entry:
*	arg = (double *) pointer to double-precision floating-point number 
*	buf = (char *) pointer to buffer into which to put the converted
*				   ASCII form of the number
*	format = (int) 'e', 'f', or 'g'
*	precision = (int) giving number of decimal places for %e and %f formats,
*					  and giving maximum number of significant digits for
*					  %g format
*	caps = (int) flag indicating whether 'E' in exponent should be capatilized
*				 (for %E and %G formats only)
*	
*Exit:
*	returns : (void)
*
*Exceptions:
*******************************************************************************/
/*
 *  Function name:  _cfltcvt
 *
 *  Arguments:	    arg    -  double * pointer
 *		    buf    -  char * pointer
 *					format -  int
 *		    ndec   -  int
 *		    caps   -  int
 *
 *  Description:    _cfltcvt determines from the format, what routines to
 *		    call to generate the correct floating point format
 *
 *  Side Effects:   none
 *
 *	Author: 	   Dave Weil, Jan 12, 1985
 */

void __cdecl _cfltcvt( double * arg, char * buffer, int format, int precision, int caps )
{
    if (format == 'e' || format == 'E')
	_cftoe(arg, buffer, precision, caps);
    else if (format == 'f')
	_cftof(arg, buffer, precision);
    else
	_cftog(arg, buffer, precision, caps);
}

/*** 
*_shift(s, dist) - shift a null-terminated string in memory (internal routine)
*Purpose:
*	_shift is a helper routine that shifts a null-terminated string 
*	in memory, e.g., moves part of a buffer used for floating-point output
*
*	modifies memory locations (s+dist) through (s+dist+strlen(s))
*
*Entry:
*	s = (char *) pointer to string to move
*	dist = (int) distance to move the string to the right (if negative, to left)
*
*Exit:
*	returns : (void)
*
*Exceptions:
*******************************************************************************/

static void _CALLTYPE5 _shift( char *s, int dist )
{
    if( dist )
	memmove(s+dist, s, strlen(s)+1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\conv\mantold.c ===
/***
*mantold.c - conversion of a decimal mantissa to _LDBL12
*
*	Copyright (c) 1991-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*   Conversion of a decimal mantissa into _LDBL12 format (i.e. long
*   double with two additional bytes of significand)
*
*Revision History:
*   7-17-91	GDP	Initial version (ported from assembly)
*
*******************************************************************************/

#include <cv.h>





/***
*int _CALLTYPE5 __addl(u_long x, u_long y, u_long *sum) - u_long addition
*
*Purpose: add two u_long numbers and return carry
*
*Entry: u_long x, u_long y : the numbers to be added
*	u_long *sum : where to store the result
*
*Exit: *sum receives the value of x+y
*      the value of the carry is returned
*
*Exceptions:
*
*******************************************************************************/

int _CALLTYPE5 __addl(u_long x, u_long y, u_long *sum)
{
    u_long r;
    int carry=0;
    r = x+y;
    if (r < x || r < y)
	carry++;
    *sum = r;
    return carry;
}






/***
*void _CALLTYPE5 __add_12(_LDBL12 *x, _LDBL12 *y) -	_LDBL12 addition
*
*Purpose: add two _LDBL12 numbers. The numbers are added
*   as 12-byte integers. Overflow is ignored.
*
*Entry: x,y: pointers to the operands
*
*Exit: *x receives the sum
*
*Exceptions:
*
*******************************************************************************/

void _CALLTYPE5 __add_12(_LDBL12 *x, _LDBL12 *y)
{
    int c0,c1,c2;
    c0 = __addl(*UL_LO_12(x),*UL_LO_12(y),UL_LO_12(x));
    if (c0) {
	c1 = __addl(*UL_MED_12(x),(u_long)1,UL_MED_12(x));
	if (c1) {
	    (*UL_HI_12(x))++;
	}
    }
    c2 = __addl(*UL_MED_12(x),*UL_MED_12(y),UL_MED_12(x));
    if (c2) {
	(*UL_HI_12(x))++;
    }
    /* ignore next carry -- assume no overflow will occur */
    (void) __addl(*UL_HI_12(x),*UL_HI_12(y),UL_HI_12(x));
}





/***
*void _CALLTYPE5 __shl_12(_LDBL12 *x) - _LDBL12 shift left
*void _CALLTYPE5 __shr_12(_LDBL12 *x) - _LDBL12 shift right
*
*Purpose: Shift a _LDBL12 number one bit to the left (right). The number
*   is shifted as a 12-byte integer. The MSB is lost.
*
*Entry: x: a pointer to the operand
*
*Exit: *x is shifted one bit to the left (or right)
*
*Exceptions:
*
*******************************************************************************/

void _CALLTYPE5 __shl_12(_LDBL12 *p)
{
    u_long c0,c1;

    c0 = *UL_LO_12(p) & MSB_ULONG ? 1: 0;
    c1 = *UL_MED_12(p) & MSB_ULONG ? 1: 0;
    *UL_LO_12(p) <<= 1;
    *UL_MED_12(p) = *UL_MED_12(p)<<1 | c0;
    *UL_HI_12(p) = *UL_HI_12(p)<<1 | c1;
}

void _CALLTYPE5 __shr_12(_LDBL12 *p)
{
    u_long c2,c1;
    c2 = *UL_HI_12(p) & 0x1 ? MSB_ULONG: 0;
    c1 = *UL_MED_12(p) & 0x1 ? MSB_ULONG: 0;
    *UL_HI_12(p) >>= 1;
    *UL_MED_12(p) = *UL_MED_12(p)>>1 | c2;
    *UL_LO_12(p) = *UL_LO_12(p)>>1 | c1;
}






/***
*void _CALLTYPE5 __mtold12(char *manptr,unsigned manlen,_LDBL12 *ld12) -
*   convert a mantissa into a _LDBL12
*
*Purpose: convert a mantissa into a _LDBL12. The mantissa is
*   in the form of an array of manlen BCD digits and is
*   considered to be an integer.
*
*Entry: manptr: the array containing the packed BCD digits of the mantissa
*	manlen: the size of the array
*	ld12: a pointer to the long double where the result will be stored
*
*Exit:
*	ld12 gets the result of the conversion
*
*Exceptions:
*
*******************************************************************************/

void _CALLTYPE5 __mtold12(char *manptr,
			 unsigned manlen,
			 _LDBL12 *ld12)
{
    _LDBL12 tmp;
    u_short expn = LD_BIASM1+80;

    *UL_LO_12(ld12) = 0;
    *UL_MED_12(ld12) = 0;
    *UL_HI_12(ld12) = 0;
    for (;manlen>0;manlen--,manptr++){
	tmp = *ld12;
	__shl_12(ld12);
	__shl_12(ld12);
	__add_12(ld12,&tmp);
	__shl_12(ld12);	       /* multiply by 10 */
	*UL_LO_12(&tmp) = (u_long)*manptr;
	*UL_MED_12(&tmp) = 0;
	*UL_HI_12(&tmp) = 0;
	__add_12(ld12,&tmp);
    }

    /* normalize mantissa -- first shift word by word */
    while (*UL_HI_12(ld12) == 0) {
	*UL_HI_12(ld12) = *UL_MED_12(ld12) >> 16;
	*UL_MED_12(ld12) = *UL_MED_12(ld12) << 16 | *UL_LO_12(ld12) >> 16;
	(*UL_LO_12(ld12)) <<= 16;
	expn -= 16;
    }
    while ((*UL_HI_12(ld12) & 0x8000) == 0) {
	__shl_12(ld12);
	expn--;
    }
    *U_EXP_12(ld12) = expn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\conv\tenpow.c ===
/***
*tenpow.c - multiply a _LDBL12 by a power of 10
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       07-17-91  GDP   Initial version (ported from assembly)
*       11-15-93  GJF   Merged in NT SDK verions. Replaced MIPS and _ALPHA_
*                       by _M_MRX000 and _M_ALPHA (resp.).
*       10-02-94  BWT   PPC changes
*       07-15-96  GJF   Added parantheses to fix precedence problem in expr.
*                       Also, detab-ed.
*       05-05-99  RDL   Added _M_IA64 to #if def's for alignment.
*
*******************************************************************************/


#include <cv.h>

extern _LDBL12 _pow10pos[];
extern _LDBL12 _pow10neg[];




/***
*void _CALLTYPE5 __ld12mul(_LDBL12 *px, _LDBL12 *py) -
*   _LDBL12 multiplication
*
*Purpose: multiply two _LDBL12 numbers
*
*Entry: px,py: pointers to the _LDBL12 operands
*
*Exit: *px contains the product
*
*Exceptions:
*
*******************************************************************************/

void _CALLTYPE5 __ld12mul(_LDBL12 *px, _LDBL12 *py)
{
    u_short sign = 0;
    _LDBL12 tempman; /*this is actually a 12-byte mantissa,
                         not a 12-byte long double */
    int i;
    u_short expx, expy, expsum;
    int roffs,poffs,qoffs;
    int sticky = 0;

    *UL_LO_12(&tempman) = 0;
    *UL_MED_12(&tempman) = 0;
    *UL_HI_12(&tempman) = 0;

    expx = *U_EXP_12(px);
    expy = *U_EXP_12(py);

    sign = (expx ^ expy) & (u_short)0x8000;
    expx &= 0x7fff;
    expy &= 0x7fff;
    expsum = expx+expy;
    if (expx >= LD_MAXEXP
        || expy >= LD_MAXEXP
        || expsum > LD_MAXEXP+ LD_BIASM1){
        /* overflow to infinity */
        PUT_INF_12(px,sign);
        return;
    }
    if (expsum <= LD_BIASM1-63) {
        /* underflow to zero */
        PUT_ZERO_12(px);
        return;
    }
    if (expx == 0) {
        /*
         * If this is a denormal temp real then the mantissa
         * was shifted right once to set bit 63 to zero.
         */
        expsum++; /* Correct for this */
        if (ISZERO_12(px)) {
            /* put positive sign */
            *U_EXP_12(px) = 0;
            return;
        }
    }
    if (expy == 0) {
        expsum++; /* because arg2 is denormal */
        if (ISZERO_12(py)) {
            PUT_ZERO_12(px);
            return;
        }
    }

    roffs = 0;
    for (i=0;i<5;i++) {
        int j;
        poffs = i<<1;
        qoffs = 8;
        for (j=5-i;j>0;j--) {
	    u_long prod;
#if     defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)
            /* a variable to hold temprary sums */
            u_long sum;
#endif
            int carry;
            u_short *p, *q;
            u_long *r;
            p = USHORT_12(px,poffs);
            q = USHORT_12(py,qoffs);
            r = ULONG_12(&tempman,roffs);
            prod = (u_long)*p * (u_long)*q;
#if     defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)
            /* handle misalignment problems */
            if (i&0x1){ /* i is odd */
                carry = __addl(*ALIGN(r), prod, &sum);
                *ALIGN(r) =  sum;
            }
            else /* i is even */
                carry = __addl(*r, prod, r);
#else
            carry = __addl(*r,prod,r);
#endif
            if (carry) {
                /* roffs should be less than 8 in this case */
                (*USHORT_12(&tempman,roffs+4))++;
            }
            poffs+=2;
            qoffs-=2;
        }
        roffs+=2;
    }

    expsum -= LD_BIASM1;

    /* normalize */
    while ((s_short)expsum > 0 &&
           ((*UL_HI_12(&tempman) & MSB_ULONG) == 0)) {
         __shl_12(&tempman);
         expsum--;
    }

    if ((s_short)expsum <= 0) {
        expsum--;
        while ((s_short)expsum < 0) {
            if (*U_XT_12(&tempman) & 0x1)
                sticky++;
            __shr_12(&tempman);
            expsum++;
        }
        if (sticky)
            *U_XT_12(&tempman) |= 0x1;
    }

    if (*U_XT_12(&tempman) > 0x8000 ||
         ((*UL_LO_12(&tempman) & 0x1ffff) == 0x18000)) {
        /* round up */
        if (*UL_MANLO_12(&tempman) == MAX_ULONG) {
            *UL_MANLO_12(&tempman) = 0;
            if (*UL_MANHI_12(&tempman) == MAX_ULONG) {
                *UL_MANHI_12(&tempman) = 0;
                if (*U_EXP_12(&tempman) == MAX_USHORT) {
                    /* 12-byte mantissa overflow */
                    *U_EXP_12(&tempman) = MSB_USHORT;
                    expsum++;
                }
                else
                    (*U_EXP_12(&tempman))++;
            }
            else
                (*UL_MANHI_12(&tempman))++;
        }
        else
            (*UL_MANLO_12(&tempman))++;
    }


    /* check for exponent overflow */
    if (expsum >= 0x7fff){
        PUT_INF_12(px, sign);
        return;
    }

    /* put result in px */
    *U_XT_12(px) = *USHORT_12(&tempman,2);
    *UL_MANLO_12(px) = *UL_MED_12(&tempman);
    *UL_MANHI_12(px) = *UL_HI_12(&tempman);
    *U_EXP_12(px) = expsum | sign;
}



void _CALLTYPE5
__multtenpow12(_LDBL12 *pld12, int pow, unsigned mult12)
{
    _LDBL12 *pow_10p = _pow10pos-8;
    if (pow == 0)
        return;
    if (pow < 0) {
        pow = -pow;
        pow_10p = _pow10neg-8;
    }

    if (!mult12)
        *U_XT_12(pld12) = 0;


    while (pow) {
        int last3; /* the 3 LSBits of pow */
        _LDBL12 unround;
        _LDBL12 *py;

        pow_10p += 7;
        last3 = pow & 0x7;
        pow >>= 3;
        if (last3 == 0)
            continue;
        py = pow_10p + last3;

#ifdef _LDSUPPORT
        if (mult12) {
#endif
            /* do an exact 12byte multiplication */
            if (*U_XT_12(py) >= 0x8000) {
                /* copy number */
                unround = *py;
                /* unround adjacent byte */
                (*UL_MANLO_12(&unround))--;
                /* point to new operand */
                py = &unround;
            }
            __ld12mul(pld12,py);
#ifdef _LDSUPPORT
        }
        else {
            /* do a 10byte multiplication */
            py = (_LDBL12 *)TEN_BYTE_PART(py);
            *(long double *)TEN_BYTE_PART(pld12) *=
                *(long double *)py;
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\conv\strgtold.c ===
/***
*strgtold.c - conversion of a string into a long double
*
*	Copyright (c) 1991-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose: convert a fp constant into a 10 byte long double (IEEE format)
*
*Revision History:
*	07-17-91  GDP	Initial version (ported from assembly)
*	04-03-92  GDP	Preserve sign of -0
*	04-30-92  GDP	Now returns _LDBL12 instead of _LDOUBLE
*	06-17-92  GDP	Added __strgtold entry point again (68k code uses it)
*	06-22-92  GDP	Use scale, decpt and implicit_E for FORTRAN support
*	11-06-92  GDP	Made char-to-int conversions usnigned for 'isdigit'
*	03-11-93  JWM	Added minimal support for _INTL decimal point - one byte only!
*	07-01-93  GJF	Made buf[] a local array, rather than static array of
*			local scope (static is evil in multi-thread!).
*	09-15-93  SKS	Change _decimal_point to __decimal_point for CFW.
*	09-06-94  CFW	Remove _INTL switch.
*
*******************************************************************************/

#include <ctype.h>  /* for 'isdigit' macro */
#include <cv.h>
#include <nlsint.h>

/* local macros */
#define ISNZDIGIT(x) ((x)>='1' && (x)<='9' )
#define ISWHITE(x) ((x)==' ' || (x)=='\t' || (x)=='\n' || (x)=='\r' )


/****
*unsigned int __strgtold12( _LDBL12 *pld12,
*			  char * * pEndPtr,
*			  char * str,
*			  int Mult12,
*			  int scale,
*			  int decpt,
*			  int implicit_E)
*
*Purpose:
*   converts a character string into a 12byte long double (_LDBL12)
*   This has the same format as a 10byte long double plus two extra
*   bytes for the mantissa
*
*Entry:
*   pld12   - pointer to the _LDBL12 where the result should go.
*   pEndStr - pointer to a far pointer that will be set to the end of string.
*   str     - pointer to the string to be converted.
*   Mult12  - set to non zero if the _LDBL12 multiply should be used instead of
*		the long double mulitiply.
*   scale   - FORTRAN scale factor (0 for C)
*   decpt   - FORTRAN decimal point factor (0 for C)
*   implicit_E - if true, E, e, D, d can be implied (FORTRAN syntax)
*
*Exit:
*   Returns the SLD_* flags or'ed together.
*
*Uses:
*
*Exceptions:
*
********************************************************************************/

unsigned int
__strgtold12(_LDBL12 *pld12,
	    const char * *p_end_ptr,
	    const char * str,
	    int mult12,
	    int scale,
	    int decpt,
	    int implicit_E)
{
    typedef enum {
	S_INIT,  /* initial state */
	S_EAT0L, /* eat 0's at the left of mantissa */
	S_SIGNM, /* just read sign of mantissa */
	S_GETL,  /* get integer part of mantissa */
	S_GETR,  /* get decimal part of mantissa */
	S_POINT, /* just found decimal point */
	S_E,	 /* just found	'E', or 'e', etc  */
	S_SIGNE, /* just read sign of exponent */
	S_EAT0E, /* eat 0's at the left of exponent */
	S_GETE,  /* get exponent */
	S_END,	 /* final state */
	S_E_IMPLICIT  /* check for implicit exponent */
    } state_t;

    /* this will accomodate the digits of the mantissa in BCD form*/
    char buf[LD_MAX_MAN_LEN1];
    char *manp = buf;

    /* a temporary _LDBL12 */
    _LDBL12 tmpld12;

    u_short man_sign = 0; /* to be ORed with result */
    int exp_sign = 1; /* default sign of exponent (values: +1 or -1)*/
    /* number of decimal significant mantissa digits so far*/
    unsigned manlen = 0;
    int found_digit = 0;
    int found_decpoint = 0;
    int found_exponent = 0;
    int overflow = 0;
    int underflow = 0;
    int pow = 0;
    int exp_adj = 0;  /* exponent adjustment */
    u_long ul0,ul1;
    u_short u,uexp;

    unsigned int result_flags = 0;

    state_t state = S_INIT;

    char c;  /* the current input symbol */
    const char *p; /* a pointer to the next input symbol */
    const char *savedp;

    for(savedp=p=str;ISWHITE(*p);p++); /* eat up white space */

    while (state != S_END) {
	c = *p++;
	switch (state) {
	case S_INIT:
	    if (ISNZDIGIT(c)) {
		state = S_GETL;
		p--;
	    }
		else if (c == *__decimal_point)
	    	state = S_POINT;
	    else
		switch (c) {
		case '0':
		    state = S_EAT0L;
		    break;
		case '+':
		    state = S_SIGNM;
		    man_sign = 0x0000;
		    break;
		case '-':
		    state = S_SIGNM;
		    man_sign = 0x8000;
		    break;
		default:
		    state = S_END;
		    p--;
		    break;
		}
	    break;
	case S_EAT0L:
	    found_digit = 1;
	    if (ISNZDIGIT(c)) {
		state = S_GETL;
		p--;
	    }
		else if (c == *__decimal_point)
	    	state = S_GETR;
	    else
		switch (c) {
		case '0':
		    state = S_EAT0L;
		    break;
		case 'E':
		case 'e':
		case 'D':
		case 'd':
		    state = S_E;
		    break;
		case '+':
		case '-':
		    p--;
		    state = S_E_IMPLICIT;
		    break;
		default:
		    state = S_END;
		    p--;
		}
	    break;
	case S_SIGNM:
	    if (ISNZDIGIT(c)) {
		state = S_GETL;
		p--;
	    }
		else if (c == *__decimal_point)
	    	state = S_POINT;
	    else
		switch (c) {
		case '0':
		    state = S_EAT0L;
		    break;
		default:
		    state = S_END;
		    p = savedp;
		}
	    break;
	case S_GETL:
	    found_digit = 1;
	    for (;isdigit((int)(unsigned char)c);c=*p++) {
		if (manlen < LD_MAX_MAN_LEN+1){
		    manlen++;
		    *manp++ = c - (char)'0';
		}
		else
		   exp_adj++;
	    }
		if (c == *__decimal_point)
	    	state = S_GETR;
	    else
	    switch (c) {
	    case 'E':
	    case 'e':
	    case 'D':
	    case 'd':
		state = S_E;
		break;
	    case '+':
	    case '-':
		p--;
		state = S_E_IMPLICIT;
		break;
	    default:
		state = S_END;
		p--;
	    }
	break;
	case S_GETR:
	    found_digit = 1;
	    found_decpoint = 1;
	    if (manlen == 0)
		for (;c=='0';c=*p++)
		    exp_adj--;
	    for(;isdigit((int)(unsigned char)c);c=*p++){
		if (manlen < LD_MAX_MAN_LEN+1){
		    manlen++;
		    *manp++ = c - (char)'0';
		    exp_adj--;
		}
	    }
	    switch (c){
	    case 'E':
	    case 'e':
	    case 'D':
	    case 'd':
		state = S_E;
		break;
	    case '+':
	    case '-':
		p--;
		state = S_E_IMPLICIT;
		break;
	    default:
		state = S_END;
		p--;
	    }
	    break;
	case S_POINT:
	    found_decpoint = 1;
	    if (isdigit((int)(unsigned char)c)){
		state = S_GETR;
		p--;
	    }
	    else{
		state = S_END;
		p = savedp;
	    }
	    break;
	case S_E:
	    savedp = p-2; /* savedp points to 'E' */
	    if (ISNZDIGIT(c)){
		state = S_GETE;
		p--;
	    }
	    else
		switch (c){
		case '0':
		    state = S_EAT0E;
		    break;
		case '-':
		    state = S_SIGNE;
		    exp_sign = -1;
		    break;
		case '+':
		    state = S_SIGNE;
		    break;
		default:
		    state = S_END;
		    p = savedp;
		}
	break;
	case S_EAT0E:
	    found_exponent = 1;
	    for(;c=='0';c=*p++);
	    if (ISNZDIGIT(c)){
		state = S_GETE;
		p--;
	    }
	    else {
		state = S_END;
		p--;
	    }
	    break;
	case S_SIGNE:
	    if (ISNZDIGIT(c)){
		state = S_GETE;
		p--;
	    }
	    else
		switch (c){
		case '0':
		    state = S_EAT0E;
		    break;
		default:
		    state = S_END;
		    p = savedp;
		}
	    break;
	case S_GETE:
	    found_exponent = 1;
	    {
		long longpow=0; /* TMAX10*10 should fit in a long */
		for(;isdigit((int)(unsigned char)c);c=*p++){
		    longpow = longpow*10 + (c - '0');
		    if (longpow > TMAX10){
			longpow = TMAX10+1; /* will force overflow */
			break;
		    }
		}
		pow = (int)longpow;
	    }
	    for(;isdigit((int)(unsigned char)c);c=*p++); /* eat up remaining digits */
	    state = S_END;
	    p--;
	    break;
	case S_E_IMPLICIT:
	    if (implicit_E) {
		savedp = p-1; /* savedp points to whatever precedes sign */
		switch (c){
		case '-':
		    state = S_SIGNE;
		    exp_sign = -1;
		    break;
		case '+':
		    state = S_SIGNE;
		    break;
		default:
		    state = S_END;
		    p = savedp;
		}
	    }
	    else {
		 state = S_END;
		 p--;
	    }
	    break;
	}  /* switch */
    }  /* while */

    *p_end_ptr = p;	/* set end pointer */

    /*
     * Compute result
     */

    if (found_digit && !overflow && !underflow) {
	if (manlen>LD_MAX_MAN_LEN){
	    if (buf[LD_MAX_MAN_LEN-1]>=5) {
	       /*
		* Round mantissa to MAX_MAN_LEN digits
		* It's ok to round 9 to 0ah
		*/
		buf[LD_MAX_MAN_LEN-1]++;
	    }
	    manlen = LD_MAX_MAN_LEN;
	    manp--;
	    exp_adj++;
	}
	if (manlen>0) {
	   /*
	    * Remove trailing zero's from mantissa
	    */
	    for(manp--;*manp==0;manp--) {
		/* there is at least one non-zero digit */
		manlen--;
		exp_adj++;
	    }
	    __mtold12(buf,manlen,&tmpld12);

	    if (exp_sign < 0)
		pow = -pow;
	    pow += exp_adj;

	    /* new code for FORTRAN support */
	    if (!found_exponent) {
		pow += scale;
	    }
	    if (!found_decpoint) {
		pow -= decpt;
	    }


	    if (pow > TMAX10)
		overflow = 1;
	    else if (pow < TMIN10)
		underflow = 1;
	    else {
		__multtenpow12(&tmpld12,pow,mult12);

		u = *U_XT_12(&tmpld12);
		ul0 =*UL_MANLO_12(&tmpld12);
		ul1 = *UL_MANHI_12(&tmpld12);
		uexp = *U_EXP_12(&tmpld12);

	    }
	}
	else {
	    /* manlen == 0, so	return 0 */
	    u = (u_short)0;
	    ul0 = ul1 = uexp = 0;
	}
    }

    if (!found_digit) {
       /* return 0 */
       u = (u_short)0;
       ul0 = ul1 = uexp = 0;
       result_flags |= SLD_NODIGITS;
    }
    else if (overflow) {
	/* return +inf or -inf */
	uexp = (u_short)0x7fff;
	ul1 = 0x80000000;
	ul0 = 0;
	u = (u_short)0;
	result_flags |= SLD_OVERFLOW;
    }
    else if (underflow) {
       /* return 0 */
       u = (u_short)0;
       ul0 = ul1 = uexp = 0;
       result_flags |= SLD_UNDERFLOW;
    }

    /*
     * Assemble	result
     */

    *U_XT_12(pld12) = u;
    *UL_MANLO_12(pld12) = ul0;
    *UL_MANHI_12(pld12) = ul1;
    *U_EXP_12(pld12) = uexp | man_sign;

    return result_flags;
}



/****
*unsigned int _CALLTYPE5 __stringtold( LDOUBLE	*pLd,
*				   char * * pEndPtr,
*				   char * str,
*				   int	      Mult12 )
*
*Purpose:
*   converts a character string into a long double
*
*Entry:
*   pLD     - pointer to the long double where the result should go.
*   pEndStr - pointer to a pointer that will be set to the end of string.
*   str     - pointer to the string to be converted.
*   Mult12  - set to non zero if the _LDBL12 multiply should be used instead of
*		the long double mulitiply.
*
*Exit:
*   Returns the SLD_* flags or'ed together.
*
*Uses:
*
*Exceptions:
*
********************************************************************************/

unsigned int _CALLTYPE5
__STRINGTOLD(_LDOUBLE *pld,
	    const char * *p_end_ptr,
	    const char *str,
	    int mult12)
{
    unsigned int retflags;
    INTRNCVT_STATUS intrncvt;
    _LDBL12 ld12;

    retflags = __strgtold12(&ld12, p_end_ptr, str, mult12, 0, 0, 0);

    intrncvt = _ld12told(&ld12, pld);

    if (intrncvt == INTRNCVT_OVERFLOW) {
	    retflags |= SLD_OVERFLOW;
    }

    return retflags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\inc\i386\convert.inc ===
page	,132
;***
;convert.inc - macros and defines for floating point/ascii convertion routines
;
;	Copyright (c) 1989-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	Macros and defines for floating point/ascii convertion routines
;
;Revision History:
;
;   04/17/89  WAJ   Initial version.  Assembeler version of convert.h
;   04/20/89  WAJ   Now defines constants for $i10_output() OutputFlags
;
;*******************************************************************************



;*******************************************************************************
;
;   Constants
;
;*******************************************************************************


MAX_MAN_DIGITS	equ   21		; Largest number of decimal digits returned


;*
;*  Flags returned by __StrToLd()
;*

SLD_UNDERFLOW	equ	1	; Underflow occurred. Zero returned.
SLD_OVERFLOW	equ	2	; Overflow occured.  Infinity returned.
SLD_NODIGITS	equ	4	; No digits were found. Zero returned.


;*
;*  Output flags for $i10_output()
;*

SO_FFORMAT	equ	1	; 'f' format.  Use precision as number of digits to right of decimal.




;*******************************************************************************
;
;   Structures
;
;*******************************************************************************


FloatOutStruct	struc
    FloatExp	dw	?
    FloatSign	db	?
    FloatStrLen db	?
    FloatStr	db	(MAX_MAN_DIGITS + 1) dup(?)
FloatOutStruct	ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\conv\x10fout.c ===
/***
*x10fout.c - floating point output for 10-byte long double
*
*	Copyright (c) 1991-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*   Support conversion of a long double into a string
*
*Revision History:
*   07/15/91	GDP	Initial version in C (ported from assembly)
*   01/23/92	GDP	Support MIPS encoding for NaN
*
*******************************************************************************/

#include <string.h>
#include <cv.h>

#define STRCPY strcpy

#define PUT_ZERO_FOS(fos)	 \
		fos->exp = 0,	 \
		fos->sign = ' ', \
		fos->ManLen = 1, \
		fos->man[0] = '0',\
		fos->man[1] = 0;

#define SNAN_STR      "1#SNAN"
#define SNAN_STR_LEN  6
#define QNAN_STR      "1#QNAN"
#define QNAN_STR_LEN  6
#define INF_STR	      "1#INF"
#define INF_STR_LEN   5
#define IND_STR	      "1#IND"
#define IND_STR_LEN   5


/***
*int _CALLTYPE5
* _$i10_output(_LDOUBLE ld,
*	    int ndigits,
*	    unsigned output_flags,
*	    FOS *fos) - output conversion of a 10-byte _LDOUBLE
*
*Purpose:
*   Fill in a FOS structure for a given _LDOUBLE
*
*Entry:
*   _LDOUBLE ld:  The long double to be converted into a string
*   int ndigits: number of digits allowed in the output format.
*   unsigned output_flags: The following flags can be used:
*	SO_FFORMAT: Indicates 'f' format
*	(default is 'e' format)
*   FOS *fos: the structure that i10_output will fill in
*
*Exit:
*   modifies *fos
*   return 1 if original number was ok, 0 otherwise (infinity, NaN, etc)
*
*Exceptions:
*
*******************************************************************************/


int _CALLTYPE5 $I10_OUTPUT(_LDOUBLE ld, int ndigits,
		    unsigned output_flags, FOS *fos)
{
    u_short expn;
    u_long manhi,manlo;
    u_short sign;

    /* useful constants (see algorithm explanation below) */
    u_short const log2hi = 0x4d10;
    u_short const log2lo = 0x4d;
    u_short const log4hi = 0x9a;
    u_long const c = 0x134312f4;
#if defined(L_END)
    _LDBL12 ld12_one_tenth = {
	   {0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,
	    0xcc,0xcc,0xcc,0xcc,0xfb,0x3f}
    };
#elif defined(B_END)
    _LDBL12 ld12_one_tenth = {
	   {0x3f,0xfb,0xcc,0xcc,0xcc,0xcc,
	    0xcc,0xcc,0xcc,0xcc,0xcc,0xcc}
    };
#endif

    _LDBL12 ld12; /* space for a 12-byte long double */
    _LDBL12 tmp12;
    u_short hh,ll; /* the bytes of the exponent grouped in 2 words*/
    u_short mm; /* the two MSBytes of the mantissa */
    s_long r; /* the corresponding power of 10 */
    s_short ir; /* ir = floor(r) */
    int retval = 1; /* assume valid number */
    char round; /* an additional character at the end of the string */
    char *p;
    int i;
    int ub_exp;
    int digcount;

    /* grab the components of the long double */
    expn = *U_EXP_LD(&ld);
    manhi = *UL_MANHI_LD(&ld);
    manlo = *UL_MANLO_LD(&ld);
    sign = expn & MSB_USHORT;
    expn &= 0x7fff;

    if (sign)
	fos->sign = '-';
    else
	fos->sign = ' ';

    if (expn==0 && manhi==0 && manlo==0) {
	PUT_ZERO_FOS(fos);
	return 1;
    }

    if (expn == 0x7fff) {
	fos->exp = 1; /* set a positive exponent for proper output */

	/* check for special cases */
	if (_IS_MAN_SNAN(sign, manhi, manlo)) {
	    /* signaling NAN */
	    STRCPY(fos->man,SNAN_STR);
	    fos->ManLen = SNAN_STR_LEN;
	    retval = 0;
	}
	else if (_IS_MAN_IND(sign, manhi, manlo)) {
	    /* indefinite */
	    STRCPY(fos->man,IND_STR);
	    fos->ManLen = IND_STR_LEN;
	    retval = 0;
	}
	else if (_IS_MAN_INF(sign, manhi, manlo)) {
	    /* infinity */
	    STRCPY(fos->man,INF_STR);
	    fos->ManLen = INF_STR_LEN;
	    retval = 0;
	}
	else {
	    /* quiet NAN */
	    STRCPY(fos->man,QNAN_STR);
	    fos->ManLen = QNAN_STR_LEN;
	    retval = 0;
	}
    }
    else {
       /*
	*    Algorithm for the decoding of a valid real number x
	*
	* In the  following  INT(r)  is	the largest integer less than or
	* equal to r (i.e. r rounded toward -infinity).	We want a result
	* r equal  to  1  + log(x), because then x = mantissa
	* * 10^(INT(r)) so that	.1  <=	mantissa  <  1.   Unfortunately,
	* we cannot  compute  s	exactly  so  we must alter the procedure
	* slightly.  We will  instead  compute	an  estimate  r	of  1  +
	* log(x) which	is  always  low.   This	will either result
	* in the correctly normalized number on	the  top  of  the  stack
	* or perhaps  a	number	which  is  a factor of 10 too large.  We
	* will then check to see that if  x  is	larger	 than  one
	* and if so multiply x by 1/10.
	*
	* We will  use	a  low	precision  (fixed  point 24 bit) estimate
	* of of 1 + log base 10 of x.  We  have	approximately  .mm
	* * 2^hhll  on	the  top of the stack where m, h, and l represent
	* hex digits,  mm  represents  the  high  2  hex  digits  of  the
	* mantissa, hh	represents the high 2 hex digits of the exponent,
	* and ll represents the low 2 hex digits of the exponent.   Since
	* .mm is  a  truncated	representation	of the mantissa, using it
	* in this  monotonically  increasing   polynomial   approximation
	* of the  logarithm  will  naturally  give  a  low result.  Let's
	* derive a formula for a lower	bound  r  on  1	+  log(x):
	*
	*      .4D104D42H < log(2)=.30102999...(base 10) < .4D104D43H
	*	  .9A20H < log(4)=.60205999...(base 10) < .9A21H
	*
	*  1/2 <= .mm < 1
	*  ==>	log(.mm) >= .mm * log(4) - log(4)
	*
	* Substituting in  truncated  hex  constants in the formula above
	* gives r = 1 + .4D104DH * hhll.  + .9AH *  .mm	-  .9A21H.   Now
	* multiplication of  hex  digits  5  and 6 of log(2) by ll has an
	* insignificant effect on the first 24	bits  of  the  result  so
	* it will  not	be  calculated.	 This  gives  the expression r =
	* 1 + .4D10H * hhll.  +	.4DH  *  .hh  +  .9A  *  .mm  -  .9A21H.
	* Finally we  must  add	terms to our formula to subtract out the
	* effect of the exponent bias.	We obtain the following	formula:
	*
	*			(implied decimal point)
	*   <				  >.<				   >
	*   |3|3|2|2|2|2|2|2|2|2|2|2|1|1|1|1|1|1|1|1|1|1|0|0|0|0|0|0|0|0|0|0|
	*   |1|0|9|8|7|6|5|4|3|2|1|0|9|8|7|6|5|4|3|2|1|0|9|8|7|6|5|4|3|2|1|0|
	* + <		  1		  >
	* + <			    .4D10H * hhll.			   >
	* +				    <	    .00004DH * hh00.	   >
	* +				    <	       .9AH * .mm	   >
	* -				    <		 .9A21H 	   >
	* - <			    .4D10H * 3FFEH			   >
	* -				    <	    .00004DH * 3F00H	   >
	*
	*  ==>	r = .4D10H * hhll. + .4DH * .hh + .9AH * .mm - 1343.12F4H
	*
	* The difference  between  the	lower bound r and the upper bound
	* s is calculated as follows:
	*
	*  .937EH < 1/ln(10)-log(1/ln(4))=.57614993...(base 10) < .937FH
	*
	*  1/2 <= .mm < 1
	*  ==>	log(.mm) <= .mm * log(4) - [1/ln(10) - log(1/ln(4))]
	*
	* so tenatively	s  =  r  +  log(4)  - [1/ln(10) - log(1/ln(4))],
	* but we must also add in terms to ensure we will have	an  upper
	* bound even  after  the  truncation  of various values.  Because
	* log(2) * hh00.  is truncated	to  .4D104DH  *	hh00.	we  must
	* add .0043H,  because	log(2)	*  ll.	is truncated to .4D10H *
	* ll.  we  must	add  .0005H,  because  <mantissa>  *  log(4)  is
	* truncated to .mm * .9AH we must add .009AH and .0021H.
	*
	* Thus s = r - .937EH + .9A21H + .0043H + .0005H + .009AH + .0021H
	*	= r + .07A6H
	*  ==>	s = .4D10H * hhll. + .4DH * .hh + .9AH * .mm - 1343.0B4EH
	*
	* r is	equal  to  1  +	log(x) more than (10000H - 7A6H) /
	* 10000H = 97% of the time.
	*
	* In the above formula, a u_long is use to accomodate r, and
	* there is an implied decimal point in the middle.
	*/

	hh = expn >> 8;
	ll = expn & (u_short)0xff;
	mm = (u_short) (manhi >> 24);
	r = (s_long)log2hi*(s_long)expn + log2lo*hh + log4hi*mm - c;
	ir = (s_short)(r >> 16);

       /*
	*
	* We stated that we wanted to normalize x so that
	*
	*  .1 <= x < 1
	*
	* This was	a  slight  oversimplification.	 Actually  we  want a
	* number which when rounded to 16 significant digits  is  in  the
	* desired range.   To  do  this we must normalize x so that
	*
	*  .1 - 5*10^(-18) <= x < 1 - 5*10^(-17)
	*
	* and then round.
	*
	* If we  had f = INT(1+log(x)) we could multiply by 10^(-f)
	* to get x into the desired range.	We do  not  quite  have
	* f but  we  do  have  INT(r)  from  the last step which is equal
	* to f 97% of the time and 1 less than f the rest  of  the	time.
	* We can  multiply	by  10^-[INT(r)] and if the result is greater
	* than 1 - 5*10^(-17) we can then multiply by 1/10.   This	final
	* result will lie in the proper range.
	*/

	/* convert _LDOUBLE to _LDBL12) */
	*U_EXP_12(&ld12) = expn;
	*UL_MANHI_12(&ld12) = manhi;
	*UL_MANLO_12(&ld12) = manlo;
	*U_XT_12(&ld12) = 0;

	/* multiply by 10^(-ir) */
	__multtenpow12(&ld12,-ir,1);

	/* if ld12 >= 1.0 then divide by 10.0 */
	if (*U_EXP_12(&ld12) >= 0x3fff) {
	    ir++;
	    __ld12mul(&ld12,&ld12_one_tenth);
	}

	fos->exp = ir;
	if (output_flags & SO_FFORMAT){
	    /* 'f' format, add exponent to ndigits */
	    ndigits += ir;
	    if (ndigits <= 0) {
		/* return 0 */
		PUT_ZERO_FOS(fos);
		return 1;
	    }
	}
	if (ndigits > MAX_MAN_DIGITS)
	    ndigits = MAX_MAN_DIGITS;

	ub_exp = *U_EXP_12(&ld12) - 0x3ffe; /* unbias exponent */
	*U_EXP_12(&ld12) = 0;

	/*
	 * Now the mantissa has to be converted to fixed point.
	 * Then we will use the MSB of ld12 for generating
	 * the decimal digits. The next 11 bytes will hold
	 * the mantissa (after it has been converted to
	 * fixed point).
	 */

	for (i=0;i<8;i++)
	    __shl_12(&ld12); /* make space for an extra byte,
			      in case we shift right later */
	if (ub_exp < 0) {
	    int shift_count = (-ub_exp) & 0xff;
	    for (;shift_count>0;shift_count--)
		__shr_12(&ld12);
	}

	p = fos->man;
	for(digcount=ndigits+1;digcount>0;digcount--) {
	    tmp12 = ld12;
	    __shl_12(&ld12);
	    __shl_12(&ld12);
	    __add_12(&ld12,&tmp12);
	    __shl_12(&ld12);	/* ld12 *= 10 */

	    /* Now we have the first decimal digit in the msbyte of exponent */
	    *p++ = (char) (*UCHAR_12(&ld12,11) + '0');
	    *UCHAR_12(&ld12,11) = 0;
	}

	round = *(--p);
	p--; /* p points now to the last character of the string
		   excluding the rounding digit */
	if (round >= '5') {
	    /* look for a non-9 digit starting from the end of string */
	    for (;p>=fos->man && *p=='9';p--) {
		*p = '0';
	    }
	    if (p < fos->man){
		p++;
		fos->exp ++;
	    }
	    (*p)++;
	}
	else {
	    /* remove zeros */
	    for (;p>=fos->man && *p=='0';p--);
	    if (p < fos->man) {
		/* return 0 */
		PUT_ZERO_FOS(fos);
		return 1;
	    }
	}
	fos->ManLen = (char) (p - fos->man + 1);
	fos->man[fos->ManLen] = '\0';
    }
    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\inc\i386\defsegs.inc ===
;***
;defsegs.inc - defines segments.
;
;   Copyright (c) 1989-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;   This file defines segments for the math libs.
;
;Revision History:
;   11-14-89  WAJ   Initial version.
;
;*******************************************************************************


CrtDefSegs macro   SegList
    irp     seg, <SegList>

	ifidni	<seg>,<code>
	    ifdef I386
		createSeg _TEXT,code,dword,public,code,FLAT
		defGrp FLAT,<code>
	    else
		ifdef  FAR_CODE
		    createSeg _RTEXT,code,word,public,code
		else
		    createSeg _RTEXT,code,word,public,code
		endif
	    endif

	elseifidni <seg>,<data>
	    ifdef I386
		createSeg DATA,data,dword,public,DATA,FLAT
		defGrp FLAT,<data>
	    else
		createSeg DATA,data,word,public,DATA,DGROUP
		defGrp DGROUP,<data>
	    endif

	elseifidni <seg>,<init>
	    ifdef I386
		createSeg XIB,	xibseg, dword, public, DATA, FLAT
		createSeg XI,	xiseg,	dword, public, DATA, FLAT
		createSeg XIE,	xieseg, dword, public, DATA, FLAT
		defGrp FLAT,<xibseg,xiseg,xieseg>
	    else
		createSeg XIB,	xibseg, word, public, DATA, DGROUP
		createSeg XI,	xiseg,	word, public, DATA, DGROUP
		createSeg XIE,	xieseg, word, public, DATA, DGROUP
		defGrp DGROUP,<xibseg,xiseg,xieseg>
	    endif

	else
	    %out <Error in CrtDefSeg:  Unknown segment &seg.>
	    .err
	endif

    endm    ;; irp loop
endm	    ;; CrtDefSeg macro
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\inc\i386\elem87.inc ===
;***
;elem87.inc -
;
;	Copyright (c) 1988-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:   Include file for 8087 transcendental dunctions.
;	    Has jump table and common dispatch code definitions
;
;
;Revision History:
;
;   04/21/88	WAJ	Added this header.  Added wUser1/wUser2/bUser3 to
;			common dispatch code stack frame.  These are used
;			for multi thread fortran.
;
;   08/25/88	WAJ	386 version
;
;   11/16/91	GDP	put exception structure on stack frame
;
;   02/05/01	GDP	modified DispLocals, added DOMAIN_QNAN
;
;   03/25/92	GDP	added IEEE exception opcodes
;
;   09/06/94	CFW	Replace MTHREAD with _MT.
;
;   08-28-96    JWM     Added default_CW & DEFAULT_CW_without_precision for Intel mods.
;
;*******************************************************************************


SBUFSIZE EQU   108	     ; length of buffer used by fsave


;	local temps for common dispatch code

DispLocals  struc

wUser1	    dw	    ?
wUser2	    dw	    ?
savCntrl    dw	    ?
setCntrl    dw	    ?
StatusWord  dw	    ?
Fac	    dt	    ?

ifdef I386
Function    dd	    ?
else
Function    dw	    ?
endif

ErrorType   db	    ?

ifdef  _MT
__cpower    db	    ?
else
bUser3	    db	    ?
endif

typ	    dd	    ?
nam	    dd	    ?
arg1	    dq	    ?
arg2	    dq	    ?
retval	    dq	    ?
savebuf     db	    SBUFSIZE dup (?)	; buffer used for fsave'ing

DispLocals  ends

DSFISize    equ     ((size DispLocals) + ISIZE - 1) and (not (ISIZE-1))

DSF	equ	[rbp-DSFISize]			; Dispatch Stack Frame

CondCode    equ     byte ptr [DSF.StatusWord+1]
savCntrlbyte equ    byte ptr [DSF.savCntrl+1]


ifdef  _MT
_cpower equ  <DSF.__cpower>
endif



;	8087 control word structure

tranCntrl=	13h			; 64 bits, round even, affine inf
Affine= 	10h			; affine inf
default_CW=     027fh                   ; C default control word
DEFAULT_CW_without_precision = 007fh    ; C default control word, with zero precision bits


;	error types for matherr

CHECKRANGE=	-2			; check for possible overflow or underflow
CHECKOVER=	-1			; check for possible overflow
DOMAIN= 	1
SING=		2
OVERFLOW=	3
UNDERFLOW=	4
TLOSS=		5
PLOSS=		6
DOMAIN_QNAN=	7			; should be changed to DOMAIN
					; before calling matherr
INEXACT=	8


;	function jump table structure

funtab		struc
  fnamlen	db	?
  fnam		db	6 dup (?)
  fuseval	db	6 dup (?)
  fnumarg	db	?
  fnumber	db	?
		db	?	;; padding
funtab		ends


jmptab	macro	nam,namlen,strnam,useval,numarg
labelW		_&nam&jmptab, PUBLIC
	db	namlen		;; 1
	db	strnam		;; 6
	db	useval		;; 6
	db	numarg		;; 1
	db	nam		;; 1
	db	?		;; 1
	endm


Z = 1*ISIZE		    ; 0.0
H = 2*ISIZE		    ; HUGE
mH = 3*ISIZE		    ; -HUGE


Pentry	macro	pnam,nam,narg
extrn		__&nam&jmptab:word
extrn		__ptrandisp&narg&s:near
extrn		__ptrandisp&narg&d"near
labelP	pnam&SRQQ, PUBLIC
	mov	rdx, dataoffset __&nam&jmptab
	jmp	__ptrandisp&narg&s
labelP	pnam&DRQQ, PUBLIC
	mov	rdx, dataoffset __&nam&jmptab
	jmp	__ptrandisp&narg&d
	endm

; This macro is used to generate the necessary code and declarations
; for Fortran intrinsics with one argument

F1ArgEntry	macro	nam
extrn		_&nam&jmptab:word
extrn		_ctrand1:near
labelP	_FI&nam, PUBLIC
	mov	rdx, dataoffset _&nam&jmptab
	jmp	_ctrand1
	endm

; This macro is used to generate the necessary code and declarations
; for Fortran intrinsics with two arguments

F2ArgEntry	macro	nam
extrn		_&nam&jmptab:word
extrn		_ctrand2:near
labelP	_FI&nam, PUBLIC
	mov	rdx, dataoffset _&nam&jmptab
	jmp	_ctrand2
	endm


;	C/FORTRAN/BASIC floatcall macro

fc	macro	JSS,JDS,FCNAM,INS,SIZE,WAITI
;;		JSS - SS:BX and ES:BX offset
;;		    JDS - DS:BX offset
;;			FCNAM - float call name suffix
;;			      INS - 8087 instruction.
;;				  SIZE - byte,word,dword,qword,tbyte
;;				       WAIT - 8087 wait.
;;
;;	if large model, then frame floatcalls for BASIC error recovery

ifnb	   <JSS>
  labelP  _s&FCNAM, PUBLIC
	  push	  ss
	  pop	  es
  _e&FCNAM  proc
	  f&ins&size& ptr es:[rbx]  ;; Perform instruction.
	  waiti
	  ret
  _e&FCNAM  endp
endif	   ;;JES

ifnb	   <JDS>
  _f&FCNAM  proc
  ifnb	     <SIZE>
	  f&ins&size& ptr [rbx]     ;; Perform instruction.
	  waiti
  else
    ifnb    <ins>
	    f&ins
	    waiti
    endif
  endif    ;;SIZE

  _f&FCNAM  endp

endif	   ;;JDS
endm


; IEEE exception opcodes
; should be in sync with fpieee.h, ntxcapi.h

OP_SQRT    = 05h
OP_ACOS    = 0dh
OP_ASIN    = 0eh
OP_ATAN    = 0fh
OP_ATAN2   = 10h
OP_COS	   = 12h
OP_COSH    = 13h
OP_EXP	   = 14h
OP_FMOD    = 16h
OP_LOG	   = 1ah
OP_LOG10   = 1bh
OP_POW	   = 1dh
OP_SIN	   = 1eh


OP_SINH    = 1fh
OP_TAN	   = 20h
OP_TANH    = 21h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\inc\i386\errno.inc ===
;***
;errno.inc - defines standard C error codes
;
;	Copyright (c) 1987-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	This file contains definitions for the standard C error codes
;	used by XENIX (many of these have little significance for
;	MS-DOS).
;
;Revision History:
;
;*******************************************************************************


err	MACRO	num,name,text
name	equ	num
	ENDM


err	1,	EPERM,		<Not owner>
err	2,	ENOENT, 	<No such file or directory>
err	3,	ESRCH,		<No such process>
err	4,	EINTR,		<Interrupted system call>
err	5,	EIO,		<I/O error>
err	6,	ENXIO,		<No such device or address>
err	7,	E2BIG,		<Arg list too long>
err	8,	ENOEXEC,	<Exec format error>
err	9,	EBADF,		<Bad file number>
err	10,	ECHILD, 	<No child processes>
err	11,	EAGAIN, 	<No more processes>
err	12,	ENOMEM, 	<Not enough space>
err	13,	EACCES, 	<Permission denied>
err	14,	EFAULT, 	<Bad address>
err	15,	ENOTBLK,	<Block device required>
err	16,	EBUSY,		<Mount device busy>
err	17,	EEXIST, 	<File exists>
err	18,	EXDEV,		<Cross-device link>
err	19,	ENODEV, 	<No such device>
err	20,	ENOTDIR,	<Not a directory>
err	21,	EISDIR, 	<Is a directory>
err	22,	EINVAL, 	<Invalid argument>
err	23,	ENFILE, 	<File table overflow>
err	24,	EMFILE, 	<Too many open files>
err	25,	ENOTTY, 	<Not a typewriter>
err	26,	ETXTBSY,	<Text file busy>
err	27,	EFBIG,		<File too large>
err	28,	ENOSPC, 	<No space left on device>
err	29,	ESPIPE, 	<Illegal seek>
err	30,	EROFS,		<Read-only file system>
err	31,	EMLINK, 	<Too many links>
err	32,	EPIPE,		<Broken pipe>
err	33,	EDOM,		<Math argument>
err	34,	ERANGE, 	<Result too large>
err	35,	EUCLEAN,	<file system needs cleaning>
err	36,	EDEADLOCK,	<would deadlock>

;	end of errno.inc
;-----------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\inc\i386\mathver.inc ===
;***
;mathver.inc - defines current math model
;
;	Copyright (c) 1987-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	This file defines what math version is being built.
;
;Revision History:
;	02-21-88  WAJ	Combined all mathver.* into this file.
;	09-14-88  WAJ	Added to 386 tree
;
;*******************************************************************************



;       This file contains special version specific information -
;
;       Floating point format definition -
;
;           MBinFmt     Microsoft Binary Format
;           DecFmt      Microsoft Decimal Format
;           IEEEFmt     IEEE Binary Format
;
;       Size definition -
;
;           Single      Single Precision Format
;           Double      Double Precision Format
;
;       Language definition -
;
;           BASIC       BASIC Interpreter
;           BASCOM      BASIC Compiler
;           CC          C Compiler
;           FORTRAN     FORTRAN Compiler
;           PASCAL      PASCAL Compiler
;
;       The above switches should be defined in this include file only if
;       they are being set.  They should only be set to 1.


ifdef  MATHVERDBL

IEEEFmt=    1                               ; IEEE
Double=     1                               ; Double

FORTRAN=    1
PASCAL=     1

endif	;MATHVERDBL


ifdef  MATHVERU87

IEEEFmt=        1                               ; IEEE
Double=         1                               ; Double

FORTRAN=        1
PASCAL=         1
Denormal=       1
Use8087=        1
 
endif	;MATHVERU87


ifdef  MATHVERSNG


IEEEFmt=    1                               ; IEEE
Single=     1                               ; Single
 
FORTRAN=    1
PASCAL=     1


endif	;MATHVERSNG


ifdef  MATHVERDEC

DecFmt=     1                               ; Decimal
Double=     1                               ; Double

FORTRAN=    1
PASCAL=     1


endif	;MATHVERDEC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\inc\i386\memmacs.inc ===
;***
;memmacs.inc - defines macros to to handle different memory models easier.
;
;   Copyright (c) 1989-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;   This file defines the macros that handle different memory models.
;
;Revision History:
;
;   01-23-89  WAJ   Initial version copied from cruntime.inc
;   11-01-89  WAJ   Added IWORD/ISIZE
;   11-01-89  WAJ   Added PCS
;   11-01-89  WAJ   Added short condition jmps for 386 code
;
;*******************************************************************************



;*******************************************************************************
;*
;*  Define load pointer and segment override macros.
;*
;*******************************************************************************

if sizeD
    LPES equ <les>
    LPDS equ <lds>
    PDS  equ <ds:>
    PES  equ <es:>
else
    LPES equ <mov>
    LPDS equ <mov>
    PDS  equ <>
    PES  equ <>
endif

ifdef I386
    LFPES equ <mov>
    LFPDS equ <mov>
    FPES equ <>
    FPDS equ <>
else
    LFPES equ <les>
    LFPDS equ <lds>
    FPES equ <es:>
    FPDS equ <ds:>
endif

ifdef SS_NEQ_DGROUP
    PSS   equ <ss:>		; SS != DS
else
    PSS   equ <>		; SS == DS
endif

ifdef I386
    PCS   equ <>
else
    PCS   equ <cs:>
endif


;*******************************************************************************
;*
;*  Define IWORD and ISIZE.
;*
;*******************************************************************************

ifdef  I386
    IWORD   equ     <dword>
    ISIZE   equ     4
else
    IWORD   equ     <word>
    ISIZE   equ     2
endif


;*******************************************************************************
;*
;*  Define short conditional jumps for 386 code.
;*
;*******************************************************************************

	irp	x,<Z,E,S,C,P,PE,PO,A,AE,B,BE,G,GE,L,LE,O>
JS&x	equ   <j&x short>
JSN&x	equ   <jn&x short>
	endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\inc\i386\os2supp.inc ===
;*** 
;os2supp.inc - helper macros for OS/2, MTHREAD, and DLL support
;
;	Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Support for OS/2, MTHREAD, and DLL support
;
;Revision History:
;
;   08-25-88 WAJ    Added this header.	Added to 386 tree.
;   09-06-94 CFW    Replace MTHREAD with _MT.
;
;*******************************************************************************


ifdef	_MT
    OS2SUPP equ     1
else
    OS2SUPP equ     0
endif

__MsgString equ     <>

ifdef	_MT
__MsgString catstr __MsgString, < _MT>
endif

ifdef	SS_NEQ_DGROUP
__MsgString catstr __MsgString, < SS_NEQ_DGROUP>
endif

ifdef	DLL
__MsgString catstr __MsgString, < DLL>
endif

__SMsgString  sizestr __MsgString

if  __SMsgString
    if OS2SUPP
	__MsgString catstr <OS/2 Support Lib ->, __MsgString
    else
	__MsgString catstr <Support Lib ->, __MsgString
    endif
    ifndef QUIET
%	display __MsgString
    endif
endif


_loadds 	macro		;; code for loading ds with DGROUP
	push	ds
	mov	ax,DGROUP
	mov	ds,ax
endm	

_reloadds	macro		;; code for resetting ds
	pop	ds
endm	




ifmt	macro	code
    ifdef   _MT
	code
    endif
endm

nomt	macro	code
    ifndef  _MT
	code
    endif
endm

ifdll	macro	code
    ifdef   DLL
	code
    endif
endm


if_LOAD_DGROUP	macro	code
    ifdef  _LOAD_DGROUP
	code
    endif
endm

no_LOAD_DGROUP	macro	code
    ifndef  _LOAD_DGROUP
	code
    endif
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\inc\i386\mathmac.inc ===
;---------------        Standard MATHMAC.INC
;
;       Standard Math Macro Definition File
;
;       Gregory F. Whitten
;       07/28/83
;
;       Copyright (c) 1983-2001, Microsoft Corporation. All rights reserved.
;
;
;       Revision History
;
;       10/18/83        Greg Whitten
;                       changed LCL FLT option to have 2 values for IEEE
;
;       05/02/84        Greg Whitten
;                       added CSconst switch support
;
;       07/23/84        Greg Whitten
;                       changed public/extrn to lower case
;
;       09/03/84        Greg Whitten
;                       added movcnp macro for constant pointers (with CSconst)
;                       fixed CSconst bug in f_movcs (only used 1 place)
;
;       10/29/84        Greg Whitten
;                       added debugger switch for fout changes
;
;	06/17/87	Jamie Bariteau
;			changed outif macro for MASM 5.0 compatibility
;
;	02/22/88	Bill johnston
;			outif now checks to see if QUIET was defined.
;
;---------------


if1     ; Pass 1 only

;       Helper macros for undefined symbols


;***    OUTIF   name,msg
;
; Function:
;       Output msg if name is non-zero.  If name is undefined, set name = 0.
;

outif   MACRO   name,msg
ifndef          Name
  Name=           0
else
  if    Name
    if1
	ifndef QUIET
	    %out    ! msg
	endif
    endif
  endif
	Name=Name
endif
	ENDM


;***    ERROR   msg
;
; Function:
;       Output msg and generate an assembly time error
;

error   MACRO   msg
	bug
	%OUT    E r r o r ----- msg
	ENDM

endif   ; Pass 1

;       Define standard math package switches

ifdef  DEBUG
	%out <+++++++++++++++++++++++>
	%out <+++  DEBUG version  +++>
	%out <+++++++++++++++++++++++>
endif	;DEBUG

outif   XENIX3,         <+++  XENIX 3.0 and later version  +++>

outif   BASIC,          <BASIC Interpreter>
outif   BASCOM,         <BASIC Compiler>
outif   CC,             <C Compiler>
outif   FORTRAN,        <FORTRAN Compiler>
outif   PASCAL,         <PASCAL Compiler>
outif   Frontends,      <  compiler front-end version>
outif   LOGO,           <LOGO Interpreter>
outif   IBMASM,         <IBM Assembler Library>
outif   ASSEMBLER,      <Macro Assembler>
outif   debugger,       <Symbolic Assembly Debugger>

outif   DecFmt,         <- Decimal Microsoft Format>
outif   MBinFmt,        <- Binary Microsoft Format>
outif   IEEEFmt,        <- IEEE Format>
if      IEEEFmt and (Frontends or debugger)
Denormal=       1                               ; front-ends need denormals
endif
outif   Denormal,       <-   denormal number support>
outif   Use8087,        <-   8087 instructions>

outif   Single,         <-   Single precision>
outif   Double,         <-   Double precision>
outif   CSconst,        <-   Constants in CS>



if      DecFmt+IEEEFmt+MBinFmt ne 1
	error   <Improper math format specified>
endif

if      Single+Double ne 1
	error   <Improper math size specified>
endif


poly1   =   8000h                       ; flag for leading 1 in poly

if      Single                          ; Defined on both passes
  DefTyp= 4
  DefWrd= 2
else    ;Double
  DefTyp= 8
  DefWrd= 4
endif


;       offsets to sign and exponent fields

if      IEEEFmt
  if      single
expmask=        07F80h
expbias=        03F80h
expshft=        7
manbits=        24
of_exp=         2
of_sgn=         3
  else    ;double
expmask=        07FF0h
expbias=        03FF0h
expshft=        4
manbits=        53
of_exp=         6
of_sgn=         7
  endif
endif   ;IEEEFmt

if      MBinFmt
  if      single
manbits=        24
of_exp=         3
of_sgn=         2
  else    ;double
manbits=        56
of_exp=         7
of_sgn=         6
  endif
endif   ;MBinFmt

if      DecFmt
of_exp=         0
of_sgn=         0
endif   ;DecFmt



if1     ; Pass 1 only

;       Helper macros for elementary functions


;***    LCL     name,type,value
;
; Function:
;       LCL declares data with the specified name, type, and value.
;       If the type is FLT for IEEE numbers, then either DD or DQ is
;       substituted depending on the size of the variable.
;

lcl     MACRO  name,type,value,value2
ifidn   <type>,<FLT>
  if      IEEEFmt
    if      Single
      name    DD      value
    else    ;;Double
      name    DQ      value2
    endif
  else
	  error   <FLT not implemented for this type>
  endif
else
  name    type    value
endif
	ENDM


;***    GENHELP typ,siz
;
; Function:
;       GENHELP generates the following macros with the typ and siz
;       information embedded in the macro.
;
;           PUB     name
;           PUB4    name
;           PUB8    name
;           GBL     name,type,value
;           GBL4    name,type,value
;           GBL8    name,type,value
;           EXT     name,type
;           EXT4    name,type
;           EXT8    name,type
;           F_DW    rout
;           F4_DW   rout
;           F8_DW   rout
;           F_JMP   rout
;           F4_JMP  rout
;           F8_JMP  rout
;           F_CALL  rout
;           F4_CALL rout
;           F8_CALL rout
;
;       Global names are considered to be names with the type and size prefix.
;       Local names have no prefix.  I.e., $I8_ONE and ONE, respectively.
;
;       Macros with a size in the name create local names with the size at the
;       end.  I.e., RESULT4
;

genhelp MACRO   typ,siz


;***    PUB     name
;
; Function:
;       PUB declares both the global and local names as labels.
;

pub     &MACRO   name
	public  $&typ&&siz&_&&name
$&typ&&siz&_&&name:
name:
	&ENDM


pub4    &MACRO   name
	public  $&typ&4_&&name
$&typ&4_&&name:
name&&4:
	&ENDM


pub8    &MACRO   name
	public  $&typ&8_&&name
$&typ&8_&&name:
name&&8:
	&ENDM

;***    PUBX     name
;
; Function:
;       PUBX declares both the global and local names as labels.
;	Added for MASM 5.0 compatibility.  Adds leading underscore
;	to local names to avoid conflict with MASM 5.0 reserved words.
;
pubx     &MACRO   name
	public  $&typ&&siz&_&&name
$&typ&&siz&_&&name:
_&&name:
	&ENDM

pub4x   &MACRO   name
	public  $&typ&4_&&name
$&typ&4_&&name:
_name&&4:
	&ENDM


pub8x   &MACRO   name
	public  $&typ&8_&&name
$&typ&8_&&name:
_name&&8:
	&ENDM

;***    GLB     name,type,value
;
; Function:
;       GLB declares the global name for the data value and aliases the local
;       name to it.
;

glb     &MACRO  name,type,value
	public  $&typ&&siz&_&&name
	lcl     $&typ&&siz&_&&name,type,<value>
name    equ     $&typ&&siz&_&&name
	&ENDM


glb4    &MACRO  name,type,value
	public  $&typ&4_&&name
	lcl     $&typ&4_&&name,type,<value>
name&&4 equ     $&typ&4_&&name
	&ENDM


glb8    &MACRO  name,type,value
	public  $&typ&8_&&name
	lcl     $&typ&8_&&name,type,<value>
name&&8 equ     $&typ&8_&&name
	&ENDM


;***    EXT     name,type
;
; Function:
;       EXT declares the global name to be external with the specified type.
;       It also aliases the local name to the global name.
;

ext     &MACRO  name,type
	extrn   $&typ&&siz&_&&name:type
name    equ     $&typ&&siz&_&&name
	&ENDM


ext4    &MACRO  name,type
	extrn   $&typ&4_&&name:type
name&&4 equ     $&typ&8_&&name
	&ENDM


ext8    &MACRO  name,type
	extrn   $&typ&8_&&name:type
name&&8 equ     $&typ&8_&&name
	&ENDM


;***    F_DW    name
;
; Function:
;       F_DW declares the code address of the global name
;

f_dw    &MACRO  name
	dwcp    $&typ&&siz&_&&name
	&ENDM


f4_dw   &MACRO  name
	dwcp    $&typ&4_&&name
	&ENDM


f8_dw   &MACRO  name
	dwcp    $&typ&8_&&name
	&ENDM


;***    F_CALL  name
;
; Function:
;       F_CALL declares the global name to be external and issues a call.
;

f_call  &MACRO  name
	extrn   $&typ&&siz&_&&name:near
	  call    $&typ&&siz&_&&name
	&ENDM


f4_call &MACRO  name
	extrn   $&typ&4_&&name:near
	  call    $&typ&4_&&name
	&ENDM


f8_call &MACRO  name
	extrn   $&typ&8_&&name:near
	  call    $&typ&8_&&name
	&ENDM


;***    F_JMP   name
;
; Function:
;       F_JMP declares the global name to be external and issues a jmp.
;

f_jmp   &MACRO  name
	extrn   $&typ&&siz&_&&name:near
	  jmp     $&typ&&siz&_&&name
	&ENDM


f4_jmp  &MACRO  name
	extrn   $&typ&4_&&name:near
	  jmp     $&typ&4_&&name
	&ENDM


f8_jmp  &MACRO  name
	extrn   $&typ&8_&&name:near
	  jmp     $&typ&8_&&name
	&ENDM


	ENDM                            ;; End of genhelp



;       Invoke GENHELP with the appropriate type and size information.

if      DecFmt
  if      Single
	  genhelp d,4
  else    ;;Double
	  genhelp d,8
  endif
endif

if      IEEEFmt
  if      Single
	  genhelp i,4
  else    ;;Double
	  genhelp i,8
  endif
endif

if      MBinFmt
  if      Single
	  genhelp m,4
  else    ;;Double
	  genhelp m,8
  endif
endif

	purge   genhelp                         ; toss genhelp macro


;       cs mover macros - generate code iff CSconst nonzero

movcssi macro
if      CSconst
	f_call  mvcssi
endif
	endm

movcsdi macro
if      CSconst
	f_call  mvcsdi
endif
	endm


movcnp  macro   dest,name,off
if  CSconst
	movcp   dest,name,off
else
	movp    dest,name,off
endif
	endm


;       f_movcs macro
;       f_mov   macro
;       f4_mov  macro
;       f8_mov  macro
;
; Special forms         f_mov
;
;       op1/DI          op2/SI          Routine         Res SI          Use
;
;       ARG             AC              movarg_ac       AC              DI
;       ARG             <>              movarg          SI              DI
;       AC              ARG             movac_arg       AC              DI
;       AC              <>              movac           AC              DI
;       TEMP            <>              movtemp         SI              DI
;       any             any             gen code        used            SI.DI
;
; Special forms         f_movcs
;
;       op1/DI          op2/SI          Routine         Res SI          Use
;
;       AC              any             gencode         AC              DI
;       any             any             gen code        used            SI.DI

f_movcs macro   op1,op2
if      CSconst
	movp    di,op1
	movcp   si,op2                ;; op2 is source
	&rept   DefWrd
	movs    word ptr es:[di],word ptr cs:[si]
	&endm
  ifidn <op1>,<AC>
	movp    si,AC
  endif
else
	f_mov   op1,op2
endif
	endm

f_mov   MACRO   op1,op2
ifidn   <op1>,<ARG>
  ifidn   <op2>,<AC>
	  f_call  movarg_ac
  else
    ifnb    <op2>
	  movp    si,op2                ;; op2 is source
    endif
	  f_call  movarg
  endif
else
  ifidn   <op1>,<AC>
    ifidn   <op2>,<ARG>
	  f_call  movac_arg
    else
      ifnb    <op2>
	  movp    si,op2                ;; op2 is source
      endif
	  f_call  movac
    endif
  else
    ifidn   <op1>,<TEMP>
      ifnb    <op2>
	  movp    si,op2                ;; op2 is source
      endif
	  f_call  movtemp
    else
      ifnb    <op1>
	  movp    di,op1                ;; op1 is dest
      endif
      ifnb    <op2>
	  movp    si,op2                ;; op2 is source
      endif
	  &rept    DefWrd
	    movsw
	  &endm
    endif
  endif
endif
	ENDM


f4_mov  MACRO   op1,op2
ifidn   <op1>,<ARG>
  ifidn   <op2>,<AC>
	  f4_call movarg_ac
  else
    ifnb    <op2>
	  movp    si,op2                ;; op2 is source
    endif
	  f4_call movarg
  endif
else
  ifidn   <op1>,<AC>
    ifidn   <op2>,<ARG>
	  f4_call movac_arg
    else
      ifnb    <op2>
	  movp    si,op2                ;; op2 is source
      endif
	  f4_call movac
    endif
  else
    ifidn   <op1>,<TEMP>
      ifnb    <op2>
	  movp    si,op2                ;; op2 is source
      endif
	  f4_call movtemp
    else
      ifnb    <op1>
	  movp    di,op1                ;; op1 is dest
      endif
      ifnb    <op2>
	  movp    si,op2                ;; op2 is source
      endif
	  movsw
	  movsw
    endif
  endif
endif
	ENDM


f8_mov  MACRO   op1,op2
ifidn   <op1>,<ARG>
  ifidn   <op2>,<AC>
	  f8_call movarg_ac
  else
    ifnb    <op2>
	  movp    si,op2                ;; op2 is source
    endif
	  f8_call movarg
  endif
else
  ifidn   <op1>,<AC>
    ifidn   <op2>,<ARG>
	  f8_call movac_arg
    else
      ifnb    <op2>
	  movp    si,op2                ;; op2 is source
      endif
	  f8_call movac
    endif
  else
    ifidn   <op1>,<TEMP>
      ifnb    <op2>
	  movp    si,op2                ;; op2 is source
      endif
	  f8_call movtemp
    else
      ifnb    <op1>
	  movp    di,op1                ;; op1 is dest
      endif
      ifnb    <op2>
	  movp    si,op2                ;; op2 is source
      endif
	  movsw
	  movsw
	  movsw
	  movsw
    endif
  endif
endif
	ENDM


;       f_push  macro
;
; Special forms
;
;       op1             Routine         Res SI          Use
;
;       AC              pushac          AC              AX
;       ARG             pusharg         ARG             AX
;       SI              pushsi          SI              AX
;       any             gen code        SI              ---

f_push  MACRO   op1
ifidn   <op1>,<AC>
	  f_call   pshac
else
  ifidn   <op1>,<ARG>
	  f_call   psharg
  else
    ifidn   <op1>,<SI>
	  f_call   pshsi
    else
      if      Double
	  push    [op1+6]
	  push    [op1+4]
      endif
	  push    [op1+2]
	  push    [op1]
    endif
  endif
endif
	ENDM


;       f_pop   macro
;
; Special forms
;
;       op1             Routine         Res SI          Use
;
;       AC              popac           AC              AX
;       ARG             poparg          ARG             AX
;       SI              popsi           SI              AX
;       any             gen code        SI              ---

f_pop   MACRO   op1
ifidn   <op1>,<AC>
	  f_call   popac
else
  ifidn   <op1>,<ARG>
	  f_call   poparg
  else
    ifidn   <op1>,<SI>
	  f_call   popsi
    else
	  pop     [op1]
	  pop     [op1+2]
      if      Double
	  pop     [op1+4]
	  pop     [op1+6]
      endif
    endif
  endif
endif
	ENDM


;       f_opr    macro
;
; Special forms
;
;       op1/SI          op2/DI          routine         operations
;
;       AC              ARG             xxxf            add,sub,mul,div,cmp
;       <>              ARG             xxxfsi          add,sub,mul,div,cmp
;       ARG             AC              xxxr            sub,div,cmp
;       ARG             <>              xxxrdi          sub,div,cmp
;       any             any             gen moves and call

genoper  MACRO   op
f_&op   &MACRO  op1,op2
ifidn   <op2>,<ARG>
  ifidn   <op1>,<AC>
	  f_call   op&f
  else
    ifb     <op1>
	  f_call   op&fsi
    else
	  movp    si,op1
	  movp    di,ARG
	  f_call   op
    endif
  endif
else
  ifidn   <op1>,<ARG>
    ifidn   <op2>,<AC>
	  f_call   op&r
    else
      ifb     <op2>
	  f_call   op&rdi
      else
	  movp    si,ARG
	  movp    di,op2
	  f_call   op
      endif
    endif
  else
    ifnb    <op1>
	  movp    si,op1
    endif
    ifnb    <op2>
	  movp    di,op2
    endif
	  f_call   op
  endif
endif
	&ENDM
	ENDM

genoper add
genoper sub
genoper mul
genoper div
genoper cmp

	purge   genoper


endif   ; Pass 1

;---------------        End of Standard MATHMAC.INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\inc\i386\mrt386.inc ===
;***
;mrt386.inc - include to aid in generating 386 code
;
;	Copyright (c) 1988-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	This file reproduces a few of the cMacro macros.
;
;Revision History:
;	08-24-88  WAJ	Initial version.
;
;*******************************************************************************



ifdef  I386		    ; Define Near Code Pointer
    DNCPTR  equ     <dd>
else
    DNCPTR  equ     <dw>
endif


ifdef  I386
    if	sizeD
	DPWORD	equ  <fword>
    else
	DPWORD	equ  <dword>
    endif
    DFPWORD  equ  <fword>
    DNPWORD  equ  <dword>

else	;not I386
    if	sizeD
	DPWORD	equ  <dword>
    else
	DPWORD	equ  <word>
    endif
    DFPWORD  equ  <dword>
    DNPWORD  equ  <word>
endif	;not I386


ifdef  I386
    if	sizeC
	CPWORD	equ  <fword>
    else
	CPWORD	equ  <dword>
    endif
    CFPWORD  equ  <fword>
    CNPWORD  equ  <dword>

else	;not I386
    if	sizeC
	CPWORD	equ  <dword>
    else
	CPWORD	equ  <word>
    endif
    CFPWORD  equ  <dword>
    CNPWORD  equ  <word>
endif	;not I386



MOVRW	macro	reg, word   ;; move a word into a register
ifdef  I386
%	movzx	reg, (word)
else
%	mov	reg, (word)
endif
	endm


ifdef  I386
RBXONLY equ	<rbx>
RBXUSED equ	<rbx>

else	;not I386
RBXONLY equ	<nothing>
RBXUSED equ	<>
endif	;not I386


ifdef I386
    ife sizeC
	ife sizeD
	    FLAT386 equ <DEFINED>
	endif
    endif
endif

ifflat	macro code
ifdef  FLAT386
	code
endif
	endm


noflat	macro code
ifndef	FLAT386
	code
endif
	endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\inc\i386\version.inc ===
;***
;version.inc - defines current memory model
;
;   Copyright (c) 1987-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;   This file defines the current memory model being used.
;
;Revision History:
;   10-22-87  JCR   Single version to handle all four memory models
;   02-11-88  WAJ   Added to math project
;   12-02-88  WAJ   Added definition of CallDist
;   09-22-89  WAJ   Removed CallDist.  Added "ifdef WIN".
;   10-16-89  WAJ   Added "?WIN = 1".
;   11-20-89  WAJ   Added ?QUIET
;
;*******************************************************************************

?PLM = 0

ifdef  WIN
    ?WIN = 1
else
    ?WIN = 0
endif

ifdef  mem_s
    memS    equ     1		    ; small model
endif

ifdef  mem_c
    memC    equ     1		    ; compact model
endif

ifdef  mem_m
    memM    equ     1		    ; medium model
endif

ifdef  mem_l
    memL    equ     1		    ; large model
endif

ifdef  I386
    memS32  equ     1		    ; small 32 bit model
endif

ifdef  QUIET
    ?QUIET  equ     1
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\include\cv.h ===
/***
*cv.h - definitions for floating point conversion
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   define types, macros, and constants used in floating point
*   conversion routines
*
*Revision History:
*       07-17-91  GDP   initial version
*       09-21-91  GDP   restructured 'ifdef' directives
*       10-29-91  GDP   MIPS port: new defs for ALIGN and DOUBLE
*       03-03-92  GDP   removed os2 16-bit stuff
*       04-30-92  GDP   support intrncvt.c --cleanup and reorganize
*       05-13-92  XY    fixed B_END macros
*       06-16-92  GDP   merged changes from \\orville and \\vangogh trees
*       09-05-92  GDP   included fltintrn.h, new calling convention macros
*       04-06-93  SKS   Replace _CALLTYPE* with __cdecl
*       07-16-93  SRW   ALPHA Merge
*       11-17-93  GJF   Merged in NT version. Replaced _ALPHA_ with _M_ALPHA,
*                       MIPS with _M_MRX000, MTHREAD with _MT, and deleted
*                       M68K stuff.
*       10-02-94  BWT   PPC merge
*       02-06-95  JWM   Mac merge
*       10-07-97  RDL   Added IA64.
*       05-05-99  RDL   Added _M_IA64 to #if def's for alignment.
*       05-13-99  PML   Remove _CRTAPI1
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#ifndef _INC_CV

#ifdef __cplusplus
extern "C" {
#endif

#include <cruntime.h>

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#include <fltintrn.h>


/* define little endian or big endian memory */

#if     defined(_M_IX86) || defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64) || defined(_M_AMD64)
#define L_END
#endif

typedef unsigned char   u_char;   /* should have 1 byte */
typedef char            s_char;   /* should have 1 byte */
typedef unsigned short  u_short;  /* should have 2 bytes */
typedef signed short    s_short;  /* should have 2 bytes */
typedef unsigned int    u_long;   /* sholuld have 4 bytes */
typedef int             s_long;   /* sholuld have 4 bytes */

/* calling conventions */
#define _CALLTYPE5


/*
 * defining _LDSUPPORT enables using long double computations
 * for string conversion. We do not do this even for i386,
 * since we want to avoid using floating point code that
 * may generate IEEE exceptions.
 *
 * Currently our string conversion routines do not conform
 * to the special requirements of the IEEE standard for
 * floating point conversions
 */


#ifndef _LDSUPPORT

#pragma pack(4)
typedef struct {
    u_char ld[10];
} _LDOUBLE;
#pragma pack()

#define PTR_LD(x) ((u_char  *)(&(x)->ld))

#else

typedef long double _LDOUBLE;

#define PTR_LD(x) ((u_char  *)(x))

#endif


#pragma pack(4)
typedef struct {
    u_char ld12[12];
} _LDBL12;
#pragma pack()

typedef struct {
    float f;
} FLOAT;



/*
 * return values for internal conversion routines
 * (12-byte to long double, double, or float)
 */

typedef enum {
    INTRNCVT_OK,
    INTRNCVT_OVERFLOW,
    INTRNCVT_UNDERFLOW
} INTRNCVT_STATUS;


/*
 * return values for strgtold12 routine
 */

#define SLD_UNDERFLOW 1
#define SLD_OVERFLOW 2
#define SLD_NODIGITS 4

#define MAX_MAN_DIGITS 21


/* specifies '%f' format */

#define SO_FFORMAT 1

typedef  struct _FloatOutStruct {
                    short   exp;
                    char    sign;
                    char    ManLen;
                    char    man[MAX_MAN_DIGITS+1];
                    } FOS;



#define PTR_12(x) ((u_char  *)(&(x)->ld12))

#define MAX_USHORT  ((u_short)0xffff)
#define MSB_USHORT  ((u_short)0x8000)
#define MAX_ULONG   ((u_long)0xffffffff)
#define MSB_ULONG   ((u_long)0x80000000)

#define TMAX10 5200       /* maximum temporary decimal exponent */
#define TMIN10 -5200      /* minimum temporary decimal exponent */
#define LD_MAX_EXP_LEN 4  /* maximum number of decimal exponent digits */
#define LD_MAX_MAN_LEN 24  /* maximum length of mantissa (decimal)*/
#define LD_MAX_MAN_LEN1 25 /* MAX_MAN_LEN+1 */

#define LD_BIAS 0x3fff    /* exponent bias for long double */
#define LD_BIASM1 0x3ffe  /* LD_BIAS - 1 */
#define LD_MAXEXP 0x7fff  /* maximum biased exponent */

#define D_BIAS  0x3ff    /* exponent bias for double */
#define D_BIASM1 0x3fe  /* D_BIAS - 1 */
#define D_MAXEXP 0x7ff  /* maximum biased exponent */


/*
 * end of definitions from crt32\h\fltintrn.h
 */

/* Recognizing special patterns in the mantissa field */
#define _EXP_SP  0x7fff
#define NAN_BIT (1<<30)

#define _IS_MAN_INF(signbit, manhi, manlo) \
        ( (manhi)==MSB_ULONG && (manlo)==0x0 )


/* i386 and Alpha use same NaN format */
#if     defined(_M_IX86) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64) || defined(_M_AMD64)
#define _IS_MAN_IND(signbit, manhi, manlo) \
        ((signbit) && (manhi)==0xc0000000 && (manlo)==0)

#define _IS_MAN_QNAN(signbit, manhi, manlo) \
        ( (manhi)&NAN_BIT )

#define _IS_MAN_SNAN(signbit, manhi, manlo) \
        (!( _IS_MAN_INF(signbit, manhi, manlo) || \
           _IS_MAN_QNAN(signbit, manhi, manlo) ))


#elif defined(_M_MRX000) 
#define _IS_MAN_IND(signbit, manhi, manlo) \
        (!(signbit) && (manhi)==0xbfffffff && (manlo)==0xfffff800)

#define _IS_MAN_SNAN(signbit, manhi, manlo) \
        ( (manhi)&NAN_BIT )

#define _IS_MAN_QNAN(signbit, manhi, manlo) \
        (!( _IS_MAN_INF(signbit, manhi, manlo) || \
           _IS_MAN_SNAN(signbit, manhi, manlo) ))
#endif



#if     defined (L_END) && !( defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64) )
/* "little endian" memory */
/* Note: MIPS and Alpha have alignment requirements and have different
 * macros */
/*
 * Manipulation of a 12-byte long double number (an ordinary
 * 10-byte long double plus two extra bytes of mantissa).
 */
/*
 * byte layout:
 *
 *              +-----+--------+--------+-------+
 *              |XT(2)|MANLO(4)|MANHI(4)|EXP(2) |
 *              +-----+--------+--------+-------+
 *              |<-UL_LO->|<-UL_MED->|<-UL_HI ->|
 *                  (4)       (4)        (4)
 */

/* a pointer to the exponent/sign portion */
#define U_EXP_12(p) ((u_short  *)(PTR_12(p)+10))

/* a pointer to the 4 hi-order bytes of the mantissa */
#define UL_MANHI_12(p) ((u_long  *)(PTR_12(p)+6))

/* a pointer to the 4 lo-order bytes of the ordinary (8-byte) mantissa */
#define UL_MANLO_12(p) ((u_long  *)(PTR_12(p)+2))

/* a pointer to the 2 extra bytes of the mantissa */
#define U_XT_12(p) ((u_short  *)PTR_12(p))

/* a pointer to the 4 lo-order bytes of the extended (10-byte) mantissa */
#define UL_LO_12(p) ((u_long  *)PTR_12(p))

/* a pointer to the 4 mid-order bytes of the extended (10-byte) mantissa */
#define UL_MED_12(p) ((u_long  *)(PTR_12(p)+4))

/* a pointer to the 4 hi-order bytes of the extended long double */
#define UL_HI_12(p) ((u_long  *)(PTR_12(p)+8))

/* a pointer to the byte of order i (LSB=0, MSB=9)*/
#define UCHAR_12(p,i) ((u_char  *)PTR_12(p)+(i))

/* a pointer to a u_short with offset i */
#define USHORT_12(p,i) ((u_short  *)((u_char  *)PTR_12(p)+(i)))

/* a pointer to a u_long with offset i */
#define ULONG_12(p,i) ((u_long  *)((u_char  *)PTR_12(p)+(i)))

/* a pointer to the 10 MSBytes of a 12-byte long double */
#define TEN_BYTE_PART(p) ((u_char  *)PTR_12(p)+2)

/*
 * Manipulation of a 10-byte long double number
 */
#define U_EXP_LD(p) ((u_short  *)(PTR_LD(p)+8))
#define UL_MANHI_LD(p) ((u_long  *)(PTR_LD(p)+4))
#define UL_MANLO_LD(p) ((u_long  *)PTR_LD(p))

/*
 * Manipulation of a 64bit IEEE double
 */
#define U_SHORT4_D(p) ((u_short  *)(p) + 3)
#define UL_HI_D(p) ((u_long  *)(p) + 1)
#define UL_LO_D(p) ((u_long  *)(p))

#endif

/* big endian */
#if defined (B_END)

/*
 * byte layout:
 *
 *              +------+-------+---------+------+
 *              |EXP(2)|MANHI(4)|MANLO(4)|XT(2) |
 *              +------+-------+---------+------+
 *              |<-UL_HI->|<-UL_MED->|<-UL_LO ->|
 *                  (4)       (4)        (4)
 */


#define U_EXP_12(p) ((u_short  *)PTR_12(p))
#define UL_MANHI_12(p) ((u_long  *)(PTR_12(p)+2))
#define UL_MANLO_12(p) ((u_long  *)(PTR_12(p)+6))
#define U_XT_12(p) ((u_short  *)(PTR_12(p)+10))

#define UL_LO_12(p) ((u_long  *)(PTR_12(p)+8))
#define UL_MED_12(p) ((u_long  *)(PTR_12(p)+4))
#define UL_HI_12(p) ((u_long  *)PTR_12(p))

#define UCHAR_12(p,i) ((u_char  *)PTR_12(p)+(11-(i)))
#define USHORT_12(p,i)  ((u_short  *)((u_char  *)PTR_12(p)+10-(i)))
#define ULONG_12(p,i) ((u_long  *)((u_char  *)PTR_12(p)+8-(i)))
#define TEN_BYTE_PART(p) (u_char  *)PTR_12(p)

#define U_EXP_LD(p) ((u_short  *)PTR_LD(p))
#define UL_MANHI_LD(p) ((u_long  *)(PTR_LD(p)+2))
#define UL_MANLO_LD(p) ((u_long  *)(PTR_LD(p)+6))

/*
 * Manipulation of a 64bit IEEE double
 */
#define U_SHORT4_D(p) ((u_short  *)(p))
#define UL_HI_D(p) ((u_long  *)(p))
#define UL_LO_D(p) ((u_long  *)(p) + 1)

#endif

#if     defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)

#define ALIGN(x)  ( (unsigned long  __unaligned *) (x))

#define U_EXP_12(p) ((u_short  *)(PTR_12(p)+10))

#define UL_MANHI_12(p) ((u_long  __unaligned *) (PTR_12(p)+6) )
#define UL_MANLO_12(p) ((u_long  __unaligned *) (PTR_12(p)+2) )


#define U_XT_12(p) ((u_short  *)PTR_12(p))
#define UL_LO_12(p) ((u_long  *)PTR_12(p))
#define UL_MED_12(p) ((u_long  *)(PTR_12(p)+4))
#define UL_HI_12(p) ((u_long  *)(PTR_12(p)+8))

/* the following 3 macros do not take care of proper alignment */
#define UCHAR_12(p,i) ((u_char  *)PTR_12(p)+(i))
#define USHORT_12(p,i) ((u_short  *)((u_char  *)PTR_12(p)+(i)))
#define ULONG_12(p,i) ((u_long  *) ((u_char  *)PTR_12(p)+(i) ))

#define TEN_BYTE_PART(p) ((u_char  *)PTR_12(p)+2)

/*
 * Manipulation of a 10-byte long double number
 */
#define U_EXP_LD(p) ((u_short  *)(PTR_LD(p)+8))

#define UL_MANHI_LD(p) ((u_long  *) (PTR_LD(p)+4) )
#define UL_MANLO_LD(p) ((u_long  *) PTR_LD(p) )

/*
 * Manipulation of a 64bit IEEE double
 */
#define U_SHORT4_D(p) ((u_short  *)(p) + 3)
#define UL_HI_D(p) ((u_long  *)(p) + 1)
#define UL_LO_D(p) ((u_long  *)(p))

#endif


#define PUT_INF_12(p,sign) \
                  *UL_HI_12(p) = (sign)?0xffff8000:0x7fff8000; \
                  *UL_MED_12(p) = 0; \
                  *UL_LO_12(p) = 0;

#define PUT_ZERO_12(p) *UL_HI_12(p) = 0; \
                  *UL_MED_12(p) = 0; \
                  *UL_LO_12(p) = 0;

#define ISZERO_12(p) ((*UL_HI_12(p)&0x7fffffff) == 0 && \
                      *UL_MED_12(p) == 0 && \
                      *UL_LO_12(p) == 0 )

#define PUT_INF_LD(p,sign) \
                  *U_EXP_LD(p) = (sign)?0xffff:0x7fff; \
                  *UL_MANHI_LD(p) = 0x8000; \
                  *UL_MANLO_LD(p) = 0;

#define PUT_ZERO_LD(p) *U_EXP_LD(p) = 0; \
                  *UL_MANHI_LD(p) = 0; \
                  *UL_MANLO_LD(p) = 0;

#define ISZERO_LD(p) ((*U_EXP_LD(p)&0x7fff) == 0 && \
                      *UL_MANHI_LD(p) == 0 && \
                      *UL_MANLO_LD(p) == 0 )


/*********************************************************
 *
 *   Function Prototypes
 *
 *********************************************************/

/* from mantold.c */
void _CALLTYPE5 __mtold12(char  *manptr, unsigned manlen,_LDBL12 *ld12);
int  _CALLTYPE5 __addl(u_long x, u_long y, u_long  *sum);
void _CALLTYPE5 __shl_12(_LDBL12  *ld12);
void _CALLTYPE5 __shr_12(_LDBL12  *ld12);
void _CALLTYPE5 __add_12(_LDBL12  *x, _LDBL12  *y);

/* from tenpow.c */
void _CALLTYPE5 __multtenpow12(_LDBL12  *pld12,int pow, unsigned mult12);
void _CALLTYPE5 __ld12mul(_LDBL12  *px, _LDBL12  *py);

/* from strgtold.c */
unsigned int __strgtold12(_LDBL12 *pld12,
            const char * *p_end_ptr,
            const char * str,
            int mult12,
            int scale,
            int decpt,
            int implicit_E);

unsigned _CALLTYPE5 __STRINGTOLD(_LDOUBLE *pld,
            const char  * *p_end_ptr,
            const char  *str,
            int mult12);


/* from x10fout.c */
/* this is defined as void in convert.h
 * After porting the asm files to c, we need a return value for
 * i10_output, that used to reside in reg. ax
 */
int _CALLTYPE5  $I10_OUTPUT(_LDOUBLE ld, int ndigits,
                    unsigned output_flags, FOS  *fos);


/* for cvt.c and fltused.c */
/* The following functions are #defined as macros in fltintrn.h */
#undef _cfltcvt
#undef _cropzeros
#undef _fassign
#undef _forcdecpt
#undef _positive

void __cdecl _cfltcvt(double *arg, char *buffer,
                         int format, int precision,
                         int caps);
void __cdecl _cropzeros(char *buf);
void __cdecl _fassign(int flag, char  *argument, char *number);
void __cdecl _forcdecpt(char *buf);
int __cdecl _positive(double *arg);

/* from intrncvt.c */
void _atodbl(DOUBLE *d, char *str);
void _atoldbl(_LDOUBLE *ld, char *str);
void _atoflt(FLOAT *f, char *str);
INTRNCVT_STATUS _ld12tod(_LDBL12 *ifp, DOUBLE *d);
INTRNCVT_STATUS _ld12tof(_LDBL12 *ifp, FLOAT *f);
INTRNCVT_STATUS _ld12told(_LDBL12 *ifp, _LDOUBLE *ld);

#ifdef __cplusplus
}
#endif

#define _INC_CV
#endif  /* _INC_CV */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\include\testfdiv.h ===
/***
* testfdiv.h - user include file for detection of flawed Pentium chips.
*
*   Copyright (c) 1994-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*   User include file for detection of early steppings of
*   Pentium chips with incorrect FDIV tables.
*
*Revision History:
*	12-19-94  JWM	file added
*	 1-13-95  JWM	underscores added to prototypes for ANSI compatibility
*/


#ifndef _TEST_FDIV
#define _TEST_FDIV

#ifdef __cplusplus
extern "C" {
#endif


int _ms_p5_test_fdiv();
int _ms_p5_mp_test_fdiv();

#ifdef __cplusplus
}
#endif

#endif	/* _TEST_FDIV */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\atan.c ===
/***
*atan.c - arctangent of x and x/y
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-15-91  GDP   written
*       12-30-91  GDP   support IEEE exceptions
*        3-27-92  GDP   support UNDERFLOW
*       02-06-95  JWM   Mac merge
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

#if defined(_M_IA64)
#pragma function(atan, atan2)
#endif

static double _atanhlp(double x);

static double const a[4] = {
    0.0,
    0.52359877559829887308,   /* pi/6 */
    1.57079632679489661923,   /* pi/2 */
    1.04719755119659774615    /* pi/3 */
};

/* constants */
static double const EPS = 1.05367121277235079465e-8; /* 2^(-53/2) */
static double const PI_OVER_TWO = 1.57079632679489661923;
static double const PI          = 3.14159265358979323846;
static double const TWO_M_SQRT3 = 0.26794919243112270647;
static double const SQRT3_M_ONE = 0.73205080756887729353;
static double const SQRT3       = 1.73205080756887729353;

/* chose MAX_ARG s.t. 1/MAX_ARG does not underflow */
static double const MAX_ARG     = 4.494232837155790e+307;

/* constants for rational approximation */
static double const p0 = -0.13688768894191926929e+2;
static double const p1 = -0.20505855195861651981e+2;
static double const p2 = -0.84946240351320683534e+1;
static double const p3 = -0.83758299368150059274e+0;
static double const q0 =  0.41066306682575781263e+2;
static double const q1 =  0.86157349597130242515e+2;
static double const q2 =  0.59578436142597344465e+2;
static double const q3 =  0.15024001160028576121e+2;
static double const q4 =  0.10000000000000000000e+1;


#define Q(g)  (((((g) + q3) * (g) + q2) * (g) + q1) * (g) + q0)
#define R(g)  ((((p3 * (g) + p2) * (g) + p1) * (g) + p0) * (g)) / Q(g)

/***
*double atan(double x) - arctangent
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*   P, I
\*******************************************************************************/
double atan(double x)
{
    uintptr_t savedcw;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        switch(_sptype(x)) {
        case T_PINF:
            result = PI_OVER_TWO;
            break;
        case T_NINF:
            result = -PI_OVER_TWO;
            break;
        case T_QNAN:
            return _handle_qnan1(OP_ATAN,x,savedcw);
        default: //T_SNAN
            return _except1(FP_I,OP_ATAN,x,_s2qnan(x),savedcw);
        }
    }

    if (x == 0.0)
        RETURN(savedcw,x);

    result = _atanhlp(x);
    RETURN_INEXACT1(OP_ATAN,x,result,savedcw);
}

/***
*double atan2(double x, double y) - arctangent (x/y)
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*    NAN or both args 0: DOMAIN error
*******************************************************************************/
double atan2(double v, double u)
{
    uintptr_t savedcw;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(v) || IS_D_SPECIAL(u)){
        if (IS_D_SNAN(v) || IS_D_SNAN(u)){
            return _except2(FP_I,OP_ATAN2,v,u,_d_snan2(v,u),savedcw);
        }
        if (IS_D_QNAN(v) || IS_D_QNAN(u)){
            return _handle_qnan2(OP_ATAN2,v,u,savedcw);
        }
        if ((IS_D_INF(v) || IS_D_MINF(v)) &&
            (IS_D_INF(u) || IS_D_MINF(u))){
            return _except2(FP_I,OP_ATAN2,v,u,QNAN_ATAN2,savedcw);
        }
        /* the other combinations of infinities will be handled
         * later by the division v/u
         */
    }


    if (u == 0) {
        if (v == 0) {
            return _except2(FP_I,OP_ATAN2,v,u,QNAN_ATAN2,savedcw);
        }
        else {
            result = PI_OVER_TWO;
        }
    }
    else if (INTEXP(v) - INTEXP(u) > MAXEXP - 3) {
        /* v/u overflow */
        result = PI_OVER_TWO;
    }
    else {
        double arg = v/u;


        if (ABS(arg) < D_MIN) {

            if (v == 0.0 || IS_D_INF(u) || IS_D_MINF(u)) {
                result = (u < 0) ? PI : 0;
                if (v < 0) {
                    result = -result;
                }
                if (result == 0) {
                     RETURN(savedcw,  result);
                }
                else {
                     RETURN_INEXACT2(OP_ATAN2,v,u,result,savedcw);
                }
            }
            else {

                double v1, u1;
                int vexp, uexp;
                int exc_flags;

                //
                // in this case an underflow has occurred
                // re-compute the result in order to raise
                // an IEEE underflow exception
                //

                if (u < 0) {
                    result = v < 0 ? -PI: PI;
                    RETURN_INEXACT2(OP_ATAN2,v,u,result,savedcw);
                }

                v1 = _decomp(v, &vexp);
                u1 = _decomp(u, &uexp);
                result = _add_exp(v1/u1, vexp-uexp+IEEE_ADJUST);
                result = ABS(result);

                if (v < 0) {
                    result = -result;
                }

                // this is not a perfect solution. In the future
                // we may want to have a way to let the division
                // generate an exception and propagate the IEEE result
                // to the user's handler

                exc_flags = FP_U;
                if (_statfp() & ISW_INEXACT) {
                    exc_flags  |= FP_P;
                }
                return _except2(exc_flags,OP_ATAN2,v,u,result,savedcw);

            }
        }

        else {
           result = _atanhlp( ABS(arg) );
        }

    }

    /* set sign of the result */
    if (u < 0) {
        result = PI - result;
    }
    if (v < 0) {
        result = -result;
    }


    RETURN_INEXACT2(OP_ATAN2,v,u,result,savedcw);
}





/***
*double _atanhlp(double x) - arctangent helper
*
*Purpose:
*   Compute arctangent of x, assuming x is a valid, non infinite
*   number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
static double _atanhlp(double x)
{
    double f,g,result;
    int n;


    f = ABS(x);
    if (f > MAX_ARG) {
        // if this step is ommited, 1.0/f might underflow in the
        // following block
        return x > 0.0 ? PI_OVER_TWO : -PI_OVER_TWO;
    }
    if (f > 1.0) {
        f = 1.0/f;
        n = 2;
    }
    else {
        n = 0;
    }

    if (f > TWO_M_SQRT3) {
        f = (((SQRT3_M_ONE * f - .5) - .5) + f) / (SQRT3 + f);
        n++;
    }

    if (ABS(f) < EPS) {
        result = f;
    }
    else {
        g = f*f;
        result = f + f * R(g);
    }

    if (n > 1)
        result = -result;

    result += a[n];

    if (x < 0.0)
        result = -result;


    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\include\trans.h ===
/***
*trans.h - definitions for computing transcendentals
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Define constants and macros that are used for computing
*       transcendentals. Some of the definitions are machine dependent.
*       Double is assumed to conform to the IEEE 754 std format.
*
*Revision History:
*       08-14-91  GDP   written
*       10-29-91  GDP   removed unused prototypes, added _frnd
*       01-20-92  GDP   significant changes -- IEEE exc. support
*       03-27-92  GDP   put IEEE definitions in fpieee.h
*       03-31-92  GDP   add internal constants for _ctrlfp, _statfp
*       05-08-92  PLM   added M68K switch
*       05-18-92  XY    added exception macro under M68K switch
*       06-23-92  GDP   added macro for negative zero
*       09-06-92  GDP   include cruntime.h, calling convention macros
*       07-16-93  SRW   ALPHA Merge
*       11-17-93  GJF   Merged in NT SDK version. Replaced MIPS with
*                       _M_MRX000, _ALPHA_ with _M_ALPHA, deleted old M68K
*                       stuff (obsolete).
*       01-13-94  RDL   Added #ifndef _LANGUAGE_ASSEMBLY for asm includes.
*       01-25-94  GJF   Merged in 01-13 change above from Roger Lanser (from
*                       fp32 tree on \\orville\razzle).
*       03-11-94  GJF   Picked up latest changes from Dec (from fp32 tree
*                       on \\orville\razzle for Alpha build).
*       10-02-94  BWT   PPC merge
*       02-06-95  JWM   Mac merge
*       02-07-95  JWM   powhlp() prototype restored to Intel version.
*       10-07-97  RDL   Added IA64.
*       05-13-99  PML   Remove _CRTAPI1
*       05-17-99  PML   Remove all Macintosh support.
*       10-06-99  PML   Add _W64 modifier to types which are 32 bits in Win32,
*                       64 bits in Win64.
*       04-30-01  BWT   AMD64 change from DaveC
*
*******************************************************************************/

#ifndef _INC_TRANS

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __assembler     /* MIPS ONLY: Protect from assembler */

#include <cruntime.h>

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif


#include <fpieee.h>

#define D_BIASM1 0x3fe /* off by one to compensate for the implied bit */

#ifdef B_END
/* big endian */
#define D_EXP(x) ((unsigned short *)&(x))
#define D_HI(x) ((unsigned long *)&(x))
#define D_LO(x) ((unsigned long *)&(x)+1)
#else
#define D_EXP(x) ((unsigned short *)&(x)+3)
#define D_HI(x) ((unsigned long *)&(x)+1)
#define D_LO(x) ((unsigned long *)&(x))
#endif

/* return the int representation of the exponent
 * if x = .f * 2^n, 0.5<=f<1, return n (unbiased)
 * e.g. INTEXP(3.0) == 2
 */
#define INTEXP(x) ((signed short)((*D_EXP(x) & 0x7ff0) >> 4) - D_BIASM1)


/* check for infinity, NAN */
#define D_ISINF(x) ((*D_HI(x) & 0x7fffffff) == 0x7ff00000 && *D_LO(x) == 0)
#define IS_D_SPECIAL(x) ((*D_EXP(x) & 0x7ff0) == 0x7ff0)
#define IS_D_NAN(x) (IS_D_SPECIAL(x) && !D_ISINF(x))

#ifdef  _M_MRX000

#define IS_D_SNAN(x)    ((*D_EXP(x) & 0x7ff8) == 0x7ff8)
#define IS_D_QNAN(x)    ((*D_EXP(x) & 0x7ff8) == 0x7ff0 && \
                         (*D_HI(x) << 13 || *D_LO(x)))
#else

#define IS_D_QNAN(x)    ((*D_EXP(x) & 0x7ff8) == 0x7ff8)
#define IS_D_SNAN(x)    ((*D_EXP(x) & 0x7ff8) == 0x7ff0 && \
                         (*D_HI(x) << 13 || *D_LO(x)))
#endif

#define IS_D_DENORM(x)  ((*D_EXP(x) & 0x7ff0) == 0  && \
                         (*D_HI(x) << 12 || *D_LO(x)))


#define IS_D_INF(x)  (*D_HI(x) == 0x7ff00000 && *D_LO(x) == 0)
#define IS_D_MINF(x) (*D_HI(x) == 0xfff00000 && *D_LO(x) == 0)


#ifdef  _M_MRX000
#define D_IND_HI 0x7ff7ffff
#define D_IND_LO 0xffffffff
#else
#define D_IND_HI 0xfff80000
#define D_IND_LO 0x0
#endif


typedef union   {
    long lng[2];
    double dbl;
    } _dbl;

extern _dbl _d_inf;
extern _dbl _d_ind;
extern _dbl _d_max;
extern _dbl _d_min;
extern _dbl _d_mzero;

#define D_INF  (_d_inf.dbl)
#define D_IND  (_d_ind.dbl)
#define D_MAX  (_d_max.dbl)
#define D_MIN  (_d_min.dbl)
#define D_MZERO (_d_mzero.dbl)       /* minus zero */

/* min and max exponents for normalized numbers in the
 * form: 0.xxxxx... * 2^exp (NOT 1.xxxx * 2^exp !)
 */
#define MAXEXP 1024
#define MINEXP -1021

#endif  /* #ifndef __assembler */


#if defined(_M_IX86)

/* Control word for computation of transcendentals */
#define ICW        0x133f

#define IMCW       0xffff

#define IMCW_EM         0x003f          /* interrupt Exception Masks */
#define IEM_INVALID     0x0001          /*   invalid */
#define IEM_DENORMAL    0x0002          /*   denormal */
#define IEM_ZERODIVIDE  0x0004          /*   zero divide */
#define IEM_OVERFLOW    0x0008          /*   overflow */
#define IEM_UNDERFLOW   0x0010          /*   underflow */
#define IEM_INEXACT     0x0020          /*   inexact (precision) */


#define IMCW_RC 0x0c00                  /* Rounding Control */
#define IRC_CHOP        0x0c00          /*   chop */
#define IRC_UP          0x0800          /*   up */
#define IRC_DOWN        0x0400          /*   down */
#define IRC_NEAR        0x0000          /*   near */

#define ISW_INVALID     0x0001          /* invalid */
#define ISW_DENORMAL    0x0002          /* denormal */
#define ISW_ZERODIVIDE  0x0004          /* zero divide */
#define ISW_OVERFLOW    0x0008          /* overflow */
#define ISW_UNDERFLOW   0x0010          /* underflow */
#define ISW_INEXACT     0x0020          /* inexact (precision) */

#define IMCW_PC         0x0300          /* Precision Control */
#define IPC_24          0x0000          /*    24 bits */
#define IPC_53          0x0200          /*    53 bits */
#define IPC_64          0x0300          /*    64 bits */

#define IMCW_IC         0x1000          /* Infinity Control */
#define IIC_AFFINE      0x1000          /*   affine */
#define IIC_PROJECTIVE  0x0000          /*   projective */

#elif defined(_M_AMD64)

/* Control word for computation of transcendentals */
#define ICW         (IMCW_EM | IRC_NEAR)
#define ISW         (ISW_INEXACT | ISW_UNDERFLOW | ISW_OVERFLOW | ISW_ZERODIVIDE | ISW_INVALID | ISW_DENORMAL)

#define IMCW        (0xffff ^ ISW)

#define IMCW_EM         0x1f80          /* interrupt Exception Masks */
#define IEM_INVALID     0x0080          /*   invalid */
#define IEM_DENORMAL    0x0100          /*   denormal */
#define IEM_ZERODIVIDE  0x0200          /*   zero divide */
#define IEM_OVERFLOW    0x0400          /*   overflow */
#define IEM_UNDERFLOW   0x0800          /*   underflow */
#define IEM_INEXACT     0x1000          /*   inexact (precision) */


#define IMCW_RC         0x6000          /* Rounding Control */
#define IRC_CHOP        0x6000          /*   chop */
#define IRC_UP          0x4000          /*   up */
#define IRC_DOWN        0x2000          /*   down */
#define IRC_NEAR        0x0000          /*   near */

#define ISW_INVALID     0x0001          /* invalid */
#define ISW_DENORMAL    0x0002          /* denormal */
#define ISW_ZERODIVIDE  0x0004          /* zero divide */
#define ISW_OVERFLOW    0x0008          /* overflow */
#define ISW_UNDERFLOW   0x0010          /* underflow */
#define ISW_INEXACT     0x0020          /* inexact (precision) */


#elif defined(_M_IA64)

/* Control word for computation of transcendentals */
#define ICW (IMCW_EM | IRC_NEAR | IPC_64)
#define ISW (ISW_INEXACT | ISW_UNDERFLOW | ISW_OVERFLOW | ISW_ZERODIVIDE | ISW_INVALID | ISW_DENORMAL)
#define IMCW (0xffffffff ^ ISW)

#define IMCW_EM         0x003f          /* interrupt Exception Masks */
#define IEM_INVALID     0x0001          /*   invalid */
#define IEM_DENORMAL    0x0002          /*   denormal */
#define IEM_ZERODIVIDE  0x0004          /*   zero divide */
#define IEM_OVERFLOW    0x0008          /*   overflow */
#define IEM_UNDERFLOW   0x0010          /*   underflow */
#define IEM_INEXACT     0x0020          /*   inexact (precision) */


#define IMCW_RC 0x0c00                  /* Rounding Control */
#define IRC_CHOP        0x0c00          /*   chop */
#define IRC_UP          0x0800          /*   up */
#define IRC_DOWN        0x0400          /*   down */
#define IRC_NEAR        0x0000          /*   near */

#define ISW_INVALID     0x02000         /* invalid */
#define ISW_DENORMAL    0x04000         /* denormal */
#define ISW_ZERODIVIDE  0x08000         /* zero divide */
#define ISW_OVERFLOW    0x10000         /* overflow */
#define ISW_UNDERFLOW   0x20000         /* underflow */
#define ISW_INEXACT     0x40000         /* inexact (precision) */

#define IMCW_PC         0x0300          /* Precision Control */
#define IPC_24          0x0000          /*    24 bits */
#define IPC_53          0x0200          /*    53 bits */
#define IPC_64          0x0300          /*    64 bits */

#elif defined(_M_MRX000)


#define ICW             0x00000f80              /* Internal CW for transcendentals */
#define IMCW            0xffffff83              /* Internal CW Mask */

#define IMCW_EM         0x00000f80              /* interrupt Exception Masks */
#define IEM_INVALID     0x00000800              /*   invalid */
#define IEM_ZERODIVIDE  0x00000400              /*   zero divide */
#define IEM_OVERFLOW    0x00000200              /*   overflow */
#define IEM_UNDERFLOW   0x00000100              /*   underflow */
#define IEM_INEXACT     0x00000080              /*   inexact (precision) */


#define IMCW_RC         0x00000003              /* Rounding Control */
#define IRC_CHOP        0x00000001              /*   chop */
#define IRC_UP          0x00000002              /*   up */
#define IRC_DOWN        0x00000003              /*   down */
#define IRC_NEAR        0x00000000              /*   near */


#define ISW_INVALID     (1<<6)  /* invalid */
#define ISW_ZERODIVIDE  (1<<5)  /* zero divide */
#define ISW_OVERFLOW    (1<<4)  /* overflow */
#define ISW_UNDERFLOW   (1<<3)  /* underflow */
#define ISW_INEXACT     (1<<2)  /* inexact (precision) */


#elif defined(_M_ALPHA)

//
// ICW is the Internal Control Word for transcendentals: all five exceptions
// are masked and round to nearest mode is set. IMCW is the mask: all bits
// are set, except for the ISW bits.
//

#define ICW (IEM_INEXACT | IEM_UNDERFLOW | IEM_OVERFLOW | IEM_ZERODIVIDE | IEM_INVALID | IRC_NEAR)
#define ISW (ISW_INEXACT | ISW_UNDERFLOW | ISW_OVERFLOW | ISW_ZERODIVIDE | ISW_INVALID)
#define IMCW (0xffffffff ^ ISW)

//
// The defines for the internal control word match the format of the Alpha
// AXP software FPCR except for the rounding mode which is obtained from the
// Alpha AXP hardware FPCR and shifted right 32 bits.
//

//
// Internal Exception Mask bits.
// Each bit _disables_ an exception (they are not _enable_ bits).
//

#define IMCW_EM         0x0000003e      /* interrupt Exception Masks */

#define IEM_INEXACT     0x00000020      /*   inexact (precision) */
#define IEM_UNDERFLOW   0x00000010      /*   underflow */
#define IEM_OVERFLOW    0x00000008      /*   overflow */
#define IEM_ZERODIVIDE  0x00000004      /*   zero divide */
#define IEM_INVALID     0x00000002      /*   invalid */

//
// Internal Rounding Control values.
//

#define IMCW_RC         (0x3 << 26)     /* Rounding Control */

#define IRC_CHOP        (0x0 << 26)     /*   chop */
#define IRC_DOWN        (0x1 << 26)     /*   down */
#define IRC_NEAR        (0x2 << 26)     /*   near */
#define IRC_UP          (0x3 << 26)     /*   up */

//
// Internal Status Word bits.
//

#define ISW_INEXACT     0x00200000      /* inexact (precision) */
#define ISW_UNDERFLOW   0x00100000      /* underflow */
#define ISW_OVERFLOW    0x00080000      /* overflow */
#define ISW_ZERODIVIDE  0x00040000      /* zero divide */
#define ISW_INVALID     0x00020000      /* invalid */


#elif defined(_M_PPC)

#define IMCW_EM         0x000000f8      /* Exception Enable Mask    */

#define IEM_INVALID     0x00000080      /*   invalid                */
#define IEM_OVERFLOW    0x00000040      /*   overflow               */
#define IEM_UNDERFLOW   0x00000020      /*   underflow              */
#define IEM_ZERODIVIDE  0x00000010      /*   zero divide            */
#define IEM_INEXACT     0x00000008      /*   inexact (precision)    */


#define IMCW_RC         0x00000003      /* Rounding Control Mask    */

#define IRC_NEAR        0x00000000      /*   near                   */
#define IRC_CHOP        0x00000001      /*   chop                   */
#define IRC_UP          0x00000002      /*   up                     */
#define IRC_DOWN        0x00000003      /*   down                   */


#define IMCW_SW         0x3E000000      /* Status Mask              */

#define ISW_INVALID     0x20000000      /*   invalid summary        */
#define ISW_OVERFLOW    0x10000000      /*   overflow               */
#define ISW_UNDERFLOW   0x08000000      /*   underflow              */
#define ISW_ZERODIVIDE  0x04000000      /*   zero divide            */
#define ISW_INEXACT     0x02000000      /*   inexact (precision)    */


#define IMCW_VX         0x01F80700      /* Invalid Cause Mask       */

#define IVX_SNAN        0x01000000      /*   SNaN                   */
#define IVX_ISI         0x00800000      /*   infinity - infinity    */
#define IVX_IDI         0x00400000      /*   infinity / infinity    */
#define IVX_ZDZ         0x00200000      /*   zero / zero            */
#define IVX_IMZ         0x00100000      /*   infinity * zero        */
#define IVX_VC          0x00080000      /*   inv flpt compare       */
#define IVX_SOFT        0x00000400      /*   software request       */
#define IVX_SQRT        0x00000200      /*   sqrt of negative       */
#define IVX_CVI         0x00000100      /*   inv integer convert    */


/* Internal CW for transcendentals */

#define ICW             (IMCW_EM)

/* Internal CW Mask (non-status bits) */

#define IMCW           (0xffffffff & (~(IMCW_SW|IMCW_VX)))

#endif

#ifndef __assembler     /* MIPS ONLY: Protect from assembler */

#define RETURN(fpcw,result) return _rstorfp(fpcw),(result)

#define RETURN_INEXACT1(op,arg1,res,cw)                 \
        if (cw & IEM_INEXACT) {                         \
            _rstorfp(cw);                               \
            return res;                                 \
        }                                               \
        else {                                          \
            return _except1(FP_P, op, arg1, res, cw);   \
        }


#define RETURN_INEXACT2(op,arg1,arg2,res,cw)            \
        if (cw & IEM_INEXACT) {                         \
            _rstorfp(cw);                               \
            return res;                                 \
        }                                               \
        else {                                          \
            return _except2(FP_P, op, arg1, arg2, res, cw);     \
        }


#ifdef _M_ALPHA

//
// Since fp32 is not compiled in IEEE exception mode perform Alpha NaN
// propagation in software to avoid hardware/kernel trap involvement.
//

extern double _nan2qnan(double);

#define _d_snan2(x,y)   _nan2qnan(y)
#define _s2qnan(x)      _nan2qnan(x)

#else
//handle NaN propagation
#define _d_snan2(x,y)   ((x)+(y))
#define _s2qnan(x)      ((x)+1.0)
#endif


#define _maskfp() _ctrlfp(ICW, IMCW)
#ifdef  _M_ALPHA
#define _rstorfp(cw) 0
#else
#define _rstorfp(cw) _ctrlfp(cw, IMCW)
#endif


#define ABS(x) ((x)<0 ? -(x) : (x) )


int _d_inttype(double);

#endif  /* #ifndef __assembler */

#define _D_NOINT 0
#define _D_ODD 1
#define _D_EVEN 2


// IEEE exceptions
#define FP_O         0x01
#define FP_U         0x02
#define FP_Z         0x04
#define FP_I         0x08
#define FP_P         0x10

// An extra flag for matherr support
// Set together with FP_I from trig functions when the argument is too large
#define FP_TLOSS     0x20


#ifndef __assembler     /* MIPS ONLY: Protect from assembler */
#ifdef B_END
#define SET_DBL(msw, lsw)     msw, lsw
#else
#define SET_DBL(msw, lsw)     lsw, msw
#endif
#endif  /* #ifndef __assembler */


// special types
#define T_PINF  1
#define T_NINF  2
#define T_QNAN  3
#define T_SNAN  4


// exponent adjustment for IEEE overflow/underflow exceptions
// used before passing the result to the trap handler

#define IEEE_ADJUST 1536

// QNAN values

#define INT_NAN         (~0)

#define QNAN_SQRT       D_IND
#define QNAN_LOG        D_IND
#define QNAN_LOG10      D_IND
#define QNAN_POW        D_IND
#define QNAN_SINH       D_IND
#define QNAN_COSH       D_IND
#define QNAN_TANH       D_IND
#define QNAN_SIN1       D_IND
#define QNAN_SIN2       D_IND
#define QNAN_COS1       D_IND
#define QNAN_COS2       D_IND
#define QNAN_TAN1       D_IND
#define QNAN_TAN2       D_IND
#define QNAN_ACOS       D_IND
#define QNAN_ASIN       D_IND
#define QNAN_ATAN2      D_IND
#define QNAN_CEIL       D_IND
#define QNAN_FLOOR      D_IND
#define QNAN_MODF       D_IND
#define QNAN_LDEXP      D_IND
#define QNAN_FMOD       D_IND
#define QNAN_FREXP      D_IND


/*
 * Function prototypes
 */

#ifndef __assembler     /* MIPS ONLY: Protect from assembler */

double _set_exp(double x, int exp);
double _set_bexp(double x, int exp);
double _add_exp(double x, int exp);
double _frnd(double);
double _fsqrt(double);
double _except1(int flags, int opcode, double arg, double res, uintptr_t cw);
double _except2(int flags, int opcode, double arg1, double arg2, double res, uintptr_t cw);
int _sptype(double);
int _get_exp(double);
double _decomp(double, int *);
int _powhlp(double x, double y, double * result);
extern unsigned int _fpstatus;
double _frnd(double);
double _exphlp(double, int *);
double _handle_qnan1(unsigned int op, double arg, uintptr_t cw);
double _handle_qnan2(unsigned int op,double arg1,double arg2,uintptr_t cw);
unsigned int _clhwfp(void);
unsigned int _setfpcw(uintptr_t);
int _errcode(unsigned int flags);
void _set_errno(int matherrtype);
int _handle_exc(unsigned int flags, double * presult, uintptr_t cw);
uintptr_t _clrfp(void);
uintptr_t _ctrlfp(uintptr_t,uintptr_t);
uintptr_t _statfp(void);
void _set_statfp(uintptr_t);

#endif  /* #ifndef __assembler */

#ifdef __cplusplus
}
#endif

#define _INC_TRANS
#endif  /* _INC_TRANS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\asincos.c ===
/***
*asincos.c - inverse sin, cos
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-15-91  GDP   written
*       12-26-91  GDP   support IEEE exceptions
*       06-23-92  GDP   asin(denormal) now raises underflow exception
*       02-06-95  JWM   Mac merge
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

#if defined(_M_IA64)
#pragma function(asin, acos)
#endif

static double _asincos(double x, int flag);
static double const a[2] = {
    0.0,
    0.78539816339744830962
};

static double const b[2] = {
    1.57079632679489661923,
    0.78539816339744830962
};

static double const EPS = 1.05367121277235079465e-8; /* 2^(-53/2) */

/* constants for the rational approximation */
static double const p1 = -0.27368494524164255994e+2;
static double const p2 =  0.57208227877891731407e+2;
static double const p3 = -0.39688862997504877339e+2;
static double const p4 =  0.10152522233806463645e+2;
static double const p5 = -0.69674573447350646411e+0;
static double const q0 = -0.16421096714498560795e+3;
static double const q1 =  0.41714430248260412556e+3;
static double const q2 = -0.38186303361750149284e+3;
static double const q3 =  0.15095270841030604719e+3;
static double const q4 = -0.23823859153670238830e+2;
/*  q5 = 1 is not needed (avoid myltiplying by 1) */

#define Q(g)  (((((g + q4) * g + q3) * g + q2) * g + q1) * g + q0)
#define R(g)  (((((p5 * g + p4) * g + p3) * g + p2) * g + p1) * g) / Q(g)

/***
*double asin(double x) - inverse sin
*double acos(double x) - inverse cos
*
*Purpose:
*   Compute arc sin, arc cos.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   P, I
*  (denormals are accepted)
*******************************************************************************/
double asin(double x)
{
    return _asincos(x,0);
}

double acos(double x)
{
    return _asincos(x,1);
}

static double _asincos(double x, int flag)
{
    uintptr_t savedcw;
    double qnan;
    int who;
    double y,result;
    double g;
    int i;

    /* save user fp control word */
    savedcw = _maskfp();

    if (flag) {
        who = OP_ACOS;
        qnan = QNAN_ACOS;
    }
    else {
        who = OP_ASIN;
        qnan = QNAN_ASIN;
    }

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        switch(_sptype(x)) {
        case T_PINF:
        case T_NINF:
            return _except1(FP_I,who,x,qnan,savedcw);
        case T_QNAN:
            return _handle_qnan1(who,x,savedcw);
        default: //T_SNAN
            return _except1(FP_I,who,x,_s2qnan(x),savedcw);
        }
    }


    // do test for zero after making sure that x is not special
    // because the compiler does not handle NaNs for the time
    if (x == 0.0 && !flag) {
        RETURN(savedcw, x);
    }

    y = ABS(x);
    if (y < EPS) {
        i = flag;
        result = y;
        if (IS_D_DENORM(result)) {
            // this should only happen for sin(denorm). Use x as a result
            return _except1(FP_U | FP_P,who,x,_add_exp(x, IEEE_ADJUST),savedcw);
        }
    }
    else {
        if (y > .5) {
            i = 1-flag;
            if (y > 1.0) {
                return _except1(FP_I,who,x,qnan,savedcw);
            }
            else if (y == 1.0) {
                /* separate case to avoid domain error in sqrt */
                if (flag && x >= 0.0) {
                    //
                    // acos(1.0) is exactly computed as 0.0
                    //
                    RETURN(savedcw, 0.0);
                }
                y = 0.0;
                g = 0.0;

            }
            else {
                /* now even if y is as close to 1 as possible,
                 * 1-y is still not a denormal.
                 * e.g. for y=3fefffffffffffff, 1-y is about 10^(-16)
                 * So we can speed up division
                 */
                g = _add_exp(1.0 - y,-1);
                /* g and sqrt(g) are not denomrals either,
                 * even in the worst case
                 * So we can speed up multiplication
                 */
                y = _add_exp(-_fsqrt(g),1);
            }
        }
        else {
            /* y <= .5 */
            i = flag;
            g = y*y;
        }
        result = y + y * R(g);
    }

    if (flag == 0) {
        /* compute asin */
        if (i) {
            /* a[i] is non zero if i is nonzero */
            result = (a[i] + result) + a[i];
        }
        if (x < 0)
            result = -result;
    }
    else {
        /* compute acos */
        if (x < 0)
            result = (b[i] + result) + b[i];
        else
            result = (a[i] - result) + a[i];
    }

    RETURN_INEXACT1 (who,x,result,savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ceil.c ===
/***
*ceil.c - ceiling
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*        1-09-92  GDP   support IEEE exceptions
*        6-23-92  GDP   ceil(INF) now returns INF (NCEG spec)
*       02-06-95  JWM   Mac merge
*       01-26-01  PML   Pentium4 merge
*
*******************************************************************************/
#include <math.h>
#include <trans.h>

extern double _frnd(double);


/***
*double ceil(double x) - ceiling
*
*Purpose:
*   Return a double representing the smallest integer that is
*   greater than or equal to x
*
*Entry:
*
*Exit:
*
*Exceptions:
*    P, I
*******************************************************************************/
static uintptr_t newcw = (ICW & ~IMCW_RC) | (IRC_UP & IMCW_RC);



#if !defined(_M_IX86)
double ceil(double x)
#else
double _ceil_default(double x)
#endif
{
    uintptr_t savedcw;
    double result;

    /* save user fp control word */
    savedcw = _ctrlfp(newcw,IMCW);      /* round up */

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
        case T_NINF:
            RETURN(savedcw,x);
        case T_QNAN:
            return _handle_qnan1(OP_CEIL, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I, OP_CEIL, x, _s2qnan(x), savedcw);
        }
    }

    result = _frnd(x); /* round according to the current rounding mode */

    // In general, the Precision Exception should be raised if
    // _frnd reports a precision loss. In order to detect this with
    // masked exceptions, the status word needs to be cleared.
    // However, we want to avoid this, since the 387 instruction
    // set does not provide an fast way to restore the status word

    if (result == x) {
        RETURN(savedcw,result);
    }
    else {
        RETURN_INEXACT1(OP_CEIL, x, result, savedcw);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\exp.c ===
/***
*exp.c - exponential
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   Compute exp(x)
*
*Revision History:
*        8-15-91  GDP   written
*       12-21-91  GDP   support IEEE exceptions
*       02-03-92  GDP   added _exphlp for use by exp, sinh, and cosh
*       02-06-95  JWM   Mac merge
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

#if defined(_M_IA64)
#pragma function(exp)
#endif

double _exphlp(double, int *);

/*
 * Thresholds for over/underflow that results in an adjusted value
 * too big/small to be represented as a double.
 * OVFX: ln(XMAX * 2^IEEE_ADJ)
 * UFLX: ln(XIN * 2^(-IEEE_ADJ)
 */

static _dbl const ovfx = {SET_DBL(0x40862e42, 0xfefa39f8)}; /*  709.782712893385 */
static _dbl const uflx = {SET_DBL(0xc086232b, 0xdd7abcda)};     /* -708.396418532265 */

#define OVFX    ovfx.dbl
#define UFLX    uflx.dbl


static double const  EPS    =  5.16987882845642297e-26;   /* 2^(-53) / 2 */
static double const  LN2INV =  1.442695040889634074;      /* 1/ln(2) */
static double const  C1     =  0.693359375000000000;
static double const  C2     = -2.1219444005469058277e-4;

/* constants for the rational approximation */
static double const p0 = 0.249999999999999993e+0;
static double const p1 = 0.694360001511792852e-2;
static double const p2 = 0.165203300268279130e-4;
static double const q0 = 0.500000000000000000e+0;
static double const q1 = 0.555538666969001188e-1;
static double const q2 = 0.495862884905441294e-3;

#define P(z)  ( (p2 * (z) + p1) * (z) + p0 )
#define Q(z)  ( (q2 * (z) + q1) * (z) + q0 )

/***
*double exp(double x) - exponential
*
*Purpose:
*   Compute the exponential of a number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions: O, U, P, I
*
*******************************************************************************/

double exp (double x)
{
    uintptr_t savedcw;
    int newexp;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
            RETURN(savedcw,x);
        case T_NINF:
            RETURN(savedcw,0.0);
        case T_QNAN:
            return _handle_qnan1(OP_EXP, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I, OP_EXP, x, _s2qnan(x), savedcw);
        }
    }

    if (x == 0.0) {
        RETURN(savedcw, 1.0);
    }

    if (x > OVFX) {

        // even after scaling the exponent of the result,
        // it is still too large.
        // Deliver infinity to the trap handler

        return _except1(FP_O | FP_P, OP_EXP, x, D_INF, savedcw);
    }

    if (x < UFLX) {

        // even after scaling the exponent of the result,
        // it is still too small.
        // Deliver 0 to the trap handler

        return _except1(FP_U | FP_P, OP_EXP, x, 0.0, savedcw);
    }

    if (ABS(x) < EPS) {
        result = 1.0;
    }

    else {
        result = _exphlp(x, &newexp);
        if (newexp > MAXEXP) {
            result = _set_exp(result, newexp-IEEE_ADJUST);
            return _except1(FP_O | FP_P, OP_EXP, x, result, savedcw);
        }
        else if (newexp < MINEXP) {
            result = _set_exp(result, newexp+IEEE_ADJUST);
            return _except1(FP_U | FP_P, OP_EXP, x, result, savedcw);
        }
        else
            result = _set_exp(result, newexp);
    }

    RETURN_INEXACT1(OP_EXP, x, result, savedcw);
}




/***
*double _exphlp(double x, int * pnewexp) - exp helper routine
*
*Purpose:
*   Provide the mantissa and  the exponent of e^x
*
*Entry:
*   x : a (non special) double precision number
*
*Exit:
*   *newexp: the exponent of e^x
*   return value: the mantissa m of e^x scaled by a factor
*                 (the value of this factor has no significance.
*                  The mantissa can be obtained with _set_exp(m, 0).
*
*   _set_exp(m, *pnewexp) may be used for constructing the final
*   result, if it is within the representable range.
*
*Exceptions:
*   No exceptions are raised by this function
*
*******************************************************************************/



double _exphlp(double x, int * pnewexp)
{

    double xn;
    double g,z,gpz,qz,rg;
    int n;

    xn = _frnd(x * LN2INV);
    n = (int) xn;

    /* assume guard digit is present */
    g = (x - xn * C1) - xn * C2;
    z = g*g;
    gpz = g * P(z);
    qz = Q(z);
    rg = 0.5 + gpz/(qz-gpz);

    n++;

    *pnewexp = _get_exp(rg) + n;
    return rg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\bessel.c ===
/***
*bessel.c - defines the bessel functions for C.
*
*       Copyright (c) 1983-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*
*  This is a collection of routines for computing the bessel functions j0, j1,
*  y0, y1, jn and yn.  The approximations used for j0, j1, y0, and y1 are
*  from the approximations listed in Hart, Computer Approximations, 1978.
*  For these functions, a rational approximation with 18 places of accuracy
*  after the decimal point has been selected.  jn and yn are computed using
*  the recursive formula that the bessel functions satisfy.  Using these
*  formulas their values can be computed from the values of the bessel
*  functions of order 0 and 1.  In the case of jn, the recursive formula
*
*                 jn(n-1,x) = (2.0*n/x)*jn(n,x) - jn(n+1,x)
*
*  is used to stabily compute in the downward direction, normalizing in the
*  the end by j0(x) in the usual manner.  In the case of yn, the recursive
*  formula
*
*                 yn(n+1,x) = (2.0*n/x)*yn(n,x) - yn(n-1,x)
*
*  is used to stably compute the functions in the forward direction.
*
*
*  Note: upon testing and experimentation the low range approximations were
*        found to have an error on the order of 1.0e-14 in the neighborhood of
*        8.0.  Moving the boundary point between the low range and high
*        range approximations down to 7.5 reduced this error to less than
*        1.0e-14.  This is not suprising.  The high range asymptotoic is
*        likely to have greater precision in the neighborhood of 8.0.
*
*Revision History:
*
*       06/05/89  WAJ   Added this header. Made changes for C6 and -W3
*       06/06/89  WAJ   Moved some of the routines into _RTEXT if MTHREAD.
*       08/17/90  WAJ   Now uses _stdcall.
*       01/13/92  GDP   changed domain_err. No full IEEE support yet
*       04-06-93  SKS   Replace _CALLTYPE* with __cdecl
*       08-28-96  JWM   Disabled warning 4056.
*
*******************************************************************************/


/*
 *  The functions sqrt, sin, cos, and log from the math library are used in
 *  the computations of the bessel functions.
 */

#include <math.h>
#include <trans.h>

#ifdef _M_IX86
#pragma warning(disable:4056)
#endif

#ifdef _X86SEG_
#include <os2supp.h>
#define _CALLTYPE1 _PASCAL
#else
#include <cruntime.h>
#endif

#ifdef LD_VER
#define D_TYPE  long double

#else
#define D_TYPE  double
#endif



static D_TYPE  domain_err( int who, D_TYPE arg1, D_TYPE arg2 ); /* error routine for y0, y1, yn */
static D_TYPE  evaluate( D_TYPE x, D_TYPE p[], int n1, D_TYPE q[], int n2 );


#ifdef FAR_CODE
    #ifdef LD_VER
        #pragma alloc_text( _RTEXT, _y0l, _y1l, _ynl, _j0l, _j1l, _jnl )
    #else
        #pragma alloc_text( _RTEXT, _y0, _y1, _yn, _j0, _j1, _jn )
    #endif
#endif



/*
 *  Following are the constants needed for the computations of the bessel
 *  functions as in Hart.
 */

#define PI 3.14159265358979323846264338327950288


/* coefficients for Hart JZERO 5848, the low range approximation for _j0 */

static D_TYPE J0p[12] = {
                         0.1208181340866561224763662419e+12 ,
                        -0.2956513002312076810191727211e+11 ,
                         0.1729413174598080383355729444e+10 ,
                        -0.4281611621547871420502838045e+08 ,
                         0.5645169313685735094277826749e+06 ,
                        -0.4471963251278787165486324342e+04 ,
                         0.2281027164345610253338043760e+02 ,
                        -0.7777570245675629906097285039e-01 ,
                         0.1792464784997734953753734861e-03 ,
                        -0.2735011670747987792661294323e-06 ,
                         0.2553996162031530552738418047e-09 ,
                        -0.1135416951138795305302383379e-12
                        };

static D_TYPE J0q[5] =  {
                        0.1208181340866561225104607422e+12 ,
                        0.6394034985432622416780183619e+09 ,
                        0.1480704129894421521840387092e+07 ,
                        0.1806405145147135549477896097e+04 ,
                        0.1e+01
                        };


/* coefficients for Hart 6548, P0 of the high range approximation for j0
   and _y0 */

static D_TYPE P0p[6] =  {
                        0.2277909019730468430227002627e+05 ,
                        0.4134538663958076579678016384e+05 ,
                        0.2117052338086494432193395727e+05 ,
                        0.3480648644324927034744531110e+04 ,
                        0.1537620190900835429577172500e+03 ,
                        0.8896154842421045523607480000e+00
                        };

static D_TYPE P0q[6] =  {
                        0.2277909019730468431768423768e+05 ,
                        0.4137041249551041663989198384e+05 ,
                        0.2121535056188011573042256764e+05 ,
                        0.3502873513823560820735614230e+04 ,
                        0.1571115985808089364906848200e+03 ,
                        0.1e+01
                        };


/* coefficients for Hart 6948, Q0 of the high range approximation for _j0
   and _y0 */

static D_TYPE Q0p[6] =  {
                        -0.8922660020080009409846916000e+02 ,
                        -0.1859195364434299380025216900e+03 ,
                        -0.1118342992048273761126212300e+03 ,
                        -0.2230026166621419847169915000e+02 ,
                        -0.1244102674583563845913790000e+01 ,
                        -0.8803330304868075181663000000e-02
                        };

static D_TYPE Q0q[6] =  {
                        0.5710502412851206190524764590e+04 ,
                        0.1195113154343461364695265329e+05 ,
                        0.7264278016921101883691345060e+04 ,
                        0.1488723123228375658161346980e+04 ,
                        0.9059376959499312585881878000e+02 ,
                        0.1e+01
                        };



/* coefficients for Hart JONE 6047, the low range approximation for _j1 */

static D_TYPE J1p[11] = {
                         0.4276440148317146125749678272e+11 ,
                        -0.5101551390663600782363700742e+10 ,
                         0.1928444249391651825203957853e+09 ,
                        -0.3445216851469225845312168656e+07 ,
                         0.3461845033978656620861683039e+05 ,
                        -0.2147334276854853222870548439e+03 ,
                         0.8645934990693258061130801001e+00 ,
                        -0.2302415336775925186376173217e-02 ,
                         0.3991878933072250766608485041e-05 ,
                        -0.4179409142757237977587032616e-08 ,
                         0.2060434024597835939153003596e-11
                        };


 static D_TYPE J1q[5] = {
                        0.8552880296634292263013618479e+11 ,
                        0.4879975894656629161544052051e+09 ,
                        0.1226033111836540909388789681e+07 ,
                        0.1635396109098603257687643236e+04 ,
                        0.1e+01
                        };


/* coefficients for Hart PONE 6749, P1 of the high range approximation for
   _j1 and y1 */

static D_TYPE P1p[6] =  {
                        0.3522466491336797983417243730e+05 ,
                        0.6275884524716128126900567500e+05 ,
                        0.3135396311091595742386698880e+05 ,
                        0.4985483206059433843450045500e+04 ,
                        0.2111529182853962382105718000e+03 ,
                        0.1257171692914534155849500000e+01
                        };

static D_TYPE P1q[6] =  {
                        0.3522466491336797980683904310e+05 ,
                        0.6269434695935605118888337310e+05 ,
                        0.3124040638190410399230157030e+05 ,
                        0.4930396490181088978386097000e+04 ,
                        0.2030775189134759322293574000e+03 ,
                        0.1e+01
                        };


/* coefficients for Hart QONE 7149, Q1 of the high range approximation for _j1
   and y1 */

static D_TYPE Q1p[6] =  {
                        0.3511751914303552822533318000e+03 ,
                        0.7210391804904475039280863000e+03 ,
                        0.4259873011654442389886993000e+03 ,
                        0.8318989576738508273252260000e+02 ,
                        0.4568171629551226706440500000e+01 ,
                        0.3532840052740123642735000000e-01
                        };

static D_TYPE Q1q[6] =  {
                        0.7491737417180912771451950500e+04 ,
                        0.1541417733926509704998480510e+05 ,
                        0.9152231701516992270590472700e+04 ,
                        0.1811186700552351350672415800e+04 ,
                        0.1038187587462133728776636000e+03 ,
                        0.1e+01
                        };


/* coeffiecients for Hart YZERO 6245, the low range approximation for y0 */

static D_TYPE Y0p[9] =  {
                        -0.2750286678629109583701933175e+20 ,
                         0.6587473275719554925999402049e+20 ,
                        -0.5247065581112764941297350814e+19 ,
                         0.1375624316399344078571335453e+18 ,
                        -0.1648605817185729473122082537e+16 ,
                         0.1025520859686394284509167421e+14 ,
                        -0.3436371222979040378171030138e+11 ,
                         0.5915213465686889654273830069e+08 ,
                        -0.4137035497933148554125235152e+05
                        };

static D_TYPE Y0q[9] =  {
                        0.3726458838986165881989980739e+21 ,
                        0.4192417043410839973904769661e+19 ,
                        0.2392883043499781857439356652e+17 ,
                        0.9162038034075185262489147968e+14 ,
                        0.2613065755041081249568482092e+12 ,
                        0.5795122640700729537480087915e+09 ,
                        0.1001702641288906265666651753e+07 ,
                        0.1282452772478993804176329391e+04 ,
                        0.1e+01
                        };


/* coefficients for Hart YONE 6444, the low range approximation for y1 */

static D_TYPE Y1p[8] =  {
                        -0.2923821961532962543101048748e+20 ,
                         0.7748520682186839645088094202e+19 ,
                        -0.3441048063084114446185461344e+18 ,
                         0.5915160760490070618496315281e+16 ,
                        -0.4863316942567175074828129117e+14 ,
                         0.2049696673745662182619800495e+12 ,
                        -0.4289471968855248801821819588e+09 ,
                         0.3556924009830526056691325215e+06
                        };


static D_TYPE Y1q[9] =  {
                        0.1491311511302920350174081355e+21 ,
                        0.1818662841706134986885065935e+19 ,
                        0.1131639382698884526905082830e+17 ,
                        0.4755173588888137713092774006e+14 ,
                        0.1500221699156708987166369115e+12 ,
                        0.3716660798621930285596927703e+09 ,
                        0.7269147307198884569801913150e+06 ,
                        0.1072696143778925523322126700e+04 ,
                        0.1e+01
                        };



/*
 *  Function name:  evaluate
 *
 *  Arguments:      x  -  double
 *                  p, q  -  double arrays of coefficients
 *                  n1, n2  -  the order of the numerator and denominator
 *                             polynomials
 *
 *  Description:    evaluate is meant strictly as a helper routine for the
 *                  bessel function routines to evaluate the rational polynomial
 *                  aproximations appearing in _j0, _j1, y0, and y1.  Given the
 *                  coefficient arrays in p and q, it evaluates the numerator
 *                  and denominator polynomials through orders n1 and n2
 *                  respectively, returning p(x)/q(x).  This routine is not
 *                  available to the user of the bessel function routines.
 *
 *  Side Effects:   evaluate uses the global data stored in the coefficients
 *                  above.  No other global data is used or affected.
 *
 *  Author:         written  R.K. Wyss, Microsoft,  Sept. 9, 1983
 *
 *  History:
 */

static D_TYPE  evaluate( D_TYPE x, D_TYPE p[], int n1, D_TYPE q[], int n2 )
{
D_TYPE  numerator, denominator;
int     i;

    numerator = x*p[n1];
    for ( i = n1-1 ; i > 0 ; i-- )
        numerator = x*(p[i] + numerator);
    numerator += p[0];

    denominator = x*q[n2];
    for ( i = n2-1 ; i > 0 ; i-- )
        denominator = x*(q[i] + denominator);
    denominator += q[0];

    return( numerator/denominator );
}


/*
 *  Function name:  _j0
 *
 *  Arguments:      x  -  double
 *
 *  Description:    _j0 computes the bessel function of the first kind of zero
 *                  order for real values of its argument x, where x can range
 *                  from - infinity to + infinity.  The algorithm is taken
 *                  from Hart, Computer Approximations, 1978, and yields full
 *                  double precision accuracy.
 *
 *  Side Effects:   no global data other than the static coefficients above
 *                  is used or affected.
 *
 *  Author:         written  R.K. Wyss,  Microsoft,  Sept. 9, 1983
 *
 *  History:
 */

#ifdef  LD_VER
    D_TYPE _
cdecl _j0l( D_TYPE x )
#else
    D_TYPE __cdecl _j0( D_TYPE x )
#endif
{
D_TYPE  z, P0, Q0;

    /* if the argument is negative, take the absolute value */

    if ( x < 0.0 )
        x = - x;

    /* if x <= 7.5  use Hart JZERO 5847 */

    if ( x <= 7.5 )
        return( evaluate( x*x, J0p, 11, J0q, 4) );

    /* else if x >= 7.5  use Hart PZERO 6548 and QZERO 6948, the high range
       approximation */

    else {
        z = 8.0/x;
        P0 = evaluate( z*z, P0p, 5, P0q, 5);
        Q0 = z*evaluate( z*z, Q0p, 5, Q0q, 5);
        return( sqrt(2.0/(PI*x))*(P0*cos(x-PI/4) - Q0*sin(x-PI/4)) );
        }
}


/*
 *  Function name:  _j1
 *
 *  Arguments:      x  -  double
 *
 *  Description:    _j1 computes the bessel function of the first kind of the
 *                  first order for real values of its argument x, where x can
 *                  range from - infinity to + infinity.  The algorithm is taken
 *                  from Hart, Computer Approximations, 1978, and yields full
 *                  D_TYPE precision accuracy.
 *
 *  Side Effects:   no global data other than the static coefficients above
 *                  is used or affected.
 *
 *  Author:         written  R.K. Wyss,  Microsoft,  Sept. 9, 1983
 *
 *  History:
 */

#ifdef  LD_VER
    D_TYPE _cdecl _j1l( D_TYPE x )
#else
    D_TYPE __cdecl _j1( D_TYPE x )
#endif
{
D_TYPE  z, P1, Q1;
int     sign;

     /* if the argument is negative, take the absolute value and set sign */

     sign = 1;
     if( x < 0.0 ){
        x = -x;
        sign = -1;
        }

     /* if x <= 7.5  use Hart JONE 6047 */

     if ( x <= 7.5 )
        return( sign*x*evaluate( x*x, J1p, 10, J1q, 4) );


    /* else if x > 7.5  use Hart PONE 6749 and QONE 7149, the high range
       approximation */

    else {
        z = 8.0/x;
        P1 = evaluate( z*z, P1p, 5, P1q, 5);
        Q1 = z*evaluate( z*z, Q1p, 5, Q1q, 5);
        return( sign*sqrt(2.0/(PI*x))*
                           ( P1*cos(x-3.0*PI/4.0) - Q1*sin(x-3.0*PI/4.0) )  );
        }
}



/*
 *  Function name:  _y0
 *
 *  Arguments:      x  -  double
 *
 *  Description:    y0 computes the bessel function of the second kind of zero
 *                  order for real values of its argument x, where x can range
 *                  from 0 to + infinity.  The algorithm is taken from Hart,
 *                  Computer Approximations, 1978, and yields full double
 *                  precision accuracy.
 *
 *  Side Effects:   no global data other than the static coefficients above
 *                  is used or affected.
 *
 *  Author:         written  R.K. Wyss, Microsoft,  Sept. 9, 1983
 *
 *  History:
 */

#ifdef  LD_VER
    D_TYPE _cdecl _y0l( D_TYPE x )
#else
    D_TYPE __cdecl _y0( D_TYPE x )
#endif
{
D_TYPE  z, P0, Q0;


    /* if the argument is negative, set EDOM error, print an error message,
     * and return -HUGE
     */

    if (x < 0.0)
        return( domain_err(OP_Y0 , x, D_IND) );


    /* if x <= 7.5 use Hart YZERO 6245, the low range approximation */

    if ( x <= 7.5 )
        return( evaluate( x*x, Y0p, 8, Y0q, 8) + (2.0/PI)*_j0(x)*log(x) );


    /* else if x > 7.5 use Hart PZERO 6548 and QZERO 6948, the high range
       approximation */

    else {
        z = 8.0/x;
        P0 = evaluate( z*z, P0p, 5, P0q, 5);
        Q0 = z*evaluate( z*z, Q0p, 5, Q0q, 5);
        return( sqrt(2.0/(PI*x))*(P0*sin(x-PI/4) + Q0*cos(x-PI/4)) );
        }
}


/*
 *  Function name:  _y1
 *
 *  Arguments:      x  -  double
 *
 *  Description:    y1 computes the bessel function of the second kind of first
 *                  order for real values of its argument x, where x can range
 *                  from 0 to + infinity.  The algorithm is taken from Hart,
 *                  Computer Approximations, 1978, and yields full double
 *                  precision accuracy.
 *
 *  Side Effects:   no global data other than the static coefficients above
 *                  is used or affected.
 *
 *  Author:         written  R.K. Wyss,  Microsoft,  Sept. 9, 1983
 *
 *  History:
 */

#ifdef  LD_VER
    D_TYPE _cdecl _y1l( D_TYPE x )
#else
    D_TYPE __cdecl _y1( D_TYPE x )
#endif
{
D_TYPE  z, P1, Q1;


    /* if the argument is negative, set EDOM error, print an error message,
     * and return -HUGE
     */

    if (x < 0.0)
        return( domain_err(OP_Y1, x, D_IND) );

    /* if x <= 7.5  use Hart YONE 6444, the low range approximation */

    if ( x <= 7.5 )
        return( x*evaluate( x*x, Y1p, 7, Y1q, 8)
                               + (2.0/PI)*(_j1(x)*log(x) - 1.0/x) );


    /* else if x > 7.5  use Hart PONE 6749 and QONE 7149, the high range
       approximation */

    else {
        z = 8.0/x;
        P1 = evaluate( z*z, P1p, 5, P1q, 5);
        Q1 = z*evaluate( z*z, Q1p, 5, Q1q, 5);
        return(  sqrt(2.0/(PI*x))*
                         ( P1*sin(x-3.0*PI/4.0) + Q1*cos(x-3.0*PI/4.0) )   );
        }
}


/*
 *  Function name:  _jn
 *
 *  Arguments:      n  -  integer
 *                  x  -  double
 *
 *  Description:    _jn computes the bessel function of the first kind of order
 *                  n for real values of its argument, where x can range from
 *                  - infinity to + infinity, and n can range over the integers
 *                  from - infinity to + infinity.  The function is computed
 *                  by recursion, using the formula
 *
 *                               _jn(n-1,x) = (2.0*n/x)*_jn(n,x) - _jn(n+1,x)
 *
 *                  stabilly in the downward direction, normalizing by _j0(x)
 *                  in the end in the usual manner.
 *
 *  Side Effects:   the routines _j0, y0, and yn are called during the
 *                  execution of this routine.
 *
 *  Author:         written  R.K. Wyss,  Microsoft,  Sept. 9, 1983
 *
 *  History:
 *              07/29/85        Greg Whitten
 *                              rewrote _jn to use Hart suggested algorithm
 */

#ifdef  LD_VER
    D_TYPE _cdecl _jnl( int n, D_TYPE x )
#else
    D_TYPE __cdecl _jn( int n, D_TYPE x )
#endif
{
int     i;
D_TYPE  x2, jm1, j, jnratio, hold;

    /*  use symmetry relationships:  _j(-n,x) = _j(n,-x) */

    if( n < 0 ){
        n = -n;
        x = -x;
        }

    /*  if n = 0 use _j0(x) and if n = 1 use _j1(x) functions */

    if (n == 0)
        return (_j0(x));

    if (n == 1)
        return (_j1(x));

    /*  if x = 0.0 then _j(n,0.0) = 0.0 for n > 0   (_j(0,x) = 1.0) */

    if (x == 0.0)
        return (0.0);

    /*  otherwise - must use the recurrence relation
     *
     *      _jn(n+1,x) = (2.0*n/x)*_jn(n,x) - _jn(n-1,x)  forward
     *      _jn(n-1,x) = (2.0*n/x)*_jn(n,x) - _jn(n+1,x)  backward
     */

    if( (double)n < fabs(x) ) {

        /*  stably compute _jn using forward recurrence above */

        n <<= 1;  /* n *= 2  (n is positive) */
        jm1 = _j0(x);
        j = _j1(x);
        i = 2;
        for(;;) {
            hold = j;
            j = ((double)(i))*j/x - jm1;
            i += 2;
            if (i == n)
                return (j);
            jm1 = hold;
            }
        }
    else {
        /*  stably compute _jn using backward recurrence above */

        /*  use Hart continued fraction formula for j(n,x)/j(n-1,x)
         *  so that we can compute a normalization factor
         */

        n <<= 1;                /* n *= 2  (n is positive) */
        x2 = x*x;
        hold = 0.0;             /* initial continued fraction tail value */
        for (i=n+36; i>n; i-=2)
            hold = x2/((double)(i) - hold);
        jnratio = j = x/((double)(n) - hold);
        jm1 = 1.0;

        /*  have jn/jn-1 ratio - now use backward recurrence */

        i = n-2;
        for (;;) {
            hold = jm1;
            jm1 = ((double)(i))*jm1/x - j;
            i -= 2;
            if (i == 0)
                    break;
            j = hold;
            }

        /*  jm1 is relative j0(x) so normalize it for final result
         *
         *  jnratio = K*j(n,x) and jm1 = K*_j0(x)
         */

        return(_j0(x)*jnratio/jm1);
        }
}


/*
 *  Function name:  _yn
 *
 *  Arguments:      n  -  integer
 *                  x  -  double
 *
 *  Description:    yn computes the bessel function of the second kind of order
 *                  n for real values of its argument x, where x can range from
 *                  0 to + infinity, and n can range over the integers from
 *                  - infinity to + infinity. The function is computed by
 *                  recursion from y0 and y1, using the recursive formula
 *
 *                          yn(n+1,x) = (2.0*n/x)*yn(n,x) - yn(n-1,x)
 *
 *                  in the forward direction.
 *
 *  Side Effects:   the routines y0 and y1 are called during the execution
 *                  of this routine.
 *
 *  Author:         written  R.K. Wyss,  Microsoft,  Sept. 9, 1983
 *
 *  History:
 *              08/09/85        Greg Whitten
 *                              added check for n==0 and n==1
 *              04/20/87        Barry McCord
 *                              eliminated use of "const" as an identifier for ANSI conformance
 */

#ifdef  LD_VER
    D_TYPE _cdecl _ynl( int n, D_TYPE x )
#else
    D_TYPE __cdecl _yn( int n, D_TYPE x )
#endif
{
int     i;
int     sign;
D_TYPE  constant, yn2, yn1, yn0;


    /* if the argument is negative, set EDOM error, print an error message,
         * and return -HUGE
         */

    if (x < 0.0)
        return(domain_err(OP_YN, x, D_IND));


     /* take the absolute value of n, and set sign accordingly */

     sign = 1;
     if( n < 0 ){
        n = -n;
        if( n&1 )
            sign = -1;
        }

     if( n == 0 )
        return( sign*_y0(x) );

     if (n == 1)
        return( sign*_y1(x) );

     /* otherwise go ahead and compute the function by iteration */

     yn0 = _y0(x);
     yn1 = _y1(x);

     constant = 2.0/x;
     for( i = 1 ; i < n ; i++ ){
        yn2 = constant*i*yn1 - yn0;
        yn0 = yn1;
        yn1 = yn2;
        }
     return( sign*yn2 );
}


static D_TYPE  domain_err( int who, D_TYPE arg1, D_TYPE arg2 )
{
#ifdef  LD_VER
#error long double version not supported
#endif

    uintptr_t savedcw;
    savedcw = _maskfp();
    return _except1(FP_I, who, arg1, arg2, savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\fabs.c ===
/***
*fabs.c - absolute value of a floating point number
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*       12-10-91  GDP   Domain error for NAN, use fp negation
*        1-13-91  GDP   support IEEE exceptions
*        6-23-92  GDP   fabs(-0) is now +0 (NCEG spec)
*       02-06-95  JWM   Mac merge
*       10-07-97  RDL   Added IA64.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

#if     defined(_M_IX86) || defined(_M_PPC) || defined(_M_IA64)
#pragma function(fabs)
#endif


/***
*double fabs(double x)
*
*Purpose:
*   Compute |x|
*
*Entry:
*
*Exit:
*
*Exceptions:
*   I
*
*******************************************************************************/
double fabs(double x)
{
    uintptr_t savedcw;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
            RETURN(savedcw,x);
        case T_NINF:
            RETURN(savedcw,-x);
        case T_QNAN:
            return _handle_qnan1(OP_ABS, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I, OP_ABS, x, _s2qnan(x), savedcw);
        }
    }


    *D_HI(result) = *D_HI(x) & ~(1<<31);
    *D_LO(result) = *D_LO(x);
    RETURN(savedcw,result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\frexp.c ===
/***
*frexp.c - get mantissa and exponent of a floating point number
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*        1-13-92  GDP   support IEEE exceptions
*       02-06-95  JWM   Mac merge
*
*******************************************************************************/
#include <math.h>
#include <trans.h>

/***
*double frexp(double x, double *expptr)
*
*Purpose:
*   The nomalized fraction f is returned: .5<=f<1
*   The exponent is stored in the object pointed by expptr
*
*Entry:
*
*Exit:
*
*Exceptions:
*    NAN: domain error
*
*******************************************************************************/
double frexp(double x, int *expptr)
{
    uintptr_t savedcw;
    double man;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        *expptr = INT_NAN;
        switch (_sptype(x)) {
        case T_PINF:
        case T_NINF:
            return _except1(FP_I, OP_FREXP, x, QNAN_FREXP, savedcw);
        case T_QNAN:
            return _handle_qnan1(OP_FREXP, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I, OP_FREXP, x, _s2qnan(x), savedcw);
        }
    }

    man = _decomp(x, expptr);
    RETURN(savedcw,man);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\fpexcept.c ===
/***
*fpexcept.c - floating point exception handling
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       08-24-91  GDP   written
*       09-26-91  GDP   changed DOMAIN error handling
*       10-10-91  GDP   use fp addition for propagating NaNs
*       01-14-92  GDP   IEEE exception support
*       03-20-92  GDP   major changes, reorganized code
*       03-31-92  GDP   new interface, use internal fp control functions
*       07-16-93  SRW   ALPHA Merge
*       11-18-93  GJF   Merged in NT SDK version. Cleaned up preprocessing
*                       conditional: replaced #if _NTSUBSET_ with #ifdef
*                       _NTSUBSET_, i386 with _M_IX86, MIPS with _M_MRX000,
*                       _ALPHA_ with _M_ALPHA.
*       09-01-94  SKS   Change include file from <nt.h> to <windows.h>
*       09-05-94  SKS   Change another #ifdef i386 to #ifdef _M_IX86
*       10-02-94  BWT   PPC merge and change NTSUBSET includes to use nt.h
*       02-19-95  BWT   Define _KERNEL32_ before including windows.h for _NTSUBSET_
*                       build (otherwise declspec(dllimport) will be on for
*                       RaiseException)
*       03-29-95  BWT   Add casts to fix warnings.
*       05-10-96  BWT   POSIX fix
*       06-21-00  GB    Add OP_LOGB in _get_fname.
*
*******************************************************************************/

#if defined(_NTSUBSET_) || defined (_POSIX_)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define _KERNEL32_          // Don't Export RaiseException
#endif  // _NTSUBSET_


#include <trans.h>
#include <errno.h>
#include <math.h>
#include <windows.h>

#ifdef  _NTSUBSET_
VOID
WINAPI
RaiseException(
    DWORD dwExceptionCode,
    DWORD dwExceptionFlags,
    DWORD nNumberOfArguments,
    CONST DWORD_PTR *lpArguments
    )
{
    EXCEPTION_RECORD ExceptionRecord;
    ULONG n;
    PULONG_PTR s,d;
    ExceptionRecord.ExceptionCode = (DWORD)dwExceptionCode;
    ExceptionRecord.ExceptionFlags = dwExceptionFlags & EXCEPTION_NONCONTINUABLE;
    ExceptionRecord.ExceptionRecord = NULL;
    ExceptionRecord.ExceptionAddress = (PVOID)RaiseException;
    if ( ARGUMENT_PRESENT(lpArguments) ) {
        n =  nNumberOfArguments;
        if ( n > EXCEPTION_MAXIMUM_PARAMETERS ) {
            n = EXCEPTION_MAXIMUM_PARAMETERS;
            }
        ExceptionRecord.NumberParameters = n;
        s = (PULONG_PTR)lpArguments;
        d = ExceptionRecord.ExceptionInformation;
        while(n--){
            *d++ = *s++;
            }
        }
    else {
        ExceptionRecord.NumberParameters = 0;
        }
    RtlRaiseException(&ExceptionRecord);

}
#endif  // _NTSUBSET_


//
// copy a double without generating floating point instructions
// (avoid invalid operation on x87)
//

#define COPY_DOUBLE(pdest, psrc) \
      ( *(unsigned int *)pdest = *(unsigned int *)psrc,   \
        *((unsigned int *)pdest+1) = *((unsigned int *)psrc+1) )



//
// _matherr_flag is a communal variable. It is equal to zero
// if the user has redefined matherr(). Otherwise it has a
// non zero value. The default matherr routine does nothing
// and returns 0.
//

int _matherr_flag;

//
// a routine for artificially setting the fp status bits in order
// to signal a software generated masked fp exception.
//

extern void _set_statfp(uintptr_t);


void _raise_exc(_FPIEEE_RECORD *prec,uintptr_t *pcw,
    int flags, int opcode, double *parg1, double *presult);

double _umatherr(int type, unsigned int opcode,
                 double arg1, double arg2, double presult,
                 uintptr_t cw);

static char *_get_fname(unsigned int opcode);

/***
* _handle_qnan1, _handle_qnan2 - handle quiet NaNs as function arguments
*
*Purpose:
*   Do all necessary work for handling the case where the argument
*   or one of the arguments of a floating point function is a quiet NaN
*
*Entry:
*   unsigned int opcode: The operation code of the fp function
*   double x: the fp function argument
*   double y: the fp function second argument (_handle_qnan2 only)
*   uintptr_t savedcw: the user's control word
*
*Exit:
*   restore the user's control word,  and
*   return the suggested return value for the fp function
*
*Exceptions:
*
*******************************************************************************/

double _handle_qnan1(unsigned int opcode,
                     double x,
                     uintptr_t savedcw)
{
    if (! _matherr_flag) {

        //
        // QNaN arguments are treated as domain errors
        // invoke the user's matherr routine
        // _umatherr will take care of restoring the
        // user's control word
        //

        return _umatherr(_DOMAIN,opcode,x,0.0,x,savedcw);
    }
    else {
        errno = EDOM;
        _rstorfp(savedcw);
        return x;
    }
}


double _handle_qnan2(unsigned int opcode,
                     double x,
                     double y,
                     uintptr_t savedcw)
{
    double result;

    //
    // NaN propagation should be handled by the underlying fp h/w
    //

    result = x+y;

    if (! _matherr_flag) {
        return _umatherr(_DOMAIN,opcode,x,y,result,savedcw);
    }
    else {
        errno = EDOM;
        _rstorfp(savedcw);
        return result;
    }
}



/***
* _except1 - exception handling shell for fp functions with one argument
*
*Purpose:
*
*Entry:
*   int flags:  the exception flags
*   int opcode: the operation code of the fp function that faulted
*   double arg: the argument of the fp function
*   double result: default result
*   uintptr_t cw: user's fp control word
*
*Exit:
*   restore user's fp control word
*   and return the (possibly modified) result of the fp function
*
*Exceptions:
*
*******************************************************************************/

double _except1(int flags,
                int opcode,
                double arg,
                double result,
                uintptr_t cw)
{
    int type;

    if (_handle_exc(flags, &result, cw) == 0) {

        //
        // At this point _handle_exception has failed to deal
        // with the error
        // An IEEE exception should be raised
        //

        _FPIEEE_RECORD rec;

        // The rec structure will be filled in by _raise_exc,
        // except for the Operand2 information

        rec.Operand2.OperandValid = 0;
        _raise_exc(&rec, &cw, flags, opcode, &arg, &result);
    }


    //
    // At this point we have either the masked response of the
    // exception, or a value supplied by the user's IEEE exception
    // handler. The _matherr mechanism is supported for backward
    // compatibility.
    //

    type = _errcode(flags);

    // Inexact result fp exception does not have a matherr counterpart;
    // in that case type is 0.

    if (! _matherr_flag && type) {
        return _umatherr(type, opcode, arg, 0.0, result, cw);
    }
    else {
        _set_errno(type);
    }

    RETURN(cw,result);
}



/***
* _except2 - exception handling shell for fp functions with two arguments
*
*Purpose:
*
*Entry:
*   int flags:  the exception flags
*   int opcode: the operation code of the fp function that faulted
*   double arg1: the first argument of the fp function
*   double arg2: the second argument of the fp function
*   double result: default result
*   unsigned int cw: user's fp control word
*
*Exit:
*   restore user's fp control word
*   and return the (possibly modified) result of the fp function
*
*Exceptions:
*
*******************************************************************************/

double _except2(int flags,
                int opcode,
                double arg1,
                double arg2,
                double result,
                uintptr_t cw)
{
    int type;

    if (_handle_exc(flags, &result, cw) == 0) {

        //
        // trap should be taken
        //

        _FPIEEE_RECORD rec;

        //
        // fill in operand2 info. The rest of rec will be
        // filled in by _raise_exc
        //

        rec.Operand2.OperandValid = 1;
        rec.Operand2.Format = _FpFormatFp64;
        rec.Operand2.Value.Fp64Value = arg2;

        _raise_exc(&rec, &cw, flags, opcode, &arg1, &result);

    }

    type = _errcode(flags);

    if (! _matherr_flag && type) {
        return _umatherr(type, opcode, arg1, arg2, result, cw);
    }
    else {
        _set_errno(type);
    }

    RETURN(cw,result);
}



/***
* _raise_exc - raise fp IEEE exception
*
*Purpose:
*   fill in an fp IEEE record struct and raise a fp exception
*
*
*Entry / Exit:
*   IN _FPIEEE_RECORD prec   pointer to an IEEE record
*   IN OUT unsigned int *pcw     pointer to user's fp control word
*   IN int flags,       exception flags
*   IN int opcode,      fp operation code
*   IN double *parg1,        pointer to first argument
*   IN double *presult)      pointer to result
*
*Exceptions:
*
*******************************************************************************/

void _raise_exc( _FPIEEE_RECORD *prec,
                 uintptr_t *pcw,
                 int flags,
                 int opcode,
                 double *parg1,
                 double *presult)
{
    DWORD exc_code;
    uintptr_t sw;

    //
    // reset all control bits
    //

    *(int *)&(prec->Cause) = 0;
    *(int *)&(prec->Enable) = 0;
    *(int *)&(prec->Status) = 0;

    //
    // Precision exception may only coincide with overflow
    // or underflow. If this is the case, overflow (or
    // underflow) take priority over precision exception.
    // The order of checks is from the least important
    // to the most important exception
    //

    if (flags & FP_P) {
        exc_code = (DWORD) STATUS_FLOAT_INEXACT_RESULT;
        prec->Cause.Inexact = 1;
    }
    if (flags & FP_U) {
        exc_code = (DWORD) STATUS_FLOAT_UNDERFLOW;
        prec->Cause.Underflow = 1;
    }
    if (flags & FP_O) {
        exc_code = (DWORD) STATUS_FLOAT_OVERFLOW;
        prec->Cause.Overflow = 1;
    }
    if (flags & FP_Z) {
        exc_code = (DWORD) STATUS_FLOAT_DIVIDE_BY_ZERO;
        prec->Cause.ZeroDivide = 1;
    }
    if (flags & FP_I) {
        exc_code = (DWORD) STATUS_FLOAT_INVALID_OPERATION;
        prec->Cause.InvalidOperation = 1;
    }


    //
    // Set exception enable bits
    //

    prec->Enable.InvalidOperation = (*pcw & IEM_INVALID) ? 0 : 1;
    prec->Enable.ZeroDivide = (*pcw & IEM_ZERODIVIDE) ? 0 : 1;
    prec->Enable.Overflow = (*pcw & IEM_OVERFLOW) ? 0 : 1;
    prec->Enable.Underflow = (*pcw & IEM_UNDERFLOW) ? 0 : 1;
    prec->Enable.Inexact = (*pcw & IEM_INEXACT) ? 0 : 1;


    //
    // Set status bits
    //

    sw = _statfp();


    if (sw & ISW_INVALID) {
        prec->Status.InvalidOperation = 1;
    }
    if (sw & ISW_ZERODIVIDE) {
        prec->Status.ZeroDivide = 1;
    }
    if (sw & ISW_OVERFLOW) {
        prec->Status.Overflow = 1;
    }
    if (sw & ISW_UNDERFLOW) {
        prec->Status.Underflow = 1;
    }
    if (sw & ISW_INEXACT) {
        prec->Status.Inexact = 1;
    }


    switch (*pcw & IMCW_RC) {
    case IRC_CHOP:
        prec->RoundingMode = _FpRoundChopped;
        break;
    case IRC_UP:
        prec->RoundingMode = _FpRoundPlusInfinity;
        break;
    case IRC_DOWN:
        prec->RoundingMode = _FpRoundMinusInfinity;
        break;
    case IRC_NEAR:
        prec->RoundingMode = _FpRoundNearest;
        break;
    }

#ifdef _M_IX86

    switch (*pcw & IMCW_PC) {
    case IPC_64:
        prec->Precision = _FpPrecisionFull;
        break;
    case IPC_53:
        prec->Precision = _FpPrecision53;
        break;
    case IPC_24:
        prec->Precision = _FpPrecision24;
        break;
    }

#endif


#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC)
    prec->Precision = _FpPrecision53;
#endif

    prec->Operation = opcode;

    prec->Operand1.OperandValid = 1;
    prec->Operand1.Format = _FpFormatFp64;
    prec->Operand1.Value.Fp64Value = *parg1;

    prec->Result.OperandValid = 1;
    prec->Result.Format = _FpFormatFp64;
    prec->Result.Value.Fp64Value = *presult;

    //
    // By convention software exceptions use the first exception
    // parameter in order to pass a pointer to the _FPIEEE_RECORD
    // structure.
    //

    _clrfp();

    RaiseException(exc_code,0,1,(uintptr_t *)&prec);


    //
    // user's trap handler may have changed either the fp environment
    // or the result
    //

    //
    // Update exception mask
    //

    if (prec->Enable.InvalidOperation)
        (*pcw) &= ~IEM_INVALID;
    if (prec->Enable.ZeroDivide)
        (*pcw) &= ~IEM_ZERODIVIDE;
    if (prec->Enable.Overflow)
        (*pcw) &= ~IEM_OVERFLOW;
    if (prec->Enable.Underflow)
        (*pcw) &= ~IEM_UNDERFLOW;
    if (prec->Enable.Inexact)
        (*pcw) &= ~IEM_INEXACT;

    //
    // Update Rounding mode
    //

    switch (prec->RoundingMode) {
    case _FpRoundChopped:
         *pcw = *pcw & ~IMCW_RC | IRC_CHOP;
         break;
    case _FpRoundPlusInfinity:
         *pcw = *pcw & ~IMCW_RC | IRC_UP;
         break;
    case _FpRoundMinusInfinity:
         *pcw = *pcw & ~IMCW_RC | IRC_DOWN;
         break;
    case _FpRoundNearest:
         *pcw = *pcw & ~IMCW_RC | IRC_NEAR;
         break;
    }


#ifdef _M_IX86

    //
    // Update Precision Control
    //

    switch (prec->Precision) {
    case _FpPrecisionFull:
         *pcw = *pcw & ~IMCW_RC | IPC_64;
         break;
    case _FpPrecision53:
         *pcw = *pcw & ~IMCW_RC | IPC_53;
         break;
    case _FpPrecision24:
         *pcw = *pcw & ~IMCW_RC | IPC_24;
         break;
    }

#endif

    //
    // Update result
    //

    *presult = prec->Result.Value.Fp64Value;
}



/***
* _handle_exc - produce masked response for IEEE fp exception
*
*Purpose:
*
*Entry:
*   unsigned int flags      the exception flags
*   double *presult         the default result
*   unsigned int cw         user's fp control word
*
*Exit:
*   returns 1 on successful handling, 0 on failure
*   On success, *presult becomes the masked response
*
*Exceptions:
*
*******************************************************************************/

int _handle_exc(unsigned int flags, double * presult, uintptr_t cw)
{
    //
    // flags_p is useful for deciding whether there are still unhandled
    // exceptions in case multiple exceptions have occurred
    //

    int flags_p = flags & (FP_I | FP_Z | FP_O | FP_U | FP_P);

    if (flags & FP_I && cw & IEM_INVALID) {

        //
        // Masked response for invalid operation
        //

        _set_statfp(ISW_INVALID);
        flags_p &= ~FP_I;
    }

    else if (flags & FP_Z && cw & IEM_ZERODIVIDE) {

        //
        // Masked response for Division by zero
        // result should already have the proper value
        //

        _set_statfp( ISW_ZERODIVIDE);
        flags_p &= ~FP_Z;
    }

    else if (flags & FP_O && cw & IEM_OVERFLOW) {

        //
        // Masked response for Overflow
        //

        _set_statfp(ISW_OVERFLOW);
        switch (cw & IMCW_RC) {
        case IRC_NEAR:
            *presult = *presult > 0.0 ? D_INF : -D_INF;
            break;
        case IRC_UP:
            *presult = *presult > 0.0 ? D_INF : -D_MAX;
            break;
        case IRC_DOWN:
            *presult = *presult > 0.0 ? D_MAX : -D_INF;
            break;
        case IRC_CHOP:
            *presult = *presult > 0.0 ? D_MAX : -D_MAX;
            break;
        }

        flags_p &= ~FP_O;
    }

    else if (flags & FP_U && cw & IEM_UNDERFLOW) {

        //
        // Masked response for Underflow:
        // According to the IEEE standard, when the underflow trap is not
        // enabled, underflow shall be signaled only when both tininess
        // and loss of accuracy have been detected
        //

        int aloss=0;    // loss of accuracy flag

        if (flags & FP_P) {
            aloss = 1;
        }

        //
        // a zero value in the result denotes
        // that even after ieee scaling, the exponent
        // was too small.
        // in this case the masked response is also
        // zero (sign is preserved)
        //

        if (*presult != 0.0) {
            double result;
            int expn, newexp;

            result = _decomp(*presult, &expn);
            newexp = expn - IEEE_ADJUST;

            if (newexp < MINEXP - 53) {
                result *= 0.0;          // produce a signed zero
                aloss = 1;
            }
            else {
                int neg = result < 0;       // save sign

                //
                // denormalize result
                //

                (*D_EXP(result)) &= 0x000f; /* clear exponent field */
                (*D_EXP(result)) |= 0x0010; /* set hidden bit */

                for (;newexp<MINEXP;newexp++) {
                    if (*D_LO(result) & 0x1 && !aloss) {
                        aloss = 1;
                    }

                    /* shift mantissa to the right */
                    (*D_LO(result)) >>= 1;
                    if (*D_HI(result) & 0x1) {
                        (*D_LO(result)) |= 0x80000000;
                    }
                    (*D_HI(result)) >>= 1;
                }
                if (neg) {
                    result = -result;       // restore sign
                }
            }

            *presult = result;
        }
        else {
            aloss = 1;
        }

        if (aloss) {
            _set_statfp(ISW_UNDERFLOW);
        }

        flags_p &= ~FP_U;
    }


    //
    // Separate check for precision exception
    // (may coexist with overflow or underflow)
    //

    if (flags & FP_P && cw & IEM_INEXACT) {

        //
        // Masked response for inexact result
        //

        _set_statfp(ISW_INEXACT);
        flags_p &= ~FP_P;
    }

    return flags_p ? 0: 1;
}



/***
* _umatherr - call user's matherr routine
*
*Purpose:
*   call user's matherr routine and set errno if appropriate
*
*
*Entry:
*     int type              type of excpetion
*     unsigned int opcode   fp function that caused the exception
*     double arg1           first argument of the fp function
*     double arg2           second argument of the fp function
*     double retval         return value of the fp function
*     unsigned int cw       user's fp control word
*
*Exit:
*     fp control word       becomes the user's fp cw
*     errno                 modified if user's matherr returns 0
*     return value          the retval entered by the user in
*                           the _exception matherr struct
*
*Exceptions:
*
*******************************************************************************/

double _umatherr(
              int type,
              unsigned int opcode,
              double arg1,
              double arg2,
              double retval,
              uintptr_t cw
              )
{
    struct _exception exc;

    //
    // call matherr only if the name of the function
    // is registered in the table, i.e., only if exc.name is valid
    //

    if (exc.name = _get_fname(opcode)) {
        exc.type = type;

        COPY_DOUBLE(&exc.arg1,&arg1);
        COPY_DOUBLE(&exc.arg2,&arg2);
        COPY_DOUBLE(&exc.retval,&retval);

        _rstorfp(cw);

        if (_matherr(&exc) == 0) {
            _set_errno(type);
        }
        return  exc.retval;
    }
    else {

        //
        // treat this case as if matherr returned 0
        //

        _rstorfp(cw);
        _set_errno(type);
        return retval;
    }

}



/***
* _set_errno - set errno
*
*Purpose:
*   set correct error value for errno
*
*Entry:
*   int matherrtype:    the type of math error
*
*Exit:
*   modifies errno
*
*Exceptions:
*
*******************************************************************************/

void _set_errno(int matherrtype)
{
    switch(matherrtype) {
    case _DOMAIN:
        errno = EDOM;
        break;
    case _OVERFLOW:
    case _SING:
        errno = ERANGE;
        break;
    }
}



/***
* _get_fname -  get function name
*
*Purpose:
*  returns the _matherr function name that corresponds to a
*  floating point opcode
*
*Entry:
*  _FP_OPERATION_CODE opcode
*
*Exit:
*   returns a pointer to a string
*
*Exceptions:
*
*******************************************************************************/
#define OP_NUM  29   /* number of fp operations */

static char *_get_fname(unsigned int opcode)
{

    static struct {
        unsigned int opcode;
        char *name;
    } _names[OP_NUM] = {
        { OP_EXP,   "exp" },
        { OP_POW,   "pow" },
        { OP_LOG,   "log" },
        { OP_LOG10, "log10"},
        { OP_SINH,  "sinh"},
        { OP_COSH,  "cosh"},
        { OP_TANH,  "tanh"},
        { OP_ASIN,  "asin"},
        { OP_ACOS,  "acos"},
        { OP_ATAN,  "atan"},
        { OP_ATAN2, "atan2"},
        { OP_SQRT,  "sqrt"},
        { OP_SIN,   "sin"},
        { OP_COS,   "cos"},
        { OP_TAN,   "tan"},
        { OP_CEIL,  "ceil"},
        { OP_FLOOR, "floor"},
        { OP_ABS,   "fabs"},
        { OP_MODF,  "modf"},
        { OP_LDEXP, "ldexp"},
        { OP_CABS,  "_cabs"},
        { OP_HYPOT, "_hypot"},
        { OP_FMOD,  "fmod"},
        { OP_FREXP, "frexp"},
        { OP_Y0,    "_y0"},
        { OP_Y1,    "_y1"},
        { OP_YN,    "_yn"},
        { OP_LOGB,  "_logb"},
        { OP_NEXTAFTER, "_nextafter"}
    };

    int i;
    for (i=0;i<OP_NUM;i++) {
        if (_names[i].opcode == opcode)
            return _names[i].name;
    }
    return (char *)0;
}



/***
* _errcode - get _matherr error code
*
*Purpose:
*   returns matherr type that corresponds to exception flags
*
*Entry:
*   flags: exception flags
*
*Exit:
*   returns matherr type
*
*Exceptions:
*
*******************************************************************************/

int _errcode(unsigned int flags)
{
    unsigned int errcode;

    if (flags & FP_TLOSS) {
        errcode = _TLOSS;
    }
    else if (flags & FP_I) {
        errcode = _DOMAIN;
    }
    else if (flags & FP_Z) {
        errcode = _SING;
    }
    else if (flags & FP_O) {
        errcode = _OVERFLOW;
    }
    else if (flags & FP_U) {
        errcode = _UNDERFLOW;
    }
    else {

        // FP_P

        errcode = 0;
    }
    return errcode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\fmod.c ===
/***
*fmod.c - floating point remainder
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*        1-13-92  GDP   support IEEE exceptions
*        3-04-92  GDP   complete rewrite for improved accuracy
*        3-16-92  GDP   restore cw properly, do not raise Inexact exception
*       06-23-92  GDP   support NCEG special return values (signed 0's etc)
*       02-06-95  JWM   Mac merge
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

#if defined(_M_IA64)
#pragma function(fmod)
#endif

/***
*double fmod(double x, double y)
*
*Purpose:
*   Return f, s.t. x = i*y + f, where i is an integer, f has the same
*   sign as x, and |f| < |y|
*
*Entry:
*
*Exit:
*
*Exceptions:
*   I,P
*******************************************************************************/
#define SCALE  53

double fmod(double x, double y)
{
    uintptr_t savedcw;
    int neg=0;
    int denorm=0;
    double d,tx,ty,fx,fy;
    int nx, ny, nexp;



    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(y) || IS_D_SPECIAL(x)){
        if (IS_D_SNAN(y) || IS_D_SNAN(x)){
            return _except2(FP_I,OP_FMOD,x,y,_d_snan2(x,y),savedcw);
        }
        if (IS_D_QNAN(y) || IS_D_QNAN(x)){
            return _handle_qnan2(OP_FMOD,x,y,savedcw);
        }

        if (IS_D_INF(x) || IS_D_MINF(x)) {
            return _except2(FP_I,OP_FMOD,x,y,QNAN_FMOD,savedcw);
        }

        RETURN(savedcw, x);
    }


    if (y == 0) {
        return _except2(FP_I,OP_FMOD,x,y,QNAN_FMOD,savedcw);
    }

    if (x == 0) {
        RETURN(savedcw, x);      // NCEG spec
    }


    if (x < 0) {
        tx = -x;
        neg = 1;
    }
    else {
        tx = x;
    }

    ty = ABS(y);


    while (tx >= ty) {
        fx = _decomp(tx, &nx);
        fy = _decomp(ty, &ny);

        if (nx < MINEXP) {
            // tx is a denormalized number
            denorm = 1;
            nx += SCALE;
            ny += SCALE;
            tx = _set_exp(fx, nx);
            ty = _set_exp(fy, ny);
        }


        if (fx >= fy) {
            nexp = nx ;
        }
        else {
            nexp = nx - 1;
        }
        d = _set_exp(fy, nexp);
        tx -= d;
    }

    if (denorm) {

        //
        // raise only FP_U exception
        //

        return _except2(FP_U,
                        OP_FMOD,
                        x,
                        y,
                        _add_exp(tx, IEEE_ADJUST-SCALE),
                        savedcw);
    }

    if (neg) {
        tx = -tx;
    }

    RETURN(savedcw,tx);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\floor.c ===
/***
*floor.c - floor
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*        1-09-92  GDP   support IEEE exceptions
*        6-23-92  GDP   floor(INF) now returns INF (NCEG spec)
*       02-06-95  JWM   Mac merge
*       01-26-01  PML   Pentium4 merge
*
*******************************************************************************/
#include <math.h>
#include <trans.h>

extern double _frnd(double);

/***
*double floor(double x) - floor
*
*Purpose:
*   Return a double representing the largest integer that is
*   less than or equal to x
*
*Entry:
*
*Exit:
*
*Exceptions:
*    I, P
*******************************************************************************/
static unsigned int newcw = (ICW & ~IMCW_RC) | (IRC_DOWN & IMCW_RC);


#if !defined(_M_IX86)
double floor(double x)
#else
double _floor_default(double x)
#endif
{
    uintptr_t savedcw;
    double result;

    /* save user fp control word */
    savedcw = _ctrlfp(newcw,IMCW);      /* round down */

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
        case T_NINF:
            RETURN(savedcw,x);
        case T_QNAN:
            return _handle_qnan1(OP_FLOOR, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I, OP_FLOOR, x, _s2qnan(x), savedcw);
        }
    }


    result = _frnd(x); /* round according to the current rounding mode */

    // In general, the Precision Exception should be raised if
    // _frnd reports a precision loss. In order to detect this with
    // masked exceptions, the status word needs to be cleared.
    // However, we want to avoid this, since the 387 instruction
    // set does not provide an fast way to restore the status word

    if (result == x) {
        RETURN(savedcw,result);
    }
    else {
        RETURN_INEXACT1(OP_FLOOR, x, result, savedcw);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ldexp.c ===
/***
*ldexp.c - multiply by a power of two
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*        1-13-92  GDP   rewritten to support IEEE exceptions
*        5-05-92  GDP   bug fix for x denormal
*       07-16-93  SRW   ALPHA Merge
*       11-18-93  GJF   Merged in NT SDK verion.
*
*******************************************************************************/
#include <math.h>
#include <float.h>
#include <trans.h>
#include <limits.h>

/***
*double ldexp(double x, int exp)
*
*Purpose:
*   Compute x * 2^exp
*
*Entry:
*
*Exit:
*
*Exceptions:
*    I  U  O  P
*
*******************************************************************************/
double ldexp(double x, int exp)
{
    uintptr_t savedcw;
    int oldexp;
    long newexp; /* for checking out of bounds exponents */
    double result, mant;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
        case T_NINF:
            RETURN(savedcw,x);
        case T_QNAN:
            return _handle_qnan2(OP_LDEXP, x, (double)exp, savedcw);
        default: //T_SNAN
            return _except2(FP_I,OP_LDEXP,x,(double)exp,_s2qnan(x),savedcw);
        }
    }


    if (x == 0.0) {
        RETURN(savedcw,x);
    }

    mant = _decomp(x, &oldexp);

    if (ABS(exp) > INT_MAX)
        newexp = exp; // avoid possible integer overflow
    else
        newexp = oldexp + exp;


    /* out of bounds cases */
    if (newexp > MAXEXP + IEEE_ADJUST) {
        return _except2(FP_O|FP_P,OP_LDEXP,x,(double)exp,_copysign(D_INF,mant),savedcw);
    }
    if (newexp > MAXEXP) {
        result = _set_exp(mant, newexp-IEEE_ADJUST);
        return _except2(FP_O|FP_P,OP_LDEXP,x,(double)exp,result,savedcw);
    }
    if (newexp < MINEXP - IEEE_ADJUST) {
        return _except2(FP_U|FP_P,OP_LDEXP,x,(double)exp,mant*0.0,savedcw);
    }
    if (newexp < MINEXP) {
        result = _set_exp(mant, newexp+IEEE_ADJUST);
        return _except2(FP_U|FP_P,OP_LDEXP,x,(double)exp,result,savedcw);
    }

    result = _set_exp(mant, (int)newexp);

    RETURN(savedcw,result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ieeemisc.c ===
/***
* ieeemisc.c - IEEE miscellaneous recommended functions
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        5-04-92  GDP   written
*        8-13-96  JWM   Order of tests in _fpclass() rearranged, since
*                       "if (x==0.0)" now uses FP hardware.
*       11-25-00  PML   IA64 _logb and _isnan supplied by libm .s code.
*
*******************************************************************************/

#include <trans.h>
#include <math.h>
#include <float.h>


/***
* _copysign - copy sign
*
*Purpose:
*   copysign(x,y) returns x with the sign of y. Hence, abs(x) := copysign
*   even if x is NaN [IEEE std 854-1987 Appendix]
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*   No exceptions, even if one of the arguments is NaN.
*
*   (Currently the i386 compiler returns doubles on the fp stack
*   so the fld instruction at the end will cause an invalid operation
*   if x is NaN. However this compiler calling convention will change
*   soon)
*
*******************************************************************************/

double _copysign (double x, double y)
{
    double retval;
    *D_LO(retval) = *D_LO(x);
    *D_HI(retval) = *D_HI(x) & ~(1<<31) |
                    *D_HI(y) &  (1<<31) ;

    return retval;
}



/***
* _chgsign - change sign
*
*Purpose:
*  x is copied with its sign reversed, not 0-x; the distinction is germane
*  when x is +0, -0, or NaN
*
*Entry:
*
*Exit:
*
*Exceptions:
*   No exceptions, even if x is NaN.
*
*   (Currently the i386 compiler returns doubles on the fp stack
*   so the fld instruction at the end will cause an invalid operation
*   if x is NaN. However this compiler calling convention will change
*   soon)
*
*******************************************************************************/

double _chgsign (double x)
{
    double retval;

    *D_LO(retval) = *D_LO(x);
    *D_HI(retval) = *D_HI(x) & ~(1 << 31)  |
                    ~*D_HI(x) & (1<<31);

    return retval;
}


/***
* _scalb - scale by power of 2
*
*Purpose:
*   _scalb(x,n) returns x * 2^n for integral values of n without
*   computing 2^n
*   Special case:
*      If x is infinity or zero, _scaleb returns x
*
*
*Entry:
*   double x
*   int   n
*
*Exit:
*
*Exceptions:
*   Invalid operation, Overflow, Underflow
*
*******************************************************************************/

double _scalb(double x, long n)
{
    //
    // It turns out that our implementation of ldexp matces the IEEE
    // description of _scalb. The only problem with calling ldexp
    // is that if an exception occurs, the operation code reported
    // to the handler will be the one that corresponds to ldexp
    // (i.e., we do not define a new operation code for _scalb
    //

    return ldexp(x,n);
}


#if !defined(_M_IA64)

/***
* _logb - extract exponent
*
*Purpose:
*   _logb(x) returns the unbiased exponent of x, a signed integer in the
*   format of x, except that logb(NaN) is a NaN, logb(+INF) is +INF,and
*   logb(0) is is -INF and signals the division by zero exception.
*   For x positive and finite, 1<= abs(scalb(x, -logb(x))) < 2
*
*
*Entry:
*   double x
*   int   n
*
*Exit:
*
*Exceptions:
*   Invalid operation, Division by zero
*
*******************************************************************************/
double _logb(double x)
{
    uintptr_t savedcw;
    int exp;
    double retval;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
        case T_NINF:
            RETURN(savedcw, x);
        case T_QNAN:
            return _handle_qnan1(OP_LOGB, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I, OP_LOGB, x, _s2qnan(x), savedcw);
        }
    }

    if (x == 0) {
         return _except1(FP_Z, OP_LOGB, x, -D_INF, savedcw);
    }

    (void) _decomp(x, &exp);

    //
    // x == man * 2^exp, where .5 <= man < 1. According to the spec
    // of this function, we should compute the exponent so that
    // 1<=man<2, i.e., we should decrement the computed exp by one
    //

    retval = (double) (exp - 1);

    RETURN(savedcw, retval);

}

#endif  // !defined(_M_IA64)



/***
* _nextafter - next representable neighbor
*
*Purpose:
*  _nextafter(x,y) returns the next representable neighbor of x in
*  the direction toward y. The following special cases arise: if
*  x=y, then the result is x without any exception being signaled;
*  otherwise, if either x or y is a quiet NaN, then the result is
*  one or the other of the input NaNs. Overflow is sibnaled when x
*  is finite but nextafter(x,y) is infinite; underflow is signaled
*  when nextafter(x,y) lies strictly between -2^Emin, 2^Emin; in
*  both cases, inexact is signaled.
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*   O, U, I, P
*
*******************************************************************************/

double _nextafter(double x, double y)
{
    uintptr_t savedcw;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x) || IS_D_SPECIAL(y)){
        if (IS_D_SNAN(x) || IS_D_SNAN(y)){
            return _except2(FP_I,OP_NEXTAFTER,x,y,_d_snan2(x,y),savedcw);
        }
        if (IS_D_QNAN(x) || IS_D_QNAN(y)){
            return _handle_qnan2(OP_NEXTAFTER,x,y,savedcw);
        }

        //
        // infinite arguments are not treated as special cases
        //
    }

    if (y == x) {

        //
        // no exceptions are raised in this case
        //

        RETURN(savedcw, x);
    }

    if (x == 0) {

        *D_LO(result) = 1;

        if (y > x) {
            *D_HI(result) = 0;
        }

        else {

            //
            // result should be negative
            //

            *D_HI(result) = (unsigned long)(1<<31);
        }

    }


    //
    // At this point x!=y, and x!=0. x can be treated as a 64bit
    // integer in sign/magnitude representation. To get the next
    // representable neighbor we add or subtract one from this
    // integer. (Note that for boundary cases like x==INF, need to
    // add one will never occur --this would mean that y should
    // be greater than INF, which is impossible)
    //

    if (x > 0 && y < x ||
        x < 0 && y > x) {

        //
        // decrease value by one
        //

        *D_LO(result) = *D_LO(x) - 1;
        *D_HI(result) = *D_HI(x);

        if (*D_LO(x) == 0) {

            //
            // a borrow should propagate to the high order dword
            //

            (*D_HI(result)) --;
        }
    }

    else if (x > 0 && y > x ||
             x < 0 && y < x) {

        //
        // increase value by one
        //

        *D_LO(result) = *D_LO(x) + 1;
        *D_HI(result) = *D_HI(x);

        if (*D_LO(result) == 0) {

            //
            // a carry should propagate to the high order dword
            //

            (*D_HI(result)) ++;
        }
    }


    //
    // check if an exception should be raised
    //


    if ( IS_D_DENORM(result) ) {

        //
        // should signal underflow and inexact
        // and provide a properly scaled value
        //

        double mant;
        int exp;

        mant = _decomp(result, &exp);
        result = _set_exp(mant, exp+IEEE_ADJUST);

        return _except2(FP_U|FP_P,OP_NEXTAFTER,x,y,result,savedcw);
    }



    if ( IS_D_INF(result) || IS_D_MINF(result) ) {

        //
        // should signal overflow and inexact
        // and provide a properly scaled value
        //

        double mant;
        int exp;

        mant = _decomp(result, &exp);
        result = _set_exp(mant, exp-IEEE_ADJUST);

        return _except2(FP_O|FP_P,OP_NEXTAFTER,x,y,result,savedcw);
    }


    RETURN(savedcw, result);
}




/***
* _finite -
*
*Purpose:
*   finite(x) returns the value TRUE if -INF < x < +INF and returns
*   false otherwise [IEEE std]
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*   This routine is treated as a nonarithmetic operation, therefore
*   it does not signal any floating point exceptions
*
*******************************************************************************/

int _finite(double x)
{
    if (IS_D_SPECIAL(x)) {

        //
        // x is INF or NaN
        //

        return 0;
    }
    return 1;
}



#if !defined(_M_IA64)

/***
* _isnan -
*
*Purpose:
*   isnan(x) returns the value TRUE if x is a NaN, and returns FALSE
*   otherwise.
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*   This routine is treated as a nonarithmetic operation, therefore
*   it does not signal any floating point exceptions
*
*******************************************************************************/

int _isnan(double x)
{
    if (IS_D_SNAN(x) || IS_D_QNAN(x)) {
        return 1;
    }
    return 0;
}

#endif  // !defined(_M_IA64)


/***
*double _fpclass(double x) - floating point class
*
*Purpose:
*   Compute the floating point class of a number, according
*   to the recommendations of the IEEE std. 754
*
*Entry:
*
*Exit:
*
*Exceptions:
*   This function is never exceptional, even when the argument is SNAN
*
*******************************************************************************/

int _fpclass(double x)
{
    int sign;

    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
            return _FPCLASS_PINF;
        case T_NINF:
            return _FPCLASS_NINF;
        case T_QNAN:
            return _FPCLASS_QNAN;
        default: //T_SNAN
            return _FPCLASS_SNAN;
        }
    }
    sign = (*D_EXP(x)) & 0x8000;

    if (IS_D_DENORM(x))
        return sign? _FPCLASS_ND : _FPCLASS_PD;

    if (x == 0.0)
        return sign? _FPCLASS_NZ : _FPCLASS_PZ;

    return sign? _FPCLASS_NN : _FPCLASS_PN;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\hypot.c ===
/***
*hypot.c - hypotenuse and complex absolute value
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       08-15-91  GDP   written
*       10-20-91  GDP   removed inline assembly for calling sqrt
*
*******************************************************************************/
#include <math.h>
#include <trans.h>

static double _hypothlp(double x, double y, int who);

/*
 *  Function name:  hypot
 *
 *  Arguments:      x, y  -  double
 *
 *  Description:    hypot returns sqrt(x*x + y*y), taking precautions against
 *                  unwarrented over and underflows.
 *
 *  Side Effects:   no global data is used or affected.
 *
 *  Author:         written  R.K. Wyss, Microsoft,  Sept. 9, 1983
 *
 *  History:
 *      03/13/89  WAJ   Minor changes to source.
 *      04/13/89  WAJ   Now uses _cdecl for _CDECL
 *      06/07/91  JCR   ANSI naming (_hypot)
 *      08/26/91  GDP   NaN support, error handling
 *      01/13/91  GDP   IEEE exceptions support
 */

double _hypot(double x, double y)
{
    return _hypothlp(x,y,OP_HYPOT);
}

/***
*double _cabs(struct _complex z) - absolute value of a complex number
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*******************************************************************************/
double _cabs(struct _complex z)
{
    return( _hypothlp(z.x, z.y, OP_CABS ) );
}



static double _hypothlp(double x, double y, int who)
{
    double max;
    double result, sum;
    uintptr_t savedcw;
    int exp1, exp2, newexp;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x) || IS_D_SPECIAL(y)){
        if (IS_D_SNAN(x) || IS_D_SNAN(y)){
            return _except2(FP_I,who,x,y,_d_snan2(x,y),savedcw);
        }
        if (IS_D_QNAN(x) || IS_D_QNAN(y)){
            return _handle_qnan2(who,x,y,savedcw);
        }
        /* there is at least one infinite argument ... */
        RETURN(savedcw,D_INF);
    }


    /* take the absolute values of x and y, compute the max, and then scale by
       max to prevent over or underflowing */

    if ( x < 0.0 )
        x = - x;

    if ( y < 0.0 )
        y = - y;

    max = ( ( y > x ) ?  y : x );

    if ( max == 0.0 )
        RETURN(savedcw, 0.0 );

    x /= max;   //this may pollute the fp status word (underflow flag)
    y /= max;

    sum = x*x + y*y;

    result = _decomp(sqrt(sum),&exp1) * _decomp(max,&exp2);
    newexp = exp1 + exp2 + _get_exp(result);

    // in case of overflow or underflow
    // adjusting exp by IEEE_ADJUST will certainly
    // bring the result in the representable range

    if (newexp > MAXEXP) {
        result = _set_exp(result, newexp - IEEE_ADJUST);
        return _except2(FP_O | FP_P, who, x, y, result, savedcw);
    }
    if (newexp < MINEXP) {
        result = _set_exp(result, newexp + IEEE_ADJUST);
        return _except2(FP_U | FP_P, who, x, y, result, savedcw);
    }

    result = _set_exp(result, newexp);
    // fix needed: P exception is raised even if the result is exact

    RETURN_INEXACT2(who, x, y, result, savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\matherr.c ===
/***
*matherr.c - floating point exception handling
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*       08-03-94  GJF   Revised to support user-supplied version of _matherr
*                       in clients of msvcrt*.dll.
*       05-13-99  PML   Remove Win32s
*
*******************************************************************************/

#include <math.h>
#include <stddef.h>

int _matherr_flag = 9876;

#if     defined(CRTDLL) && !defined(_NTSDK)

/*
 * Pointer to user-supplied _matherr routine if one has been supplied.
 */
int (__cdecl * pusermatherr)(struct _exception *) = NULL;

/***
*void __setusermatherr ( int (__cdecl *pf)(struct exception *) )
*
*Purpose:
*       Copy pointer to user-supplied matherr routine into pusermatherr
*
*Entry:
*       pf  - pointer to an implementation of _matherr supplied by the user
*Exit:
*
*Exceptions:
*******************************************************************************/

_CRTIMP void __setusermatherr( int (__cdecl *pf)(struct _exception *) )
{
        pusermatherr = pf;
        _matherr_flag = 0;
}

#endif

/***
*int _matherr(struct _exception *except) - handle math errors
*
*Purpose:
*   Permits the user customize fp error handling by redefining this function.
*
*   The default matherr does nothing and returns 0
*
*Entry:
*
*Exit:
*
*Exceptions:
*******************************************************************************/
int _matherr(struct _exception *pexcept)
{
#if     defined(CRTDLL) && !defined(_NTSDK)

        /*
         * If user has supplied a _matherr implementation, pass control to
         * it and let it handle the error.
         */
        if ( pusermatherr != NULL )
                return pusermatherr(pexcept);
#endif
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\powhlp.c ===
/***
*powhlp.c - pow() helper routines for handling special cases
*
*	Copyright (c) 1991-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*	pow(x,y) helper routine. Handles +inf, -inf
*
*Revision History:
*   11-09-91	GDP
*   06-23-92	GDP	adjusted return values according to the NCEG spec
*   02-06-95	JWM	Mac merge
*	02-07-95	JWM	powhlp() restored to Intel version.
*
*******************************************************************************/
#include <trans.h>
#include <float.h>

/***
*int _powhlp(double x, double y, double * result) - pow() helper
*
*Purpose:
*   Calculate x^(sign)inf
*
*Entry:
*   double x: the base
*   int sign: the sign of the infinite exponent (0: pos, non-0: neg)
*   double *result: pointer to the result
*
*Exit:
*   0: normal exit
*   -1: indicates domain error for pow(x,inf)
*
*Exceptions:
*
***************************************************************************/

int _powhlp(double x, double y, double * result)
{
    double absx;
    int err = 0;


    absx = ABS(x);

    if (IS_D_INF(y)) {
	if (absx > 1.0) {
	    *result = D_INF;
	}
	else if (absx < 1.0) {
	    *result = 0.0;
	}
	else {
	    *result = D_IND;
	    err = 1;
	}
    }

    else if (IS_D_MINF(y)) {
	if (absx > 1.0) {
	    *result = 0.0;
	}
	else if (absx < 1.0) {
	    *result = D_INF;
	}
	else {
	    *result = D_IND;
	    err = 1;
	}
    }

    else if (IS_D_INF(x)) {
	if (y > 0)
	    *result = D_INF;
	else if (y < 0.0)
	    *result = 0.0;
	else {
	    *result = 1.0;
	}
    }

    else if (IS_D_MINF(x)) {
	int type;

	type = _d_inttype(y);

	if (y > 0.0) {
	    *result = (type == _D_ODD ? -D_INF : D_INF);
	}
	else if (y < 0.0) {
	    *result = (type == _D_ODD ? D_MZERO : 0.0);
	}
	else {
	    *result = 1;
	}

    }

    return err;
}




int _d_inttype(double y)
{
    double rounded;
    /* check if y is an integral value */
    if (_fpclass(y) & (_FPCLASS_PD | _FPCLASS_ND))
      return _D_NOINT;
    rounded = _frnd(y);
    if (rounded == y) {
	if (_frnd(y/2.0) == y/2.0)
	    return _D_EVEN;
	else
	    return _D_ODD;
    }
    return _D_NOINT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\modf.c ===
/***
*modf.c - modf()
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*        1-13-92  GDP   support IEEE exceptions
*        6-23-92  GDP   modified special return values for NCEG conformance
*       02-06-95  JWM   Mac merge
*       01-26-01  PML   Pentium4 merge
*       02-28-01  PML   Make sure 0.0 fraction return has correct sign
*
*******************************************************************************/

#include <math.h>
#include <trans.h>
#include <float.h>

extern double _frnd(double);
extern double _copysign (double x, double y);

/***
*double modf(double x, double *intptr)
*
*Purpose:
*   Split x into fractional and integer part
*   The signed fractional portion is returned
*   The integer portion is stored as a floating point value at intptr
*
*Entry:
*
*Exit:
*
*Exceptions:
*    I
*******************************************************************************/
static  uintptr_t newcw = (ICW & ~IMCW_RC) | (IRC_CHOP & IMCW_RC);

#if !defined(_M_IX86)
double modf(double x, double *intptr)
#else
double _modf_default(double x, double *intptr)
#endif
{
    uintptr_t savedcw;
    double result,intpart;

    /* save user fp control word */
    savedcw = _ctrlfp(0, 0);     /* get old control word */
    _ctrlfp(newcw,IMCW);        /* round towards 0 */

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        *intptr = QNAN_MODF;
        switch (_sptype(x)) {
        case T_PINF:
        case T_NINF:
            *intptr = x;
            result = _copysign(0, x);
            RETURN(savedcw,result);
        case T_QNAN:
            *intptr = x;
            return _handle_qnan1(OP_MODF, x, savedcw);
        default: //T_SNAN
            result = _s2qnan(x);
            *intptr = result;
            return _except1(FP_I, OP_MODF, x, result, savedcw);
        }
    }

    intpart = _frnd(x); //fix needed: this may set the P exception flag
                        //and pollute the fp status word

    *intptr = intpart;
    result = x - intpart;

    if (result == 0.0) {
	/* Make sure fractional part of 0.0 has the correct sign */
	*D_EXP(result) |= (*D_EXP(x) & 0x8000);
    }

    RETURN(savedcw,result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\pow.c ===
/***
*pow.c - raise to a power
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-15-91  GDP   written
*       12-20-91  GDP   support IEEE exceptions & denormals
*        1-11-92  GDP   special handling of small powers
*                       special handling of u1, u2 when cancellation occurs
*        3-22-92  GDP   changed handling of int exponents, pow(0, neg)
*                       added check to avoid internal overflow due to large y
*        6-23-92  GDP   adjusted special return values according to NCEG spec
*       02-06-95  JWM   Mac merge
*       02-07-95  JWM   powhlp() usage restored to Intel version.
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>
#include <float.h>

#if defined(_M_IA64)
#pragma function(pow)
#endif

static double _reduce(double);

static double const a1[18] = {
    0.00000000000000000000e+000,   /* dummy element */
    1.00000000000000000000e+000,
    9.57603280698573646910e-001,
    9.17004043204671231754e-001,
    8.78126080186649741555e-001,
    8.40896415253714543073e-001,
    8.05245165974627154042e-001,
    7.71105412703970411793e-001,
    7.38413072969749655712e-001,
    7.07106781186547524436e-001,
    6.77127773468446364133e-001,
    6.48419777325504832961e-001,
    6.20928906036742024317e-001,
    5.94603557501360533344e-001,
    5.69394317378345826849e-001,
    5.45253866332628829604e-001,
    5.22136891213706920173e-001,
    5.00000000000000000000e-001
};

static double const a2[9] = {
    0.00000000000000000000e+000,   /* dummy element */
   -5.31259064517897172664e-017,
    1.47993596544271355242e-017,
    1.23056946577104753260e-017,
   -1.74014448683923461658e-017,
    3.84891771232354074073e-017,
    2.33103467084383453312e-017,
    4.45607092891542322377e-017,
    4.27717757045531499216e-017
};

static double const log2inv = 1.44269504088896340739e+0; //  1/log(2)
static double const K = 0.44269504088896340736e+0;

static double const p1 = 0.83333333333333211405e-1;
static double const p2 = 0.12500000000503799174e-1;
static double const p3 = 0.22321421285924258967e-2;
static double const p4 = 0.43445775672163119635e-3;

#define P(v) (((p4 * v + p3) * v + p2) * v + p1)

static double const q1 = 0.69314718055994529629e+0;
static double const q2 = 0.24022650695909537056e+0;
static double const q3 = 0.55504108664085595326e-1;
static double const q4 = 0.96181290595172416964e-2;
static double const q5 = 0.13333541313585784703e-2;
static double const q6 = 0.15400290440989764601e-3;
static double const q7 = 0.14928852680595608186e-4;

#define Q(w)   ((((((q7 * w + q6) * w + q5) * w + q4) * w + \
                              q3) * w + q2) * w + q1)


/*
 * Thresholds for over/underflow that results in an adjusted value
 * too big/small to be represented as a double. An infinity or 0
 * is delivered to the trap handler instead
 */

static _dbl const _ovfx ={SET_DBL(0x40e40000,0)}; // 16*log2(XMAX*2^IEEE_ADJ)
static _dbl const _uflx ={SET_DBL(0xc0e3fc00,0)}; // 16*log2(XMIN*2^(-IEEE_ADJ))

#define OVFX _ovfx.dbl
#define UFLX _uflx.dbl

#define INT_POW_LIMIT   128.0

static double ymax = 1e20;

static double _reduce(double x)
{
    return 0.0625 * _frnd( 16.0 * x);
}

/***
*double pow(double x, double y) - x raised to the power of y
*
*Purpose:
*   Calculate x^y
*   Algorithm from Cody & Waite
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*   All 5 IEEE exceptions may occur
*
*******************************************************************************/
double pow(double x, double y)
{
    uintptr_t savedcw;
    int m,mprim;
    int p,pprim;
    int i,iw1;
    int iy;
    int newexp;
    double diw1;
    double sign;
    double g,z,bigz,v,rz,result;
    double u1,u2,y1,y2,w,w1,w2;
    double savedx;

    /* save user fp control word */
    savedcw = _maskfp();
    savedx = x;         // save original value of first argument

    if (_fpclass(y) & (_FPCLASS_NZ | _FPCLASS_PZ)) {
        RETURN(savedcw, 1.0);
    }

    /* Check for zero^y */
    if (_fpclass(x) & (_FPCLASS_NZ | _FPCLASS_PZ)) { /* x==0? */
        int type;

        type = _d_inttype(y);

        if (y < 0.0) {
            result = (type == _D_ODD ? _copysign(D_INF,x) : D_INF);
            return _except2(FP_Z,OP_POW,savedx,y,result,savedcw|ISW_ZERODIVIDE);
        }
        else if (y > 0.0) {
            result = (type == _D_ODD ? x : 0.0);
                RETURN(savedcw, result);
        }
    }

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x) || IS_D_SPECIAL(y)) {
      double absx = fabs(x);

      if (IS_D_SNAN(x) || IS_D_SNAN(y)) {
        return _except2(FP_I,OP_POW,savedx,y,_d_snan2(x,y),savedcw | (ISW_INVALID>>5) );
      }
      if (IS_D_QNAN(x) || IS_D_QNAN(y)){
        return _handle_qnan2(OP_POW,x,y,savedcw | (ISW_INVALID>>5) );
      }
      
      /* there is at least one infinite argument ... */
      if (_powhlp(x, y, &result)) { /* removed "<" 0. */
        return _except2(FP_I,OP_POW,savedx,y,result,savedcw | (ISW_INVALID>>5) );
      }
      RETURN(savedcw, result);
    }

    sign = 1.0;
    if (x < 0) {
        switch (_d_inttype(y)) {
        case _D_ODD: /* y is an odd integral value */
            sign = -1.0;
            /* NO BREAK */
        case _D_EVEN:
            x = -x;
            break;
        default: /* y is not an integral value */
            return _except2(FP_I,OP_POW,savedx,y,D_IND,savedcw|(ISW_INVALID>>5));
        }
    }

    //
    // This is here in order to prevent internal overflows
    // due to a large value of y
    // The following relation holds on overflow with a scaled
    // result out of range
    // (lg stands for log base 2)
    //      |y| * |lg(x)| > MAXEXP + IEEE_ADJUST        <=>
    //      |y| >  2560 / |lg(x)|
    // The values of lg(x) closer to 0 are:
    //      x                                    lg(x)
    //  3fefffffffffffff    (0,99...9)        -1.601e-16
    //  3ff0000000000000    (1.0)              0.0
    //  3ff0000000000001    (1.00...1)         3.203e-16
    //
    // So if |y| > 2560/1.6e-16 = 1.6e19 overflow occurs
    // We set ymax to 1e20 in order to have a safety margin
    //

    if (ABS(y) > ymax) {
        if (y < 0) {
            y = -y;
            //
            // this may cause an underflow
            // there is no problem with fp sw pollution because
            // a FP_U exception is going to be raised anyway.
            //
            x = 1.0 / x;
        }
        if (x > 1.0) {
            return _except2(FP_O | FP_P,OP_POW,savedx,y,sign*D_INF,savedcw|ISW_OVERFLOW);
        }
        else if (x < 1.0){
            return _except2(FP_U | FP_P,OP_POW,savedx,y,sign*0.0,savedcw|ISW_UNDERFLOW);
        }
        else {
            RETURN(savedcw, sign*1.0);
        }
    }


    /* determine m, g */
    g = _decomp(x, &m);


    /* handle small integer powers
     * for small integer powers this is faster that Cody&Waite's
     * algorithm, and yields better precision
     * Without this piece of code there was not enough precision
     * to satisfy all requirements of the 'paranoia' test.
     * We choose INT_POW_LIMIT such that (1) no overflow or underflow
     * occurs while computing bigz (g is in the range
     * [0.5, 1.0) or (1.0, 2.0] so INT_POW_LIMIT should be less than
     * approximately 10^3) and (2) no extraordinary loss of precision
     * occurs because of repeated multiplications (this practically
     * restricts the maximum INT_POW_LIMIT to 128).
     */

    if (y <= INT_POW_LIMIT &&
        _d_inttype(x) != _D_NOINT &&
        _d_inttype(y) != _D_NOINT &&
        y > 0.0 ) {

        iy = (int)y;
        mprim = m * iy;

        for (bigz=1 ; iy ; iy >>= 1, g *= g) {
            if (iy & 0x1)
                bigz *= g;
        }

        newexp = _get_exp(bigz) + mprim;
        if (newexp > MAXEXP + IEEE_ADJUST) {
            return _except2(FP_O | FP_P, OP_POW, savedx, y, sign*bigz*D_INF, savedcw);
        }
        if (newexp < MINEXP - IEEE_ADJUST) {
            return _except2(FP_U | FP_P, OP_POW, savedx, y, sign*bigz*0.0, savedcw);
        }

    }


    else {

        /* determine p using binary search */
        p = 1;
        if (g <= a1[9])
            p = 9;
        if (g <= a1[p+4])
            p += 4;
        if (g <= a1[p+2])
            p += 2;


        /* C&W's algorithm is not very accurate when m*16-p == 1,
         * because there is cancellation between u1 and u2.
         * Handle this separately.
         */
        if (ABS(m*16-p) == 1) {
            u1 = log(x) * log2inv;
            u2 = 0.0;
        }
        else {
            /* determine z */
            z = ( (g - a1[p+1]) - a2[(p+1)/2] ) / ( g + a1[p+1] );
            z += z;


            /* determine u2 */
            v = z * z;
            rz = P(v) * v * z;
            rz += K * rz;
            u2 = (rz + z * K) + z;

            u1 = (m * 16 - p) * 0.0625;
        }

        /* determine w1, w2 */
        y1 = _reduce(y);
        y2 = y - y1;
        w = u2 * y + u1 * y2;
        w1 = _reduce(w);
        w2 = w - w1;
        w = w1 + u1 * y1;
        w1 = _reduce(w);
        w2 += w - w1;
        w = _reduce(w2);
        diw1 = 16 * (w1 + w); /* iw1 might overflow here, so use diw1 */
        w2 -= w;

        if (diw1 > OVFX) {
            return _except2(FP_O | FP_P,OP_POW,savedx,y,sign*D_INF,savedcw | ISW_OVERFLOW);
        }
        if (diw1 < UFLX) {
            return _except2(FP_U | FP_P,OP_POW,savedx,y,sign*0.0,savedcw | ISW_UNDERFLOW);
        }

        iw1 = (int) diw1;        /* now it is safe to cast to int */


        /* make sure w2 <= 0 */
        if (w2 > 0) {
            iw1 += 1;
            w2 -= 0.0625;
        }

        /* determine mprim, pprim */
        i = iw1 < 0 ? 0 : 1;
        mprim = iw1 / 16 + i;
        pprim = 16 * mprim - iw1;

        /* determine 2^w2 */
        bigz = Q(w2) * w2;

        /* determine  final result */
        bigz = a1[pprim + 1] + a1[pprim + 1] * bigz;
        newexp = _get_exp(bigz) + mprim;
    }


    if (newexp > MAXEXP) {
        result = sign * _set_exp(bigz, newexp - IEEE_ADJUST);
        return _except2(FP_O | FP_P, OP_POW, savedx, y, sign*D_INF, savedcw|ISW_OVERFLOW);
    }
    if (newexp < MINEXP) {
        result = sign * _set_exp(bigz, newexp + IEEE_ADJUST);
        return _except2(FP_U | FP_P, OP_POW, savedx, y, sign*0.0, savedcw|ISW_UNDERFLOW);
    }

    result = sign * _set_exp(bigz, newexp);
    RETURN_INEXACT2(OP_POW, savedx, y, result, savedcw|ISW_INEXACT);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\log.c ===
/***
*log.c - logarithmic functions
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   Compute log(x) and log10(x)
*
*Revision History:
*        8-15-91  GDP   written
*       12-20-91  GDP   support IEEE exceptions
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

#if defined(_M_IA64)
#pragma function(log, log10)
#endif

static double _log_hlp( double x, int flag);

/* constants */
static double const c0 =  0.70710678118654752440;       /* sqrt(0.5) */
static double const c1 =  0.69335937500000000000;
static double const c2 = -2.121944400546905827679e-4;
static double const c3 =  0.43429448190325182765;

/* coefficients for rational approximation */
static double const a0 = -0.64124943423745581147e2 ;
static double const a1 =  0.16383943563021534222e2 ;
static double const a2 = -0.78956112887491257267e0 ;
static double const b0 = -0.76949932108494879777e3 ;
static double const b1 =  0.31203222091924532844e3 ;
static double const b2 = -0.35667977739034646171e2 ;
/* b3=1.0  is not used -avoid multiplication by 1.0 */

#define A(w) (((w) * a2 + a1) * (w) + a0)
#define B(w) ((((w) + b2) * (w) + b1) * (w) + b0)

/***
*double log(double x) -  natural logarithm
*double log10(double x) - base-10 logarithm
*
*Purpose:
*   Compute the natural and base-10 logarithm of a number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   I P Z
*******************************************************************************/

double log10(double x)
{
    return(_log_hlp(x,OP_LOG10));
}

double log(double x)
{
    return(_log_hlp(x,OP_LOG));
}

static double _log_hlp(double x, int opcode)
{
    uintptr_t savedcw;
    int n;
    double f,result;
    double z,w,znum,zden;
    double rz,rzsq;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
            RETURN(savedcw, x);
        case T_QNAN:
            return _handle_qnan1(opcode, x, savedcw);
        case T_SNAN:
            return _except1(FP_I, opcode, x, _s2qnan(x), savedcw);
        }
        /* NINF will be handled in the x<0 case */
    }

    if (x <= 0.0) {
        double qnan;
        if (x == 0.0) {
            return _except1(FP_Z,opcode,x,-D_INF,savedcw);
        }
        qnan = (opcode == OP_LOG ? QNAN_LOG : QNAN_LOG10);
        return _except1(FP_I,opcode,x,qnan,savedcw);
    }

    if (x == 1.0) {
        // no precision ecxeption
        RETURN(savedcw, 0.0);
    }

    f = _decomp(x, &n);

    if (f > c0) {
        znum = (f - 0.5) - 0.5;
        zden = f * 0.5 + 0.5;
    }
    else {
        n--;
        znum = f - 0.5;
        zden = znum * 0.5 + 0.5;
    }
    z = znum / zden;
    w = z * z;

    rzsq = w * A(w)/B(w) ;
    rz = z + z*rzsq;

    result = (n * c2 + rz) + n * c1;
    if (opcode == OP_LOG10) {
        result *= c3;
    }

    RETURN_INEXACT1(opcode,x,result,savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\sqrt.c ===
/***
*sqrt.c - square root
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-15-91  GDP   written
*        1-29-91  GDP   Kahan's algorithm for final rounding
*        3-11-92  GDP   new interval and initial approximation
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#ifndef R4000

#include <math.h>
#include <trans.h>

#if defined(_M_IA64)
#pragma function(sqrt)
#endif

//
// Coefficients for initial approximation (Hart & al)
//

static double p00 =  .2592768763e+0;
static double p01 =  .1052021187e+1;
static double p02 = -.3163221431e+0;


/***
*double sqrt(double x) - square root
*
*Purpose:
*   Compute the square root of a number.
*   This function should be provided by the underlying
*   hardware (IEEE spec).
*Entry:
*
*Exit:
*
*Exceptions:
*  I P
*******************************************************************************/
double sqrt(double x)
{
    uintptr_t savedcw, sw;
    double result,t;
    uintptr_t stat,rc;

    savedcw = _ctrlfp(ICW, IMCW);

    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
            RETURN(savedcw, x);
        case T_QNAN:
            return _handle_qnan1(OP_SQRT, x, savedcw);
        case T_SNAN:
            return _except1(FP_I,OP_SQRT,x,QNAN_SQRT,savedcw);
        }
        /* -INF will be handled in the x<0 case */
    }
    if (x < 0.0) {
        return _except1(FP_I, OP_SQRT, x, QNAN_SQRT,savedcw);
    }

    if (x == 0.0) {
        RETURN (savedcw, x);
    }


    result = _fsqrt(x);

    _ctrlfp(IRC_DOWN, IMCW_RC);


    //
    // Kahan's algorithm
    //

    sw = _clrfp();
    t = x / result;
    stat = _statfp();
    if (! (stat & ISW_INEXACT)) {
        // exact
        if (t == result) {
            _set_statfp(sw);            // restore status word
            RETURN(savedcw, result);
        }
        else {
            // t = t-1
            if (*D_LO(t) == 0) {
                (*D_HI(t)) --;
            }
            (*D_LO(t)) --;
        }

    }

    rc = savedcw & IMCW_RC;
    if (rc == IRC_UP  || rc == IRC_NEAR) {
        // t = t+1
        (*D_LO(t)) ++;
        if (*D_LO(t) == 0) {
            (*D_HI(t)) ++;
        }
        if (rc == IRC_UP) {
            // y = y+1
            (*D_LO(t)) ++;
            if (*D_LO(t) == 0) {
                (*D_HI(t)) ++;
            }
        }
    }

    result = 0.5 * (t + result);

    _set_statfp(sw | ISW_INEXACT);      // update status word
    RETURN_INEXACT1(OP_SQRT, x, result, savedcw);
}



/***
* _fsqrt - non IEEE conforming square root
*
*Purpose:
*   compute a square root of a normal number without performing
*   IEEE rounding. The argument is a finite number (no NaN or INF)
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

double _fsqrt(double x)
{
    double f,y,result;
    int n;

    f = _decomp(x,&n);

    if (n & 0x1) {
        // n is odd
        n++;
        f = _add_exp(f, -1);
    }

    //
    // approximation for sqrt in the interval [.25, 1]
    // (Computer Approximationsn, Hart & al.)
    // gives more than 7 bits of accuracy
    //

    y =  p00 + f * (p01 + f *  p02);

    y += f / y;
    y = _add_exp(y, -1);

    y += f / y;
    y = _add_exp(y, -1);

    y += f / y;
    y = _add_exp(y, -1);

    n >>= 1;
    result = _add_exp(y,n);

    return result;
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\sincos.c ===
/***
*sincos.c - sine and cosine
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-15-91  GDP   written
*        9-29-91  GDP   added missing ABS() for cosine
*       12-26-91  GDP   IEEE exceptions support
*       03-11-91  GDP   use 66 significant bits for representing pi
*                       support FP_TLOSS, use _frnd for rounding
*       06-23-92  GDP   sin(denormal) now raises underflow exception
*       02-06-95  JWM   Mac merge
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

#if defined(_M_IA64)
#pragma function(sin, cos)
#endif

static double _sincos(double x, double y, double sin);

/* constants */
static double const EPS = 1.05367121277235079465e-8; /* 2^(-53/2) */
static double const PI     = 3.14159265358979323846;
static double const PI2    = 1.57079632679489661923; /* pi/2 */
static double const PI_INV = 0.31830988618379067154; /* 1/pi */
static double const YMAX   = 2.2e8; /* approx. pi * 2 ^(t/2), where t=53 */

//
// The sum of C1 and C2 is a representation of PI with 66 bits in the
// significand (same as x87). (PI = 4 * 0.c90fdaa2 2168c234 c h)
//

static _dbl _C1  = {SET_DBL (0x400921fb, 0x54400000)};
static _dbl _C2  = {SET_DBL (0x3de0b461, 0x1a600000)};
#define C1  (_C1.dbl)
#define C2  (_C2.dbl)

/* constants for the polynomial approximation of sin, cos */
static double const r1 = -0.16666666666666665052e+0;
static double const r2 =  0.83333333333331650314e-2;
static double const r3 = -0.19841269841201840457e-3;
static double const r4 =  0.27557319210152756119e-5;
static double const r5 = -0.25052106798274584544e-7;
static double const r6 =  0.16058936490371589114e-9;
static double const r7 = -0.76429178068910467734e-12;
static double const r8 =  0.27204790957888846175e-14;

#define R(g)  ((((((((r8 * (g) + r7) * (g) + r6) * (g) + r5) * (g) + r4) \
                         * (g) + r3) * (g) + r2) * (g) + r1) * (g))


/***
*double sin(double x) - sine
*
*Purpose:
*   Compute the sine of a number.
*   The algorithm (reduction / polynomial approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   I, P, U
*   if x is denormal: raise Underflow
*******************************************************************************/
double sin (double x)
{
    uintptr_t savedcw;
    double result;
    double sign,y;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch(_sptype(x)) {
        case T_PINF:
        case T_NINF:
            return _except1(FP_I,OP_SIN,x,QNAN_SIN1,savedcw);
        case T_QNAN:
            return _handle_qnan1(OP_SIN, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I,OP_SIN,x,_s2qnan(x),savedcw);
        }
    }

    if (x == 0.0) {
        // no P exception
        RETURN(savedcw,x);
    }

    if (x < 0) {
        sign = -1;
        y = -x;
    }
    else {
        sign = 1;
        y = x;
    }
    if (y >= YMAX) {

        // The argument is too large to produce a meaningful result,
        // so this is treated as an invalid operation.
        // We also set the (extra) FP_TLOSS flag for matherr
        // support

        return _except1(FP_TLOSS | FP_I,OP_SIN,x,QNAN_SIN2,savedcw);
    }

    result = _sincos(x,y,sign);

    if (IS_D_DENORM(result)) {
        return _except1(FP_U | FP_P,OP_SIN,x,_add_exp(result, IEEE_ADJUST),savedcw);
    }

    RETURN_INEXACT1(OP_SIN,x,result,savedcw);
}


/***
*double cos(double x) - cosine
*
*Purpose:
*   Compute the cosine of a number.
*   The algorithm (reduction / polynomial approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   P, I
*   if x is denormal: return 1
*******************************************************************************/

double cos (double x)
{
    uintptr_t savedcw;
    double result,y;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch(_sptype(x)) {
        case T_PINF:
        case T_NINF:
            return _except1(FP_I,OP_COS,x,QNAN_COS1,savedcw);
        case T_QNAN:
            return _handle_qnan1(OP_COS,x, savedcw);
        default: //T_SNAN
            return _except1(FP_I,OP_COS,x,_s2qnan(x),savedcw);
        }
    }

    /* this will handle small arguments */
    if (ABS(x) < EPS) {
        if (x == 0.0) {
            RETURN(savedcw,1.0);
        }
        result = 1.0;
    }

    else {
        y = ABS(x) + PI2;
        if (y >= YMAX) {

            // The argument is too large to produce a meaningful result,
            // so this is treated as an invalid operation.
            // We also set the (extra) FP_TLOSS flag for matherr
            // support

            return _except1(FP_TLOSS | FP_I,OP_COS,x,QNAN_COS2,savedcw);
        }

        result = _sincos(x,y,1.0);
    }

    RETURN_INEXACT1(OP_COS,x,result,savedcw);
}



/***
*double _sincos(double x, double y,double sign) - cos sin helper
*
*Purpose:
*   Help computing sin or cos of a valid, within correct range
*   number.
*   The algorithm (reduction / polynomial approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

static double _sincos(double x, double y, double sign)
{
    unsigned long n;
    double xn,f,g,r,result;

    xn = _frnd(y * PI_INV);
    n = (int) xn;

    if (n & 0x1) {
        /* n is odd */
        sign = -sign;
    }
    if (ABS(x) != y) {
        /* cosine wanted */
        xn -= .5;
    }

    /* assume there is a guard digit for addition */
    f = (ABS(x) - xn * C1) - xn * C2;
    if (ABS(f) < EPS)
        result = f;
    else {
        g = f*f;
        r = R(g);
        result = f + f*r;
    }
    result *= sign;

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\sincosh.c ===
/***
*sincosh.c - hyperbolic sine and cosine
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-15-91  GDP   written
*       12-20-91  GDP   support IEEE exceptions
*       02-03-92  GDP   use _exphlp for computing e^x
*       06-23-92  GDP   sinh(denormal) now raises underflow exception (NCEG)
*       07-16-93  SRW   ALPHA Merge
*       11-18-93  GJF   Merged in NT SDK version.
*       02-06-95  JWM   Mac merge
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

extern double _exphlp(double, int *);

static double const EPS  = 5.16987882845642297e-26;    /* 2^(-53) / 2 */
/* exp(YBAR) should be close to but less than XMAX
 * and 1/exp(YBAR) should not underflow
 */
static double const YBAR = 7.00e2;

/* WMAX=ln(OVFX)+0.69 (Cody & Waite),ommited LNV, used OVFX instead of BIGX */

static double const WMAX = 1.77514678223345998953e+003;

/* constants for the rational approximation */
static double const p0 = -0.35181283430177117881e+6;
static double const p1 = -0.11563521196851768270e+5;
static double const p2 = -0.16375798202630751372e+3;
static double const p3 = -0.78966127417357099479e+0;
static double const q0 = -0.21108770058106271242e+7;
static double const q1 =  0.36162723109421836460e+5;
static double const q2 = -0.27773523119650701667e+3;
/* q3 = 1 is not used (avoid myltiplication by 1) */

#define P(f)   (((p3 * (f) + p2) * (f) + p1) * (f) + p0)
#define Q(f)   ((((f) + q2) * (f) + q1) * (f) + q0)

#if !defined(_M_PPC) && !defined(_M_AMD64)
#pragma function(sinh, cosh)
#endif

/***
*double sinh(double x) - hyperbolic sine
*
*Purpose:
*   Compute the hyperbolic sine of a number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*       I P
*       no exception if x is denormal: return x
*******************************************************************************/

double sinh(double x)
{
    uintptr_t savedcw;
    double result;
    double y,f,z,r;
    int newexp;
    int sgn;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch(_sptype(x)) {
        case T_PINF:
        case T_NINF:
            RETURN(savedcw,x);
        case T_QNAN:
            return _handle_qnan1(OP_SINH, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I,OP_SINH,x,_s2qnan(x),savedcw);
        }
    }

    if (x == 0.0) {
        RETURN(savedcw,x); // no precision ecxeption
    }

    y = ABS(x);
    sgn = x<0 ? -1 : +1;

    if (y > 1.0) {
        if (y > YBAR) {
            if (y > WMAX) {
                // result too large, even after scaling
                return _except1(FP_O | FP_P,OP_SINH,x,x*D_INF,savedcw);
            }

            //
            // result = exp(y)/2
            //

            result = _exphlp(y, &newexp);
            newexp --;      //divide by 2
            if (newexp > MAXEXP) {
                result = _set_exp(result, newexp-IEEE_ADJUST);
                return _except1(FP_O|FP_P,OP_SINH,x,result,savedcw);
            }
            else {
                result = _set_exp(result, newexp);
            }

        }
        else {
            z = _exphlp(y, &newexp);
            z = _set_exp(z, newexp);
            result = (z - 1/z) / 2;
        }

        if (sgn < 0) {
            result = -result;
        }
    }
    else {
        if (y < EPS) {
            result = x;
            if (IS_D_DENORM(result)) {
                return _except1(FP_U | FP_P,OP_SINH,x,_add_exp(result, IEEE_ADJUST),savedcw);
            }
        }
        else {
            f = x * x;
            r = f * (P(f) / Q(f));
            result = x + x * r;
        }
    }

    RETURN_INEXACT1(OP_SINH,x,result,savedcw);
}



/***
*double cosh(double x) - hyperbolic cosine
*
*Purpose:
*   Compute the hyperbolic cosine of a number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   I P
*   no exception if x is denormal: return 1
*******************************************************************************/
double cosh(double x)
{
    uintptr_t savedcw;
    double y,z,result;
    int newexp;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch(_sptype(x)) {
        case T_PINF:
        case T_NINF:
            RETURN(savedcw,D_INF);
        case T_QNAN:
            return _handle_qnan1(OP_COSH, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I,OP_COSH,x,_s2qnan(x),savedcw);
        }
    }

    if (x == 0.0) {
        RETURN(savedcw,1.0);
    }

    y = ABS(x);
    if (y > YBAR) {
        if (y > WMAX) {
            return _except1(FP_O | FP_P,OP_COSH,x,D_INF,savedcw);
        }

        //
        // result =     exp(y)/2
        //

        result = _exphlp(y, &newexp);
        newexp --;          //divide by 2
        if (newexp > MAXEXP) {
            result = _set_exp(result, newexp-IEEE_ADJUST);
            return _except1(FP_O|FP_P,OP_COSH,x,result,savedcw);
        }
        else {
            result = _set_exp(result, newexp);
        }
    }
    else {
        z = _exphlp(y, &newexp);
        z = _set_exp(z, newexp);
        result = (z + 1/z) / 2;
    }

    RETURN_INEXACT1(OP_COSH,x,result,savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\amd64\huge.asm ===
page	,132
	title   HUGE    - HUGE value
;*** 
;huge.asm - defines HUGE
;
;	Copyright (c) 1984-2000, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	defines HUGE
;
;Revision History:
;
;   07/04/84	Greg Whitten
;		initial version
;
;   12/21/84	Greg Whitten
;		add assumes so that C can find variable
;
;   09/23/87	Barry C. McCord
;		add _matherr_flag for the sake of the
;		C floating-point intrinsic functions
;
;   08/29/88	Bill Johinston
;		386 version
;
;   08/27/91	JeffRob
;		ANSI naming
;
;   09/06/91	GeorgioP
;		define HUGE as positive infinity
;
;   09/06/91	GeorgioP
;		define _HUGE_dll
;
;   04/05/93	SteveSa
;		undefine _HUGE_dll
;   10/14/93	GregF
;		Restored _HUGE_DLL for _NTSDK
;
;*******************************************************************************

	.data

ifdef	_NTSDK
ifdef	CRTDLL
public	_HUGE_dll
_HUGE_dll dq	7ff0000000000000R
else
public	_HUGE
_HUGE	dq	7ff0000000000000R
endif
else
public	_HUGE
_HUGE	dq	7ff0000000000000R
endif

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\amd64\ieee.c ===
/***
*ieee.c - ieee control and status routines
*
*   Copyright (c) 1985-2000, Microsoft Corporation
*
*Purpose:
*   IEEE control and status routines.
*
*Revision History:
*
*   04-01-02  GDP   Rewritten to use abstract control and status words
*
*/

#include <trans.h>
#include <float.h>
#include <signal.h>

extern unsigned int _get_fpsr(void);
extern void _set_fpsr(unsigned int);
extern void _fclrf(void);

static unsigned int _abstract_sw(unsigned int sw);
static unsigned int _abstract_cw(unsigned int cw);
static unsigned int _hw_cw(unsigned int abstr);

#define FS         (1<<6)

/***
* _statusfp() -
*
*Purpose:
*	return abstract fp status word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _statusfp()
{
    unsigned int status;

    status = _get_fpsr();

    return _abstract_sw(status);
}


/***
*_clearfp() -
*
*Purpose:
*	return abstract	status word and clear status
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _clearfp()
{
    unsigned int status;

    status = _get_fpsr();
    _fclrf();

    return _abstract_sw(status);
}



/***	_control87
*() -
*
*Purpose:
*	return and set abstract user fp control word
*	can modify EM_DENORMAL mask
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _control87(unsigned int newctrl, unsigned int mask)
{
    unsigned int oldCw;
    unsigned int newCw;
    unsigned int oldabs;
    unsigned int newabs;

    oldCw = _get_fpsr();

    oldabs = _abstract_cw(oldCw);

    newabs = (newctrl & mask) | (oldabs & ~mask);

    newCw = _hw_cw(newabs);

    _set_fpsr(newCw);

    return newabs;
}					/* _control87() */


/***	_controlfp
*() -
*
*Purpose:
*	return and set abstract user fp control word
*	cannot change denormal mask (ignores _EM_DENORMAL)
*	This is done for portable IEEE behavior on all platforms
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _controlfp(unsigned int newctrl, unsigned int mask)
{
    return _control87(newctrl, mask & ~_EM_DENORMAL);
}


/***
* _abstract_cw() - abstract control word
*
*Purpose:
*   produce a fp control word in abstracted (machine independent) form
*
*Entry:
*   cw:     machine control word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _abstract_cw(unsigned int cw)
{
    unsigned int abstr = 0;


    //
    // Set exception mask bits
    //

    if (cw & IEM_INVALID)
	abstr |= _EM_INVALID;
    if (cw & IEM_ZERODIVIDE)
	abstr |= _EM_ZERODIVIDE;
    if (cw & IEM_OVERFLOW)
	abstr |= _EM_OVERFLOW;
    if (cw & IEM_UNDERFLOW)
	abstr |= _EM_UNDERFLOW;
    if (cw & IEM_INEXACT)
	abstr |= _EM_INEXACT;
    if (cw & IEM_DENORMAL)
	abstr |= _EM_DENORMAL;

    //
    // Set rounding mode
    //

    switch (cw & IMCW_RC) {
    case IRC_NEAR:
	abstr |= _RC_NEAR;
	break;
    case IRC_UP:
	abstr |= _RC_UP;
	break;
    case IRC_DOWN:
	abstr |= _RC_DOWN;
	break;
    case IRC_CHOP:
	abstr |= _RC_CHOP;
	break;
    }
    return abstr;
}


/***
* _hw_cw() -  h/w control word
*
*Purpose:
*   produce a machine dependent fp control word
*
*
*Entry:
*   abstr:	abstract control word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _hw_cw(unsigned int abstr)
{
    //
    // Set standard infinity and denormal control bits
    //

    unsigned int cw = 0;

    //
    // Set exception mask bits
    //

    if (abstr & _EM_INVALID)
	cw |= IEM_INVALID;
    if (abstr & _EM_ZERODIVIDE)
	cw |= IEM_ZERODIVIDE;
    if (abstr & _EM_OVERFLOW)
	cw |= IEM_OVERFLOW;
    if (abstr & _EM_UNDERFLOW)
	cw |= IEM_UNDERFLOW;
    if (abstr & _EM_INEXACT)
	cw |= IEM_INEXACT;
    if (abstr & _EM_DENORMAL)
	cw |= IEM_DENORMAL;

    //
    // Set rounding mode
    //

    switch (abstr & _MCW_RC) {
    case _RC_NEAR:
	cw |= IRC_NEAR;
	break;
    case _RC_UP:
	cw |= IRC_UP;
	break;
    case _RC_DOWN:
	cw |= IRC_DOWN;
	break;
    case _RC_CHOP:
	cw |= IRC_CHOP;
	break;
    }
    return cw;
}



/***
* _abstract_sw() - abstract fp status word
*
*Purpose:
*   produce an abstract (machine independent) fp status word
*
*
*Entry:
*   sw:     machine status word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _abstract_sw(unsigned int sw)
{
    unsigned int abstr = 0;


    if (sw & ISW_INVALID)
	abstr |= _SW_INVALID;
    if (sw & ISW_ZERODIVIDE)
	abstr |= _SW_ZERODIVIDE;
    if (sw & ISW_OVERFLOW)
	abstr |= _SW_OVERFLOW;
    if (sw & ISW_UNDERFLOW)
	abstr |= _SW_UNDERFLOW;
    if (sw & ISW_INEXACT)
	abstr |= _SW_INEXACT;
    if (sw & ISW_DENORMAL)
	abstr |= _SW_DENORMAL;

    return abstr;
}

/***
* _fpreset() - reset fp system
*
*Purpose:
*	reset fp environment to the default state
*	Also reset saved fp environment if invoked from a user's
*	signal handler
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
void _fpreset()
{
    unsigned int status = ICW;  
//    PEXCEPTION_POINTERS excptrs = (PEXCEPTION_POINTERS) _pxcptinfoptrs;

    //
    // reset fp state
    //

    _set_fpsr(status);

//    if (excptrs &&
//        excptrs->ContextRecord->ContextFlags & CONTEXT_FLOATING_POINT) {
        // _fpreset has been invoked by a signal handler which in turn
        // has been invoked by the CRT filter routine. In this case
        // the saved fp context should be cleared, so that the change take
        // effect on continuation.

//        excptrs->ContextRecord->StFPSR = ICW;
//    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\amd64\fpctrl.c ===
/***
*fpctrl.c - fp low level control and status routines
*
*   Copyright (c) 1985-2000, Microsoft Corporation
*
*Purpose:
*   IEEE control and status routines for internal use.
*   These routines use machine specific constants while _controlfp,
*   _statusfp, and _clearfp use an abstracted control/status word
*
*Revision History:
*
*   03-31-92  GDP   written
*   05-12-92  GJF   Rewrote fdivr as fdivrp st(1),st to work around C8-32
*		    assertions.
*
*/

#include <trans.h>

extern unsigned int _get_fpsr(void);
extern void _set_fpsr(unsigned int);
extern void _fclrf(void);

/***	_statfp
*() -
*
*Purpose:
*	return user status word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

uintptr_t _statfp()
{
    unsigned int status;

    status = _get_fpsr();
    status &= 0x3f;

    return (uintptr_t)status;
}

/***	_clrfp
*() -
*
*Purpose:
*	return user status word and clear status
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

uintptr_t _clrfp()
{
    unsigned int status;

    status = _get_fpsr();
    status &= 0x3f;
    _fclrf();

    return (uintptr_t)status;
}


/***	_ctrlfp
*() -
*
*Purpose:
*	return and set user control word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

uintptr_t _ctrlfp(uintptr_t newctrl, uintptr_t _mask)
{
    unsigned int oldCw;
    unsigned int newCw;
    unsigned int tmp;

    oldCw = _get_fpsr();
    tmp = oldCw;
    oldCw >>=7;
    oldCw = (oldCw & 0x3f) | ((oldCw & 0xc0) << 4) | 0x300;
    newCw = ((unsigned int)(newctrl & _mask) | (oldCw & (unsigned int)~_mask));
    newCw |= (oldCw & ~(unsigned int)0x0001f3f);
    newCw = ((((newCw & 0x3f) <<7) | ((newCw & 0xc00) << 3)) & 0x7f80) | (tmp & (~0x7f80));
    _set_fpsr(newCw);

    return (uintptr_t)oldCw;
}



/***	_set_statfp
*() -
*
*Purpose:
*	force selected exception flags to 1
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void _set_statfp(uintptr_t sw)
{
    unsigned int status;

    status = _get_fpsr();

    status |= (sw&0x3f);

    _set_fpsr(status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\util.c ===
/***
*util.c - utilities for fp transcendentals
*
*	Copyright (c) 1991-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*   _set_exp and _add_exp are as those defined in Cody & Waite
*
*Revision History:
*   08-15-91	GDP	written
*   10-20-91	GDP	removed _rint, unsafe_intrnd
*   02-05-92	GDP	added _fpclass
*   03-27-92	GDP	added _d_min
*   06-23-92	GDP	added _d_mzero
*
*******************************************************************************/
#include "trans.h"

/* define special values */

_dbl _d_inf = {SET_DBL (0x7ff00000, 0x0) };	  //positive infinity
_dbl _d_ind = {SET_DBL (D_IND_HI, D_IND_LO)};	  //real indefinite
_dbl _d_max = {SET_DBL (0x7fefffff, 0xffffffff)}; //max double
_dbl _d_min = {SET_DBL (0x00100000, 0x00000000)}; //min normalized double
_dbl _d_mzero = {SET_DBL (0x80000000, 0x00000000)}; //negative zero



double _set_exp(double x, int exp)
/* does not check validity of exp */
{
    double retval;
    int biased_exp;
    retval = x;
    biased_exp = exp + D_BIASM1;
    *D_EXP(retval) = (unsigned short) (*D_EXP(x) & 0x800f | (biased_exp << 4));
    return retval;
}


int _get_exp(double x)
{
    signed short exp;
    exp = (signed short)((*D_EXP(x) & 0x7ff0) >> 4);
    exp -= D_BIASM1; //unbias
    return (int) exp;
}


double _add_exp(double x, int exp)
{
    return _set_exp(x, INTEXP(x)+exp);
}


double _set_bexp(double x, int bexp)
/* does not check validity of bexp */
{
    double retval;
    retval = x;
    *D_EXP(retval) = (unsigned short) (*D_EXP(x) & 0x800f | (bexp << 4));
    return retval;
}


int _sptype(double x)
{
    if (IS_D_INF(x))
	return T_PINF;
    if (IS_D_MINF(x))
	return T_NINF;
    if (IS_D_QNAN(x))
	return T_QNAN;
    if (IS_D_SNAN(x))
	return T_SNAN;
    return 0;
}



/***
*double _decomp(double x, double *expptr)
*
*Purpose:
*   decompose a number to a normalized mantisa and exponent
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

double _decomp(double x, int *pexp)
{
    int exp;
    double man;

    if (x == 0) {
	man = 0;
	exp = 0;
    }
    else if (IS_D_DENORM(x)) {
	int neg;

	exp = 1-D_BIASM1;
	neg = x < 0.0;
	while((*D_EXP(x) & 0x0010) == 0) {
	    /* shift mantissa to the left until bit 52 is 1 */
	    (*D_HI(x)) <<= 1;
	    if (*D_LO(x) & 0x80000000)
		(*D_HI(x)) |= 0x1;
	    (*D_LO(x)) <<= 1;
	    exp--;
	}
	(*D_EXP(x)) &= 0xffef; /* clear bit 52 */
	if (neg) {
	    (*D_EXP(x)) |= 0x8000; /* set sign bit */
	}
	man = _set_exp(x,0);
    }
    else {
	man = _set_exp(x,0);
	exp = INTEXP(x);
    }

    *pexp = exp;
    return man;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\tan.c ===
/***
*tan.c - tangent
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-15-91  GDP   written
*       12-30-91  GDP   support IEEE exceptions
*       03-11-91  GDP   use 66 significant bits for representing pi
*                       support FP_TLOSS
*       06-23-92  GDP   tan(denormal) now raises underflow exception
*       02-06-95  JWM   Mac merge
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

#if defined(_M_IA64)
#pragma function(tan)
#endif

/* constants */
static double const TWO_OVER_PI = 0.63661977236758134308;
static double const EPS  = 1.05367121277235079465e-8; /* 2^(-53/2) */
static double const YMAX = 2.98156826864790199324e8; /* 2^(53/2)*PI/2 */

//
// The sum of C1 and C2 is a representation of PI/2 with 66 bits in the
// significand (same as x87). (PI/2 = 2 * 0.c90fdaa2 2168c234 c h)
//

static _dbl _C1  = {SET_DBL (0x3ff921fb, 0x54400000)};
static _dbl _C2  = {SET_DBL (0x3dd0b461, 0x1a600000)};
#define C1  (_C1.dbl)
#define C2  (_C2.dbl)

/* constants for the rational approximation */
/* p0 = 1.0  is not used (avoid mult by 1) */
static double const p1 = -0.13338350006421960681e+0;
static double const p2 =  0.34248878235890589960e-2;
static double const p3 = -0.17861707342254426711e-4;
static double const q0 =  0.10000000000000000000e+1;
static double const q1 = -0.46671683339755294240e+0;
static double const q2 =  0.25663832289440112864e-1;
static double const q3 = -0.31181531907010027307e-3;
static double const q4 =  0.49819433993786512270e-6;


#define Q(g)   ((((q4 * (g) + q3) * (g) + q2) * (g) + q1) * (g) + q0)
#define P(g,f)  (((p3 * (g) + p2) * (g) + p1) * (g) * (f) + (f))

#define ISODD(i) ((i)&0x1)


/***
*double tan(double x) - tangent
*
*Purpose:
*   Compute the tangent of a number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   P, I, U
*   if x is denormal: raise underflow
*******************************************************************************/
double tan(double x)
{
    uintptr_t savedcw;
    unsigned long n;
    double xn,xnum,xden;
    double f,g,result;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch(_sptype(x)) {
        case T_PINF:
        case T_NINF:
            return _except1(FP_I,OP_TAN,x,QNAN_TAN1,savedcw);
        case T_QNAN:
            return _handle_qnan1(OP_TAN, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I,OP_TAN,x,_s2qnan(x),savedcw);
        }
    }

    if (x == 0.0)
        RETURN(savedcw, x);

    if (ABS(x) > YMAX) {

        // The argument is too large to produce a meaningful result,
        // so this is treated as an invalid operation.
        // We also set the (extra) FP_TLOSS flag for matherr
        // support

        return _except1(FP_TLOSS | FP_I,OP_TAN,x,QNAN_TAN2,savedcw);
    }

    xn = _frnd(x * TWO_OVER_PI);
    n = (unsigned long) fabs(xn);


    /* assume there is a guard digit for addition */
    f = (x - xn * C1) - xn * C2;
    if (ABS(f) < EPS) {
        xnum = f;
        xden = 1;
        if (IS_D_DENORM(f)) {
            return _except1(FP_U | FP_P,OP_TAN,x,_add_exp(f, IEEE_ADJUST),savedcw);
        }
    }
    else {
        g = f*f;
        xnum = P(g,f);
        xden = Q(g);
    }

    if (ISODD(n)) {
        xnum = -xnum;
        result = xden/xnum;
    }
    else
        result = xnum/xden;

    RETURN_INEXACT1(OP_TAN,x,result,savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\87cdisp.asm ===
page	,132
	title	87cdisp  - C transcendental function dispatcher
;*** 
;87cdisp.asm - C transcendental function dispatcher (80x87/emulator version)
;
;   Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   Common dispatch code and error handling for C transcendental functions
;
;Revision History:
;   07-04-84  GFW   initial version
;   12-21-84  GFW   correctly point to name in matherr struct
;   05-12-85  GFW   return HUGE correctly signed on ERANGE errors
;		    fill 2nd operand for matherr structure correctly
;   07-05-85  GFW   check for possible overflow on PLOSS errors
;		    in this case OVERFLOW overrides PLOSS
;   07-08-85  GFW   added FWAIT in useHUGE
;   11-20-85  GFW   faster RANGE checking
;   09-30-86  JMB   internationalized error message handling
;   03-09-87  BCM   changed writestr to _wrt2err (extern)
;   04-14-87  BCM   log(0.0) and log10(0.0) sets errno to ERANGE
;		    for MS C 5.0 (ANSI compatible); errno is still
;		    set to EDOM for IBM C 2.0 (System V compatible).
;   04-28-87  BCM   Added _cintrindisp1 and _cintrindisp2
;		    for C "intrinsic" versions of pow, log, log10, exp,
;		    cos, sin, tan, acos, asin, atan, atan2,
;		    cosh, sinh, tanh, sqrt, ... for MS C 5.0
;   08-04-87  BCM   Removed "externP write" declaration.
;   08-17-87  BCM   Changed _wrt2err from near to model-dependent
;		    except for IMBC20; this is because of QC core lib
;   10-12-87  BCM   OS/2 support C library changes
;   11-24-87  BCM   added _loadds under ifdef DLL
;   01-18-88  BCM   eliminated IBMC20; ifos2,noos2 ==> ifmt, nomt
;   02-10-88  WAJ   MTHREAD libraries now lock stderr  when printing errors
;   04-25-88  WAJ   _cpower is on the stack for MTHREAD so must be set to 1
;   07-11-88  WAJ   address of matherr structure was incorrect in MTHREAD case
;   08-24-88  WAJ   386 version.
;   11-20-89  WAJ   386 MTHREAD is no longer _pascal.
;   08-17-90  WAJ   Now uses _stdcall.
;   10-15-90  WAJ   Fixed intrinsic/2 argument problems.
;   05-17-91  WAJ   Added _STDCALL ifdefs.
;   08-27-91  JCR   ANSI naming
;   09-15-91  GDP   Added _cwrt2err. _NMSG_WRITE is no longer _pascal
;   11-15-91  GDP   Removed error message display stuff
;		    moved exception structure to stack frame, even for
;			single thread code (allow recursive calls of
;			transcendentals through matherr)
;		    call _87except after fsave
;		    put Localfac on the stack for multi thread
;   02-10-92  GDP   changed error handling avoid polluting the fp status word
;   03-15-92  GDP   extensive changes in error detection scheme
;   10-27-92  SKS   Re-arranged some code to make this work with MASM 6.10
;   11-06-92  GDP   merged changes from the fp tree on \\vangogh: removed
;		    saveflag, added __fastflag, new range error checking
;   09-06-94  CFW   Replace MTHREAD with _MT.
;   04-06-01  PML   CHECKOVER should check overflow, not underflow (vs7#132450)
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include os2supp.inc
	include elem87.inc
.list


EDOM =		33		; math error numbers
ERANGE =	34

EDOMAIN =	120		; internal error number for DOMAIN
ESING = 	121		; internal error number for SING
ETLOSS =	122		; internal error number for TLOSS



	.data

comm	_matherr_flag:dword
extrn	__fastflag:dword

	.const

staticQ DblMax,	      07fefffffffffffffR
staticQ DblMin,       00010000000000000R
staticQ IeeeAdjO,     0c098000000000000R
staticQ IeeeAdjU,     04098000000000000R
staticQ _infinity,    07ff0000000000000R
staticQ _zero,	      00000000000000000R

ifndef	_MT

	.data?

staticQ LocalFac,     ?
intrinflag  db	    ?

else	;_MT


MTStackFrame	struc
    MTS_LocalFac   dq	?
    MTS_cdispflags db	?
MTStackFrame	ends

MTSFISize equ	((size MTStackFrame) + ISIZE - 1) and (not (ISIZE-1))


LocalFac    equ     <MTSF.MTS_LocalFac>
cdispflags  equ     <MTSF.MTS_cdispflags>

INTRINFLAG = 01h
TWOARGFLAG = 02h

endif	;_MT

;	error value action table

;labelW	retvaltab
;    DNCPTR  codeOFFSET useretval
page


	CODESEG

extrn	_trandisp1:near
extrn	_trandisp2:near
extrn	_87except:proc




;----------------------------------------------------------
;
;	intrinsic versions: TRANSCENDENTAL DISPATCH ROUTINES
;
;----------------------------------------------------------
;
;	_cintrindisp1 - Intrinsic Dispatch for 1 arg DP transcendental
;	_cintrindisp2 - Intrinsic Dispatch for 2 arg DP transcendental
;
;	rdx - function dispatch table address
;
;----------------------------------------------------------


_cintrindisp2	proc  uses RBXONLY
	local	DLSF[DSFISize]:IWORD
ifmt	<local	MTSF[MTSFISize]:IWORD>


	fstcw	[DSF.savCntrl]
	fwait

	; store the args in case they are needed by matherr.
	; Generally avoid storing since this may generate
	; various exceptions (overflow, underflow, inexact, invalid)
	; Args will not be available to an exception handler and
	; users should not use /Oi if interested in IEEE conformance

	cmp	[_matherr_flag], 0
	JSE	save2arg

lab resume2

;ifmt	<mov	 [_cpower], 1>	; set _cpower to C semantics
				; DISABLED this feature since pow(0,0)
				; will return 1 in C (NCEG spec) which
				; is the same as in FORTRAN  --GDP


	call	_trandisp2

ifmt	<or	 [cdispflags], (INTRINFLAG OR TWOARGFLAG)>
nomt	<mov	 [intrinflag], 1>

	call	cintrinexit
	ret


lab save2arg
	fxch 
	fst	[DSF.arg1]
	fxch
	fst	[DSF.arg2]
	jmp	resume2

_cintrindisp2	endp


_cintrindisp1	proc  uses RBXONLY
	local	DLSF[DSFISize]:IWORD
ifmt	<local	MTSF[MTSFISize]:IWORD>


	fstcw	[DSF.savCntrl]
	cmp	[_matherr_flag], 0
	JSE	save1arg

lab resume1

	call	_trandisp1

ifmt	<or	 [cdispflags],INTRINFLAG>
ifmt	<and	 [cdispflags],(NOT TWOARGFLAG)>
nomt	<mov	 [intrinflag], 1>

	call	cintrinexit
	ret


lab save1arg
	fst	[DSF.arg1]
	jmp	resume1


_cintrindisp1	endp




;*******************************************************************************
;*
;*	TRANSCENDENTAL DISPATCH ROUTINES
;*
;*******************************************************************************
;*
;*	_ctrandisp1 - Dispatch for 1 arg DP transcendental
;*	_ctrandisp2 - Dispatch for 2 arg DP transcendental
;*
;*	edx - function dispatch table address
;*
;*******************************************************************************

;*
;*  Two arg standard dispatch.
;*

_ctrandisp2  proc  uses ebx, parm1:qword, parm2:qword

	local	DLSF[DSFISize]:IWORD
ifmt   <local  MTSF[MTSFISize]:IWORD>


	push	dword ptr [parm1+4]	 ; load arg1
	push	dword ptr [parm1]
	call	_fload
ifndef _STDCALL
	add	esp, 8
endif
	push	dword ptr [parm2+4]	 ; load arg2
	push	dword ptr [parm2]
	call	_fload
ifndef _STDCALL
	add	esp, 8
endif

	fstcw	[DSF.savCntrl]

ifmt	<or	 [cdispflags], TWOARGFLAG>
ifmt	<mov	 [_cpower], 1>		    ; set _cpower to C semantics

	call	_trandisp2

	call	ctranexit

ifdef _STDCALL
	ret	16
else
	ret
endif

;*
;*  Check for overflow and errors.
;*



ctranexit::

ifmt	<and	 [cdispflags], (NOT INTRINFLAG)>
nomt	<mov	 [intrinflag], 0>

cintrinexit::
	cmp	__fastflag, 0
	JSNZ	restoreCW

	fst	qword ptr [LocalFac]	; cast result to double precision

	;
	; PROBLEM: Since the intrinsics may be given an argument anywhere
	; in the long double range, functions that are not normally
	; expected to overflow (like sqrt) may generate IEEE exceptions
	; at this point. We can cure this by making the checkrange test
	; standard.
	;


	mov	al, [DSF.ErrorType]	; check for errors
	or	al, al
	JE	checkinexact
	cmp	al, CHECKOVER
	JE	checkoverflow
	cmp	al, CHECKRANGE
	JSE	checkrng
	or	al, al
	JSE	restoreCW
	CBI
	mov	[DSF.typ], rax		; set exception type
	jmp	haveerror


lab checkinexact

	; This will be the most common path because of
	; the nature of transcendentals. If inexact is
	; unmasked in user's cw and active, raise it

	mov	ax, [DSF.savCntrl]
	and	ax, 20h
	JSNZ	restoreCW		; inexact exception masked
	fstsw	ax
	and	ax, 20h
	JSZ	restoreCW
	mov	[DSF.typ], INEXACT
	jmp	haveerror


lab restoreCW
lab restoreCW2
	fldcw	[DSF.savCntrl]		; load old control word
	fwait

	retn



lab checkrng
	mov	ax, word ptr [LocalFac+6]	; get exponent part
	and	ax, 07ff0h
	or	ax, ax
	JSE	haveunderflow
	cmp	ax, 07ff0h
	JSE	haveoverflow
	jmp	checkinexact		; assume possibly inexact result


lab checkoverflow
	mov	ax, word ptr [LocalFac+6]	; get exponent part
	and	ax, 07ff0h
	cmp	ax, 07ff0h
	JSE	haveoverflow
	jmp	checkinexact		; assume possibly inexact result


lab haveunderflow
	mov	[DSF.typ], UNDERFLOW
	fld	IeeeAdjU
	fxch
	fscale
	fstp	st(1)
	fld	st(0)
	fabs
	fcomp	[DblMin]
	fstsw	ax
	sahf
	JSAE	haveerror
	fmul	[_zero]
	jmp	short haveerror

lab haveoverflow
	mov	[DSF.typ], OVERFLOW
	fld	IeeeAdjO
	fxch
	fscale
	fstp	st(1)
	fld	st(0)
	fabs
	fcomp	[DblMax]
	fstsw	ax
	sahf
	JSBE	haveerror
	fmul	[_infinity]

lab haveerror
;	fill error structure and call matherr

	push	rsi			; save si
	push	rdi

	mov	rbx, [DSF.Function]	; get function jmp table address
	inc	rbx

	mov	[DSF.nam], rbx		; save name address


ifmt	<test	 cdispflags, INTRINFLAG>
nomt	<cmp	 [intrinflag], 0>

	JSNE	aftercopy
;
; copy function args (for matherr structure) 
;
	cld
	lea	esi, [parm1]
	lea	edi, [DSF.arg1]
	movsd
	movsd
	cmp	[rbx-1].fnumarg, 1	; check for 2nd parameter
	JSE	aftercopy
	lea	esi, [parm2]
	lea	edi, [DSF.arg2]
	movsd
	movsd

lab aftercopy
lab useretval
	fstp	[DSF.retval]		; store return value


	;
	; If intrinsic calling convention, an 'fsave' is required
	; before matherr starts doing any fp operations.
	; (This needs to be documented.)

	lea	rax, [DSF.typ]
	lea	rbx, [DSF.savCntrl]
	push	rbx
	push	rax
	mov	rbx, [DSF.function]
	mov	al, [rbx].fnumber
	CBI
	push	rax
	call	_87except		; _fpexcept(&exception, &savedcw)
ifndef _STDCALL
	add	esp, 12			; clear arguments if _cdecl.
endif

lab movretval
	pop	rdi			; restore di
	pop	rsi			; restore si
	fld	[DSF.retval]		; this assumes that the user
					; does not want to return a
					; signaling NaN

	jmp	restoreCW		;  restore CW and return

_ctrandisp2  endp




;*
;*  One arg standard dispatch.
;*

_ctrandisp1 proc  uses ebx, parm1:qword

	local	DLSF[DSFISize]:IWORD
ifmt   <local	MTSF[MTSFISize]:IWORD>

	push	dword ptr [parm1+4]	 ; load arg1
	push	dword ptr [parm1]
	call	_fload
ifndef _STDCALL
	add	esp, 8
endif

	fstcw	[DSF.savCntrl]

ifmt	<and	 [cdispflags],(NOT TWOARGFLAG)>

	call	_trandisp1

	call	ctranexit

ifdef _STDCALL
	ret	8
else
	ret
endif


_ctrandisp1  endp



;
; Load arg in the fp stack without raising an exception if the argument
; is a signaling NaN
;


_fload	proc	uses ebx, parm:qword
	local	tmp:tbyte

	mov	ax, word ptr [parm+6]  ; get exponent field
	mov	bx, ax		       ; save it
	and	ax, 07ff0h
	cmp	ax, 07ff0h	       ; check for special exponent
	JSNE	fpload
				       ; have special argument (NaN or INF)
	or	bx, 07fffh	       ; preserve sign, set max long double exp
	mov	word ptr [tmp+8], bx
				       ; convert to long double
	mov	eax, dword ptr [parm+4]
	mov	ebx, dword ptr [parm]
	shld	eax, ebx, 11
				       ; the MSB of the significand is
				       ; already 1 because of the exponent value
	mov	dword ptr [tmp+4], eax
	mov	dword ptr [tmp], ebx
	fld	tmp
	jmp	short return

lab fpload
	fld	parm
lab return
ifdef _STDCALL
	ret	8
else
	ret
endif

_fload endp





end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\tanh.c ===
/***
*tanh.c - hyperbolic tangent
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-15-91  GDP   written
*       12-22-91  GDP   support IEEE exceptions
*       06-23-92  GDP   tanh(denormal) now raises underflow exception (NCEG)
*       02-06-95  JWM   Mac merge
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

/* constants */
static double const EPS  = 5.16987882845642297e-26;     /* 2^(-53) / 2 */
static double const XBIG = 1.90615474653984960096e+001; /* ln(2)(53+2)/2 */
static double const C0   = 0.54930614433405484570;      /* ln(3)/2 */

/* constants for rational approximation */
static double const p0 = -0.16134119023996228053e+4;
static double const p1 = -0.99225929672236083313e+2;
static double const p2 = -0.96437492777225469787e+0;
static double const q0 =  0.48402357071988688686e+4;
static double const q1 =  0.22337720718962312926e+4;
static double const q2 =  0.11274474380534949335e+3;
static double const q3 =  0.10000000000000000000e+1;


#define Q(g)    ((((g) + q2) * (g) + q1) * (g) + q0)
#define R(g)    ((((p2 * (g) + p1) * (g) + p0) * (g)) / Q(g))

#if !defined(_M_PPC) && !defined(_M_AMD64)
#pragma function(tanh)
#endif

/***
*double tanh(double x) - hyperbolic tangent
*
*Purpose:
*   Compute the hyperbolic tangent of a number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   I P
*******************************************************************************/
double tanh(double x)
{
    uintptr_t savedcw;
    double f,g;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch(_sptype(x)) {
        case T_PINF:
            RETURN(savedcw,1.0);
        case T_NINF:
            RETURN(savedcw,-1.0);
        case T_QNAN:
            return _handle_qnan1(OP_TANH, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I,OP_TANH,x,_s2qnan(x),savedcw);
        }
    }

    if (x == 0.0) {
        // no precision exception
        RETURN(savedcw,x);
    }

    f = ABS(x);
    if (f > XBIG) {
        result = 1;
    }
    else if (f > C0) {
        result = 0.5 - 1.0 / (exp(f+f) + 1.0);
        result = result + result;
    }
    else if (f < EPS) {
        result = f;
        if (IS_D_DENORM(result)) {
            return _except1(FP_U | FP_P,OP_TANH,x,_add_exp(x, IEEE_ADJUST),savedcw);
        }
    }
    else {
        g = f * f;
        result = f + f * R(g);
    }

    if (x < 0)
        result = -result;

    RETURN_INEXACT1(OP_TANH,x,result,savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\amd64\fpsr.asm ===
; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.8982 

	TITLE	fpctrl.c

PUBLIC	_get_fpsr
_TEXT	SEGMENT
_status$ = 0
_get_fpsr PROC NEAR					; COMDAT

    sub     rsp, 8
	stmxcsr	DWORD PTR _status$[rsp]
	mov	    eax, DWORD PTR _status$[rsp]
    add     rsp, 8
	ret	0

_get_fpsr ENDP
_TEXT	ENDS


PUBLIC	_set_fpsr
_TEXT	SEGMENT
_status$ = 8
_set_fpsr	PROC NEAR					; COMDAT

    mov     DWORD PTR _status$[rsp], ecx
    ldmxcsr DWORD PTR _status$[rsp]
	ret	0

_set_fpsr	ENDP
_TEXT	ENDS

PUBLIC  _fclrf
_TEXT   SEGMENT
_fclrf PROC    NEAR
	stmxcsr	DWORD PTR _status$[rsp]
    mov     ecx, 0ffffffc0h
    and     DWORD PTR _status$[rsp], ecx
    ldmxcsr DWORD PTR _status$[rsp]
_fclrf ENDP
_TEXT   ENDS


PUBLIC	_frnd
_TEXT	SEGMENT
_frnd PROC NEAR
    CVTPD2DQ    xmm(1), xmm(0)
    CVTDQ2PD    xmm(0), xmm(1)
	ret	0
_frnd ENDP
_TEXT	ENDS
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\87ctran.asm ===
page	,132
	title	87ctran - C interfaces - exp, log, log10, pow
;***
;87ctran.asm - exp, log, log10, pow functions (8087/emulator version)
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   C interfaces for exp, log, log10, pow functions (8087/emulator version)
;
;Revision History:
;   07-04-84  GFW   initial version
;   05-08-87  BCM   added C intrinsic interface (_CI...)
;   10-12-87  BCM   changes for OS/2 Support Library
;   11-24-87  BCM   added _loadds under ifdef DLL
;   01-18-88  BCM   eliminated IBMC20; ifos2,noos2 ==> ifmt,nomt
;   08-26-88  WAJ   386 version
;   11-20-89  WAJ   Don't need pascal for MTHREAD 386.
;   01-26-01  PML   Pentium4 merge.
;
;*******************************************************************************

.xlist
	include cruntime.inc
.list

_FUNC_     equ	<exp>
_FUNC_DEF_ equ	<_exp_default>
_FUNC_P4_  equ	<_exp_pentium4>
_FUNC_P4_EXTERN_ equ 1
	include	disp_pentium4.inc

_FUNC_     equ	<_CIexp>
_FUNC_DEF_ equ	<_CIexp_default>
_FUNC_P4_  equ	<_CIexp_pentium4>
	include	disp_pentium4.inc

	.data

extrn _OP_EXPjmptab:word


page

	CODESEG

extrn	_ctrandisp1:near

	public	_exp_default
_exp_default proc

	mov	edx, OFFSET _OP_EXPjmptab
	jmp	_ctrandisp1

_exp_default endp


extrn	_cintrindisp1:near

	public	_CIexp_default
_CIexp_default proc

	mov	edx, OFFSET _OP_EXPjmptab
	jmp	_cintrindisp1

_CIexp_default endp



	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\87csqrt.asm ===
page	,132
	title	87csqrt - C interfaces - sqrt
;***
;87csqrt.asm - sqrt functions (8087/emulator version)
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   C interfaces for the sqrt function (8087/emulator version)
;
;Revision History:
;   07-04-84  GFW   initial version
;   05-08-87  BCM   added C intrinsic interface (_CIsqrt)
;   10-12-87  BCM   changes for OS/2 Support Library
;   11-24-87  BCM   added _loadds under ifdef DLL
;   01-18-88  BCM   eliminated IBMC20; ifos2,noos2 ==> ifmt,nomt
;   08-26-88  WAJ   386 version.
;   11-20-89  WAJ   Don't need pascal for 386 MTHREAD.
;
;*******************************************************************************

.xlist
	include cruntime.inc
.list


	.data
extrn	_OP_SQRTjmptab:word

page

	CODESEG

extrn	_ctrandisp1:near


	public	oldsqr
oldsqr	proc

	mov	edx, OFFSET _OP_SQRTjmptab
	jmp	_ctrandisp1

oldsqr	endp


extrn	_cintrindisp1:near


	public	_old_CIsqrt
_old_CIsqrt	proc

	mov	edx, OFFSET _OP_SQRTjmptab
	jmp	_cintrindisp1

_old_CIsqrt	endp


	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\87ctrigh.asm ===
page	,132
	title	87ctrigh - C interfaces - sinh, cosh, tanh
;***
;87ctrigh.asm - hyperbolic trig functions (8087/emulator version)
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   C interfaces for sinh, cosh, tanh functions (8087/emulator version)
;
;Revision History:
;   07-04-84  GFW   initial version
;   05-08-87  BCM   added C intrinsic interface (_CI...)
;   10-12-87  BCM   changes for OS/2 Support Library
;   11-24-87  BCM   added _loadds under ifdef DLL
;   01-18-88  BCM   eliminated IBMC20; ifos2,noos2 ==> ifmt,nomt
;   08-26-88  WAJ   386 version
;   11-20-89  WAJ   Don't need pascal for MTHREAD 386.
;
;*******************************************************************************

.xlist
	include cruntime.inc
.list

	.data

extrn _OP_SINHjmptab:word
extrn _OP_COSHjmptab:word
extrn _OP_TANHjmptab:word

page

	CODESEG

extrn _ctrandisp1:near
extrn _ctrandisp2:near


	public	sinh
sinh	proc

	mov	rdx, OFFSET _OP_SINHjmptab
disp1::
	jmp	_ctrandisp1

sinh	endp


	public	cosh
cosh	proc

	mov	rdx, OFFSET _OP_COSHjmptab
	jmp	disp1

cosh	endp


	public	tanh
tanh	proc

	mov	rdx, OFFSET _OP_TANHjmptab
	jmp	disp1

tanh	endp


extrn _cintrindisp1:near
extrn _cintrindisp2:near


	public	_CIsinh
_CIsinh	proc

	mov	rdx, OFFSET _OP_SINHjmptab
idisp1::
	jmp	_cintrindisp1

_CIsinh	endp


	public	_CIcosh
_CIcosh	proc

	mov	rdx, OFFSET _OP_COSHjmptab
	jmp	idisp1

_CIcosh	endp


	public	_CItanh
_CItanh	proc

	mov	rdx, OFFSET _OP_TANHjmptab
	jmp	idisp1

_CItanh	endp


	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\87ctriga.asm ===
page	,132
	title	87ctriga - C interfaces - asin, acos, atan, atan2
;***
;87ctriga.asm - inverse trig functions (8087/emulator version)
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   C interfaces for asin, acos, atan, atan2 (8087/emulator version)
;
;Revision History:
;   07-04-84  GFW   initial version
;   05-08-87  BCM   added C intrinsic interface (_CI...)
;   10-12-87  BCM   changes for OS/2 Support Library
;   11-24-87  BCM   added _loadds under ifdef DLL
;   01-18-88  BCM   eliminated IBMC20; ifos2,noos2 ==> ifmt,nomt
;   08-26-88  WAJ   386 version
;   11-20-89  WAJ   Don't need pascal for MTHREAD 386.
;
;*******************************************************************************

.xlist
	include cruntime.inc
.list

	.data

extrn _OP_ATAN2jmptab:word

page

	CODESEG

extrn _ctrandisp2:near

	public	atan2
atan2	proc

	mov	edx, OFFSET _OP_ATAN2jmptab
	jmp	_ctrandisp2

atan2	endp


extrn _cintrindisp2:near

	public	_CIatan2
_CIatan2	proc

	mov	edx, OFFSET _OP_ATAN2jmptab
	jmp	_cintrindisp2

_CIatan2	endp


	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\87ctrig.asm ===
page	,132
	title	87ctrig - C interfaces - sin, cos, tan
;***
;87ctrig.asm - trig functions (8087/emulator version)
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   C interfaces for the sin, cos, and tan functions (8087/emulator version)
;
;Revision History:
;   07-04-84  GFW   initial version
;   05-08-87  BCM   added C intrinsic interface (_CI...)
;   10-12-87  BCM   changes for OS/2 Support Library
;   11-24-87  BCM   added _loadds under ifdef DLL
;   01-18-88  BCM   eliminated IBMC20; ifos2,noos2 ==> ifmt,nomt
;   08-26-88  WAJ   386 version
;   11-20-89  WAJ   Don't need pascal for MTHREAD 386.
;
;*******************************************************************************

.xlist
	include cruntime.inc
.list

	.data
extrn _OP_SINjmptab:word
extrn _OP_COSjmptab:word
extrn _OP_TANjmptab:word

page

	CODESEG

extrn	_ctrandisp1:near
extrn	_ctrandisp2:near


	public	oldsin
oldsin	proc

	mov	edx, OFFSET _OP_SINjmptab
trigdisp::
	jmp	_ctrandisp1

oldsin	endp


	public	oldcos
oldcos	proc

	mov	edx, OFFSET _OP_COSjmptab
	jmp	trigdisp

oldcos	endp


	public	oldtan
oldtan	proc

	mov	edx, OFFSET _OP_TANjmptab
	jmp	trigdisp

oldtan	endp


extrn	_cintrindisp1:near
extrn	_cintrindisp2:near


	public	_old_CIsin
_old_CIsin	proc

	mov	edx, OFFSET _OP_SINjmptab
itrigdisp::
	jmp	_cintrindisp1

_old_CIsin	endp


	public	_old_CIcos
_old_CIcos	proc

	mov	edx, OFFSET _OP_COSjmptab
	jmp	itrigdisp

_old_CIcos	endp


	public	_old_CItan
_old_CItan	proc

	mov	edx, OFFSET _OP_TANjmptab
	jmp	itrigdisp

_old_CItan	endp


	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\87fmod.asm ===
page	,132
	title	87fmod	 - fmod function
;***
;87fmod.asm - fmod function (8087/emulator version)
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   Implements fmod() library function for computing floating-point
;   remainder.	Uses FPREM 8087 instruction or its emulated equivalent.
;
;Revision History:
;	12-09-84  GFW	Added copyright message
;	05-12-85  GFW	Changed fmod(x,0) = 0 for System V.2 compatibility
;	10-15-86  GFW	In-line instructions rather than call _fpmath
;	05-08-87  BCM	Added intrinsic version (_CIfmod)
;	10-12-87  BCM	OS/2 support C library changes
;			Including pascal naming and calling conv. & no _fac
;	01-18-88  BCM	Eliminated IBMC20 switches; ifos2,noos2 ==> ifmt,nomt
;			OS2_SUPPORT ==> MTHREAD
;	08-26-88  WAJ	386 version.
;	08-17-90  WAJ	Now uses _stdcall.
;	05-17-91  WAJ	Added _STDCALL ifdefs.
;	03-04-92  GDP	Changed behavior for INF args
;	03-22-92  GDP	Fixed bug: removed fxch out of the remloop
;	09-22-93  SKS	Removed obsolete _FIamod (no longer needed by FORTRAN)
;	12-09-94  JWM	Modified fFMOD to test for bogus Pentiums and call an FPREM workaround
;	12-13-94  SKS	Correct spelling of _adjust_fdiv
;	10-15-95  BWT	Don't do _adjust_fdiv test for NT.
;
;*******************************************************************************


.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
.list

    .data

ifndef NT_BUILD
extrn	_adjust_fdiv:dword
endif

jmptab	OP_FMOD,4,<'fmod',0,0>,<0,0,0,0,0,0>,2
    DNCPTR	codeoffset fFMOD	; 0000 NOS Valid non-0, TOS Valid non-0
    DNCPTR	codeoffset _rtindfpop	; 0001 NOS Valid non-0, TOS 0
    DNCPTR	codeoffset _tosnan2	; 0010 NOS Valid non-0, TOS NAN
    DNCPTR	codeoffset _rtindfpop	; 0011 NOS Valid non-0, TOS Inf
    DNCPTR	codeoffset _rtzeropop	; 0100 NOS 0, TOS Valid non-0
    DNCPTR	codeoffset _rtindfpop	; 0101 NOS 0, TOS 0
    DNCPTR	codeoffset _tosnan2	; 0110 NOS 0, TOS NAN
    DNCPTR	codeoffset _rtindfpop	; 0111 NOS 0, TOS Inf
    DNCPTR	codeoffset _nosnan2	; 1000 NOS NAN, TOS Valid non-0
    DNCPTR	codeoffset _nosnan2	; 1001 NOS NAN, TOS 0
    DNCPTR	codeoffset _nan2	; 1010 NOS NAN, TOS NAN
    DNCPTR	codeoffset _nosnan2	; 1011 NOS NAN, TOS Inf
    DNCPTR	codeoffset _rtindfpop	; 1100 NOS Inf, TOS Valid non-0
    DNCPTR	codeoffset _rtindfpop	; 1101 NOS Inf, TOS 0
    DNCPTR	codeoffset _tosnan2	; 1110 NOS Inf, TOS NAN
    DNCPTR	codeoffset _rtindfpop	; 1111 NOS Inf, TOS Inf


page

	CODESEG

extrn	_ctrandisp2:near
extrn	_cintrindisp2:near


extrn	_rtindfpop:near
extrn	_rtnospop:near
extrn	_rtzeropop:near
extrn	_tosnan2:near
extrn	_nosnan2:near
extrn	_nan2:near

ifndef NT_BUILD
extrn	_adj_fprem:near
endif

.386

;***
;fFMOD - floating-point remainder (8087/emulator intrinsic version)
;Purpose:
;	fmod(x,y) computes floating-point remainder of x/y, i.e. the
;	floating-point number f such that x = iy + f where f and x have
;	the same sign, and |f| < |y|, and i is an integer.
;
;	Uses the FPREM instruction to compute the remainder.
;	(Formerly used FDIV.)
;
;Entry:
;	floating-point numerator in ST(1)
;	floating-point denominator in ST(0)
;
;Exit:
;	floating-point result in ST(0);
;	(pops one of the arguments, replaces the other with the result)	
;
;Uses:
;	AX, Flags.
;
;Exceptions:
;	fmod(x, 0.0) currently returns 0.0 -- see System V specification
;*******************************************************************************


	public	fmod
fmod	proc

	mov	edx, OFFSET _OP_FMODjmptab
	jmp     _ctrandisp2

fmod	endp


	public	_CIfmod
_CIfmod	proc

	mov	edx, OFFSET _OP_FMODjmptab
	jmp	_cintrindisp2

_CIfmod	endp


lab fFMOD
	fxch

lab remloop

ifdef NT_BUILD				; NT handles the P5 bug in the OS
	fprem				; do fprem's until reduction is done
else
	cmp		_adjust_fdiv, 1
	jz		badP5_fprem
	fprem				; do fprem's until reduction is done
	jmp		fprem_done
lab badP5_fprem
	call	_adj_fprem
lab fprem_done
endif
	fstsw	ax
	fwait
	sahf				; load fprem flags into flags
	JSPE	remloop 		;   not done with range reduction

	fstp	st(1)			; get rid of divisor
	ret


end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\87disp.asm ===
page	,132
	title	87disp - common transcendental dispatch routine
;*** 
;87disp.asm - common transcendental dispatch routine (80x87/emulator version)
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   Common transcendental dispatch routine (80x87/emulator version)
;
;Revision History:
;   07-07-84  GFW initial version
;   11-20-85  GFW mask overflow/underflow/precision exceptions;
;		  fixed affine/projective infinity confusion
;   09-12-86  BCM added _Flanguage to distinguish languages
;   10-21-86  BCM use _cpower rather than _Flanguage to
;		  distinguish C and FORTRAN exponentiation semantics
;   06-11-87  GFW faster dispatch code - all in-line
;   10-26-87  BCM minor changes for new cmacros.inc
;   04-25-88  WAJ _cpower is now on stack for MTHREAD
;   08-24-88  WAJ 386 version
;   02-01-92  GDP ported to NT
;   09-06-94  CFW Replace MTHREAD with _MT.
;
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
.list

	.data

globalT _indefinite,  0FFFFC000000000000000R
globalT _piby2,       03FFFC90FDAA22168C235R
staticQ One,	      03FF0000000000000R


ifndef	_MT 	        ; by default assume C pow() semantics
globalB _cpower, 1	; if zero, assume FORTRAN (or other) exponentiation
endif	;_MT	        ;    semantics



labelB	XAMtoTagTab
			    ; C2 C1 C0 C3   Meaning	   Meaning  Tag   0
	db	2 * ISIZE   ;  0  0  0	0  +Unnormal  =>   NAN	     10   0
	db	1 * ISIZE   ;  0  0  0	1  +Zero      =>   Zero      01   0
	db	2 * ISIZE   ;  0  0  1	0  +NAN       =>   NAN	     10   0
	db	2 * ISIZE   ;  0  0  1	1   Empty     =>   NAN	     10   0
	db	2 * ISIZE   ;  0  1  0	0  -Unnormal  =>   NAN	     10   0
	db	1 * ISIZE   ;  0  1  0	1  -Zero      =>   Zero      01   0
	db	2 * ISIZE   ;  0  1  1	0  -NAN       =>   NAN	     10   0
	db	2 * ISIZE   ;  0  1  1	1   Empty     =>   NAN	     10   0
	db	0 * ISIZE   ;  1  0  0	0  +Normal    =>   Valid     00   0
	db	1 * ISIZE   ;  1  0  0	1  +Denormal  =>   Zero      01   0
	db	3 * ISIZE   ;  1  0  1	0  +Infinity  =>   Infinity  11   0
	db	2 * ISIZE   ;  1  0  1	1   Empty     =>   NAN	     10   0
	db	0 * ISIZE   ;  1  1  0	0  -Normal    =>   Valid     00   0
	db	1 * ISIZE   ;  1  1  0	1  -Denormal  =>   Zero      01   0
	db	3 * ISIZE   ;  1  1  1	0  -Infinity  =>   Infinity  11   0
	db	2 * ISIZE   ;  1  1  1	1   Empty     =>   NAN	     10   0


	CODESEG

xamTOS	macro
	cmp	[rdx].fnumber, OP_SQRT	; check for sqrt
	JSNE	cwdefault
	mov	bx, word ptr (DSF.savCntrl)
	or	bh, 2			; set precision control to 53 bits
	and	bh, 0feh
	mov	bl, 03fh		; mask exceptions
	jmp	setcw
lab cwdefault
	mov	bx, 133fh		; default cw
lab setcw
	mov	DSF.setCntrl, bx	; set new control word
	fldcw	DSF.setCntrl		; load new control word
	mov	rbx, dataoffset XAMtoTagTab	; Prepare for XLAT
	fxam
	mov	DSF.Function, rdx	; save function jmp table address
	fstsw	DSF.StatusWord
	mov	DSF.ErrorType, 0	; clear error code
	endm

comdisp macro
	CBI
	and	rcx, 0404h		; clear all but signs from CX
	mov	rbx, rdx
	add	rbx, rax
	add	rbx, size funtab	; skip over name, error vals, etc.
	jmp	[rbx]			; jmp to function
	endm

; Will dispatch  to  the  special  case routines for the single argument
; transcendental functions.  It assumes on  entry  that  the  8087 stack
; has the  argument  on  the  top  of its stack and that DX has been set
; to the address of the dispatch table (which should be in  Tag  order).
; This routine	will  FXAM  the top of the 8087 stack, generate Tag info
; from the condition code, and jump to the corresponding dispatch  table
; entry.  In the process of creating the offset for the XLAT instruction
; bit 2 of CL will be loaded with  the sign of the argument.  DI may not
; be used in any computations.

_trandisp1  proc    near

	xamTOS				; setup control word and check TOS

	fwait
	mov	cl, CondCode
	shl	cl, 1
	sar	cl, 1
	rol	cl, 1
	mov	al, cl
	and	al, 0fh
	xlat

	comdisp

_trandisp1  endp


; Will dispatch to the special case routines  for  the	double	argument
; transcendental functions.   It  assumes on entry that the 8087 has arg1
; next to the top and arg2 on top of the 8087  stack  and  that  DX  has
; been set  to	the  address  of  the dispatch table (which should be in
; Tag-arg1,Tag-arg2  order).   This  routine  will  FXAM  the  top   two
; registers of	the  8087  stack,generate  Tag info from the condition
; codes, and jump to the corresponding	dispatch  table entry.	 In  the
; process of  creating	the  offsets  for  the	XLAT statements bit 2 of
; CH and bit 2 of CL will be loaded with  the  signs  of  the  arguments
; next to the  top and on top, respectively, of  the 8087 stack.  DI may
; not be used in any computations.

_trandisp2  proc    near

	xamTOS				; setup control word and check TOS

	fxch
	mov	cl, CondCode
	fxam
	fstsw	DSF.StatusWord
	fxch
	mov	ch, CondCode
	shl	ch, 1
	sar	ch, 1
	rol	ch, 1
	mov	al, ch
	and	al, 0fh
	xlat
	mov	ah, al
	shl	cl, 1
	sar	cl, 1
	rol	cl, 1
	mov	al, cl
	and	al, 0fh
	xlat
	shl	ah, 1
	shl	ah, 1
	or	al, ah

	comdisp

_trandisp2  endp



page
;----------------------------------------------------------
;
;	SPECIAL CASE RETURN FUNCTIONS
;
;----------------------------------------------------------
;
;	INPUTS - The signs of the last, second to last
;		 arguments are in CH, CL respectively.
;
;	OUTPUT - The result is the stack top.
;
;----------------------------------------------------------

labelNP _rttospopde, PUBLIC
	call	setDOMAIN

labelNP _rttospop, PUBLIC
	fxch				; remove ST(1)

labelNP _rtnospop, PUBLIC
	fstp	st(0)			; remove ST(0)

labelNP _rttosnpop, PUBLIC
	ret				; return TOS

labelNP _rtnospopde, PUBLIC
	call	setDOMAIN
	jmp	_rtnospop


;----------------------------------------------------------

labelNP _rtzeropop, PUBLIC
	fstp	st(0)			; remove ST(0)

labelNP _rtzeronpop, PUBLIC
	fstp	st(0)			; remove ST(0)
	fldz				; push 0.0 onto stack
	ret

;----------------------------------------------------------

labelNP _rtonepop, PUBLIC
	fstp	st(0)			; remove ST(0)

labelNP _rtonenpop, PUBLIC
	fstp	st(0)			; remove ST(0)
	fld1				; push 1.0 onto stack
	ret

;----------------------------------------------------------

isQNAN macro
	fstp	DSF.Fac 		; use ten byte storage
	fld	DSF.Fac
	test	byte ptr [DSF.Fac+7], 40h ; Test for QNaN or SNaN
	endm


labelNP _tosnan1, PUBLIC		; ST(0) is a NaN
	isQNAN
	JSZ	_tossnan1
	mov	DSF.Errortype, DOMAIN_QNAN
	ret
lab _tossnan1
	mov	DSF.Errortype, DOMAIN
	fadd	[One]			; Convert SNaN to QNaN
	ret

labelNP _nosnan2, PUBLIC		; ST(1) is a NaN
	fxch
labelNP _tosnan2, PUBLIC		; ST(0) is a NaN
	isQNAN
	JSZ	_tossnan2
	mov	DSF.Errortype, DOMAIN_QNAN
	jmp	_tosnan2ret
lab _tossnan2
	mov	DSF.Errortype, DOMAIN
lab _tosnan2ret
	fadd				; Propagate NaN and pop
	ret

labelNP _nan2, PUBLIC
	isQNAN
	JSZ	_snan2
	fxch
	isQNAN
	JSZ	_snan2
	mov	DSF.Errortype, DOMAIN_QNAN
	jmp	_nan2ret
lab _snan2
	mov	DSF.Errortype, DOMAIN
lab _nan2ret
	fadd				; Propagate NaN and pop
	ret




;----------------------------------------------------------

labelNP _rtindfpop, PUBLIC
	fstp	st(0)			; remove ST(0)

labelNP _rtindfnpop, PUBLIC
	fstp	st(0)			; remove ST(0)
	fld	[_indefinite]		; push real indefinite onto stack
	cmp	DSF.ErrorType, 0	; if error set
	JSG	retj			;   must be SING, don't set DOMAIN

labelNP _rttosnpopde, PUBLIC
lab setDOMAIN
	mov	DSF.ErrorType, DOMAIN
lab retj
	or	cl, cl			; test sign in cl
	ret


;----------------------------------------------------------

labelNP _rtchsifneg, PUBLIC
	or	cl, cl			; if arg is negative
	JSZ	chsifnegret		;    negate top of stack
	fchs
lab chsifnegret
	ret

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\87except.c ===
/***
*87except.c - floating point exception handling
*
*	Copyright (c) 1991-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*
*Revision History:
*   8-24-91	GDP	written
*   9-26-91	GDP	changed DOMAIN error handling
*   1-29-91	GDP	renamed to 87exept.c
*   3-15-92	GDP	support raising exceptions
*
*******************************************************************************/
#include <errno.h>
#include <math.h>
#include <trans.h>


#define _DOMAIN_QNAN	7 /* should be in sync with elem87.inc */
#define _INEXACT	8 /* should be in sync with elem87.inc */

int _matherr_flag;
extern void _raise_exc(_FPIEEE_RECORD *prec,unsigned int *pcw,
    int flags, int opcode, double *parg1, double *presult);
extern void _set_errno(int matherrtype);
extern int _handle_exc(unsigned int flags, double * presult, unsigned int cw);




/***
*double _87except(struct _exception *except, unsigned int *cw)
*
*Purpose:
*   Handle floating point exceptions.
*
*Entry:
*
*Exit:
*
*Exceptions:
*******************************************************************************/

void _87except(int opcode, struct _exception *exc, unsigned short *pcw16)
{
    int fixed;
    unsigned int flags;
    unsigned int cw, *pcw;

    //
    // convert fp control word into an unsigned int
    //

    cw = *pcw16;
    pcw = &cw;

    switch (exc->type) {
    case _DOMAIN:
    case _TLOSS:
	flags = FP_I;
	break;
    case _OVERFLOW:
	flags = FP_O | FP_P;
	break;
    case _UNDERFLOW:
	flags = FP_U | FP_P;
	break;
    case _SING:
	flags = FP_Z;
	break;
    case _INEXACT:
	flags = FP_P;
	break;
    case _DOMAIN_QNAN:
	exc->type = _DOMAIN;
	// no break
    default:
	flags = 0;
    }



    if (flags && _handle_exc(flags, &exc->retval, *pcw) == 0) {

	//
	// trap should be taken
	//

	_FPIEEE_RECORD rec;

	//
	// fill in operand2 info. The rest of rec will be
	// filled in by _raise_exc
	//

	switch (opcode) {
	case OP_POW:
	case OP_FMOD:
	case OP_ATAN2:
	    rec.Operand2.OperandValid = 1;
	    rec.Operand2.Format = _FpFormatFp64;
	    rec.Operand2.Value.Fp64Value = exc->arg2;
	    break;
	default:
	    rec.Operand2.OperandValid = 0;
	}

	_raise_exc(&rec,
		   pcw,
		   flags,
		   opcode,
		   &exc->arg1,
		   &exc->retval);
    }


    /* restore cw  */
    _rstorfp(*pcw);

    fixed = 0;

    if (exc->type != _INEXACT &&
	! _matherr_flag) {
	fixed = _matherr(exc);
    }
    if (!fixed) {
	_set_errno(exc->type);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\87sqrt.asm ===
page	,132
	title	87sqrt	 - square root - SQRT
;*** 
;87sqrt.asm - common square root support (80x87/emulator version)
;
;	Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Common support for the sqrt function (80x87/emulator version)
;
;Revision History:
;	07-04-84  GFW initial version
;	10-26-87  BCM minor changes for new cmacros.inc
;	08-24-88  WAJ 386 version
;
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
.list


	CODESEG

extrn	_rtindfnpop:near
extrn	_rttosnpopde:near
extrn	_rtzeronpop:near
extrn	_tosnan1:near

;----------------------------------------------------------
;
;	SQUARE ROOT FUNCTIONS
;
;----------------------------------------------------------

lab fFSQRT
	or	cl,cl			; test sign
	JSNZ	sqrtindfnpop		;    return indefinite if negative
	fsqrt				; calculate the square root of TOS
	ret

lab _rtforsqrtinf
	or	cl,cl			; test sign
	JSNZ	sqrtindfnpop
	ret				; return infinity

lab _rtforsqrtzero			; zero or denormal
	ftst
	fstsw	ax
	fwait
	sahf
	JSNZ	fFSQRT			; denormal operand
	ret				; return +0 or -0 (IEEE std)

lab sqrtindfnpop
	jmp	_rtindfnpop		; return indefinite

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\87trig.asm ===
page	,132
	title	87trig	 - trigonometric functions - SIN, COS, TAN
;*** 
;87trig.asm - trigonometric functions - SIN, COS, TAN
;
;	Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Support for SIN, COS, TAN
;
;Revision History:
;
;    11-06-91	 GDP	rewritten for 386
;
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
.list


	.data

extrn	_piby2:tbyte

staticT _piby4,     03FFEC90FDAA22168C235R  ; pi/4
staticD _plossval,  04D000000R		    ; 2^27
staticD _tlossval,  04F000000R		    ; 2^31


	CODESEG

extrn	_rtindfnpop:near
extrn	_rtonenpop:near
extrn	_rttosnpop:near
extrn	_rtinfnpopse:near
extrn	_rttosnpop:near
extrn	_rttosnpopde:near
extrn	_tosnan1:near

;----------------------------------------------------------
;
;	FORWARD TRIGONOMETRIC FUNCTIONS
;
;----------------------------------------------------------
;
;	INPUTS - The argument is the stack top.
;		 The sign of argument is the 04h bit of CL.
;
;	OUTPUT - The result is the stack top.
;
;----------------------------------------------------------

jmponC2 macro	tag
	fstsw	ax
	fwait
	sahf
	JSP	tag
	endm



labelNP _fFCOS, PUBLIC
lab fFCOS
	fcos
	jmponC2	ArgTooLarge
	ret


labelNP _fFSIN, PUBLIC
lab fFSIN
	fsin
	jmponC2	ArgTooLarge
	ret


lab fFTAN
	fptan
	fstsw	ax
	fstp	st(0)		    ; pop TOS (fptan pushed an extra value)
	sahf
	JSP	ArgTooLarge
	ret


lab ArgTooLarge
	mov	DSF.ErrorType, TLOSS	; set TLOSS error
	jmp	_rtindfnpop



end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\87triga.asm ===
page	,132
        title   87triga   - inverse trigonometric functions - ASIN, ACOS, ATAN
;*** 
;87triga.asm - inverse trigonometric functions - ASIN, ACOS, ATAN
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   Routines for ASIN, ACOS, ATAN
;
;Revision History:
;
;   07/04/84	Greg Whitten
;		initial version
;
;   10/01/84	Brad Verheiden
;		Fixed bug in _rtforatnby0 which did not remove an
;		element from the floating stack
;
;   10/28/85	Jamie Bariteau
;		Added comment about inputs to fFATN2, made fFATN2
;		public
;		made _fFATN2 and _rtpiby2 public labels
;
;   10/30/87	Bill Johnston
;		Minor changes for new cmacros.
;
;   08/25/88	Bill Johnston
;		386 version.
;
;   02/10/92	Georgios Papagiannakopoulos
;		NT port -- Bug fix for atan(-INF)
;
;   03/27/92	GDP  support underflow
;
;   01/03/96	JWM  Modify return value of atan2(0,0)
;
;   05/10/00    GB   Modify return value for atan2(-0.0, 1.0)
;
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
.list



	.data

extrn	_indefinite:tbyte
extrn	_piby2:tbyte

jmptab	OP_ATAN2,5,<'atan2',0>,<0,0,0,0,0,0>,2
    DNCPTR	codeoffset fFATN2	; 0000 NOS Valid non-0, TOS Valid non-0
    DNCPTR	codeoffset _rtforatnby0 ; 0001 NOS Valid non-0, TOS 0
    DNCPTR	codeoffset _tosnan2	; 0010 NOS Valid non-0, TOS NAN
    DNCPTR	codeoffset _rtforatn20	; 0011 NOS Valid non-0, TOS Inf
    DNCPTR	codeoffset _rtforatn20	; 0100 NOS 0, TOS Valid non-0
    DNCPTR	codeoffset _rtforatn20  ; 0101 NOS 0, TOS 0
    DNCPTR	codeoffset _tosnan2	; 0110 NOS 0, TOS NAN
    DNCPTR	codeoffset _rtforatn20	; 0111 NOS 0, TOS Inf
    DNCPTR	codeoffset _nosnan2	; 1000 NOS NAN, TOS Valid non-0
    DNCPTR	codeoffset _nosnan2	; 1001 NOS NAN, TOS 0
    DNCPTR	codeoffset _nan2	; 1010 NOS NAN, TOS NAN
    DNCPTR	codeoffset _nosnan2	; 1011 NOS NAN, TOS Inf
    DNCPTR	codeoffset _rtforatnby0	; 1100 NOS Inf, TOS Valid non-0
    DNCPTR	codeoffset _rtforatnby0	; 1101 NOS Inf, TOS 0
    DNCPTR	codeoffset _tosnan2	; 1110 NOS Inf, TOS NAN
    DNCPTR	codeoffset _rtindfpop	; 1111 NOS Inf, TOS Inf

page


	CODESEG

extrn	_rtchsifneg:near
extrn	_rtindfpop:near
extrn	_rtindfnpop:near
extrn	_rtnospop:near
extrn	_rtonenpop:near
extrn	_rttospop:near
extrn	_rttosnpop:near
extrn	_rttosnpopde:near
extrn	_rtzeronpop:near
extrn	_tosnan1:near
extrn	_tosnan2:near
extrn	_nosnan2:near
extrn	_nan2:near

;----------------------------------------------------------
;
;       INVERSE TRIGONOMETRIC FUNCTIONS
;
;----------------------------------------------------------
;
;       INPUTS - For single argument functions the argument
;                is the stack top.  For fFATN2 the numerator
;                is next to stack top, the denominator is
;                the stack top.
;                For single argument functions the sign is
;                in bit 2 of CL.  For fFATN2 the numerator
;                sign is bit 2 of CH, the denominator
;                sign is bit 2 of CL.
;
;		 Note:
;		 _clog calls fFATN2 with the signs of the arguments
;		 in bit 0 of CL and CH respectively.  This should
;		 work since fFATN2 tests for sign of numerator and
;		 denominator by using "or CL,CL" and "or CH,CH"
;
;       OUTPUT - The result is the stack top
;
;----------------------------------------------------------

lab fFASN
	call	AugmentSinCos		; num.=arg, den.=sqrt(1-arg^2)
	xchg	ch, cl			; sign(num.)=sign(arg)
	jmp	short fFPATAN


lab fFACS
	call	AugmentSinCos		; num.=arg, den.=sqrt(1-arg^2)
	fxch				; num.=sqrt(1-arg^2), den.=arg
	jmp	short fFPATAN


lab fFATN
	fabs
	fld1				; denominator is 1
	mov	ch, cl
	xor	cl, cl			; sign of denominator is +ve
	jmp	short fFPATAN


labelNP _fFATN2, PUBLIC
lab fFATN2
	mov	DSF.ErrorType, CHECKRANGE ; indicate possible over/under flow on exit
	fabs
	fxch
	fabs
	fxch

lab fFPATAN
	fpatan				; compute partial arctangent
	or	cl, cl			; if denominator was +ve
	JSZ	PatanNumeratorTest	;    bypass -ve denominator adjust
	fldpi
	fsubrp	st(1), st(0)		; change Patan to pi - Patan

lab PatanNumeratorTest
	or	ch, ch			; if numerator was +ve
	JSZ	PatanDone		;    bypass -ve numerator adjust
	fchs				; change Patan to -Patan

lab PatanDone
	ret

page

lab AugmentSinCos
	fabs				; NOS=x = |input|
	fld	st(0)			; NOS=x, TOS=x
	fld	st(0)			; NNOS=x, NOS=x, TOS=x
	fld1				; NNNOS=x, NNOS=x, NOS=x, TOS=1
	fsubrp	st(1),st(0)		; NNOS=x, NOS=x, TOS=1-x
	fxch				; NNOS=x, NOS=1-x, TOS=x
	fld1				; NNNOS=x, NNOS=1-x, NOS=x, TOS=1
	fadd				; NNOS=x, NOS=1-x, TOS=1+x
	fmul				; NOS=x, TOS=1-x^2
	ftst
	fstsw	DSF.StatusWord
	fwait
	test	CondCode, 1		; if 1-x^2 < 0
	JSNZ	DescriminantNeg 	;    return a NAN
	xor	ch, ch			; sign of TOS is +ve
	fsqrt				; NOS=x, TOS=sqrt(1-x^2)
	ret

lab DescriminantNeg
	pop	rax			; remove return address from stack
	jmp	_rtindfpop		; replace top of stack with a NAN

page
;----------------------------------------------------------
;
;       SPECIAL CASE RETURN FUNCTIONS
;
;----------------------------------------------------------
;
;       INPUTS - The signs of the last, second to last
;                arguments are in CH, CL respectively.
;
;       OUTPUT - The result is the stack top.
;
;----------------------------------------------------------

labelNP _rtpiby2, PUBLIC
	fstp	st(0)			; remove ST(0)
	fld	[_piby2]		; push pi/2 onto stack
	ret


lab _rtforatn20
	fstp	st(0)			; remove ST(0)
	or	cl ,cl			; if denominator is +ve
	JSZ	zeronpop		;    return zero
	fstp	st(0)
	fldpi				; push pi onto stack
	or	ch, ch			; if numerator was +ve
	JSZ	postv
	fchs
lab postv
	ret

lab zeronpop
    fstp    st(0)
    fldz                ; push 0.0 onto stack
    or  ch, ch          ; if numerator was +ve
    JSZ postv
    fchs
    ret


lab _rtforatn200
lab indfpop
	fstp	st(0)			; remove ST(0)
lab indfnpop
	jmp	_rtindfnpop		; return real indefinite


lab _rtforatnby0
	fstp	st(0)			; remove an argument before returning
	mov	cl, ch			; cl is sign(TOS)
	jmp	short _rtsignpiby2


lab _rtforatninf
lab _rtsignpiby2
	call	_rtpiby2		; push pi/2 onto stack
	jmp	_rtchsifneg		; return with sign change if negative

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\87tran.asm ===
page	,132
	title	87tran	 - elementary functions - EXP, LOG, LN, X^Y
;***
;87tran.asm - elementary functions - EXP, LOG, LN, X^Y
;
;	Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Support for  EXP, LOG, LN, X^Y (80x87/emulator version)
;
;Revision History:
;
;   07/04/84	Greg Whitten
;		initial version
;
;   07/05/85	Greg Whitten
;		support x ^ y where x < 0 and y is an integer
;
;   07/08/85	Greg Whitten
;		corrected value of infinity (was a NaN)
;
;   07/26/85	Greg Whitten
;		make XENIX version truely System V compatible
;
;   10/31/85	Jamie Bariteau
;		made _fFEXP and _fFLN public labels
;
;   05/29/86	Jamie Bariteau
;		make pow return values conform to System V and
;		ANSI C standards
;
;   09/12/86	Barry McCord
;		added FORTRAN specific code to deal
;		with zero**nonpositive;
;		it requires run-time switching on language
;		for mixed-language support
;
;   10/09/86	Barry McCord
;		cotan(0.0) ==> SING error (jmp _rtinfnpopse),
;		return infinity
;
;   06/11/87	Greg Whitten
;		faster transcendental functions
;
;   06/24/87	Barry McCord
;		fixed FORTRAN 4.01 bug (bcp #1801) in which
;		an expression of the form
;		   (small positive less than one) ** (large positive)
;		was overflowing instead of underflowing to zero
;
;   10/30/87	Bill Johnston
;		made changes for os/2 support.
;
;   04/25/88	Bill Johnston
;		_cpower is now on stack for MTHREAD
;
;   05/01/88	Bill Johnston
;		si was being trashed in MTHREAD
;
;   06/03/88	Bill Johnston
;		fixed neg ^ int int MTHREAD case
;
;   08/24/88	Bill Johnston
;		386 version
;
;   11/15/91	Georgios Papagiannakopoulos
;		NT port. call _powhlp to handle special cases for pow()
;
;   04/01/91	Georgios Papagiannakopoulos
;		fixed special values: log(-INF), log(0), pow(0, neg)
;
;   10/27/92    Steve Salisbury
;		Move declaration of _powhlp out of .data declarations
;		This fix is required for use with MASM 6.10.
;
;   11/06/92	Georgios Papagiannakopoulos
;		changed special return values for NCEG conformance
;
;   09/06/94    Chris Weight
;               Change MTHREAD to _MT.
;
;   12/09/94	Jamie MacCalman
;		Modified fFEXP to test for bogus Pentiums and call an FDIV workaround
;
;   12/13/94	SKS	Correct spelling of _adjust_fdiv
;
;	10-15-95  BWT	Don't do _adjust_fdiv test for NT.
;
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
	include os2supp.inc
.list

	.data

globalT _infinity,	07FFF8000000000000000R
globalT _minfinity,	0FFFF8000000000000000R
globalT _logemax,	0400DB1716685B9D7A7DCR

staticT _log2max,	0400DFFFF000000000000R
staticT _smallarg,	03FFD95F619980C4336F7R
staticQ _half,		03fe0000000000000R

SBUFSIZE EQU	108

ifndef _MT
staticT _temp, 0
extrn	_cpower:byte
endif

ifndef NT_BUILD
extrn	_adjust_fdiv:dword
endif


jmptab	OP_EXP,3,<'exp',0,0,0>,<0,0,0,0,0,0>,1
    DNCPTR	codeoffset fFEXP       ; 0000 TOS Valid non-0
    DNCPTR	codeoffset _rtonenpop	; 0001 TOS 0
    DNCPTR	codeoffset _tosnan1	; 0010 TOS NAN
    DNCPTR	codeoffset _rtforexpinf ; 0011 TOS Inf

page

	CODESEG


extrn	_rtindfpop:near
extrn	_rtindfnpop:near
extrn	_rtnospop:near
extrn	_rtonepop:near
extrn	_rtonenpop:near
extrn	_rttospop:near
extrn	_rttosnpop:near
extrn	_rttosnpopde:near
extrn	_rtzeronpop:near
extrn	_tosnan1:near
extrn	_tosnan2:near
extrn	_nosnan2:near
extrn	_nan2:near
extrn	_powhlp:proc

ifndef NT_BUILD
extrn	_safe_fdivr:near
endif

;----------------------------------------------------------
;
;	LOG AND EXPONENTIAL FUNCTIONS
;
;----------------------------------------------------------
;
;	INPUTS - For single argument functions the argument
;		 is the stack top.  For fFYTOX the base
;		 is next to stack top, the exponent is
;		 the stack top.
;		 For single argument functions the sign is
;		 in bit 2 of CL.  For fFYTOX the base
;		 sign is bit 2 of CH, the exponent
;		 sign is bit 2 of CL.
;
;	OUTPUT - The result is the stack top
;
;----------------------------------------------------------

lab fFYTOX
	mov	DSF.ErrorType, CHECKRANGE ; indicate possible over/under flow on exit
	or	ch,ch		    ; base < 0
	JSNZ	negYTOX 	    ;	 check for integer power
	fxch			    ; TOS = base , NOS = exponent


lab fFXTOY
	fyl2x			    ; compute y*log2(x)
	jmp	short fF2X	    ; compute 2^(y*log2(x))



;-----------------------------------------------
;
;   Entry for exponential function (exp)
;
;-----------------------------------------------

labelNP _fFEXP, PUBLIC
lab fFEXP
	mov	DSF.ErrorType, CHECKRANGE ; indicate possible over/under flow on exit
	xor	ch,ch		    ; result is always positive
	fldl2e
	fmul			    ; convert log base e to log base 2

lab fF2X
	call	_ffexpm1	    ; get exponent and (2^fraction)-1
	fld1
	fadd
	test	CondCode,1	    ; if fraction > 0 (TOS > 0)
	JSZ	ExpNoInvert	    ;	 bypass 2^x invert
	fld1
ifdef NT_BUILD			    ; NT always handles the P5 bug in the OS
	fdivrp	st(1),st(0)
else
	cmp		_adjust_fdiv, 1
	jz		badP5_fdivr
	fdivrp	st(1),st(0)
	jmp		fdivr_done
lab badP5_fdivr
	call	_safe_fdivr
lab fdivr_done

endif

lab ExpNoInvert
	test	dl,040h 	    ; if integer part was zero
	JSNZ	ExpScaled	    ;	 bypass scaling to avoid bug
	fscale			    ; now TOS = 2^x

lab ExpScaled
	or	ch,ch		    ; check for negate flag
	JSZ	expret
	fchs			    ; negate result (negreal ^ odd integer)
lab expret
	jmp	_rttospop



lab negYTOX			    ; check for negreal ^ integer
	call	_isintTOS
	or	eax, eax
	JSE	negYTOXerror
	xor	ch,ch
	cmp	eax, 2
	JSE	evenexp
	not	ch		    ; ch <> 0 means negative result
lab evenexp
	fxch
	fabs			    ; x is positive
	jmp	fFXTOY		    ; continue with ch <> 0 for neg result


lab _rtfor0to0
	;cmp	[_cpower], 1	    ; DISABLED (conform to NCEG spec)
	;JSE	c_0to0		    ; C requires a DOMAIN error for System V compat.
	jmp	_rtonepop	    ; MS FORTRAN has 0.0**0.0 == 1.0


c_0to0::			; System V needs DOMAIN error with 0.0 return

lab negYTOXerror
lab Yl2XArgNegative
	jmp 	_rtindfpop	; DOMAIN error or SING error
				; top of stack now has a NAN
				; 	code in 87cdisp replaces this with
				;		proper System V return value
				;		(for C only)
				;	FORTRAN keeps indefinite value but
				;		currently aborts on DOMAIN
				;		and SING errors


; FORTRAN SING error (return infinity)
;	e.g. 0.0**negative
;	and  cotan(0.0)
;

labelNP _rtinfpopse, PUBLIC
	fstp	st(0)		

labelNP _rtinfnpopse, PUBLIC
	fstp	st(0)
	fld	tbyte ptr [_infinity]
	mov	DSF.ErrorType, SING
	ret

labelNP _fFLN, PUBLIC
lab fFLN
	fldln2
	fxch
	ftst
	fstsw	DSF.StatusWord
	fwait
	test	CondCode, 041H		; if arg is negative or zero
	JSNZ	Yl2XArgNegative 	;    return a NAN

	fyl2x				; compute y*log2(x)
	ret


;-------------------------------------------------------
;
; Logarithmic functions (log and log 10) entry points
;
;-------------------------------------------------------

lab _rtforln0				; (we don't distinguish +0, -0)
	mov	DSF. ErrorType, SING	; set SING error
	fstp	st(0)
	fld	tbyte ptr [_minfinity]
	ret

lab _rtforloginf
	or	cl, cl			; check sign
	JSNZ	tranindfnpop		; if negetive return indefinite
	ret				; else return +INF
					; no overflow in this case (IEEE)





lab fFLOGm
	fldlg2				; main LOG10 entry point
	jmp	short fFYL2Xm

lab fFLNm				; main LN entry point
	fldln2

lab fFYL2Xm
	fxch
	or	cl, cl			; if arg is negative
	JSNZ	Yl2XArgNegative 	;    return a NAN
	fyl2x				; compute y*log2(x)
	ret

page

lab _rtforyto0
	jmp	_rtonepop		; return 1.0


lab _rtfor0tox
	call	_isintTOS
	fstp	st(0)
	fstp	st(0)
	or	cl, cl			; if 0^(-valid)
	JSNZ	_rtfor0toneg		;    do more checking
	fldz
	cmp	eax, 1		; eax has the return value of _isintTOS
	JSNE	zerotoxdone
	or	ch, ch
	JSE	zerotoxdone
	fchs
lab zerotoxdone
	ret


lab _rtfor0toneg
	mov	DSF.ErrorType, SING
	fld	tbyte ptr [_infinity]
	cmp	eax, 1		; eax has the return value of _isintTOS
	JSNE	zerotoxdone
	or	ch, ch
	JSE	zerotoxdone
	fchs
	jmp	zerotoxdone


lab tranzeropop
	fstp	st(0)			; toss 1 stack entry

lab tranzeronpop
	jmp	_rtzeronpop


lab tranindfpop
	fstp	st(0)			; toss 1 stack entry

lab tranindfnpop
	jmp	_rtindfnpop


lab ExpArgOutOfRange
	pop	rax			; remove return address from stack
					; We need to check the sign of the
					; exponent to distinguish underflow
					; from overflow.  We cannot just check
					; CL directly since for the XtoY case,
					; the exponent is a product of Y*log2(x)
					; and not an original argument that
					; has already been thru FXAM.  So,
					; the following instructions were
					; substituted to fix FORTRAN 4.01
					; bcp #1801)

	ftst				; check if exponent was negative large
	fstsw	DSF.StatusWord
	fwait
	test	CondCode, 01h		; if valid^(-large)
	JSNZ	zeronpopue		; underflow error/return zero
	fstp	st(0)			; else return infinity/overflow
	fld	[_infinity]
	or	ch, ch
	JSZ	_expbigret
	fchs
lab _expbigret
	ret

lab zeronpopue
	mov	DSF.ErrorType, UNDERFLOW
	jmp	_rtzeronpop


labelNP _rtinfpop, PUBLIC
	fstp	st(0)			; remove ST(0)

labelNP _rtinfnpop, PUBLIC
	fstp	st(0)			; remove ST(0)
	fld	[_infinity]		; push infinity onto stack
lab setOVERFLOW
	mov	DSF.ErrorType, OVERFLOW ;  set OVERFLOW error
	ret


lab _rtforexpinf
	or	cl, cl
	JSNZ	tranzeronpop		; if exp(-infinity) return +zero
	fstp	st(0)
	fld	[_infinity]		; return infinity, no overflow
	ret

labelNP _ffexpm1, PUBLIC
	fld	st(0)			; copy TOS
	fabs				; make TOS +ve
	fld	[_log2max]		; get log2 of largest number
	fcompp
	fstsw	DSF.StatusWord
	fwait
	test	CondCode, 041H		; if abs(arg) >= 2^15-.5
	JSNZ	ExpArgOutOfRange	;    perform arg out of range routine
	fld	st(0)			; copy TOS
	frndint 			; near round to integer
	ftst
	fstsw	DSF.StatusWord
	fwait
	mov	dl, CondCode		; save sign of integer part
	fxch				; NOS gets integer part
	fsub	st,st(1)		; TOS gets fraction
	ftst
	fstsw	DSF.StatusWord		; store sign of fraction
	fabs
	f2xm1
	ret

;
; returns 0, 1, 2 if TOS is non-int, odd int or even int respectively
;

lab _isintTOS
	fld	st(0)
	frndint
	fcomp
	fstsw	ax
	sahf
	JSNE	notanint
	fld	st(0)		    ; it is an integer
	fmul	[_half]
	fld	st(0)
	frndint
	fcompp
	fstsw	ax
	sahf
	JSE	evenint
	mov	eax, 1
lab _isintTOSret
	ret
lab notanint
	mov	eax, 0
	jmp	_isintTOSret
lab evenint
	mov	eax, 2
	jmp	_isintTOSret






lab _usepowhlp

	push	rsi			; save rsi
	sub	rsp, SBUFSIZE+8 	; get storage for _retval and savebuf
	mov	rsi, rsp
	push	rsi			; push address for result

	sub	rsp, 8
	fstp	qword ptr [rsp]
	sub	rsp, 8
	fstp	qword ptr [rsp]

	fsave	[rsi+8]
	call	_powhlp
ifndef _STDCALL
	add	esp, 16+ISIZE		; clear arguments if _cdecl.
endif
	frstor	[rsi+8]
	fld	qword ptr [rsi] 	; load result on the NDP stack
	add	rsp, SBUFSIZE+8		; get rid of storage
	pop	rsi			; restore rsi

	test	rax, rax		; check return value for domain error
	JSZ	noerror
	jmp	_rttosnpopde

lab	noerror
	ret



end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\87trigh.asm ===
page	,132
	title   87trigh   - hyperbolic trigonometric functions - SINH, COSH, TANH
;*** 
;87trigh.asm - hyperbolic trigonometric functions - SINH, COSH, TANH
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   Routines for SINH, COSH, TANH
;
;Revision History:
;
;   07/04/84	Greg Whitten
;		initial version
;
;   10/31/85	Jamie Bariteau
;		made _fFSINH and _fFCOSH public labels
;
;   10/30/87	Bill Johnston
;		Minor changes for new cmacros.
;
;   08/25/88	Bill Johnston
;		386 version.
;
;   02/10/92	Georgios Papagiannakopoulos
;		NT port --used CHECKOVER for detection of overflow
;
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
.list

	.data

extrn	_logemax:tbyte
extrn	_infinity:tbyte
staticT _tanhmaxarg,	04003987E0C9996699000R

jmptab	OP_SINH,4,<'sinh',0,0>,<0,0,0,0,0,0>,1
    DNCPTR	codeoffset fFSINH	; 0000 TOS Valid non-0
    DNCPTR	codeoffset _rttosnpop	; 0001 TOS 0
    DNCPTR	codeoffset _tosnan1	; 0010 TOS NAN
    DNCPTR	codeoffset _rtforsnhinf ; 0011 TOS Inf

jmptab	OP_COSH,4,<'cosh',0,0>,<0,0,0,0,0,0>,1
    DNCPTR	codeoffset fFCOSH      ; 0000 TOS Valid non-0
    DNCPTR	codeoffset _rtonenpop	; 0001 TOS 0
    DNCPTR	codeoffset _tosnan1	; 0010 TOS NAN
    DNCPTR	codeoffset _rtforcshinf	; 0011 TOS Inf

jmptab	OP_TANH,4,<'tanh',0,0>,<0,0,0,0,0,0>,1
    DNCPTR	codeoffset fFTANH      ; 0000 TOS Valid non-0
    DNCPTR	codeoffset _rttosnpop	; 0001 TOS 0
    DNCPTR	codeoffset _tosnan1	; 0010 TOS NAN
    DNCPTR	codeoffset _rtfortnhinf ; 0011 TOS Inf

page

	CODESEG

extrn	_ffexpm1:near
extrn	_rtchsifneg:near
extrn	_rtindfnpop:near
extrn	_rtinfnpop:near
extrn	_rtonenpop:near
extrn	_rttospop:near
extrn	_rttosnpop:near
extrn	_rttosnpopde:near
extrn	_tosnan1:near

;----------------------------------------------------------
;
;       HYPERBOLIC FUNCTIONS
;
;----------------------------------------------------------
;
;       INPUTS - The argument is the stack top.
;                The sign of the argument is bit 2 of CL.
;
;       OUTPUT - The result is the stack top
;
;----------------------------------------------------------


labelNP _fFSINH, PUBLIC
lab fFSINH
	mov	DSF.ErrorType, CHECKOVER ; indicate possible overflow on exit
	call	fFEXPH			; compute e^x for hyperbolics
	or	bl, bl			; if e^x is infinite
	JSZ	_rtforsnhlarge		;    return as if x = affine infinity
	call	ExpHypCopyInv		; TOS = e^(-x), NOS = e^x
	fsubp	st(1), st(0)		; compute e^x - e^(-x) for hyperbolics
	jmp	short SinhCoshReturn


lab fFTANH
	fld	st(0)			; copy TOS
	fabs				; make TOS +ve
	fld	[_tanhmaxarg]		; get largest arg, roughly ln(2)(55)/2
	fcompp
	fstsw	DSF.StatusWord
	fwait
	test	CondCode, 041h		; if abs(arg) > XBIG (see tanh.h)
	JSNZ	_rtfortnhlarge		;    return as if x = affine infinity
	call	fFEXPH			; compute e^x for hyperbolics
	or	bl, bl			; if e^x is infinite
	JSZ	_rtfortnhlarge		;    return as if x = affine infinity
	fld	st(0)			; copy TOS
	call	ExpHypSum		; compute e^x + e^(-x) for hyperbolics
	fxch				; get copy of e^x
	call	ExpHypCopyInv		; TOS = e^(-x), NOS = e^x
	fsubp	st(1), st(0)		; compute e^x - e^(-x) for hyperbolics
	fdivrp	st(1), st(0)		; now TOS = tanh(x)
	ret


labelNP _fFCOSH, PUBLIC
lab fFCOSH
	mov	DSF.ErrorType, CHECKOVER ; indicate possible overflow on exit
	call	fFEXPH			; compute e^x for hyperbolics
	or	bl, bl			; if e^x is infinite
	JSZ	_rtforcnhlarge		;    return as if x = affine infinity
	call	ExpHypSum		; compute e^x + e^(-x) for hyperbolics

lab SinhCoshReturn
	fld1
	fchs
	fxch
	fscale				; divide result by 2
	jmp	_rttospop

page

lab _rtforsnhinf
	fstp	st(0)
	fld	[_infinity]
	jmp	_rtchsifneg		; change sign if argument -ve

lab _rtforcshinf
	fstp	st(0)
	fld	[_infinity]
	ret

lab infpositive
	ret

lab _rtforsnhlarge
	call	_rtinfnpop		; TOS = infinity

lab chsifneg
	jmp	_rtchsifneg		; change sign if argument -ve


lab _rtforcnhlarge
	jmp	_rtinfnpop		; TOS = infinity


lab _rtfortnhlarge
	mov	DSF.ErrorType, INEXACT
lab _rtfortnhinf
	call	_rtonenpop		; TOS = one
	jmp	chsifneg		; change sign if argument -ve

page

lab fFEXPH
	fldl2e
	fmul				; convert log base e to log base 2
	xor	rbx, rbx		; clear e^x, finite result flags
	call	_ffexpm1		; TOS = e^|x|-1 unscaled, NOS = scale
	not	bl			; set finite result flag
	test	CondCode, 1		; if fraction > 0 (TOS > 0)
	JSZ	ExpHypNoInvert		;    bypass e^x-1 invert
	call	ExpHypCopyInv		; TOS = e^(-x)-1, NOS = e^x-1
	fxch
	fstp	st(0)			; remove NOS

lab ExpHypNoInvert
	test	dl, 040h		; if integer part was zero
	JSNZ	ExpHypScaled		;    bypass scaling to avoid bug
	not	bh			; set e^x flag
	fld1
	fadd				; TOS = e^x unscaled
	fscale				; now TOS = e^x

lab ExpHypScaled
	jmp	_rttospop		; TOS = e^x-1 or e^x scaled

lab ExpHypSum
	call	ExpHypCopyInv		; TOS = e^(-x), NOS = e^x
	fadd				; TOS = e^x + e^(-x)
	or	bh, bh			; if e^x flag set
	JSNZ	ExpHypSumReturn 	;    bypass e^x-1 adjust
	fld1
	fadd	st(1),st
	fadd				; add 2 to result

lab ExpHypSumReturn
	ret

lab ExpHypCopyInv
	fld	st(0)			; TOS = e^x (or e^x-1)
	fld1				; TOS = 1, NOS = e^x (or e^x-1)
	or	bh, bh			; if e^x flag set
	JSNZ	ExpHypCopyInvReturn	;    bypass e^x-1 adjust
	fadd	st, st(1)		; TOS = e^x, NOS = e^x-1
	fchs				; TOS = -e^x, NOS = e^x-1
	fxch				; TOS = e^x-1, NOS = -e^x

lab ExpHypCopyInvReturn
	fdivrp	st(1), st(0)		; TOS = e^(-x) (or e^(-x)-1)
	ret

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\acos.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;
;*******************************************************************************

_ACOS_ equ 1
include triga.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\asin.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;
;*******************************************************************************

_ASIN_ equ 1
include triga.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\adj_fdiv.asm ===
title   adj_fdiv   - routines to compensate for incorrect Pentium FDIV
;*** 
;adj_fdiv - routines to compensate for incorrect Pentium FDIV
;
;   Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   Workarounds to correct for broken FDIV
;
;Revision History:
;
;   12/06/94	Jamie MacCalman
;		initial version, based on Intel fix
;   12/09/94	Jamie MacCalman
;		added _adj_fpremX & _safe_fdivX entry points
;   12/13/94	Jamie MacCalman
;		upgraded to V.3 of Intel's workarounds
;   12/19/94	Jamie MacCalman
;		upgraded to V.4 of Intel's workarounds
;   12/27/94	Jamie MacCalman
;		upgraded to V.5 (aka "V1.0") of Intel's workarounds
;    1/13/95	Jamie MacCalman
;		added underscores to fdivp_sti_st & fdivrp_sti_st for ANSI conformance
;
;  The following code is a PRELIMINARY IMPLEMENTATION of a
;  software patch for the floating point divide instructions.
;
;


	include cruntime.inc
	include mrt386.inc
	include elem87.inc

;
;  Stack variables for divide routines.
;

DENOM		EQU	0
NUMER		EQU	12
PREV_CW		EQU	28
PATCH_CW 	EQU	32

DENOM_SAVE	EQU	32

MAIN_DENOM	EQU	4
MAIN_NUMER	EQU	16

SPILL_SIZE	EQU	12
MEM_OPERAND	EQU	8
STACK_SIZE	EQU	44
SPILL_MEM_OPERAND	EQU	20

ONESMASK	EQU	0e000000h

SINGLE_NAN	EQU	07f800000h
DOUBLE_NAN	EQU	07ff00000h

ILLEGAL_OPC	EQU	6

;
; FPREM constants
;

FPREM_FLT_SIZE		EQU	12
FPREM_DENOM			EQU 0
FPREM_DENOM_SAVE	EQU	FPREM_DENOM + FPREM_FLT_SIZE
FPREM_NUMER			EQU FPREM_DENOM_SAVE + FPREM_FLT_SIZE
FPREM_PREV_CW		EQU FPREM_NUMER + FPREM_FLT_SIZE
FPREM_PATCH_CW		EQU FPREM_PREV_CW + 4
FPREM_SW			EQU	FPREM_PATCH_CW + 4
FPREM_STACK_SIZE	EQU FPREM_SW + 4
FPREM_RET_SIZE		EQU	4
FPREM_PUSH_SIZE		EQU	4

FPREM_MAIN_FUDGE	EQU	FPREM_RET_SIZE + FPREM_PUSH_SIZE + FPREM_PUSH_SIZE + FPREM_PUSH_SIZE

FPREM_MAIN_DENOM		EQU FPREM_DENOM + FPREM_MAIN_FUDGE
FPREM_MAIN_DENOM_SAVE	EQU	FPREM_DENOM_SAVE + FPREM_MAIN_FUDGE
FPREM_MAIN_NUMER		EQU FPREM_NUMER + FPREM_MAIN_FUDGE
FPREM_MAIN_PREV_CW		EQU	FPREM_PREV_CW + FPREM_MAIN_FUDGE
FPREM_MAIN_PATCH_CW		EQU	FPREM_PATCH_CW + FPREM_MAIN_FUDGE
FPREM_MAIN_FPREM_SW		EQU	FPREM_SW + FPREM_MAIN_FUDGE

FPREM_ONESMASK	EQU     700h


.data

fdiv_risc_table	DB	0, 1, 0, 0, 4, 0, 0, 7, 0, 0, 10, 0, 0, 13, 0, 0
fdiv_scale_1  	DD	03f700000h		;0.9375
fdiv_scale_2	DD	03f880000h		;1.0625
one_shl_63  	DD	05f000000h

fprem_risc_table 	DB 	0, 1, 0, 0, 4, 0, 0, 7, 0, 0, 10, 0, 0, 13, 0, 0
fprem_scale 		DB 	0, 0, 0, 0, 0, 0, 0eeh, 03fh
one_shl_64 		DB 	0, 0, 0, 0, 0, 0, 0f0h, 043h
one_shr_64 		DB 	0, 0, 0, 0, 0, 0, 0f0h, 03bh
one 			DB 	0, 0, 0, 0, 0, 0, 0f0h, 03fh
half 			DB 	0, 0, 0, 0, 0, 0, 0e0h, 03fh
big_number		DB	0, 0, 0, 0, 0, 0, 0ffh, 0ffh, 0feh, 07fh

ifdef	DEBUG
	public	fpcw
	public	fpsw
fpcw	dw	0
fpsw	dw	0
endif

FPU_STATE	STRUC
	CONTROL_WORD	DW	?
	reserved_1	DW	?
	STATUS_WORD	DD	?
	TAG_WORD	DW	?
	reserved_3	DW	?
	IP_OFFSET	DD	?
	CS_SLCT		DW	?
	OPCODE		DW	?
	DATA_OFFSET	DD	?
	OPERAND_SLCT	DW	?
	reserved_4	DW	?
FPU_STATE	ENDS

ENV_SIZE	EQU	28



dispatch_table DD	offset FLAT:label0
	DD	offset FLAT:label1
	DD	offset FLAT:label2
	DD	offset FLAT:label3
	DD	offset FLAT:label4
	DD	offset FLAT:label5
	DD	offset FLAT:label6
	DD	offset FLAT:label7
	DD	offset FLAT:label8
	DD	offset FLAT:label9
	DD	offset FLAT:label10
	DD	offset FLAT:label11
	DD	offset FLAT:label12
	DD	offset FLAT:label13
	DD	offset FLAT:label14
	DD	offset FLAT:label15
	DD	offset FLAT:label16
	DD	offset FLAT:label17
	DD	offset FLAT:label18
	DD	offset FLAT:label19
	DD	offset FLAT:label20
	DD	offset FLAT:label21
	DD	offset FLAT:label22
	DD	offset FLAT:label23
	DD	offset FLAT:label24
	DD	offset FLAT:label25
	DD	offset FLAT:label26
	DD	offset FLAT:label27
	DD	offset FLAT:label28
	DD	offset FLAT:label29
	DD	offset FLAT:label30
	DD	offset FLAT:label31
	DD	offset FLAT:label32
	DD	offset FLAT:label33
	DD	offset FLAT:label34
	DD	offset FLAT:label35
	DD	offset FLAT:label36
	DD	offset FLAT:label37
	DD	offset FLAT:label38
	DD	offset FLAT:label39
	DD	offset FLAT:label40
	DD	offset FLAT:label41
	DD	offset FLAT:label42
	DD	offset FLAT:label43
	DD	offset FLAT:label44
	DD	offset FLAT:label45
	DD	offset FLAT:label46
	DD	offset FLAT:label47
	DD	offset FLAT:label48
	DD	offset FLAT:label49
	DD	offset FLAT:label50
	DD	offset FLAT:label51
	DD	offset FLAT:label52
	DD	offset FLAT:label53
	DD	offset FLAT:label54
	DD	offset FLAT:label55
	DD	offset FLAT:label56
	DD	offset FLAT:label57
	DD	offset FLAT:label58
	DD	offset FLAT:label59
	DD	offset FLAT:label60
	DD	offset FLAT:label61
	DD	offset FLAT:label62
	DD	offset FLAT:label63


fpcw	dw	0



CODESEG


;
;  PRELIMINARY VERSION for register-register divides.
;


					; In this implementation the
					; fdiv_main_routine is called,
					; therefore all the stack frame
					; locations are adjusted for the
					; return pointer.

fdiv_main_routine PROC	NEAR

	fld     tbyte ptr [esp+MAIN_NUMER]	; load the numerator
	fld     tbyte ptr [esp+MAIN_DENOM]	; load the denominator
retry:

;  The following three lines test for denormals and zeros.
;  A denormal or zero has a 0 in the explicit digit to the left of the
;  binary point.  Since that bit is the high bit of the word, adding
;  it to itself will produce a carry if and only if the number is not
;  denormal or zero.
;
	mov 	eax, [esp+MAIN_DENOM+4]	; get mantissa bits 32-64
	add 	eax,eax			; shift the one's bit onto carry
	jnc 	denormal		; if no carry, we're denormal

;  The following three lines test the three bits after the four bit 
;  pattern (1,4,7,a,d).  If these three bits are not all one, then
;  the denominator cannot expose the flaw.  This condition is tested by
;  inverting the bits and testing that all are equal to zero afterward.

	xor 	eax, ONESMASK		; invert the bits that must be ones
	test	eax, ONESMASK		; and make sure they are all ones
	jz  	scale_if_needed		; if all are one scale numbers
	fdivp	st(1), st		; use of hardware is OK.
	ret

;
;  Now we test the four bits for one of the five patterns.
;
scale_if_needed:
	shr	eax, 28			; keep first 4 bits after point
	cmp	byte ptr fdiv_risc_table[eax], 0	; check for (1,4,7,a,d)
	jnz	divide_scaled		; are in potential problem area
	fdivp	st(1), st		; use of hardware is OK.
	ret

divide_scaled:
	mov	eax, [esp + MAIN_DENOM+8]	; test denominator exponent
	and	eax, 07fffh             ; if pseudodenormal ensure that only
	jz	invalid_denom		; invalid exception flag is set
	cmp	eax, 07fffh             ; if NaN or infinity  ensure that only
	je	invalid_denom		; invalid exception flag is set
;
;  The following six lines turn off exceptions and set the
;  precision control to 80 bits.  The former is necessary to
;  force any traps to be taken at the divide instead of the scaling
;  code.  The latter is necessary in order to get full precision for
;  codes with incoming 32 and 64 bit precision settings.  If
;  it can be guaranteed that before reaching this point, the underflow
;  exception is masked and the precision control is at 80 bits, these
;  six lines can be omitted.
;
	fnstcw	[esp+PREV_CW]		; save caller's control word
	mov	eax, [esp+PREV_CW] 
	or	eax, 033fh		; mask exceptions, pc=80
	and	eax, 0f3ffh		; set rounding mode to nearest
	mov	[esp+PATCH_CW], eax
	fldcw	[esp+PATCH_CW]		; mask exceptions & pc=80

;  The following lines check the numerator exponent before scaling.
;  This in order to prevent undeflow when scaling the numerator,
;  which will cause a denormal exception flag to be set when the
;  actual divide is preformed. This flag would not have been set
;  normally. If there is a risk of underflow, the scale factor is
;  17/16 instead of 15/16.
;
 	mov	eax, [esp+MAIN_NUMER+8]	; test numerator exponent
 	and	eax, 07fffh
 	cmp	eax, 00001h
 	je	small_numer

	fmul	fdiv_scale_1		; scale denominator by 15/16
	fxch
	fmul	fdiv_scale_1		; scale numerator by 15/16
	fxch

;
;  The next line restores the users control word.  If the incoming
;  control word had the underflow exception masked and precision
;  control set to 80 bits, this line can be omitted.
;

	fldcw	[esp+PREV_CW]		; restore caller's control word
	fdivp	st(1), st		; use of hardware is OK.
	ret

small_numer:
	fmul	fdiv_scale_2		; scale denominator by 17/16
	fxch
	fmul	fdiv_scale_2		; scale numerator by 17/16
	fxch

;
;  The next line restores the users control word.  If the incoming
;  control word had the underflow exception masked and precision
;  control set to 80 bits, this line can be omitted.
;

	fldcw	[esp+PREV_CW]		; restore caller's control word
	fdivp	st(1), st		; use of hardware is OK.
	ret

denormal:
	mov	eax, [esp+MAIN_DENOM]	; test for whole mantissa == 0
	or	eax, [esp+MAIN_DENOM+4]	; test for whole mantissa == 0
	jnz	denormal_divide_scaled	; denominator is not zero
invalid_denom:				; zero or invalid denominator
	fdivp	st(1), st		; use of hardware is OK.
	ret

denormal_divide_scaled:
	mov	eax, [esp + MAIN_DENOM + 8]	; get exponent 
	and	eax, 07fffh		; check for zero exponent
	jnz	invalid_denom		; 
;
;  The following six lines turn off exceptions and set the
;  precision control to 80 bits.  The former is necessary to
;  force any traps to be taken at the divide instead of the scaling
;  code.  The latter is necessary in order to get full precision for
;  codes with incoming 32 and 64 bit precision settings.  If
;  it can be guaranteed that before reaching this point, the underflow
;  exception is masked and the precision control is at 80 bits, these
;  six lines can be omitted.
;

	fnstcw	[esp+PREV_CW]		; save caller's control word
	mov	eax, [esp+PREV_CW] 
	or	eax, 033fh		; mask exceptions, pc=80
	and	eax, 0f3ffh		; set rounding mode to nearest
	mov	[esp+PATCH_CW], eax
	fldcw	[esp+PATCH_CW]		; mask exceptions & pc=80

	mov	eax, [esp + MAIN_NUMER +8]	; test numerator exponent
	and	eax, 07fffh		; check for denormal numerator
	je	denormal_numer	
	cmp	eax, 07fffh		; NaN or infinity
	je	invalid_numer
	mov	eax, [esp + MAIN_NUMER + 4]	; get bits 32..63 of mantissa
	add	eax, eax		; shift the first bit into carry
	jnc	invalid_numer		; if there is no carry, we have an
					; invalid numer
	jmp	numer_ok

denormal_numer:
	mov	eax, [esp + MAIN_NUMER + 4]	; get bits 32..63 of mantissa
	add	eax, eax		; shift the first bit into carry
	jc	invalid_numer		; if there is a carry, we have an
					; invalid numer
	
numer_ok:
	fxch
	fstp	st			; pop numerator
	fld 	st			; make copy of denominator
	fmul	dword ptr[one_shl_63]	; make denominator not denormal
	fstp	tbyte ptr [esp+MAIN_DENOM]	; save modified denominator
	fld 	tbyte ptr [esp+MAIN_NUMER]	; load numerator
	fxch				; restore proper order
	fwait

;  The next line restores the users control word.  If the incoming
;  control word had the underflow exception masked and precision
;  control set to 80 bits, this line can be omitted.
;

	fldcw	[esp+PREV_CW]		; restore caller's control word
	jmp	retry			; start the whole thing over

invalid_numer:
;
;  The next line restores the users control word.  If the incoming
;  control word had the underflow exception masked and precision
;  control set to 80 bits, this line can be omitted.
;
	fldcw	[esp + PREV_CW]
	fdivp	st(1), st		; use of hardware is OK.
	ret

fdiv_main_routine	ENDP

fdivr_st	MACRO	reg_index, reg_index_minus1
	fstp	tbyte ptr [esp+DENOM]
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fstp	tbyte ptr [esp+NUMER]
	call	fdiv_main_routine
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fld	tbyte ptr [esp+NUMER]
	fxch	st(reg_index)
	add	esp, STACK_SIZE
ENDM

fdivr_sti	MACRO	reg_index, reg_index_minus1
	fstp	tbyte ptr [esp+NUMER]
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fstp	tbyte ptr [esp+DENOM]
	call	fdiv_main_routine
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fld	tbyte ptr [esp+NUMER]
	add	esp, STACK_SIZE
ENDM

fdivrp_sti	MACRO	reg_index, reg_index_minus1
	fstp	tbyte ptr [esp+NUMER]
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fstp	tbyte ptr [esp+DENOM]
	call	fdiv_main_routine
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	add	esp, STACK_SIZE
ENDM

fdiv_st		MACRO	reg_index, reg_index_minus1
	fstp	tbyte ptr [esp+NUMER]
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fld	st
	fstp	tbyte ptr [esp+DENOM]
	fstp	tbyte ptr [esp+DENOM_SAVE]	; save original denom, 
	call	fdiv_main_routine
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fld	tbyte ptr [esp+DENOM_SAVE]
	fxch	st(reg_index)
	add	esp, STACK_SIZE
ENDM

fdiv_sti	MACRO	reg_index, reg_index_minus1
	fxch	st(reg_index)
	fstp	tbyte ptr [esp+NUMER]
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fld	st
	fstp	tbyte ptr [esp+DENOM]
	fstp	tbyte ptr [esp+DENOM_SAVE]	; save original denom, 
	call	fdiv_main_routine
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fld	tbyte ptr [esp+DENOM_SAVE]
	add	esp, STACK_SIZE
ENDM

fdivp_sti	MACRO	reg_index, reg_index_minus1
	fstp	tbyte ptr [esp+DENOM]
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fstp	tbyte ptr [esp+NUMER]
	call	fdiv_main_routine
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	add	esp, STACK_SIZE
ENDM 


	public  _adj_fdiv_r
_adj_fdiv_r      PROC    NEAR

	sub	esp, STACK_SIZE			; added back at end of fdiv_x macros
	and eax, 0000003FH			; upper 26 bits could be anything
	jmp	dword ptr dispatch_table[eax*4]



label0::
	fdiv	st,st(0)		; D8 F0 	FDIV	ST,ST(0)
	add	esp, STACK_SIZE
	ret
label1::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label2::
	fdivr	st,st(0)		; D8 F8		FDIVR	ST,ST(0)
	add	esp, STACK_SIZE
	ret
label3::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label4::
	fdiv 	st(0),st		; DC F8/D8 F0	FDIV	ST(0),ST
	add	esp, STACK_SIZE
	ret
label5::
	fdivp 	st(0),st		; DE F8		FDIVP	ST(0),ST
	add	esp, STACK_SIZE
	ret
label6::
	fdivr 	st(0),st		; DC F0/DE F0	FDIVR	ST(0),ST
	add	esp, STACK_SIZE
	ret
label7::
	fdivrp 	st(0),st		; DE F0		FDIVRP	ST(0),ST
	add	esp, STACK_SIZE
	ret
label8::
	fdiv_st 1,0
	ret
label9::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label10::
	fdivr_st 1,0
	ret
label11::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label12::
	fdiv_sti 1,0
	ret
label13::
	fdivp_sti 1,0
	ret
label14::
	fdivr_sti 1,0
	ret
label15::
	fdivrp_sti 1,0
	ret
label16::
	fdiv_st 2,1
	ret
label17::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label18::
	fdivr_st 2,1
	ret
label19::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label20::
	fdiv_sti 2,1
	ret
label21::
	fdivp_sti 2,1
	ret
label22::
	fdivr_sti 2,1
	ret
label23::
	fdivrp_sti 2,1
	ret
label24::
	fdiv_st 3,2
	ret
label25::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label26::
	fdivr_st 3,2
	ret
label27::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label28::
	fdiv_sti 3,2
	ret
label29::
	fdivp_sti 3,2
	ret
label30::
	fdivr_sti 3,2
	ret
label31::
	fdivrp_sti 3,2
	ret
label32::
	fdiv_st 4,3
	ret
label33::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label34::
	fdivr_st 4,3
	ret
label35::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label36::
	fdiv_sti 4,3
	ret
label37::
	fdivp_sti 4,3
	ret
label38::
	fdivr_sti 4,3
	ret
label39::
	fdivrp_sti 4,3
	ret
label40::
	fdiv_st 5,4
	ret
label41::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label42::
	fdivr_st 5,4
	ret
label43::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label44::
	fdiv_sti 5,4
	ret
label45::
	fdivp_sti 5,4
	ret
label46::
	fdivr_sti 5,4
	ret
label47::
	fdivrp_sti 5,4
	ret
label48::
	fdiv_st 6,5
	ret
label49::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label50::
	fdivr_st 6,5
	ret
label51::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label52::
	fdiv_sti 6,5
	ret
label53::
	fdivp_sti 6,5
	ret
label54::
	fdivr_sti 6,5
	ret
label55::
	fdivrp_sti 6,5
	ret
label56::
	fdiv_st 7,6
	ret
label57::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label58::
	fdivr_st 7,6
	ret
label59::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label60::
	fdiv_sti 7,6
	ret
label61::
	fdivp_sti 7,6
	ret
label62::
	fdivr_sti 7,6
	ret
label63::
	fdivrp_sti 7,6
	ret
_adj_fdiv_r      ENDP



_fdivp_sti_st	PROC	NEAR
				; for calling from mem routines
	sub	esp, STACK_SIZE			; added back at end of fdivp_sti macro
	fdivp_sti 1, 0
	ret
_fdivp_sti_st	ENDP

_fdivrp_sti_st	PROC	NEAR
				; for calling from mem routines
	sub	esp, STACK_SIZE			; added back at end of fdivrp_sti macro
	fdivrp_sti 1, 0
	ret
_fdivrp_sti_st	ENDP


;;; _adj_fdiv_m32 - FDIV m32real FIX
;;
;; 	Input : Value of the m32real in the top of STACK
;;
;;	Output: Result of FDIV in ST

	PUBLIC	_adj_fdiv_m32
_adj_fdiv_m32	PROC	NEAR

	push	eax				; save eax
	mov	eax, [esp + MEM_OPERAND]	; check for
	and	eax, SINGLE_NAN			; NaN
	cmp	eax, SINGLE_NAN			;
	je	memory_divide_m32		;

	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack			; is FP stack full?
	fld	dword ptr[esp + MEM_OPERAND]	; load m32real in ST
	call	_fdivp_sti_st			; do actual divide
	pop	eax
	ret 4
spill_fpstack:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp ]			; save user's ST(1)
	fld	dword ptr[esp + SPILL_MEM_OPERAND] ; load m32 real 
	call	_fdivp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivrp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 4
memory_divide_m32:
	fdiv	dword ptr[esp + MEM_OPERAND]	; do actual divide
	pop	eax
	ret 4

_adj_fdiv_m32	ENDP
	

;;; _adj_fdiv_m64 - FDIV m64real FIX
;;
;; 	Input : Value of the m64real in the top of STACK
;;
;;	Output: Result of FDIV in ST

	PUBLIC	_adj_fdiv_m64
_adj_fdiv_m64	PROC	NEAR

	push	eax				; save eax
	mov	eax, [esp + MEM_OPERAND + 4]	; check for
	and	eax, DOUBLE_NAN			; NaN
	cmp	eax, DOUBLE_NAN			;
	je	memory_divide_m64		;

	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack_m64		; is FP stack full?
	fld	qword ptr[esp + MEM_OPERAND]	; load m64real in ST
	call	_fdivp_sti_st			; do actual divide
	pop	eax
	ret 8
spill_fpstack_m64:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp]			; save user's ST(1)
	fld	qword ptr[esp + SPILL_MEM_OPERAND] ; load m64real 
	call	_fdivp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivrp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 8
memory_divide_m64:
	fdiv	qword ptr[esp + MEM_OPERAND]	; do actual divide
	pop	eax
	ret 8

_adj_fdiv_m64	ENDP

;;; _adj_fdiv_m16i - FDIV m16int FIX
;;
;; 	Input : Value of the m16int in the top of STACK
;;
;;	Output: Result of FDIV in ST

	PUBLIC	_adj_fdiv_m16i
_adj_fdiv_m16i	PROC	NEAR
	push	eax				; save eax
	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack_m16i		; is FP stack full?
	fild	word ptr[esp + MEM_OPERAND]	; load m16int in ST
	call	_fdivp_sti_st			; do actual divide
	pop	eax
	ret 4
spill_fpstack_m16i:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp ]			; save user's ST(1)
	fild	word ptr[esp + SPILL_MEM_OPERAND] ; load m16int
	call	_fdivp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivrp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 4

_adj_fdiv_m16i	ENDP

;;; _adj_fdiv_m32i - FDIV m32int FIX
;;
;; 	Input : Value of the m32int in the top of STACK
;;
;;	Output: Result of FDIV in ST

	PUBLIC	_adj_fdiv_m32i
_adj_fdiv_m32i	PROC	NEAR
	push	eax				; save eax
	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack_m32i		; is FP stack full?
	fild	dword ptr[esp + MEM_OPERAND]	; load m32int in ST
	call	_fdivp_sti_st			; do actual divide
	pop	eax
	ret 4
spill_fpstack_m32i:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp ]			; save user's ST(1)
	fild	dword ptr[esp + SPILL_MEM_OPERAND] ; load m32int
	call	_fdivp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivrp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 4

_adj_fdiv_m32i	ENDP



;;; _adj_fdivr_m32 - FDIVR m32real FIX
;;
;; 	Input : Value of the m32real in the top of STACK
;;
;;	Output: Result of FDIVR in ST

	PUBLIC	_adj_fdivr_m32
_adj_fdivr_m32	PROC	NEAR
	push	eax				; save eax
	mov	eax, [esp + MEM_OPERAND]	; check for
	and	eax, SINGLE_NAN			; NaN
	cmp	eax, SINGLE_NAN			;
	je	memory_divide_m32r		;

	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack_m32r		; is FP stack full?
	fld	dword ptr[esp + MEM_OPERAND]	; load m32real in ST
	call	_fdivrp_sti_st			; do actual divide
	pop	eax
	ret 4
spill_fpstack_m32r:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp ]			; save user's ST(1)
	fld	dword ptr[esp + SPILL_MEM_OPERAND] ; load m32 real 
	call	_fdivrp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 4
memory_divide_m32r:
	fdivr	dword ptr[esp + MEM_OPERAND]	; do actual divide
	pop	eax
	ret 4

_adj_fdivr_m32	ENDP


;;; _adj_fdivr_m64 - FDIVR m64real FIX
;;
;; 	Input : Value of the m64real in the top of STACK
;;
;;	Output: Result of FDIVR in ST

	PUBLIC	_adj_fdivr_m64
_adj_fdivr_m64	PROC	NEAR
	push	eax				; save eax
	mov	eax, [esp + MEM_OPERAND + 4]	; check for
	and	eax, DOUBLE_NAN			; NaN
	cmp	eax, DOUBLE_NAN			;
	je	memory_divide_m64r		;

	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack_m64r		; is FP stack full?
	fld	qword ptr[esp + MEM_OPERAND]	; load m64real in ST
	call	_fdivrp_sti_st			; do actual divide
	pop	eax
	ret 8
spill_fpstack_m64r:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp ]			; save user's ST(1)
	fld	qword ptr[esp + SPILL_MEM_OPERAND] ; load m64real 
	call	_fdivrp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 8
memory_divide_m64r:
	fdivr	qword ptr[esp + MEM_OPERAND]	; do actual divide
	pop	eax
	ret 8

_adj_fdivr_m64	ENDP


;;; _adj_fdivr_m16i - FDIVR m16int FIX
;;
;; 	Input : Value of the m16int in the top of STACK
;;
;;	Output: Result of FDIVR in ST

	PUBLIC	_adj_fdivr_m16i
_adj_fdivr_m16i	PROC	NEAR
	push	eax				; save eax
	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack_m16ir		; is FP stack full?
	fild	word ptr[esp + MEM_OPERAND]	; load m16int in ST
	call	_fdivrp_sti_st			; do actual divide
	pop	eax
	ret 4
spill_fpstack_m16ir:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp ]			; save user's ST(1)
	fild	word ptr[esp + SPILL_MEM_OPERAND] ; load m16int
	call	_fdivrp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 4

_adj_fdivr_m16i	ENDP


;;; _adj_fdivr_m32i - FDIVR m32int FIX
;;
;; 	Input : Value of the m32int in the top of STACK
;;
;;	Output: Result of FDIVR in ST

	PUBLIC	_adj_fdivr_m32i
_adj_fdivr_m32i	PROC	NEAR
	push	eax				; save eax
	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack_m32ir		; is FP stack full?
	fild	dword ptr[esp + MEM_OPERAND]	; load m32int in ST
	call	_fdivrp_sti_st			; do actual divide
	pop	eax
	ret 4
spill_fpstack_m32ir:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp ]			; save user's ST(1)
	fild	dword ptr[esp + SPILL_MEM_OPERAND] ; load m32int
	call	_fdivrp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 4

_adj_fdivr_m32i	ENDP


;;; _safe_fdiv - FDIV fix
;;
;;	Pentium-safe version of FDIV, aka FDIVP ST(1),ST(0)
;;
;; 	Input : Numerator in ST(1), Denominator in ST(0)
;;
;;	Output: Result of FDIV in ST(0)


	PUBLIC  _safe_fdiv
_safe_fdiv      PROC    NEAR

	push eax
	sub	esp, STACK_SIZE
	fstp	tbyte ptr [esp+DENOM]
	fstp	tbyte ptr [esp+NUMER]
	call	fdiv_main_routine
	add	esp, STACK_SIZE
	pop eax
	ret

_safe_fdiv	ENDP


;;; _safe_fdivr - FDIVR fix
;;
;;	Pentium-safe version of FDIVR, aka FDIVRP ST(1),ST(0)
;;
;; 	Input : Numerator in ST(0), Denominator in ST(1)
;;
;;	Output: Result of FDIVR in ST(0)

	public  _safe_fdivr
_safe_fdivr      PROC    NEAR

	push eax
	sub	esp, STACK_SIZE
	fstp	tbyte ptr [esp+NUMER]
	fstp	tbyte ptr [esp+DENOM]
	call	fdiv_main_routine
	add	esp, STACK_SIZE
	pop eax
	ret

_safe_fdivr	ENDP



;;; _adj_fprem - FPREM FIX
;;
;;	Based on PRELIMINARY Intel code.


_fprem_common	PROC	NEAR

	push	eax
	push	ebx
	push	ecx
    mov     eax, [FPREM_MAIN_DENOM+6+esp] ; exponent and high 16 bits of mantissa
    xor     eax, FPREM_ONESMASK           ; invert bits that have to be one
    test    eax, FPREM_ONESMASK           ; check bits that have to be one
	jnz     remainder_hardware_ok
    shr     eax, 11
    and     eax, 0fh
    cmp     byte ptr fprem_risc_table[eax], 0     ; check for (1,4,7,a,d)
    jz      remainder_hardware_ok

; The denominator has the bit pattern. Weed out the funny cases like NaNs
; before applying the software version. Our caller guarantees that the
; denominator is not a denormal. Here we check for:
;	denominator	inf, NaN, unnormal
;	numerator	inf, NaN, unnormal, denormal

	mov     eax, [FPREM_MAIN_DENOM+6+esp] ; exponent and high 16 bits of mantissa
    and     eax, 07fff0000h	        ; mask the exponent only
    cmp     eax, 07fff0000h         ; check for INF or NaN 
	je  	remainder_hardware_ok
	mov     eax, [FPREM_MAIN_NUMER+6+esp] ; exponent and high 16 bits of mantissa
    and     eax, 07fff0000h		; mask the exponent only
	jz  	remainder_hardware_ok	; jif numerator denormal
    cmp     eax, 07fff0000h         ; check for INF or NaN 
	je  	remainder_hardware_ok
	mov 	eax, [esp + FPREM_MAIN_NUMER + 4]	; high mantissa bits - numerator
	add 	eax, eax		; set carry if explicit bit set
	jnz 	remainder_hardware_ok	; jmp if numerator is unnormal
	mov 	eax, [esp + FPREM_MAIN_DENOM + 4] ; high mantissa bits - denominator
	add 	eax, eax		; set carry if explicit bit set
	jnz 	remainder_hardware_ok	; jmp if denominator is unnormal

rem_patch:
    mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
    and     eax, 07fffh              ; clear sy
    add     eax, 63                  ; evaluate ey + 63 
    mov     ebx, [FPREM_MAIN_NUMER+8+esp]  ; sign and exponent of x (numerator)
    and     ebx, 07fffh              ; clear sx
    sub     ebx, eax                 ; evaluate the exponent difference (ex - ey)
    ja      rem_large	 	; if ex > ey + 63, case of large arguments 
rem_patch_loop:
	mov     eax, [FPREM_MAIN_DENOM+8+esp]  ; sign and exponent of y (denominator)
	and     eax, 07fffh		; clear sy
	add 	eax, 10			; evaluate ey + 10
	mov     ebx, [FPREM_MAIN_NUMER+8+esp]	; sign and exponent of x (numerator)
	and     ebx, 07fffh		; clear sx 	
	sub 	ebx, eax		; evaluate the exponent difference (ex - ey)
	js  	remainder_hardware_ok	; safe if ey + 10 > ex
	fld     tbyte ptr [FPREM_MAIN_NUMER+esp]   ; load the numerator
	mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
    mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
	and     ebx, 07fffh             ; clear sx
	mov		ecx, ebx
	sub		ebx, eax
	and		ebx, 07h
	or		ebx, 04h
	sub		ecx, ebx
	mov		ebx, eax
	and     ebx, 08000h		; keep sy
	or		ecx, ebx		; merge the sign of y
	mov		dword ptr [FPREM_MAIN_DENOM+8+esp], ecx
	fld     tbyte ptr [FPREM_MAIN_DENOM+esp]   ; load the shifted denominator
	mov     dword ptr [FPREM_MAIN_DENOM+8+esp], eax	; restore the initial denominator
	fxch
	fprem				; this rem is safe
	fstp	tbyte ptr [FPREM_MAIN_NUMER+esp]	; update the numerator
	fstp    st(0)                   ; pop the stack
	jmp     rem_patch_loop 
rem_large:
	test	edx, 02h		; is denominator already saved
	jnz 	already_saved
	fld 	tbyte ptr[esp + FPREM_MAIN_DENOM]
	fstp	tbyte ptr[esp + FPREM_MAIN_DENOM_SAVE]	; save denominator
already_saved:
	; Save user's precision control and institute 80.  The fp ops in
	; rem_large_loop must not round to user's precision (if it is less
	; than 80) because the hardware would not have done so.  We are
	; aping the hardware here, which is all extended.

	fnstcw	[esp+FPREM_MAIN_PREV_CW]	; save caller's control word
	mov 	eax, dword ptr[esp + FPREM_MAIN_PREV_CW]
	or  	eax, 033fh		; mask exceptions, pc=80
	mov 	[esp + FPREM_MAIN_PATCH_CW], eax
	fldcw	[esp + FPREM_MAIN_PATCH_CW]	

    mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
    and     eax, 07fffh             ; clear sy
    mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
    and     ebx, 07fffh             ; clear sx
	sub 	ebx, eax		; evaluate the exponent difference
	and 	ebx, 03fh
	or  	ebx, 020h
	add 	ebx, 1
	mov 	ecx, ebx
	mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
	mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
    and     ebx, 07fffh             ; clear sx
    and     eax, 08000h             ; keep sy
    or      ebx, eax                ; merge the sign of y
    mov     dword ptr[FPREM_MAIN_DENOM+8+esp], ebx	; make ey equal to ex (scaled denominator)
    fld     tbyte ptr [FPREM_MAIN_DENOM+esp]   ; load the scaled denominator
	fabs
    fld     tbyte ptr [FPREM_MAIN_NUMER+esp]   ; load the numerator
	fabs
rem_large_loop:
	fcom
	fnstsw  ax	
	and     eax, 00100h		
	jnz 	rem_no_sub
	fsub	st, st(1)
rem_no_sub:
	fxch
	fmul	qword ptr half
	fxch
	sub	ecx, 1			; decrement the loop counter
	jnz 	rem_large_loop
	mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
	fstp	tbyte ptr[esp + FPREM_MAIN_NUMER]	; save result
	fstp	st			; toss modified denom
	fld 	tbyte ptr[esp + FPREM_MAIN_DENOM_SAVE]
	fld 	tbyte ptr[big_number]	; force C2 to be set
	fprem
	fstp	st
	fld 	tbyte ptr[esp + FPREM_MAIN_NUMER]	; restore saved result
	
	fldcw	[esp + FPREM_MAIN_PREV_CW]	; restore caller's control word
	and     ebx, 08000h             ; keep sx
	jz  	rem_done
	fchs
	jmp  	rem_done
remainder_hardware_ok:
    fld     tbyte ptr [FPREM_MAIN_DENOM+esp]   ; load the denominator
    fld     tbyte ptr [FPREM_MAIN_NUMER+esp]   ; load the numerator
	fprem                           ; and finally do a remainder
; prem_main_routine end
rem_done:
	test	edx, 03h
	jz  	rem_exit
	fnstsw	[esp + FPREM_MAIN_FPREM_SW]	; save Q0 Q1 and Q2
	test	edx, 01h
	jz  	do_not_de_scale
; De-scale the result. Go to pc=80 to prevent from fmul
; from user precision (fprem does not round the result).
	fnstcw	[esp + FPREM_MAIN_PREV_CW]	; save callers control word
	mov 	eax, [esp + FPREM_MAIN_PREV_CW]
	or  	eax, 0300h		; pc = 80
	mov 	[esp + FPREM_MAIN_PATCH_CW], eax
	fldcw	[esp + FPREM_MAIN_PATCH_CW]
	fmul	qword ptr one_shr_64
	fldcw	[esp + FPREM_MAIN_PREV_CW]	; restore callers CW
do_not_de_scale:
	mov	eax, [esp + FPREM_MAIN_FPREM_SW]
	fxch
	fstp	st
	fld 	tbyte ptr[esp + FPREM_MAIN_DENOM_SAVE]
	fxch
	and 	eax, 04300h		; restore saved Q0, Q1, Q2
	sub 	esp, ENV_SIZE
	fnstenv	[esp]
	and 	[esp].STATUS_WORD, 0bcffh
	or  	[esp].STATUS_WORD, eax
	fldenv	[esp]
	add 	esp, ENV_SIZE
rem_exit:
	pop 	ecx
	pop 	ebx
	pop 	eax
	ret
_fprem_common	ENDP




    PUBLIC  _adj_fprem
_adj_fprem	PROC	NEAR
	push	edx
    sub     esp, FPREM_STACK_SIZE
    fstp    tbyte ptr [FPREM_NUMER+esp]
    fstp    tbyte ptr [FPREM_DENOM+esp]
	xor 	edx, edx
; prem_main_routine begin
    mov     eax,[FPREM_DENOM+6+esp]       ; exponent and high 16 bits of mantissa
    test    eax,07fff0000h          ; check for denormal
    jz      fprem_denormal
	call	_fprem_common
	add 	esp, FPREM_STACK_SIZE
	pop 	edx
	ret

fprem_denormal:
    fld     tbyte ptr [FPREM_DENOM+esp]   ; load the denominator
    fld     tbyte ptr [FPREM_NUMER+esp]   ; load the numerator
    mov     eax, [FPREM_DENOM+esp]        ; test for whole mantissa == 0
    or      eax, [FPREM_DENOM+4+esp]      ; test for whole mantissa == 0
    jz      remainder_hardware_ok_l ; denominator is zero
	fxch
	fstp	tbyte ptr[esp + FPREM_DENOM_SAVE]	; save org denominator
	fld 	tbyte ptr[esp + FPREM_DENOM]
	fxch
	or  	edx, 02h
;
; For this we need pc=80.  Also, mask exceptions so we don't take any
; denormal operand exceptions.  It is guaranteed that the descaling
; later on will take underflow, which is what the hardware would have done
; on a normal fprem.
;
    fnstcw  [FPREM_PREV_CW+esp]         ; save caller's control word
    mov     eax, [FPREM_PREV_CW+esp] 
    or      eax, 0033fh             	; mask exceptions, pc=80
    mov     [FPREM_PATCH_CW+esp], eax
    fldcw   [FPREM_PATCH_CW+esp]        ; mask exceptions & pc=80

; The denominator is a denormal.  For most numerators, scale both numerator
; and denominator to get rid of denormals.  Then execute the common code
; with the flag set to indicate that the result must be de-scaled.
; For large numerators this won't work because the scaling would cause
; overflow.  In this case we know the numerator is large, the denominator
; is small (denormal), so the exponent difference is also large.  This means
; the rem_large code will be used and this code depends on the difference
; in exponents modulo 64.  Adding 64 to the denominators exponent
; doesn't change the modulo 64 difference.  So we can scale the denominator
; by 64, making it not denormal, and this won't effect the result.
;
; To start with, figure out if numerator is large

	mov 	eax, [esp + FPREM_NUMER + 8]	; load numerator exponent
	and 	eax, 7fffh		; isolate numerator exponent
	cmp 	eax, 7fbeh		; compare Nexp to Maxexp-64
	ja  	big_numer_rem_de	; jif big numerator

; So the numerator is not large scale both numerator and denominator

	or  	edx, 1			; edx = 1, if denormal extended divisor
	fmul	qword ptr one_shl_64	; make numerator not denormal
	fstp	tbyte ptr[esp + FPREM_NUMER]
	fmul	qword ptr one_shl_64	; make denominator not denormal
	fstp	tbyte ptr[esp + FPREM_DENOM]
	jmp 	scaling_done

; The numerator is large.  Scale only the denominator, which will not
; change the result which we know will be partial.  Set the scale flag
; to false.
big_numer_rem_de:
; We must do this with pc=80 to avoid rounding to single/double.
; In this case we do not mask exceptions so that we will take
; denormal operand, as would the hardware.
	fnstcw  [FPREM_PREV_CW+esp]				; save caller's control word
	mov     eax, [FPREM_PREV_CW+esp] 
	or      eax, 00300h             		; pc=80
	mov     [FPREM_PATCH_CW+esp], eax
	fldcw   [FPREM_PATCH_CW+esp]			; pc=80

	fstp	st			; Toss numerator
	fmul	qword ptr one_shl_64	; make denominator not denormal
	fstp	tbyte ptr[esp + FPREM_DENOM]
	
; Restore the control word which was fiddled to scale at 80-bit precision.
; Then call the common code.
scaling_done:
	fldcw	[esp + FPREM_PREV_CW] 	; restore callers control word
	call	_fprem_common
	add 	esp, FPREM_STACK_SIZE
	pop 	edx
	ret
	
remainder_hardware_ok_l:
    fprem              		; and finally do a remainder 

    add     esp, FPREM_STACK_SIZE
	pop 	edx
    ret

_adj_fprem	ENDP



;
; FPREM1 code begins here
;


_fprem1_common	PROC	NEAR

	push	eax
	push	ebx
	push	ecx
    mov     eax, [FPREM_MAIN_DENOM+6+esp] ; exponent and high 16 bits of mantissa
    xor     eax, FPREM_ONESMASK           ; invert bits that have to be one
    test    eax, FPREM_ONESMASK           ; check bits that have to be one
	jnz     remainder1_hardware_ok
    shr     eax, 11
    and     eax, 0fh
    cmp     byte ptr fprem_risc_table[eax], 0     ; check for (1,4,7,a,d)
    jz      remainder1_hardware_ok

; The denominator has the bit pattern. Weed out the funny cases like NaNs
; before applying the software version. Our caller guarantees that the
; denominator is not a denormal. Here we check for:
;	denominator	inf, NaN, unnormal
;	numerator	inf, NaN, unnormal, denormal

	mov     eax, [FPREM_MAIN_DENOM+6+esp] ; exponent and high 16 bits of mantissa
    and     eax, 07fff0000h	        ; mask the exponent only
    cmp     eax, 07fff0000h         ; check for INF or NaN 
	je  	remainder1_hardware_ok
	mov     eax, [FPREM_MAIN_NUMER+6+esp] ; exponent and high 16 bits of mantissa
    and     eax, 07fff0000h		; mask the exponent only
	jz  	remainder1_hardware_ok	; jif numerator denormal
    cmp     eax, 07fff0000h         ; check for INF or NaN 
	je  	remainder1_hardware_ok
	mov 	eax, [esp + FPREM_MAIN_NUMER + 4]	; high mantissa bits - numerator
	add 	eax, eax		; set carry if explicit bit set
	jnz 	remainder1_hardware_ok	; jmp if numerator is unnormal
	mov 	eax, [esp + FPREM_MAIN_DENOM + 4] ; high mantissa bits - denominator
	add 	eax, eax		; set carry if explicit bit set
	jnz 	remainder1_hardware_ok	; jmp if denominator is unnormal

rem1_patch:
    mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
    and     eax, 07fffh              ; clear sy
    add     eax, 63                  ; evaluate ey + 63 
    mov     ebx, [FPREM_MAIN_NUMER+8+esp]  ; sign and exponent of x (numerator)
    and     ebx, 07fffh              ; clear sx
    sub     ebx, eax                 ; evaluate the exponent difference (ex - ey)
    ja      rem1_large	 	; if ex > ey + 63, case of large arguments 
rem1_patch_loop:
	mov     eax, [FPREM_MAIN_DENOM+8+esp]  ; sign and exponent of y (denominator)
	and     eax, 07fffh		; clear sy
	add 	eax, 10			; evaluate ey + 10
	mov     ebx, [FPREM_MAIN_NUMER+8+esp]	; sign and exponent of x (numerator)
	and     ebx, 07fffh		; clear sx 	
	sub 	ebx, eax		; evaluate the exponent difference (ex - ey)
	js  	remainder1_hardware_ok	; safe if ey + 10 > ex
	fld     tbyte ptr [FPREM_MAIN_NUMER+esp]   ; load the numerator
	mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
    mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
	and     ebx, 07fffh             ; clear sx
	mov		ecx, ebx
	sub		ebx, eax
	and		ebx, 07h
	or		ebx, 04h
	sub		ecx, ebx
	mov		ebx, eax
	and     ebx, 08000h				; keep sy
	or		ecx, ebx				; merge the sign of y
	mov		dword ptr [FPREM_MAIN_DENOM+8+esp], ecx
	fld     tbyte ptr [FPREM_MAIN_DENOM+esp]   ; load the shifted denominator
	mov     dword ptr [FPREM_MAIN_DENOM+8+esp], eax	; restore the initial denominator
	fxch
	fprem				; this rem is safe
	fstp	tbyte ptr [FPREM_MAIN_NUMER+esp]	; update the numerator
	fstp    st(0)                   ; pop the stack
	jmp     rem1_patch_loop 
rem1_large:
	test	ebx, 02h		; is denominator already saved
	jnz 	already_saved1
	fld 	tbyte ptr[esp + FPREM_MAIN_DENOM]
	fstp	tbyte ptr[esp + FPREM_MAIN_DENOM_SAVE]	; save denominator
already_saved1:
	; Save user's precision control and institute 80.  The fp ops in
	; rem1_large_loop must not round to user's precision (if it is less
	; than 80) because the hardware would not have done so.  We are
	; aping the hardware here, which is all extended.

	fnstcw	[esp+FPREM_MAIN_PREV_CW]	; save caller's control word
	mov 	eax, dword ptr[esp + FPREM_MAIN_PREV_CW]
	or  	eax, 033fh		; mask exceptions, pc=80
	mov 	[esp + FPREM_MAIN_PATCH_CW], eax
	fldcw	[esp + FPREM_MAIN_PATCH_CW]	

    mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
    and     eax, 07fffh             ; clear sy
    mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
    and     ebx, 07fffh             ; clear sx
	sub 	ebx, eax		; evaluate the exponent difference
	and 	ebx, 03fh
	or  	ebx, 020h
	add 	ebx, 1
	mov 	ecx, ebx
	mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
	mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
    and     ebx, 07fffh             ; clear sx
    and     eax, 08000h             ; keep sy
    or      ebx, eax                ; merge the sign of y
    mov     dword ptr[FPREM_MAIN_DENOM+8+esp], ebx	; make ey equal to ex (scaled denominator)
    fld     tbyte ptr [FPREM_MAIN_DENOM+esp]   ; load the scaled denominator
	fabs
    fld     tbyte ptr [FPREM_MAIN_NUMER+esp]   ; load the numerator
	fabs
rem1_large_loop:
	fcom
	fnstsw  ax	
	and     eax, 00100h		
	jnz	rem1_no_sub
	fsub	st, st(1)
rem1_no_sub:
	fxch
	fmul	qword ptr half
	fxch
	sub 	ecx, 1			; decrement the loop counter
	jnz 	rem1_large_loop
	mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
	fstp	tbyte ptr[esp + FPREM_MAIN_NUMER]	; save result
	fstp	st			; toss modified denom
	fld 	tbyte ptr[esp + FPREM_MAIN_DENOM_SAVE]
	fld 	tbyte ptr[big_number]	; force C2 to be set
	fprem1
	fstp	st
	fld 	tbyte ptr[esp + FPREM_MAIN_NUMER]	; restore saved result
	
	fldcw	[esp + FPREM_MAIN_PREV_CW]	; restore caller's control word
	and     ebx, 08000h             ; keep sx
	jz  	rem1_done
	fchs
	jmp 	rem1_done
remainder1_hardware_ok:
    fld     tbyte ptr [FPREM_MAIN_DENOM+esp]   ; load the denominator
    fld     tbyte ptr [FPREM_MAIN_NUMER+esp]   ; load the numerator
	fprem1                           ; and finally do a remainder
; prem1_main_routine end
rem1_done:
	test	edx, 03h
	jz  	rem1_exit
	fnstsw	[esp + FPREM_MAIN_FPREM_SW]	; save Q0 Q1 and Q2
	test	edx, 01h
	jz  	do_not_de_scale1
; De-scale the result. Go to pc=80 to prevent from fmul
; from user precision (fprem does not round the result).
	fnstcw	[esp + FPREM_MAIN_PREV_CW]	; save callers control word
	mov 	eax, [esp + FPREM_MAIN_PREV_CW]
	or  	eax, 0300h		; pc = 80
	mov 	[esp + FPREM_MAIN_PATCH_CW], eax
	fldcw	[esp + FPREM_MAIN_PATCH_CW]
	fmul	qword ptr one_shr_64
	fldcw	[esp + FPREM_MAIN_PREV_CW]	; restore callers CW
do_not_de_scale1:
	mov	eax, [esp + FPREM_MAIN_FPREM_SW]
	fxch
	fstp	st
	fld 	tbyte ptr[esp + FPREM_MAIN_DENOM_SAVE]
	fxch
	and 	eax, 04300h		; restore saved Q0, Q1, Q2
	sub 	esp, ENV_SIZE
	fnstenv	[esp]
	and 	[esp].STATUS_WORD, 0bcffh
	or  	[esp].STATUS_WORD, eax
	fldenv	[esp]
	add 	esp, ENV_SIZE
rem1_exit:
	pop	ecx
	pop	ebx
	pop	eax
	ret
_fprem1_common	ENDP

	PUBLIC	_adj_fprem1
_adj_fprem1	PROC	NEAR

	push	edx
    sub     esp, FPREM_STACK_SIZE
    fstp    tbyte ptr [FPREM_NUMER+esp]
    fstp    tbyte ptr [FPREM_DENOM+esp]
	mov 	edx, 0
; prem1_main_routine begin
    mov     eax,[FPREM_DENOM+6+esp]       ; exponent and high 16 bits of mantissa
    test    eax,07fff0000h          ; check for denormal
    jz      denormal1
	call	_fprem1_common
	add 	esp, FPREM_STACK_SIZE
	pop 	edx
	ret

denormal1:
    fld     tbyte ptr [FPREM_DENOM+esp]   ; load the denominator
    fld     tbyte ptr [FPREM_NUMER+esp]   ; load the numerator
    mov     eax, [FPREM_DENOM+esp]        ; test for whole mantissa == 0
    or      eax, [FPREM_DENOM+4+esp]      ; test for whole mantissa == 0
    jz      remainder1_hardware_ok_l ; denominator is zero
	fxch
	fstp	tbyte ptr[esp + FPREM_DENOM_SAVE]	; save org denominator
	fld 	tbyte ptr[esp + FPREM_DENOM]
	fxch
	or  	edx, 02h
;
; For this we need pc=80.  Also, mask exceptions so we don't take any
; denormal operand exceptions.  It is guaranteed that the descaling
; later on will take underflow, which is what the hardware would have done
; on a normal fprem.
;
    fnstcw  [FPREM_PREV_CW+esp]         ; save caller's control word
    mov     eax, [FPREM_PREV_CW+esp] 
    or      eax, 0033fh             	; mask exceptions, pc=80
    mov     [FPREM_PATCH_CW+esp], eax
    fldcw   [FPREM_PATCH_CW+esp]        ; mask exceptions & pc=80

; The denominator is a denormal.  For most numerators, scale both numerator
; and denominator to get rid of denormals.  Then execute the common code
; with the flag set to indicate that the result must be de-scaled.
; For large numerators this won't work because the scaling would cause
; overflow.  In this case we know the numerator is large, the denominator
; is small (denormal), so the exponent difference is also large.  This means
; the rem1_large code will be used and this code depends on the difference
; in exponents modulo 64.  Adding 64 to the denominators exponent
; doesn't change the modulo 64 difference.  So we can scale the denominator
; by 64, making it not denormal, and this won't effect the result.
;
; To start with, figure out if numerator is large

	mov 	eax, [esp + FPREM_NUMER + 8]	; load numerator exponent
	and 	eax, 7fffh		; isolate numerator exponent
	cmp 	eax, 7fbeh		; compare Nexp to Maxexp-64
	ja  	big_numer_rem1_de	; jif big numerator

; So the numerator is not large scale both numerator and denominator

	or  	edx, 1			; edx = 1, if denormal extended divisor
	fmul	qword ptr one_shl_64	; make numerator not denormal
	fstp	tbyte ptr[esp + FPREM_NUMER]
	fmul	qword ptr one_shl_64	; make denominator not denormal
	fstp	tbyte ptr[esp + FPREM_DENOM]
	jmp 	scaling_done1

; The numerator is large.  Scale only the denominator, which will not
; change the result which we know will be partial.  Set the scale flag
; to false.
big_numer_rem1_de:
; We must do this with pc=80 to avoid rounding to single/double.
; In this case we do not mask exceptions so that we will take
; denormal operand, as would the hardware.
	fnstcw  [FPREM_PREV_CW+esp]			; save caller's control word
	mov     eax, [FPREM_PREV_CW+esp] 
	or      eax, 00300h             	; pc=80
	mov     [FPREM_PATCH_CW+esp], eax
	fldcw   [FPREM_PATCH_CW+esp]		;  pc=80
	fstp	st							; Toss numerator
	fmul	qword ptr one_shl_64		; make denominator not denormal
	fstp	tbyte ptr[esp + FPREM_DENOM]
	
; Restore the control word which was fiddled to scale at 80-bit precision.
; Then call the common code.
scaling_done1:
	fldcw	[esp + FPREM_PREV_CW] 	; restore callers control word
	call	_fprem1_common
	add 	esp, FPREM_STACK_SIZE
	pop 	edx
	ret
	
remainder1_hardware_ok_l:
    fprem              		; and finally do a remainder 
    add     esp, FPREM_STACK_SIZE
	pop	edx
    ret
_adj_fprem1	ENDP

	PUBLIC	_safe_fprem
_safe_fprem	PROC	NEAR

    call _adj_fprem
    ret

_safe_fprem	ENDP

	PUBLIC	_safe_fprem1
_safe_fprem1	PROC	NEAR

    call _adj_fprem1
    ret

_safe_fprem1	ENDP



;;; _adj_fpatan - FPATAN FIX
;;
;;	Dummy entry point


	PUBLIC	_adj_fpatan
_adj_fpatan	PROC	NEAR

	fpatan
	ret

_adj_fpatan	ENDP


;;; _adj_fptan - FPTAN FIX
;;
;;	Dummy entry point


	PUBLIC	_adj_fptan
_adj_fptan	PROC	NEAR

	fptan
	ret

_adj_fptan	ENDP


	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\ceil_pentium4.asm ===
; file: ceil_wmt.asm

; Copyright  (C) 1985-2000 Intel Corporation.
;
; The information and source code contained herein is the exclusive property
; of Intel Corporation and may not be disclosed, examined, or reproduced in
; whole or in part without explicit written authorization from the Company.
;
; Implemented in VNIIEF-STL, july 2000

; double ceil (double x)
;
; Willamette specific version (MASM 6.15 required)
;
; Description:
;  The ceil function returns the smallest integer value not less than x,
;  expressed as a (double-precision) floating-point number.
;
; Special cases:
;  ceil(NaN) = that NaN
;  ceil(INF) = that INF
;  ceil(0) = that 0
;
; Accuracy:
;  The result is always exact.

.xlist
	include cruntime.inc
.list

EXTRN C __libm_error_support : NEAR  

_FUNC_     equ	<ceil>
_FUNC_DEF_ equ	<_ceil_default>
_FUNC_P4_  equ	<_ceil_pentium4>
_FUNC_DEF_EXTERN_ equ 1
	include	disp_pentium4.inc

      .const
      ALIGN 16

;-- 16x-aligned data --------------------------------------------------------

_One  DQ 03ff0000000000000H,03ff0000000000000H
_Bns  DQ 00000000000000433H,00000000000000433H
_Zero DQ 00000000000000000H,00000000000000000H
_S    DQ 000000000000007ffH,00000000000000000H

;-- 8x-aligned data ---------------------------------------------------------

_NegZero DQ 08000000000000000H

      codeseg
      ALIGN 16

; double ceil (double x);

; Stack frame locations

ceil_x TEXTEQU <esp+4>
XMMWORD TEXTEQU <OWORD>

PUBLIC _ceil_pentium4
_ceil_pentium4 PROC NEAR
    movq      xmm0, QWORD PTR [ceil_x]           ;
    movapd    xmm2, XMMWORD PTR _Bns             ;
    movapd    xmm1, xmm0                         ;
    movapd    xmm7, xmm0                         ;
    psrlq     xmm0, 52                           ; exp(x)
    movd      eax, xmm0                          ;
    andpd     xmm0, XMMWORD PTR _S               ;
    psubd     xmm2, xmm0                         ;
    psrlq     xmm1, xmm2                         ;

    test      eax, 0800H                         ;
    je        SHORT positive                     ;
    cmp       eax, 0bffH                         ;
    jl        SHORT ret_zero                     ;
    psllq     xmm1, xmm2                         ;
    cmp       eax, 0c32H                         ;
    jg        SHORT return_x                     ;
    movq      QWORD PTR [ceil_x], xmm1           ;
    fld       QWORD PTR [ceil_x]                 ;
    ret                                          ;

return_x:

    ucomisd   xmm7, xmm7
    jnp       not_nan

    mov       edx, 1004
    ;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
    sub       esp, 16
    mov       DWORD PTR [esp+12],edx
    mov       edx, esp
    add       edx, 16+4
    mov       DWORD PTR [esp+8],edx
    mov       DWORD PTR [esp+4],edx
    mov       DWORD PTR [esp],edx
    call      NEAR PTR __libm_error_support
    add       esp, 16

not_nan:
    fld       QWORD PTR [ceil_x]                 ;
    ret                                          ;

positive:

    movq      xmm0, QWORD PTR [ceil_x]           ;
    psllq     xmm1, xmm2                         ;
    movapd    xmm3, xmm0                         ;
    cmppd     xmm0, xmm1, 6                      ; !<=

    cmp       eax, 03ffH                         ;
    jl        SHORT ret_one                      ;
    cmp       eax, 0432H                         ;
    jg        SHORT return_x                     ;

    andpd     xmm0, XMMWORD PTR _One             ;
    addsd     xmm1, xmm0                         ;
    movq      QWORD PTR [ceil_x], xmm1           ;
    fld       QWORD PTR [ceil_x]                 ;
    ret                                          ;

ret_zero:

    fld       QWORD PTR _NegZero                 ;
    ret                                          ;

ret_one:

    cmppd     xmm3, XMMWORD PTR _Zero, 6         ; !<=
    andpd     xmm3, XMMWORD PTR _One             ;
    movq      QWORD PTR [ceil_x], xmm3           ;
    fld       QWORD PTR [ceil_x]                 ;
    ret                                          ;

_ceil_pentium4 ENDP

    END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\common.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;
;*******************************************************************************

.xlist
        include cruntime.inc
        include elem87.inc
.list
              .const
staticQ One,                    03FF0000000000000R
globalW _DEFAULT_CW_in_mem      027fh
globalT _pi_by_2_to_61          0403ec90fdaa22168c235R        ; (2**61) * pi
staticQ DblMax,                 07fefffffffffffffR
staticQ DblMin,                 00010000000000000R
staticQ IeeeAdjO,               0c098000000000000R
staticQ IeeeAdjU,               04098000000000000R
staticQ _infinity,              07ff0000000000000R
staticQ _zero,                  00000000000000000R

        CODESEG

extrn   _startOneArgErrorHandling:near
extrn   _startTwoArgErrorHandling:near

;***********************************************************
;
;                           _twoToTOS
;
;***********************************************************
; Recieves:
;        TOS is not NaN
; Retunns:
;        2^TOS
; Note:
;        uses 3 entries of FPU stack

_twoToTOS        proc
        fld     st(0)                         ; duplicate stack top
        frndint                               ; N = round(y)
        fsubr   st(1), st
        fxch
        fchs                                  ; g = y - N where abs(g) < 1
        f2xm1                                 ; 2**g - 1
        fld1
        fadd                                  ; 2**g
        fscale                                ; (2**g) * (2**N) - gives 2**y
        fstp    st(1)
        ret                                   ; pop extra stuff from fp stack
_twoToTOS        endp


;***********************************************************
;
;                           _load_CW
;
;***********************************************************
;        receives current control word on stack
;        and it's known that it differs from default
; Purpose:
;       load default CW, but take precision from current CW (bits 8 and 9)
; Note:
;       value of edx is destroyed
;
_load_CW        proc
        mov     edx,[esp+4]
        and     edx,0300H                     ; all bits except precision are zero
        or      edx,DEFAULT_CW_without_precision
        mov     [esp+6],dx                    ; use 2 free bytes in stack
        fldcw   [esp+6]
        ret
_load_CW        endp

;***********************************************************
;
;                           _convertTOStoQNaN
;
;***********************************************************
; Recieves:
;        TOS is QNaN or SNaN
;        eax is high dword of TOS
; Retunns:
;        if TOS=QNaN
;            eax=DOMAIN_QNAN
;        else (TOS=SNaN)
;            eax=DOMAIN
;        TOS=QNaN

_convertTOStoQNaN  proc
        test    eax, 00080000H                ; test weather arg is QNaN or SNaN
        jz      tosIsSNaN
        mov     eax,DOMAIN_QNAN               ; TOS is QNaN
        ret
tosIsSNaN:
        fadd    [One]                         ; convert SNaN to QNan
        mov     eax,DOMAIN                    ; TOS was SNaN
        ret                                   ; _cdecl return

_convertTOStoQNaN  endp



;***********************************************************
;
;                           _fload_withFB
;
;***********************************************************
; Load arg in the fp stack without raising an exception if the argument
; is a signaling NaN
; In other words, when arg is 53-bit SNaN convert it to 64-bit SNaN
;
; edx points to argument (in double precision)
; return value:
;   if we have normal number:
;        eax=exponent
;        Zero flag is 0
;   if we have special number:
;        eax=high dword
;        Zero flag is 1

_fload_withFB   proc                          ; load with feed back
        mov     eax, [edx+4]                  ; get exponent field
        and     eax, 07ff00000h
        cmp     eax, 07ff00000h               ; check for special exponent
        je      fpload_special
        fld     qword ptr[edx]                ; ZF=0
        ret                                   ; _cdecl return

; have special argument (NaN or INF)
fpload_special:                               ; convert to long double
        mov     eax,[edx+4]                   ; high dword of double
        sub     esp,LDBLSIZE
        or      eax, 7fff0000h                ; preserve sign, set max long double exp
        mov     [esp+6],eax                   ; store sign and power
        mov     eax,[edx+4]                   ; low dword of double
        mov     ecx,[edx]
        shld    eax,ecx,11
        shl     ecx,11

        mov     [esp+4],eax
        mov     [esp],ecx
        fld     tbyte ptr [esp]
        add     esp,LDBLSIZE
        test    eax,0                         ; ZF=1
        mov     eax,[edx+4]                   ; high dword of double

        ret                                   ; _cdecl return
_fload_withFB  endp

;***********************************************************
;
;                   _checkTOS_withFB
;
;***********************************************************
; Test first argument on INTEGER stack and set registers and flags exactly like _fload_withFB
;
; we have on stack : ret_value(4 bytes), arg1(8 bytes)
; return value:
;   if we have normal number:
;        eax=exponent
;        Zero flag is 0
;   if we have special number:
;        eax=high dword
;        Zero flag is 1

_checkTOS_withFB        proc
        mov     eax, [esp+8]                  ; get high dword
        and     eax,07ff00000h
        cmp     eax,07ff00000h                ; check for special exponent
                                              ; and set ZF
        je      special_exp
        ret                                   ; _cdecl return
special_exp:
        mov     eax, [esp+8]                  ; get exponent field
        ret                                   ; _cdecl return

_checkTOS_withFB  endp


;***********************************************************
;
;                        _fast_exit
;
;***********************************************************
;   called after execution of each math function (sin,cos, ....),
;         and if __fastflag!=0
;
_fast_exit      proc
        cmp     word ptr[esp],default_CW
        je      fast_exit_CW_is_restored
        fldcw   [esp]
fast_exit_CW_is_restored:
        pop     edx                           ; remove saved CW from stack
        ret                                   ; _cdecl return
_fast_exit      endp


;***********************************************************
;
;                        _math_exit
;
;***********************************************************
; called after execution of each math function (sin,cos, ....)
; and if __fastflag=0.
; The purpose is to check inexact exception.
; ecx        points to function name
; edx   function id (for example OP_LOG)

_math_exit      proc
        mov     ax,word ptr[esp]
        cmp     ax,default_CW
        je      CW_is_restored                ; we assume here that in default CW inexact
                                              ; exception is masked
        and     ax,20h                        ; test if inexact exception is masked
        jz      restore_CW
        fstsw   ax
        and     ax,20h
        jz      restore_CW
        mov     eax,INEXACT
        call    _startOneArgErrorHandling
        pop     edx                           ; remove saved CW from stack
        ret
restore_CW:
        fldcw   [esp]
CW_is_restored:
        pop     edx                           ; remove saved CW from stack
        ret                                   ; _cdecl return
_math_exit      endp


;***********************************************************
;
;                        _check_overflow_exit
;
;***********************************************************
;
_check_overflow_exit        proc
        sub     esp,DBLSIZE                   ; prepare place for argument
        fst     qword ptr[esp]
        mov     eax,[esp+4]                   ; eax=high dword
        add     esp,DBLSIZE
        and     eax,7ff00000H
        jmp     _check_overflow_start
_check_overflow_exit        endp


;***********************************************************
;
;                        _check_range_exit
;
;***********************************************************
; called after execution of math functions, which may generate
; overflow/underflow, and if __fastflag=0.
; used in exp() and pow() functions
; The purpose is to check inexact overflow/underflow and inexact exception
; ecx        points to function name
; edx   function id (for example OP_EXP)

_check_range_exit        proc
        sub     esp,DBLSIZE                   ; prepare place for argument
        fst     qword ptr[esp]
        mov     eax,[esp+4]                   ; eax=high dword
        add     esp,DBLSIZE
        and     eax,7ff00000H
        jz      haveunderflow
_check_overflow_start        label        proc
        cmp     eax,7ff00000H
        jz      haveoverflow

; check INEXACT(precision) exception
        mov     ax,word ptr[esp]             ; saved CW
        cmp     ax,default_CW
        je      CW_is_restored               ; we assume here that in default CW inexact
                                              ; exception is masked
        and     ax,20h                       ; test if inexact exception is masked
        jnz     restore_CW
        fstsw   ax
        and     ax,20h
        jz      restore_CW
        mov     eax,INEXACT
have_error:
        cmp     edx,OP_POW
        je      have_error_in_pow
        call    _startOneArgErrorHandling
        pop     edx                          ; remove saved CW from stack
        ret
have_error_in_pow:
        call    _startTwoArgErrorHandling
        pop     edx                          ; remove saved CW from stack
        ret

restore_CW:
        fldcw   [esp]
CW_is_restored:
        pop     edx                           ; remove saved CW from stack
        ret                                   ; _cdecl return

; this code is taken from previous version, to receive
; exactly the same result as before. But we may simplify it...
haveunderflow:                                ; underflow is detected
        fld     IeeeAdjU
        fxch
        fscale
        fstp    st(1)
        fld     st(0)
        fabs
        fcomp   [DblMin]
        fstsw   ax
        sahf
        mov     eax,UNDERFLOW
        JSAE    have_error
        fmul    [_zero]
        jmp     short have_error

haveoverflow:                                 ; overflow is detected
        fld     IeeeAdjO
        fxch
        fscale
        fstp    st(1)
        fld     st(0)
        fabs
        fcomp   [DblMax]
        fstsw   ax
        sahf
        mov     eax,OVERFLOW
        JSBE    have_error
        fmul    [_infinity]
        jmp     short have_error

_check_range_exit        endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\cos.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;
;*******************************************************************************

_COS_ equ 1
include trig.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\cpu_disp.c ===
/**
*** Copyright  (C) 1985-1998 Intel Corporation.
***
*** The information and source code contained herein is the exclusive property
*** of Intel Corporation and may not be disclosed, examined, or
*** reproduced in whole or in part without explicit written authorization from
*** the Company.
***
*** static char sccs_id[] = "@(#)cpu_disp.c     1.9 06/06/00 14:08:14";
***
**/

#include <sect_attribs.h>
#include <cruntime.h>
#include <internal.h>
#undef leave

#define CPU_HAS_SSE2(x)   (((x) & (1 << 26)) != 0)

#ifdef _MSC_VER

int __sse2_available_init(void);

#pragma data_seg(".CRT$XIC")
_CRTALLOC(".CRT$XIC") static _PIFV pinit = __sse2_available_init;

#pragma data_seg()

#endif /* _MSC_VER */

int __sse2_available;
int __use_sse2_mathfcns;

static int
has_osfxsr_set()
{
    int ret = 0;

    __try {
        __asm movapd xmm0, xmm1;
        ret = 1;
    }
    __except(1) {
    }

    return ret;
}

__declspec(naked) int __sse2_available_init()
{
    int cpu_feature;

    __asm
    {
        push    ebp
        mov     ebp, esp
        sub     esp, __LOCAL_SIZE
        push    ebx
        push    edi
        push    esi

        pushfd                  /* if we can't write to bit 21  */
        pop     eax             /* of the eflags, then we don't */
        mov     ecx, eax        /* have a cpuid instruction.    */
        xor     eax, 0x200000
        push    eax
        popfd
        pushfd
        pop     edx
        sub     edx, ecx
        je      DONE            /* CPUID not available */

        push    ecx             /* restore eflags */
        popfd
        mov     eax, 1
        cpuid
DONE :
        mov     cpu_feature, edx
    }

    __use_sse2_mathfcns = __sse2_available = 0;

    if (CPU_HAS_SSE2(cpu_feature)) {
        if (has_osfxsr_set()) {
            __sse2_available = 1;
#if !defined(_SYSCRT)
            /*
             * The VC++ CRT will automatically enable the SSE2 implementations
             * when possible.  The system CRT will not, so existing apps don't
             * start seeing different results on a Pentium4.
             */
            __use_sse2_mathfcns = 1;
#endif
        }
    }

    __asm
    {
        xor     eax, eax
        pop     esi
        pop     edi
        pop     ebx
        leave
        ret
    }
}

_CRTIMP int __cdecl _set_SSE2_enable(int flag)
{
    return __use_sse2_mathfcns = flag ? __sse2_available : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\debug.c ===
/*****************************************************************/
/*            Copyright (c) 1998 Intel Corporation               */        
/*                                                               */
/* All rights reserved.  No part of this program or publication  */
/* may be reproduced, transmitted, transcribed, stored in a      */
/* retrieval system, or translated into any language or computer */
/* language, in any form or by any means, electronic, mechanical */
/* magnetic, optical, chemical, manual, or otherwise, without    */
/* the prior written permission of Intel Corporation.            */
/*                                                               */
/*****************************************************************/
/*          INTEL CORPORATION PROPRIETARY INFORMATION            */
/*                                                               */
/*                                                               */
/*****************************************************************/

/*++

  Module Name:

    debug.c

Abstract:

    This module provides handy routines for debugging

Author:

Revision History:

--*/


#include <wtypes.h>
#include <stdio.h>
#include <conio.h>
#include "fpieee.h"
#include "xmmi_types.h"
#include "temp_context.h"
#include "filter.h"
#include "debug.h"


ULONG   DebugFlag = 0;
ULONG   Console = 0;
ULONG   DebugImm8 = 0;
ULONG   NotOk = 0;

#define DUMP_HEXL(pxmmi, num)    { \
    PRINTF(("in Hex:  ")); \
    for (i = 0; i < num; i++) { \
        PRINTF(("[%d] %x ", i, pxmmi->u.ul[i])); \
    } \
    PRINTF(("\n")); }

#define DUMP_FS(pxmmi, num)    { \
    PRINTF(("in Fflt: ")); \
    for (i = 0; i < num; i++) { \
        PRINTF(("[%d] %f ", i, pxmmi->u.fs[i])); \
    } \
    PRINTF(("\n")); }

#define DUMP_HEXLL(pxmmi, num)    { \
    PRINTF(("in Hex:  ")); \
    for (i = 0; i < num; i++) { \
        PRINTF(("[%d] %I64x ", i, pxmmi->u.ull[i])); \
    } \
    PRINTF(("\n")); }

#define DUMP_DS(pxmmi, num)    { \
    PRINTF(("in Dflt: ")); \
    for (i = 0; i < num; i++) { \
        PRINTF(("[%d] %e ", i, pxmmi->u.fd[i])); \
    } \
    PRINTF(("\n")); }


void
print_Rounding(PXMMI_ENV XmmiEnv) {

  if (XmmiEnv->Ieee->RoundingMode == _FpRoundNearest) {
      PRINTF(("XmmiEnv->Ieee->RoundingMode = _FpRoundNearest\n"));
  } else {
      if (XmmiEnv->Ieee->RoundingMode == _FpRoundMinusInfinity) { 
          PRINTF(("XmmiEnv->Ieee->RoundingMode = _FpRoundMinusInfinity\n"));
      } else {
          if (XmmiEnv->Ieee->RoundingMode == _FpRoundPlusInfinity) {
              PRINTF(("XmmiEnv->Ieee->RoundingMode = _FpRoundPlusInfinity\n"));
          } else {
              if (XmmiEnv->Ieee->RoundingMode == _FpRoundChopped) {
                  PRINTF(("XmmiEnv->Ieee->RoundingMode = _FpRoundChopped\n"));
              } else {
                  PRINTF(("XmmiEnv->Ieee->RoundingMode = UNKNOWN\n"));
              }
          }
      }
  }

}

void
print_Precision(PXMMI_ENV XmmiEnv) {

  if (XmmiEnv->Ieee->Precision == _FpPrecision24) {
      PRINTF(("XmmiEnv->Ieee->Precision = _FpPrecision24\n"));
  } else {
      if (XmmiEnv->Ieee->Precision == _FpPrecision53) {
          PRINTF(("XmmiEnv->Ieee->Precision = _FpPrecision53\n"));
      } else {
          if (XmmiEnv->Ieee->Precision == _FpPrecisionFull) {
              PRINTF(("XmmiEnv->Ieee->Precision = _FpPrecisionFull\n"));
          } else {
              PRINTF(("XmmiEnv->Ieee->Precision = INCORRECT\n"));
          }
      }
  }

}

void
print_CauseEnable(PXMMI_ENV XmmiEnv) {

  PRINTF(("XmmiEmv->Ieee->Cause:     P=%x U=%x O=%x Z=%x I=%x\n",
      XmmiEnv->Ieee->Cause.Inexact, XmmiEnv->Ieee->Cause.Underflow,
      XmmiEnv->Ieee->Cause.Overflow, XmmiEnv->Ieee->Cause.ZeroDivide,
      XmmiEnv->Ieee->Cause.InvalidOperation));
  PRINTF(("XmmiEnv->Ieee->Enable: P=%x U=%x O=%x Z=%x I=%x\n",
      XmmiEnv->Ieee->Enable.Inexact, XmmiEnv->Ieee->Enable.Underflow,
      XmmiEnv->Ieee->Enable.Overflow, XmmiEnv->Ieee->Enable.ZeroDivide,
      XmmiEnv->Ieee->Enable.InvalidOperation));

}

void
print_Status(PXMMI_ENV XmmiEnv) {

  PRINTF(("XmmiEnv->Ieee->Status: P=%x U=%x O=%x Z=%x I=%x\n",
      XmmiEnv->Ieee->Status.Inexact, XmmiEnv->Ieee->Status.Underflow,
      XmmiEnv->Ieee->Status.Overflow, XmmiEnv->Ieee->Status.ZeroDivide,
      XmmiEnv->Ieee->Status.InvalidOperation));

}

void
print_Operations(PXMMI_ENV XmmiEnv) {

    switch (XmmiEnv->Ieee->Operation) {
    case OP_ADDPS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_ADDPS\n"));
      break;
    case OP_ADDSS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_ADDSS\n"));
      break;
    case OP_SUBPS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SUBPS\n"));
      break;
    case OP_SUBSS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SUBSS\n"));
      break;
    case OP_MULPS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MULPS\n"));
      break;
    case OP_MULSS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MULSS\n"));
      break;
    case OP_DIVPS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_DIVPS\n"));
      break;
    case OP_DIVSS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_DIVSS\n"));
      break;
    case OP_MAXPS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MAXPS\n"));
      break;
    case OP_MAXSS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MAXSS\n"));
      break;
    case OP_MINPS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MINPS\n"));
      break;
    case OP_MINSS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MINSS\n"));
      break;
    case OP_CVTPI2PS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTPI2PS\n"));
      break;
    case OP_CVTSI2SS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTSI2SS\n"));
      break;
    case OP_CVTPS2PI:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTPS2PI\n"));
      break;
    case OP_CVTSS2SI:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTSS2SI\n"));
      break;
    case OP_CVTTPS2PI:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTTPS2PI\n"));
      break;
    case OP_CVTTSS2SI:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTTSS2SI\n"));
      break;
    case OP_COMISS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_COMISS\n"));
      break;
    case OP_UCOMISS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_UCOMISS\n"));
      break;
    case OP_CMPPS:
    case OP_CMPSS: 
    case OP_CMPPD:  
    case OP_CMPSD:    
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CMPPS/CMPSS/CMPPD/CMPSD "));

      switch (XmmiEnv->Imm8 & 0x07) {

        case IMM8_EQ:
          PRINTF(("EQ\n"));
          break;
        case IMM8_UNORD:
          PRINTF(("UNORD\n"));
          break;
        case IMM8_NEQ:
          PRINTF(("NEQ\n"));
          break;
        case IMM8_ORD:
          PRINTF(("ORD\n"));
          break;
        case IMM8_LT:
          PRINTF(("LT\n"));
          break;
        case IMM8_LE:
          PRINTF(("LE\n"));
          break;
        case IMM8_NLT:
          PRINTF(("NLT\n"));
          break;
        case IMM8_NLE:
          PRINTF(("NLE\n"));
          break;
        default:
          ; // will never occur

      }
      break;
    case OP_SQRTPS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SQRTPS\n"));
      break;
    case OP_SQRTSS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SQRTSS\n"));
      break;
    case OP_ADDPD:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_ADDPD\n"));
      break;
    case OP_ADDSD:   
      PRINTF(("XmmiEnv->Ieee->Operation = OP_ADDSD\n"));
      break;        
    case OP_SUBPD:    
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SUBPD\n"));
      break;        
    case OP_SUBSD:   
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SUBSD\n"));
      break;        
    case OP_MULPD: 
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MULPD\n"));
      break;
    case OP_MULSD:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MULSD\n"));
      break;        
    case OP_DIVPD:    
      PRINTF(("XmmiEnv->Ieee->Operation = OP_DIVPD\n"));
      break;
    case OP_DIVSD:   
      PRINTF(("XmmiEnv->Ieee->Operation = OP_DIVSD\n"));
      break;        
    case OP_SQRTPD:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SQRTPD\n"));
      break;       
    case OP_SQRTSD: 
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SQRTSD\n"));
      break;        
    case OP_MAXPD:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MAXPD\n"));
      break;        
    case OP_MAXSD:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MAXSD\n"));
      break;        
    case OP_MINPD: 
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MINPD\n"));
      break;        
    case OP_MINSD:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MINSD\n"));
      break;                
    case OP_COMISD:   
      PRINTF(("XmmiEnv->Ieee->Operation = OP_COMISD\n"));
      break;        
    case OP_UCOMISD:   
      PRINTF(("XmmiEnv->Ieee->Operation = OP_UCOMISD\n"));
      break;
    case OP_CVTPD2PI:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTPD2PI\n"));
      break;
    case OP_CVTSD2SI:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTSD2SI\n"));
      break;
    case OP_CVTTPD2PI: 
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTTPD2PI\n"));
      break;
    case OP_CVTTSD2SI: 
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTTSD2SI\n"));
      break;
    case OP_CVTPS2PD:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTPS2PD\n"));
      break;        
    case OP_CVTSS2SD: 
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTSS2SD\n"));
      break;        
    case OP_CVTPD2PS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTPD2PS\n"));
      break;        
    case OP_CVTSD2SS:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTSD2SS\n"));
      break;        
    case OP_CVTDQ2PS:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTDQ2PS\n"));
      break;
    case OP_CVTTPS2DQ: 
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTTPS2DQ\n"));
      break;
    case OP_CVTPS2DQ:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTPS2DQ\n"));
      break;
    case OP_CVTPD2DQ:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTPD2DQ\n"));
      break;        
    case OP_CVTTPD2DQ:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTTPD2DQ\n"));
      break;
        
    default:
      PRINTF(("XmmiEnv->Ieee->Operation %d = UNKNOWN\n",
          XmmiEnv->Ieee->Operation));
    }
}

void
print_Operand1(PXMMI_ENV XmmiEnv) {

    PRINTF(("XmmiEnv->Ieee->Operand1.OperandValid = %x\n",
        XmmiEnv->Ieee->Operand1.OperandValid));

    if (!XmmiEnv->Ieee->Operand1.OperandValid) return;

    if (XmmiEnv->Ieee->Operand1.Format == _FpFormatFp32) {
        PRINTF(("XmmiEnv->Ieee->Operand1.Format = _FpFormatFp32\n"));
        PRINTF(("XmmiEnv->Ieee->Operand1.Value.Fp32Value = %f = %x\n",
            (float)XmmiEnv->Ieee->Operand1.Value.Fp32Value,
            XmmiEnv->Ieee->Operand1.Value.U32Value));
    } else if (XmmiEnv->Ieee->Operand1.Format == _FpFormatU32) {
        PRINTF(("XmmiEnv->Ieee->Operand1.Format = _FpFormatU32\n"));
        PRINTF(("XmmiEnv->Ieee->Operand1.Value.U32Value = %d = %x\n",
            XmmiEnv->Ieee->Operand1.Value.U32Value,
            XmmiEnv->Ieee->Operand1.Value.U32Value));
    } else if (XmmiEnv->Ieee->Operand1.Format == _FpFormatI32) {
        PRINTF(("XmmiEnv->Ieee->Operand1.Format = _FpFormatI32\n"));
        PRINTF(("XmmiEnv->Ieee->Operand1.Value.I32Value = %d = %x\n",
            XmmiEnv->Ieee->Operand1.Value.I32Value,
            XmmiEnv->Ieee->Operand1.Value.U32Value));
    } else if (XmmiEnv->Ieee->Operand1.Format == _FpFormatFp64) {
        PRINTF(("XmmiEnv->Ieee->Operand1.Format = _FpFormatFp64\n"));
        PRINTF(("XmmiEnv->Ieee->Operand1.Value.Fp64Value = %e = %I64x\n",
            (double)XmmiEnv->Ieee->Operand1.Value.Fp64Value,
            XmmiEnv->Ieee->Operand1.Value.U64Value));
    } else {
        PRINTF(("XmmiEnv->Ieee->Operand1.Format = INCORRECT\n"));
    }

}

void
print_Operand2(PXMMI_ENV XmmiEnv) {

    PRINTF(("XmmiEnv->Ieee->Operand2.OperandValid = %x\n",
        XmmiEnv->Ieee->Operand2.OperandValid));

    if (!XmmiEnv->Ieee->Operand2.OperandValid) return;

    if (XmmiEnv->Ieee->Operand2.Format == _FpFormatFp32) {
        PRINTF(("XmmiEnv->Ieee->Operand2.Format = _FpFormatFp32\n"));
        PRINTF(("XmmiEnv->Ieee->Operand2.Value.Fp32Value = %f = %x\n",
            (float)XmmiEnv->Ieee->Operand2.Value.Fp32Value,
            XmmiEnv->Ieee->Operand2.Value.U32Value));
    } else if (XmmiEnv->Ieee->Operand2.Format == _FpFormatU32) {
        PRINTF(("XmmiEnv->Ieee->Operand2.Format = _FpFormatU32\n"));
        PRINTF(("XmmiEnv->Ieee->Operand2.Value.U32Value = %d = %x\n",
            XmmiEnv->Ieee->Operand2.Value.U32Value,
            XmmiEnv->Ieee->Operand2.Value.U32Value));
    } else if (XmmiEnv->Ieee->Operand2.Format == _FpFormatI32) {
        PRINTF(("XmmiEnv->Ieee->Operand2.Format = _FpFormatI32\n"));
        PRINTF(("XmmiEnv->Ieee->Operand2.Value.I32Value = %d = %x\n",
            XmmiEnv->Ieee->Operand2.Value.I32Value,
            XmmiEnv->Ieee->Operand2.Value.U32Value));
    } else if (XmmiEnv->Ieee->Operand2.Format == _FpFormatFp64) {
        PRINTF(("XmmiEnv->Ieee->Operand2.Format = _FpFormatFp64\n"));
        PRINTF(("XmmiEnv->Ieee->Operand2.Value.Fp64Value = %e = %I64x\n",
            (double)XmmiEnv->Ieee->Operand2.Value.Fp64Value,
            XmmiEnv->Ieee->Operand2.Value.U64Value));
    } else {
        PRINTF(("XmmiEnv->Ieee->Operand2.Format = INCORRECT\n"));
    }
 
}

void
print_Result(PXMMI_ENV XmmiEnv, BOOL Exception) {

    PRINTF(("XmmiEnv->Ieee->Result.OperandValid = %x\n",
        XmmiEnv->Ieee->Result.OperandValid));

    if (XmmiEnv->Ieee->Result.OperandValid) {
        if (XmmiEnv->Ieee->Result.Format == _FpFormatFp32) {
            PRINTF(("XmmiEnv->Ieee->Result.Format = _FpFormatFp32\n")); 
            PRINTF(("XmmiEnv->Ieee->Result.Value.Fp32Value = %f = %x\n",
                (float)XmmiEnv->Ieee->Result.Value.Fp32Value,
                XmmiEnv->Ieee->Result.Value.U32Value));
        } else if (XmmiEnv->Ieee->Result.Format == _FpFormatU32) {
            PRINTF(("XmmiEnv->Ieee->Result.Format = _FpFormatU32\n")); 
            PRINTF(("XmmiEnv->Ieee->Result.Value.U32Value = %d = %x\n",
                XmmiEnv->Ieee->Result.Value.U32Value,
                XmmiEnv->Ieee->Result.Value.U32Value));
        } else if (XmmiEnv->Ieee->Result.Format == _FpFormatI32) {
            PRINTF(("XmmiEnv->Ieee->Result.Format = _FpFormatI32\n")); 
            PRINTF(("XmmiEnv->Ieee->Result.Value.I32Value = %d = %x\n",
                XmmiEnv->Ieee->Result.Value.I32Value,
                XmmiEnv->Ieee->Result.Value.U32Value));
        } else if (XmmiEnv->Ieee->Result.Format == _FpFormatFp64) {
            PRINTF(("XmmiEnv->Ieee->Result.Format = _FpFormatFp64\n"));
            PRINTF(("XmmiEnv->Ieee->Result.Value.Fp64Value = %e = %I64x\n",
                (double)XmmiEnv->Ieee->Result.Value.Fp64Value,
                XmmiEnv->Ieee->Result.Value.U64Value));
        } else {
            PRINTF(("XmmiEnv->Ieee->Result.Format = INCORRECT\n"));
        }
    }

    if (!Exception) {
        if (XmmiEnv->Ieee->Operation == _FpCodeCompare) {
            PRINTF(("XmmiEnv->EFlags = %x\n", XmmiEnv->EFlags)); 
        }
    }

}


void print_FPIEEE_RECORD_EXCEPTION (PXMMI_ENV XmmiEnv) {

  // print the FP IEEE record info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (EXCEPTION):\n"));

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_CauseEnable(XmmiEnv);
  print_Status(XmmiEnv);
  print_Result(XmmiEnv, TRUE);

  PRINTF(("\n"));

}


void print_FPIEEE_RECORD_NO_EXCEPTION (PXMMI_ENV XmmiEnv) {

  // print the FP IEEE record result info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (NO EXCEPTION):\n"));

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_Status(XmmiEnv);
  print_Result(XmmiEnv, FALSE);

  PRINTF(("\n"));

}

void print_FPIEEE_RECORD (PXMMI_ENV XmmiEnv) {
    

  // print input values
  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  if (XmmiEnv->Rc == _FpRoundNearest) {
      PRINTF(("XmmiEnv->Rc = _FpRoundNearest\n"));
  } else {
      if (XmmiEnv->Rc == _FpRoundMinusInfinity) { 
          PRINTF(("XmmiEnv->Rc = _FpRoundMinusInfinity\n"));
      } else {
          if (XmmiEnv->Rc == _FpRoundPlusInfinity) {
              PRINTF(("XmmiEnv->Rc = _FpRoundPlusInfinity\n"));
          } else {
              if (XmmiEnv->Rc == _FpRoundChopped) {
                  PRINTF(("XmmiEnv->Rc = _FpRoundChopped\n"));
              } else {
                  PRINTF(("XmmiEnv->Rc = UNKNOWN\n"));
              }
          }
      }
  }

  if (XmmiEnv->Precision == _FpPrecision24) {
      PRINTF(("XmmiEnv->Precision = _FpPrecision24\n"));
  } else {
      if (XmmiEnv->Precision == _FpPrecision53) {
          PRINTF(("XmmiEnv->Precision = _FpPrecision53\n"));
      } else {
          if (XmmiEnv->Precision == _FpPrecisionFull) {
              PRINTF(("XmmiEnv->Precision = _FpPrecisionFull\n"));
          } else {
              PRINTF(("XmmiEnv->Precision = INCORRECT\n"));
          }
      }
  }

  print_Operations(XmmiEnv);
  print_Operand1(XmmiEnv);
  print_Operand2(XmmiEnv);

}


void
dump_DataXMMI2(PTEMP_EXCEPTION_POINTERS p)
{

    PEXCEPTION_RECORD exc;
    PTEMP_CONTEXT pctxt;
    PFLOATING_EXTENDED_SAVE_AREA pExtendedArea;
    PXMMI_AREA XmmiArea;
    PX87_AREA X87Area;
    PXMMI128 xmmi128;
    PXMMI128 reg0, reg1, reg2, reg3, reg4, reg5, reg6, reg7;
    PMMX64 mmx0, mmx1, mmx2, mmx3, mmx4, mmx5, mmx6, mmx7;
    ULONG i;

    exc = p->ExceptionRecord;
    pctxt = p->ContextRecord;
    pExtendedArea = (PFLOATING_EXTENDED_SAVE_AREA) &pctxt->ExtendedRegisters[0];
    XmmiArea = (PXMMI_AREA) &pExtendedArea->XMMIRegisterArea[0];
    X87Area = (PX87_AREA) &pExtendedArea->X87RegisterArea[0];
    
    reg0 = (PXMMI128) &XmmiArea->Xmmi[0];
    reg1 = (PXMMI128) &XmmiArea->Xmmi[1]; 
    reg2 = (PXMMI128) &XmmiArea->Xmmi[2];
    reg3 = (PXMMI128) &XmmiArea->Xmmi[3]; 
    reg4 = (PXMMI128) &XmmiArea->Xmmi[4];
    reg5 = (PXMMI128) &XmmiArea->Xmmi[5]; 
    reg6 = (PXMMI128) &XmmiArea->Xmmi[6];
    reg7 = (PXMMI128) &XmmiArea->Xmmi[7]; 

    mmx0 = (PMMX64) &X87Area->Mm[0].Mmx;
    mmx1 = (PMMX64) &X87Area->Mm[1].Mmx;
    mmx2 = (PMMX64) &X87Area->Mm[2].Mmx;
    mmx3 = (PMMX64) &X87Area->Mm[3].Mmx;
    mmx4 = (PMMX64) &X87Area->Mm[4].Mmx;
    mmx5 = (PMMX64) &X87Area->Mm[5].Mmx;
    mmx6 = (PMMX64) &X87Area->Mm[6].Mmx;
    mmx7 = (PMMX64) &X87Area->Mm[7].Mmx;

    xmmi128 = (PXMMI128) pExtendedArea->DataOffset;

    PRINTF(("Dump Saved Area:\n"));
    PRINTF(("Registers: Edi 0x%x Esi 0x%x Ebx 0x%x, Edx 0x%x, Ecx 0x%x, Eax 0x%x, Ebp 0x%x\n",
            pctxt->Edi, pctxt->Esi, pctxt->Ebx, pctxt->Edx,
            pctxt->Ecx, pctxt->Eax, pctxt->Ebp));
        
    PRINTF(("pExtendedArea->DataOffset\n"));
    DUMP_HEXLL(xmmi128, 2);
    DUMP_DS(xmmi128, 2);

    PRINTF(("mmx reg0:\n"));
    DUMP_HEXL(mmx0, 2);

    PRINTF(("mmx reg1:\n"));
    DUMP_HEXL(mmx1, 2);

    PRINTF(("mmx reg2:\n"));
    DUMP_HEXL(mmx2, 2);

    PRINTF(("mmx reg3:\n"));
    DUMP_HEXL(mmx3, 2);

    PRINTF(("mmx reg4:\n"));
    DUMP_HEXL(mmx4, 2);

    PRINTF(("mmx reg5:\n"));
    DUMP_HEXL(mmx5, 2);

    PRINTF(("mmx reg6:\n"));
    DUMP_HEXL(mmx6, 2);

    PRINTF(("mmx reg7:\n"));
    DUMP_HEXL(mmx7, 2);

    PRINTF(("xmmi reg0: (+0, -0)\n"));
    DUMP_HEXLL(reg0, 2);
    DUMP_DS(reg0, 2);

    PRINTF(("xmmi reg1: (+1.5*2^1022, +denormalized finite)\n"));
    DUMP_HEXLL(reg1, 2);
    DUMP_DS(reg1, 2);

    PRINTF(("xmmi reg2: (-denormalized finite, +normalized finite)\n"));
    DUMP_HEXLL(reg2, 2);
    DUMP_DS(reg2, 2);

    PRINTF(("xmmi reg3: (-normalized finite, +infinites)\n"));
    DUMP_HEXLL(reg3, 2);
    DUMP_DS(reg3, 2);

    PRINTF(("xmmi reg4: (-infinity, +1.1111110...011*2^-1022)\n"));
    DUMP_HEXLL(reg4, 2);
    DUMP_DS(reg4, 2);

    PRINTF(("xmmi reg5: (SNan, SNan)\n"));
    DUMP_HEXLL(reg5, 2);
    DUMP_DS(reg5, 2);

    PRINTF(("xmmi reg6: (QNan, QNan)\n"));
    DUMP_HEXLL(reg6, 2);
    DUMP_DS(reg6, 2);

    PRINTF(("xmmi reg7: (+1.375*2^1022, +1.11111110...01 * 2^-1022)\n"));
    DUMP_HEXLL(reg7, 2);
    DUMP_DS(reg7, 2);

}

void
dump_Data(PTEMP_EXCEPTION_POINTERS p)
{

    PEXCEPTION_RECORD exc;
    PTEMP_CONTEXT pctxt;
    PFLOATING_EXTENDED_SAVE_AREA pExtendedArea;
    PXMMI_AREA XmmiArea;
    PX87_AREA X87Area;
    PXMMI128 xmmi128;
    PXMMI128 reg0, reg1, reg2, reg3, reg4, reg5, reg6, reg7;
    PMMX64 mmx0, mmx1, mmx2, mmx3, mmx4, mmx5, mmx6, mmx7;
    ULONG i;

    exc = p->ExceptionRecord;
    pctxt = p->ContextRecord;
    pExtendedArea = (PFLOATING_EXTENDED_SAVE_AREA) &pctxt->ExtendedRegisters[0];
    XmmiArea = (PXMMI_AREA) &pExtendedArea->XMMIRegisterArea[0];
    X87Area = (PX87_AREA) &pExtendedArea->X87RegisterArea[0];
    
    reg0 = (PXMMI128) &XmmiArea->Xmmi[0];
    reg1 = (PXMMI128) &XmmiArea->Xmmi[1]; 
    reg2 = (PXMMI128) &XmmiArea->Xmmi[2];
    reg3 = (PXMMI128) &XmmiArea->Xmmi[3]; 
    reg4 = (PXMMI128) &XmmiArea->Xmmi[4];
    reg5 = (PXMMI128) &XmmiArea->Xmmi[5]; 
    reg6 = (PXMMI128) &XmmiArea->Xmmi[6];
    reg7 = (PXMMI128) &XmmiArea->Xmmi[7]; 

    mmx0 = (PMMX64) &X87Area->Mm[0].Mmx;
    mmx1 = (PMMX64) &X87Area->Mm[1].Mmx;
    mmx2 = (PMMX64) &X87Area->Mm[2].Mmx;
    mmx3 = (PMMX64) &X87Area->Mm[3].Mmx;
    mmx4 = (PMMX64) &X87Area->Mm[4].Mmx;
    mmx5 = (PMMX64) &X87Area->Mm[5].Mmx;
    mmx6 = (PMMX64) &X87Area->Mm[6].Mmx;
    mmx7 = (PMMX64) &X87Area->Mm[7].Mmx;

    xmmi128 = (PXMMI128) pExtendedArea->DataOffset;

    PRINTF(("Dump Saved Area:\n"));
    PRINTF(("Registers: Edi 0x%x Esi 0x%x Ebx 0x%x, Edx 0x%x, Ecx 0x%x, Eax 0x%x, Ebp 0x%x\n",
            pctxt->Edi, pctxt->Esi, pctxt->Ebx, pctxt->Edx,
            pctxt->Ecx, pctxt->Eax, pctxt->Ebp));
        
    PRINTF(("pExtendedArea->DataOffset\n"));
    DUMP_HEXL(xmmi128, 4);
    DUMP_FS(xmmi128, 4);

    PRINTF(("mmx reg0:\n"));
    DUMP_HEXL(mmx0, 2);

    PRINTF(("mmx reg1:\n"));
    DUMP_HEXL(mmx1, 2);

    PRINTF(("mmx reg2:\n"));
    DUMP_HEXL(mmx2, 2);

    PRINTF(("mmx reg3:\n"));
    DUMP_HEXL(mmx3, 2);

    PRINTF(("mmx reg4:\n"));
    DUMP_HEXL(mmx4, 2);

    PRINTF(("mmx reg5:\n"));
    DUMP_HEXL(mmx5, 2);

    PRINTF(("mmx reg6:\n"));
    DUMP_HEXL(mmx6, 2);

    PRINTF(("mmx reg7:\n"));
    DUMP_HEXL(mmx7, 2);

    PRINTF(("xmmi reg0: (n, n, n, n)\n"));
    DUMP_HEXL(reg0, 4);
    DUMP_FS(reg0, 4);

    PRINTF(("xmmi reg1: (+0, -0, +denormalized finite, n)\n"));
    DUMP_HEXL(reg1, 4);
    DUMP_FS(reg1, 4);

    PRINTF(("xmmi reg2: (-denormalized finite, +normalized finite, -normalized finite, n)\n"));
    DUMP_HEXL(reg2, 4);
    DUMP_FS(reg2, 4);

    PRINTF(("xmmi reg3: (+infinites, -infinites, n, 1000003)\n"));
    DUMP_HEXL(reg3, 4);
    DUMP_FS(reg3, 4);

    PRINTF(("xmmi reg4: (n, n, n, n)\n"));
    DUMP_HEXL(reg4, 4);
    DUMP_FS(reg4, 4);

    PRINTF(("xmmi reg5: (SNan, SNan, n, n)\n"));
    DUMP_HEXL(reg5, 4);
    DUMP_FS(reg5, 4);

    PRINTF(("xmmi reg6: (QNan, QNan, 7ec00000, n)\n"));
    DUMP_HEXL(reg6, 4);
    DUMP_FS(reg6, 4);

    PRINTF(("xmmi reg7: (n, n, 7eb00000, 100004)\n"));
    DUMP_HEXL(reg7, 4);
    DUMP_FS(reg7, 4);

}

void
dump_OpLocation(POPERAND Operand) {

    if (!Operand->Op.OperandValid) {
        PRINTF(("Operand Invalid\n")) 
        return;
    }

    switch (Operand->OpLocation) {
    case ST0:
        PRINTF(("OpLocation = ST0 "));
        break;
    case ST1:
        PRINTF(("OpLocation = ST1 "));
        break;
    case ST2:
        PRINTF(("OpLocation = ST2 "));
        break;
    case ST3:
        PRINTF(("OpLocation = ST3 "));
        break;
    case ST4:
        PRINTF(("OpLocation = ST4 "));
        break;
    case ST5:
        PRINTF(("OpLocation = ST5 "));
        break;
    case ST6:
        PRINTF(("OpLocation = ST6 "));
        break;
    case ST7:
        PRINTF(("OpLocation = ST7 "));
        break;
    case REG:
        PRINTF(("OpLocation = REG "));
        PRINTF(("OpReg %x", Operand->OpReg));
        break;
    case RS:
        PRINTF(("OpLocation = RS "));
        break;
    case M16I:
        PRINTF(("OpLocation = M16I "));
        break;
    case M32I:
        PRINTF(("OpLocation = M32I "));
        break;
    case M64I:
        PRINTF(("OpLocation = M64I "));
        break;
    case M32R:
        PRINTF(("OpLocation = M32R "));
        break;
    case M64R:
        PRINTF(("OpLocation = M64R "));
        break;
    case M80R:
        PRINTF(("OpLocation = M80R "));
        break;
    case M80D:
        PRINTF(("OpLocation = M80D "));
        break;
    case Z80R:
        PRINTF(("OpLocation = Z80R "));
        break;
    case M128_M32R:
        PRINTF(("OpLocation = M128_M32R "));
        break;
    case M128_M64R:
        PRINTF(("OpLocation = M128_M64R "));
        break;
    case MMX:
        PRINTF(("OpLocation = MMX "));
        PRINTF(("OpReg %x", Operand->OpReg));
        break;
    case XMMI:
        PRINTF(("OpLocation = XMMI "));
        PRINTF(("OpReg %x", Operand->OpReg));
        break;
    case XMMI2:
        PRINTF(("OpLocation = XMMI2 "));
        PRINTF(("OpReg %x", Operand->OpReg));
        break;
    case IMM8:
        PRINTF(("OpLocation = IMM8 "));
        break;
    case M64R_64:
        PRINTF(("OpLocation = M64R_64 "));
        break;
    case M128_M32I:
        PRINTF(("OpLocation = M128_M32I "));
        break;
    case XMMI_M32I:
        PRINTF(("OpLocation = XMMI_M32I "));
        PRINTF(("OpReg %x", Operand->OpReg));
        break;
    case LOOKUP:
        PRINTF(("OpLocation = LOOKUP "));
        break;
    case INV:
        PRINTF(("OpLocation = INV "));
        break;
    default:
        PRINTF(("?"));
    }

    PRINTF(("\n"));

}

void
dump_XmmiFpEnv(
    PXMMI_FP_ENV XmmiFpEnv) {
    
    POPERAND Operand;
    XMMI_ENV XmmiEnv;
    _FPIEEE_RECORD ieee;

    XmmiEnv.Ieee = &ieee;
    XmmiEnv.Ieee->Operation = XmmiFpEnv->OriginalOperation;
    XmmiEnv.Imm8 = XmmiFpEnv->Imm8;
    print_Operations(&XmmiEnv);
        
    Operand = &XmmiFpEnv->Operand1;
    PRINTF(("Operand1: "));
    dump_OpLocation(Operand);

    Operand = &XmmiFpEnv->Operand2;
    PRINTF(("Operand2: "));
    dump_OpLocation(Operand);

}

void
dump_Control(PTEMP_EXCEPTION_POINTERS p) {

    PEXCEPTION_RECORD exc;
    PTEMP_CONTEXT pctxt;
    PFLOATING_EXTENDED_SAVE_AREA pExtendedArea;
    PULONG istream;

    exc = p->ExceptionRecord;
    pctxt = p->ContextRecord;
    pExtendedArea = (PFLOATING_EXTENDED_SAVE_AREA) &pctxt->ExtendedRegisters[0];
    istream = (PULONG) pctxt->Eip;

    PRINTF(("EIP %x ExceptionRecord %x ContextRecord %x ExtendedArea %x\n",
             istream, exc, pctxt, pExtendedArea));
    PRINTF(("MXCsr: %x, CW: %x\n", pExtendedArea->MXCsr, pExtendedArea->ControlWord));

}

void
dump_Format(_FPIEEE_VALUE *Operand) {

    _U64 u64;
    _I64 i64;
    _FP80 fp80;
    _FP128 fp128;
    ULONG i;

    if (!Operand->OperandValid) {
        PRINTF(("Operand Invalid\n")); 
    }

    PRINTF(("Format/Value: "));
    switch (Operand->Format) {
    case _FpFormatFp32:
         PRINTF(("_FpFormatFp32 %f", Operand->Value.Fp32Value));
         PRINTF((" = (hex) %x\n", Operand->Value.U32Value));
         break;
    case _FpFormatFp64:
         PRINTF(("_FpFormatFp64 %e\n", Operand->Value.Fp64Value));
         for (i=0; i < 3; i++) {
             PRINTF((" = (hex) %x\n", Operand->Value.U64Value.W[i]));
         }
         break;
    case _FpFormatFp80:
         fp80 = Operand->Value.Fp80Value;
         PRINTF(("_FpFormatFp80 (hex)"));        
         for (i=0; i < 5; i++) {
             PRINTF((" %x", fp80.W[i]));
         }
         break;
    case _FpFormatFp128:
         fp128 = Operand->Value.Fp128Value;
         PRINTF(("_FpFormatFp128 (hex)"));        
         for (i=0; i < 4; i++) {
             PRINTF((" %x", fp128.W[i]));
         }
         break;
    case _FpFormatI16:
         PRINTF(("_FpFormatI16 %d\n", Operand->Value.I16Value));
         break;
    case _FpFormatI32:
         PRINTF(("_FpFormatI32 %d", Operand->Value.I32Value));
         PRINTF((" = (hex) %x\n", Operand->Value.U32Value));
         break;
    case _FpFormatI64:
         i64 = Operand->Value.I64Value;
         PRINTF(("_FpFormatI64 (hex)"));  
         for (i=0; i < 2; i++) {
             PRINTF((" %x", i64.W[i]));
         }
         break;
    case _FpFormatU16:
         PRINTF(("_FpFormatU16 h%u\n", Operand->Value.U16Value));
         break;
    case _FpFormatU32:
         PRINTF(("_FpFormatU32 l%u\n", Operand->Value.U32Value));
         PRINTF((" = (hex) %x\n", Operand->Value.U32Value));
         break;
    case _FpFormatU64:
         u64 = Operand->Value.U64Value;
         PRINTF(("_FpFormatU64 (hex)"));  
         for (i=0; i < 2; i++) {
             PRINTF((" %x", u64.W[i]));
         }
         break;
    case _FpFormatCompare:
         PRINTF(("_FpFormatCompare %x\n", Operand->Value.CompareValue));
         break;
    case _FpFormatString:
         PRINTF(("_FpFormatString %s\n", Operand->Value.StringValue));
         break;

    default:
         PRINTF(("?"));
         break;

    }

    PRINTF(("\n"));

    return;

}

void
dump_fpieee_record(_FPIEEE_RECORD *pieee) {

    XMMI_ENV XmmiEnv;

    XmmiEnv.Ieee = pieee;
    PRINTF(("OPERATION: 0x%x\n", pieee->Operation));

    print_Rounding(&XmmiEnv);
    print_Precision(&XmmiEnv);
    print_CauseEnable(&XmmiEnv);
    print_Status(&XmmiEnv);
        
    PRINTF(("Operand 1:\n"));
    dump_Format(&pieee->Operand1);
    PRINTF(("Operand 2: \n"));
    dump_Format(&pieee->Operand2);

    PRINTF(("Result:"));
    dump_Format(&pieee->Result);

}

void 
print_FPIEEE_RECORD_EXCEPTION1 (PXMMI_ENV XmmiEnv, ULONG res1, ULONG res0, ULONG flags) {

  // print the FP IEEE record info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (EXCEPTION):\n"));

  if (res1 != XmmiEnv->Ieee->Result.Value.U64Value.W[1] ||
      res0 != XmmiEnv->Ieee->Result.Value.U64Value.W[0])
      PRINTF (("ERROR: expected res = %8.8x %8.8x got res = %8.8x %8.8x\n",
      res1, res0, XmmiEnv->Ieee->Result.Value.U64Value.W[1],
      XmmiEnv->Ieee->Result.Value.U64Value.W[0]));

  if (flags != XmmiEnv->Flags)
      PRINTF (("ERROR: expected flags = %x got flags = %x\n",
      flags, XmmiEnv->Flags));

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_CauseEnable(XmmiEnv);
  print_Status(XmmiEnv);
  print_Result(XmmiEnv, TRUE);

  PRINTF(("\n"));

}

void
print_FPIEEE_RECORD_EXCEPTION2 (PXMMI_ENV XmmiEnv, ULONG res, ULONG flags) {

  // print the FP IEEE record info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (EXCEPTION):\n"));

  if (res != XmmiEnv->Ieee->Result.Value.U32Value)
      printf ("ERROR: expected res = %x got res = %f = %8.8x\n",
      res, XmmiEnv->Ieee->Result.Value.Fp32Value,
      XmmiEnv->Ieee->Result.Value.U32Value);

  if (flags != XmmiEnv->Flags)
      printf ("ERROR: expected flags = %x got flags = %x\n",
      flags, XmmiEnv->Flags);

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_CauseEnable(XmmiEnv);
  print_Status(XmmiEnv);
  print_Result(XmmiEnv, TRUE);

  PRINTF(("\n"));

}

void
print_FPIEEE_RECORD_EXCEPTION3 (PXMMI_ENV XmmiEnv, ULONG eflags, ULONG flags) {

  // print the FP IEEE record info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (EXCEPTION):\n"));

  if (eflags != XmmiEnv->EFlags)
      printf ("ERROR: expected eflags = %x got eflags = %x\n",
      eflags, XmmiEnv->EFlags);

  if (flags != XmmiEnv->Flags)
      printf ("ERROR: expected flags = %x got flags = %x\n",
      flags, XmmiEnv->Flags);

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_CauseEnable(XmmiEnv);
  print_Status(XmmiEnv);

  PRINTF(("\n"));

}

void 
print_FPIEEE_RECORD_NO_EXCEPTION1 (PXMMI_ENV XmmiEnv, ULONG res1, ULONG res0, ULONG flags) {

  // print the FP IEEE record result info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (NO EXCEPTION):\n"));

  if (res1 != XmmiEnv->Ieee->Result.Value.U64Value.W[1] ||
      res0 != XmmiEnv->Ieee->Result.Value.U64Value.W[0])
      PRINTF (("ERROR: expected res = %8.8x %8.8x got res = %8.8x %8.8x\n",
      res1, res0, XmmiEnv->Ieee->Result.Value.U64Value.W[1],
      XmmiEnv->Ieee->Result.Value.U64Value.W[0]));

  if (flags != XmmiEnv->Flags)
      PRINTF (("ERROR: expected flags = %x got flags = %x\n",
      flags, XmmiEnv->Flags));

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_Status(XmmiEnv);
  print_Result(XmmiEnv, FALSE);

  PRINTF(("\n"));

}

void
print_FPIEEE_RECORD_NO_EXCEPTION2 (PXMMI_ENV XmmiEnv, ULONG res, ULONG flags) {

  // print the FP IEEE record result info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (NO EXCEPTION):\n"));

  if (res != XmmiEnv->Ieee->Result.Value.U32Value)
      printf ("ERROR: expected res = %x got res = %f = %8.8x\n",
      res, XmmiEnv->Ieee->Result.Value.Fp32Value,
      XmmiEnv->Ieee->Result.Value.U32Value);

  if (flags != XmmiEnv->Flags)
      printf ("ERROR: expected flags = %x got flags = %x\n",
      flags, XmmiEnv->Flags);

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_Status(XmmiEnv);
  print_Result(XmmiEnv, FALSE);

  PRINTF(("\n"));

}


void
print_FPIEEE_RECORD_NO_EXCEPTION3 (PXMMI_ENV XmmiEnv, ULONG eflags, ULONG flags)
 {

  // print the FP IEEE record result info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (NO EXCEPTION):\n"));

  if (eflags != XmmiEnv->EFlags)
      printf ("ERROR: expected eflags = %x got eflags = %x\n",
      eflags, XmmiEnv->EFlags);

  if (flags != XmmiEnv->Flags)
      printf ("ERROR: expected flags = %x got flags = %x\n",
      flags, XmmiEnv->Flags);

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_Status(XmmiEnv);
  print_Result(XmmiEnv, FALSE);

  PRINTF(("\n"));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\atan_pentium4.asm ===
;/* File: "atan_wmt.asm". */
;//
;//               INTEL CORPORATION PROPRIETARY INFORMATION
;//  This software is supplied under the terms of a license agreement or
;//  nondisclosure agreement with Intel Corporation and may not be copied
;//  or disclosed except in accordance with the terms of that agreement.
;//        Copyright (c) 2000 Intel Corporation. All Rights Reserved.
;//
;//
;//  Contents:      atan.
;//
;//  Purpose:       Libm 
;//

    .686P
    .387
    .XMM
    .MODEL FLAT,C

EXTRN C __libm_error_support : NEAR  

CONST	SEGMENT PARA PUBLIC USE32 'CONST'
        ALIGN 16

EXTRN C _atan_table:QWORD

_atn TEXTEQU <_atan_table>

;/*
;//   FUNCTION:     double atan(double x)
;//
;//   DESCRIPTION:
;//
;//      1. For |x| < 2^(-27), where atan(x) ~= x, return x.
;//      2. For |x| >= 0.1633123935319536975596774e+17, where atan(x) ~= +-Pi/2, return +-Pi/2.
;//      3. In interval [0.0,0.03125] polynomial approximation of atan(x)=x-x*P(x^2).
;//      4. In interval [0.03125,0.375] polynomial approximation of atan(x)=x-x*D(x^2).
;//      5. In interval [0.375,8.0] we compute ind and eps such, that x=0.03125*ind+eps and 0.0<eps<0.03125.
;//         Let s=0.03125*ind, then atan(x)=atan(s)+atan(t), where t=((x-s)/(1+x*s)). For lo and hi part of
;//         atan(s) we have table (see file atan_table.c): atn[ind]+atn[ind+1]=atan(s).
;//         atan(t) is approximated atan(t)=t-t*P(t^2).
;//      6. In interval [8.0,0.1633123935319536975596774e+17] atan(x)=Pi/2+atan(-1/x).
;//         atan(-1/x) is approximated atan(t)=t-t*P(t^2), where t=-1/x.
;//      7. For x < 0.0 atan(x) = -atan(|x|).
;//      8. Special cases:
;//         atan(+0)   = +0;
;//         atan(-0)   = -0;
;//         atan(+INF) = +Pi/2;
;//         atan(-INF) = -Pi/2;
;//         atan(NaN)  = NaN.
;//
;//   KEYS OF COMPILER: -c -w -Zl -Di386 /QIfdiv-
;*/

_mexp   DQ  07ff0000000000000H, 07ff0000000000000H
_mabs   DQ  07fffffffffffffffH, 07fffffffffffffffH
_pi_2d  DQ  03ff921fb54442d18H, 0bff921fb54442d18H
_cntshf DQ  00000000000040201H, 00000000000040201H
_d1400  DQ  03fd5555555555552H, 00000000000000000H
_d1213  DQ  03fc249249246aa76H, 0bfc99999999992acH
_d1011  DQ  03fb745d15933de8aH, 0bfbc71c71b835923H
_d89    DQ  03fb110f5eeb76ecaH, 0bfb3b1390a3b9899H
_d67    DQ  03faae4492fe3a600H, 0bfae1c1704144b68H
_d45    DQ  03fa51fa164891abeH, 0bfa8171d55d53138H
_d23    DQ  03f974721481ca2a2H, 0bfa124ce2388f2cbH
_d01    DQ  03f66107c30e0b8a5H, 0bf866e5652b14bbdH
_p60    DQ  03fd55555555554ebH, 00000000000000000H
_p45    DQ  03fc249249014497eH, 0bfc9999999976718H
_p23    DQ  03fb7453ba342480fH, 0bfbc71c4eebfb10eH
_p01    DQ  03fae9be97b0f8d08H, 0bfb39ad683f878c6H
_zero   DQ  00000000000000000H, 00000000000000000H
_onen   DQ  0bff0000000000000H, 0bff0000000000000H
_one    DQ  03ff0000000000000H, 03ff0000000000000H
_cnst8  DQ  04020000000000000H, 04020000000000000H
_in3    DQ  04020000000000000H, 04020000000000000H
_in2    DQ  03fd8000000000000H, 03fd8000000000000H
_in1    DQ  03fa0000000000000H, 03fa0000000000000H
_in0    DQ  03e40000000000000H, 03e40000000000000H
_in     DQ  0434d02967c31cdb5H, 0434d02967c31cdb5H
_minval DQ  00010000000000000H, 00010000000000000H
libm_small  DQ  00200000000000000H 
CONST	ENDS

_x      TEXTEQU     <esp+4>
XMMWORD TEXTEQU <OWORD>

_TEXT   SEGMENT PARA PUBLIC USE32 'CODE'
        ALIGN       4

PUBLIC C _atan_pentium4, _CIatan_pentium4
_CIatan_pentium4  PROC NEAR
	push	    ebp
	mov 	    ebp, esp 
	sub         esp, 8                          ; for argument DBLSIZE
	and         esp, 0fffffff0h
	fstp        qword ptr [esp]
	movq        xmm7, qword ptr [esp]
	call        start
	leave
	ret
_atan_pentium4   label proc
        movq        xmm7, QWORD PTR [_x]            ;  x
start:
        unpcklpd    xmm7, xmm7
        movapd      xmm2, xmm7
        andpd       xmm2, XMMWORD PTR _mabs         ; |x|
        comisd      xmm2, XMMWORD PTR _in           ; |x| < 0.1633123935319536975596774e+17 ?
        jp          x_nan
        jae         bigx
        comisd      xmm2, XMMWORD PTR _in1          ; |x| < 0.03125 ?
        jae         xge0_03125
        comisd      xmm2, XMMWORD PTR _in0          ; |x| < 2^(-27) ?
        jb          retx                            ; atan(x) ~= x

        ; 2^(-27) < |x| < 0.03125, atan(x)=x-x*P(x^2)

        movapd      xmm1, xmm2
        mulpd       xmm1, xmm2                      ; |x|^2
        movapd      xmm3, xmm1
        mulpd       xmm3, xmm1                      ; |x|^4
        movapd      xmm5, XMMWORD PTR _p01          ; calculate P(x^2)
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _p23
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _p45
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _p60
        mulsd       xmm5, xmm1
        movapd      xmm3, xmm5
        shufpd      xmm3, xmm3, 1
        addsd       xmm5, xmm3                      ; P(x^2)
        mulsd       xmm5, xmm7                      ; x * P(x^2)
        subsd       xmm7, xmm5                      ; x - x * P(x^2)
        movq        QWORD PTR [_x], xmm7
        fld         QWORD PTR [_x]
        ret

xge0_03125:                                         ; |x| >= 0.03125
        comisd    xmm2, XMMWORD PTR _in2            ; |x| < 0.375 ?
        jae       xge0_375

        ; 0.03125 < |x| < 0.375, atan(x)=x-x*D(x^2)

        movapd      xmm1, xmm2
        mulpd       xmm1, xmm2                      ; |x|^2
        movapd      xmm3, xmm1
        mulpd       xmm3, xmm1                      ; |x|^4
        movapd      xmm5, XMMWORD PTR _d01          ; calculate D(x^2)
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _d23
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _d45
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _d67
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _d89
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _d1011
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _d1213
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _d1400
        mulsd       xmm5, xmm1
        movapd      xmm3, xmm5
        shufpd      xmm3, xmm3, 1
        addsd       xmm5, xmm3                      ; D(x^2)
        mulsd       xmm5, xmm7                      ; x * D(x^2)
        subsd       xmm7, xmm5                      ; x - x * D(x^2)
        movq        QWORD PTR [_x], xmm7
        fld         QWORD PTR [_x]
        ret

xge0_375:                                           ; |x| >= 0.375
        movq        xmm6, xmm7                      ; x
        xorpd       xmm6, xmm2                      ; sign x
        comisd      xmm2, XMMWORD PTR _in3          ; |x| < 8.0 ?
        jae         xge8_0

;       0.375 < |x| < 8.0:
;       atan(|x|)=atan(s)+atan(t), s=ind*0.03125, t=(|x|-s)/(1+|x|*s)

        movq        xmm0, XMMWORD PTR _cnst8
        movq        xmm5, XMMWORD PTR _cntshf
        movq        xmm3, xmm2                      ; calculate ind
        addsd       xmm3, xmm0
        psrlq       xmm3, 44
        psubd       xmm3, xmm5
        movd        eax,  xmm3                      ; ind
        lea         eax,  DWORD PTR [eax+eax*2]     ; ind*3
        movq        xmm5, QWORD PTR _atn[eax*8+16]  ; s
        movq        xmm3, xmm2                      ; |x|
        subsd       xmm2, xmm5                      ; |x|-s
        mulsd       xmm3, xmm5                      ; |x|*s
        addsd       xmm3, XMMWORD PTR _one          ; 1+|x|*s
        divsd       xmm2, xmm3                      ; (|x|-s)/(1+|x|*s)
        unpcklpd    xmm2, xmm2
        jmp         clcpol

xge8_0:                                             ; |x| > 8.0

;       8.0 < |x| < 0.1633123935319536975596774e+17:
;       atan(|x|)=Pi/2+atan(-1/|x|)

        mov         eax, 768                        ; ind*3 - entry point in table, where lo and hi part of Pi/2
        movq        xmm0, xmm2                      ; |x|
        movq        xmm2, XMMWORD PTR _onen
        divsd       xmm2, xmm0                      ;-1/|x|
        unpcklpd    xmm2, xmm2

clcpol:
        movq        xmm0, QWORD PTR _atn[0+eax*8]   ; atn[ind+0] - hi part of atan(s) or Pi/2
        movq        xmm4, QWORD PTR _atn[8+eax*8]   ; atn[ind+1] - lo part of atan(s) or Pi/2
        movapd      xmm1, xmm2
        mulpd       xmm1, xmm2                      ; |x|^2
        movapd      xmm3, xmm1
        mulpd       xmm3, xmm1                      ; |x|^4
        movapd      xmm5, XMMWORD PTR _p01          ; calculate P(x^2)
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _p23
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _p45
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _p60
        mulsd       xmm5, xmm1
        movapd      xmm3, xmm5
        shufpd      xmm3, xmm3, 1
        addsd       xmm5, xmm3                      ; P(x^2)

;       atan(|x|) = atn[ind+0]-((|x|*P(x^2)-atn[ind+1])-|x|)

        mulsd       xmm5, xmm2                      ; |x|*P(x^2)
        subsd       xmm5, xmm4                      ; |x|*P(x^2)-atn[ind+1]
        subsd       xmm5, xmm2                      ; (|x|*P(x^2)-atn[ind+1])-|x|
        subsd       xmm0, xmm5                      ; atn[ind+0]-((|x|*P(x^2)-atn[ind+1])-|x|)
        orpd        xmm0, xmm6                      ; sign x
        movq        QWORD PTR [_x], xmm0
        fld         QWORD PTR [_x]
        ret

retx:                                               ; |x| < 2^(-27): atan(x) ~= x
        comisd      xmm2, XMMWORD PTR _zero         ; x == 0 ?
        jne         notzero
        fld         QWORD PTR [_x]                  ; x == +0.0 or -0.0
        ret

notzero:
        comisd      xmm2, XMMWORD PTR _minval       ; x < minval ?
        jae         ge_minval
        fld         QWORD PTR libm_small
        fmul        QWORD PTR libm_small
        sub         esp, 8
        fstp        QWORD PTR [esp]                 ; should be flag UNDERFLOW
        fld         QWORD PTR [esp]
        add         esp, 8
        fadd        QWORD PTR [_x]                  ; should be inexact result
        ret

ge_minval:                                          ; minval < x < 2^(-27)
        fld         QWORD PTR libm_small
        fmul        QWORD PTR libm_small
        fadd        QWORD PTR [_x]                  ; should be inexact result
        ret

bigx:                                               ; |x| > 0.1633123935319536975596774e+17
        movq        xmm0, xmm2                      ; |x|
        movq        xmm3, QWORD PTR _mexp
        andpd       xmm0, xmm3
        ucomisd     xmm0, xmm3
        jp          x_nan

        mov         eax, DWORD PTR [_x+4]           ; x
        shr         eax, 31                         ; sign x
        fld         QWORD PTR libm_small
        fadd        QWORD PTR _pi_2d[eax*8]         ; should be inexact result
        ret                                         ; return +-Pi/2

x_nan:
        mov         edx, 1003
        ;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
        sub         esp, 16
        mov         DWORD PTR [esp+12],edx
        mov         edx, esp
        add         edx, 16+4
        mov         DWORD PTR [esp+8],edx
        mov         DWORD PTR [esp+4],edx
        mov         DWORD PTR [esp],edx
        call        NEAR PTR __libm_error_support
        add         esp, 16

        fld         QWORD PTR [_x]
        ret                                         ; return same nan

        ALIGN       4

_CIatan_pentium4  ENDP

_TEXT   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\atan.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;        support for atan() function
;
;Revision History:
;   01-26-01  PML   Pentium4 merge.
;
;*******************************************************************************

.xlist
        include cruntime.inc
        include elem87.inc
.list

_FUNC_     equ	<atan>
_FUNC_DEF_ equ	<_atan_default>
_FUNC_P4_  equ	<_atan_pentium4>
_FUNC_P4_EXTERN_ equ 1
	include	disp_pentium4.inc

_FUNC_     equ	<_CIatan>
_FUNC_DEF_ equ	<_CIatan_default>
_FUNC_P4_  equ	<_CIatan_pentium4>
	include	disp_pentium4.inc

        .data

_NAME_ db 'atan',0,0,0,0

extrn   _indefinite:tbyte
extrn   __fastflag:dword
extrn   _piby2:tbyte
extrn   _DEFAULT_CW_in_mem:word

        CODESEG

extrn   _startOneArgErrorHandling:near
extrn   _fload_withFB:near
extrn   _convertTOStoQNaN:near
extrn   _checkTOS_withFB:near
extrn   _math_exit:near
extrn   _fast_exit:near


; arg                ErrorType        result
;-------------------------------------------
;+infinity            -                 pi/2
;-infinity            -                -pi/2
;QNaN                DOMAIN_QNAN        QNaN            | ? to distinguish them???
;SNaN                DOMAIN             indefinite      | ? it costs 14 bytes per function
;indefinite is like QNaN
;denormal        fld converts it to normal (80 bits)

        public _atan_default,_CIatan_default
_CIatan_default proc
        sub     esp,DBLSIZE+4                 ; for argument
        fst     qword ptr [esp]
        call    _checkTOS_withFB
        call    start
        add     esp, DBLSIZE+4
        ret

_atan_default label   proc
        lea     edx, [esp+4]
        call    _fload_withFB
start:
        push    edx                           ; allocate space for Control Word
        fstcw   [esp]                         ; store Control Word

; at this point we have on stack: cw(4), ret_addr(4), arg1(8bytes)

        jz      inf_or_nan
        cmp     word ptr[esp], default_CW
        je      CW_is_set_to_default
; fpatan is not affected by precision bits. So we may ignore user's CW
        fldcw   _DEFAULT_CW_in_mem
CW_is_set_to_default:

        fld1                                  ; load 1.0
        fpatan                                ; fpatan(x,1.0)

exit:
        cmp     __fastflag, 0
        jnz     _fast_exit

; prepare in registers arguments for math_exit
        mov     edx,OP_ATAN
        lea     ecx,[_NAME_]
        jmp     _math_exit


not_infinity:
        call    _convertTOStoQNaN             ; eax MUST contain high dword
        jmp     _Error_handling               ; eax=error number
inf_or_nan:
        test    eax, 000fffffh
        jnz     not_infinity
        cmp     dword ptr[esp+8], 0
        jne     not_infinity
        fstp    st(0)
        fld     [_piby2]
        test    eax,80000000H
        jz      exit                          ; return pi/2
        fchs
        jmp     exit                          ; return  -pi/2

        mov     eax,DOMAIN
_Error_handling:
        cmp     __fastflag, 0
        jnz     _fast_exit

        mov     edx,OP_ATAN
        lea     ecx,[_NAME_]
        call    _startOneArgErrorHandling
        pop     edx                           ; remove saved CW from stack
        ret

_CIatan_default endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\atan_table.c ===
/* File: "atan_table.c". */

/*
//
//               INTEL CORPORATION PROPRIETARY INFORMATION
//  This software is supplied under the terms of a license agreement or
//  nondisclosure agreement with Intel Corporation and may not be copied
//  or disclosed except in accordance with the terms of that agreement.
//        Copyright (c) 2000 Intel Corporation. All Rights Reserved.
//
//  Contents:      Table for functhion atan (see file atan.c and atan_wmt.asm).
//
//  Purpose:       Libm.
//
//
*/

const double _atan_table[] = {
     3.12398332171142101287841796875e-02,    2.131540661249275652049909770325e-10,    3.12500e-02,
     6.24188096262514591217041015625e-02,    3.697058893522750114230051136063e-10,    6.25000e-02,
     9.34767806902527809143066406250e-02,    4.683366825902205526870604788232e-10,    9.37500e-02,
     1.24354993924498558044433593750e-01,    6.222628769869212554138710255732e-10,    1.25000e-01,
     1.54996741563081741333007812500e-01,    3.608592409707065624334921910556e-10,    1.56250e-01,
     1.85347948223352432250976562500e-01,    1.772342332635049398728544644515e-09,    1.87500e-01,
     2.15357698500156402587890625000e-01,    1.197581645436569002166489650499e-09,    2.18750e-01,
     2.44978662580251693725585937500e-01,    5.466124604464965437112758109141e-10,    2.50000e-01,
     2.74167448282241821289062500000e-01,    2.837416976310309398342175801554e-09,    2.81250e-01,
     3.02884865552186965942382812500e-01,    2.822784439618173282005558213292e-09,    3.12500e-01,
     3.31096075475215911865234375000e-01,    1.228916183079104412756944545469e-09,    3.43750e-01,
     3.58770668506622314453125000000e-01,    1.763949905942795063926460499777e-09,    3.75000e-01,
     3.85882668197154998779296875000e-01,    1.200918777118398609607231411754e-09,    4.06250e-01,
     4.12410438060760498046875000000e-01,    3.536626808852916289667126937047e-09,    4.37500e-01,
     4.38336558640003204345703125000e-01,    1.217954601099912924214771330029e-09,    4.68750e-01,
     4.63647607713937759399414062500e-01,    1.286868356814842168961214402029e-09,    5.00000e-01,
     4.88333947956562042236328125000e-01,    3.099843481630836835747064837358e-09,    5.31250e-01,
     5.12389458715915679931640625000e-01,    1.594822026734960395584259254421e-09,    5.62500e-01,
     5.35811230540275573730468750000e-01,    7.420188126538616318707691407099e-09,    5.93750e-01,
     5.58599308133125305175781250000e-01,    7.210437130795726966401661270346e-09,    6.25000e-01,
     5.80756351351737976074218750000e-01,    2.215932423129055725001500862099e-09,    6.56250e-01,
     6.02287344634532928466796875000e-01,    1.500431253215325819204232909999e-09,    6.87500e-01,
     6.23199328780174255371093750000e-01,    1.153891675621381599060374595087e-09,    7.18750e-01,
     6.43501102924346923828125000000e-01,    5.868937462974684228717322638042e-09,    7.50000e-01,
     6.63202986121177673339843750000e-01,    6.584915582023410560238275873263e-09,    7.81250e-01,
     6.82316549122333526611328125000e-01,    5.752414551645101856711152993143e-09,    8.12500e-01,
     7.00854405760765075683593750000e-01,    2.123685096774357531786751268090e-09,    8.43750e-01,
     7.18829996883869171142578125000e-01,    2.737755334274436026525904653951e-09,    8.75000e-01,
     7.36257426440715789794921875000e-01,    2.540712341947913396089146662832e-09,    9.06250e-01,
     7.53151275217533111572265625000e-01,    5.744661277952473745269028881600e-09,    9.37500e-01,
     7.69526474177837371826171875000e-01,    6.227820888580648160985654018868e-09,    9.68750e-01,
     7.85398162901401519775390625000e-01,    4.960467898402702208198757210493e-10,    1.00000e+00,
     8.00781562924385070800781250000e-01,    2.253658389748251166028452574564e-09,    1.03125e+00,
     8.15691918134689331054687500000e-01,    5.181534079966773338745645846567e-09,    1.06250e+00,
     8.30144390463829040527343750000e-01,    4.388234867630905473345013524770e-09,    1.09375e+00,
     8.44153985381126403808593750000e-01,    7.320445987092503982716475065259e-10,    1.12500e+00,
     8.57735492289066314697265625000e-01,    1.646976974689393634401636258728e-09,    1.15625e+00,
     8.70903454720973968505859375000e-01,    2.354678984634313737597814094030e-09,    1.18750e+00,
     8.83672110736370086669921875000e-01,    5.917087395273464170528949437663e-09,    1.21875e+00,
     8.96055378019809722900390625000e-01,    6.551534233274410093029937827025e-09,    1.25000e+00,
     9.08066816627979278564453125000e-01,    2.273925746984707125349512590406e-09,    1.28125e+00,
     9.19719599187374114990234375000e-01,    6.163042702238369079821089425988e-09,    1.31250e+00,
     9.31026540696620941162109375000e-01,    3.271650007157030305038895044289e-09,    1.34375e+00,
     9.42000038921833038330078125000e-01,    1.457630626407859045534593586072e-09,    1.37500e+00,
     9.52652096748352050781250000000e-01,    4.111357358345352207769909959585e-09,    1.40625e+00,
     9.62994329631328582763671875000e-01,    1.049607619051523960997099925814e-09,    1.43750e+00,
     9.73037928342819213867187500000e-01,    6.858995333578316940744079860537e-09,    1.46875e+00,
     9.82793718576431274414062500000e-01,    4.670897793571648111014666014497e-09,    1.50000e+00,
     9.92272108793258666992187500000e-01,    3.583932702000201676434503589257e-09,    1.53125e+00,
     1.00148312747478485107421875000e+00,    8.219449881844110845301437412509e-09,    1.56250e+00,
     1.01043644547462463378906250000e+00,    4.415428828550118277573210101588e-09,    1.59375e+00,
     1.01914133131504058837890625000e+00,    1.295130914625943666702306364877e-08,    1.62500e+00,
     1.02760674059391021728515625000e+00,    9.913158540718138781765724473397e-09,    1.65625e+00,
     1.03584124147891998291015625000e+00,    1.152988019367453822032544397905e-08,    1.68750e+00,
     1.04385308921337127685546875000e+00,    1.039209569213430778015756976209e-08,    1.71875e+00,
     1.05165021121501922607421875000e+00,    1.333354441385648562086299829630e-09,    1.75000e+00,
     1.05924019217491149902343750000e+00,    7.449679592682189804327891757113e-09,    1.78125e+00,
     1.06663036346435546875000000000e+00,    1.851388094329176347420279866865e-09,    1.81250e+00,
     1.07382771372795104980468750000e+00,    8.187892256056230171157143093471e-09,    1.84375e+00,
     1.08083899319171905517578125000e+00,    7.349449255711375479217199820270e-09,    1.87500e+00,
     1.08767065405845642089843750000e+00,    7.919106542905609278549419916748e-09,    1.90625e+00,
     1.09432889521121978759765625000e+00,    1.210997013229513206461023521251e-08,    1.93750e+00,
     1.10081967711448669433593750000e+00,    1.126340195293153417684743910042e-08,    1.96875e+00,
     1.10714870691299438476562500000e+00,    1.088109611825144046017853704007e-08,    2.00000e+00,
     1.11332146823406219482421875000e+00,    1.066480928312016123954471335648e-08,    2.03125e+00,
     1.11934322118759155273437500000e+00,    1.405475076614440095064569287758e-08,    2.06250e+00,
     1.12521903216838836669921875000e+00,    7.651926474267472354793458802278e-09,    2.09375e+00,
     1.13095372915267944335937500000e+00,    1.482648100311155851553632780475e-08,    2.12500e+00,
     1.13655199110507965087890625000e+00,    1.489301596741226207440196119733e-08,    2.15625e+00,
     1.14201828837394714355468750000e+00,    1.097493308804676433616846293427e-08,    2.18750e+00,
     1.14735691249370574951171875000e+00,    8.141471637937760575662511675050e-09,    2.21875e+00,
     1.15257199108600616455078125000e+00,    6.129661353489368612612751379749e-09,    2.25000e+00,
     1.15766748785972595214843750000e+00,    6.656769276927379159572038936973e-09,    2.28125e+00,
     1.16264721751213073730468750000e+00,    5.527676601269576108270774250510e-09,    2.31250e+00,
     1.16751483082771301269531250000e+00,    1.424834750241433964256123253258e-08,    2.34375e+00,
     1.17227387428283691406250000000e+00,    6.845639472538094944133704614971e-09,    2.37500e+00,
     1.17692771553993225097656250000e+00,    5.186029634961463187726083501939e-10,    2.40625e+00,
     1.18147960305213928222656250000e+00,    1.909616480075475539707852321316e-09,    2.43750e+00,
     1.18593266606330871582031250000e+00,    1.271992558884159172963360952599e-08,    2.46875e+00,
     1.19028994441032409667968750000e+00,    5.272207636248046274829318337601e-09,    2.50000e+00,
     1.19455431401729583740234375000e+00,    2.140227396707584909847208775055e-09,    2.53125e+00,
     1.19872856140136718750000000000e+00,    6.535408980289369957115321521420e-09,    2.56250e+00,
     1.20281538367271423339843750000e+00,    6.977198096471879240373377633244e-09,    2.59375e+00,
     1.20681735873222351074218750000e+00,    1.155302901965332408005655763031e-08,    2.62500e+00,
     1.21073698997497558593750000000e+00,    7.468868748272727604040307287924e-09,    2.65625e+00,
     1.21457666158676147460937500000e+00,    9.811984937110373652926690293626e-09,    2.68750e+00,
     1.21833869814872741699218750000e+00,    5.819464992428498234448426570259e-09,    2.71875e+00,
     1.22202531993389129638671875000e+00,    3.277098340655022993922570490883e-09,    2.75000e+00,
     1.22563867270946502685546875000e+00,    4.242763244518118341144662912366e-09,    2.78125e+00,
     1.22918082773685455322265625000e+00,    8.410234901274410412884989594487e-09,    2.81250e+00,
     1.23265379667282104492187500000e+00,    1.417428114670811737511913702246e-09,    2.84375e+00,
     1.23605948686599731445312500000e+00,    2.612084627456326971109078698703e-09,    2.87500e+00,
     1.23939976096153259277343750000e+00,    8.369044500402396194457257207079e-09,    2.90625e+00,
     1.24267642199993133544921875000e+00,    9.779659899699352145777694333653e-09,    2.93750e+00,
     1.24589119851589202880859375000e+00,    1.021388557297760889923466396129e-08,    2.96875e+00,
     1.24904575943946838378906250000e+00,    1.295878604204085457728109012308e-08,    3.00000e+00,
     1.25214172899723052978515625000e+00,    8.741573416471721248374162284960e-09,    3.03125e+00,
     1.25518065690994262695312500000e+00,    7.846187711282708199415876872025e-09,    3.06250e+00,
     1.25816404819488525390625000000e+00,    1.252056463778502262154196628145e-08,    3.09375e+00,
     1.26109337806701660156250000000e+00,    4.185423817751440881247335772010e-09,    3.12500e+00,
     1.26397003233432769775390625000e+00,    5.054011716071304844264195262485e-09,    3.15625e+00,
     1.26679538190364837646484375000e+00,    5.551103661141789592586819428842e-09,    3.18750e+00,
     1.26957073807716369628906250000e+00,    1.085534696510658459004780444988e-08,    3.21875e+00,
     1.27229738235473632812500000000e+00,    1.285398101317119374982248049407e-08,    3.25000e+00,
     1.27497655153274536132812500000e+00,    6.723153879304604699213464023845e-09,    3.28125e+00,
     1.27760942280292510986328125000e+00,    7.434089310438806796214328210783e-09,    3.31250e+00,
     1.28019715845584869384765625000e+00,    6.584012759248711064053626364991e-09,    3.34375e+00,
     1.28274087607860565185546875000e+00,    3.665665095507416501136495530625e-09,    3.37500e+00,
     1.28524164855480194091796875000e+00,    7.470486111767017009769765205919e-09,    3.40625e+00,
     1.28770053386688232421875000000e+00,    7.628518782370858406087463234843e-09,    3.43750e+00,
     1.29011854529380798339843750000e+00,    5.694900512274118337353804509427e-09,    3.46875e+00,
     1.29249666631221771240234375000e+00,    1.477567555500747671407081684585e-09,    3.50000e+00,
     1.29483583569526672363281250000e+00,    9.114595638024382007616089537116e-09,    3.53125e+00,
     1.29713699221611022949218750000e+00,    1.349669599669199502665650520093e-08,    3.56250e+00,
     1.29940104484558105468750000000e+00,    1.147679758986937059227915110913e-09,    3.59375e+00,
     1.30162882804870605468750000000e+00,    5.960490089117285850366685592141e-09,    3.62500e+00,
     1.30382120609283447265625000000e+00,    5.878161128489539301878008334584e-09,    3.65625e+00,
     1.30597898364067077636718750000e+00,    1.324843697720655978211778739786e-08,    3.68750e+00,
     1.30810298025608062744140625000e+00,    1.226106884751302716449107062469e-09,    3.71875e+00,
     1.31019392609596252441406250000e+00,    8.951593109842375189171905312273e-09,    3.75000e+00,
     1.31225259602069854736328125000e+00,    8.275016105071470064554145959456e-09,    3.78125e+00,
     1.31427970528602600097656250000e+00,    8.864547056389410047056937889374e-09,    3.81250e+00,
     1.31627595424652099609375000000e+00,    1.427042673943814755137727468444e-08,    3.84375e+00,
     1.31824204325675964355468750000e+00,    7.760077406304642702327136253116e-09,    3.87500e+00,
     1.32017861306667327880859375000e+00,    1.262921005512445307883014395673e-08,    3.90625e+00,
     1.32208633422851562500000000000e+00,    3.472858124168611993312009390952e-09,    3.93750e+00,
     1.32396580278873443603515625000e+00,    1.114432779750422544163364758367e-08,    3.96875e+00,
     1.32581765949726104736328125000e+00,    4.170771417695957960428475631184e-09,    4.00000e+00,
     1.32764247059822082519531250000e+00,    8.562541371162473394290094300359e-09,    4.03125e+00,
     1.32944083213806152343750000000e+00,    4.081431296441402128141829549292e-09,    4.06250e+00,
     1.33121328055858612060546875000e+00,    1.420136831552919347675057084008e-08,    4.09375e+00,
     1.33296039700508117675781250000e+00,    2.332364690796037369733155809370e-09,    4.12500e+00,
     1.33468267321586608886718750000e+00,    6.442354753983593217476570076898e-09,    4.15625e+00,
     1.33638064563274383544921875000e+00,    5.438341998417537726877161967895e-09,    4.18750e+00,
     1.33805480599403381347656250000e+00,    9.046037814385648659622761501864e-09,    4.21875e+00,
     1.33970564603805541992187500000e+00,    1.356094411940642875258955574110e-08,    4.25000e+00,
     1.34133365750312805175781250000e+00,    2.285596037267486062179053583112e-09,    4.28125e+00,
     1.34293927252292633056640625000e+00,    5.554870562188788912498970827328e-09,    4.31250e+00,
     1.34452295303344726562500000000e+00,    1.173381403717569307500270273711e-08,    4.34375e+00,
     1.34608514606952667236328125000e+00,    1.231072725868565967825177962565e-08,    4.37500e+00,
     1.34762628376483917236328125000e+00,    2.272218287547117422631062509978e-09,    4.40625e+00,
     1.34914675354957580566406250000e+00,    1.026664321996712870251856126637e-08,    4.43750e+00,
     1.35064698755741119384765625000e+00,    9.544908659820431810059953309619e-09,    4.46875e+00,
     1.35212737321853637695312500000e+00,    7.702418280236022941389812850984e-09,    4.50000e+00,
     1.35358829796314239501953125000e+00,    2.298311106522236589881694951011e-09,    4.53125e+00,
     1.35503011941909790039062500000e+00,    1.096875641746231101174713542048e-08,    4.56250e+00,
     1.35645322501659393310546875000e+00,    1.212201701673204195192859245690e-08,    4.59375e+00,
     1.35785797238349914550781250000e+00,    4.832000329604677385964058528746e-09,    4.62500e+00,
     1.35924468934535980224609375000e+00,    9.116804692809882842286486387302e-09,    4.65625e+00,
     1.36061373353004455566406250000e+00,    6.602682522350465783445563760715e-09,    4.68750e+00,
     1.36196543276309967041015625000e+00,    3.877573446682057410929518329238e-10,    4.71875e+00,
     1.36330009996891021728515625000e+00,    3.907837370041422778250991189943e-10,    4.75000e+00,
     1.36461804807186126708984375000e+00,    8.691123502302366102158347386489e-09,    4.78125e+00,
     1.36591960489749908447265625000e+00,    4.860289062625101607000745385741e-09,    4.81250e+00,
     1.36720505356788635253906250000e+00,    5.791195446259436674713169620190e-09,    4.84375e+00,
     1.36847469210624694824218750000e+00,    6.310345929394450693694852955619e-09,    4.87500e+00,
     1.36972880363464355468750000000e+00,    9.189514516165813329271081407916e-09,    4.90625e+00,
     1.37096767127513885498046875000e+00,    1.044676754867526478916455067153e-08,    4.93750e+00,
     1.37219156324863433837890625000e+00,    1.444291066122994092077186874377e-08,    4.96875e+00,
     1.37340076267719268798828125000e+00,    4.267823172872990676444961148651e-09,    5.00000e+00,
     1.37459550797939300537109375000e+00,    1.527387122824184692078603101451e-09,    5.03125e+00,
     1.37577605247497558593750000000e+00,    6.914999640531745497463320512676e-09,    5.06250e+00,
     1.37694266438484191894531250000e+00,    3.818378486586558829857026629662e-10,    5.09375e+00,
     1.37809556722640991210937500000e+00,    9.061011323442859641291551522494e-10,    5.12500e+00,
     1.37923499941825866699218750000e+00,    7.047511712721813814391809872058e-09,    5.15625e+00,
     1.38036119937896728515625000000e+00,    1.200237518564746200539758407614e-08,    5.18750e+00,
     1.38147440552711486816406250000e+00,    3.752431303860485847154508830984e-09,    5.21875e+00,
     1.38257481157779693603515625000e+00,    9.912328922024811167768568512557e-09,    5.25000e+00,
     1.38366265594959259033203125000e+00,    8.461972007611136551662947080744e-09,    5.28125e+00,
     1.38473814725875854492187500000e+00,    2.387134272079734864149462150428e-09,    5.31250e+00,
     1.38580147922039031982421875000e+00,    4.908768598138564463776776339150e-09,    5.34375e+00,
     1.38685286045074462890625000000e+00,    9.806976825422688109704248603488e-09,    5.37500e+00,
     1.38789249956607818603515625000e+00,    6.444437697102163472927543094628e-09,    5.40625e+00,
     1.38892057538032531738281250000e+00,    9.687117337622079724907822955494e-09,    5.43750e+00,
     1.38993729650974273681640625000e+00,    4.142746755845765070359169866481e-10,    5.46875e+00,
     1.39094282686710357666015625000e+00,    1.353147719826124443836432060856e-10,    5.50000e+00,
     1.39193734526634216308593750000e+00,    1.149271815404143250733190405928e-08,    5.53125e+00,
     1.39292106032371520996093750000e+00,    3.465104850475983881869885279409e-09,    5.56250e+00,
     1.39389412105083465576171875000e+00,    8.751972846933355826997338259422e-10,    5.59375e+00,
     1.39485669136047363281250000000e+00,    9.981895149582312209204422264489e-09,    5.62500e+00,
     1.39580896496772766113281250000e+00,    3.673990225978010422888335299850e-09,    5.65625e+00,
     1.39675107598304748535156250000e+00,    1.096911042189325662689037157861e-08,    5.68750e+00,
     1.39768320322036743164062500000e+00,    1.279477068249628351462798799313e-08,    5.71875e+00,
     1.39860551059246063232421875000e+00,    1.679496962688451331611428233573e-09,    5.75000e+00,
     1.39951811730861663818359375000e+00,    1.163902146698957855756715392016e-08,    5.78125e+00,
     1.40042120218276977539062500000e+00,    1.394951087425882225980348078085e-08,    5.81250e+00,
     1.40131491422653198242187500000e+00,    6.633460392900879147180110239037e-09,    5.84375e+00,
     1.40219937264919281005859375000e+00,    1.453627420047443672943364926769e-08,    5.87500e+00,
     1.40307474136352539062500000000e+00,    1.489477349711843444848571805625e-08,    5.90625e+00,
     1.40394115447998046875000000000e+00,    1.191512705053974257955257371087e-08,    5.93750e+00,
     1.40479874610900878906250000000e+00,    7.040537971277288777775128203578e-09,    5.96875e+00,
     1.40564763545989990234375000000e+00,    1.392036987860844340199580798810e-08,    6.00000e+00,
     1.40648797154426574707031250000e+00,    1.377265262781251842762842030113e-08,    6.03125e+00,
     1.40731988847255706787109375000e+00,    1.516454832781008004109129588904e-10,    6.06250e+00,
     1.40814347565174102783203125000e+00,    8.812392852367568475736726912337e-09,    6.09375e+00,
     1.40895888209342956542968750000e+00,    1.346304412954022002507925692872e-08,    6.12500e+00,
     1.40976624190807342529296875000e+00,    3.293815482142621061407439716301e-10,    6.15625e+00,
     1.41056562960147857666015625000e+00,    1.291535597312565950651550805849e-08,    6.18750e+00,
     1.41135720908641815185546875000e+00,    3.046912056781504556598516301656e-09,    6.21875e+00,
     1.41214105486869812011718750000e+00,    9.739797095250426171858489159963e-09,    6.25000e+00,
     1.41291730105876922607421875000e+00,    1.024031168077398483141533761956e-08,    6.28125e+00,
     1.41368605196475982666015625000e+00,    9.483176298330940700362142113524e-09,    6.31250e+00,
     1.41444741189479827880859375000e+00,    1.033869222335914782699115849033e-08,    6.34375e+00,
     1.41520148515701293945312500000e+00,    1.366085396849313009758338943949e-08,    6.37500e+00,
     1.41594839096069335937500000000e+00,    3.432973375068371408689440807613e-09,    6.40625e+00,
     1.41668820381164550781250000000e+00,    6.417824622786507475303697774616e-09,    6.43750e+00,
     1.41742104291915893554687500000e+00,    2.794932855413679169126588151130e-09,    6.46875e+00,
     1.41814699769020080566406250000e+00,    7.094306537397978039700989523716e-10,    6.50000e+00,
     1.41886615753173828125000000000e+00,    6.511618638791985801618497405100e-09,    6.53125e+00,
     1.41957862675189971923828125000e+00,    9.896556194686557004717711949810e-09,    6.56250e+00,
     1.42028449475765228271484375000e+00,    1.374603985595606071085278554348e-08,    6.59375e+00,
     1.42098386585712432861328125000e+00,    4.364874928050023392461446666118e-09,    6.62500e+00,
     1.42167679965496063232421875000e+00,    1.112308502143230238342818370506e-08,    6.65625e+00,
     1.42236341536045074462890625000e+00,    2.184350807916878859325266118764e-09,    6.68750e+00,
     1.42304377257823944091796875000e+00,    3.750899549292036644030269089181e-09,    6.71875e+00,
     1.42371796071529388427734375000e+00,    1.069120023462447529661072975031e-08,    6.75000e+00,
     1.42438608407974243164062500000e+00,    1.474877843219146090565202646625e-09,    6.78125e+00,
     1.42504818737506866455078125000e+00,    1.271139062462222761511135154115e-08,    6.81250e+00,
     1.42570438981056213378906250000e+00,    5.071595443040728669327516512176e-09,    6.84375e+00,
     1.42635473608970642089843750000e+00,    1.233054621889336855972812656957e-08,    6.87500e+00,
     1.42699933052062988281250000000e+00,    7.287424870077642925112396819355e-09,    6.90625e+00,
     1.42763823270797729492187500000e+00,    6.103270472013076602528007488299e-09,    6.93750e+00,
     1.42827151715755462646484375000e+00,    8.725177533766308578803575218566e-09,    6.96875e+00,
     1.42889925837516784667968750000e+00,    1.381556484973878257453719835909e-08,    7.00000e+00,
     1.42952154576778411865234375000e+00,    3.878408183331421157737222813987e-09,    7.03125e+00,
     1.43013842403888702392578125000e+00,    4.890586035833613242167706359834e-09,    7.06250e+00,
     1.43074996769428253173828125000e+00,    1.182210199236867169011076347577e-08,    7.09375e+00,
     1.43135626614093780517578125000e+00,    3.562621093048238216840177931212e-09,    7.12500e+00,
     1.43195736408233642578125000000e+00,    2.550855547300852132957145207900e-09,    7.15625e+00,
     1.43255333602428436279296875000e+00,    2.928837471379335503148003066060e-10,    7.18750e+00,
     1.43314424157142639160156250000e+00,    2.089160561552372671877910995624e-09,    7.21875e+00,
     1.43373014032840728759765625000e+00,    1.215630169904281565966988736486e-08,    7.25000e+00,
     1.43431112170219421386718750000e+00,    3.847142280027166839044400023082e-09,    7.28125e+00,
     1.43488721549510955810546875000e+00,    9.079536390908432116337422093224e-09,    7.31250e+00,
     1.43545849621295928955078125000e+00,    1.404952806211560556946013416408e-08,    7.34375e+00,
     1.43602503836154937744140625000e+00,    3.955616146055021283715500878067e-09,    7.37500e+00,
     1.43658687174320220947265625000e+00,    7.722515695860274460544521388517e-09,    7.40625e+00,
     1.43714407086372375488281250000e+00,    8.613979178524680791921236062657e-09,    7.43750e+00,
     1.43769669532775878906250000000e+00,    3.856753838848147089954125263076e-09,    7.46875e+00,
     1.43824478983879089355468750000e+00,    4.659431704406716747935481585539e-09,    7.50000e+00,
     1.43878841400146484375000000000e+00,    6.428527409096803478729704302162e-09,    7.53125e+00,
     1.43932762742042541503906250000e+00,    3.687602194584522205654788432971e-09,    7.56250e+00,
     1.43986247479915618896484375000e+00,    4.995962512345000737858412162894e-09,    7.59375e+00,
     1.44039301574230194091796875000e+00,    3.163461276481761353139212686569e-09,    7.62500e+00,
     1.44091929495334625244140625000e+00,    5.069541396358720258230994326320e-09,    7.65625e+00,
     1.44144137203693389892578125000e+00,    1.877242963101349535406770464928e-09,    7.68750e+00,
     1.44195927679538726806640625000e+00,    1.375263542407784571763662797591e-08,    7.71875e+00,
     1.44247309863567352294921875000e+00,    4.734282970760733099377292525125e-10,    7.75000e+00,
     1.44298283755779266357421875000e+00,    1.045580022307847213187143258234e-08,    7.78125e+00,
     1.44348858296871185302734375000e+00,    1.955330641876895861323269134488e-09,    7.81250e+00,
     1.44399034976959228515625000000e+00,    6.994297172085502553694421170635e-09,    7.84375e+00,
     1.44448819756507873535156250000e+00,    1.216657763016328285985080370259e-08,    7.87500e+00,
     1.44498218595981597900390625000e+00,    3.355001307363149651861224256277e-09,    7.90625e+00,
     1.44547232985496520996093750000e+00,    1.044838491216955419489400858952e-08,    7.93750e+00,
     1.44595870375633239746093750000e+00,    3.046649524822425965668741214886e-09,    7.96875e+00,
     1.44644132256507873535156250000e+00,    9.683056448848404342475880416525e-09,    8.00000e+00,
     1.5707963267948965579989817342720925807952880859375,       /* hi part of Pi/2 */
     0.6123233995736765886130329661375005291048747229615e-16,   /* lo part of Pi/2 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\filter.h ===
/***
* filter.h - IEEE exception filter routine
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       05-24-92  GDP   written
*       09-01-94  SKS   Change include file from <nt.h> to <windows.h>
*       01-11-95  GJF   Made instr_info_table[] static.
*       02-07-95  CFW   assert -> _ASSERTE.
*       04-07-95  SKS   Clean up prototype of param3 to _fpieee_flt()
*       03-01-98  PLS   move the definitions from filter.c to filter.h, so
*                       filter_simd.c can use it.
*******************************************************************************/


//
// Location codes
//
//
// By convention the first eight location codes contain the number of
// a floating point register, i.e., ST0 through ST7 have the values
// 0 to 7 respectively. The other codes have arbitrary values:
//
//  CODE    MEANING
//   STi    (0<=i<8) Floating point stack location ST(i)
//   REG    FP stack location is in the REG field of the instruction
//   RS     FP status register
//   M16I   Memory location (16bit int)
//   M32I   Memory location (32bit int)
//   M64I   Memory location (64bit int)
//   M32R   Memory location (32bit real)
//   M64R   Memory location (64bit real)
//   M80R   Memory location (80bit real)
//   M80D   Memory location (80bit packed decimal)
//   Z80R   Implied Zero Operand
//   M128R_M32R  Memory location (128bit memory location, 32bit real)
//   M128R_M64R  Memory location (128bit memory location, 64bit real) 
//   MMX    64-bit multimedia register
//   XMMI   128-bit multimedia register
//   IMM8   immedidate 8-bit operand
//   INV    Invalid, unavailable, or unused
//

#define ST0         0x00
#define ST1         0x01
#define ST2         0x02
#define ST3         0x03
#define ST4         0x04
#define ST5         0x05
#define ST6         0x06
#define ST7         0x07
#define REG         0x08
#define RS          0x09
#define M16I        0x0a
#define M32I        0x0b
#define M64I        0x0c
#define M32R        0x0d
#define M64R        0x0e
#define M80R        0x0f
#define M80D        0x10
#define Z80R        0x11
#define M128_M32R   0x12 //Xmmi
#define M128_M64R   0x13 //Xmmi
#define MMX         0x14 //Xmmi
#define XMMI        0x15 //Xmmi
#define IMM8        0x16 //Xmmi
#define XMMI2       0x17 //Xmmi2
#define M64R_64     0x19 //Xmmi2
#define M128_M32I   0x1a //Xmmi2
#define XMMI_M32I   0x1b //Xmmi2
#define LOOKUP      0x1e //Xmmi2
#define INV         0x1f
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\exp_pentium4.asm ===
;//
;//               INTEL CORPORATION PROPRIETARY INFORMATION
;//  This software is supplied under the terms of a license agreement or
;//  nondisclosure agreement with Intel Corporation and may not be copied
;//  or disclosed except in accordance with the terms of that agreement.
;//  Copyright (c) 2000 Intel Corporation. All Rights Reserved.
;//
;//
;  exp_wmt.asm
;
;  double exp(double);
;
;  Initial version: 11/30/2000
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; This is a new version using just one table. Reduction by log2/64    ;;
;; A non-standard table is used. Normally, we store T,t where          ;;
;; T+t  =  exp(jlog2/64) to high precision. This implementation        ;;
;; stores  T,d where d = t/T. This shortens the latency by 1 FP op     ;;
;; This version uses two tricks from Andrey. First, we merge two       ;;
;; integer-based tests for exception filtering into 1. Second, instead ;;
;; of using sign(X)2^52 as a shifter, we use S = 2^52 * 1.10000..000   ;;
;; as the shifter. This will give bit pattern of the 2's complement of ;;
;; N in trailing bits of S + W, W = X * 64/log2.                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.686P
.387
.XMM
.MODEL FLAT,C

EXTRN C __libm_error_support : NEAR  

CONST SEGMENT PARA PUBLIC USE32 'CONST'
ALIGN 16

smask   DQ 8000000000000000H, 8000000000000000H ; mask to get sign bit
emask   DQ 0FFF0000000000000H, 0FFF0000000000000H
mmask   DQ 00000000FFFFFFC0H, 00000000FFFFFFC0H ; mask off bottom 6 bits
bias    DQ 000000000000FFC0H, 000000000000FFC0H	; 1023 shifter left 6 bits
Shifter DQ 4338000000000000H, 4338000000000000H	; 2^52+2^51|2^52+2^51
twom60  DQ 3C30000000000000H, 3C30000000000000H ; 2^(-60)


cv      DQ 40571547652b82feH, 40571547652b82feH		; invL|invL
        DQ 3F862E42FEFA0000H, 3F862E42FEFA0000H         ; log2_hi|log2_hi
        DQ 3D1CF79ABC9E3B3AH, 3D1CF79ABC9E3B3AH         ; log2_lo|log2_lo

	DQ 3F811074B1D108E5H, 3FC555555566A45AH		; p2|p4
	DQ 3FA5555726ECED80H, 3FDFFFFFFFFFE17BH		; p1|p3

;-------Table d, T  so that movapd gives [ T | d ]
;-------Note that the exponent field of T is set to 000
Tbl_addr  DQ 0000000000000000H, 0000000000000000H
          DQ 3CAD7BBF0E03754DH, 00002C9A3E778060H
          DQ 3C8CD2523567F613H, 000059B0D3158574H
          DQ 3C60F74E61E6C861H, 0000874518759BC8H
          DQ 3C979AA65D837B6CH, 0000B5586CF9890FH
          DQ 3C3EBE3D702F9CD1H, 0000E3EC32D3D1A2H
          DQ 3CA3516E1E63BCD8H, 00011301D0125B50H
          DQ 3CA4C55426F0387BH, 0001429AAEA92DDFH
          DQ 3CA9515362523FB6H, 000172B83C7D517AH
          DQ 3C8B898C3F1353BFH, 0001A35BEB6FCB75H
          DQ 3C9AECF73E3A2F5FH, 0001D4873168B9AAH
          DQ 3C8A6F4144A6C38DH, 0002063B88628CD6H
          DQ 3C968EFDE3A8A894H, 0002387A6E756238H
          DQ 3C80472B981FE7F2H, 00026B4565E27CDDH
          DQ 3C82F7E16D09AB31H, 00029E9DF51FDEE1H
          DQ 3C8B3782720C0AB3H, 0002D285A6E4030BH
          DQ 3C834D754DB0ABB6H, 000306FE0A31B715H
          DQ 3C8FDD395DD3F84AH, 00033C08B26416FFH
          DQ 3CA12F8CCC187D29H, 000371A7373AA9CAH
          DQ 3CA7D229738B5E8BH, 0003A7DB34E59FF6H
          DQ 3C859F48A72A4C6DH, 0003DEA64C123422H
          DQ 3CA8B846259D9205H, 0004160A21F72E29H
          DQ 3C4363ED60C2AC12H, 00044E086061892DH
          DQ 3C6ECCE1DAA10379H, 000486A2B5C13CD0H
          DQ 3C7690CEBB7AAFB0H, 0004BFDAD5362A27H
          DQ 3CA083CC9B282A09H, 0004F9B2769D2CA6H
          DQ 3CA509B0C1AAE707H, 0005342B569D4F81H
          DQ 3C93350518FDD78EH, 00056F4736B527DAH
          DQ 3C9063E1E21C5409H, 0005AB07DD485429H
          DQ 3C9432E62B64C035H, 0005E76F15AD2148H
          DQ 3CA0128499F08C0AH, 0006247EB03A5584H
          DQ 3C99F0870073DC06H, 0006623882552224H
          DQ 3C998D4D0DA05571H, 0006A09E667F3BCCH
          DQ 3CA52BB986CE4786H, 0006DFB23C651A2EH
          DQ 3CA32092206F0DABH, 00071F75E8EC5F73H
          DQ 3CA061228E17A7A6H, 00075FEB564267C8H
          DQ 3CA244AC461E9F86H, 0007A11473EB0186H
          DQ 3C65EBE1ABD66C55H, 0007E2F336CF4E62H
          DQ 3C96FE9FBBFF67D0H, 00082589994CCE12H
          DQ 3C951F1414C801DFH, 000868D99B4492ECH
          DQ 3C8DB72FC1F0EAB4H, 0008ACE5422AA0DBH
          DQ 3C7BF68359F35F44H, 0008F1AE99157736H
          DQ 3CA360BA9C06283CH, 00093737B0CDC5E4H
          DQ 3C95E8D120F962AAH, 00097D829FDE4E4FH
          DQ 3C71AFFC2B91CE27H, 0009C49182A3F090H
          DQ 3C9B6D34589A2EBDH, 000A0C667B5DE564H
          DQ 3C95277C9AB89880H, 000A5503B23E255CH
          DQ 3C8469846E735AB3H, 000A9E6B5579FDBFH
          DQ 3C8C1A7792CB3387H, 000AE89F995AD3ADH
          DQ 3CA22466DC2D1D96H, 000B33A2B84F15FAH
          DQ 3CA1112EB19505AEH, 000B7F76F2FB5E46H
          DQ 3C74FFD70A5FDDCDH, 000BCC1E904BC1D2H
          DQ 3C736EAE30AF0CB3H, 000C199BDD85529CH
          DQ 3C84E08FD10959ACH, 000C67F12E57D14BH
          DQ 3C676B2C6C921968H, 000CB720DCEF9069H
          DQ 3C93700936DF99B3H, 000D072D4A07897BH
          DQ 3C74A385A63D07A7H, 000D5818DCFBA487H
          DQ 3C8E5A50D5C192ACH, 000DA9E603DB3285H
          DQ 3C98BB731C4A9792H, 000DFC97337B9B5EH
          DQ 3C74B604603A88D3H, 000E502EE78B3FF6H
          DQ 3C916F2792094926H, 000EA4AFA2A490D9H
          DQ 3C8EC3BC41AA2008H, 000EFA1BEE615A27H
          DQ 3C8A64A931D185EEH, 000F50765B6E4540H
          DQ 3C77893B4D91CD9DH, 000FA7C1819E90D8H


ONE_val  DQ 3ff0000000000000H ; 1.0

EMIN     DQ 0010000000000000H

MAX_ARG  DQ 40862e42fefa39efH

MIN_ARG  DQ 0c086232bdd70000H

INF      DQ 7ff0000000000000H

ZERO     DQ 0

XMAX	 DQ 7fefffffffffffffH

XMIN	 DQ 0010000000000000H

Sm_Thres    DQ 3C3000003C300000H  ; DP 2^(-60)
Del_Thres   DQ 045764CA045764CAH  ; DP 1080*log(2) - 2^(-60), hi part

ALIGN 16
CONST ENDS

_TEXT SEGMENT PARA PUBLIC USE32 'CODE'
ALIGN 16

PUBLIC _exp_pentium4, _CIexp_pentium4 
_CIexp_pentium4 PROC NEAR
	push	    ebp
	mov         ebp, esp
	sub         esp, 8                          ; for argument DBLSIZE
	and         esp, 0fffffff0h
	fstp        qword ptr [esp]
	movq        xmm0, qword ptr [esp]
	call        start
	leave
	ret
_exp_pentium4 label proc
	; load *|x in XMM0
    	movlpd xmm0, 4[esp]  
start:
	unpcklpd xmm0,xmm0

        ; load Inv_L pair
        movapd xmm1, QWORD PTR [cv]
        ; load Shifter
        movapd xmm6, QWORD PTR [Shifter]
        ; load L_hi pair
        movapd xmm2, QWORD PTR [cv+16]
        ; load L_lo pair
        movapd xmm3, QWORD PTR [cv+32]

	pextrw eax, xmm0,3
        and eax,7FFFH 
	; x>=2^{10} ? (i.e. 2^{10}-eps-x<0)
	mov edx, 408fH
	sub edx, eax
	; avoid underflow on intermediate calculations (|x|<2^{-54} ?)
	sub eax, 3c90H
	or edx, eax
	cmp edx, 80000000H
	; small input or UF/OF
	jae RETURN_ONE

	; xmm1=Inv_L*x|Inv_L*x
	mulpd  xmm1,xmm0
	; xmm1=Inv_L*x+Shifter| Inv_L*x+Shifter
	addpd  xmm1,xmm6
        ; xmm7 contains bit pattern of N
        movapd xmm7,xmm1
	; xmm1=N
	subpd xmm1,xmm6

	; xmm2=L_hi*round_to_int(Inv_L*x)|L_hi*round_to_int(Inv_L*x) ; N_L_hi
	mulpd xmm2,xmm1

        ; [p2|p4]
        MOVAPD xmm4,[cv+48]

	; xmm3=L_lo*round_to_int(Inv_L*x)|L_lo*round_to_int(Inv_L*x) ; N_L_lo
	mulpd xmm3,xmm1

        ; [p1|p3]
        MOVAPD xmm5,[cv+64]

	; xmm0=x-xmm2	   ; R := X |-| N_L_hi
	subpd xmm0,xmm2

        ; set eax <-- n, ecx <--j
        movd   eax,xmm7
        mov    ecx,eax
        and    ecx,0000003FH
      
        ; get offset for [T,d]
        shl ecx,4
        ; eax,edx <-- m
        sar eax,6
        mov edx,eax

	; xmm0-=xmm3       ; R := R |-| N_L_lo
	subpd xmm0,xmm3
        
        ; xmm2 <- [T,d]
        movapd xmm2,[ecx+Tbl_addr]
        
	; xmm4=p2*R|p4*R
	mulpd xmm4,xmm0

        MOVAPD xmm1,xmm0
        MULPD  xmm0,xmm0

	; xmm5=p1+p2*R|p3+p4*R
	addpd xmm5,xmm4
        MULSD xmm0,xmm0       
        
        ; get xmm1 <-- [R|R+d]
        addsd    xmm1,xmm2

        ; xmm2 <-- [T|T]
        unpckhpd xmm2,xmm2
        ; xmm7 <-- exponent of 2^m
        movdqa   xmm6,[mmask]
        pand     xmm7,xmm6
        movdqa   xmm6,[bias]
        paddq    xmm7,xmm6
        psllq    xmm7,46

	; xmm5=[P_hi | P_lo]
	mulpd xmm0,xmm5
        ; xmm1 <- [R |d+R+P_lo]
	addsd xmm1,xmm0
       
        ; xmm2 is 2^m T
        ORPD     xmm2,xmm7

        ; xmm5 <- [P_hi | P_hi]
        unpckhpd xmm0,xmm0

        ; xmm5 <-- [P_hi | d+R+P ]
        addsd    xmm0,xmm1

        ; make sure -894 <= m <= 1022 
        ; before we use the exponent in xmm7
        ; test by unsigned comp of  m+894 with 1022+894
        add edx,894
        cmp edx,1916

        ja  ADJUST

        mulsd    xmm0,xmm2
        sub esp, 16
        addsd    xmm0,xmm2

        movlpd    QWORD PTR [esp+4], xmm0       ; return result
        fld       QWORD PTR [esp+4]             ;
        add esp, 16
	ret

ADJUST:
;---xmm5 contains [*| d+R+P]
;---xmm2 contains [*| T ] where is exponent field is not correct
;---eax still contain the correct m
;---so we split m into m1 and m2, m1+m2 = m. Make T with exponent 2^m1 by
;---integer manipulation, and multiply final result by 2^m2

	; overflow or underflow
	sub esp,18

	fstcw WORD PTR [esp+16]
	mov dx,WORD PTR [esp+16]
	; set pc=64 bits
	or dx,300H 
	mov WORD PTR [esp],dx
	fldcw WORD PTR [esp]

        ; eax <-- m1 = m/2, edx <-- m2 = m - m1
        mov edx,eax
        sar eax,1
        sub edx,eax

        ; T with exponent field zerorized
        movdqa xmm6,[emask]
        pandn  xmm6,xmm2
        add    eax,1023
        movd   xmm3,eax
        psllq  xmm3,52
	; xmm6=T*2^m1
        ORPD   xmm6,xmm3

        add    edx,1023
        movd   xmm4,edx
        psllq  xmm4,52

	; load P on FP stack
	movlpd QWORD PTR [esp], xmm0
	fld QWORD PTR [esp]

	; load T'=T*2^m1 on FP stack
	movlpd QWORD PTR [esp+8], xmm6
	fld QWORD PTR [esp+8]

	; T'*P
	fmul st(1), st(0)
	; T'+T'*P
	faddp st(1), st(0)

	; load 2^m2 on FP stack
	movlpd QWORD PTR [esp], xmm4
	fld QWORD PTR [esp]

        ; final calculation: 2^m2*(T'+T'*P)
	fmulp st(1), st(0)

	; store result in memory, then xmm0
	fstp QWORD PTR [esp]
	movlpd xmm0, QWORD PTR [esp] 

	; restore FPCW
	fldcw WORD PTR [esp+16]
	add esp,18

;	mov ecx, DWORD PTR [esp+8]
;	; if 0<x<2^{10}*ln2, return
;	cmp ecx, 40862e42H
;	jb RETURN
;	ja CONT0
	pextrw ecx, xmm0, 3
	and ecx, 7ff0H
	cmp ecx, 7ff0H
	jae OVERFLOW
	cmp ecx, 0
	jz UNDERFLOW
	jmp RETURN

	; load lower 32 bits of x
;	mov edx, DWORD PTR [esp+4]
;	cmp edx, 0fefa39efH
;	jb RETURN
;	jmp OVERFLOW

CONT0:
	; OF/UF
	; OF ?
	cmp ecx,80000000H
	jb OVERFLOW

	; x<(2-2^{10})*ln2 ?
	cmp ecx, 0c086232bH
	jb RETURN
	ja UNDERFLOW
	mov edx, DWORD PTR [esp+4]
	cmp edx, 0fefa39efH
	jb RETURN
	jmp UNDERFLOW		

OVERFLOW:
	;OF
	mov edx,14
	jmp CALL_LIBM_ERROR

UNDERFLOW:
	mov edx, 15

CALL_LIBM_ERROR:
	;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
	sub esp, 28
	movlpd QWORD PTR [esp+16], xmm0
	mov DWORD PTR [esp+12],edx
	mov edx, esp
	add edx,16
	mov DWORD PTR [esp+8],edx
	add edx,16
	mov DWORD PTR [esp+4],edx
	mov DWORD PTR [esp],edx
	call NEAR PTR __libm_error_support
	movlpd xmm0, QWORD PTR [esp+16]
    	add esp, 28

RETURN:
        sub esp, 16
        movlpd    QWORD PTR [esp+4], xmm0       ; return result
        fld       QWORD PTR [esp+4]             ;
        add esp, 16
	ret


SPECIAL_CASES: 
;  code to be added, but OK for now
;  Need to resolve several cases
;
;  Case 1: Argument is close to zero ( |X| < 2^(-60) )
;  Compute 1 + X and return the result
;  This will allow the appropriate action to take place.
;  For example, in directed rounding, the correct number below/above 1 is returned.
;  If X is denormalized, and that DAE is set, then we will be consistant with DAE,
;  that is X is treated as zero and directed rounding will not affect the result.
;  This action also takes care of the case X = 0.
;
;  Case 2: |X| is large but finite
;  Generate overflow/underflow by a simple arithmetic operation. This is also a place
;  holder for various exception handling protocol.
;
;  Case 3: X is +-inf. Return +inf or +0 exactly without exception
;
;  Case 4: X is s/q NaN
;


OF_UF:
	; x=infinity/NaN ?
	cmp eax, 7ff00000H
	jae INF_NAN

        mov eax,[esp+8]
	cmp eax,80000000H
	jae UF

	movlpd xmm0, QWORD PTR [XMAX]
	mulsd xmm0, xmm0
	mov edx,14
	jmp CALL_LIBM_ERROR

UF:	movlpd xmm0, QWORD PTR [XMIN]
	mulsd xmm0, xmm0
	mov edx,15
	jmp CALL_LIBM_ERROR

INF_NAN:
	; load lower 32 bits of x
	mov edx, DWORD PTR [esp+4]
	cmp eax, 7ff00000H
	ja NaN_arg
	cmp edx,0
	jnz NaN_arg

	mov eax,DWORD PTR [esp+8]
	cmp eax,7ff00000H
	jne INF_NEG

	; +INF
	fld QWORD PTR [INF]
	ret

INF_NEG:
	; -INF
	fld QWORD PTR [ZERO]
	ret

NaN_arg:   
        ; movlpd xmm0, 4[esp]
        ; addsd xmm0,xmm0
	; sub esp, 16
	; movlpd 4[esp],xmm0
	   
    	; fld  QWORD PTR [esp+4]            ; return x
	; add esp, 16
    	; ret
	mov edx,1002
	jmp CALL_LIBM_ERROR
 
RETURN_ONE:
        ; load hi-part of x
        mov eax,[esp+8]
        and eax,7FFFFFFFH
	; large absolute value (>=2^{10}) ?
        cmp eax, 40900000H
	jae OF_UF

	; small inputs, return 1
	movlpd xmm0, 4[esp]
	; set D flag
	addsd xmm0, QWORD PTR [ONE_val]
	sub esp, 16
	movlpd 4[esp],xmm0
	   
    	fld  QWORD PTR [esp+4]            ; return x
	add esp, 16
	ret

_CIexp_pentium4 ENDP

ALIGN 16
_TEXT ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\debug.h ===
/***
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
* Module Name:
*
*    debug.h
*
* Abstract:
*
*    This module contains XMMI debugging definitions.
*   
* Author:
*
*    Ping L. Sager
*
* Revision History:
*
--*/

#include <stdio.h>
#include <conio.h>

extern
ULONG DebugImm8;
extern 
ULONG DebugFlag;
extern 
ULONG Console;
extern
ULONG NotOk;

//Debugging
#define XMMI_INFO        0x00000001
#define XMMI_ERROR       0x00000002
#define XMMI_WARNING     0x00000004


void print_Rounding(PXMMI_ENV XmmiEnv);

void print_Precision(PXMMI_ENV XmmiEnv);

void print_CauseEnable(PXMMI_ENV XmmiEnv);

void print_Status(PXMMI_ENV XmmiEnv);

void print_Operations(PXMMI_ENV XmmiEnv);

void print_Operand1(PXMMI_ENV XmmiEnv);

void print_Operand2(PXMMI_ENV XmmiEnv);

void print_Result(PXMMI_ENV XmmiEnv, BOOL Exception);

void print_FPIEEE_RECORD_EXCEPTION (PXMMI_ENV XmmiEnv);

void print_FPIEEE_RECORD_NO_EXCEPTION (PXMMI_ENV XmmiEnv);

void print_FPIEEE_RECORD (PXMMI_ENV XmmiEnv);
    
void dump_Data(PTEMP_EXCEPTION_POINTERS p);

void dump_DataXMMI2(PTEMP_EXCEPTION_POINTERS p);

void dump_Control(PTEMP_EXCEPTION_POINTERS p);

void dump_XmmiFpEnv(PXMMI_FP_ENV XmmiFpEnv);

void dump_fpieee_record(_FPIEEE_RECORD *pieee);

void dump_OpLocation(POPERAND Operand);

void dump_Format(_FPIEEE_VALUE *Operand);

void print_FPIEEE_RECORD_EXCEPTION1 (PXMMI_ENV, ULONG, ULONG, ULONG);
void print_FPIEEE_RECORD_EXCEPTION2 (PXMMI_ENV, ULONG, ULONG);
void print_FPIEEE_RECORD_EXCEPTION3 (PXMMI_ENV, ULONG, ULONG);

void print_FPIEEE_RECORD_NO_EXCEPTION1 (PXMMI_ENV, ULONG, ULONG, ULONG);
void print_FPIEEE_RECORD_NO_EXCEPTION2 (PXMMI_ENV, ULONG, ULONG);
void print_FPIEEE_RECORD_NO_EXCEPTION3 (PXMMI_ENV, ULONG, ULONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\filter_simd.c ===
/***
* filter_simd.c - IEEE exception filter routine
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Handles XMMI SIMD numeric exceptions
*
*Revision History:
*       03-01-98  PLS   written.  
*       01-11-99  PLS   added XMMI2 support.
*       01-12-99  PLS   included XMMI2 conversion support.
*       11-30-99  PML   Compile /Wp64 clean.
*       07-31-00  PLS   Placeholder for DAZ bit set
*       11-02-00  PLS   DAZ is supported by XMMI Emulation Code, 
*                       remove DAZ placeholder
*
*******************************************************************************/

#include <trans.h>
#include <windows.h>
#include <dbgint.h>
#include <fpieee.h>
#include "filter.h"
#include "xmmi_types.h"
#include "temp_context.h"
#ifdef _XMMI_DEBUG
#include "debug.h"
#endif

#pragma warning(disable:4311 4312)      // x86 specific, ignore /Wp64 warnings

#define InitExcptFlags(flags)       { \
        (flags).Inexact = 0; \
        (flags).Underflow = 0; \
        (flags).Overflow = 0; \
        (flags).ZeroDivide = 0; \
        (flags).InvalidOperation = 0; \
} 

__inline
void
FxSave(
    PFLOATING_EXTENDED_SAVE_AREA NpxFrame
    )
{
    _asm {
        mov eax, NpxFrame
        ;fxsave [eax]
        _emit  0fh
        _emit  0aeh
        _emit  0h
    }
}

__inline
void
FxRstor(
    PFLOATING_EXTENDED_SAVE_AREA NpxFrame
    )
{
    _asm {
        mov eax, NpxFrame
        ;fxrstor [eax]
        _emit  0fh
        _emit  0aeh
        _emit  8h
    }
}

extern 
ULONG 
XMMI_FP_Emulation(
    PXMMI_ENV XmmiEnv);

extern 
ULONG 
XMMI2_FP_Emulation(
    PXMMI_ENV XmmiEnv);

void
LoadOperand(
    BOOLEAN fScalar,
    ULONG OpLocation,
    ULONG OpReg,
    POPERAND pOperand,
    PTEMP_CONTEXT pctxt);

ULONG
LoadImm8(
    PXMMIINSTR Instr);

void
AdjustExceptionResult(
    ULONG OriginalOperation,
    PXMMI_ENV XmmiEnv);

void 
UpdateResult(
    POPERAND pOperand,
    PTEMP_CONTEXT pctxt,
    ULONG EFlags);

BOOLEAN
ValidateResult(
    PXMMI_FP_ENV XmmiFpEnv);

static ULONG  ax0  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  ax8  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  ax32 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  cx0  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  cx8  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  cx32 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  dx0  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  dx8  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  dx32 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  bx0  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  bx8  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  bx32 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  sib0 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  sib8 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  sib32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  d32  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  bp8  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  bp32 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  si0  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  si8  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  si32 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  di0  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  di8  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  di32 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  reg  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );

//
//The following 4 tables are used to parse the instructions - 0F/F3 0F/66 0F/F2 0F Opcodes.
//(XMMI/XMMI2 Opcodes are sparse.  Instead of having 1 big table, 4 tables are created,
// grouped by opcodes).
//Note: For the Scalar form of the instruction, it is always looked up in the table as 
//      XXXXPS for XMMI, XXXXPD for XMMI2. fScalar indicates if the instruction is a 
//      scalar or not. instrIndex indicates if the instruction is a XMMI or XMMI2.  
//      Scalar operation code == non-Scalar operation code + 1 (1st col in the table), 
//      Scalar operand location: scalar form of the non-Scalar operand.
//Note: The NumArgs is a 2 bit fields in the table, the actual value is NumArgs+1.
//
//
//InstInfoTableX is added to assist the parsing of the XMMI2 conversion instructions.
//Scalar rule does not apply to some of the XMMI2 conversion instructions.  Additional
//information is needed to parse the instruction.  In such case, one of the 4 tables
//(based on the Opcode) is looked up, if Op1Location has a value of LOOKUP, then,
//Op2Location is used as index to InstInfoTableX.  The entry in InstInfoTableX describes
//the real parsing rule for the instruction.  
//
//This table is indexed by 
//   (ULONG Op2Location:5) // Location of 2nd operand
//if (ULONG Op1Location:5) // Location of 1st operand has a value of LOOKUP
//from XMMI_INSTR_INFO. 
//
//Note: the size is 5, therefore, the max entries in this table can only be 32.
//

//
// Opcode 5x table
//
static XMMI_INSTR_INFO InstInfoTable5X[64] = {
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_SQRTPS,    INV,  XMMI,       0,     XMMI, 3},               // OP_SQRTSS    F3 51 (XMMI)
 {OP_SQRTPD,    INV,  XMMI2,      0,     XMMI2,1},               // OP_SQRTSD    F2 51 (XMMI2)
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_ADDPS,     XMMI, XMMI,       0,     XMMI, 3},               // OP_ADDSS     F3 58 (XMMI)
 {OP_ADDPD,     XMMI2,XMMI2,      0,     XMMI2,1},               // OP_ADDSD     F2 58 (XMMI2)
 {OP_MULPS,     XMMI, XMMI,       0,     XMMI, 3},               // OP_MULSS     F3 59 (XMMI)
 {OP_MULPD,     XMMI2,XMMI2,      0,     XMMI2,1},               // OP_MULSD     F2 59 (XMMI2)
 {OP_CVTPS2PD,  LOOKUP,0,         0,     0,    0},               // OP_CVTSS2SD  F3 5A (XMMI2)
 {OP_CVTPD2PS,  INV,  XMMI2,      0,     XMMI, 1},               // OP_CVTSD2SS  F2 5A (XMMI2)
 {OP_CVTDQ2PS,  LOOKUP,4,         0,     0,    0},               // OP_CVTTPS2DQ F3 5B (XMMI2)
 {OP_CVTPS2DQ,  LOOKUP,6,         0,     0,    0},               // NONE               (XMMI2)
 {OP_SUBPS,     XMMI, XMMI,       0,     XMMI, 3},               // OP_SUBSS     F3 5C (XMMI)
 {OP_SUBPD,     XMMI2,XMMI2,      0,     XMMI2,1},               // OP_SUBSD     F2 5C (XMMI2)
 {OP_MINPS,     XMMI, XMMI,       0,     XMMI, 3},               // OP_MINSS     F3 5D (XMMI)
 {OP_MINPD,     XMMI2,XMMI2,      0,     XMMI2,1},               // OP_MINSD     F2 5D (XMMI2)
 {OP_DIVPS,     XMMI, XMMI,       0,     XMMI, 3},               // OP_DIVSS     F3 5E (XMMI)
 {OP_DIVPD,     XMMI2,XMMI2,      0,     XMMI2,1},               // OP_DIVSD     F2 5E (XMMI2)
 {OP_MAXPS,     XMMI, XMMI,       0,     XMMI, 3},               // OP_MAXSS     F3 5F (XMMI)
 {OP_MAXPD,     XMMI2,XMMI2,      0,     XMMI2,1},               // OP_MAXSD     F2 5F (XMMI2)

 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_SQRTPS,    INV,  M128_M32R,  0,     XMMI, 3},               // OP_SQRTSS    M32R    F3 51 (XMMI)
 {OP_SQRTPD,    INV,  M128_M64R,  0,     XMMI2,1},               // OP_SQRTSD    M64R_64 F2 51 (XMMI2)
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_ADDPS,     XMMI, M128_M32R,  0,     XMMI, 3},               // OP_ADDSS     M32R    F3 58 (XMMI)
 {OP_ADDPD,     XMMI2,M128_M64R,  0,     XMMI2,1},               // OP_ADDSD     M64R_64 F2 58 (XMMI2)
 {OP_MULPS,     XMMI, M128_M32R,  0,     XMMI, 3},               // OP_MULSS     M32R    F3 59 (XMMI)
 {OP_MULPD,     XMMI2,M128_M64R,  0,     XMMI2,1},               // OP_MULSD     M64R_64 F2 59 (XMMI2)
 {OP_CVTPS2PD,  LOOKUP,2,         0,     0,    0},               // OP_CVTSS2SD  M32R    F3 5A (XMMI2)
 {OP_CVTPD2PS,  INV,  M128_M64R,  0,     XMMI, 1},               // OP_CVTSD2SS  M64R_64 F2 5A (XMMI2)
 {OP_CVTDQ2PS,  LOOKUP,8,         0,     0,    0},               // OP_CVTTPS2DQ         F3 5B (XMMI2)
 {OP_CVTPS2DQ,  LOOKUP,10,        0,     0,    0},               // NONE                       (XMMI2)
 {OP_SUBPS,     XMMI, M128_M32R,  0,     XMMI, 3},               // OP_SUBSS     M32R    F3 5C (XMMI)
 {OP_SUBPD,     XMMI2,M128_M64R,  0,     XMMI2,1},               // OP_SUBSD     M64R_64 F2 5C (XMMI2)
 {OP_MINPS,     XMMI, M128_M32R,  0,     XMMI, 3},               // OP_MINSS     M32R    F3 5D (XMMI)
 {OP_MINPD,     XMMI2,M128_M64R,  0,     XMMI2,1},               // OP_MINSD     M64R_64 F2 5D (XMMI2)
 {OP_DIVPS,     XMMI, M128_M32R,  0,     XMMI, 3},               // OP_DIVSS     M32R    F3 5E (XMMI)
 {OP_DIVPD,     XMMI2,M128_M64R,  0,     XMMI2,1},               // OP_DIVSD     M64R_64 F2 5E (XMMI2)
 {OP_MAXPS,     XMMI, M128_M32R,  0,     XMMI, 3},               // OP_MAXSS     M32R    F3 5F (XMMI)
 {OP_MAXPD,     XMMI2,M128_M64R,  0,     XMMI2,1},               // OP_MAXSD     M64R_64 F2 5F (XMMI2)
                                                                 // M128_M32R -> M32R
                                                                 // M128_M64R -> M64R_64
};

//
// Opcode Cx table
//
static XMMI_INSTR_INFO InstInfoTableCX[64] = {
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_CMPPS,     XMMI, XMMI,       HAS_IMM8, XMMI, 3},            // OP_CMPSS  F3 C2 (XMMI)
 {OP_CMPPD,     XMMI2,XMMI2,      HAS_IMM8, XMMI2,1},            // OP_CMPSD  F2 C2 (XMMI2)
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved

 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_CMPPS,     XMMI, M128_M32R,  HAS_IMM8,  XMMI, 3},           // OP_CMPSS  M32R    F3 C2 (XMMI)
 {OP_CMPPD,     XMMI2,M128_M64R,  HAS_IMM8,  XMMI2,1},           // OP_CMPSD  M64R_64 F2 C2 (XMMI2)
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
                                                                 // M128_M32R -> M32R
                                                                 // M128_M64R -> M64R_64
};

//
// Opcode 2x table
//
static XMMI_INSTR_INFO InstInfoTable2X[64] = {
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_CVTPI2PS,  INV,  MMX,        0,     XMMI, 1},               // OP_CVTSI2SS  REG F3 2A (XMMI)
 {OP_UNSPEC,    0,    0,          0,     0,    0},     
 {OP_UNSPEC,    0,    0,          0,     0,    0},     
 {OP_UNSPEC,    0,    0,          0,     0,    0},     
 {OP_CVTTPS2PI, INV,  XMMI,       0,     MMX,  1},               // OP_CVTTSS2SI REG F3 2C (XMMI)
 {OP_CVTTPD2PI, INV,  XMMI2,      0,     MMX,  1},               // OP_CVTTSD2SI REG F2 2C (XMMI2)
 {OP_CVTPS2PI,  INV,  XMMI,       0,     MMX,  1},               // OP_CVTSS2SI  REG F3 2D (XMMI) 
 {OP_CVTPD2PI,  INV,  XMMI2,      0,     MMX,  1},               // OP_CVTSD2SI  REG F2 2D (XMMI2) 
 {OP_UCOMISS,   XMMI, XMMI,       0,     RS,   0},               // NONE                   (XMMI)
 {OP_UCOMISD,   XMMI2,XMMI2,      0,     RS,   0},               // NONE                   (XMMI2)
 {OP_COMISS,    XMMI, XMMI,       0,     RS,   0},               // NONE                   (XMMI)
 {OP_COMISD,    XMMI2,XMMI2,      0,     RS,   0},               // NONE                   (XMMI2)

 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_CVTPI2PS,  INV,  M64I,       0,     XMMI, 1},               // OP_CVTSI2SS  M32I     F3 2A (XMMI)
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},     
 {OP_UNSPEC,    0,    0,          0,     0,    0},     
 {OP_CVTTPS2PI, INV,  M64R,       0,     MMX,  1},               // OP_CVTTSS2SI M32R REG F3 2C (XMMI)
 {OP_CVTTPD2PI, INV,  M128_M64R,  0,     MMX,  1},               // OP_CVTTSD2SI M64_64R REG F2 2C (XMMI2)
 {OP_CVTPS2PI,  INV,  M64R,       0,     MMX,  1},               // OP_CVTSS2SI  M32R REG F3 2D (XMMI) 
 {OP_CVTPD2PI,  INV,  M128_M64R,  0,     MMX,  1},               // OP_CVTSD2SI  M64_64R REG F2 2D (XMMI2) 
 {OP_UCOMISS,   XMMI, M32R,       0,     XMMI, 0},               // NONE                        (XMMI)
 {OP_UCOMISD,   XMMI2,M64R_64,    0,     XMMI2,0},               // NONE                        (XMMI2)
 {OP_COMISS,    XMMI, M32R,       0,     XMMI, 0},               // NONE                        (XMMI)
 {OP_COMISD,    XMMI2,M64R_64,    0,     XMMI2,0},               // NONE                        (XMMI2)
                                                                 // MMX -> REG
                                                                 // M64R      -> M32R
                                                                 // M128_M64R -> M64R_64
                                                                 // M64I      -> M32I
};

//
// Opcode Ex table
//
static XMMI_INSTR_INFO InstInfoTableEX[64] = {
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_CVTTPD2DQ, LOOKUP,12,        0,     0,    0},               // OP_CVTPD2DQ F2 E6 (XMMI2)    
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved

 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_CVTTPD2DQ, LOOKUP,14,        0,     0,    0},               // OP_CVTPD2DQ F2 E6 (XMMI2)    
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
};

//
//This table is indexed by 
//   (ULONG Op2Location:5) // Location of 2nd operand
//if (ULONG Op1Location:5) // Location of 1st operand has a value of LOOKUP
//from XMMI_INSTR_INFO 
//
//
static XMMI_INSTR_INFO InstInfoTableX[16] = {
 {OP_CVTPS2PD,  INV,  XMMI,       0,     XMMI2,1},               //    0F 5A  (XMMI2)
 {OP_CVTSS2SD,  INV,  XMMI,       0,     XMMI2,0},               // F3 0F 5A  (XMMI2)

 {OP_CVTPS2PD,  INV,  M64R,       0,     XMMI2,1},               //    0F 5A  (XMMI2)
 {OP_CVTSS2SD,  INV,  M32R,       0,     XMMI2,0},               // F3 0F 5A  (XMMI2)

 {OP_CVTDQ2PS,  INV,  XMMI_M32I,  0,     XMMI, 3},               //    0F 5B  (XMMI2)
 {OP_CVTTPS2DQ, INV,  XMMI,       0,     XMMI_M32I, 3},          // F3 0F 5B  (XMMI2)
 {OP_CVTPS2DQ,  INV,  XMMI,       0,     XMMI_M32I, 3},          // 66 0F 5B  (XMMI2)
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved

 {OP_CVTDQ2PS,  INV,  M128_M32I,  0,     XMMI, 3},               //    0F 5B  (XMMI2)
 {OP_CVTTPS2DQ, INV,  M128_M32R,  0,     XMMI_M32I, 3},          // F3 0F 5B  (XMMI2)
 {OP_CVTPS2DQ,  INV,  M128_M32R,  0,     XMMI_M32I, 3},          // 66 0F 5B  (XMMI2)
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved

 {OP_CVTTPD2DQ, INV,  XMMI2,      0,     XMMI_M32I,1},           // 66 0F E6 (XMMI2)    
 {OP_CVTPD2DQ,  INV,  XMMI2,      0,     XMMI_M32I,1},           // F2 0F E6 (XMMI2)    

 {OP_CVTTPD2DQ, INV,  M128_M64R,  0,     XMMI_M32I,1},           // 66 0F E6 (XMMI2)     
 {OP_CVTPD2DQ,  INV,  M128_M64R,  0,     XMMI_M32I,1},           // F2 0F E6 (XMMI2)    
};

//The following table is used to parse Mod/RM byte to compute the data memory reference
/* Mod | Reg | R/M */
/* 7-6 | 5-3 | 2-0 */

/* Reg: EAX ECX EDX EBX ESP EBP ESI EDI */
/*      000 001 010 011 100 101 110 111 */
/* Mod: R/M:     Ea            Routine  */
/* 00   000      [EAX]         ax0      */
/*      001      [ECX]         cx0      */
/*      010      [EDX]         dx0      */
/*      011      [EBX]         bx0      */
/*      100      +SIB          sib0     */
/*      101      disp32        d32      */
/*      110      [ESI]         si0      */
/*      111      [EDI]         di0      */
/* 01   000      disp8[EAX]    ax8      */
/*      001      disp8[ECX]    cx8      */
/*      010      disp8[EDX]    dx8      */
/*      011      disp8[EBX]    bx8      */
/*      100      disp8+SIB     sib8     */
/*      101      disp8[EBP]    bp8      */
/*      110      disp8+[ESI]   si8      */
/*      111      disp8+[EDI]   di8      */
/* 10   000      disp32[EAX]   ax32     */
/*      001      disp32[ECX]   cx32     */
/*      010      disp32[EDX]   dx32     */
/*      011      disp32[EBX]   bx32     */
/*      100      disp32+SIB    sib32    */
/*      101      disp32[EBP]   bp32     */
/*      110      disp32+[ESI]  si32     */
/*      111      disp32+[EDI]  di32     */
/* 11   000-111  Regs          reg      */
typedef (*codeptr)();
static codeptr modrm32[256] = {
/*       0       1       2       3       4       5       6       7          */
/*       8       9       a       b       c       d       e       f          */
/*0*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*0*/
/*0*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*0*/
/*1*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*1*/
/*1*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*1*/
/*2*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*2*/
/*2*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*2*/
/*3*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*3*/
/*3*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*3*/
/*4*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*4*/
/*4*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*4*/
/*5*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*5*/
/*5*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*5*/
/*6*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*6*/
/*6*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*6*/
/*7*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*7*/
/*7*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*7*/
/*8*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*8*/
/*8*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*8*/
/*9*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*9*/
/*9*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*9*/
/*a*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*a*/
/*a*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*a*/
/*b*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*b*/
/*b*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*b*/
/*c*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*c*/
/*c*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*c*/
/*d*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*d*/
/*d*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*d*/
/*e*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*e*/
/*e*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*e*/
/*f*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*f*/
/*f*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*f*/
/*       0       1       2       3       4       5       6       7          */
/*       8       9       a       b       c       d       e       f          */
};


/***
* fpieee_flt_simd - IEEE fp filter routine
*
*Purpose:
*   Invokes the user's trap handler on IEEE fp exceptions and provides
*   it with all necessary information
*
*Entry:
*   unsigned long exc_code: the NT exception code
*   PEXCEPTION_POINTERS p: a pointer to the NT EXCEPTION_POINTERS struct
*   int handler (_FPIEEE_RECORD *): a user supplied ieee trap handler
*
*   Note: The IEEE filter routine does not handle some transcendental
*   instructions. This can be done at the cost of additional decoding.
*   Since the compiler does not generate these instructions, no portable
*   program should be affected by this fact.
*
*Exit:
*   returns the value returned by handler
*
*Exceptions:
*
*******************************************************************************/

int fpieee_flt_simd(unsigned long exc_code,
                    PTEMP_EXCEPTION_POINTERS p,
                    int (__cdecl *handler) (_FPIEEE_RECORD *))
{

    PEXCEPTION_RECORD pexc;
    PTEMP_CONTEXT pctxt;
    PFLOATING_EXTENDED_SAVE_AREA pExtendedArea;
    _FPIEEE_RECORD FpieeeRecord;
    ULONG Status = EXCEPTION_CONTINUE_EXECUTION;
    ULONG *pinfo;
    PUCHAR istream;
    UCHAR ibyte;
    BOOLEAN fPrefix,fScalar,fDecode, fMod;
    MXCSRReg MXCsr;
    XMMI_FP_ENV XmmiFpEnv;
    XMMI_ENV XmmiEnv;
    PXMMI_INSTR_INFO ptable;
    PXMMI_INSTR_INFO instr_info_table;
    PXMMIINSTR instr;
    ULONG instrIndex, index, pair, InstLen = 0, Offset = 0;
    PXMMI_EXCEPTION_FLAGS OFlags, Flags;
    ULONG DataOffset;

#ifdef _XMMI_DEBUG
    DebugFlag=7;
#endif

    pexc = p->ExceptionRecord;
    pinfo = pexc->ExceptionInformation;
    
    //Check for software generated exception
    
    //
    //By convention the first argument to the exception is 0 for h/w exception. 
    //For s/w exceptions it points to the _FPIEEE_RECORD
    //
    if (pinfo[0]) {

        //  
        //We have a software exception:
        //the first parameter points to the IEEE structure
        //
        return handler((_FPIEEE_RECORD *)(pinfo[0]));

    }

    //
    //If control reaches here, then we have to deal with a hardware exception
    //First check to see if the context record has XMMI saved area.
    //
    pctxt = (PTEMP_CONTEXT) p->ContextRecord;
    
    if ((pctxt->ContextFlags & CONTEXT_EXTENDED_REGISTERS) != CONTEXT_EXTENDED_REGISTERS) {
#ifdef _XMMI_DEBUG
        fprintf(stderr, "No Context_Extended_Registers area\n");
#else        
        _ASSERT(0);
#endif
        return EXCEPTION_CONTINUE_SEARCH;
        
    } else {
        //For NT
        pExtendedArea = (PFLOATING_EXTENDED_SAVE_AREA) &pctxt->ExtendedRegisters[0];
    }
 
#ifdef _XMMI_DEBUG
    dump_Control(p);
#endif //_XMMI_DEBUG

    //
    //Save the original DataOffset.
    //Unlike X87 (X87: The memory reference is provided via DataOffset), XMMI's 
    //memory reference is derived from parsing the instruction by this routine.
    //
    DataOffset = pExtendedArea->DataOffset;

    //
    //Check Instruction prefixes and/or 2 byte opcode starts with 0F
    //The only prefix we support is F3 (Scalar form of the XMMI instruction) for XMMI.
    //Additional prefix we support is 66 and F2 (Scalar form of the XMMI2 instruction) for XMMI2.
    //There may other instruction prefix, such as, segment override or address size. 
    //However, the filter routine does not handle this type (same as x87).
    //
    //Default to Katmai Instruction set
    instrIndex = XMMI_INSTR;
    fDecode = FALSE;      //Default to no error seen
    __try {

        //
        //Read instruction prefixes
        //
        fPrefix = TRUE;   //Default to prefix scan
        fScalar = FALSE;  //Default to non-scalar instruction

        //
        //Unlike X87 (X87: the EIP is from: istream = (PUCHAR) pExtendedArea->ErrorOffset),
        //EIP is from trap frame's EIP.
        //
        istream = (PUCHAR) pctxt->Eip;

        while (fPrefix) {
            ibyte = *istream;
            istream++;
            switch (ibyte) {
                case 0xF3:  // rep or XMMI scaler
                    fScalar = TRUE;
                    InstLen++;
                    break;

                case 0x66:  // operand size or XMMI2
                    instrIndex = XMMI2_INSTR;
                    InstLen++;
                    break;

                case 0xF2:  // rep or XMMI2 scaler
                    fScalar = TRUE;
                    instrIndex = XMMI2_INSTR;
                    InstLen++;
                    break;

                case 0x2e:  // cs override
                case 0x36:  // ss override
                case 0x3e:  // ds override
                case 0x26:  // es override
                case 0x64:  // fs override
                case 0x65:  // gs override

                    //
                    //We don't support this.  X87 does not support this either. 
                    //
                    fDecode = TRUE;
                    break;

                case 0x67:  // address size
                case 0xF0:  // lock
 
                    fDecode = TRUE;         
                    break;
                    
                default:    // stop the prefix scan
                    fPrefix = FALSE;
                    break;
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
#ifdef _XMMI_DEBUG
        DPrint(XMMI_WARNING, ("Encounter Invalid Istream during parsing 1 %x\n", istream));  
#else
         _ASSERT(0);
#endif
        return EXCEPTION_CONTINUE_SEARCH; 
    }

    if (fDecode) {
#ifdef _XMMI_DEBUG
        DPrint(XMMI_WARNING, ("Invalid Istream 1, %x EIP: %x \n", istream, pctxt->Eip));  
        istream = (PUCHAR) pctxt->Eip;
        DPrint(XMMI_WARNING, ("%x\n", *istream));  
#else
        _ASSERT(0);
#endif
        return EXCEPTION_CONTINUE_SEARCH;
    }

    //
    // Get the next opcode
    //
    __try {

        //
        // instr points to the real Opcode (istream points to the byte after 0F)
        //
        instr = (PXMMIINSTR) istream;

        //
        // If we get here, ibyte can only point to 0F, for,
        // there are only 4 valid cases: 
        // 66 0F, F2 0F, F3 0F or 0F
        //
        if (ibyte != 0x0F) {
            fDecode = TRUE;
            goto tryExit;
        }
        
        //5x
        if (instr->Opcode1b == 5) {
            instr_info_table = InstInfoTable5X;
        //Cx
        } else {
            if (instr->Opcode1b == 0x0C) {
                instr_info_table = InstInfoTableCX;
            //2x
            } else {
                if (instr->Opcode1b == 2) {
                    instr_info_table = InstInfoTable2X;
                } else {
                    if (instr->Opcode1b == 0x0E) {
                        instr_info_table = InstInfoTableEX;
                    } else {
                        fDecode = TRUE;
                        goto tryExit;
                    }
                }
            }    
        }

        //
        //Pick up the Mod field: Register Ref (0) or Memory Ref (1)
        //
        fMod = instr->Mod == 0x3 ? 0 : 1;

        //
        //fScalar indicates XMMI/XMMI2 instruction is a scalar form or not.
        //1st byte of the Opcode tells which table it is.
        //2nd byte of the Opcode tells which entry it is in the table.
        //Compute the index, if it is a memory ref, index will be at the second half of the table.
        //ie. ADDPS 58 - for reg, index = 8*2
        //    ADDPD 58 - for reg, index = 8*2+1
        //    ADDPS 58 - for mem, index = 18h*2
        //    ADDPD 58 - for mem, index = 18h*2+1

        index = instr->Opcode1a | fMod << 4;
        
        //
        //Check to see if the Opcode byte is valid.
        //
        if (index > INSTR_IN_OPTABLE) {
            fDecode = TRUE;
            goto tryExit;
        }

        ptable = &instr_info_table[index*INSTR_SET_SUPPORTED+instrIndex];
        if (ptable->Operation == OP_UNSPEC) {
            fDecode = TRUE;
            goto tryExit;
        } else {

            //
            // Odd ball instructions, perform further look up.
            //
            if (ptable->Op1Location == LOOKUP) {
                if (fScalar) {
                    ptable = &InstInfoTableX[ptable->Op2Location+1];
                } else {
                    ptable = &InstInfoTableX[ptable->Op2Location];
                }

                //
                //All bets are off.
                //
                fScalar = 0;
                instrIndex = XMMI2_OTHER;
            }

        }

        //
        // Adjust and Save the Operation, Take fScalar into account.
        //
        XmmiFpEnv.OriginalOperation = ptable->Operation + fScalar;

        //
        //At this point, we have a valid XMMI instruction that this routine supports.
        //
        //nF3 + 0F OpCode Mod/RM
        //nF2 + 0F OpCode 
        //n66 + 0F Opcode
        //      0F Opcode
        InstLen = InstLen + 3;

        //
        //We need to compute the memory reference if the data is a memory reference type.
        //
        if (fMod) {
            
            istream = (PUCHAR) instr;
            
            //
            //instr points to the opcode, we want the Mod/RM byte in ibyte.
            //
            istream++;
            ibyte = *istream;

            //
            //point to the byte after Mod/RM
            //
            istream++;

            //
            //Parse the instruction to calculate the memory reference, store the result
            //in DataOffset.
            //
            Offset = (*modrm32[ibyte])(&pExtendedArea->DataOffset, pctxt, istream);
            PRINTF(("pExtendedArea->DataOffset %x\n", pExtendedArea->DataOffset));  
        }

        //
        //Load Operand 1 for instruction with 2 operands, 
        //or none for instruction with 1 operand.
        //
        LoadOperand(fScalar, ptable->Op1Location, instr->Reg, &XmmiFpEnv.Operand1, pctxt); 

        //
        //Load Operand 2
        //
        if (ptable->Op1Location == INV) { //instruction with 1 operand
            LoadOperand(fScalar, ptable->Op2Location, instr->RM,  &XmmiFpEnv.Operand1, pctxt);
            XmmiFpEnv.Operand2.Op.OperandValid = 0;
        } else {                          //instruction with 2 operands
            LoadOperand(fScalar, ptable->Op2Location, instr->RM,  &XmmiFpEnv.Operand2, pctxt); 
        }

        //
        //Load Result, init to Operand1
        //
        LoadOperand(fScalar, ptable->ResultLocation, instr->Reg, &XmmiFpEnv.Result, pctxt); 
    
        InstLen = InstLen + Offset;

        //
        //Pick up imm8 if any.
        //
        if (ptable->Op3Location == HAS_IMM8) {
            istream = istream + Offset;
            XmmiFpEnv.Imm8 = *istream;
            InstLen++;
        }


tryExit: ;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
#ifdef _XMMI_DEBUG
        DPrint(XMMI_WARNING, ("Encounter Invalid Istream during parsing 2, %x\n", istream)); 
#else
         _ASSERT(0);
#endif
        return EXCEPTION_CONTINUE_SEARCH; 
    }
   
    if (fDecode) {
#ifdef _XMMI_DEBUG
        DPrint(XMMI_WARNING, ("Invalid Istream 2, %x Inst: %x, %x\n", istream, instr, *instr)); 
#else
        _ASSERT(0);
#endif
        return EXCEPTION_CONTINUE_SEARCH;
    }

    //
    //Set up XmmiEnv environment from fp & mxcsr for Emulation.
    //

    //decode fp environment information
    switch (pExtendedArea->ControlWord & IMCW_PC) {
    case IPC_64:
        XmmiEnv.Precision = _FpPrecisionFull;
        break;
    case IPC_53:
        XmmiEnv.Precision = _FpPrecision53;
        break;
    case IPC_24:
        XmmiEnv.Precision = _FpPrecision24;
        break;
    }

    //decode mxcsr
    MXCsr.u.ul = pExtendedArea->MXCsr;
    switch (MXCsr.u.mxcsr.Rc & MaskCW_RC) {
    case rc_near:
        XmmiEnv.Rc = _FpRoundNearest;
        break;
    case rc_down:
        XmmiEnv.Rc = _FpRoundMinusInfinity;
        break;
    case rc_up:
        XmmiEnv.Rc = _FpRoundPlusInfinity;
        break;
    case rc_chop:
        XmmiEnv.Rc = _FpRoundChopped;
        break;
    }

    //and the rest.
    XmmiEnv.Masks = (MXCsr.u.ul & MXCSR_MASKS_MASK) >> 7;
    XmmiEnv.Fz    = MXCsr.u.mxcsr.Fz;
    XmmiEnv.Daz   = MXCsr.u.mxcsr.daz;
    XmmiEnv.EFlags = pctxt->EFlags;
    XmmiEnv.Imm8 = XmmiFpEnv.Imm8;
    Flags = (PXMMI_EXCEPTION_FLAGS) &XmmiEnv.Flags;

    //
    //Set up XmmiFpEnv environment for this routine.
    //

    //Save the original exception flags
    XmmiFpEnv.IFlags = MXCsr.u.ul & MXCSR_FLAGS_MASK;
    XmmiFpEnv.OFlags = 0;
    OFlags = (PXMMI_EXCEPTION_FLAGS) &XmmiFpEnv.OFlags;

#ifdef _XMMI_DEBUG
    dump_XmmiFpEnv(&XmmiFpEnv);
#endif //_XMMI_DEBUG

    pair = ptable->NumArgs + 1;
    if (fScalar) pair = 1;

    //
    // Loop through SIMD.  1 data item at a time.
    //
    for ( index=0; index < pair; index++ ) {    

        //
        // ieee field does not have denormal bit defined. Emulator returns
        // all Exception flags bits through this XmmiEnv.Flags field.
        //
        XmmiEnv.Flags = 0;

        //
        // Set up ieee Input Operands
        //
        InitExcptFlags(FpieeeRecord.Cause);
        InitExcptFlags(FpieeeRecord.Enable);
        InitExcptFlags(FpieeeRecord.Status);
        FpieeeRecord.RoundingMode = XmmiEnv.Rc; 
        FpieeeRecord.Precision = XmmiEnv.Precision;
        FpieeeRecord.Operation = XmmiFpEnv.OriginalOperation;

        FpieeeRecord.Operand1.OperandValid = XmmiFpEnv.Operand1.Op.OperandValid; 
        if (instrIndex == XMMI2_INSTR) {
            FpieeeRecord.Operand1.Value.Q64Value = XmmiFpEnv.Operand1.Op.Value.Fpq64Value.W[index];
        } else {
            if (instrIndex == XMMI_INSTR) {
                FpieeeRecord.Operand1.Value.U32Value = XmmiFpEnv.Operand1.Op.Value.Fp128Value.W[index];
            } else {
                switch (XmmiFpEnv.OriginalOperation) {
                    case OP_CVTPS2PD:
                    case OP_CVTSS2SD:
                         FpieeeRecord.Operand1.Value.Q64Value = XmmiFpEnv.Operand1.Op.Value.Fp128Value.W[index];
                         break;

                    case OP_CVTDQ2PS:
                    case OP_CVTTPS2DQ:
                    case OP_CVTPS2DQ:
                         FpieeeRecord.Operand1.Value.U32Value = XmmiFpEnv.Operand1.Op.Value.Fp128Value.W[index];
                         break;

                    case OP_CVTTPD2DQ:
                    case OP_CVTPD2DQ:
                         FpieeeRecord.Operand1.Value.Q64Value = XmmiFpEnv.Operand1.Op.Value.Fpq64Value.W[index];
                         break;
                }
            }
        }
        FpieeeRecord.Operand1.Format = XmmiFpEnv.Operand1.Op.Format;
       
        if (XmmiFpEnv.Operand2.Op.OperandValid) {
            FpieeeRecord.Operand2.OperandValid = XmmiFpEnv.Operand2.Op.OperandValid; 
            if (instrIndex == XMMI2_INSTR) {
                FpieeeRecord.Operand2.Value.Q64Value = XmmiFpEnv.Operand2.Op.Value.Fpq64Value.W[index];
            } else {
                if (instrIndex == XMMI_INSTR) {
                    FpieeeRecord.Operand2.Value.U32Value = XmmiFpEnv.Operand2.Op.Value.Fp128Value.W[index];
                } else {
                    switch (XmmiFpEnv.OriginalOperation) {
                        case OP_CVTPS2PD:
                        case OP_CVTSS2SD:
                             FpieeeRecord.Operand2.Value.Q64Value = XmmiFpEnv.Operand2.Op.Value.Fp128Value.W[index];
                             break;

                        case OP_CVTDQ2PS:
                        case OP_CVTTPS2DQ:
                        case OP_CVTPS2DQ:
                             FpieeeRecord.Operand2.Value.U32Value = XmmiFpEnv.Operand2.Op.Value.Fp128Value.W[index];
                             break;

                        case OP_CVTTPD2DQ:
                        case OP_CVTPD2DQ:
                             FpieeeRecord.Operand2.Value.Q64Value = XmmiFpEnv.Operand2.Op.Value.Fpq64Value.W[index];
                             break;
                    }
                }
            }
            FpieeeRecord.Operand2.Format = XmmiFpEnv.Operand2.Op.Format;
        } else {
            FpieeeRecord.Operand2.OperandValid = 0;
        }

        FpieeeRecord.Result.OperandValid = 0; 
        if (instrIndex == XMMI2_INSTR) {
            FpieeeRecord.Result.Value.Q64Value = XmmiFpEnv.Result.Op.Value.Fpq64Value.W[index];
        } else {
            if (instrIndex == XMMI_INSTR) {
                FpieeeRecord.Result.Value.U32Value = XmmiFpEnv.Result.Op.Value.Fp128Value.W[index];
            } else {
                switch (XmmiFpEnv.OriginalOperation) {
                    case OP_CVTPS2PD:
                    case OP_CVTSS2SD:
                         FpieeeRecord.Result.Value.Q64Value = XmmiFpEnv.Result.Op.Value.Fp128Value.W[index];
                         break;

                    case OP_CVTDQ2PS:
                    case OP_CVTTPS2DQ:
                    case OP_CVTPS2DQ:
                         FpieeeRecord.Result.Value.U32Value = XmmiFpEnv.Result.Op.Value.Fp128Value.W[index];
                         break;

                    case OP_CVTTPD2DQ:
                    case OP_CVTPD2DQ:
                         FpieeeRecord.Result.Value.Q64Value = XmmiFpEnv.Result.Op.Value.Fpq64Value.W[index];
                         break;
                }
            }
        }
        FpieeeRecord.Result.Format = XmmiFpEnv.Result.Op.Format;

        XmmiEnv.Ieee = (_PFPIEEE_RECORD) &FpieeeRecord;

#ifdef _XMMI_DEBUG
        PRINTF(("INPUT #%d:\n", index));
#endif _XMMI_DEBUG

        //
        // Perform Emulation
        //
        // Note: Cause will be all zeros for denormal.  
        //       Raised     - Denormal
        //       Not Raised - no exception
        //
        if ((instrIndex == XMMI2_INSTR) || (instrIndex == XMMI2_OTHER)) {
            XmmiFpEnv.Raised[index] = XMMI2_FP_Emulation(&XmmiEnv);
        } else {
            XmmiFpEnv.Raised[index] = XMMI_FP_Emulation(&XmmiEnv);
        }

        //
        // Remember the exceptions. 
        //
        XmmiFpEnv.Flags[index] = XmmiEnv.Flags;

        if (XmmiFpEnv.Raised[index] == ExceptionRaised) {

#ifdef _XMMI_DEBUG
            PRINTF(("OUTPUT #%d: ExceptionRaised\n", index));
            print_FPIEEE_RECORD_EXCEPTION(&XmmiEnv);
#endif //_XMMI_DEBUG
            
            //
            //ORed the flags.
            //
            if (Flags->pe) OFlags->pe = 1;
            if (Flags->ue) OFlags->ue = 1;
            if (Flags->oe) OFlags->oe = 1; 
            if (Flags->ze) OFlags->ze = 1;
            if (Flags->de) OFlags->de = 1;
            if (Flags->ie) OFlags->ie = 1;

            //
            // invoke the user-defined exception handler
            //
            Status = handler(&FpieeeRecord);        

            //
            // return if not EXCEPTION_CONTINUE_EXECUTION
            //
            if (Status != EXCEPTION_CONTINUE_EXECUTION) {
                return (Status);
            }

            //
            // Adjust the compare result.
            //
            AdjustExceptionResult(XmmiFpEnv.OriginalOperation, &XmmiEnv);

        } else {
#ifdef _XMMI_DEBUG
            PRINTF(("OUTPUT #%d:No ExceptionRaised\n", index));
            print_FPIEEE_RECORD_NO_EXCEPTION(&XmmiEnv);
#endif //_XMMI_DEBUG
        }

        //
        // Or the result piece together
        //
        XmmiFpEnv.Result.Op.OperandValid = FpieeeRecord.Result.OperandValid;
        XmmiFpEnv.EFlags = XmmiEnv.EFlags;
        if (XmmiFpEnv.Result.Op.OperandValid) {
            if (instrIndex == XMMI2_INSTR) {
                XmmiFpEnv.Result.Op.Value.Fpq64Value.W[index] = FpieeeRecord.Result.Value.Q64Value;
            } else {
                if (instrIndex == XMMI_INSTR) {
                    XmmiFpEnv.Result.Op.Value.Fp128Value.W[index] = FpieeeRecord.Result.Value.U32Value;
                } else {
                    switch (XmmiFpEnv.OriginalOperation) {
                        case OP_CVTPS2PD:
                        case OP_CVTSS2SD:
                             XmmiFpEnv.Result.Op.Value.Fpq64Value.W[index] = FpieeeRecord.Result.Value.U32Value;
                             break;

                        case OP_CVTDQ2PS:
                        case OP_CVTTPS2DQ:
                        case OP_CVTPS2DQ:
                             XmmiFpEnv.Result.Op.Value.Fp128Value.W[index] = FpieeeRecord.Result.Value.U32Value;
                             break;
                        case OP_CVTTPD2DQ:
                        case OP_CVTPD2DQ:
                             XmmiFpEnv.Result.Op.Value.Fpq64Value.W[index] = FpieeeRecord.Result.Value.Q64Value;
                             break;
                    }
                }
            }
        }
    } // End of Loop through SIMD.  1 data item at a time.

    //
    // Update the result from XmmiFpEnv to the context
    // 
    UpdateResult(&XmmiFpEnv.Result, pctxt, XmmiFpEnv.EFlags);

#ifdef _XMMI_DEBUG
    //
    // Valid the processor MXCSR and the emulator MXCSR 
    //
    NotOk = ValidateResult(&XmmiFpEnv);
#endif //_XMMI_DEBUG

    //
    //Update EIP
    //
    istream = (PUCHAR) pctxt->Eip;
    istream = istream + InstLen;
    (PUCHAR) pctxt->Eip = istream;

    //
    //Place the original one back.
    //
    pExtendedArea->DataOffset = DataOffset;


    return Status;

}

/***
* LoadOperand - Load in operand information
*
*Purpose:
*   Fill in data in the internal operand structure based on the information 
*   found in the floating point context and the location code
*
*Entry:
*    fScalar             Packed or Scalar
*    opLocation          type of the operand
*    opReg               reg number
*    pOperand            pointer to the operand to be filled in
*    pExtendedArea       pointer to the floating point context extended area
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void
LoadOperand(
    BOOLEAN fScalar,
    ULONG OpLocation,
    ULONG OpReg,
    POPERAND pOperand,
    PTEMP_CONTEXT pctxt)

{

    PXMMI_AREA XmmiArea;
    PX87_AREA  X87Area;
    PMMX_AREA  MmxArea;
    PFLOATING_EXTENDED_SAVE_AREA pExtendedArea;
    ULONG index;
    PXMMI128 Fp128;
    
    //
    // If location is REG, the register number is
    // encoded in the instruction
    //
    pOperand->OpLocation = OpLocation;
    if (pOperand->OpLocation == INV) {
        pOperand->Op.OperandValid = 0;
        return;
    }

    //
    // Change to the sclar form if it is a scalr instruction.
    //
    if ((OpLocation == XMMI) || (OpLocation == MMX) || (OpLocation == XMMI2) || OpLocation == XMMI_M32I) {
 
        if (fScalar) {
            if (OpLocation == MMX) {
                pOperand->OpLocation = REG;
                }
            }
        pOperand->OpReg = OpReg;

    } else {
        if ((fScalar) && (OpLocation != INV)) {
            if (OpLocation == M128_M32R) {
                pOperand->OpLocation = M32R;
            }

            if (OpLocation == M128_M64R) {
                pOperand->OpLocation = M64R_64;
            }

            if (OpLocation == M64R) {
                pOperand->OpLocation = M32R;
            }

            if (OpLocation == M64I) {
                pOperand->OpLocation = M32I;
            }
        }
    }


    pExtendedArea = (PFLOATING_EXTENDED_SAVE_AREA) &pctxt->ExtendedRegisters[0];

    //
    // Init to 0
    //
    for ( index=0; index < 4; index++ ) {   
        pOperand->Op.Value.Fp128Value.W[index] = 0;
    }

    //
    // Assume valid operand (this is almost always the case)
    //
    pOperand->Op.OperandValid = 1;

    //
    // Load up value from the context area.  We need to be careful about accessing
    // the value, make sure there is no compiler intermediate data type conversion
    // via X87 floating point instruction.  If there is, X87 floating point inst
    // can screw us up when encountering a bad input value.  Bad input value may
    // be changed by the processor due to the processor is executing a masked 
    // X87 floating point inst.
    //
    switch (pOperand->OpLocation) {

        case M128_M32I:
             pOperand->Op.Format = _FpFormatI32;
             pOperand->Op.Value.Fp128Value = *(_FP128 *)(pExtendedArea->DataOffset);
             break;

        case M128_M32R:
             pOperand->Op.Format = _FpFormatFp32;
             pOperand->Op.Value.Fp128Value = *(_FP128 *)(pExtendedArea->DataOffset);
             break;

        case M128_M64R:
             pOperand->Op.Format = _FpFormatFp64;
             pOperand->Op.Value.Fp128Value = *(_FP128 *)(pExtendedArea->DataOffset);
             break;

        case M64R:
             pOperand->Op.Format = _FpFormatFp32;
             pOperand->Op.Value.U64Value = *(_U64 *)(pExtendedArea->DataOffset);
             break;

        case M64R_64:
             pOperand->Op.Format = _FpFormatFp64;
             pOperand->Op.Value.U64Value = *(_U64 *)(pExtendedArea->DataOffset);
             break;

        case M32R:
             pOperand->Op.Format = _FpFormatFp32;
             pOperand->Op.Value.U32Value = *(_U32 *)(pExtendedArea->DataOffset);
             break;

        case M64I:
             pOperand->Op.Format = _FpFormatI32;
             pOperand->Op.Value.U64Value = *(_U64 *)(pExtendedArea->DataOffset);
             break;

        case M32I:
             pOperand->Op.Format = _FpFormatI32;
             pOperand->Op.Value.U32Value = *(_U32 *)(pExtendedArea->DataOffset);
             break;

        case XMMI:
             XmmiArea = (PXMMI_AREA) &pExtendedArea->XMMIRegisterArea[0];
             pOperand->Op.Format = _FpFormatFp32;
             Fp128 = &XmmiArea->Xmmi[OpReg];
             pOperand->Op.Value.Fp128Value = Fp128->u.fp128;
             break;

        case XMMI2:
             XmmiArea = (PXMMI_AREA) &pExtendedArea->XMMIRegisterArea[0];
             pOperand->Op.Format = _FpFormatFp64;
             Fp128 = &XmmiArea->Xmmi[OpReg];
             pOperand->Op.Value.Fp128Value = Fp128->u.fp128;
             break;
         
        case XMMI_M32I:
             XmmiArea = (PXMMI_AREA) &pExtendedArea->XMMIRegisterArea[0];
             pOperand->Op.Format = _FpFormatI32;
             Fp128 = &XmmiArea->Xmmi[OpReg];
             pOperand->Op.Value.U32Value = Fp128->u.ul[0];
             break;

        case MMX:
             X87Area = (PX87_AREA) &pExtendedArea->X87RegisterArea[0];
             pOperand->Op.Format = _FpFormatI32;
             MmxArea = &X87Area->Mm[OpReg];
             pOperand->Op.Value.U64Value = MmxArea->Mmx.u.u64;
             break;

        case REG:
             pOperand->Op.Format = _FpFormatI32;
             switch (OpReg) {
             case 0x0:
                  pOperand->Op.Value.U32Value = pctxt->Eax;
                  break;
             case 0x1:
                  pOperand->Op.Value.U32Value = pctxt->Ecx;
                  break;
             case 0x2:
                  pOperand->Op.Value.U32Value = pctxt->Edx;
                  break;
             case 0x3:
                  pOperand->Op.Value.U32Value = pctxt->Ebx;
                  break;
             case 0x4:
                  //?
                  break;
             case 0x5:
                  pOperand->Op.Value.U32Value = pctxt->Ebp;
                  break;
             case 0x6:
                  pOperand->Op.Value.U32Value = pctxt->Esi;
                  break;
             case 0x7:
                  pOperand->Op.Value.U32Value = pctxt->Edi;
                  break;
             }
        break;
    }

    return;

}


/***
* LoadImm8 - Pick up imm8 from the instruction stream
*
*Purpose:
*    Return the offset of imm8 from the beginning of the Instruction stream 
*    pointer.  This routine is not used.
*
*Entry:
*    Instr - pointer to the Opcode (after f3/0f)
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

ULONG
LoadImm8(
    PXMMIINSTR Instr)

{

    PUCHAR pInstr;
    ULONG  Offset;

#ifdef _XMMI_DEBUG
    if (Console) return DebugImm8;
#endif //_XMMI_DEBUG

    //Assume 32-bit. pInstr points to the Opcode C2 after (f3/0f)
    pInstr = (PUCHAR) Instr;
    //Opcode, ModR/M
    Offset=2;
    //For Mod = 01, 10, 11
    if (Instr->Mod != 3) {
        //Notes #1 PPro 2-5
        if (Instr->RM == 4)  Offset=Offset+1; //SIB
        if (Instr->Mod == 0) Offset=Offset+0;
        if (Instr->Mod == 1) Offset=Offset+1;
        if (Instr->Mod == 2) Offset=Offset+4;
        //Notes #2 PPro 2-5
        if ((Instr->Mod == 0) && (Instr->RM == 5)) Offset=Offset+4; //SIB
        //Notes #3 PPro 2-5
        if ((Instr->Mod == 1) && (Instr->RM == 0)) Offset=Offset+1; //SIB
    }
    
    //imm8 
    return *(pInstr+Offset);

}

/***
* AdjustExceptionResult -  Adjust exception result returned from user's handler
*
*Purpose:
*    This routine is called after the exception is raised from the Emulation
*    the result is passed onto user's handler, and the user returns 
*    EXCEPTION_CONTINUE_EXECUTION.  Go ahead to adjust the result.
*
*Entry:
*   OriginalOperation - Original operation Opcode
*   XmmiEnv - Pointer to Emulation result
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
void
AdjustExceptionResult(
    ULONG OriginalOperation,
    PXMMI_ENV XmmiEnv)


{

    // 
    //When the exception is raised, the user handler is invoked with the result.
    //If the user expects us to Adjust the result, user handler would have to
    //set the Result.OperandValid to 1.  From emulator's view point, the
    //Result.OperandValid is 0.
    //
    if (!XmmiEnv->Ieee->Result.OperandValid) return;
    if (XmmiEnv->Ieee->Result.Format != _FpCodeCompare) return;

    switch (OriginalOperation) {
        case OP_COMISS:
        case OP_UCOMISS:
        case OP_COMISD:
        case OP_UCOMISD:
             switch (XmmiEnv->Ieee->Result.Value.CompareValue) {
             case _FpCompareEqual:
                  // OF, SF, AF = 000, ZF, PF, CF = 100
                  XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff76a) | 0x00000040;
                  break;
             case _FpCompareGreater:
                  // OF, SF, AF = 000, ZF, PF, CF = 000
                  XmmiEnv->EFlags = XmmiEnv->EFlags & 0xfffff72a;
                  break;
             case _FpCompareLess:
                  // OF, SF, AF = 000, ZF, PF, CF = 001
                  XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff72b) | 0x00000001;
                  break;
             case _FpCompareUnordered:
                  // OF, SF, AF = 000, ZF, PF, CF = 111
                  XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff76f) | 0x00000045;
                  break;
             }
             break;

        case OP_CMPPS:
        case OP_CMPSS:
             switch (XmmiEnv->Ieee->Result.Value.CompareValue) {
             case _FpCompareEqual:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_EQ:
                  case IMM8_LE:
                  case IMM8_NLT:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0xffffffff;
                       break;

                  case IMM8_LT:
                  case IMM8_UNORD:
                  case IMM8_NEQ:
                  case IMM8_NLE:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0x0;
                       break;
                  }
                  break;
             case _FpCompareGreater:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_NEQ:
                  case IMM8_NLT:
                  case IMM8_NLE:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0xffffffff;
                       break;

                  case IMM8_EQ:
                  case IMM8_LT:
                  case IMM8_LE:
                  case IMM8_UNORD:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0x0;
                       break;
                  }
                  break;
             case _FpCompareLess:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_LT:
                  case IMM8_LE:
                  case IMM8_NEQ:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0xffffffff;
                       break;
                  case IMM8_EQ:
                  case IMM8_UNORD:
                  case IMM8_NLT:
                  case IMM8_NLE:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0x0;
                       break;
                  }
                  break;
             case _FpCompareUnordered:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_EQ:
                  case IMM8_LT:
                  case IMM8_LE:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0x0;
                       break;
                  case IMM8_UNORD:
                  case IMM8_NEQ:
                  case IMM8_NLT:
                  case IMM8_NLE:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0xffffffff;
                       break;
                  }
                  break;
             }

        case OP_CMPPD:
        case OP_CMPSD:
             switch (XmmiEnv->Ieee->Result.Value.CompareValue) {
             case _FpCompareEqual:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_EQ:
                  case IMM8_LE:
                  case IMM8_NLT:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0xffffffffffffffff;
                       break;

                  case IMM8_LT:
                  case IMM8_UNORD:
                  case IMM8_NEQ:
                  case IMM8_NLE:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0x0;
                       break;
                  }
                  break;
             case _FpCompareGreater:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_NEQ:
                  case IMM8_NLT:
                  case IMM8_NLE:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0xffffffffffffffff;
                       break;

                  case IMM8_EQ:
                  case IMM8_LT:
                  case IMM8_LE:
                  case IMM8_UNORD:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0x0;
                       break;
                  }
                  break;
             case _FpCompareLess:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_LT:
                  case IMM8_LE:
                  case IMM8_NEQ:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0xffffffffffffffff;
                       break;
                  case IMM8_EQ:
                  case IMM8_UNORD:
                  case IMM8_NLT:
                  case IMM8_NLE:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0x0;
                       break;
                  }
                  break;
             case _FpCompareUnordered:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_EQ:
                  case IMM8_LT:
                  case IMM8_LE:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0x0;
                       break;
                  case IMM8_UNORD:
                  case IMM8_NEQ:
                  case IMM8_NLT:
                  case IMM8_NLE:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0xffffffffffffffff;
                       break;
                  }
                  break;
             }

             break;
    }

    return;

}

/***
* UpdateResult -  Update result information in the extended floating point context
*
*Purpose:
*   Copy the operand information to  the snapshot of the floating point
*   context or memory, as to make it available on continuation
*
*Entry:
*   pOperand Pointer to the result
*   pctxt    Pointer to the context
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void
UpdateResult(
    POPERAND pOperand,
    PTEMP_CONTEXT pctxt,
    ULONG EFlags)

{

    PXMMI_AREA XmmiArea;
    PX87_AREA  X87Area;
    PMMX_AREA  MmxArea;
    PFLOATING_EXTENDED_SAVE_AREA pExtendedArea;
    ULONG OpReg;

    OpReg = pOperand->OpReg;
    pExtendedArea = (PFLOATING_EXTENDED_SAVE_AREA) &pctxt->ExtendedRegisters[0];
    XmmiArea = (PXMMI_AREA) &pExtendedArea->XMMIRegisterArea[0];
    X87Area = (PX87_AREA) &pExtendedArea->X87RegisterArea[0];

    switch (pOperand->OpLocation) {

        case M128_M32R:
        case M128_M64R:
        case M128_M32I:
             *(_FP128 *)(pExtendedArea->DataOffset) = pOperand->Op.Value.Fp128Value;
             break;

        case M64R_64:
        case M64R:
             *(_U64 *)(pExtendedArea->DataOffset) = pOperand->Op.Value.U64Value;
             break;

        case M32R:
             *(_U32 *)(pExtendedArea->DataOffset) = pOperand->Op.Value.U32Value;
             break;

        case M64I:
             *(_U64 *)(pExtendedArea->DataOffset) = pOperand->Op.Value.U64Value;
             break;

        case M32I:
             *(_U32 *)(pExtendedArea->DataOffset) = pOperand->Op.Value.U32Value;
             break;

        case XMMI:
        case XMMI2:
        case XMMI_M32I:
             XmmiArea->Xmmi[OpReg].u.fp128 = pOperand->Op.Value.Fp128Value;
             break;

        case MMX:
             MmxArea = &X87Area->Mm[OpReg];
             MmxArea->Mmx.u.u64 = pOperand->Op.Value.U64Value;
             break;

        case REG:

             switch (OpReg) {
             case 0x0:
                  pctxt->Eax = pOperand->Op.Value.U32Value;
                  break;
             case 0x1:
                  pctxt->Ecx = pOperand->Op.Value.U32Value;
                  break;
             case 0x2:
                  pctxt->Edx = pOperand->Op.Value.U32Value;
                  break;
             case 0x3:
                  pctxt->Ebx = pOperand->Op.Value.U32Value;
                  break;
             case 0x4:
                  //?
                  break;
             case 0x5:
                  pctxt->Ebp = pOperand->Op.Value.U32Value;
                  break;
             case 0x6:
                  pctxt->Esi = pOperand->Op.Value.U32Value;
                  break;
             case 0x7:
                  pctxt->Edi = pOperand->Op.Value.U32Value;
                  break;
             }

        case RS:
             pctxt->EFlags = EFlags;
        break;
    }
    
}

/***
* ValidateResult -  Validate the emulation result with the MXCSR
*
*Purpose:
*   We are about to dismiss the exception, perform validation to
*   see if the processor agrees with our Emulation
*
*Entry:
*   XmmiFpEnv - pointer to the data about the exception.
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

BOOLEAN
ValidateResult(
    PXMMI_FP_ENV XmmiFpEnv)

{

    PXMMI_EXCEPTION_FLAGS IFlags;
    PXMMI_EXCEPTION_FLAGS OFlags;
    BOOLEAN Flag;

    Flag = FALSE;
    IFlags = (PXMMI_EXCEPTION_FLAGS) &XmmiFpEnv->IFlags;
    OFlags = (PXMMI_EXCEPTION_FLAGS) &XmmiFpEnv->OFlags;

/*    DPrint(XMMI_WARNING, ("Checking MXCSR Exception Flags\n"));  */
    if (IFlags->ie != OFlags->ie) {
/*        DPrint(XMMI_WARNING, ("ie: Processor %x, Emulator %x\n", IFlags->ie, OFlags->ie));  */
        Flag=TRUE;
    }

    if (IFlags->de != OFlags->de) {
/*        DPrint(XMMI_WARNING, ("de: Processor %x, Emulator %x\n", IFlags->de, OFlags->de)); */
        Flag=TRUE;
    }

    if (IFlags->ze != OFlags->ze) {
/*        DPrint(XMMI_WARNING, ("ze: Processor %x, Emulator %x\n", IFlags->ze, OFlags->ze));  */
        Flag=TRUE;
    }

    if (IFlags->oe != OFlags->oe) {
/*        DPrint(XMMI_WARNING, ("oe: Processor %x, Emulator %x\n", IFlags->oe, OFlags->oe));  */
        Flag=TRUE;
    }

    if (IFlags->ue != OFlags->ue) {
/*        DPrint(XMMI_WARNING, ("ue: Processor %x, Emulator %x\n", IFlags->ue, OFlags->ue));  */
        Flag=TRUE;
    }

    if (IFlags->pe != OFlags->pe) {
/*        DPrint(XMMI_WARNING, ("pe: Processor %x, Emulator %x\n", IFlags->pe, OFlags->pe));  */
        Flag=TRUE;
    }

    if (!Flag) {
/*        DPrint(XMMI_INFO, ("Validating MXCSR Exception Flags Ok, Prc:0x%x, Em:0x%x\n\n",  */
/*            XmmiFpEnv->IFlags, XmmiFpEnv->OFlags));  */
    }

    if (Flag) {
#ifdef _XMMI_DEBUG
        DPrint(XMMI_INFO, ("Validating MXCSR Exception Flags NotOk, Prc:0x%x, Em:0x%x\n\n", 
            XmmiFpEnv->IFlags, XmmiFpEnv->OFlags));  
        PRINTF(("WARNING: Validating MXCSR Exception Flags NotOk, Prc:0x%x, Em:0x%x\n",   
            XmmiFpEnv->IFlags, XmmiFpEnv->OFlags));  
#else
        _ASSERT(0);
#endif
    }

    return Flag;

}


/*
 *  mod r/m byte decoder support
 */

/*-----------------------------------------------------------------
 *  Routine:  ax0
 */
ULONG
ax0( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{
    PRINTF(("ax0\n"));
    *DataOffset = GET_REG(Eax);
    return 0;

} /* End ax0(). */


/*-----------------------------------------------------------------
 *  Routine:  ax8
 */
ULONG
ax8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{
    PRINTF(("ax8\n"));
    *DataOffset = GET_REG(Eax) + GET_USER_UBYTE(eip);
    return 1;

} /* End ax8(). */


/*-----------------------------------------------------------------
 *  Routine:  ax32
 */
ULONG
ax32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{
    PRINTF(("ax32\n"));
    *DataOffset = GET_REG(Eax) + GET_USER_ULONG(eip);
    return 4;

} /* End ax32(). */


/*-----------------------------------------------------------------
 *  Routine:  cx0
 */
ULONG
cx0( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{
    PRINTF(("cx0\n"));
    *DataOffset = GET_REG(Ecx);
    return 0;

} /* End cx0(). */


/*-----------------------------------------------------------------
 *  Routine:  cx8
 */
ULONG
cx8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{   
    PRINTF(("cx8\n"));
    *DataOffset = GET_REG(Ecx) + GET_USER_UBYTE(eip);
    return 1;

} /* End cx8(). */


/*-----------------------------------------------------------------
 *  Routine:  cx32
 */
ULONG
cx32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{
    
    PRINTF(("cx32\n"));
    *DataOffset = GET_REG(Ecx) + GET_USER_ULONG(eip);
    return 4;

} /* End cx32(). */


/*-----------------------------------------------------------------
 *  Routine:  dx0
 */
ULONG
dx0( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("dx0\n"));
    *DataOffset = GET_REG(Edx);
    return 0;

} /* End dx0(). */


/*-----------------------------------------------------------------
 *  Routine:  dx8
 */
ULONG
dx8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("dx8\n"));
    *DataOffset = GET_REG(Edx) + GET_USER_UBYTE(eip);
    return 1;

} /* End dx8(). */


/*-----------------------------------------------------------------
 *  Routine:  dx32
 */
ULONG
dx32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("dx32\n"));
    *DataOffset = GET_REG(Edx) + GET_USER_ULONG(eip);
    return 4;

} /* End dx32(). */

/*-----------------------------------------------------------------
 *  Routine:  bx0
 */
ULONG
bx0( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("bx0\n"));
    *DataOffset = GET_REG(Ebx);
    return 0;

} /* End bx0(). */


/*-----------------------------------------------------------------
 *  Routine:  bx8
 */
ULONG
bx8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("bx8\n"));
    *DataOffset = GET_REG(Ebx) + GET_USER_UBYTE(eip);
    return 1;

} /* End bx8(). */


/*-----------------------------------------------------------------
 *  Routine:  bx32
 */
ULONG
bx32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("bx32\n"));
    *DataOffset = GET_REG(Ebx) + GET_USER_ULONG(eip);
    return 4;

} /* End bx32(). */


/*
 *  A "mod r/m" byte indicates an s-i-b byte is present.  Assume the register
 *  from the mod r/m byte is not relevant (does not participate in a memory
 *  reference) and calculate the EA based on the s-i-b byte.
 */
/* SS  | Index | Base */
/* 7-6 |  5-3  |  2-0 */
/* Base: EAX ECX EDX EBX ESP EBP ESI EDI */
/*       000 001 010 011 100 101 110 111 */
/* SS: Index:    
/* 00   000      [EAX]         
/*      001      [ECX]         
/*      010      [EDX]         
/*      011      [EBX]         
/*      100      none         
/*      101      [EBP]        
/*      110      [ESI]         
/*      111      [EDI]         
/* 01   000      [EAX*2]    
/*      001      [ECX*2]    
/*      010      [EDX*2]    
/*      011      [EBX*2]    
/*      100      none     
/*      101      [EBP*2]    
/*      110      [ESI*2]   
/*      111      [EDI*2]   
/* 10   000      [EAX*4]    
/*      001      [ECX*4]    
/*      010      [EDX*4]    
/*      011      [EBX*4]    
/*      100      none     
/*      101      [EBP*4]    
/*      110      [ESI*4]   
/*      111      [EDI*4]   
/* 11   000      [EAX*8]    
/*      001      [ECX*8]    
/*      010      [EDX*8]    
/*      011      [EBX*8]    
/*      100      none     
/*      101      [EBP*8]    
/*      110      [ESI*8]   
/*      111      [EDI*8]   
/*Note: Mod=00, no base, Mod=01/10, base is EBP

/*-----------------------------------------------------------------
 *  Routine:  sib0
 */
ULONG
sib0( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    ULONG sib = GET_USER_UBYTE(eip);
    ULONG scale;
    ULONG index;

    PRINTF(("sib0\n"));

    //(Base+Index*Scale)+disp0
    //Get ss: scaled as *1 (00), *2 (01), *4 (10), *8 (11)
    scale = 1 << (sib >> 6);
    //Get index: 000-111
    index = ((sib >> 3)&0x7);
    if (index == ESP_INDEX) {
        index = 0;
    } else {
        //index=GET_REG(index), upon return, index has the value of the register
        GET_REG_VIA_NDX(index, index);
    }
    //Get base: 000-111
    sib = (sib & 0x7);
    //mod=00, there is no base.
    if (sib == EBP_INDEX) {
        *DataOffset = GET_USER_ULONG(eip + 1) + index*scale;
        return 5;
    }

    if (sib == ESP_INDEX) {
        *DataOffset = GET_REG(Esp) + index*scale;
    } else {
        GET_REG_VIA_NDX(*DataOffset, sib);
        *DataOffset += index*scale;
    }
    return 1;

} /* End sib0(). */


/*-----------------------------------------------------------------
 *  Routine:  sib8
 */
ULONG
sib8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    ULONG sib = GET_USER_UBYTE(eip);
    ULONG scale;
    ULONG index;

    PRINTF(("sib8\n"));

    //(Base+Index*Scale)+disp8
    //Get ss: scaled as *1 (00), *2 (01), *4 (10), *8 (11)
    scale = 1 << (sib >> 6);
    //Get index: 000-111
    index = ((sib >> 3)&0x7);
    if (index == ESP_INDEX) {
        index = 0;
    } else {
        GET_REG_VIA_NDX(index, index);
    }
    //Get base: 000-111
    sib = (sib & 0x7);
    if (sib == ESP_INDEX) {
        *DataOffset = GET_USER_UBYTE(eip + 1) + GET_REG(Esp) + index*scale;
    } else {
        GET_REG_VIA_NDX(*DataOffset, sib);
        *DataOffset += GET_USER_UBYTE(eip + 1) + index*scale;
    }
    return 2;

} /* End sib8(). */


/*-----------------------------------------------------------------
 *  Routine:  sib32
 */
ULONG
sib32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    ULONG sib = GET_USER_UBYTE(eip);
    ULONG scale;
    ULONG index;

    PRINTF(("sib32\n"));

    //(Base+Index*Scale)+disp32
    //Get ss: scaled as *1 (00), *2 (01), *4 (10), *8 (11)
    scale = 1 << (sib >> 6);
    index =((sib >> 3)&0x7);
    //Get index: 000-111
    if (index == ESP_INDEX) {
        index = 0;
    } else {
        GET_REG_VIA_NDX(index, index);
    }
    //Get base: 000-111
    sib = (sib & 0x7);
    if (sib == ESP_INDEX) {
        *DataOffset = GET_USER_ULONG(eip + 1) + GET_REG(Esp) + index*scale;
    } else {
        GET_REG_VIA_NDX(*DataOffset, sib);
        *DataOffset += GET_USER_ULONG(eip + 1) + index*scale;
    }
    return 5;

} /* End sib32(). */

/*-----------------------------------------------------------------
 *  Routine:  d32
 */
ULONG
d32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("d32\n"));

    *DataOffset = GET_USER_ULONG(eip);
    return 4;

} /* End d32(). */

/*-----------------------------------------------------------------
 *  Routine:  bp8
 */
ULONG
bp8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("bp8%x\n"));

    *DataOffset = GET_REG(Ebp) + GET_USER_UBYTE(eip);
    return 1;

} /* End bp8(). */


/*-----------------------------------------------------------------
 *  Routine:  bp32
 */
ULONG
bp32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("bp32\n"));

    *DataOffset = GET_REG(Ebp) + GET_USER_ULONG(eip);
    return 4;

} /* End bp32(). */

/*-----------------------------------------------------------------
 *  Routine:  si0
 */
ULONG
si0( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("si0\n"));

    *DataOffset = GET_REG(Esi);
    return 0;

} /* End si0(). */


/*-----------------------------------------------------------------
 *  Routine:  si8
 */
ULONG
si8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("si8\n"));

    *DataOffset = GET_REG(Esi) + GET_USER_UBYTE(eip);
    return 1;

} /* End si8(). */


/*-----------------------------------------------------------------
 *  Routine:  si32
 */
ULONG
si32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("si32\n"));

    *DataOffset = GET_REG(Esi) + GET_USER_ULONG(eip);
    return 4;

} /* End si32(). */

/*-----------------------------------------------------------------
 *  Routine:  di0
 */
ULONG
di0( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("di0\n"));

    *DataOffset = GET_REG(Edi);
    return 0;

} /* End di0(). */


/*-----------------------------------------------------------------
 *  Routine:  di8
 */
ULONG
di8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("di8%x\n"));

    *DataOffset = GET_REG(Edi) + GET_USER_UBYTE(eip);
    return 1;

} /* End di8(). */

/*-----------------------------------------------------------------
 *  Routine:  di32
 */
ULONG
di32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("di32%x\n"));

    *DataOffset = GET_REG(Edi) + GET_USER_ULONG(eip);
    return 4;

} /* End di32(). */


/*-----------------------------------------------------------------
 *  Routine:  reg
 */
ULONG
reg( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("reg, should never be called\n"));

    return 0;

} /* End reg(). */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\filter.c ===
/***
* filter.c - IEEE exception filter routine
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       05-24-92  GDP   written
*       09-01-94  SKS   Change include file from <nt.h> to <windows.h>
*       01-11-95  GJF   Made instr_info_table[] static.
*       02-07-95  CFW   assert -> _ASSERTE.
*       04-07-95  SKS   Clean up prototype of param3 to _fpieee_flt()
*       05-21-98  JWM   FP regs now saved/restored in logical, not physical,
*                       order
*       09-11-98  JWM   Katmai support added
*       10-11-99  PML   Protect against corrupting stack frames (vs7#6472)
*       10-15-99  PML   Pop register file, not just change Top ptr (vs7#5422)
*       11-30-99  PML   Compile /Wp64 clean.
*       04-24-00  PML   _fninit before handling SIMD exceptions (vs7#91746)
*
*******************************************************************************/

#include <trans.h>
#include <windows.h>
#include <dbgint.h>
#include "filter.h"

#pragma warning(disable:4311 4312)      // x86 specific, ignore /Wp64 warnings

void _FillOperand(
    _FPIEEE_VALUE *pOperand,
    PFLOATING_SAVE_AREA pFloatSave,
    int location);

void _UpdateFpCtxt(
    PFLOATING_SAVE_AREA pFloatSave,
    _FPIEEE_VALUE *pOperand,
    int resultLocation,
    int pop);

void _UpdateResult(
    PFLOATING_SAVE_AREA pFloatSave,
    _FPIEEE_VALUE *pOperand,
    int resultLocation);

void _AdjustStack(
    PFLOATING_SAVE_AREA pFloatSave,
    int pop);

int _AdjustLocation(
    int location,
    int pop);

int _PreventStackOverwrite(
    PCONTEXT pctxt,
    int location);

int _IsMemoryLocation(int location);

_FP80 _GetFpRegVal(
    PFLOATING_SAVE_AREA pFloatSave,
    int location);

void _SetFpRegVal(
    PFLOATING_SAVE_AREA pFloatSave,
    int location,
    _FP80 *pval);

void _SetTag(
    ULONG *pTagWord,
    int reg,
    int value);

static _FP80 _zero80 = { 0, 0, 0, 0, 0 };



//
// Define macros for IEEE scaling
// These should be called with all exceptions masked
//


#define SCALE(Operand, adj)          \
    _asm{fild   adj}                 \
    _asm{fld    tbyte ptr Operand}   \
    _asm{fscale}                     \
    _asm{fstp   st(1)}               \
    _asm{fstp   tbyte ptr Operand}



#define FP80_TO_FP64(p64, p80)  \
    _asm{fld    tbyte ptr p80}  \
    _asm{fstp   qword ptr p64}


#define FP80_TO_FP32(p32, p80)  \
    _asm {fld   tbyte ptr p80}  \
    _asm{fstp   dword ptr p32}


static int const _ieee_adj_single = 192;
static int const _ieee_adj_double = 1536;


//
// Define masks for instruction decoding
// x87 instruction form:
//    -------------------------------------------------
//    |      |          |   op  |            |        |
//    | MOD  | OPCODE2  | or REG| 1 1 0 1 1  | OPCODE1|
//    |or op |          | or R/M|  (ESC)     |        |
//    -------------------------------------------------
//    |<-2-->|<---3---->|<--3-->|<---5------>|<--3--->|

#define MASK_OPCODE2    0x3800
#define MASK_REG        0x0700
#define MASK_MOD        0xc000


#define ESC_PREFIX      0xd8
#define MASK_OPCODE1    0x07


typedef struct {
    ULONG   Opcode1:3;
    ULONG   Escape:5;
    ULONG   Reg:3;
    ULONG   Opcode2:3;
    ULONG   Mod:2;
    ULONG   Pad:16;
} X87INSTR, *PX87INSTR;


// define masks for C3,C2,C0 in fp status word

#define C3  (1 << 14)
#define C2  (1 << 10)
#define C0  (1 << 8)

typedef struct {
    ULONG Invalid:1;
    ULONG Denormal:1;
    ULONG ZeroDivide:1;
    ULONG Overflow:1;
    ULONG Underflow:1;
    ULONG Inexact:1;
    ULONG StackFault:1;
    ULONG ErrorSummary:1;
    ULONG CC0:1;
    ULONG CC1:1;
    ULONG CC2:1;
    ULONG Top:3;
    ULONG CC3:1;
    ULONG B:1;
    ULONG Pad:16;
} X87STATUS, *PX87STATUS;


//
// Define Tag word values
//

#define TAG_VALID       0x0
#define TAG_ZERO        0x1
#define TAG_SPECIAL     0x2
#define TAG_EMPTY       0x3



// Sanitize status word macro

#define SANITIZE_STATUS_WORD(pFSave) (pFSave->StatusWord &= ~0xff)




//
// Instruction Information structure
//

typedef struct {
    unsigned long Operation:12;       // Fp Operation code
    unsigned long Op1Location:5;      // Location of 1st operand
    unsigned long Op2Location:5;      // Location of 2nd operand
    unsigned long ResultLocation:5;   // Location of result
    int           PopStack:3;         // # of pops done by the instruction
                                      // (if <0 implies a push)
    unsigned long NumArgs:2;          // # of args to the instruction
} INSTR_INFO, *PINSTR_INFO;


//
// The following table contains instruction information for most
// of the x87 instructions. It is indexed with a 7-bit code (3 last
// bits of 1st byte of the instruction (OPCODE1), 1 bit that
// indicates the presence of a MOD field and 3 bits for OPCODE2.
// Reserved instructions, instructions that are not generated by the
// compiler, and some of the instructions that do not raise IEEE
// exceptions have OP_UNSPEC (unspecified) as Operation code
//

//  By convention FLD instructions and some others (FXTRACT, FSINCOS)
//  have a negative pop value (i.e., they push the stack instead of
//  popping it). In that case the location code specifies the register
//  number after pushing the stack


static INSTR_INFO instr_info_table[128] = {

 {OP_ADD,   ST0,  M32R, ST0,   0, 2 }, // FADD  single real
 {OP_MUL,   ST0,  M32R, ST0,   0, 2 }, // FMUL  single real
 {OP_COMP,  ST0,  M32R, RS,    0, 2 }, // FCOM  single real
 {OP_COMP,  ST0,  M32R, RS,    1, 2 }, // FCOMP single real
 {OP_SUB,   ST0,  M32R, ST0,   0, 2 }, // FSUB  single real
 {OP_SUB,   M32R, ST0,  ST0,   0, 2 }, // FSUBR single real
 {OP_DIV,   ST0,  M32R, ST0,   0, 2 }, // FDIV  single real
 {OP_DIV,   M32R, ST0,  ST0,   0, 2 }, // FDIVR single real

 {OP_ADD,   ST0,  REG,  ST0,   0, 2 }, // FADD  ST, ST(i)
 {OP_MUL,   ST0,  REG,  ST0,   0, 2 }, // FMUL  ST, ST(i)
 {OP_COMP,  ST0,  REG,  RS,    0, 2 }, // FCOM  ST, ST(i)
 {OP_COMP,  ST0,  REG,  RS,    1, 2 }, // FCOMP ST, ST(i)
 {OP_SUB,   ST0,  REG,  ST0,   0, 2 }, // FSUB  ST, ST(i)
 {OP_SUB,   ST0,  REG,  ST0,   0, 2 }, // FSUBR ST, ST(i)
 {OP_DIV,   ST0,  REG,  ST0,   0, 2 }, // FDIV  ST, ST(i)
 {OP_DIV,   ST0,  REG,  ST0,   0, 2 }, // FDIVR ST, ST(i)

 {OP_CVT,   M32R, INV,  ST0,  -1, 1 }, // FLD   single real
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_CVT,   ST0,  INV,  M32R,  0, 1 }, // FST   single real
 {OP_CVT,   ST0,  INV,  M32R,  1, 1 }, // FSTP  single real
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FLDENV
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FLDCW
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FSTENV
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FSTCW

 {OP_CVT,   REG,  INV,  ST0,  -1, 1 }, // FLD   ST(i)
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FXCH
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FNOP or reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_COMP,  ST0,  Z80R, RS,    0, 2 }, // FTST (only this may raise IEEE exc)
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FLDxx (no IEEE exceptions)
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // instructions not generated by cl386
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // instructions not generated by cl386

 {OP_ADD,   ST0,  M32I, ST0,   0, 2 }, // FIADD  short integer
 {OP_MUL,   ST0,  M32I, ST0,   0, 2 }, // FIMUL  short integer
 {OP_COMP,  ST0,  M32I, RS,    0, 2 }, // FICOM  short integer
 {OP_COMP,  ST0,  M32I, RS,    1, 2 }, // FICOMP short integer
 {OP_SUB,   ST0,  M32I, ST0,   0, 2 }, // FISUB  short integer
 {OP_SUB,   M32I, ST0,  ST0,   0, 2 }, // FISUBR short integer
 {OP_DIV,   ST0,  M32I, ST0,   0, 2 }, // FIDIV  short integer
 {OP_DIV,   M32I, ST0,  ST0,   0, 2 }, // FIDIVR short integer

 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_COMP,  ST0,  ST1,  RS,    2, 2 }, // FUCOMPP
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved

 {OP_CVT,   M32I, INV,  ST0,  -1, 1 }, // FILD  short integer
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_CVT,   ST0,  INV,  M32I,  0, 1 }, // FIST  short integer
 {OP_CVT,   ST0,  INV,  M32I,  1, 1 }, // FISTP short integer
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_CVT,   M80R, INV,  ST0,  -1, 1 }, // FLD   extended real
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_CVT,   ST0,  INV,  M80R,  1, 1 }, // FSTP  extended real

 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FCLEX, FINIT, or reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved

 {OP_ADD,   ST0,  M64R, ST0,   0, 2 }, // FADD  double real
 {OP_MUL,   ST0,  M64R, ST0,   0, 2 }, // FMUL  double real
 {OP_COMP,  ST0,  M64R, RS,    0, 2 }, // FCOM  double real
 {OP_COMP,  ST0,  M64R, RS,    1, 2 }, // FCOMP double real
 {OP_SUB,   ST0,  M64R, ST0,   0, 2 }, // FSUB  double real
 {OP_SUB,   M64R, ST0,  ST0,   0, 2 }, // FSUBR double real
 {OP_DIV,   ST0,  M64R, ST0,   0, 2 }, // FDIV  double real
 {OP_DIV,   M64R, ST0,  ST0,   0, 2 }, // FDIVR double real

 {OP_ADD,   REG,  ST0,  REG,   0, 2 }, // FADD  ST(i), ST
 {OP_MUL,   REG,  ST0,  REG,   0, 2 }, // FMUL  ST(i), ST
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_SUB,   REG,  ST0,  REG,   0, 2 }, // FSUBR ST(i), ST
 {OP_SUB,   ST0,  REG,  REG,   0, 2 }, // FSUB  ST(i), ST
 {OP_DIV,   REG,  ST0,  REG,   0, 2 }, // FDIVR ST(i), ST
 {OP_DIV,   ST0,  REG,  REG,   0, 2 }, // FDIV  ST(i), ST

 {OP_CVT,   M64R, INV,  ST0,  -1, 1 }, // FLD   double real
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_CVT,   ST0,  INV,  M64R,  0, 1 }, // FST   double real
 {OP_CVT,   ST0,  INV,  M64R,  1, 1 }, // FSTP  double real
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FRSTOR
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FSAVE
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FSTSW

 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FFREE ST(i)
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_CVT,   ST0,  INV,  REG,   0, 1 }, // FST   ST(i)
 {OP_CVT,   ST0,  INV,  REG,   1, 1 }, // FSTP  ST(i)
 {OP_COMP,  ST0,  REG,  RS,    0, 2 }, // FUCOM ST(i)
 {OP_COMP,  ST0,  REG,  RS,    1, 2 }, // FUCOMP ST(i)
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved

 {OP_ADD,   ST0,  M16I, ST0,   0, 2 }, // FIADD  word integer
 {OP_MUL,   ST0,  M16I, ST0,   0, 2 }, // FIMUL  word integer
 {OP_COMP,  ST0,  M16I, RS,    0, 2 }, // FICOM  word integer
 {OP_COMP,  ST0,  M16I, RS,    1, 2 }, // FICOMP word integer
 {OP_SUB,   ST0,  M16I, ST0,   0, 2 }, // FISUB  word integer
 {OP_SUB,   M16I, ST0,  ST0,   0, 2 }, // FISUBR word integer
 {OP_DIV,   ST0,  M16I, ST0,   0, 2 }, // FIDIV  word integer
 {OP_DIV,   M16I, ST0,  ST0,   0, 2 }, // FIDIVR word integer

 {OP_ADD,   REG,  ST0,  REG,   1, 2 }, // FADDP  ST(i), ST
 {OP_MUL,   REG,  ST0,  REG,   1, 2 }, // FMULP  ST(i), ST
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_COMP,  ST0,  ST1,  RS,    2, 0 }, // FCOMPP (or reserved)
 {OP_SUB,   REG,  ST0,  REG,   1, 2 }, // FSUBRP ST(i), ST
 {OP_SUB,   ST0,  REG,  REG,   1, 2 }, // FSUBP  ST(i), ST
 {OP_DIV,   REG,  ST0,  REG,   1, 2 }, // FDIVRP ST(i), ST
 {OP_DIV,   ST0,  REG,  REG,   1, 2 }, // FDIVP  ST(i), ST

 {OP_CVT,   M16I, INV,  ST0,  -1, 1 }, // FILD  word integer
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_CVT,   ST0,  INV,  M16I,  0, 1 }, // FIST  word integer
 {OP_CVT,   ST0,  INV,  M16I,  1, 1 }, // FISTP word integer
 {OP_CVT,   M80D, INV,  ST0,  -1, 0 }, // FBLD  packed decimal
 {OP_CVT,   M64I, INV,  ST0,  -1, 1 }, // FILD  long integer
 {OP_CVT,   ST0,  INV,  M80D,  1, 1 }, // FBSTP packed decimal
 {OP_CVT,   ST0,  INV,  M64I,  1, 1 }, // FISTP long integer

 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FSTSW AX or reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
};



extern int fpieee_flt_simd(unsigned long exc_code, PEXCEPTION_POINTERS p,
           int (__cdecl *handler) (_FPIEEE_RECORD *));



/***
* _fpieee_flt - IEEE fp filter routine
*
*Purpose:
*   Invokes the user's trap handler on IEEE fp exceptions and provides
*   it with all necessary information
*
*Entry:
*   unsigned long exc_code: the NT exception code
*   PEXCEPTION_POINTERS p: a pointer to the NT EXCEPTION_POINTERS struct
*   int handler (_FPIEEE_RECORD *): a user supplied ieee trap handler
*
*   Note: The IEEE filter routine does not handle some transcendental
*   instructions. This can be done at the cost of additional decoding.
*   Since the compiler does not generate these instructions, no portable
*   program should be affected by this fact.
*
*Exit:
*   returns the value returned by handler
*
*Exceptions:
*
*******************************************************************************/
int _fpieee_flt(unsigned long exc_code,
                PEXCEPTION_POINTERS p,
                int (__cdecl *handler) (_FPIEEE_RECORD *))
{
    PEXCEPTION_RECORD pexc;
    PCONTEXT pctxt;
    PFLOATING_SAVE_AREA pFloatSave;
    _FPIEEE_RECORD ieee;
    ULONG *pinfo;
    X87INSTR instr;
    PINSTR_INFO ptable;
    int ret, index;
    int mod;
    ULONG cw, sw;

    ULONG op1Location, op2Location, resultLocation;
    ULONG newOp1Location, newOp2Location, newResultLocation;



    //
    // If the exception is not an IEEE exception, continue search
    // for another handler
    //


    if (exc_code != STATUS_FLOAT_DIVIDE_BY_ZERO &&
        exc_code != STATUS_FLOAT_INEXACT_RESULT &&
        exc_code != STATUS_FLOAT_INVALID_OPERATION &&
        exc_code != STATUS_FLOAT_OVERFLOW &&
        exc_code != STATUS_FLOAT_UNDERFLOW &&
        exc_code != STATUS_FLOAT_MULTIPLE_FAULTS &&
        exc_code != STATUS_FLOAT_MULTIPLE_TRAPS) {

        return EXCEPTION_CONTINUE_SEARCH;
    }

    _asm{fninit}

    /* Handle Katmai exceptions separately */
    if (exc_code == STATUS_FLOAT_MULTIPLE_FAULTS ||
        exc_code == STATUS_FLOAT_MULTIPLE_TRAPS) {
        return fpieee_flt_simd(exc_code, p, handler);
    }


    pexc = p->ExceptionRecord;
    pinfo = pexc->ExceptionInformation;
    pctxt = p->ContextRecord;
    pFloatSave = &pctxt->FloatSave;



    //
    // Check for software generated exception
    //
    // By convention the first argument to the exception is
    // 0 for h/w exception. For s/w exceptions it points
    // to the _FPIEEE_RECORD
    //

    if (pinfo[0]) {

        /*
         * we have a software exception:
         * the first parameter points to the IEEE structure
         */

        if ((ret = handler((_FPIEEE_RECORD *)(pinfo[0]))) ==
             EXCEPTION_CONTINUE_EXECUTION) {

            //
            // Sanitize status word only if there is continuation
            //

            SANITIZE_STATUS_WORD(pFloatSave);
        }

        return ret;
    }


    //
    // If control reaches here, then we have to deal with a
    // hardware exception
    //


    //
    // If the first byte of the instruction does not contain
    // the ESCAPE bit pattern (1101) there may be an instruction
    // prefix for segment override or address size. The filter
    // routine does not handle this.
    //

    if ((*(UCHAR *)(pFloatSave->ErrorOffset)&~MASK_OPCODE1) != ESC_PREFIX) {

        _ASSERT(0);
        return EXCEPTION_CONTINUE_SEARCH;
    }

    *(USHORT *)&instr = *(USHORT *)(pFloatSave->ErrorOffset);

    mod = instr.Mod == 0x3 ? 1 : 0;
    index = instr.Opcode1 << 4 | mod << 3 | instr.Opcode2;
    ptable = instr_info_table + index;

    ieee.Operation = ptable->Operation;


    cw = pFloatSave->ControlWord;
    sw = pFloatSave->StatusWord;



    //
    // decode fp environment information
    //


    switch (cw & IMCW_RC) {
    case IRC_NEAR:
        ieee.RoundingMode = _FpRoundNearest;
        break;

    case IRC_DOWN:
        ieee.RoundingMode = _FpRoundMinusInfinity;
        break;

    case IRC_UP:
        ieee.RoundingMode = _FpRoundPlusInfinity;
        break;

    case IRC_CHOP:
        ieee.RoundingMode = _FpRoundChopped;
        break;
    }

    switch (cw & IMCW_PC) {
    case IPC_64:
        ieee.Precision = _FpPrecisionFull;
        break;
    case IPC_53:
        ieee.Precision = _FpPrecision53;
        break;
    case IPC_24:
        ieee.Precision = _FpPrecision24;
        break;
    }

    ieee.Enable.Inexact = cw & IEM_INEXACT ? 0 : 1;
    ieee.Enable.Underflow = cw & IEM_UNDERFLOW ? 0 : 1;
    ieee.Enable.Overflow = cw & IEM_OVERFLOW ? 0 : 1;
    ieee.Enable.ZeroDivide = cw & IEM_ZERODIVIDE ? 0 : 1;
    ieee.Enable.InvalidOperation = cw & IEM_INVALID ? 0 : 1;

    ieee.Status.Inexact = sw & ISW_INEXACT ? 1 : 0;
    ieee.Status.Underflow = sw & ISW_UNDERFLOW ? 1 : 0;
    ieee.Status.Overflow = sw & ISW_OVERFLOW ? 1 : 0;
    ieee.Status.ZeroDivide = sw & ISW_ZERODIVIDE ? 1 : 0;
    ieee.Status.InvalidOperation = sw & ISW_INVALID ? 1 : 0;

    ieee.Cause.Inexact = ieee.Enable.Inexact && ieee.Status.Inexact;
    ieee.Cause.Underflow = ieee.Enable.Underflow && ieee.Status.Underflow;
    ieee.Cause.Overflow = ieee.Enable.Overflow && ieee.Status.Overflow;
    ieee.Cause.ZeroDivide = ieee.Enable.ZeroDivide && ieee.Status.ZeroDivide;
    ieee.Cause.InvalidOperation = ieee.Enable.InvalidOperation && ieee.Status.InvalidOperation;

    //
    // If location is REG, the register number is
    // encoded in the instruction
    //

    op1Location = ptable->Op1Location == REG ?
                  instr.Reg :
                  ptable->Op1Location;


    op2Location = ptable->Op2Location == REG ?
                  instr.Reg :
                  ptable->Op2Location;

    resultLocation = ptable->ResultLocation == REG ?
                  instr.Reg :
                  ptable->ResultLocation;


    switch (exc_code) {
    case STATUS_FLOAT_INVALID_OPERATION:
    case STATUS_FLOAT_DIVIDE_BY_ZERO:

        //
        // Invalid Operation and Divide by zero are detected
        // before the operation begins; therefore the NPX
        // register stack and memory have not been updated
        //

        _FillOperand(&ieee.Operand1, pFloatSave, op1Location);
        _FillOperand(&ieee.Operand2, pFloatSave, op2Location);

        _FillOperand(&ieee.Result, pFloatSave, resultLocation);

        //
        // The previous call was only good for setting the
        // result Format. Since the
        // operation has not begun yet, the result location
        // may contain an incorrect value.
        // For this reason, set OperandValid to 0
        //

        ieee.Result.OperandValid = 0;


        if ((ret = handler (&ieee)) == EXCEPTION_CONTINUE_EXECUTION) {

            resultLocation = _PreventStackOverwrite(pctxt,
                                                    resultLocation);

            _UpdateFpCtxt(pFloatSave,
                          &ieee.Result,
                          resultLocation,
                          ptable->PopStack);
        }

        break;


    case STATUS_FLOAT_OVERFLOW:
    case STATUS_FLOAT_UNDERFLOW:

        //
        // Overflow and Underflow exception
        // A result has already been computed and the stack has
        // been adjusted, unless the destination is memory (FST instruction)
        //

        if (_IsMemoryLocation(ptable->ResultLocation)) {
            _FP80 tmp;
            _FP32 ftmp;
            _FP64 dtmp;

            int adj;

            //
            // FST(P) instruction (takes only one argument)
            //

            _FillOperand(&ieee.Operand1, pFloatSave, op1Location);
            tmp = _GetFpRegVal(pFloatSave, 0);

            ieee.Result.OperandValid = 1;

            if (resultLocation == M32R) {
                ieee.Result.Format = _FpFormatFp32;
                adj = _ieee_adj_single;
            }
            else {
                ieee.Result.Format = _FpFormatFp64;
                adj = _ieee_adj_double;
            }

            if (exc_code == STATUS_FLOAT_OVERFLOW) {
                adj = -adj;
            }

            SCALE(tmp, adj)

            if (resultLocation == M32R){
                FP80_TO_FP32(ftmp,tmp)
                ieee.Result.Value.Fp32Value = ftmp;
            }
            else {
                FP80_TO_FP64(dtmp,tmp)
                ieee.Result.Value.Fp64Value = dtmp;
            }
            _asm{fnclex}


            if ((ret = handler (&ieee)) == EXCEPTION_CONTINUE_EXECUTION) {

                resultLocation = _PreventStackOverwrite(pctxt,
                                                        resultLocation);

                _UpdateFpCtxt(pFloatSave,
                              &ieee.Result,
                              resultLocation,
                              ptable->PopStack);
            }

            break;
        }


        // NO BREAK

    case STATUS_FLOAT_INEXACT_RESULT:

        //
        // Stack has already been adjusted, so we should compute
        // the new location of operands and result
        //


        newOp1Location = _AdjustLocation(op1Location, ptable->PopStack);
        newOp2Location = _AdjustLocation(op2Location, ptable->PopStack);
        newResultLocation = _AdjustLocation(resultLocation, ptable->PopStack);

        if (newOp1Location == newResultLocation)
            newOp1Location = INV;

        if (newOp2Location == newResultLocation)
            newOp2Location = INV;

        _FillOperand(&ieee.Result, pFloatSave, newResultLocation);
        _FillOperand(&ieee.Operand1, pFloatSave, newOp1Location);
        _FillOperand(&ieee.Operand2, pFloatSave, newOp2Location);


        if ((ret = handler (&ieee)) == EXCEPTION_CONTINUE_EXECUTION) {

            newResultLocation = _PreventStackOverwrite(pctxt,
                                                       newResultLocation);

            _UpdateFpCtxt(pFloatSave,
                          &ieee.Result,
                          newResultLocation,
                          0);

            //
            // no need to adjust the stack
            //
        }

        break;
    }

    if (ret == EXCEPTION_CONTINUE_EXECUTION) {


        SANITIZE_STATUS_WORD(pFloatSave);


        //
        // make fp control word changes take effect on continuation
        //

        cw = pFloatSave->ControlWord;

        switch (ieee.RoundingMode) {
        case _FpRoundNearest:
            cw = cw & ~ IMCW_RC | IRC_NEAR & IMCW_RC;
            break;
        case _FpRoundMinusInfinity:
            cw = cw & ~ IMCW_RC | IRC_DOWN & IMCW_RC;
            break;
        case _FpRoundPlusInfinity:
            cw = cw & ~ IMCW_RC | IRC_UP & IMCW_RC;
            break;
        case _FpRoundChopped:
            cw = cw & ~ IMCW_RC | IRC_CHOP & IMCW_RC;
            break;
        }
        switch (ieee.Precision) {
        case _FpPrecisionFull:
            cw = cw & ~ IMCW_PC | IPC_64 & IMCW_PC;
            break;
        case _FpPrecision53:
            cw = cw & ~ IMCW_PC | IPC_53 & IMCW_PC;
            break;
        case _FpPrecision24:
            cw = cw & ~ IMCW_PC | IPC_24 & IMCW_PC;
            break;
        }

        ieee.Enable.Inexact ? (cw &= ~IEM_INEXACT)
                    : (cw |= IEM_INEXACT);
        ieee.Enable.Underflow ? (cw &= ~IEM_UNDERFLOW)
                    : (cw |= IEM_UNDERFLOW);
        ieee.Enable.Overflow ? (cw &= ~IEM_OVERFLOW)
                   : (cw |= IEM_OVERFLOW);
        ieee.Enable.ZeroDivide ? (cw &= ~IEM_ZERODIVIDE)
                     : (cw |= IEM_ZERODIVIDE);
        ieee.Enable.InvalidOperation ? (cw &= ~IEM_INVALID)
                           : (cw |= IEM_INVALID);

        pFloatSave->ControlWord = cw;


    }


    return ret;
}





/***
* _FillOperand - Fill in operand information
*
*Purpose:
*   Fill in a _FPIEEE_VALUE record based on the information found in
*   the floating point context and the location code
*
*
*Entry:
*    _FPIEEE_VALUE *pOperand        pointer to the operand to be filled in
*    PFLOATING_SAVE_AREA pFloatSave pointer to the floating point context
*    int location                   location code of the operand
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/



void _FillOperand(
    _FPIEEE_VALUE *pOperand,
    PFLOATING_SAVE_AREA pFloatSave,
    int location)
{
    int c0,c2,c3;

    //
    // Assume valid operand (this is almost always the case)
    //

    pOperand->OperandValid = 1;


    switch (location) {
    case ST0:
    case ST1:
    case ST2:
    case ST3:
    case ST4:
    case ST5:
    case ST6:
    case ST7:

        //
        // By convention the location code contains the number of the
        // floating point register
        //

        pOperand->Format = _FpFormatFp80;
        pOperand->Value.Fp80Value = _GetFpRegVal(pFloatSave, location);
        break;

    case M80R:
        pOperand->Format = _FpFormatFp80;
        pOperand->Value.Fp80Value = *(_FP80 *)(pFloatSave->DataOffset);
        break;

    case M16I:
        pOperand->Format = _FpFormatI16;
        pOperand->Value.I16Value = *(_I16 *)(pFloatSave->DataOffset);
        break;

    case M32I:
        pOperand->Format = _FpFormatI32;
        pOperand->Value.I32Value = *(_I32 *)(pFloatSave->DataOffset);
        break;

    case M64I:
        pOperand->Format = _FpFormatI64;
        pOperand->Value.I64Value = *(_I64 *)(pFloatSave->DataOffset);
        break;

    case M64R:
        pOperand->Format = _FpFormatFp64;
        pOperand->Value.Fp64Value = *(_FP64 *)(pFloatSave->DataOffset);
        break;

    case M32R:
        pOperand->Format = _FpFormatFp32;
        pOperand->Value.Fp32Value = *(_FP32 *)(pFloatSave->DataOffset);
        break;

    case M80D:
        pOperand->Format = _FpFormatBcd80;
        pOperand->Value.Bcd80Value = *(_BCD80 *)(pFloatSave->DataOffset);
        break;

    //
    // Status register is used only for comparison instructions
    // therefore the format should be _FpFormatCompare
    //

    case RS:
        pOperand->Format = _FpFormatCompare;
        c0 = pFloatSave->StatusWord & C0 ? (1<<0) : 0;
        c2 = pFloatSave->StatusWord & C2 ? (1<<2) : 0;
        c3 = pFloatSave->StatusWord & C0 ? (1<<3) : 0;

        switch(c0 | c2 | c3) {
        case 0x000:

            // ST > SRC

            pOperand->Value.CompareValue = _FpCompareGreater;
            break;

        case 0x001:

            // ST < SRC

            pOperand->Value.CompareValue = _FpCompareLess;
            break;

        case 0x100:

            // ST = SRC

            pOperand->Value.CompareValue = _FpCompareEqual;
            break;

        default:

            pOperand->Value.CompareValue = _FpCompareUnordered;
            break;
        }

        break;


    case Z80R:
        pOperand->Format = _FpFormatFp80;
        pOperand->Value.Fp80Value = _zero80;
        break;

    case INV:

        pOperand->OperandValid = 0;
        break;


    case REG:

        //
        // Control should never reach here. REG should have already
        // been replaced with a code that corresponds to the register
        // encoded in the instruction

        _ASSERT(0);
        pOperand->OperandValid = 0;
        break;

    }
}




/***
* _UpdateFpCtxt - Update fp context
*
*Purpose:
*   Copy the operand information to  the snapshot of the floating point
*   context or memory, as to make it available on continuation and
*   adjust the fp stack accordingly
*
*
*Entry:
*
*   PFLOATING_SAVE_AREA pFloatSave    pointer to the floating point context
*   _FPIEEE_VALUE *pOperand           pointer to source operand
*   int location                      location code for destination in the
*                                     floating point context
*   int pop                           # of times the stack should be popped
*                                     (if negative, the stack is pushed)
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void _UpdateFpCtxt(
    PFLOATING_SAVE_AREA pFloatSave,
    _FPIEEE_VALUE *pOperand,
    int location,
    int pop)
{
    if (pop < 0) {
        _AdjustStack(pFloatSave, pop);
    }

    _UpdateResult(pFloatSave, pOperand, location);

    if (pop > 0) {
        _AdjustStack(pFloatSave, pop);
    }
}




/***
* _UpdateResult -  Update result information in the fp context
*
*Purpose:
*   Copy the operand information to  the snapshot of the floating point
*   context or memory, as to make it available on continuation
*
*Entry:
*
*   PFLOATING_SAVE_AREA pFloatSave    pointer to the floating point context
*   _FPIEEE_VALUE *pOperand           pointer to source operand
*   int location)                     location code for destination in the
*                                     floating point context
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void _UpdateResult(
    PFLOATING_SAVE_AREA pFloatSave,
    _FPIEEE_VALUE *pOperand,
    int location)
{

    switch (location) {
    case ST0:
    case ST1:
    case ST2:
    case ST3:
    case ST4:
    case ST5:
    case ST6:
    case ST7:

        //
        // By convention the location code contains the number of the
        // floating point register
        //

        _SetFpRegVal(pFloatSave,location,&pOperand->Value.Fp80Value);
        break;

    case M80R:
        *(_FP80 *)(pFloatSave->DataOffset) = pOperand->Value.Fp80Value;
        break;

    case M16I:
        *(_I16 *)(pFloatSave->DataOffset) = pOperand->Value.I16Value;
        break;

    case M32I:
        *(_I32 *)(pFloatSave->DataOffset) = pOperand->Value.I32Value;
        break;

    case M64I:
        *(_I64 *)(pFloatSave->DataOffset) = pOperand->Value.I64Value;
        break;

    case M64R:
        *(_FP64 *)(pFloatSave->DataOffset) = pOperand->Value.Fp64Value;
        break;

    case M32R:
        *(_FP32 *)(pFloatSave->DataOffset) = pOperand->Value.Fp32Value;
        break;

    case M80D:
        *(_BCD80 *)(pFloatSave->DataOffset) = pOperand->Value.Bcd80Value;
        break;

    //
    // Status register is used only for comparison instructions
    // therefore the format should be _FpFormatCompare
    //

    case RS:
        switch (pOperand->Value.CompareValue) {
        case _FpCompareEqual:
            // C3,C2,C0 <- 100
            pFloatSave->StatusWord |= C3;
            pFloatSave->StatusWord &= (~C2 & ~C0);
            break;
        case _FpCompareGreater:
            // C3,C2,C0 <- 000
            pFloatSave->StatusWord &= (~C3 & ~C2 & ~C0);
            break;
        case _FpCompareLess:
            // C3,C2,C0 <- 001
            pFloatSave->StatusWord |= C0;
            pFloatSave->StatusWord &= (~C3 & ~C2);
            break;
        case _FpCompareUnordered:
            // C3,C2,C0 <- 111
            pFloatSave->StatusWord |= (C3 | C2 | C0);
            break;
        }


    case INV:

        break;

    case REG:
    case Z80R:

        //
        // Control should never reach here. REG should have already
        // been replaced with a code that corresponds to the register
        // encoded in the instruction

        _ASSERT(0);
        break;

    }
}




/***
* _AdjustStack -
*
*Purpose:
*  Pop (or push) the image of the fp stack in the fp context
*
*Entry:
*  PFLOATING_SAVE_AREA pFloatSaveArea:  pointer to the fp context
*  int pop:     Number of times to pop the stack
*               (if pop<0 stack should be pushed once)
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/


void _AdjustStack(
    PFLOATING_SAVE_AREA pFloatSave,
    int pop)
{
    PX87STATUS pStatus;
    _FP80 tempRegFile[8];
    int i;

    pStatus = (PX87STATUS) &pFloatSave->StatusWord;

    if (pop > 0) {

        // stack should be popped

        for (i=0; i<pop; i++) {

            //
            // mark register as invalid
            //

            _SetTag(&pFloatSave->TagWord, pStatus->Top, TAG_EMPTY);

            pStatus->Top++;
        }

        // pop (rotate) register save area

        memcpy(tempRegFile, pFloatSave->RegisterArea, pop * sizeof(_FP80));
        memmove(pFloatSave->RegisterArea,
                ((_FP80 *)pFloatSave->RegisterArea) + pop,
                (8 - pop) * sizeof(_FP80));
        memcpy(((_FP80 *)pFloatSave->RegisterArea) + (8 - pop),
               tempRegFile,
               pop * sizeof(_FP80));

    }

    else if (pop < 0) {

        // stack should be pushed once (e.g., fsincos, fxtract)

        //
        // mark register as valid
        //

        pStatus->Top--;

        _SetTag(&pFloatSave->TagWord, pStatus->Top, TAG_VALID);

        // push (rotate) register save area just once

        memmove(((_FP80 *)pFloatSave->RegisterArea) + 1,
                pFloatSave->RegisterArea,
                7 * sizeof(_FP80));

    }
}



/***
* _AdjustLocation -
*
*Purpose:
*   Modify location code based on stack adjustment
*
*Entry:
*   int location:   old location code
*   int pop:        stack adjustment factor (>0 for pop, <0 for push)
*
*Exit:
*   returns new location code
*
*Exceptions:
*
*******************************************************************************/


int _AdjustLocation(int location, int pop)
{

    int newlocation;

    switch (location) {
    case ST0:
    case ST1:
    case ST2:
    case ST3:
    case ST4:
    case ST5:
    case ST6:
    case ST7:

        newlocation = location - pop;
        if (newlocation < 0 || newlocation > 7) {
            newlocation = INV;
        }
        break;

    default:
        newlocation = location;
    }

    return newlocation;

}


/***
* _PreventStackOverwrite -
*
*Purpose:
*  Checks if a memory result location is to a stale stack address, where
*  writing to that address would corrupt some newer stack frame.  This can
*  happen when a pending exception was for an FST to a stack local, but the
*  exception wasn't triggered until after the enclosing function exited and
*  the stack local no longer exists, so that it's memory is now being used
*  by an exception handling routine.
*
*Entry:
*  int location:    result location code
*
*Exit:
*  Returns a location code of INV if stack corruption would occur, otherwise
*  returns the entry location code unchanged.
*
*Exceptions:
*
*******************************************************************************/

int _PreventStackOverwrite(PCONTEXT pctxt, int location)
{
    if (_IsMemoryLocation(location)) {

        if (pctxt->Esp > pctxt->FloatSave.DataOffset) {

            //
            // Memory result location is below ESP of FP instr where pending
            // exception was raised
            //

            uintptr_t curESP;
            _asm {
                push    esp
                pop     eax
                mov     curESP, eax
            }

            if (curESP <= pctxt->FloatSave.DataOffset + sizeof(M80R)) {

                //
                // Memory result is in the stack frame of an exception
                // handling function - suppress the update.
                //

                location = INV;
            }
        }
    }

    return location;
}

/***
* _IsMemoryLocation -
*
*Purpose:
*  Returns true if the location code specifies a memory location,
*  otherwise it returns false.
*
*
*Entry:
*  int location:    location code
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

int _IsMemoryLocation(int location)
{
    switch (location) {
    case M80R:
    case M16I:
    case M32I:
    case M64I:
    case M64R:
    case M32R:
    case M80D:
        return 1;
    }

    return 0;

}







/***
* _GetFpRegVal - Get floating point register value
*
*Purpose:
* Return the value of the floating point register ST(stacklocation)
* found in the saved floating point context
*
*Entry:
* PFLOATING_SAVE_AREA pFloatSave  floating point context
* int stackLocation               location of register relative to stack top
*
*Exit:
* returns the register value in _FP80 format
*
*Exceptions:
*
*******************************************************************************/

_FP80 _GetFpRegVal(
    PFLOATING_SAVE_AREA pFloatSave,
    int stackLocation)
{
    if (stackLocation>=0 && stackLocation<8)
        return *((_FP80 *)(pFloatSave->RegisterArea)+stackLocation);
    else
        return _zero80;
}



/***
* _SetFpRegVal - Set floating point register value
*
*Purpose:
* Set the value of the floating point register ST(stacklocation)
* found in the saved floating point context
*
*Entry:
* PFLOATING_SAVE_AREA pFloatSave  floating point context
* int stackLocation               location of register relative to stack top
* _FP80 *pval                     pointer to the new value
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void _SetFpRegVal(
    PFLOATING_SAVE_AREA pFloatSave,
    int stackLocation,
    _FP80 *pval)
{
    PX87STATUS pStatus;
    int n;
    int tag;

    pStatus = (PX87STATUS) &pFloatSave->StatusWord;

    if (stackLocation>=0 && stackLocation<8) {
        *((_FP80 *)(pFloatSave->RegisterArea)+stackLocation) = *pval;

        n = (pStatus->Top+stackLocation) % 8;

        //
        // Update tag word
        //

        switch (pval->W[4] & 0x7fff) { // check value of the exponent

        case 0:
            if (*(ULONG *)pval == 0 && *((ULONG *)pval+1) == 0) {
                // zero
                tag = TAG_ZERO;
            }
            else {
                // denormal or invalid
                tag = TAG_SPECIAL;
            }
            break;


        case 0x7fff:
            // infinity or NaN
            tag = TAG_SPECIAL;
            break;

        default:
            // valid
            tag = TAG_VALID;
        }

        _SetTag(&pFloatSave->TagWord, n, tag);
    }
}



/***
* _SetTag -
*
*Purpose:
* Set tag of register 'reg' in  tag word to 'value'
*
*
*Entry:
*   ULONG *pTagWord        pointer to the tagword to be modified
*   int reg                absolute register number (NOT relative to stack top)
*   int value              new tag value (empty, valid, zero, special)
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void _SetTag(
    ULONG *pTagWord,
    int reg,
    int value)
{
    ULONG mask;
    int shift;

    shift = reg << 1;
    mask = 0x3 << shift;
    value <<= shift;

    *pTagWord = *pTagWord & ~mask | value & mask;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\disp_pentium4.inc ===
.XMM

	CODESEG

	ALIGN	4
	
ifdef _NTSUBSET_	
	ifdef	_FUNC_DEF_EXTERN_
	extrn	_FUNC_DEF_:proc
	endif
	
	PUBLIC	_FUNC_

_FUNC_	PROC NEAR
	jmp	_FUNC_DEF_	; jmp to old code

_FUNC_	ENDP
else


	extrn	__use_sse2_mathfcns:dword

	ifdef	_FUNC_DEF_EXTERN_
	extrn	_FUNC_DEF_:proc
	endif

	ifdef	_FUNC_P4_EXTERN_
	extrn	_FUNC_P4_:proc
	endif

	PUBLIC	_FUNC_

_FUNC_	PROC NEAR

 	cmp	DWORD PTR __use_sse2_mathfcns, 0
 	je	_FUNC_DEF_	; not P4 go to MS code

	sub	esp, 8
	stmxcsr	dword ptr [esp+4]
	mov	eax, dword ptr [esp+4]
	and	eax, 01f80h	;mscxr mask
	cmp	eax, 01f80h
	jne	short jnedef	;if unmasked, we vector off to the MS code 

	;check if any x87 FP exceptions are unmasked
	fnstcw	word ptr [esp]
	mov	ax, word ptr [esp]
	and	ax, 07fh
	cmp	ax, 07fh
jnedef:	lea	esp, [esp+8]	;(release stack, preserve CC)
	jne	_FUNC_DEF_	;if unmasked, we vector off to the MS code 

	jmp	_FUNC_P4_	; ok to go to Intel code

_FUNC_	ENDP
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\floor_pentium4.asm ===
; file: floor_wmt.asm

; Copyright  (C) 1985-2000 Intel Corporation.
;
; The information and source code contained herein is the exclusive property
; of Intel Corporation and may not be disclosed, examined, or reproduced in
; whole or in part without explicit written authorization from the Company.
;
; Implemented in VNIIEF-STL, july 2000

; double floor (double x)
;
; Willamette specific version (MASM 6.15 required)
;
; Description:
;  The floor functions return the largest integer value not greater than x,
;  expressed as a (double-precision) floating-point number.
;
; Special cases:
;  floor(NaN) = that NaN
;  floor(INF) = that INF
;  floor(0) = that 0
;
; Accuracy:
;  The result is always exact.

.xlist
	include cruntime.inc
.list

EXTRN C __libm_error_support : NEAR  

_FUNC_     equ	<floor>
_FUNC_DEF_ equ	<_floor_default>
_FUNC_P4_  equ	<_floor_pentium4>
_FUNC_DEF_EXTERN_ equ 1
	include	disp_pentium4.inc

      .const
      ALIGN 16

;-- 16x-aligned data --------------------------------------------------------

_One     DQ 03ff0000000000000H,03ff0000000000000H
_Bns     DQ 00000000000000433H,00000000000000433H
_NegOne  DQ 0bff0000000000000H,04330000000000000H
_NegZero DQ 08000000000000000H,08000000000000000H
_S       DQ 000000000000007ffH,00000000000000000H

      codeseg
      ALIGN 16

; double floor (double x);

; Stack frame locations

floor_x TEXTEQU <esp+4>
XMMWORD TEXTEQU <OWORD>  

PUBLIC _floor_pentium4
_floor_pentium4 PROC NEAR
    movq      xmm0, QWORD PTR [floor_x]          ; X
    movapd    xmm2, XMMWORD PTR _Bns             ;
    movapd    xmm1, xmm0                         ;
    movapd    xmm7, xmm0                         ;
    psrlq     xmm0, 52                           ; exp(x)    ; sign(X) | exp(X) in XMM reg
    movd      eax, xmm0                          ; sign(X) | exp(X) in eax reg
    andpd     xmm0, XMMWORD PTR _S               ; exp(X) (+3ff)
    psubd     xmm2, xmm0                         ; exp(X)
    psrlq     xmm1, xmm2                         ; truncate the fraction (shift right)

    test      eax, 0800h                         ;
    jne       SHORT negat                        ; if (X<0.0) goto negat
    cmp       eax, 03ffh                         ;**** POSITIVE X *****
    jl        SHORT ret_zero                     ; if (X<1.0) return zero
    psllq     xmm1, xmm2                         ; truncate the fraction (integer part)
    cmp       eax, 0432h                         ; if X is integer, return X
    jg        SHORT return_x
    movq      QWORD PTR [floor_x], xmm1          ; save integer part
    fld       QWORD PTR [floor_x]                ; return integer part
    ret                                          ;

return_x:

    ucomisd   xmm7, xmm7
    jnp       not_nan

    mov       edx, 1005
    ;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
    sub       esp, 16
    mov       DWORD PTR [esp+12],edx
    mov       edx, esp
    add       edx, 16+4
    mov       DWORD PTR [esp+8],edx
    mov       DWORD PTR [esp+4],edx
    mov       DWORD PTR [esp],edx
    call      NEAR PTR __libm_error_support
    add       esp, 16

not_nan:
    fld       QWORD PTR [floor_x]                ; return integer part
    ret                                          ;

negat:        ; **** NEGATIVE X ****

    movq      xmm0, QWORD PTR [floor_x]          ;
    psllq     xmm1, xmm2                         ;
    movapd    xmm3, xmm0                         ;
    cmppd     xmm0, xmm1, 1                      ; if X<integer part, form Mask

    cmp       eax, 0bffh                         ; if X > -1.0 return -1.0
    jl        SHORT ret_neg_one                  ;
    cmp       eax, 0c32h                         ; if X is integer, return X
    jg        SHORT return_x                     ;

    andpd     xmm0, XMMWORD PTR _One             ; Mask & One
    subsd     xmm1, xmm0                         ; if X<integer part,
    movq      QWORD PTR [floor_x], xmm1          ;        return (int.part-1.0)
    fld       QWORD PTR [floor_x]                ;
    ret                                          ;

ret_zero:

    fldz                                         ;
    ret                                          ;

ret_neg_one:

    cmppd     xmm3, XMMWORD PTR _NegZero, 1      ; case for X = Negative Zero
    orpd      xmm3, XMMWORD PTR _NegZero         ; return X, if X == Negative Zero
    andpd     xmm3, XMMWORD PTR _NegOne          ; if X==NegZero, xmm3=0.0
    movq      QWORD PTR [floor_x], xmm3          ;
    fld       QWORD PTR [floor_x]                ;
    ret                                          ;

_floor_pentium4 ENDP

    END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\fpctrl.c ===
/***
*fpctrl.c - fp low level control and status routines
*
*   Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   IEEE control and status routines for internal use.
*   These routines use machine specific constants while _controlfp,
*   _statusfp, and _clearfp use an abstracted control/status word
*
*Revision History:
*
*   03-31-92  GDP   written
*   05-12-92  GJF   Rewrote fdivr as fdivrp st(1),st to work around C8-32
*		    assertions.
*
*/

#include <trans.h>

/***	_statfp
*() -
*
*Purpose:
*	return user status word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _statfp()
{
    short	status;

    _asm {
	fstsw	status
    }
    return status;
}

/***	_clrfp
*() -
*
*Purpose:
*	return user status word and clear status
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _clrfp()
{
    short	status;
    
    _asm {
	fnstsw	status
	fnclex
    }
    return status;
}


/***	_ctrlfp
*() -
*
*Purpose:
*	return and set user control word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _ctrlfp(unsigned int newctrl, unsigned int _mask)
{
    short	oldCw;
    short	newCw;

    _asm {
	fstcw	oldCw
    }
    newCw = (short) ((newctrl & _mask) | (oldCw & ~_mask));
    
    _asm {
	fldcw	newCw
    }
    return oldCw;
}



/***	_set_statfp
*() -
*
*Purpose:
*	force selected exception flags to 1
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

static unsigned long over[3] = { 0x0, 0x80000000, 0x4410 };
static unsigned long under[3] = { 0x1, 0x80000000, 0x3000 };


void _set_statfp(unsigned int sw)
{
    int itmp;
    double tmp;

    if (sw & ISW_INVALID) {
	_asm {
	    fld tbyte ptr over
	    fistp   itmp
	    fwait
	}
    }
    if (sw & ISW_OVERFLOW) {   // will also trigger precision
	_asm {
	    fstsw ax
	    fld tbyte ptr over
	    fstp    tmp
	    fwait
	    fstsw  ax
	}
    }
    if (sw & ISW_UNDERFLOW) {  // will also trigger precision
	_asm {
	    fld tbyte ptr under
	    fstp tmp
	    fwait
	}
    }
    if (sw & ISW_ZERODIVIDE) {
	_asm {
	    fldz
	    fld1
	    fdivrp  st(1), st
	    fstp st(0)
	    fwait
	}
    }
    if (sw & ISW_INEXACT) {
	_asm {
	    fldpi
	    fstp tmp
	    fwait
	}
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\fsqrt.c ===
/***
*fsqrt.c - square root helper
*
*	Copyright (c) 1991-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*   Square root helper routine to be used with the i386
*
*Revision History:
*   10-20-91	GDP	written
*
*******************************************************************************/

double _fsqrt(double x)
{
    double result;
    _asm{
	fld	x
	fsqrt
	fstp	result
    }
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\frnd.c ===
/***
*frnd.c -
*
*   Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*
*Revision History:
*
*   10-20-91  GDP   written
*   09-05-94  SKS   Change #ifdef i386 to #ifdef _M_IX86
*/

/***
*double _frnd(double x) - round to integer
*
*Purpose:
*   Round to integer according to the current rounding mode.
*   NaN's or infinities are NOT handled
*
*Entry:
*
*Exit:
*
*Exceptions:
*******************************************************************************/


double _frnd(double x)
{
    double result;

#if defined _M_IX86 || defined _X86SEG_
    _asm {
	fld x
	frndint
	fstp result
    }
#else
    #error Only 386 platform supported
#endif

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\ftol.asm ===
page	,132
	title	87ftol	 - truncate TOS to 32-bit integer
;*** 
;87ftol.asm - truncate TOS to 32-bit integer
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;
;Revision History:
;
;   07/16/85	Greg Whitten
;		save BX and CX for sloppy code generator
;   10/15/86	Greg Whitten
;		in-line instructions rather than call _fpmath
;   08/24/87	Barry McCord
;		expand the functionality of _ftol to handle
;		unsigned long by using "fistp qword ptr"
;   11/24/87	Barry McCord
;		added _loadds under ifdef DLL
;
;   08/26/88	Bill Johnston
;		386 version
;
;*******************************************************************************


.xlist
	include cruntime.inc
.list

	CODESEG

	public	_ftol
_ftol	proc

	local	oldcw:word
	local	newcw:word
	local	intval:qword

	fstcw	[oldcw] 		; get control word
	fwait				; synchronize

	mov	ax, [oldcw]		; round mode saved
	or	ah, 0ch 		; set chop rounding mode
	mov	[newcw], ax		; back to memory

	fldcw	[newcw] 		; reset rounding
	fistp	qword ptr [intval]	; store chopped integer
	fldcw	[oldcw] 		; restore rounding

	mov	eax, dword ptr [intval]
	mov	edx, dword ptr [intval+4]

	ret
_ftol	endp

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\ftol2.asm ===
page    ,132
        title   ftol2    - truncate TOS to 32-bit integer
;*** 
;ftol2.asm - truncate TOS to 32-bit integer
;
;       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;
;Revision History:
;
;   01/26/01    Phil Lucido
;               Optimized version from Intel to avoid Pentium FLDCW stalls.
;
;*******************************************************************************


.xlist
        include cruntime.inc
.list

        CODESEG

        public  _ftol2
_ftol2  proc

tmp1    equ     <[esp+24]>
tmp2    equ     <[esp+16]>
tmp3    equ     <[esp]>

        push    ebp
        mov     ebp,esp
        sub     esp,32
        and     esp,0fffffff0h

        fld     st(0)           ; duplicate FPU stack top
        fst     dword ptr tmp1  ; store single to get the sign
        fistp   qword ptr tmp2  ; sto as int
        fild    qword ptr tmp2  ; ld int, cvt to fp
        mov     edx,tmp1        ; get the sign (not fwd problem)
        mov     eax,tmp2        ; low dword of integer
        test    eax,eax
        je      integer_QnaN_or_zero

   arg_is_not_integer_QnaN:
        fsubp   st(1),st        ; TOS=d-round(d),
                                ; { st(1)=st(1)-st & pop ST}
        test    edx,edx         ; whats sign of integer
        jns     positive        ; number is negative
        fstp    dword ptr tmp3  ; result of subtraction
        mov     ecx,tmp3        ; dword of diff(single-precision)
        xor     ecx,80000000h
        add     ecx,7fffffffh   ; if diff<0 then decrement integer
        adc     eax,0           ; inc eax (add CARRY flag)
        mov     edx,tmp2+4      ; high dword of integer - deferred
        adc     edx,0
        jmp     localexit       

   positive:
        fstp    dword ptr tmp3  ; 17-18 result of subtraction
        mov     ecx,tmp3        ; dword of diff(single-precision)
        add     ecx,7fffffffh   ; if diff<0 then decrement integer
        sbb     eax,0           ; dec eax (subtract CARRY flag)
        mov     edx,tmp2+4      ; high dword of integer - deferred
        sbb     edx,0
        jmp     localexit      

   integer_QnaN_or_zero: ; load the upper 32 bits of the converted integer
        mov     edx,tmp2+4      ; high dword of integer (fwd problem)
        test    edx,7fffffffh
        jnz     arg_is_not_integer_QnaN
        fstp    dword ptr tmp1
        fstp    dword ptr tmp1

   localexit:
        leave
        ret

_ftol2  endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\huge.asm ===
page	,132
	title   HUGE    - HUGE value
;*** 
;huge.asm - defines HUGE
;
;	Copyright (c) 1984-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	defines HUGE
;
;Revision History:
;
;   07/04/84	Greg Whitten
;		initial version
;
;   12/21/84	Greg Whitten
;		add assumes so that C can find variable
;
;   09/23/87	Barry C. McCord
;		add _matherr_flag for the sake of the
;		C floating-point intrinsic functions
;
;   08/29/88	Bill Johinston
;		386 version
;
;   08/27/91	JeffRob
;		ANSI naming
;
;   09/06/91	GeorgioP
;		define HUGE as positive infinity
;
;   09/06/91	GeorgioP
;		define _HUGE_dll
;
;   04/05/93	SteveSa
;		undefine _HUGE_dll
;   10/14/93	GregF
;		Restored _HUGE_DLL for _NTSDK
;
;*******************************************************************************


.xlist
	include cruntime.inc
	include mrt386.inc
.list

	.data

ifdef	_NTSDK
ifdef	CRTDLL
globalQ _HUGE_dll, 7ff0000000000000R
else
globalQ _HUGE, 7ff0000000000000R
endif
else
globalQ _HUGE, 7ff0000000000000R
endif

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\ieee87.c ===
/***
*ieee.c - ieee control and status routines
*
*   Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   IEEE control and status routines.
*
*Revision History:
*
*       04-01-02  GDP   Rewritten to use abstract control and status words
*       10-30-92  GDP   _fpreset now resets saved fp context if called from a
*                       signal handler.
*       09-01-94  SKS   Change include file from <nt.h> to <windows.h>
*       04-11-95  JWM   _fpreset() now resets default precision.
*       05-10-96  BWT   Fix POSIX build.
*
*/

#include <trans.h>
#include <float.h>
#include <windows.h>
#include <signal.h>

extern void _setdefaultprecision();

static unsigned int _abstract_sw(unsigned short sw);
static unsigned int _abstract_cw(unsigned short cw);
static unsigned short _hw_cw(unsigned int abstr);


/***
* _statusfp() -
*
*Purpose:
*       return abstract fp status word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _statusfp()
{
    short   status;

    _asm {
        fstsw   status
    }
    return _abstract_sw(status);
}


/***
*_clearfp() -
*
*Purpose:
*       return abstract status word and clear status
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _clearfp()
{
    short   status;

    _asm {
        fnstsw  status
        fnclex
    }

    return _abstract_sw(status);
}



/***    _control87
*() -
*
*Purpose:
*       return and set abstract user fp control word
*       can modify EM_DENORMAL mask
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _control87(unsigned int newctrl, unsigned int mask)
{
    short   oldCw;
    short   newCw;
    unsigned int oldabs;
    unsigned int newabs;

    _asm {
        fstcw   oldCw
    }

    oldabs = _abstract_cw(oldCw);

    newabs = (newctrl & mask) | (oldabs & ~mask);

    newCw = _hw_cw(newabs);

    _asm {
        fldcw   newCw
    }
    return newabs;
}                   /* _controlfp() */


/***    _controlfp
*() -
*
*Purpose:
*       return and set abstract user fp control word
*       cannot change denormal mask (ignores _EM_DENORMAL)
*       This is done for portable IEEE behavior on all platforms
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _controlfp(unsigned int newctrl, unsigned int mask)
{
    return _control87(newctrl, mask & ~_EM_DENORMAL);
}




/***
* _fpreset() - reset fp system
*
*Purpose:
*       reset fp environment to the default state
*       Also reset saved fp environment if invoked from a user's
*       signal handler
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
#define TAG_ALL_EMPTY ((unsigned int) 0xffff);

void _fpreset()
{
#ifndef _POSIX_
    PEXCEPTION_POINTERS excptrs = (PEXCEPTION_POINTERS) _pxcptinfoptrs;
#endif

    _asm {
        fninit
    }
    _setdefaultprecision();     // reset precision, usually down to 53 bits
#ifndef _POSIX_
    if (excptrs &&
        excptrs->ContextRecord->ContextFlags & CONTEXT_FLOATING_POINT) {
        // _fpreset has been invoked by a signal handler which in turn
        // has been invoked by the CRT filter routine. In this case
        // the saved fp context should be cleared, so that the change take
        // effect on continuation.

        FLOATING_SAVE_AREA *pFloatSave = &excptrs->ContextRecord->FloatSave;
        pFloatSave->StatusWord = 0;
        pFloatSave->TagWord = TAG_ALL_EMPTY;
    }
#endif
}







/***
* _abstract_cw() - abstract control word
*
*Purpose:
*   produce a fp control word in abstracted (machine independent) form
*
*Entry:
*   cw:     machine control word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _abstract_cw(unsigned short cw)
{
    unsigned int abstr = 0;


    //
    // Set exception mask bits
    //

    if (cw & IEM_INVALID)
        abstr |= _EM_INVALID;
    if (cw & IEM_ZERODIVIDE)
        abstr |= _EM_ZERODIVIDE;
    if (cw & IEM_OVERFLOW)
        abstr |= _EM_OVERFLOW;
    if (cw & IEM_UNDERFLOW)
        abstr |= _EM_UNDERFLOW;
    if (cw & IEM_INEXACT)
        abstr |= _EM_INEXACT;
    if (cw & IEM_DENORMAL)
        abstr |= _EM_DENORMAL;

    //
    // Set rounding mode
    //

    switch (cw & IMCW_RC) {
    case IRC_NEAR:
        abstr |= _RC_NEAR;
        break;
    case IRC_UP:
        abstr |= _RC_UP;
        break;
    case IRC_DOWN:
        abstr |= _RC_DOWN;
        break;
    case IRC_CHOP:
        abstr |= _RC_CHOP;
        break;
    }

    //
    // Set Precision mode
    //

    switch (cw & IMCW_PC) {
    case IPC_64:
        abstr |= _PC_64;
        break;
    case IPC_53:
        abstr |= _PC_53;
        break;
    case IPC_24:
        abstr |= _PC_24;
        break;
    }


    //
    // Infinity control (bit can be programmed but has no effect)
    //

    if (cw & IMCW_IC) {
        abstr |= _IC_AFFINE;
    }

    return abstr;
}


/***
* _hw_cw() -  h/w control word
*
*Purpose:
*   produce a machine dependent fp control word
*
*
*Entry:
*   abstr:  abstract control word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned short _hw_cw(unsigned int abstr)
{
    //
    // Set standard infinity and denormal control bits
    //

    unsigned short cw = 0;

    //
    // Set exception mask bits
    //

    if (abstr & _EM_INVALID)
        cw |= IEM_INVALID;
    if (abstr & _EM_ZERODIVIDE)
        cw |= IEM_ZERODIVIDE;
    if (abstr & _EM_OVERFLOW)
        cw |= IEM_OVERFLOW;
    if (abstr & _EM_UNDERFLOW)
        cw |= IEM_UNDERFLOW;
    if (abstr & _EM_INEXACT)
        cw |= IEM_INEXACT;
    if (abstr & _EM_DENORMAL)
        cw |= IEM_DENORMAL;

    //
    // Set rounding mode
    //

    switch (abstr & _MCW_RC) {
    case _RC_NEAR:
        cw |= IRC_NEAR;
        break;
    case _RC_UP:
        cw |= IRC_UP;
        break;
    case _RC_DOWN:
        cw |= IRC_DOWN;
        break;
    case _RC_CHOP:
        cw |= IRC_CHOP;
        break;
    }

    //
    // Set Precision mode
    //

    switch (abstr & _MCW_PC) {
    case _PC_64:
        cw |= IPC_64;
        break;
    case _PC_53:
        cw |= IPC_53;
        break;
    case _PC_24:
        cw |= IPC_24;
        break;
    }


    //
    // Set Infinity mode
    //

    if (abstr & _MCW_IC) {
        cw |= IIC_AFFINE;
    }

    return cw;
}



/***
* _abstract_sw() - abstract fp status word
*
*Purpose:
*   produce an abstract (machine independent) fp status word
*
*
*Entry:
*   sw:     machine status word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _abstract_sw(unsigned short sw)
{
    unsigned int abstr = 0;


    if (sw & ISW_INVALID)
        abstr |= _SW_INVALID;
    if (sw & ISW_ZERODIVIDE)
        abstr |= _SW_ZERODIVIDE;
    if (sw & ISW_OVERFLOW)
        abstr |= _SW_OVERFLOW;
    if (sw & ISW_UNDERFLOW)
        abstr |= _SW_UNDERFLOW;
    if (sw & ISW_INEXACT)
        abstr |= _SW_INEXACT;
    if (sw & ISW_DENORMAL)
        abstr |= _SW_DENORMAL;

    return abstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\ieee.c ===
/***
*ieee.c - ieee control and status routines
*
*   Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   IEEE control and status routines.
*
*Revision History:
*
*   04-01-02  GDP   Rewritten to use abstract control and status words
*
*/

#include <trans.h>
#include <float.h>

static unsigned int _abstract_sw(unsigned short sw);
static unsigned int _abstract_cw(unsigned short cw);
static unsigned short _hw_cw(unsigned int abstr);



/***
* _statusfp() -
*
*Purpose:
*	return abstract fp status word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _statusfp()
{
    short	status;

    _asm {
	fstsw	status
    }
    return _abstract_sw(status);
}


/***
*_clearfp() -
*
*Purpose:
*	return abstract	status word and clear status
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _clearfp()
{
    short	status;
    
    _asm {
	fnstsw	status
	fnclex
    }

    return _abstract_sw(status);
}



/***	_controlfp
*() -
*
*Purpose:
*	return and set abstract user fp control word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _controlfp(unsigned int newctrl, unsigned int mask)
{
    short	oldCw;
    short	newCw;
    unsigned int oldabs;
    unsigned int newabs;

    _asm {
	fstcw	oldCw
    }

    oldabs = _abstract_cw(oldCw);

    newabs = (newctrl & mask) | (oldabs & ~mask);

    newCw = _hw_cw(newabs);
    
    _asm {
	fldcw	newCw
    }
    return newabs;
}					/* _controlfp() */


/***
* _abstract_cw() - abstract control word
*
*Purpose:
*   produce a fp control word in abstracted (machine independent) form
*
*Entry:
*   cw:     machine control word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _abstract_cw(unsigned short cw)
{
    unsigned int abstr = 0;


    //
    // Set exception mask bits
    //

    if (cw & IEM_INVALID)
	abstr |= _EM_INVALID;
    if (cw & IEM_ZERODIVIDE)
	abstr |= _EM_ZERODIVIDE;
    if (cw & IEM_OVERFLOW)
	abstr |= _EM_OVERFLOW;
    if (cw & IEM_UNDERFLOW)
	abstr |= _EM_UNDERFLOW;
    if (cw & IEM_INEXACT)
	abstr |= _EM_INEXACT;

    //
    // Set rounding mode
    //

    switch (cw & IMCW_RC) {
    case IRC_NEAR:
	abstr |= _RC_NEAR;
	break;
    case IRC_UP:
	abstr |= _RC_UP;
	break;
    case IRC_DOWN:
	abstr |= _RC_DOWN;
	break;
    case IRC_CHOP:
	abstr |= _RC_CHOP;
	break;
    }

    //
    // Set Precision mode
    //

    switch (cw & IMCW_PC) {
    case IPC_64:
	abstr |= _PC_64;
	break;
    case IPC_53:
	abstr |= _PC_53;
	break;
    case IPC_24:
	abstr |= _PC_24;
	break;
    }

    return abstr;
}


/***
* _hw_cw() -  h/w control word
*
*Purpose:
*   produce a machine dependent fp control word
*
*
*Entry:
*   abstr:	abstract control word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned short _hw_cw(unsigned int abstr)
{
    //
    // Set standard infinity and denormal control bits
    //

    unsigned short cw = 0x1002;

    //
    // Set exception mask bits
    //

    if (abstr & _EM_INVALID)
	cw |= IEM_INVALID;
    if (abstr & _EM_ZERODIVIDE)
	cw |= IEM_ZERODIVIDE;
    if (abstr & _EM_OVERFLOW)
	cw |= IEM_OVERFLOW;
    if (abstr & _EM_UNDERFLOW)
	cw |= IEM_UNDERFLOW;
    if (abstr & _EM_INEXACT)
	cw |= IEM_INEXACT;

    //
    // Set rounding mode
    //

    switch (abstr & _MCW_RC) {
    case _RC_NEAR:
	cw |= IRC_NEAR;
	break;
    case _RC_UP:
	cw |= IRC_UP;
	break;
    case _RC_DOWN:
	cw |= IRC_DOWN;
	break;
    case _RC_CHOP:
	cw |= IRC_CHOP;
	break;
    }

    //
    // Set Precision mode
    //

    switch (abstr & _MCW_PC) {
    case _PC_64:
	cw |= IPC_64;
	break;
    case _PC_53:
	cw |= IPC_53;
	break;
    case _PC_24:
	cw |= IPC_24;
	break;
    }


    return cw;
}



/***
* _abstract_sw() - abstract fp status word
*
*Purpose:
*   produce an abstract (machine independent) fp status word
*
*
*Entry:
*   sw:     machine status word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _abstract_sw(unsigned short sw)
{
    unsigned int abstr = 0;


    if (sw & ISW_INVALID)
	abstr |= _EM_INVALID;
    if (sw & ISW_ZERODIVIDE)
	abstr |= _EM_ZERODIVIDE;
    if (sw & ISW_OVERFLOW)
	abstr |= _EM_OVERFLOW;
    if (sw & ISW_UNDERFLOW)
	abstr |= _EM_UNDERFLOW;
    if (sw & ISW_INEXACT)
	abstr |= _EM_INEXACT;

    return abstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\ldsplit.asm ===
page	,132
	title	ldsplit	 - split long double
;*** 
;ldsplit.asm - split long double into two doubles
;
;	Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   Helper for handling 10byte long double quantities if there is no
;   compiler support.
;
;Revision History:
;
;   04/21/92	GDP	written
;
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
	include os2supp.inc
.list

.data

labelB TagTable
			; C2 C1 C0 C3	 Meaning
	db	2 * 4	;  0  0  0  0  +Unnormal=>   NAN
	db	1 * 4	;  0  0  0  1  +Zero	=>   Zero
	db	2 * 4	;  0  0  1  0  +NAN	=>   NAN
	db	2 * 4	;  0  0  1  1	Empty	=>   NAN
	db	2 * 4	;  0  1  0  0  -Unnormal=>   NAN
	db	1 * 4	;  0  1  0  1  -Zero	=>   Zero
	db	2 * 4	;  0  1  1  0  -NAN	=>   NAN
	db	2 * 4	;  0  1  1  1	Empty	=>   NAN
	db	0 * 4	;  1  0  0  0  +Normal	=>   Valid
	db	4 * 4	;  1  0  0  1  +Denormal=>   Denormal
	db	3 * 4	;  1  0  1  0  +Infinity=>   Infinity
	db	2 * 4	;  1  0  1  1	Empty	=>   NAN
	db	0 * 4	;  1  1  0  0  -Normal	=>   Valid
	db	4 * 4	;  1  1  0  1  -Denormal=>   Zero
	db	3 * 4	;  1  1  1  0  -Infinity=>   Infinity
	db	2 * 4	;  1  1  1  1	Empty	=>   NAN

; factor = 2^64
staticQ factor,	      043F0000000000000R

LDBIAS		equ	3fffh
DBIAS		equ	3ffh
MAX_BIASED_DEXP equ	7feh

CODESEG



table:
	dd	valid
	dd	zero
	dd	nan
	dd	inf
	dd	denorm



;***
;int _ldsplit(pld, pd1, pd2) - split long double
;
;Purpose:
;   partition a long double quantity ld into two double quantities
;   d1, d2 and an integer scaling factror s. The mantissa of d1 has
;   the high order word of the mantissa of ld. Respectively, the
;   mantissa of d2 has the low order word of the mantissa of ld.
;   The following relation should be satisfied:
;
;	    ld == ((long double)d1 + (long double)d2) * 2^s
;
;   s is 0, unless d1 or d2 cannot be expressed as normalized
;   doubles; in that case s != 0, and .5 <= d1 < 1
;
;
;Entry:
;   pld     pointer to the long double argument
;   pd1     pointer to d1
;   pd2     pointer to d2
;
;Exit:
;   *pd1, *pd2 are updated
;   return value is equal to s
;
;
;Exceptions:
;   This function should raise no IEEE exceptions.
;   special cases:
;     ld is QNAN or SNAN: d1 = QNAN, d2 = 0, s = 0
;     ls is INF:	  d1 = INF, d2 = 0, s = 0
;
;
;******************************************************************************/


_ldsplit proc	uses ebx edx edi, pld:dword, pd1:dword, pd2:dword
	local	ld:tbyte
	local	exp_adj:dword
	local	retvalue:dword
	local	denorm_adj:dword

	mov	[retvalue], 0		; default return value
	mov	[denorm_adj], 0
	mov	ebx, [pld]
	fld	tbyte ptr [ebx]
	fxam
	fstsw	ax
	fstp	[ld]			; store to local area
	shl	ah, 1
	sar	ah, 1
	rol	ah, 1
	and	ah, 0fh
	mov	al, ah
	mov	ebx, dataoffset TagTable	; Prepare for XLAT
	xlat
	movzx	eax, al
	mov	ebx, OFFSET table
	add	ebx, eax

	mov	edx, pd1	    ; edx points to the high order double
	mov	edi, pd2	    ; edi points to the low order double

	jmp	[ebx]

lab valid
	; have a valid normalized non-special long double

	mov	eax, dword ptr [ld]
	or	eax, eax
	jz	d2zero

				    ; compute mantissa an exponent for d2
	mov	[exp_adj], 31	    ; adjustment to be subtracted from exp of *pd2

	;
	; compute mantissa of d2
	; shift left low order word of ld, until a '1' is hit
	;

	cmp	eax, 0ffffh
	ja	shl16done
	sal	eax, 16
	add	[exp_adj], 16

lab shl16done
	cmp	eax, 0ffffffh
	ja	shl8done
	sal	eax, 8
	add	[exp_adj], 8

lab shl8done
lab shiftloop
	inc	[exp_adj]
	sal	eax, 1
	jnc	shiftloop

	; now eax contains the mantissa for d2
	; exp_adj is the difference of the
	; exponents of d1 and d2
	; exp_adj should be in the range
	;	  32 <= exp_adj <= 63
	; By convention, if exp_adj is 0 then
	; d2 is zero

lab setd2man
	mov	dword ptr [edi+4], 0
	shld	dword ptr [edi+4], eax, 20
	shl	eax, 20
	mov	[edi], eax

	;
	; set mantissa of d1
	;

lab setd1man
	mov	eax, dword ptr [ld+4]
	sal	eax, 1			    ; get rid of explicit bit
	mov	dword ptr [edx+4], 0
	shld	dword ptr [edx+4], eax, 20
	shl	eax, 20
	mov	[edx], eax

				    ; check if exponent is in range
	mov	ax, word ptr [ld+8]

	and	ax, 07fffh		; clear sign bit
	movzx	eax, ax

	sub	eax, LDBIAS - DBIAS

	cmp	eax, MAX_BIASED_DEXP
	ja	expoutofrange


	cmp	eax, [exp_adj]
	jb	expoutofrange


	;
	; set exponent of d1
	;

lab setexp1
	mov	ebx, eax		; save exp value
	shl	eax, 20
	or	dword ptr [edx+4], eax


	cmp	[exp_adj], 0
	je	exp2zero
	sub	ebx, [exp_adj]
	je	exp2zero
lab setexp2
	shl	ebx, 20
	or	dword ptr [edi+4], ebx
	mov	[retvalue], 0


lab setsign				; set correct signs and return
					; at this point eax contains
					; the return value
	mov	bx, word ptr [ld+8]
	and	bx, 1 SHL 15		; get sign

	or	[edi+6], bx		; set sign bit
	or	[edx+6], bx		; set sign bit

	mov	eax, [retvalue]
	add	eax, [denorm_adj]
	ret


lab d2zero
	mov	[exp_adj], 0
	jmp	setd2man

lab exp2zero
	mov	ebx, 0
	jmp	setexp2



lab expoutofrange
	mov	ebx, DBIAS
	mov	ecx, ebx
	sub	ecx, [exp_adj]

	shl	ebx, 20
	or	dword ptr [edx+4], ebx

	shl	ecx, 20
	or	dword ptr [edi+4], ecx

	sub	eax, DBIAS		; unbias exp
	mov	[retvalue], eax		; this is the return value
	jmp	short setsign


lab zero
	mov	dword ptr [edx],   0
	mov	dword ptr [edx+4], 0
	mov	dword ptr [edi],   0
	mov	dword ptr [edi+4], 0
	jmp	setsign

lab nan
	mov	dword ptr [edx],   0
	mov	dword ptr [edx+4], 07ff80000h
	mov	dword ptr [edi],   0
	mov	dword ptr [edi+4], 0
	jmp	setsign

lab inf
	mov	dword ptr [edx],   0
	mov	dword ptr [edx+4], 07ff00000h
	mov	dword ptr [edi],   0
	mov	dword ptr [edi+4], 0
	jmp	setsign

lab denorm

	;
	; We have a long double denormal
	; so we know for sure that this is out of the double
	; precision range, and the return value of _ldsplit
	; should be non-zero.
	; Multiply the denormal by 2^64, then adjust the
	; return value by subtracting 64
	;


	; this assumes denormal exception masked
	fld	[ld]
	fmul	[factor]
	fstp	[ld]
	mov	[denorm_adj], 64
	jmp	valid



_ldsplit endp

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\libm_support.h ===
//  
// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story, 
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.
//

typedef enum
{
  logl_zero=0,   logl_negative,                  /*  0,  1 */
  log_zero,      log_negative,                   /*  2,  3 */
  logf_zero,     logf_negative,                  /*  4,  5 */
  log10l_zero,   log10l_negative,                /*  6,  7 */
  log10_zero,    log10_negative,                 /*  8,  9 */
  log10f_zero,   log10f_negative,                /* 10, 11 */
  expl_overflow, expl_underflow,                 /* 12, 13 */
  exp_overflow,  exp_underflow,                  /* 14, 15 */
  expf_overflow, expf_underflow,                 /* 16, 17 */
  powl_overflow, powl_underflow,                 /* 18, 19 */
  powl_zero_to_zero,                             /* 20     */
  powl_zero_to_negative,                         /* 21     */
  powl_neg_to_non_integer,                       /* 22     */
  powl_nan_to_zero,                              /* 23     */
  pow_overflow,  pow_underflow,                  /* 24, 25 */
  pow_zero_to_zero,                              /* 26     */ 
  pow_zero_to_negative,                          /* 27     */
  pow_neg_to_non_integer,                        /* 28     */
  pow_nan_to_zero,                               /* 29     */
  powf_overflow, powf_underflow,                 /* 30, 31 */
  powf_zero_to_zero,                             /* 32     */
  powf_zero_to_negative,                         /* 33     */ 
  powf_neg_to_non_integer,                       /* 34     */ 
  powf_nan_to_zero,                              /* 35     */
  atan2l_zero,                                   /* 36     */
  atan2_zero,                                    /* 37     */
  atan2f_zero,                                   /* 38     */
  expm1l_overflow,                               /* 39     */
  expm1l_underflow,                              /* 40     */
  expm1_overflow,                                /* 41     */
  expm1_underflow,                               /* 42     */
  expm1f_overflow,                               /* 43     */
  expm1f_underflow,                              /* 44     */
  hypotl_overflow,                               /* 45     */
  hypot_overflow,                                /* 46     */
  hypotf_overflow,                               /* 47     */
  sqrtl_negative,                                /* 48     */
  sqrt_negative,                                 /* 49     */
  sqrtf_negative,                                /* 50     */
  scalbl_overflow, scalbl_underflow,             /* 51,52  */
  scalb_overflow,  scalb_underflow,              /* 53,54  */
  scalbf_overflow, scalbf_underflow,             /* 55,56  */
  acosl_gt_one, acos_gt_one, acosf_gt_one,       /* 57, 58, 59 */
  asinl_gt_one, asin_gt_one, asinf_gt_one,       /* 60, 61, 62 */
  coshl_overflow, cosh_overflow, coshf_overflow, /* 63, 64, 65 */
  y0l_zero, y0l_negative,y0l_gt_loss,            /* 66, 67, 68 */
  y0_zero, y0_negative,y0_gt_loss,               /* 69, 70, 71 */
  y0f_zero, y0f_negative,y0f_gt_loss,            /* 72, 73, 74 */
  y1l_zero, y1l_negative,y1l_gt_loss,            /* 75, 76, 77 */ 
  y1_zero, y1_negative,y1_gt_loss,               /* 78, 79, 80 */ 
  y1f_zero, y1f_negative,y1f_gt_loss,            /* 81, 82, 83 */ 
  ynl_zero, ynl_negative,ynl_gt_loss,            /* 84, 85, 86 */
  yn_zero, yn_negative,yn_gt_loss,               /* 87, 88, 89 */
  ynf_zero, ynf_negative,ynf_gt_loss,            /* 90, 91, 92 */
  j0l_gt_loss,                                   /* 93 */ 
  j0_gt_loss,                                    /* 94 */
  j0f_gt_loss,                                   /* 95 */
  j1l_gt_loss,                                   /* 96 */
  j1_gt_loss,                                    /* 97 */
  j1f_gt_loss,                                   /* 98 */
  jnl_gt_loss,                                   /* 99 */
  jn_gt_loss,                                    /* 100 */
  jnf_gt_loss,                                   /* 101 */
  lgammal_overflow, lgammal_negative,lgammal_reserve, /* 102, 103, 104 */
  lgamma_overflow, lgamma_negative,lgamma_reserve,    /* 105, 106, 107 */
  lgammaf_overflow, lgammaf_negative, lgammaf_reserve,/* 108, 109, 110 */
  gammal_overflow,gammal_negative, gammal_reserve,    /* 111, 112, 113 */
  gamma_overflow, gamma_negative, gamma_reserve,      /* 114, 115, 116 */
  gammaf_overflow,gammaf_negative,gammaf_reserve,     /* 117, 118, 119 */   
  fmodl_by_zero,                                 /* 120 */
  fmod_by_zero,                                  /* 121 */
  fmodf_by_zero,                                 /* 122 */
  remainderl_by_zero,                            /* 123 */
  remainder_by_zero,                             /* 124 */
  remainderf_by_zero,                            /* 125 */
  sinhl_overflow, sinh_overflow, sinhf_overflow, /* 126, 127, 128 */
  atanhl_gt_one, atanhl_eq_one,                  /* 129, 130 */
  atanh_gt_one, atanh_eq_one,                    /* 131, 132 */
  atanhf_gt_one, atanhf_eq_one,                  /* 133, 134 */
  acoshl_lt_one,                                 /* 135 */
  acosh_lt_one,                                  /* 136 */
  acoshf_lt_one,                                 /* 137 */
  log1pl_zero,   log1pl_negative,                /* 138, 139 */
  log1p_zero,    log1p_negative,                 /* 140, 141 */
  log1pf_zero,   log1pf_negative,                /* 142, 143 */
  ldexpl_overflow,   ldexpl_underflow,           /* 144, 145 */
  ldexp_overflow,    ldexp_underflow,            /* 146, 147 */
  ldexpf_overflow,   ldexpf_underflow,           /* 148, 149 */
  logbl_zero,   logb_zero, logbf_zero,           /* 150, 151,152 */
  nextafterl_overflow,   nextafter_overflow,  
  nextafterf_overflow,                           /* 153, 154,155 */
  ilogbl_zero,  ilogb_zero, ilogbf_zero,         /* 156, 157,158 */
  exp2l_overflow, exp2l_underflow,               /* 159, 160 */
  exp2_overflow,  exp2_underflow,                /* 161, 162 */
  exp2f_overflow, exp2f_underflow,               /* 163, 164 */
  exp10l_overflow, exp10_overflow,
  exp10f_overflow,                               /* 165, 166, 167 */
  log2l_zero,    log2l_negative,                 /* 168, 169 */
  log2_zero,     log2_negative,                  /* 170, 171 */
  log2f_zero,    log2f_negative,                 /* 172, 173 */

  log_nan = 1000,                                /* 1000 */
  log10_nan,                                     /* 1001 */
  exp_nan,                                       /* 1002 */
  atan_nan,                                      /* 1003 */
  ceil_nan,                                      /* 1004 */
  floor_nan,                                     /* 1005 */
  pow_nan,                                       /* 1006 */
  modf_nan                                       /* 1007 */
} error_types;

void __libm_error_support(void*,void*,void*,error_types);

#define BIAS_64  1023
#define EXPINF_64  2047

#define DOUBLE_HEX(HI, LO) 0x ## LO, 0x ## HI

static const unsigned INF[] = {
    DOUBLE_HEX(7ff00000, 00000000),
    DOUBLE_HEX(fff00000, 00000000)
};
static const unsigned BIG[] = {
    DOUBLE_HEX(7fe00000, 00000000),
    DOUBLE_HEX(00200000, 00000000)
};
static const unsigned ZERO[] = {
    DOUBLE_HEX(00000000, 00000000),
    DOUBLE_HEX(80000000, 00000000)
};

static const unsigned INF_32[] = {0x7f800000,0xff800000 };
static const unsigned NAN_32[] = {0x7fc00000,0xffc00000};
static const unsigned ZERO_32[] = { 0, 0x80000000 };

static const float libm_largef[] = { 1.0e+30f, -1.0e+30f };
static const float libm_smallf[] = { 1.0e-30f, -1.0e-30f };
static const double libm_small[] = { 1.0e-300, -1.0e-300 };

#define INVALID    (*((double*)&ZERO[0]) * *((double*)&INF[0]))
#define INVALID_32    *(float *)&ZERO_32[0] * *(float *)&INF_32[0]
#define LIBM_OVERFLOW (*((double*)&BIG[0]) * *((double*)&BIG[0]))
#define LIBM_UNDERFLOW (*((double*)&BIG[2]) * *((double*)&BIG[2]))
#define LIBM_OVERFLOWF (libm_largef[0] * libm_largef[0])
#define LIBM_UNDERFLOWF (libm_smallf[0] * libm_smallf[0])
#define PINF       *((double*)&INF[0]) 
#define NINF       -PINF 
#define PINF_DZ    (1.0/(*((double*)&ZERO[0])) 


struct _exception
{
  int type;
  char *name;
  double arg1, arg2, retval;
};

#define	MATHERR_D	_matherr

#define	EXC_DECL_D	_exception

extern int MATHERR_D(struct EXC_DECL_D*);

/* Set these appropriately to make thread Safe */
#define ERRNO_RANGE  errno = ERANGE
#define ERRNO_DOMAIN errno = EDOM

extern int (*_pmatherr)(struct EXC_DECL_D*);

// This is a run-time variable and may affect
// floating point behavior of the libm functions


#define BIAS_32  127
#define BIAS_64  1023
#define BIAS_80  16383
#define BIAS_128 16383

#define MAXEXP_32  254
#define MAXEXP_64  2046
#define MAXEXP_80  32766
#define MAXEXP_128 32766

#define EXPINF_32  255
#define EXPINF_64  2047
#define EXPINF_80  32767
#define EXPINF_128 32767

/*****************************/
/* memory format definitions */
/*****************************/

/*/// if you use /Zp2 option, or the following pragma... then the
//// 80 bit FP objects will occupy only 10 bytes in memory - otherwise
//// more generous alignments will "waste" memory.
//// Use of -DPACKFP80 is NOT recommended.
//// The same effect can be obtained using /Zp2 (again, NOT recommended).
//// Otherwise the alignment will be a word, forcing the size to be
//// 12 bytes (this means some memory will be wasted in exchange
//// for better performance).
//// Unfortunately, because -DPACKFP80 is implemented the same as /Zp2,
//// all structures will be packed tighter in the entire program. */
#ifdef PACKFP80
#pragma warning(disable:4103)
#pragma pack(2)
#endif

struct fp32 { /*// sign:1 exponent:8 significand:23 (implied leading 1)*/
  unsigned significand:23;
  unsigned exponent:8;
  unsigned sign:1;
};

struct fp64 { /*/ sign:1 exponent:11 significand:52 (implied leading 1)*/
  unsigned lo_significand:32;
  unsigned hi_significand:20;
  unsigned exponent:11;
  unsigned sign:1;
};

struct fp80 { /*/ sign:1 exponent:15 significand:64 (NO implied bits) */
  unsigned         lo_significand;
  unsigned         hi_significand;
  unsigned         exponent:15;
  unsigned         sign:1;
};

#ifdef __cplusplus
  extern "C" {
#endif

  #define NONZERO_SIGNIFICAND(X) ((X)->hi_significand != 0 || (X)->lo_significand != 0)
  #define ZERO_SIGNIFICAND(X)    ((X)->hi_significand == 0 && (X)->lo_significand == 0)
  #define SET_ZERO_SIGNIFICAND(X) (X)->hi_significand = 0; (X)->lo_significand = 0
  #define SET_LO_SIGNIFICAND(X, LO) (X)->lo_significand = (LO)
  #define SET_HI_SIGNIFICAND(X, HI) (X)->hi_significand = (HI)
  #define SET_SIGNIFICAND(X, HI, LO) (X)->hi_significand = (HI);(X)->lo_significand = (LO)
  #define SIGNIFICAND_EQUAL(X, HI, LO) (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand == 0x ## LO))
  #define SIGNIFICAND_GREATER(X, HI, LO) ((X)->hi_significand > 0x ## HI) || \
    (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand > 0x ## LO))
  #define SIGNIFICAND_GREATER_EQ(X, HI, LO) ((X)->hi_significand > 0x ## HI) || \
    (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand >= 0x ## LO))
  #define SIGNIFICAND_LESS(X, HI, LO) ((X)->hi_significand < 0x ## HI) || \
    (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand < 0x ## LO))
  #define SIGNIFICAND_LESS_EQ(X, HI, LO) ((X)->hi_significand < 0x ## HI) || \
    (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand <= 0x ## LO))
  #define HI_SIGNIFICAND_LESS(X, HI) ((X)->hi_significand < 0x ## HI)
  #define ISSIGNIFICAND_EQUAL(X, Y) (((X)->hi_significand == (Y)->hi_significand) && ((X)->lo_significand == (Y)->lo_significand))
  #define ISSIGNIFICAND_GREATER(X, Y) ((X)->hi_significand > (Y)->hi_significand) || \
    (((X)->hi_significand == (Y)->hi_significand) && ((X)->lo_significand > (Y)->lo_significand))
  #define ADD_ULP(X) if(!++(X)->lo_significand) { \
                           if(!++(X)->hi_significand) { \
                                 (X)->exponent++; }}
  #define SUB_ULP(X) if(!(X)->lo_significand--) { \
                           if(!(X)->hi_significand--) { \
                                 (X)->exponent--; }}
  #define CLEAR_LOW_BITS(X,MASK) (X)->lo_significand &= 0x ## MASK
  #define FIX_N_HI_BITS(X, NBIT) (X)->lo_significand = 0; (X)->hi_significand &= (0xfffff << (20 - NBIT))
  #define HI_BITS_TO_INTEGER(X, NBIT) (1 << (NBIT)) | ((X)->hi_significand >> (20 - (NBIT)))
  #ifdef BIG_ENDIAN
    #define DOUBLE_HEX(HI, LO) 0x ## HI, 0x ## LO
    #define HI_WORD(NUM) (*((unsigned *)(NUM))) & 0x7fffffff
  #else
    #define DOUBLE_HEX(HI, LO) 0x ## LO, 0x ## HI
    #define HI_WORD(NUM) (*(((unsigned *)(NUM))+1)) & 0x7fffffff
  #endif

#define SIGN_EXPAND(val,num)  ((val) << (32-(num))) >> (32-(num)) /* sign expand of 'num' LSBs */

#define VALUE_EQUAL(X,EXP,HI,LO) (((X)->exponent == (EXP)) && SIGNIFICAND_EQUAL(X, HI, LO))

#define VALUE_GREATER(X,EXP,HI,LO) (((X)->exponent > (EXP)) || \
    (((X)->exponent == (EXP)) && (SIGNIFICAND_GREATER(X, HI, LO))))
#define VALUE_GREATER_EQ(X,EXP,HI,LO) (((X)->exponent > (EXP)) || \
    (((X)->exponent == (EXP)) && (SIGNIFICAND_GREATER_EQ(X, HI, LO))))
#define VALUE_LESS(X,EXP,HI,LO) (((X)->exponent < (EXP)) || \
    (((X)->exponent == (EXP)) && (SIGNIFICAND_LESS(X, HI, LO))))
#define VALUE_LESS_EQ(X,EXP,HI,LO) (((X)->exponent < (EXP)) || \
    (((X)->exponent == (EXP)) && (SIGNIFICAND_LESS_EQ(X, HI, LO))))

#define ISVALUE_EQUAL(X, Y) \
    (((X)->exponent == (Y)->exponent) && ISSIGNIFICAND_EQUAL(X, Y))
#define ISVALUE_GREATER(X, Y) \
    (((X)->exponent > (Y)->exponent) || (((X)->exponent == (Y)->exponent) && ISSIGNIFICAND_GREATER(X, Y)))

#define VALUE_GREATERF(X,EXP,SIG) (((X)->exponent > (EXP)) || \
    (((X)->exponent == (EXP)) && ((X)->significand > 0x##SIG)))
#define VALUE_GREATER_EQF(X,EXP,SIG) (((X)->exponent > (EXP)) || \
    (((X)->exponent == (EXP)) && ((X)->significand >= 0x##SIG)))
#define VALUE_LESSF(X,EXP,SIG) (((X)->exponent < (EXP)) || \
    (((X)->exponent == (EXP)) && ((X)->significand < 0x##SIG)))
#define VALUE_LESS_EQF(X,EXP,SIG) (((X)->exponent < (EXP)) || \
    (((X)->exponent == (EXP)) && ((X)->significand <= 0x##SIG)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\libm_error.c ===
//     
// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story, James
// Edwards, and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version.
// 2/12/01: Updated to be NT double precision specific.

#include <errno.h>
#include <stdio.h>
#include "libm_support.h"

/************************************************************/
/* matherrX function pointers and setusermatherrX functions */
/************************************************************/
int (*_pmatherr)(struct EXC_DECL_D*) = MATHERR_D;

/***********************************************/
/* error-handling function, libm_error_support */
/***********************************************/
void __libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
{

struct _exception exc;

const char double_inf[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x7F}; 
const char double_huge[8] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0x7F};
const char double_zero[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
const char double_neg_inf[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0xFF}; 
const char double_neg_huge[8] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0xFF};
const char double_neg_zero[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80};

#define RETVAL_HUGE_VALD *(double *)retval = *(double *) double_inf
#define RETVAL_NEG_HUGE_VALD *(double *)retval = *(double *) double_neg_inf
#define RETVAL_HUGED *(double *)retval = (double) *(float *)float_huge
#define RETVAL_NEG_HUGED *(double *)retval = (double) *(float *) float_neg_huge 
#define RETVAL_ZEROD *(double *)retval = *(double *)double_zero 
#define RETVAL_NEG_ZEROD *(double *)retval = *(double *)double_neg_zero 
#define RETVAL_ONED *(double *)retval = 1.0 

#define NOT_MATHERRD exc.arg1=*(double *)arg1;exc.arg2=*(double *)arg2;exc.retval=*(double *)retval;if(!_pmatherr(&exc))

#define NAMED exc.name  

//
// These should work OK for MS because they are ints -
// leading underbars are not necessary.
//

#define DOMAIN          1
#define SING            2
#define OVERFLOW        3
#define UNDERFLOW       4
#define TLOSS           5
#define PLOSS           6

#define SINGD exc.type = SING
#define DOMAIND exc.type = DOMAIN 
#define OVERFLOWD exc.type = OVERFLOW 
#define UNDERFLOWD exc.type = UNDERFLOW 
#define TLOSSD exc.type = TLOSS 

#define INPUT_XD (exc.arg1=*(double*)arg1)
#define INPUT_YD (exc.arg1=*(double*)arg2)
#define INPUT_RESD (*(double *)retval)

#define WRITED_LOG_ZERO fputs("log: SING error\n",stderr)
#define WRITED_LOG_NEGATIVE fputs("log: DOMAIN error\n",stderr)
#define WRITED_LOG10_ZERO fputs("log10: SING error\n",stderr) 
#define WRITED_LOG10_NEGATIVE fputs("log10: DOMAIN error\n",stderr)
#define WRITED_POW_ZERO_TO_ZERO fputs("pow(0,0): DOMAIN error\n",stderr)
#define WRITED_POW_ZERO_TO_NEGATIVE fputs("pow(0,negative): DOMAIN error\n",stderr)
#define WRITED_POW_NEG_TO_NON_INTEGER fputs("pow(negative,non-integer): DOMAIN error\n",stderr)

  switch(input_tag)
  {
  case log_zero:
    /* log(0) */
    {
       SINGD; NAMED="log"; 
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;	
       break;
    }
  case log_negative:
    /* log(x < 0) */
    {
       DOMAIND; NAMED="log";
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;	
       break;
    } 
  case log10_zero:
    /* log10(0) */
    {
       SINGD; NAMED="log10";
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;	
       break;
    }
  case log10_negative:
    /* log10(x < 0) */
    {
       DOMAIND; NAMED="log10";
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case exp_overflow:
    /* exp overflow */
    {
       OVERFLOWD; NAMED="exp";
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;	
       break;
    }
  case exp_underflow:
    /* exp underflow */
    {
       UNDERFLOWD; NAMED="exp"; 
       NOT_MATHERRD {}
       *(double *)retval = exc.retval;
       break;
    }
  case pow_zero_to_zero:
    /* pow 0**0 */
    {
       DOMAIND; NAMED="pow";
       RETVAL_ONED;
       break;
    }
  case pow_overflow:
    /* pow(x,y) overflow */
    {
       OVERFLOWD; NAMED = "pow";
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;
       break;
    }
  case pow_underflow:
    /* pow(x,y) underflow */
    {
       UNDERFLOWD; NAMED = "pow"; 
       NOT_MATHERRD {}
       *(double *)retval = exc.retval;
       break;
    }
  case pow_zero_to_negative:
    /* 0**neg */
    {
       SINGD; NAMED = "pow";
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;
       break;
    }
  case pow_neg_to_non_integer:
    /* neg**non_integral */
    {
       DOMAIND; NAMED = "pow";
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;	
       break;
    }
  case pow_nan_to_zero:
    /* pow(NaN,0.0) */
    /* Special Error */
    {
       DOMAIND; NAMED = "pow"; INPUT_XD; INPUT_YD;
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;	
       break;
    }
  case log2_zero:
    /* log2(0) */
    {
       SINGD; NAMED="log2";
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;
       break;
    }
  case log2_negative:
    /* log2(negative) */
    {
       DOMAIND; NAMED="log2";
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case exp2_underflow:
    /* exp2 underflow */
    {
       UNDERFLOWD; NAMED="exp2"; 
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;
       break;
    }
  case exp2_overflow:
    /* exp2 overflow */
    {
       OVERFLOWD; NAMED="exp2";
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;
       break;
    }
  case exp10_overflow:
    /* exp10 overflow */
    {
       OVERFLOWD; NAMED="exp10";
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;
       break;
    }
  case log_nan:
    /* log(NaN) */
    {
       DOMAIND; NAMED="log";
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case log10_nan:
    /* log10(NaN) */
    {
       DOMAIND; NAMED="log10";
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case exp_nan:
    /* exp(NaN) */
    {
       DOMAIND; NAMED="exp";
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case atan_nan:
    /* atan(NaN) */
    {
       DOMAIND; NAMED="atan";
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case ceil_nan:
    /* ceil(NaN) */
    {
       DOMAIND; NAMED="ceil";
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case floor_nan:
    /* floor(NaN) */
    {
       DOMAIND; NAMED="floor";
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case pow_nan:
    /* pow(NaN,*) or pow(*,NaN) */
    {
       DOMAIND; NAMED="pow";
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case modf_nan:
    /* modf(NaN) */
    {
       DOMAIND; NAMED="modf";
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  }
  return;
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\log.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;   01-26-01  PML   Pentium4 merge.
;   02-28-01  PML   Check for negative denormal.
;
;*******************************************************************************

.xlist
        include cruntime.inc
        include elem87.inc
.list

ifdef   _LOG10_
    _FUNC_     equ      <log10>
    _FUNC_DEF_ equ      <_log10_default>
    _FUNC_P4_  equ      <_log10_pentium4>
else
    _FUNC_     equ      <log>
    _FUNC_DEF_ equ      <_log_default>
    _FUNC_P4_  equ      <_log_pentium4>
endif
    _FUNC_P4_EXTERN_ equ 1
        include disp_pentium4.inc

ifdef   _LOG10_
    _FUNC_     equ      <_CIlog10>
    _FUNC_DEF_ equ      <_CIlog10_default>
    _FUNC_P4_  equ      <_CIlog10_pentium4>
else
    _FUNC_     equ      <_CIlog>
    _FUNC_DEF_ equ      <_CIlog_default>
    _FUNC_P4_  equ      <_CIlog_pentium4>
endif
        include disp_pentium4.inc

        .data
extrn   _infinity:tbyte
extrn   _minfinity:tbyte
extrn   _indefinite:tbyte
extrn   __fastflag:dword
extrn   _DEFAULT_CW_in_mem:word

ifdef   _LOG10_
    LOG_name db 'log10',0,0,0
    _FUNC_      equ <_log10_default>
    _IFUNC_     equ <_CIlog10_default>
else
    LOG_name db 'log',0
    _FUNC_      equ <_log_default>
    _IFUNC_     equ <_CIlog_default>
endif
;page

        CODESEG

extrn   _startOneArgErrorHandling:near
extrn   _fload_withFB:near
extrn        _convertTOStoQNaN:near
extrn        _checkTOS_withFB:near
extrn        _math_exit:near
extrn        _fast_exit:near


; arg                ErrorType        result
;-------------------------------------------
;0.0 or -0.0         SING             minfinity
;negative            DOMAIN           indefinite
;-infinity           DOMAIN           indefinite
;+infinity           ??               +infinity
;QNaN                DOMAIN_QNAN      QNaN
;SNaN                DOMAIN           QNaN=indefinite
;indefinite is  like QNaN
;denormal(53)        fld converts it to normal (64 bits)
;denormal(64)        like normal number (64 bits)


        public        _IFUNC_,_FUNC_
_IFUNC_ proc
        sub     esp,DBLSIZE+4                   ; for argument
        fst     qword ptr [esp]
        call    _checkTOS_withFB
        call    start
        add     esp,DBLSIZE+4
        ret

_FUNC_        label        proc
        lea     edx,[esp+4]
        call    _fload_withFB
start:
        push    edx                           ; allocate space for Control Word
        fstcw   [esp]                         ; store Control Word

; at this point we have on stack: cw(4), ret_addr(4), arg1(8bytes)

        jz      inf_or_nan
        mov     eax,[esp+0ch]                 ; eax contains high dword
        cmp     word ptr[esp],default_CW
        je      CW_is_set_to_default
; fyl2x is not affected by precision bits. So we may ignore user's CW
        fldcw   _DEFAULT_CW_in_mem
CW_is_set_to_default:
        test    eax,7ff00000h
        jz      test_if_x_zero
        test    eax,80000000h                 ; obtain sign
        jnz     negative_x

normal:
ifdef _LOG10_
        fldlg2
else
        fldln2                                ; y=load loge(2)
endif
        fxch
        fyl2x                                 ; y*log2(x)

exit:
        cmp     __fastflag,0
        jnz     _fast_exit

; prepare in registers arguments for math_exit
        lea     ecx,[LOG_name]
ifdef _LOG10_
        mov     edx,OP_LOG10
else
        mov     edx,OP_LOG
endif
        jmp     _math_exit

x_is_denormal:                                ; denormal is like normal
        test    eax,80000000h                 ; obtain sign
        jnz     negative_x
        jmp     normal

inf_or_nan:                                   ; we differ inf and NaN
        test    eax,000fffffH                 ; eax=high
        jnz     not_infinity
        cmp     dword ptr[esp+8],0            ; test if low dword is zero
        jnz     not_infinity
        and     eax,80000000H                 ; test sign of infinity
        jz      exit                          ; infinity is already in ST(0)
negative_x:                                   ; -inf and neg is the same
        fstp    ST(0)
        fld     [_indefinite]                 ; log(infinity)=indefinite
        mov     eax,DOMAIN
        jmp     _ErrorHandling

not_infinity:                                 ; argument is QNaN or SNaN
        call    _convertTOStoQNaN             ; eax MUST contain high dword
        jmp     _ErrorHandling
test_if_x_zero:                               ; test if TOS is zero
        test    eax,000fffffH
        jnz     x_is_denormal                 ; denormal operand
        cmp     dword ptr[esp+8],0            ; test if low dword is zero
        jnz     x_is_denormal                 ; denormal operand

        fstp    ST(0)                         ; log(0)=-infinity
        fld     tbyte ptr[_minfinity]
        mov     eax,SING
;        jmp     _ErrorHandling

_ErrorHandling:
        cmp     __fastflag,0
        jnz     _fast_exit
        lea     ecx,[LOG_name]
ifdef _LOG10_
        mov     edx,OP_LOG10
else
        mov     edx,OP_LOG
endif
        call    _startOneArgErrorHandling
        pop     edx                           ; remove saved CW from stack
        ret

_IFUNC_        endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\genexcep.asm ===
.xlist
        include cruntime.inc
        include elem87.inc
.list

        .data

_exception struc        ; struct _exception {
typ     dd      ?       ;   int type;           /* exception type - see below */
nam     dd      ?       ;   char *name;         /* name of function where error occured */
arg1    dq      ?       ;   double arg1;        /* first argument to function */
arg2    dq      ?       ;   double arg2;        /* second argument (if any) to function */
retval  dq      ?       ;   double retval;      /* value to be returned by function */
_exception ends         ; }

Except_struct_size      equ  ((size _exception) + ISIZE - 1) and (not (ISIZE-1))

Except_struct           equ  [ebp-Except_struct_size]

        CODESEG

extrn        _87except:proc

;***********************************************************
;
;                _startTwoArgErrorHandling
;
;***********************************************************
; Purpose: call to 87except() function, and restore CW
;
; at this point we have on stack: ret_addr(4), cw(4), ret_addr(4), arg1(8bytes)
; ecx   points to function name
; edx   function id (for example OP_LOG)
; eax   error type  (for example SING)
;
; Note:
;   we could use this procedure instead of _startOneArgErrorHandling,
;   but not always we can assume that there is something on stack below param1
;

_startTwoArgErrorHandling proc                \
        savCW:dword,                          \ ; don't change it !!!
        ret_addr:dword,                       \
        param1:qword,
        param2:qword

        local        arg_to_except87:_exception

; store second argument to _exception structure
        mov     [arg_to_except87.typ],eax     ; type of error
        mov     eax,dword ptr [param2]        ; load arg2
        mov     dword ptr [arg_to_except87.arg2],eax
        mov     eax,dword ptr [param2+4]
        mov     dword ptr [arg_to_except87.arg2+4],eax
        jmp     _ContinueErrorHandling
_startTwoArgErrorHandling endp


;***********************************************************
;
;                _startOneArgErrorHandling
;
;***********************************************************
; Purpose: call to 87except() function, and restore CW
;
; at this point we have on stack: ret_addr(4), cw(4), ret_addr(4), arg1(8bytes)
; ecx   points to function name
; edx   function id (for example OP_LOG)
; eax   error type  (for example SING)
;

_startOneArgErrorHandling proc                \
        savCW:dword,                          \ ; don't change it !!!
        ret_addr:dword,                       \
        param1:qword

        local        arg_to_except87:_exception

; prepare _exception structure
        mov     [arg_to_except87.typ],eax     ; type of error
_ContinueErrorHandling        label        proc
        fstp    [arg_to_except87.retval]      ; store return value
        mov     [arg_to_except87.nam],ecx     ; pointer to function name
        mov     eax,dword ptr [param1]        ; load arg1
        mov     ecx,dword ptr [param1+4]
        mov     dword ptr [arg_to_except87.arg1],eax
        mov     dword ptr [arg_to_except87.arg1+4],ecx

; push on stack args for _87except()
        lea     eax,[savCW]                   ; load control word
        lea     ecx,arg_to_except87
        push    eax                           ; &(CW)
        push    ecx                           ; &(_exception structure)
        push    edx                           ; function number
        call    _87except
        add     esp,12                        ; clear arguments if _cdecl
        fld     [arg_to_except87.retval]      ; this assumes that user
                                              ; does not want to return a
                                              ; signaling NaN
; Now it's time to restore saved CW
        cmp     word ptr[savCW],default_CW
        je      CW_is_restored                ; it's usualy taken
        fldcw   word ptr[savCW]
CW_is_restored:
        ret                                   ; _cdecl return

_startOneArgErrorHandling        endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\log10.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;
;*******************************************************************************

_LOG10_ equ 1
include log.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\modf_pentium4.asm ===
; file: modf_wmt.asm

; Copyright  (C) 1985-2000 Intel Corporation.
;
; The information and source code contained herein is the exclusive property
; of Intel Corporation and may not be disclosed, examined, or reproduced in
; whole or in part without explicit written authorization from the Company.
;
; Implemented in VNIIEF-STL, july 2000

; double modf (double x, double *iptr)
; Returns the value of the signed fractional part of argument
;
; Willamette specific version (MASM 6.15 required)
;
; Description:
;  The modf functions break the argument value into integral and fractional parts,
;  each of which has the same type and sign as the argument. They store the integral
;  part (in floating-point format) in the object pointed to by iptr.
;
; Special cases:
;  modf(NaN,iptr) = that NaN and stores that NaN in the *iptr object
;  modf(INF,iptr) = 0 at the sign of x and stores that INF in the *iptr object
;
; Accuracy:
;  The result is always exact.

.xlist
        include cruntime.inc
.list

_FUNC_     equ  <modf>
_FUNC_DEF_ equ  <_modf_default>
_FUNC_P4_  equ  <_modf_pentium4>
_FUNC_DEF_EXTERN_ equ 1
        include disp_pentium4.inc

EXTRN C __libm_error_support : NEAR

      .const
      ALIGN 16

;-- 16x-aligned data --------------------------------------------------------

_Mantissa DQ 0000fffffffffffffH,0000fffffffffffffH
_Bns      DQ 00000000000000433H,00000000000000433H
_Sign     DQ 08000000000000000H,08000000000000000H
_Zero     DQ 00000000000000000H,00000000000000000H

      codeseg
      ALIGN 16

; double modf (double x, double *iptr);

; Stack frame locations

modf_x      TEXTEQU <esp+4>
modf_iptr   TEXTEQU <esp+12>
modf_result TEXTEQU <modf_x>
XMMWORD     TEXTEQU <OWORD>

PUBLIC _modf_pentium4
_modf_pentium4 PROC NEAR

    movq      xmm0, QWORD PTR [modf_x]           ; x
    movapd    xmm2, XMMWORD PTR _Bns             ;
    movapd    xmm3, xmm0                         ; x
    movapd    xmm1, xmm0                         ; x
    movapd    xmm4, xmm0                         ; x
    movapd    xmm6, xmm0
    psllq     xmm0, 1  ; exp(x)                  ; remove sign
    psrlq     xmm0, 53 ; exp(x)                  ; exp(x)
    psrlq     xmm3, 52 ; exp(x)                  ; sign(x) | exp(x)
    andpd     xmm4, XMMWORD PTR _Sign            ; sign(x)
    movd      eax, xmm0                          ; exp(x)
    psubd     xmm2, xmm0                         ;
    mov       ecx, DWORD PTR [modf_iptr]         ; iptr
    psrlq     xmm1, xmm2                         ; truncate
    psllq     xmm1, xmm2                         ; t = trunc(x)
    movd      edx, xmm3                          ; sign(x) | exp(x)

    cmp       eax, 03ffH                         ; if abs(x) < 1.0
    jl        SHORT ret_z                        ; case A
    cmp       eax, 0432H                         ; if abs(x) >=2**53
    jg        SHORT ret_xm                       ; case B

    movq      QWORD PTR [ecx], xmm1              ; *iptr = t
    subsd     xmm6, xmm1
    orpd      xmm6, xmm4                         ; set sign if frac = 0.0

    movq      QWORD PTR [modf_result], xmm6
    fld       QWORD PTR [modf_result]            ; return signed result
    ret                                          ;

ret_z: ; case A: |x|<1.0

    movq      QWORD PTR [ecx], xmm4              ; *iptr = properly-signed 0.0
    fld       QWORD PTR [modf_x]                 ;  return (X)
    ret                                          ;

ret_xm: ; case B: exp(x) >= 53

    cmp       eax, 07ffH                         ; check Inf (NaN)
    movq      xmm0, QWORD PTR [modf_x]           ; x
    je        SHORT ret_inf_nan                  ;

    movq      QWORD PTR [ecx], xmm0              ;

    cmp       edx, 800H                          ;
    fldz                                         ; if x is positive, return 0.0
    jl        SHORT return                       ;

    fchs                                         ; if x is negative, return -0.0

return:

    ret                                          ;

ret_inf_nan:

    movapd    xmm1, xmm0 
    addsd     xmm0, xmm0  
    movq      QWORD PTR [ecx], xmm0              ;
    andpd     xmm0, XMMWORD PTR _Mantissa        ;
    cmppd     xmm0, XMMWORD PTR _Zero, 4         ; Mask = (x == Inf) ? 0 : 1
    pextrw    eax,  xmm0, 0                      ; eax=(x==INF)? 0:1

    andpd     xmm0, xmm1                         ; t = Mask & x
    orpd      xmm0, xmm4                         ; t |= Sign(x)

    mov       edx, 1007
    cmp       eax, 0
    ; if NaN, call libm_error_support
    jnz       CALL_LIBM_ERROR

    movq      QWORD PTR [modf_result], xmm0      ;
    fld       QWORD PTR [modf_result]            ; return (t)
    ret                                          ;

CALL_LIBM_ERROR:
    ;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
    sub       esp, 28
    movlpd    QWORD PTR [esp+16], xmm0
    mov       DWORD PTR [esp+12],edx
    mov       edx, esp
    add       edx,16
    mov       DWORD PTR [esp+8],edx
    add       edx,16+8
    mov       DWORD PTR [esp+4],edx
    sub       edx, 8
    mov       DWORD PTR [esp],edx
    call      NEAR PTR __libm_error_support
;   movlpd    xmm0, QWORD PTR [esp+16]

;   movlpd    QWORD PTR [esp+16], xmm0           ; return result
    fld       QWORD PTR [esp+16]                 ;
    add       esp,28
    ret

_modf_pentium4 ENDP

    END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\pow.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;   Revision History:
;   01-26-01  PML   Pentium4 merge.
;   02-25-01  PML   Fix pow(+/-0,-denorm)
;
;*******************************************************************************

.xlist
        include cruntime.inc
        include elem87.inc
.list

_FUNC_     equ  <pow>
_FUNC_DEF_ equ  <_pow_default>
_FUNC_P4_  equ  <_pow_pentium4>
_FUNC_P4_EXTERN_ equ 1
        include disp_pentium4.inc

_FUNC_     equ  <_CIpow>
_FUNC_DEF_ equ  <_CIpow_default>
_FUNC_P4_  equ  <_CIpow_pentium4>
        include disp_pentium4.inc

        .data
globalQ _half,           03fe0000000000000R
POW_name db 'pow',0

extrn   _infinity:tbyte
extrn   _indefinite:tbyte
extrn   __fastflag:dword


        CODESEG

extrn   _startTwoArgErrorHandling:near
extrn   _fload_withFB:near
extrn   _convertTOStoQNaN:near
extrn   _checkTOS_withFB:near
extrn   _check_range_exit:near
extrn   _fast_exit:near
extrn   _load_CW:near
extrn   _powhlp:near
extrn   _twoToTOS:near

; arg1(base)   arg2(exponent)       ErrorType        result
;-----------------------------------------------------------
;infinity      not NaN                               called powhlp()
;not NaN       infinity                              called powhlp()
;QNaN          not SNaN             DOMAIN_QNAN      QNaN
;SNaN          any                  DOMAIN               
;
;*0           *0                    -                 1
;*0           positive,not odd      -                +0
;+0           positive, odd         -                +0
;-0           positive, odd         -                -0
;*0           negative,not odd      SING             infinity
;+0           negative, odd         SING             infinity
;-0           negative, odd         SING             -infinity
;negative     non-integer           DOMAIN           indefinite
;indefinite is                  like QNaN
;denormal(53)                   fld converts it to normal (64 bits)
;
; * in table above stands for both + and -
;
; if exponent field of result is 0, error type is set to UNDERFLOW
; if result is infinity, error type is set to OVERFLOW

        public        _CIpow_default,_pow_default
_CIpow_default proc
        sub     esp,2*DBLSIZE+4               ; prepare place for argument
        fxch    st(1)
        fstp    qword ptr [esp]               ; base
        fst     qword ptr [esp+8]             ; exponent
        mov     eax,[esp+12]                  ; high dword of exponent
        call    start
        add     esp,2*DBLSIZE+4               ; clean stack
        ret

_pow_default label        proc

        lea     edx,[esp+12]                  ; load exponent(arg2)
        call    _fload_withFB
start:
        mov     ecx,eax                       ; make copy of eax
        push    eax                           ; allocate space for Control Word
        fstcw   [esp]                         ; store Control Word
        cmp     word ptr[esp],default_CW
        je      CW_is_set_to_default
        call    _load_CW                      ; edx is destroyed
CW_is_set_to_default:
; at this point we have on stack: cw(4), ret_addr(4), arg1(8bytes), arg2(8bytes)
        and     ecx,7ff00000H
        lea     edx,[esp+8]                   ; edx points to arg1(base)

        cmp     ecx,7ff00000H
        je      special_exponent

        call    _fload_withFB                 ; edx already initialized
        jz      special_base
        test    eax,7ff00000H
        jz      test_if_we_have_zero_base
base_is_not_zero:
        mov     cl,[esp+15]                   ; cl will contain sign
        and     cl,80H                        ; test sign of base
        jnz     test_if_exp_is_int
normal:                                       ; denormal is like normal
        fyl2x                                 ; compute y*log2(x)
        call    _twoToTOS
        cmp     cl,1                          ; power was odd and base<0 ?
        jnz     exit
        fchs                                  ; if yes, we should change sign
exit:
        cmp     __fastflag,0
        jnz     _fast_exit

; prepare in registers arguments for math_exit
        lea     ecx,[POW_name]
        mov     edx,OP_POW
        jmp     _check_range_exit

_ErrorHandling:
        cmp     __fastflag,0
        jnz     _fast_exit

        lea     ecx,[POW_name]
        mov     edx,OP_POW
        call    _startTwoArgErrorHandling
        pop     edx                           ; remove saved CW from stack
        ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; some special cases
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 1.One of arguments is NaN
exponent_is_NAN:
        lea     edx,[esp+8]                   ; pointer to arg1(base)
        call    _fload_withFB                 ; load arg1 to FPU stack
        test    byte ptr[esp+22],08H          ; test if arg2(exponent) is SNaN
        jnz     SNaN_detected
        inc     ecx                           ; ecx!=0 when one of args is QNaN
        jmp     test_base

SNaN_detected:
        fadd
        mov     eax,DOMAIN
        jmp     _ErrorHandling

base_is_NAN:
        test    byte ptr[esp+14],08H          ; is it SNaN
        jnz     SNaN_detected
one_of_args_is_QNaN:
        fadd                                  ; one of args is QNaN, and second is not SNaN
        mov     eax,DOMAIN_QNAN
        jmp     _ErrorHandling

special_base:
; both arguments are loaded to FPU stack
        xor     ecx,ecx
        jmp     test_base

special_exponent:
; only one argument is loaded to FPU stack
        xor     ecx,ecx                       ; we use ecx to set flags
        and     eax,000fffffH                 ; eax=high
        or      eax,[esp+16]                  ; test whether mantissa is zero
        jne     exponent_is_NAN
        lea     edx,[esp+8]                   ; pointer to arg1(base)
        call    _fload_withFB                 ; load arg1(base) to FPU stack
test_base:                                    ; arg2 may be inf, QNaN or normal
; both arguments are loaded to FPU stack
        mov     eax,[esp+12]                  ; arg1 high
        mov     edx,eax
        and     eax,7ff00000H
        and     edx,000fffffH                 ; test mantissa of arg2
        cmp     eax,7ff00000H
        jne     end_of_tests
        or      edx,[esp+8]
        jnz     base_is_NAN                   ; arg1 is NaN,

end_of_tests:
        test    ecx,ecx
        jnz     one_of_args_is_QNaN           ; base is QNaN

; one of args is infinity and second is not NaN. In this case we use powhlp()
;_usepowhlp
        sub     esp, SBUFSIZE+8               ; get storage for _retval and savebuf
        mov     ecx, esp
        push    ecx                           ; push address for result

        sub     esp, 16
        fstp    qword ptr [esp]
        fstp    qword ptr [esp+8]

        fsave   [ecx+8]
        call    _powhlp
        add     esp, 16                       ; clear arguments if _cdecl.
        pop     ecx
        frstor  [ecx+8]
        fld     qword ptr [ecx]               ; load result on the NDP stack
        add     esp, SBUFSIZE+8               ; get rid of storage

        test    eax,eax
        jz      _fast_exit
        mov     eax,DOMAIN
        jmp     _ErrorHandling



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 2.  Base has zero exponent field
;
test_if_we_have_zero_base:
        mov     eax,[esp+12]
        and     eax,000fffffH
        or      eax,[esp+8]
        jnz     base_is_not_zero

; at this point we have two arguments on FPU stack.
; We know that TOS is zero, and arg2 is not special.
; We disinguish 3 cases:
;  (1) exponent is zero
;  (2) exponent is odd
;  (3) none of above

        fstp    st(0)                         ; remove zero from FPU stack
        mov     eax,[esp+20]                  ; test if arg2 is also zero
        and     eax,7fffffffh
        or      eax,[esp+16]
        jz      zero_to_zero
; check whether exponent is odd
        call    _test_whether_TOS_is_int
; cl=1 if exponent is odd,  2 - if even and 0 otherwise
        mov     ch,[esp+15]
        shr     ch,7                          ; ch==1 iff base is negative
        test    [esp+23],80H                  ; check sign of exponent
        jz      exp_is_positive
; exponent is negative
        fld     [_infinity]
        test    cl,ch
        jz      ret_inf
        fchs                                  ; base <0 and exponent is negative odd
ret_inf:
        mov     eax,SING
        jmp     _ErrorHandling

exp_is_positive:                              ; eax=error_code
        fldz
        test    cl,ch
        jz      _fast_exit
        fchs                                  ; base <0 and exponent positive is odd
        jmp     _fast_exit                    ; return -0.0

zero_to_zero:                                 ; arg1 and arg2 are zero
        fstp    st(0)                         ; remove useless argument from FPU stack
        fld1
        jmp     _fast_exit

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;3. Base is negative.
;
;   If exponent is not integer it's a DOMAIN error
;

test_if_exp_is_int:
        fld     st(1)
        call    _test_whether_TOS_is_int
        fchs
        test    cl,cl
        jnz     normal
        fstp    st(0)
        fstp    st(0)
        fld     [_indefinite]
        mov     eax,DOMAIN
        jmp     _ErrorHandling

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                _test_whether_TOS_is_int
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; returns in cl : 0,1,2 if TOS is non-int, odd int or even int respectively
;
_test_whether_TOS_is_int:
        fld     st(0)                         ; duplicate stack top
        frndint
        fcomp                                 ; is TOS integer???
        mov     cl,0                          ; prepare return value
        fstsw   ax
        sahf
        jne     _not_int                      ; TOS is not integer
        fmul    [_half]
        inc     cl                            ; cl>0, when exponent is integer
        fld     st(0)                         ; (exponent/2)
        frndint
        fcompp                                ; check if (exponent/2)==(int)(exponent/2)
        fstsw   ax
        sahf
        jne     _odd
        inc     cl                            ; sign that exponent is even
_odd:
        ret

_not_int:
        fstp    st(0)
        ret
_CIpow_default endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\log10_pentium4.asm ===
;//
;//               INTEL CORPORATION PROPRIETARY INFORMATION
;//  This software is supplied under the terms of a license agreement or
;//  nondisclosure agreement with Intel Corporation and may not be copied
;//  or disclosed except in accordance with the terms of that agreement.
;//  Copyright (c) 2000 Intel Corporation. All Rights Reserved.
;//
;//
;    log10_wmt.asm
;
;    double log10(double);
;
;    Initial version: 11/30/2000
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; This is a second implementation of the branch-free log10 function     ;;
;; In this version, we use a trick to get the index j = 0,1,...,64 that  ;;
;; does not require integer testing. By adding 2^(42)-1 (FP) to Y, the   ;;
;; least 4 bits contains dob't cares and the 7 bits following that has   ;;
;; the range 0 to 64. Hence obtaining, say, the 16 lsb and masking off   ;;
;; everything except bit 4 through 10 gives the shifted index.           ;;
;; This saves an integer shift as well.                                  ;;
;;                                                                       ;;
;; Another important feature is that we use the table of log(1/B)        ;;
;; throughout. To ensure numerical accuracy, we only need to ensure that ;;
;; T(0)_hi = B(last)_hi, T(0)_lo = B(last)_lo. This ensures W_hi = 0 and ;;
;; W_lo = 0 exactly in the case of |X-1| <= 2^(-7).                      ;;
;; Finally, we do away with the need for extra-precision addition by the ;;
;; following observation. The three pieces at the end are                ;;
;; A = W_hi + r_hi; B = r_lo; C = P + W_lo.                              ;;
;; When W_hi = W_lo = 0, the addition sequence (A+B) + C is accurate as  ;;
;; the sum A+B is exact.                                                 ;;
;; Otherwise, A + (B+C) is accurate as B is going to be largely shifted  ;;
;; off compared to the final result.                                     ;;
;; Hence if we use compare and mask operations to                        ;;
;; create alpha = (r_lo or 0), beta = (0 or r_lo), Res_hi <- W_hi+alpha, ;;
;; Res_lo <- C + beta, then result is accurately computed as             ;;
;; Res_hi+Res_lo.                                                        ;;
;;                                                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.686P
.387
.XMM
.MODEL FLAT,C

EXTRN C __libm_error_support : NEAR  

CONST SEGMENT PARA PUBLIC USE32 'CONST'
ALIGN 16

emask   DQ  000FFFFFFFFFFFFFH, 000FFFFFFFFFFFFFH ; mask off sign/expo field
CC      DQ  3FDBC00000000000H, 3FDBC00000000000H ; pair of C           
Magic   DQ  428FFFFFFFFFF810H, 428FFFFFFFFFF810H ; 2^(42)-1+2^(-7)
hi_mask DQ  7FFFFFFF80000000H, 7FFFFFFF80000000H ; maks of bottom 31 bits
LOG10_2 DQ  3FD34413509F7800H, 3D1FEF311F12B358H ; L_hi,L_lo -> [L_lo|L_hi]
place_L DQ  0000000000000000H,0FFFFFFFFFFFFFFFFH ; 0,1 -> [FF..FF|00..00]
place_R DQ 0FFFFFFFFFFFFFFFFH, 0000000000000000H ; 1,0 -> [00..00|FF..FF]
One 	DQ  3ff0000000000000H, 3ff0000000000000H ; 1,1 
Zero    DQ  0000000000000000H, 0000000000000000H ; 0,0
Two52   DQ  4330000000000000H, 4330000000000000H ; 2^52 for normalization
Infs    DQ 0FFF0000000000000H, 7FF0000000000000H ; -inf,+inf --> [+inf|-inf]
NaN     DQ  7FF0000000000001H, 7FF0000000000001H ; NaN for log(-ve), log(Nan)

coeff   DQ  40358914C697CEF9H, 0C00893096429813DH       ; p6,p3 ->[p3|p6]   
        DQ 0C025C9806A358455H,  3FFC6A02DC9635D2H       ; p5,p2 ->[p2|p5]   
        DQ  4016AB9F7E1899F7H, 0BFF27AF2DC77B135H       ; p4,p1 ->[p1|p4]  
        DQ  3F5A7A6CBF2E4108H,  0000000000000000H       ; p0,0  -> [0|p0]

;-------Table T_hi,T_lo  so that movapd gives [ T_lo | T_hi ]
T_Tbl     DQ 0000000000000000H, 0000000000000000H
          DQ 3F7C03A80AE40000H, 3D3E05382D51F71BH
          DQ 3F8B579DB6DE0000H, 3D386B09FEFB3005H
          DQ 3F9470AEDE968000H, 3D39FC780C91E11DH
          DQ 3F9ADA2E8E3E0000H, 3D351BD19E6E701AH
          DQ 3FA0ADD8F759C000H, 3D1B2A51090000A1H
          DQ 3FA3FAF7C6630000H, 3D083662F181F53FH
          DQ 3FA7171E59EFC000H, 3D16BD1A3FCF54DBH
          DQ 3FAA3E9002C70000H, 3D21D257C8D0D386H
          DQ 3FAD32332DC34000H, 3D1B7ADBF8D9441FH
          DQ 3FB0281170D6A000H, 3D1BF38B28AF5076H
          DQ 3FB19C1FECF16000H, 3D3EE03F1E5355D4H
          DQ 3FB3151BFD65C000H, 3D37E280048C6795H
          DQ 3FB4932780C56000H, 3D2FC4ACCD62A5F3H
          DQ 3FB605735EE98000H, 3D17C3CF23A17D9FH
          DQ 3FB76B778D4AA000H, 3D1C03E812A06E7AH
          DQ 3FB8D60B4EE4C000H, 3D3900E5CC4E4C82H
          DQ 3FBA33B422244000H, 3D36F17034675735H
          DQ 3FBB95B654A78000H, 3D290E5E24764EC7H
          DQ 3FBCEA2602E9E000H, 3CEBD129822ECBCBH
          DQ 3FBE42B4C16CA000H, 3D25E50FF38D4DE9H
          DQ 3FBF8D05B16A6000H, 3D2A8EA5A2B777A7H
          DQ 3FC06D9BC53C2000H, 3D32818DEEE1FA45H
          DQ 3FC10D3EACDE0000H, 3D1E8A45CB83F0AEH
          DQ 3FC1B83F1574D000H, 3D010B19F193FFD4H
          DQ 3FC251FE054FD000H, 3CFEAC09402877C0H
          DQ 3FC2F7301CF4E000H, 3D30F5C70D1A6341H
          DQ 3FC394700F795000H, 3D1FE93F791A7264H
          DQ 3FC4297453B4A000H, 3D3ECE09C5BC4B34H
          DQ 3FC4CA24FAFEC000H, 3D2E204342E66851H
          DQ 3FC5627512093000H, 3D30DFECB3AA172DH
          DQ 3FC5F21A1AF60000H, 3D3FEF1B2D3E6113H
          DQ 3FC68DA216900000H, 3CED942CFC9699D0H
          DQ 3FC720586C280000H, 3D3D20A8624054CDH
          DQ 3FC7B495FF1C5000H, 3D25012C689133C5H
          DQ 3FC83FA266CEA000H, 3D20C6C18687239FH
          DQ 3FC8CC0E0C56F000H, 3D36E3B4A1CFA0DFH
          DQ 3FC959DFEFE7D000H, 3D2420027AFFE0E5H
          DQ 3FC9E91F47D2C000H, 3D35330E6CF22420H
          DQ 3FCA6EA48B034000H, 3D33EBACB92B5B7FH
          DQ 3FCB00B7C552F000H, 3D3DF4694C64AA73H
          DQ 3FCB88E67CF97000H, 3D32FF232278A072H
          DQ 3FCC06E3BA2E4000H, 3D32CB15CD55BD7CH
          DQ 3FCC919DD46C0000H, 3D0EB64694E6AC72H
          DQ 3FCD11FB61139000H, 3D1A34DB91AE960BH
          DQ 3FCD9F59ABFD1000H, 3D207B23BCD76C73H
          DQ 3FCE163D527E6000H, 3D319D69F22E93E4H
          DQ 3FCE9A2CDC02A000H, 3D20EBF59081F187H
          DQ 3FCF1F5876949000H, 3D07AFEBEA179000H
          DQ 3FCF99801FDB7000H, 3D22737DF7F29668H
          DQ 3FD00A5B4509D000H, 3D1F6B5B2353257FH
          DQ 3FD0488037FBE800H, 3D1B6A93B9B912C6H
          DQ 3FD087315621A800H, 3D3261DA7DBFF3AEH
          DQ 3FD0C6711D6AB800H, 3D35E94A8D30C132H
          DQ 3FD0FFD9CDD2A800H, 3D16350EF6F19D80H
          DQ 3FD1402FBEC27800H, 3D313C204222BA8BH
          DQ 3FD17A9719699000H, 3D21F279212D5C99H
          DQ 3FD1B57A30AC5800H, 3D3DCF3E62FF847EH
          DQ 3FD1F0DB153AB800H, 3D27582E230C0EDFH
          DQ 3FD2260E4F424800H, 3D157E1028A41FF9H
          DQ 3FD26262A6117800H, 3D12B01A2E0C1912H
          DQ 3FD29871C043D800H, 3D2B3969AC9E3779H
          DQ 3FD2D5C1760B8000H, 3D3AEADEBE0F08BFH
          DQ 3FD30CB3A7BB3000H, 3D38929919B6D832H
          DQ 3FD34413509F7800H, 3D1FEF311F12B358H

;-----------------
CB_Tbl    DQ 3FDBC00000000000H, 3FDBC00000000000H  
          DQ 3FDB510000000000H, 3FDB510000000000H  
          DQ 3FDAE8F000000000H, 3FDAE8F000000000H  
          DQ 3FDA80E000000000H, 3FDA80E000000000H  
          DQ 3FDA1FC000000000H, 3FDA1FC000000000H  
          DQ 3FD9BEA000000000H, 3FD9BEA000000000H  
          DQ 3FD95D8000000000H, 3FD95D8000000000H  
          DQ 3FD9035000000000H, 3FD9035000000000H  
          DQ 3FD8A92000000000H, 3FD8A92000000000H  
          DQ 3FD855E000000000H, 3FD855E000000000H  
          DQ 3FD7FF2800000000H, 3FD7FF2800000000H  
          DQ 3FD7AF6000000000H, 3FD7AF6000000000H  
          DQ 3FD75F9800000000H, 3FD75F9800000000H  
          DQ 3FD70FD000000000H, 3FD70FD000000000H  
          DQ 3FD6C38000000000H, 3FD6C38000000000H  
          DQ 3FD67AA800000000H, 3FD67AA800000000H  
          DQ 3FD631D000000000H, 3FD631D000000000H  
          DQ 3FD5EC7000000000H, 3FD5EC7000000000H  
          DQ 3FD5A71000000000H, 3FD5A71000000000H  
          DQ 3FD5652800000000H, 3FD5652800000000H  
          DQ 3FD5234000000000H, 3FD5234000000000H  
          DQ 3FD4E4D000000000H, 3FD4E4D000000000H  
          DQ 3FD4A66000000000H, 3FD4A66000000000H  
          DQ 3FD46B6800000000H, 3FD46B6800000000H  
          DQ 3FD42CF800000000H, 3FD42CF800000000H  
          DQ 3FD3F57800000000H, 3FD3F57800000000H  
          DQ 3FD3BA8000000000H, 3FD3BA8000000000H  
          DQ 3FD3830000000000H, 3FD3830000000000H  
          DQ 3FD34EF800000000H, 3FD34EF800000000H  
          DQ 3FD3177800000000H, 3FD3177800000000H  
          DQ 3FD2E37000000000H, 3FD2E37000000000H  
          DQ 3FD2B2E000000000H, 3FD2B2E000000000H  
          DQ 3FD27ED800000000H, 3FD27ED800000000H  
          DQ 3FD24E4800000000H, 3FD24E4800000000H  
          DQ 3FD21DB800000000H, 3FD21DB800000000H  
          DQ 3FD1F0A000000000H, 3FD1F0A000000000H  
          DQ 3FD1C38800000000H, 3FD1C38800000000H  
          DQ 3FD1967000000000H, 3FD1967000000000H  
          DQ 3FD1695800000000H, 3FD1695800000000H  
          DQ 3FD13FB800000000H, 3FD13FB800000000H  
          DQ 3FD112A000000000H, 3FD112A000000000H  
          DQ 3FD0E90000000000H, 3FD0E90000000000H  
          DQ 3FD0C2D800000000H, 3FD0C2D800000000H  
          DQ 3FD0993800000000H, 3FD0993800000000H  
          DQ 3FD0731000000000H, 3FD0731000000000H  
          DQ 3FD0497000000000H, 3FD0497000000000H  
          DQ 3FD026C000000000H, 3FD026C000000000H  
          DQ 3FD0009800000000H, 3FD0009800000000H  
          DQ 3FCFB4E000000000H, 3FCFB4E000000000H  
          DQ 3FCF6F8000000000H, 3FCF6F8000000000H  
          DQ 3FCF2A2000000000H, 3FCF2A2000000000H  
          DQ 3FCEE4C000000000H, 3FCEE4C000000000H  
          DQ 3FCE9F6000000000H, 3FCE9F6000000000H  
          DQ 3FCE5A0000000000H, 3FCE5A0000000000H  
          DQ 3FCE1B9000000000H, 3FCE1B9000000000H  
          DQ 3FCDD63000000000H, 3FCDD63000000000H  
          DQ 3FCD97C000000000H, 3FCD97C000000000H  
          DQ 3FCD595000000000H, 3FCD595000000000H  
          DQ 3FCD1AE000000000H, 3FCD1AE000000000H  
          DQ 3FCCE36000000000H, 3FCCE36000000000H  
          DQ 3FCCA4F000000000H, 3FCCA4F000000000H  
          DQ 3FCC6D7000000000H, 3FCC6D7000000000H  
          DQ 3FCC2F0000000000H, 3FCC2F0000000000H  
          DQ 3FCBF78000000000H, 3FCBF78000000000H  
          DQ 3FCBC00000000000H, 3FCBC00000000000H  

ALIGN 16
CONST ENDS

$cmpsd MACRO op1, op2, op3
LOCAL begin_cmpsd, end_cmpsd
begin_cmpsd:
cmppd op1, op2, op3
end_cmpsd:
org begin_cmpsd
db 0F2h
org end_cmpsd
ENDM

_TEXT SEGMENT PARA PUBLIC USE32 'CODE'
    ALIGN 16

PUBLIC _log10_pentium4, _CIlog10_pentium4
_CIlog10_pentium4 PROC NEAR
push	    ebp
mov	    ebp, esp
sub         esp, 8                          ; for argument DBLSIZE
and         esp, 0fffffff0h
fstp        qword ptr [esp]
movq        xmm0, qword ptr [esp]
call        start
leave
ret


;----------------------;
;--Argument Reduction--;
;----------------------;

_log10_pentium4 label proc
movlpd    xmm0, QWORD PTR [4+esp]         ;... load X to low part of xmm0
start:
mov       edx,0                ;... set edx to 0 

DENORMAL_RETRY:

movapd    xmm5,xmm0
unpcklpd  xmm0,xmm0            ;... [X|X]

psrlq     xmm5,52
pextrw    ecx,xmm5,0

movapd    xmm1, QWORD PTR [emask]         ;... pair of 000FF...FF
movapd    xmm2, QWORD PTR [CC]            ;... pair of CC
movapd    xmm3, QWORD PTR [One]           ;... pair of 3FF000...000
movapd    xmm4, QWORD PTR [Magic]         ;... pair of 2^(42)-1+2^(-7)
movapd    xmm6, QWORD PTR [hi_mask]       ;... pair of 7FFFFFFF8000..00
andpd     xmm0,xmm1
orpd      xmm0,xmm3            ;... [Y|Y]
addpd     xmm4,xmm0            ;... 11 lsb contains the index to CB
                               ;... the last 4 lsb are don't cares, the
                               ;... 7 bits following that is the index
                               ;... Hence by masking, we already have index*16

pextrw    eax,xmm4,0
and       eax,000007F0H        ;... eax is offset
movapd    xmm4, QWORD PTR [eax+CB_Tbl]    ;... [CB|CB]
movapd    xmm7, QWORD PTR [eax+T_Tbl]

andpd     xmm6,xmm0            ;... [Y_hi|Y_hi]
subpd     xmm0,xmm6            ;... [Y_lo|Y_lo]
mulpd     xmm6,xmm4            ;... [CB*Y_hi|CB*Y_hi]
subpd     xmm6,xmm2            ;... [R_hi|R_hi]
addsd     xmm7,xmm6            ;... [T_lo|T_hi+R_hi]
mulpd     xmm0,xmm4            ;... [R_lo|R_lo]
movapd    xmm4,xmm0            ;... [R_lo|R_lo]
addpd     xmm0,xmm6            ;... [R|R]

;-----------------------------------------;
;--Approx and Reconstruction in parallel--;
;-----------------------------------------;

;...m is in ecx, [T_lo,T_hi+R_hi] in xmm7
;...xmm4 through xmm6 will be used
and       ecx,00000FFFH        ;... note we need sign and biased exponent
sub       ecx,1
cmp       ecx,2045             ;... the largest biased exponent 2046-1
                               ;... if ecx is ABOVE (unsigned) this, either
                               ;... the sign is +ve and biased exponent is 7FF
                               ;... or the sign is +ve and exponent is 0, or
                               ;... the sign is -ve (i.e. sign bit 1)
ja        SPECIAL_CASES

sub       ecx,1022             ;... m in integer format
add       ecx,edx              ;... this is the denormal adjustment

cvtsi2sd  xmm6,ecx
unpcklpd  xmm6,xmm6            ;... [m | m] in FP format

shl       ecx,10
add       eax,ecx              ;16*(64*m + j) 0 <=> (m=-1 & j=64) or (m=0 & j=0)
mov       ecx,16
mov       edx,0
cmp       eax,0
cmove     edx,ecx              ;this is the index into the mask table (place_{L,R})
 
movapd    xmm1, QWORD PTR [coeff]         ;... loading [p3|p6]
movapd    xmm3,xmm0
movapd    xmm2, QWORD PTR [coeff+16]      ;... loading [p2|p5]
mulpd     xmm1,xmm0            ;... [p3 R | p6 R]
mulpd     xmm3,xmm3            ;... [R^2|R^2]
addpd     xmm1,xmm2            ;... [p2+p3 R |p5+p6 R]
movapd    xmm2, QWORD PTR [coeff+32]      ;... [p1|p4]
mulsd     xmm3,xmm3            ;... [R^2|R^4]

movapd    xmm5, QWORD PTR [LOG10_2]       ;... loading [L_lo|L_hi]
                               ;... [T_lo|T_hi+R_hi] already in xmm7
mulpd     xmm6,xmm5            ;... [m L_lo | m L_hi]
movapd    xmm5, QWORD PTR [edx+place_L]   ;... [FF..FF|00.00] or [00..00|FF..FF]
andpd     xmm4,xmm5            ;... [R_lo|0] or [0|R_lo]
addpd     xmm7,xmm6            ;... [W_lo|W_hi]
addpd     xmm7,xmm4            ;... [A_lo|A_hi]

mulpd     xmm1,xmm0            ;... [p2 R+p3 R^2|p5 R+p6 R^2]
mulsd     xmm3,xmm0            ;... [R^2|R^5]
addpd     xmm1,xmm2            ;... [p1+.. | p4+...]
movapd    xmm2, QWORD PTR [coeff+48]      ;... [0|p0]
mulpd     xmm2,xmm0            ;... [0|p0 R]


movapd    xmm6,xmm7            
unpckhpd  xmm6,xmm6            ;... [*|A_lo]

mulpd     xmm1,xmm3            ;... [P_hi|P_lo]
sub esp, 16
movapd    xmm0,xmm1            ;... copy of [P_hi|P_lo]
addpd     xmm1,xmm2            ;... [P_hi|P_lo]
unpckhpd  xmm0,xmm0            ;... [P_hi|P_hi]

;...[P_hi|P_lo] in xmm1 at this point
addsd     xmm0,xmm1            ;... [*|P]
addsd     xmm0,xmm6
addsd     xmm0,xmm7

movlpd    QWORD PTR [esp+4], xmm0      ; return result
fld       QWORD PTR [esp+4]             ;
add esp, 16
	ret

SPECIAL_CASES:
movlpd    xmm0, QWORD PTR [4+esp]         ;... load X again
movapd    xmm1, QWORD PTR [Zero]
$cmpsd    xmm1,xmm0,0
pextrw    eax,xmm1,0           ;... ones if X = +-0.0
cmp       eax,0
ja        INPUT_ZERO

cmp       ecx,-1               ;... ecx = -1 iff X is positive denormal
je        INPUT_DENORM

cmp       ecx,000007FEH        
ja        INPUT_NEGATIVE

movlpd    xmm0, QWORD PTR [4+esp]
movapd    xmm1, QWORD PTR [emask]
movapd    xmm2, QWORD PTR [One]
andpd     xmm0,xmm1
orpd      xmm0,xmm2            ;... xmm0 is 1 iff the input argument was +inf
$cmpsd    xmm2,xmm0,0
pextrw    eax,xmm2,0           ;... 0 if X is NaN
cmp eax, 0
je        INPUT_NaN

INPUT_INF:
;....Input is +Inf
fld       QWORD PTR [Infs+8]             ;
	ret

INPUT_NaN:

; movlpd xmm0, [esp+4]
; addsd xmm0, xmm0
; sub esp, 16
; movlpd [esp+4], xmm0
; fld QWORD PTR [esp+4]
; add esp, 16
; ret
mov edx, 1001
jmp CALL_LIBM_ERROR

INPUT_ZERO:

	; raise Divide by Zero
	movlpd xmm2, QWORD PTR [One]
	divsd  xmm2, xmm0
	movlpd xmm1, QWORD PTR [Infs]
mov edx, 8
jmp CALL_LIBM_ERROR

INPUT_DENORM:

;....check for zero or denormal
;....for now I assume this is simply denormal
;....in reality, we need to check for zero and handle appropriately

movlpd    xmm1,Two52
mulsd     xmm0,xmm1
mov       edx,-52              ;...set adjustment to exponent
jmp       DENORMAL_RETRY         ;...branch back


INPUT_NEGATIVE:

add ecx,1
and ecx, 7ffH
cmp ecx, 7ffH
jae NEG_INF_NAN 

NEG_NORMAL_INFINITY:

; xmm1=0
xorpd xmm1, xmm1
; raise Invalid
divsd xmm1, xmm1
mov edx, 9

CALL_LIBM_ERROR:

;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
sub esp, 28
movlpd QWORD PTR [esp+16], xmm1
mov DWORD PTR [esp+12],edx
mov edx, esp
add edx,16
mov DWORD PTR [esp+8],edx
add edx,16
mov DWORD PTR [esp+4],edx
mov DWORD PTR [esp],edx
call NEAR PTR __libm_error_support
fld       QWORD PTR [esp+16]             ;
add esp,28
ret



NEG_INF_NAN:

  movlpd xmm2, QWORD PTR [esp+4]
  movlpd xmm0, QWORD PTR [esp+4]
  movd eax, xmm2
  psrlq xmm2, 32
  movd ecx, xmm2
  and ecx, 0fffffH ; eliminate sign/exponent
  or eax, ecx
  cmp eax,0
  jz NEG_NORMAL_INFINITY	; negative infinity

; addsd xmm0, xmm0
; sub esp,16
; movlpd QWORD PTR [esp+4], xmm0
; fld QWORD PTR [esp+4]
; add esp, 16
; ret
mov edx, 1001
jmp CALL_LIBM_ERROR
  

_CIlog10_pentium4 ENDP

ALIGN 16
_TEXT ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\log_pentium4.asm ===
;//
;//               INTEL CORPORATION PROPRIETARY INFORMATION
;//  This software is supplied under the terms of a license agreement or
;//  nondisclosure agreement with Intel Corporation and may not be copied
;//  or disclosed except in accordance with the terms of that agreement.
;//  Copyright (c) 2000 Intel Corporation. All Rights Reserved.
;//
;//
;  log_wmt.asm
;
;  double log(double);
;
;  Initial version: 12/15/2000
;  Updated with bug fixes: 2/20/2001
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                                                       ;;
;; Another important feature is that we use the table of log(1/B)        ;;
;; throughout. To ensure numerical accuracy, we only need to ensure that ;;
;; T(0)_hi = B(last)_hi, T(0)_lo = B(last)_lo. This ensures W_hi = 0 and ;;
;; W_lo = 0 exactly in the case of |X-1| <= 2^(-7).                      ;;
;; Finally, we do away with the need for extra-precision addition by the ;;
;; following observation. The three pieces at the end are                ;;
;; A = W_hi + r_hi; B = r_lo; C = P + W_lo.                              ;;
;; When W_hi = W_lo = 0, the addition sequence (A+B) + C is accurate as  ;;
;; the sum A+B is exact.                                                 ;;
;; Otherwise, A + (B+C) is accurate as B is going to be largely shifted  ;;
;; off compared to the final result.                                     ;;
;; Hence if we use compare and mask operations to                        ;;
;; create alpha = (r_lo or 0), beta = (0 or r_lo), Res_hi <- W_hi+alpha, ;;
;; Res_lo <- C + beta, then result is accurately computed as             ;;
;; Res_hi+Res_lo.                                                        ;;
;;                                                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.686P
.387
.XMM
.MODEL FLAT,C

EXTRN C __libm_error_support : NEAR  


CONST SEGMENT PARA PUBLIC USE32 'CONST'
ALIGN 16

emask   DQ  000FFFFFFFFFFFFFH, 000FFFFFFFFFFFFFH ; mask off sign/expo field
Magic   DQ  428FFFFFFFFFF80FH, 428FFFFFFFFFF80FH ; 2^(42)-1+2^(-7)
hi_mask DQ  7FFFFFFFFFE00000H, 7FFFFFFFFFE00000H ; mask of bottom 21 bits
LOG_2   DQ  3FE62E42FEFA3800H, 3D2EF35793C76730H ; L_hi,L_lo -> [L_lo|L_hi]
place_L DQ  0000000000000000H,0FFFFFFFFFFFFFFFFH ; 0,1 -> [FF..FF|00..00]
place_R DQ 0FFFFFFFFFFFFFFFFH, 0000000000000000H ; 1,0 -> [00..00|FF..FF]
One 	DQ  3ff0000000000000H, 3ff0000000000000H ; 1,1 
Zero    DQ  0000000000000000H, 0000000000000000H ; 0,0
Two52   DQ  4330000000000000H, 4330000000000000H ; 2^52 for normalization
Infs    DQ 0FFF0000000000000H, 7FF0000000000000H ; -inf,+inf --> [+inf|-inf]
NaN     DQ  7FF0000000000001H, 7FF0000000000001H ; NaN for log(-ve), log(Nan)

coeff   DQ  3FC24998090DC555H,  0BFCFFFFFFF201E13H      ; p6,p3 ->[p3|p6]
        DQ 0BFC555C54DD57D75H,   3FD55555555555A7H      ; p5,p2 ->[p2|p5]
        DQ  3FC9999998867A53H,  0BFE000000000001CH      ; p4,p1 ->[p1|p4]

;-------Table B-----------
B_Tbl     DQ 3FF0000000000000H, 3FF0000000000000H
          DQ 3FEF820000000000H, 3FEF820000000000H
          DQ 3FEF080000000000H, 3FEF080000000000H
          DQ 3FEE920000000000H, 3FEE920000000000H
          DQ 3FEE1E0000000000H, 3FEE1E0000000000H
          DQ 3FEDAE0000000000H, 3FEDAE0000000000H
          DQ 3FED420000000000H, 3FED420000000000H
          DQ 3FECD80000000000H, 3FECD80000000000H
          DQ 3FEC720000000000H, 3FEC720000000000H
          DQ 3FEC0E0000000000H, 3FEC0E0000000000H
          DQ 3FEBAC0000000000H, 3FEBAC0000000000H
          DQ 3FEB4E0000000000H, 3FEB4E0000000000H
          DQ 3FEAF20000000000H, 3FEAF20000000000H
          DQ 3FEA980000000000H, 3FEA980000000000H
          DQ 3FEA420000000000H, 3FEA420000000000H
          DQ 3FE9EC0000000000H, 3FE9EC0000000000H
          DQ 3FE99A0000000000H, 3FE99A0000000000H
          DQ 3FE9480000000000H, 3FE9480000000000H
          DQ 3FE8FA0000000000H, 3FE8FA0000000000H
          DQ 3FE8AC0000000000H, 3FE8AC0000000000H
          DQ 3FE8620000000000H, 3FE8620000000000H
          DQ 3FE8180000000000H, 3FE8180000000000H
          DQ 3FE7D00000000000H, 3FE7D00000000000H
          DQ 3FE78A0000000000H, 3FE78A0000000000H
          DQ 3FE7460000000000H, 3FE7460000000000H
          DQ 3FE7020000000000H, 3FE7020000000000H
          DQ 3FE6C20000000000H, 3FE6C20000000000H
          DQ 3FE6820000000000H, 3FE6820000000000H
          DQ 3FE6420000000000H, 3FE6420000000000H
          DQ 3FE6060000000000H, 3FE6060000000000H
          DQ 3FE5CA0000000000H, 3FE5CA0000000000H
          DQ 3FE58E0000000000H, 3FE58E0000000000H
          DQ 3FE5560000000000H, 3FE5560000000000H
          DQ 3FE51E0000000000H, 3FE51E0000000000H
          DQ 3FE4E60000000000H, 3FE4E60000000000H
          DQ 3FE4B00000000000H, 3FE4B00000000000H
          DQ 3FE47A0000000000H, 3FE47A0000000000H
          DQ 3FE4460000000000H, 3FE4460000000000H
          DQ 3FE4140000000000H, 3FE4140000000000H
          DQ 3FE3E20000000000H, 3FE3E20000000000H
          DQ 3FE3B20000000000H, 3FE3B20000000000H
          DQ 3FE3820000000000H, 3FE3820000000000H
          DQ 3FE3520000000000H, 3FE3520000000000H
          DQ 3FE3240000000000H, 3FE3240000000000H
          DQ 3FE2F60000000000H, 3FE2F60000000000H
          DQ 3FE2CA0000000000H, 3FE2CA0000000000H
          DQ 3FE29E0000000000H, 3FE29E0000000000H
          DQ 3FE2740000000000H, 3FE2740000000000H
          DQ 3FE24A0000000000H, 3FE24A0000000000H
          DQ 3FE2200000000000H, 3FE2200000000000H
          DQ 3FE1F80000000000H, 3FE1F80000000000H
          DQ 3FE1D00000000000H, 3FE1D00000000000H
          DQ 3FE1A80000000000H, 3FE1A80000000000H
          DQ 3FE1820000000000H, 3FE1820000000000H
          DQ 3FE15C0000000000H, 3FE15C0000000000H
          DQ 3FE1360000000000H, 3FE1360000000000H
          DQ 3FE1120000000000H, 3FE1120000000000H
          DQ 3FE0EC0000000000H, 3FE0EC0000000000H
          DQ 3FE0CA0000000000H, 3FE0CA0000000000H
          DQ 3FE0A60000000000H, 3FE0A60000000000H
          DQ 3FE0840000000000H, 3FE0840000000000H
          DQ 3FE0620000000000H, 3FE0620000000000H
          DQ 3FE0420000000000H, 3FE0420000000000H
          DQ 3FE0200000000000H, 3FE0200000000000H
          DQ 3FE0000000000000H, 3FE0000000000000H

;-------Table T_hi,T_lo  so that movapd gives [ T_lo | T_hi ]
T_Tbl     DQ 0000000000000000H, 0000000000000000H
          DQ 3F8FBEA8B13C0000H, 3CDEC927B17E4E13H
          DQ 3F9F7A9B16780000H, 3D242AD9271BE7D7H
          DQ 3FA766D923C20000H, 3D1FF0A82F1C24C1H
          DQ 3FAF0C30C1114000H, 3D31A88653BA4140H
          DQ 3FB345179B63C000H, 3D3D4203D36150D0H
          DQ 3FB6EF528C056000H, 3D24573A51306A44H
          DQ 3FBA956D3ECAC000H, 3D3E63794C02C4AFH
          DQ 3FBE2507702AE000H, 3D303B433FD6EEDCH
          DQ 3FC0D79E7CD48000H, 3D3CB422847849E4H
          DQ 3FC299D30C606000H, 3D3D4D0079DC08D9H
          DQ 3FC44F8B726F8000H, 3D3DF6A4432B9BB4H
          DQ 3FC601B076E7A000H, 3D3152D7D4DFC8E5H
          DQ 3FC7B00916515000H, 3D146280D3E606A3H
          DQ 3FC9509AA0044000H, 3D3F1E675B4D35C6H
          DQ 3FCAF6895610D000H, 3D375BEBBA042B64H
          DQ 3FCC8DF7CB9A8000H, 3D3EEE42F58E1E6EH
          DQ 3FCE2A877A6B2000H, 3D3823817787081AH
          DQ 3FCFB7D86EEE3000H, 3D371FCF1923FB43H
          DQ 3FD0A504E97BB000H, 3D303094E6690C44H
          DQ 3FD1661CAECB9800H, 3D2D1C000C076A8BH
          DQ 3FD22981FBEF7800H, 3D17AF7A7DA9FC99H
          DQ 3FD2E9E2BCE12000H, 3D24300C128D1DC2H
          DQ 3FD3A71C56BB4800H, 3D08C46FB5A88483H
          DQ 3FD4610BC29C5800H, 3D385F4D833BCDC7H
          DQ 3FD51D1D93104000H, 3D35B0FAA20D9C8EH
          DQ 3FD5D01DC49FF000H, 3D2740AB8CFA5ED3H
          DQ 3FD68518244CF800H, 3D28722FF88BF119H
          DQ 3FD73C1800DC0800H, 3D3320DBF75476C0H
          DQ 3FD7E9883FA49800H, 3D3FAFF96743F289H
          DQ 3FD898D38A893000H, 3D31F666071E2F57H
          DQ 3FD94A0428036000H, 3D30E7BCB08C6B44H
          DQ 3FD9F123F4BF6800H, 3D36892015F2401FH
          DQ 3FDA99FCABDB8000H, 3D11E89C5F87A311H
          DQ 3FDB44977C148800H, 3D3C6A343FB526DBH
          DQ 3FDBEACD9E271800H, 3D268A6EDB879B51H
          DQ 3FDC92B7D6BB0800H, 3D10FE9FFF876CC2H
          DQ 3FDD360E90C38000H, 3D342CDB58440FD6H
          DQ 3FDDD4AA04E1C000H, 3D32D8512DF01AFDH
          DQ 3FDE74D262788800H, 3CFEB945ED9457BCH
          DQ 3FDF100F6C2EB000H, 3D2CCE779D37F3D8H
          DQ 3FDFACC89C9A9800H, 3D163E0D100EC76CH
          DQ 3FE02582A5C9D000H, 3D222C6C4E98E18CH
          DQ 3FE0720E5C40DC00H, 3D38E27400B03FBEH
          DQ 3FE0BF52E7353800H, 3D19B5899CD387D3H
          DQ 3FE109EB9E2E4C00H, 3D12DA67293E0BE7H
          DQ 3FE15533D3B8D400H, 3D3D981CA8B0D3C3H
          DQ 3FE19DB6BA0BA400H, 3D2B675885A4A268H
          DQ 3FE1E6DF676FF800H, 3D1A58BA81B983AAH
          DQ 3FE230B0D8BEBC00H, 3D12FC066E48667BH
          DQ 3FE2779E1EC93C00H, 3D36523373359B79H
          DQ 3FE2BF29F9841C00H, 3CFD8A3861D3B7ECH
          DQ 3FE30757344F0C00H, 3D309BE85662F034H
          DQ 3FE34C80A8958000H, 3D1D4093FCAC34BDH
          DQ 3FE39240DDE5CC00H, 3D3493DBEAB758B3H
          DQ 3FE3D89A6B1A5400H, 3D28C7CD5FA81E3EH
          DQ 3FE41BCFF4860000H, 3D076FD6B90E2A84H
          DQ 3FE4635BCF40DC00H, 3D2CE8D5D412CAADH
          DQ 3FE4A3E862342400H, 3D224FA993F78464H
          DQ 3FE4E8D015786C00H, 3D38B1C0D0303623H
          DQ 3FE52A6D269BC400H, 3D30022268F689C9H
          DQ 3FE56C91D71CF800H, 3CE07BAFD1366E9EH
          DQ 3FE5AB505B390400H, 3CD5627AF66563FAH
          DQ 3FE5EE82AA241800H, 3D2202380CDA46BEH
          DQ 3FE62E42FEFA3800H, 3D2EF35793C76730H
  
ALIGN 16
CONST ENDS

$cmpsd MACRO op1, op2, op3
LOCAL begin_cmpsd, end_cmpsd
begin_cmpsd:
cmppd op1, op2, op3
end_cmpsd:
org begin_cmpsd
db 0F2h
org end_cmpsd
ENDM


_TEXT SEGMENT PARA PUBLIC USE32 'CODE'
ALIGN 16

PUBLIC _log_pentium4, _CIlog_pentium4
_CIlog_pentium4 PROC NEAR
push        ebp
mov         ebp, esp
sub         esp, 8                          ; for argument DBLSIZE
and         esp, 0fffffff0h
fstp        qword ptr [esp]
movq        xmm0, qword ptr [esp]
call        start
leave
ret

;----------------------;
;--Argument Reduction--;
;----------------------;
_log_pentium4 label proc
movlpd    xmm0, QWORD PTR [4+esp]         ;... load X to low part of xmm0
start:
mov       edx,0                ;... set edx to 0 

DENORMAL_RETRY:

movapd    xmm5,xmm0
unpcklpd  xmm0,xmm0            ;... [X|X]

psrlq     xmm5,52
pextrw    ecx,xmm5,0

movapd    xmm1, QWORD PTR [emask]         ;... pair of 000FF...FF
movapd    xmm3, QWORD PTR [One]           ;... pair of 3FF000...000
movapd    xmm4, QWORD PTR [Magic]         ;... pair of 2^(42)-1+2^(-7)
movapd    xmm6, QWORD PTR [hi_mask]       ;... pair of 7FFFFFFF..FE00000
andpd     xmm0,xmm1
orpd      xmm0,xmm3            ;... [Y|Y]
addpd     xmm4,xmm0            ;... 11 lsb contains the index to B
                               ;... the last 4 lsb are don't cares, the
                               ;... 7 bits following that is the index
                               ;... Hence by masking, we already have index*16

pextrw    eax,xmm4,0
and       eax,000007F0H                   ;... eax is offset
movapd    xmm4, QWORD PTR [eax+B_Tbl]     ;... [B|B]
movapd    xmm7, QWORD PTR [eax+T_Tbl]

andpd     xmm6,xmm0            ;... [Y_hi|Y_hi]
subpd     xmm0,xmm6            ;... [Y_lo|Y_lo]
mulpd     xmm6,xmm4            ;... [B*Y_hi|B*Y_hi]
subpd     xmm6,xmm3            ;... [R_hi|R_hi]
addsd     xmm7,xmm6            ;... [T_lo|T_hi+R_hi]
mulpd     xmm0,xmm4            ;... [R_lo|R_lo]
movapd    xmm4,xmm0            ;... [R_lo|R_lo]
addpd     xmm0,xmm6            ;... [R|R]

;-----------------------------------------;
;--Approx and Reconstruction in parallel--;
;-----------------------------------------;

;...m is in ecx, [T_lo,T_hi+R_hi] in xmm7
;...xmm4 through xmm6 will be used
and       ecx,00000FFFH        ;... note we need sign and biased exponent
sub       ecx,1
cmp       ecx,2045             ;... the largest biased exponent 2046-1
                               ;... if ecx is ABOVE (unsigned) this, either
                               ;... the sign is +ve and biased exponent is 7FF
                               ;... or the sign is +ve and exponent is 0, or
                               ;... the sign is -ve (i.e. sign bit 1)
ja        SPECIAL_CASES

sub       ecx,1022             ;... m in integer format
add       ecx,edx              ;... this is the denormal adjustment

cvtsi2sd  xmm6,ecx
unpcklpd  xmm6,xmm6            ;... [m | m] in FP format

shl       ecx,10
add       eax,ecx              ;16*(64*m + j) 0 <=> (m=-1 & j=64) or (m=0 & j=0)
mov       ecx,16
mov       edx,0
cmp       eax,0
cmove     edx,ecx              ;this is the index into the mask table (place_{L,R})
 
movapd    xmm1, QWORD PTR [coeff]         ;... loading [p3|p6]
movapd    xmm3,xmm0
movapd    xmm2, QWORD PTR [coeff+16]      ;... loading [p2|p5]
mulpd     xmm1,xmm0                       ;... [p3 R | p6 R]
mulpd     xmm3,xmm3                       ;... [R^2|R^2]
addpd     xmm1,xmm2                       ;... [p2+p3 R |p5+p6 R]
movapd    xmm2, QWORD PTR [coeff+32]      ;... [p1|p4]
mulsd     xmm3,xmm3                       ;... [R^2|R^4]

movapd    xmm5, QWORD PTR [LOG_2]         ;... loading [L_lo|L_hi]
                                          ;... [T_lo|T_hi+R_hi] already in xmm7
mulpd     xmm6,xmm5                       ;... [m L_lo | m L_hi]
movapd    xmm5, QWORD PTR [edx+place_L]   ;... [FF..FF|00.00] or [00..00|FF..FF]
andpd     xmm4,xmm5                       ;... [R_lo|0] or [0|R_lo]
addpd     xmm7,xmm6                       ;... [W_lo|W_hi]
addpd     xmm7,xmm4                       ;... [A_lo|A_hi]

mulpd     xmm1,xmm0                       ;... [p2 R+p3 R^2|p5 R+p6 R^2]
mulsd     xmm3,xmm0                       ;... [R^2|R^5]
addpd     xmm1,xmm2                       ;... [p1+.. | p4+...]


movapd    xmm6,xmm7            
unpckhpd  xmm6,xmm6            ;... [*|A_lo]

mulpd     xmm1,xmm3            ;... [P_hi|P_lo]
sub esp, 16
movapd    xmm0,xmm1            ;... copy of [P_hi|P_lo]
unpckhpd  xmm1,xmm1            ;... [P_hi|P_hi]

;...[P_hi|P_lo] in xmm1 at this point
addsd     xmm0,xmm1            ;... [*|P]
addsd     xmm0,xmm6
addsd     xmm0,xmm7

movlpd    QWORD PTR [esp+4], xmm0       ; return result
fld       QWORD PTR [esp+4]             ;
add esp, 16
	ret

SPECIAL_CASES:
movlpd    xmm0, QWORD PTR [4+esp]         ;... load X again
movapd    xmm1, QWORD PTR [Zero]
$cmpsd    xmm1,xmm0,0
pextrw    eax,xmm1,0           ;... ones if X = +-0.0
cmp       eax,0
ja        INPUT_ZERO

cmp       ecx,-1               ;... ecx = -1 iff X is positive denormal
je        INPUT_DENORM

cmp       ecx,000007FEH        
ja        INPUT_NEGATIVE

movlpd    xmm0, QWORD PTR [4+esp]
movapd    xmm1, QWORD PTR [emask]
movapd    xmm2, QWORD PTR [One]
andpd     xmm0,xmm1
orpd      xmm0,xmm2            ;... xmm0 is 1 iff the input argument was +inf
$cmpsd    xmm2,xmm0,0
pextrw    eax,xmm2,0           ;... 0 if X is NaN
cmp eax, 0
je        INPUT_NaN

INPUT_INF:

;....Input is +Inf
fld       QWORD PTR [Infs+8]             ;
ret

INPUT_NaN:

; movlpd xmm0, QWORD PTR [esp+4]
; addsd xmm0, xmm0
; sub esp, 16
; movlpd    QWORD PTR [esp+4], xmm0       ; return result
; fld       QWORD PTR [esp+4]             ;
; add esp, 16
; ret
mov edx, 1000
jmp CALL_LIBM_ERROR

INPUT_ZERO:

	; raise Divide by Zero
	movlpd xmm2, QWORD PTR [One]
	divsd  xmm2, xmm0
	movlpd xmm1, QWORD PTR [Infs]
mov edx, 2
jmp CALL_LIBM_ERROR

INPUT_DENORM:

;....check for zero or denormal
;....for now I assume this is simply denormal
;....in reality, we need to check for zero and handle appropriately

movlpd    xmm1,Two52
mulsd     xmm0,xmm1
mov       edx,-52              ;...set adjustment to exponent
jmp       DENORMAL_RETRY       ;...branch back

INPUT_NEGATIVE:

add ecx,1
and ecx, 7ffH
cmp ecx, 7ffH
jae NEG_INF_NAN 

NEG_NORMAL_INFINITY:

; xmm1=0
xorpd xmm1, xmm1
; raise Invalid
divsd xmm1, xmm1
mov edx, 3

CALL_LIBM_ERROR:

;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
sub esp, 28
movlpd QWORD PTR [esp+16], xmm1
mov DWORD PTR [esp+12],edx
mov edx, esp
add edx,16
mov DWORD PTR [esp+8],edx
add edx,16
mov DWORD PTR [esp+4],edx
mov DWORD PTR [esp],edx
call NEAR PTR __libm_error_support
;	movlpd xmm0, QWORD PTR [esp+16]
;	movlpd    QWORD PTR [esp+16], xmm0       ; return result
fld       QWORD PTR [esp+16]             ;
add esp,28
ret


NEG_INF_NAN:

  movlpd xmm2, QWORD PTR [esp+4]
  movlpd xmm0, QWORD PTR [esp+4]
  movd eax, xmm2
  psrlq xmm2, 32
  movd ecx, xmm2
  and ecx, 0fffffH ; eliminate sign/exponent
  or eax, ecx
  cmp eax,0
  jz NEG_NORMAL_INFINITY	; negative infinity

; addsd xmm0, xmm0
; sub esp,16
; movlpd QWORD PTR [esp+4], xmm0
; fld QWORD PTR [esp+4]
; add esp, 16
; ret
mov edx, 1000
jmp CALL_LIBM_ERROR


_CIlog_pentium4 ENDP

ALIGN 16
_TEXT ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\sqrt.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;        support for sqrt() function
;
;Revision History:
;
;*******************************************************************************

.xlist
        include cruntime.inc
        include elem87.inc
.list

        .data
extrn   _indefinite:tbyte
extrn   __fastflag:dword

_NAME_  db 'sqrt',0,0,0,0

        CODESEG

extrn   _startOneArgErrorHandling:near
extrn   _fload_withFB:near
extrn   _convertTOStoQNaN:near
extrn   _checkTOS_withFB:near
extrn   _math_exit:near
extrn   _fast_exit:near
extrn   _load_CW:near


; MUST BE MODIFIED
; arg                ErrorType        result
;-------------------------------------------
;QNaN                DOMAIN_QNAN      QNaN
;SNaN                DOMAIN           indefinite
;negative            DOMAIN           indefinite
;-infinity           DOMAIN           indefinite
;+infinity           -                infinity
;+0.0                -                +0.0
;-0.0                -                -0.0
;indefinite is like QNaN
;denormal        fld converts it to normal (80 bits)

        public sqrt,_CIsqrt
_CIsqrt        proc
        sub     esp,DBLSIZE+4                   ; for argument
        fst     qword ptr [esp]
        call    _checkTOS_withFB
        call    start
        add     esp,DBLSIZE+4
        ret

sqrt        label        proc
        lea     edx,[esp+4]
        call    _fload_withFB
start:
        push    edx                           ; allocate space for Control Word
        fstcw   [esp]                         ; store Control Word
        mov     eax,[esp+0ch]                 ; eax contains high dword

; at this point we have on stack: cw(4), ret_addr(4), arg1(8bytes)

        jz      inf_or_nan
        cmp     word ptr[esp], default_CW
        je      CW_is_set_to_default
        call    _load_CW                      ; use user's precision bits
CW_is_set_to_default:
        test    eax,80000000h
        jnz     test_if_x_zero
x_is_denormal:                                ; denormal is like normal
        fsqrt
exit:
        cmp     __fastflag,0
        jnz     _fast_exit

; prepare in registers arguments for math_exit
        mov     edx,OP_SQRT
        lea     ecx,[_NAME_]
        jmp     _math_exit

test_if_x_zero:                               ; x <= 0
        test    eax,7ff00000H
        jnz     negative_x
        test    eax,000fffffH
        jnz     negative_x                    ; denormal operand
        cmp     dword ptr[esp+8],0            ; test if low dword is zero
        jnz     negative_x                    ; denormal operand
        jmp     exit


not_infinity:
        call    _convertTOStoQNaN             ; eax MUST contain high dword
        jmp     _Error_handling               ; eax=error number
inf_or_nan:
        test    eax,000fffffh
        jnz     not_infinity
        cmp     dword ptr[esp+8],0            ; test if low dword is zero
        jnz     not_infinity
        and     eax,80000000H                 ; test sign of infinity
        jz      exit                          ; infinity is already in ST(0)
negative_x:
        fstp    st(0)
        fld     [_indefinite]
        mov     eax,DOMAIN
_Error_handling:
        cmp     __fastflag,0
        jnz     _fast_exit
        mov     edx,OP_SQRT
        lea     ecx,[_NAME_]
        call    _startOneArgErrorHandling
        pop     edx                           ; remove saved CW from stack
        ret
_CIsqrt        endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\pow_pentium4.asm ===
; Copyright  (C) 1985-2000 Intel Corporation.
;
; The information and source code contained herein is the exclusive property
; of Intel Corporation and may not be disclosed, examined, or reproduced in
; whole or in part without explicit written authorization from the Company.
;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  pow_p4.asm
;
;  double pow(double,double);
;
;  Initial version: 01/10/2001
;  Update (bug fixes): 02/26/2001
;  Updated the underflow/overflow path 
;       to restore edi, esi in the correct order: 03/07/2001
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  x=2^k*1.b1 b2...b6 b7 .. b52   x1=1.b1..b52
;;     f1=(b1 b2 ..b7 +1)/2
;;  x2=x1*rcp_t1[f1]=b'0.b'1 b'2 ... b'52 b'53  (b'53=0 if b'0=1)
;;     f2=(b'7 ..b'14 +1)/2
;;  x3=x2*rcp_t2[f2]=b"0.b"1 b"2 ... b"52 b"53   (b"53=0 if b"0=1)
;;     f3=(b"13 ..b"21+1)/2
;;  R=x3*rcp_t3[f3]
;;  rcp=rcp_t1[f1]*rcp_t2[f2]*rcp_t3[f3]  (exact multiplication)
;;  E=exact_mul(rcp*x1)-R
;;  R'=RN(R+E)
;;
;;  H=RN(RN(k+T1[f1]+T2[f2]+T3[f3]+R)+E)  (high part of log2(x) approximation)
;;  Rl+El=exact(k+T1[f1]+T2[f2]+T3[f3]+R+E)-H
;;
;;  Exponential evaluation started with approximate argument yH*HH (exact 
;;  product of the most significant 26 bits of y and H)
;;  Correction added to exponential reduced argument: 
;;    yH*HL+yL*HH+yL*HL+y*(D1+D2+D3+(Rl+El)+Pl14),
;;  where Pl14=cl1*R'+...+cl4*R'^4
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    .686P
    .387
    .XMM
    .MODEL FLAT,C

EXTRN C __libm_error_support : NEAR

  

CONST SEGMENT PARA PUBLIC USE32 'CONST'
    ALIGN 16

rcp_t1	DQ 03ff0000000000000H, 03fefc08000000000H
	DQ 03fef820000000000H, 03fef448000000000H
	DQ 03fef07c000000000H, 03feecc0000000000H
	DQ 03fee914000000000H, 03fee574000000000H
	DQ 03fee1e0000000000H, 03fede5c000000000H
	DQ 03fedae8000000000H, 03fed77c000000000H
	DQ 03fed41c000000000H, 03fed0cc000000000H
	DQ 03fecd84000000000H, 03feca4c000000000H
	DQ 03fec71c000000000H, 03fec3f8000000000H
	DQ 03fec0e0000000000H, 03febdd4000000000H
	DQ 03febad0000000000H, 03feb7d8000000000H
	DQ 03feb4e8000000000H, 03feb204000000000H
	DQ 03feaf28000000000H, 03feac58000000000H
	DQ 03fea990000000000H, 03fea6d0000000000H
	DQ 03fea41c000000000H, 03fea16c000000000H
	DQ 03fe9ec8000000000H, 03fe9c2c000000000H
	DQ 03fe9998000000000H, 03fe9710000000000H
	DQ 03fe948c000000000H, 03fe9210000000000H
	DQ 03fe8f9c000000000H, 03fe8d30000000000H
	DQ 03fe8acc000000000H, 03fe8870000000000H
	DQ 03fe8618000000000H, 03fe83c8000000000H
	DQ 03fe8180000000000H, 03fe7f40000000000H
	DQ 03fe7d04000000000H, 03fe7ad4000000000H
	DQ 03fe78a4000000000H, 03fe767c000000000H
	DQ 03fe745c000000000H, 03fe7244000000000H
	DQ 03fe7030000000000H, 03fe6e20000000000H
	DQ 03fe6c18000000000H, 03fe6a14000000000H
	DQ 03fe6818000000000H, 03fe6620000000000H
	DQ 03fe642c000000000H, 03fe6240000000000H
	DQ 03fe6058000000000H, 03fe5e74000000000H
	DQ 03fe5c98000000000H, 03fe5ac0000000000H
	DQ 03fe58ec000000000H, 03fe5720000000000H
	DQ 03fe5554000000000H, 03fe5390000000000H
	DQ 03fe51d0000000000H, 03fe5014000000000H
	DQ 03fe4e60000000000H, 03fe4cac000000000H
	DQ 03fe4afc000000000H, 03fe4954000000000H
	DQ 03fe47b0000000000H, 03fe460c000000000H
	DQ 03fe4470000000000H, 03fe42d8000000000H
	DQ 03fe4140000000000H, 03fe3fb0000000000H
	DQ 03fe3e24000000000H, 03fe3c98000000000H
	DQ 03fe3b14000000000H, 03fe3990000000000H
	DQ 03fe3814000000000H, 03fe3698000000000H
	DQ 03fe3520000000000H, 03fe33b0000000000H
	DQ 03fe3240000000000H, 03fe30d0000000000H
	DQ 03fe2f68000000000H, 03fe2e04000000000H
	DQ 03fe2ca0000000000H, 03fe2b40000000000H
	DQ 03fe29e4000000000H, 03fe288c000000000H
	DQ 03fe2734000000000H, 03fe25e4000000000H
	DQ 03fe2494000000000H, 03fe2344000000000H
	DQ 03fe21fc000000000H, 03fe20b4000000000H
	DQ 03fe1f70000000000H, 03fe1e30000000000H
	DQ 03fe1cf0000000000H, 03fe1bb4000000000H
	DQ 03fe1a7c000000000H, 03fe1944000000000H
	DQ 03fe1810000000000H, 03fe16e0000000000H
	DQ 03fe15b0000000000H, 03fe1484000000000H
	DQ 03fe135c000000000H, 03fe1234000000000H
	DQ 03fe1110000000000H, 03fe0ff0000000000H
	DQ 03fe0ed0000000000H, 03fe0db4000000000H
	DQ 03fe0c98000000000H, 03fe0b80000000000H
	DQ 03fe0a68000000000H, 03fe0954000000000H
	DQ 03fe0844000000000H, 03fe0734000000000H
	DQ 03fe0624000000000H, 03fe0518000000000H
	DQ 03fe0410000000000H, 03fe0308000000000H
	DQ 03fe0204000000000H, 03fe0100000000000H
	DQ 03fe0000000000000H, 0

log2_t1 DQ 0, 0
	DQ 03f86fdf461d20000H, 03d3c9efc46d9f6f7H
	DQ 03f96e625317a0000H, 03d453f0e645614dbH
	DQ 03fa11a6297920000H, 03d4d925cd7d436d6H
	DQ 03fa6bb01a01f0000H, 03d3c995e7439db70H
	DQ 03fac4eb3635c8000H, 03d4a8192bdcad609H
	DQ 03fb0ea8b80338000H, 03d4e1797942f1be5H
	DQ 03fb3a9f062a90000H, 03d3011ef2e155a44H
	DQ 03fb665684ff80000H, 03d3084f28da93fafH
	DQ 03fb919bc335d0000H, 03d246082ed03fe7fH
	DQ 03fbbc6b9d7c04000H, 03d45b7e842652658H
	DQ 03fbe7272e1dc8000H, 03d4a2ea92333a25cH
	DQ 03fc08cd7820ec000H, 03d3543c511b40206H
	DQ 03fc1dc8f3a33c000H, 03d45598cab6d744cH
	DQ 03fc32b7a27af4000H, 03d07aba1fd6522b1H
	DQ 03fc476564c740000H, 03d4dc39f249b8f70H
	DQ 03fc5c04864906000H, 03d28c5d47e5f3668H
	DQ 03fc707a4ef786000H, 03d4f86ea591de6f8H
	DQ 03fc84c59fac38000H, 03d435cd351b14a77H
	DQ 03fc98e556aacc000H, 03d341c88d156ee10H
	DQ 03fcacf30032be000H, 03d2e3733debf9165H
	DQ 03fcc0d3213ae6000H, 03d4b15bcb18be2edH
	DQ 03fcd49f9d6d66000H, 03d30b557c2a12d29H
	DQ 03fce83c98a2d0000H, 03d442af5d10d18f2H
	DQ 03fcfbc44e396e000H, 03d47b3f928665437H
	DQ 03fd078d40936e000H, 03d38f1f608125902H
	DQ 03fd112ce25b29000H, 03d3c851c0f45bae5H
	DQ 03fd1ac0b77e3f000H, 03d3f97100b047ea3H
	DQ 03fd243a590d2b000H, 03d3c9b75e8e9d45dH
	DQ 03fd2db57ad935000H, 03cf934f5238ac23eH
	DQ 03fd37158be940000H, 03d4a16d142e3f4deH
	DQ 03fd40684445fb000H, 03d469ba14bfbfc6dH
	DQ 03fd49ad4a118d000H, 03d45cd377302cca5H
	DQ 03fd52d5be2114000H, 03d3a83640f883e4bH
	DQ 03fd5bfe367828000H, 03d49755c3dea7d5aH
	DQ 03fd6517e94738000H, 03d4e8a28223a67c4H
	DQ 03fd6e22792ef1000H, 03d314f240e7e9039H
	DQ 03fd771d87fd10000H, 03d258aaf31d36edbH
	DQ 03fd8008b6b297000H, 03d1605b88ccad976H
	DQ 03fd88e3a58a56000H, 03d2097ff572e71dfH
	DQ 03fd91bd19e695000H, 03d4dbb3ee4f6c667H
	DQ 03fd9a85babbe1000H, 03d4d889a0a61b2d6H
	DQ 03fda33d25fcb1000H, 03d4f5875d92c8dd6H
	DQ 03fdabe2f8ec96000H, 03d3c773190e2cc83H
	DQ 03fdb4865273ed000H, 03d4ab54a099e1f60H
	DQ 03fdbd07e0e781000H, 03d268ac21c0dcf20H
	DQ 03fdc5960ba6e1000H, 03d43b4bd96cb81feH
	DQ 03fdce1168b913000H, 03d2fada3055d19e2H
	DQ 03fdd679920231000H, 03d18ed5096e87504H
	DQ 03fddece20dffc000H, 03d43e26c2ced8aaaH
	DQ 03fde71ebad35f000H, 03d011609e08e95e1H
	DQ 03fdef6b3d3444000H, 03d40b35b2d1614faH
	DQ 03fdf7a349e747000H, 03d4a6e7081d99120H
	DQ 03fdffd6c9e8cc000H, 03cfa67452e86699dH
	DQ 03fe03fa97e79f000H, 03d275e12e74f8beeH
	DQ 03fe080748d542800H, 03d3b8c3b78ce0adbH
	DQ 03fe0c11650cf0000H, 03d461752eb1152a5H
	DQ 03fe1010826b18000H, 03d4ea3c98a07d258H
	DQ 03fe140ccdd4ae800H, 03d1fcada197ed2c1H
	DQ 03fe180633d744800H, 03d22551707e07a41H
	DQ 03fe1bf426e8e9800H, 03d376aff6c055f55H
	DQ 03fe1fdef5db3a000H, 03d4442de8501d871H
	DQ 03fe23c68c8201000H, 03d270c749129a57aH
	DQ 03fe27a23a05a8000H, 03d4cb0ea30b214a6H
	DQ 0bfda8f9d1c354000H, 0bd4604f54f4f9853H
	DQ 0bfda1506aee3b000H, 0bd44ff93dbb28c80H
	DQ 0bfd99ae48aa53000H, 0bd0e6ed7003dfdf5H
	DQ 0bfd9213957df2000H, 0bd3e186ac01b3f7fH
	DQ 0bfd8a9228a043000H, 0bd49bc20cf8dd883H
	DQ 0bfd8306ebf51c000H, 0bd45c8266e480596H
	DQ 0bfd7b83a057f9000H, 0bd35f4f79f443745H
	DQ 0bfd741a637fca000H, 0bd4025f49ff0180dH
	DQ 0bfd6cb99e7aa4000H, 0bd412b5ad5a7002aH
	DQ 0bfd654f5e853d000H, 0bd44c7008c4a72a7H
	DQ 0bfd5dfff91d34000H, 0bd3f544ed390ba95H
	DQ 0bfd56b9933779000H, 0bd391dc031bae772H
	DQ 0bfd4f69f5d830000H, 0bd38f36dd24bae46H
	DQ 0bfd483602143d000H, 0bce09c599a327931H
	DQ 0bfd410b98a0d4000H, 0bd156a3c28e8042aH
	DQ 0bfd39d83e4060000H, 0bd447f1643c10456H
	DQ 0bfd32c15f8b57000H, 0bd0d6ee2e01d9231H
	DQ 0bfd2ba1c0891f000H, 0bd3795076c3da632H
	DQ 0bfd249f2ada03000H, 0bd2a7809feb5964fH
	DQ 0bfd1d9406c900000H, 0bd4546d73ea7c032H
	DQ 0bfd16935d34fb000H, 0bd2151c6348d84a4H
	DQ 0bfd0fb093a3fd000H, 0bd2bacac000943a5H
	DQ 0bfd08c588cda7000H, 0bd43c72c4f78dfa1H
	DQ 0bfd01d228cf40000H, 0bd3c6972c813e541H
	DQ 0bfcf5faa7e71a000H, 0bd3d157620c552c1H
	DQ 0bfce867e093dc000H, 0bd366fa6f3fffcc0H
	DQ 0bfcdac50fe6d4000H, 0bd2b6484bb8f2009H
	DQ 0bfccd398e83e8000H, 0bd05f5cde492c839H
	DQ 0bfcbfc5c1d5be000H, 0bd2784900e42b538H
	DQ 0bfcb26a0fb83e000H, 0bd4a5b99e91f69b7H
	DQ 0bfca4fed5abba000H, 0bd45976e8062c61fH
	DQ 0bfc97d45e2448000H, 0bd401c636755cd02H
	DQ 0bfc8a9ad0948a000H, 0bd4c89ba64f25a55H
	DQ 0bfc7d520a4220000H, 0bd216a44d008a53dH
	DQ 0bfc704b6c17f0000H, 0bd413a806d56d6eeH
	DQ 0bfc633609cb64000H, 0bd33f125177ec11cH
	DQ 0bfc563adff6b0000H, 0bd4d0837079422c3H
	DQ 0bfc495a582ff2000H, 0bd3ebd9313709ef4H
	DQ 0bfc3c6b62529a000H, 0bd42d2b08296bf5cH
	DQ 0bfc2f9786ad2e000H, 0bd3b5188c2483623H
	DQ 0bfc22df302746000H, 0bd3048e3c2505d3dH
	DQ 0bfc1618c543b8000H, 0bd45b8d6a3b61bd1H
	DQ 0bfc096e5a2260000H, 0bd4bde98232d61f6H
	DQ 0bfbf9c0b5c568000H, 0bd4d3483b7a56256H
	DQ 0bfbe089492ee4000H, 0bd405589fcd57f86H
	DQ 0bfbc78bae5580000H, 0bd35351d0387c197H
	DQ 0bfbaec8bfaf64000H, 0bd3d13cbabea0e44H
	DQ 0bfb95eb24969c000H, 0bd3727fab299d747H
	DQ 0bfb7d49341a08000H, 0bd4eeef8bcf7aa55H
	DQ 0bfb64e3caa930000H, 0bd31aad2031e3ecaH
	DQ 0bfb4c647d2ea8000H, 0bceb43c4115c4fb7H
	DQ 0bfb3422b94a24000H, 0bd421b493a67e318H
	DQ 0bfb1bc75cf5a4000H, 0bd4d7db2139e8397H
	DQ 0bfb03aa8f8dc8000H, 0bd153121e9af5428H
	DQ 0bfad6e8ef48f8000H, 0bd38293c51765dbcH
	DQ 0bfaa6fbed7680000H, 0bd2b1c66db7cd724H
	DQ 0bfa778fdc1828000H, 0bd34378af2af5332H
	DQ 0bfa47f2e22550000H, 0bd2a424693c56dcdH
	DQ 0bfa18249a5368000H, 0bd441b0d5fdf534bH
	DQ 0bf9d1b35ee200000H, 0bd431fb72db4f24dH
	DQ 0bf97427d317a0000H, 0bd4700f14b03b093H
	DQ 0bf9163d20d100000H, 0bd46e8b9664fe33fH
	DQ 0bf872c1f4cf00000H, 0bd2b4934580fe573H
	DQ 0bf7709c46d780000H, 0bd4563ba56cde924H
	DQ 0H, 0H


rcp_t2	DQ 03ff0000000000000H, 03fefff4000000000H
	DQ 03feffe4000000000H, 03feffd4000000000H
	DQ 03feffc4000000000H, 03feffb4000000000H
	DQ 03feffa4000000000H, 03feff94000000000H
	DQ 03feff84000000000H, 03feff74000000000H
	DQ 03feff64000000000H, 03feff54000000000H
	DQ 03feff44000000000H, 03feff34000000000H
	DQ 03feff24000000000H, 03feff14000000000H
	DQ 03feff04000000000H, 03fefef4000000000H
	DQ 03fefee4000000000H, 03fefed4000000000H
	DQ 03fefec4000000000H, 03fefeb4000000000H
	DQ 03fefea4000000000H, 03fefe94000000000H
	DQ 03fefe84000000000H, 03fefe74000000000H
	DQ 03fefe64000000000H, 03fefe54000000000H
	DQ 03fefe44000000000H, 03fefe34000000000H
	DQ 03fefe24000000000H, 03fefe14000000000H
	DQ 03fefe04000000000H, 03fefdf4000000000H
	DQ 03fefde4000000000H, 03fefdd4000000000H
	DQ 03fefdc4000000000H, 03fefdb4000000000H
	DQ 03fefda4000000000H, 03fefd94000000000H
	DQ 03fefd84000000000H, 03fefd74000000000H
	DQ 03fefd64000000000H, 03fefd54000000000H
	DQ 03fefd44000000000H, 03fefd34000000000H
	DQ 03fefd28000000000H, 03fefd18000000000H
	DQ 03fefd08000000000H, 03fefcf8000000000H
	DQ 03fefce8000000000H, 03fefcd8000000000H
	DQ 03fefcc8000000000H, 03fefcb8000000000H
	DQ 03fefca8000000000H, 03fefc98000000000H
	DQ 03fefc88000000000H, 03fefc78000000000H
	DQ 03fefc68000000000H, 03fefc58000000000H
	DQ 03fefc48000000000H, 03fefc38000000000H
	DQ 03fefc28000000000H, 03fefc18000000000H
	DQ 03ff0100000000000H, 03ff00fc000000000H
	DQ 03ff00f8000000000H, 03ff00f4000000000H
	DQ 03ff00f0000000000H, 03ff00ec000000000H
	DQ 03ff00e8000000000H, 03ff00e4000000000H
	DQ 03ff00e0000000000H, 03ff00dc000000000H
	DQ 03ff00d8000000000H, 03ff00d4000000000H
	DQ 03ff00d0000000000H, 03ff00cc000000000H
	DQ 03ff00c8000000000H, 03ff00c4000000000H
	DQ 03ff00c0000000000H, 03ff00bc000000000H
	DQ 03ff00b8000000000H, 03ff00b4000000000H
	DQ 03ff00b0000000000H, 03ff00ac000000000H
	DQ 03ff00a8000000000H, 03ff00a4000000000H
	DQ 03ff00a0000000000H, 03ff009c000000000H
	DQ 03ff0098000000000H, 03ff0094000000000H
	DQ 03ff0090000000000H, 03ff008c000000000H
	DQ 03ff0088000000000H, 03ff0084000000000H
	DQ 03ff0080000000000H, 03ff007c000000000H
	DQ 03ff0078000000000H, 03ff0074000000000H
	DQ 03ff0070000000000H, 03ff006c000000000H
	DQ 03ff0068000000000H, 03ff0064000000000H
	DQ 03ff0060000000000H, 03ff005c000000000H
	DQ 03ff0058000000000H, 03ff0054000000000H
	DQ 03ff0050000000000H, 03ff004c000000000H
	DQ 03ff0048000000000H, 03ff0044000000000H
	DQ 03ff0040000000000H, 03ff003c000000000H
	DQ 03ff0038000000000H, 03ff0034000000000H
	DQ 03ff0030000000000H, 03ff002c000000000H
	DQ 03ff0028000000000H, 03ff0024000000000H
	DQ 03ff0020000000000H, 03ff001c000000000H
	DQ 03ff0018000000000H, 03ff0014000000000H
	DQ 03ff0010000000000H, 03ff000c000000000H
	DQ 03ff0008000000000H, 03ff0004000000000H
	DQ 03ff0000000000000H, 0


log2_t2 DQ 0, 0
	DQ 03f2150297c800000H, 03d210909f6306155H
	DQ 03f34332be0000000H, 03d09518ce032f41dH
	DQ 03f3fbe9f60c00000H, 03d4ac9bc570c3b37H
	DQ 03f45a537a3600000H, 03d4325006127af86H
	DQ 03f4b6b4dcbc00000H, 03d3c621fbc9e2ad6H
	DQ 03f5098c916300000H, 03d3f7aec2cad082aH
	DQ 03f537c0264100000H, 03d4bdf2754a94bbeH
	DQ 03f565f52d1000000H, 03d46f089976214ecH
	DQ 03f5942ba5e700000H, 03d2645f4fefad48aH
	DQ 03f5c26390dc00000H, 03d394ecb87dff47fH
	DQ 03f5f09cee0700000H, 03d415d326245addfH
	DQ 03f60f6bdebf80000H, 03d492366d5b7121cH
	DQ 03f62689ffae00000H, 03d3360481790324fH
	DQ 03f63da8d9da00000H, 03d31fe61b7973265H
	DQ 03f654c86d4f00000H, 03d4d5202bf82be32H
	DQ 03f66be8ba1980000H, 03d3a5f8d1a33f641H
	DQ 03f68309c04400000H, 03d4f65693283bc5bH
	DQ 03f69a2b7fdb00000H, 03d4b05a072311cdeH
	DQ 03f6b14df8ea00000H, 03d2da3ce84a38084H
	DQ 03f6c8712b7c00000H, 03d385b88ccf9e4bcH
	DQ 03f6df95179d00000H, 03d4138577c1eb13eH
	DQ 03f6f6b9bd5880000H, 03d4eb2dd71123ec2H
	DQ 03f706ef8e5d40000H, 03d4d0d7b6d01207aH
	DQ 03f712829ae740000H, 03d44fe53f52c6d10H
	DQ 03f71e16045000000H, 03d3f031f657d9491H
	DQ 03f729a9ca9d40000H, 03d45d9663a7e7da0H
	DQ 03f7353dedd500000H, 03d418e26d5dfd1bfH
	DQ 03f740d26dfd00000H, 03d38dc829af0262cH
	DQ 03f74c674b1b00000H, 03d408e4eb4d165e5H
	DQ 03f757fc853500000H, 03d3092346f3f705eH
	DQ 03f763921c5080000H, 03d4e3fa9e85711eeH
	DQ 03f76f281073c0000H, 03d4d59479023862bH
	DQ 03f77abe61a480000H, 03d40c38980430771H
	DQ 03f786550fe880000H, 03d1f92db260b1230H
	DQ 03f791ec1b4580000H, 03d150038c4b502c5H
	DQ 03f79d8383c140000H, 03d48cd3d7b281721H
	DQ 03f7a91b496200000H, 03d42c11f472c64baH
	DQ 03f7b4b36c2d40000H, 03d4d0945eaf29dd2H
	DQ 03f7c04bec2940000H, 03d21e7318833be77H
	DQ 03f7cbe4c95b40000H, 03d462d58105ef8bfH
	DQ 03f7d77e03c980000H, 03d4f85219e901c30H
	DQ 03f7e3179b7a00000H, 03d3c51fbafc4227cH
	DQ 03f7eeb1907240000H, 03d400766896bf3baH
	DQ 03f7fa4be2b840000H, 03d43558362ba179cH
	DQ 03f802f3492900000H, 03d2a3ccb5f4b8d2aH
	DQ 03f8074d69a3c0000H, 03d490b788dcc06d5H
	DQ 03f80d1b1320e0000H, 03d2b412556cf5977H
	DQ 03f812e8eb4fc0000H, 03d45c237732b1f78H
	DQ 03f818b6f23380000H, 03d45669defd365c1H
	DQ 03f81e8527cf00000H, 03d4589b8de73054bH
	DQ 03f824538c2540000H, 03d28fab914103d9cH
	DQ 03f82a221f3900000H, 03d47df970829f58aH
	DQ 03f82ff0e10d60000H, 03d4b0d87d80e4623H
	DQ 03f835bfd1a560000H, 03cf61343d497e17fH
	DQ 03f83b8ef103a0000H, 03d49f7f4ef56f96bH
	DQ 03f8415e3f2b60000H, 03d4859d5f817f2faH
	DQ 03f8472dbc1f80000H, 03d3b2734e7bf7114H
	DQ 03f84cfd67e2e0000H, 03d3753903d1eeba1H
	DQ 03f852cd427880000H, 03d23a058a8f8ba37H
	DQ 03f8589d4be340000H, 03d37c2ec6bdcca43H
	DQ 03f85e6d842620000H, 03d43701d45acf2c4H
	DQ 03f8643deb4420000H, 03d3d6b197832ab27H
	DQ 03f86a0e814020000H, 03d411a9b5557b8ccH
	DQ 0bf7709c46d780000H, 0bd4563ba56cde924H
	DQ 0bf76adca91cc0000H, 0bd37a1a05bc6b74bH
	DQ 0bf7651cf479c0000H, 0bd461bfa6c8b2465H
	DQ 0bf75f5d28ee00000H, 0bd48fc8fd49e79d0H
	DQ 0bf7599d4678c0000H, 0bd4925a3c7b88c7cH
	DQ 0bf753dd4d1940000H, 0bd4b4606033fb2beH
	DQ 0bf74e1d3ccf00000H, 0bd20210971a52753H
	DQ 0bf7485d1598c0000H, 0bd4812a07c384c12H
	DQ 0bf7429cd77640000H, 0bd4c07239b769baaH
	DQ 0bf73cdc8266c0000H, 0bd44838a3ea90181H
	DQ 0bf7371c166980000H, 0bd288537c7f77e67H
	DQ 0bf7315b937d80000H, 0bd4575a30536968cH
	DQ 0bf72b9af9a280000H, 0bd2c45e11e2e7675H
	DQ 0bf725da48d740000H, 0bd4f8176c38b4ce6H
	DQ 0bf72019811bc0000H, 0bd1a700bd79ac8a3H
	DQ 0bf71a58a26e80000H, 0bd46fb3522850043H
	DQ 0bf71497accf40000H, 0bd4f08e7ddd3e76fH
	DQ 0bf70ed6a03d40000H, 0bd4ff2a8fb0fa804H
	DQ 0bf709157cb7c0000H, 0bd4e2fc0aec80d04H
	DQ 0bf70354423e00000H, 0bd4e332fcfabff4fH
	DQ 0bf6fb25e19f00000H, 0bd21aebe490c8214H
	DQ 0bf6efa310d600000H, 0bd4543b144a21404H
	DQ 0bf6e420122080000H, 0bd45215e0a197589H
	DQ 0bf6d89ce57d00000H, 0bd30cd2d2dbef9ddH
	DQ 0bf6cd198ae980000H, 0bd4370f2ebb44e84H
	DQ 0bf6c196026500000H, 0bd4a99c21180f792H
	DQ 0bf6b6124bee80000H, 0bd11b04ea788b3a9H
	DQ 0bf6aa8e678380000H, 0bd3d2d0d040e5bb2H
	DQ 0bf69f0a552380000H, 0bd201eaa7eae8a79H
	DQ 0bf6938614cc80000H, 0bd2b467aacd98f5bH
	DQ 0bf68801a67d00000H, 0bd4b3840d3f33c6bH
	DQ 0bf67c7d0a3480000H, 0bd25ec92da83377dH
	DQ 0bf670f83ff080000H, 0bd33ab2631d4676dH
	DQ 0bf6657347b000000H, 0bd38fd1349b69dfeH
	DQ 0bf659ee217180000H, 0bd41a8baa44fb97dH
	DQ 0bf64e68cd3380000H, 0bd4d828cbc5c5ff3H
	DQ 0bf642e34af500000H, 0bd44361aa8b3c316H
	DQ 0bf6375d9ab400000H, 0bd49e932f704de99H
	DQ 0bf62bd7bc6f80000H, 0bd42bd57c254b5e3H
	DQ 0bf62051b02600000H, 0bd167df372942ee0H
	DQ 0bf614cb75d580000H, 0bd3c729ec54d36cdH
	DQ 0bf609450d7d00000H, 0bd490ea5c63bcdf1H
	DQ 0bf5fb7cee3700000H, 0bd2d803cea0e76a9H
	DQ 0bf5e46f655d00000H, 0bd4d398b96b4f4d5H
	DQ 0bf5cd61806b00000H, 0bd4ea2cca3058bbdH
	DQ 0bf5b6533f5e00000H, 0bd3f3e6ba7bbdd88H
	DQ 0bf59f44a23200000H, 0bd442ddc05082614H
	DQ 0bf58835a8e500000H, 0bd40498534d8fe6dH
	DQ 0bf57126537400000H, 0bd2fa2a0fd4fca1cH
	DQ 0bf55a16a1db00000H, 0bd4efd6c9949b49bH
	DQ 0bf54306941900000H, 0bd4975aa0b715781H
	DQ 0bf52bf62a2a00000H, 0bd4b3ae86d7c16e7H
	DQ 0bf514e5640c00000H, 0bd3064bec2477c3fH
	DQ 0bf4fba8837600000H, 0bd20f3d834ceb438H
	DQ 0bf4cd85866800000H, 0bd433742d88c7aa2H
	DQ 0bf49f61d0ea00000H, 0bd48f98b25223470H
	DQ 0bf4713d62f600000H, 0bd4957c30af53ad3H
	DQ 0bf443183c8600000H, 0bd48218d1305b92fH
	DQ 0bf414f25d9400000H, 0bd492239f241b9b9H
	DQ 0bf3cd978c3800000H, 0bcd0642236ea2a75H
	DQ 0bf37148ec2800000H, 0bd40dfe447087803H
	DQ 0bf314f8daf400000H, 0bd3e3bcf284f9cb2H
	DQ 0bf2714eb11800000H, 0bd4e94d8dd523885H
	DQ 0bf1715193b000000H, 0bd17d35d328b2afeH
	DQ 0, 0

rcp_t3	DQ 03ff7154740000000H, 03ff71545c0000000H
	DQ 03ff7154440000000H, 03ff7154300000000H
	DQ 03ff7154180000000H, 03ff7154000000000H
	DQ 03ff7153e80000000H, 03ff7153d40000000H
	DQ 03ff7153bc0000000H, 03ff7153a40000000H
	DQ 03ff71538c0000000H, 03ff7153780000000H
	DQ 03ff7153600000000H, 03ff7153480000000H
	DQ 03ff7153300000000H, 03ff7153180000000H
	DQ 03ff7153040000000H, 03ff7152ec0000000H
	DQ 03ff7152d40000000H, 03ff7152bc0000000H
	DQ 03ff7152a80000000H, 03ff7152900000000H
	DQ 03ff7152780000000H, 03ff7152600000000H
	DQ 03ff71524c0000000H, 03ff7152340000000H
	DQ 03ff71521c0000000H, 03ff7152040000000H
	DQ 03ff7151ec0000000H, 03ff7151d80000000H
	DQ 03ff7151c00000000H, 03ff7151a80000000H
	DQ 03ff7151900000000H, 03ff71517c0000000H
	DQ 03ff7151640000000H, 03ff71514c0000000H
	DQ 03ff7151340000000H, 03ff71511c0000000H
	DQ 03ff7151080000000H, 03ff7150f00000000H
	DQ 03ff7150d80000000H, 03ff7150c00000000H
	DQ 03ff7150ac0000000H, 03ff7150940000000H
	DQ 03ff71507c0000000H, 03ff7150640000000H
	DQ 03ff7150500000000H, 03ff7150380000000H
	DQ 03ff7150200000000H, 03ff7150080000000H
	DQ 03ff714ff00000000H, 03ff714fdc0000000H
	DQ 03ff714fc40000000H, 03ff714fac0000000H
	DQ 03ff714f940000000H, 03ff714f800000000H
	DQ 03ff714f680000000H, 03ff714f500000000H
	DQ 03ff714f380000000H, 03ff714f240000000H
	DQ 03ff714f0c0000000H, 03ff714ef40000000H
	DQ 03ff714edc0000000H, 03ff714ec40000000H
	DQ 03ff714eb00000000H, 03ff714e980000000H
	DQ 03ff714e800000000H, 03ff714e680000000H
	DQ 03ff714e540000000H, 03ff714e3c0000000H
	DQ 03ff714e240000000H, 03ff714e0c0000000H
	DQ 03ff714df80000000H, 03ff714de00000000H
	DQ 03ff714dc80000000H, 03ff714db00000000H
	DQ 03ff714d980000000H, 03ff714d840000000H
	DQ 03ff714d6c0000000H, 03ff714d540000000H
	DQ 03ff714d3c0000000H, 03ff714d280000000H
	DQ 03ff714d100000000H, 03ff714cf80000000H
	DQ 03ff714ce00000000H, 03ff714ccc0000000H
	DQ 03ff714cb40000000H, 03ff714c9c0000000H
	DQ 03ff714c840000000H, 03ff714c6c0000000H
	DQ 03ff714c580000000H, 03ff714c400000000H
	DQ 03ff714c280000000H, 03ff714c100000000H
	DQ 03ff714bfc0000000H, 03ff714be40000000H
	DQ 03ff714bcc0000000H, 03ff714bb40000000H
	DQ 03ff714ba00000000H, 03ff714b880000000H
	DQ 03ff714b700000000H, 03ff714b580000000H
	DQ 03ff714b400000000H, 03ff714b2c0000000H
	DQ 03ff714b140000000H, 03ff714afc0000000H
	DQ 03ff714ae40000000H, 03ff714ad00000000H
	DQ 03ff714ab80000000H, 03ff714aa00000000H
	DQ 03ff714a880000000H, 03ff714a740000000H
	DQ 03ff714a5c0000000H, 03ff714a440000000H
	DQ 03ff714a2c0000000H, 03ff714a140000000H
	DQ 03ff714a000000000H, 03ff7149e80000000H
	DQ 03ff7149d00000000H, 03ff7149b80000000H
	DQ 03ff7149a40000000H, 03ff71498c0000000H
	DQ 03ff7149740000000H, 03ff71495c0000000H
	DQ 03ff7149480000000H, 03ff7149300000000H
	DQ 03ff7149180000000H, 03ff7149000000000H
	DQ 03ff715a380000000H, 03ff715a2c0000000H
	DQ 03ff715a240000000H, 03ff715a180000000H
	DQ 03ff715a0c0000000H, 03ff715a000000000H
	DQ 03ff7159f40000000H, 03ff7159e80000000H
	DQ 03ff7159dc0000000H, 03ff7159d00000000H
	DQ 03ff7159c40000000H, 03ff7159bc0000000H
	DQ 03ff7159b00000000H, 03ff7159a40000000H
	DQ 03ff7159980000000H, 03ff71598c0000000H
	DQ 03ff7159800000000H, 03ff7159740000000H
	DQ 03ff7159680000000H, 03ff7159600000000H
	DQ 03ff7159540000000H, 03ff7159480000000H
	DQ 03ff71593c0000000H, 03ff7159300000000H
	DQ 03ff7159240000000H, 03ff7159180000000H
	DQ 03ff71590c0000000H, 03ff7159000000000H
	DQ 03ff7158f80000000H, 03ff7158ec0000000H
	DQ 03ff7158e00000000H, 03ff7158d40000000H
	DQ 03ff7158c80000000H, 03ff7158bc0000000H
	DQ 03ff7158b00000000H, 03ff7158a40000000H
	DQ 03ff7158980000000H, 03ff7158900000000H
	DQ 03ff7158840000000H, 03ff7158780000000H
	DQ 03ff71586c0000000H, 03ff7158600000000H
	DQ 03ff7158540000000H, 03ff7158480000000H
	DQ 03ff71583c0000000H, 03ff7158300000000H
	DQ 03ff7158280000000H, 03ff71581c0000000H
	DQ 03ff7158100000000H, 03ff7158040000000H
	DQ 03ff7157f80000000H, 03ff7157ec0000000H
	DQ 03ff7157e00000000H, 03ff7157d40000000H
	DQ 03ff7157cc0000000H, 03ff7157c00000000H
	DQ 03ff7157b40000000H, 03ff7157a80000000H
	DQ 03ff71579c0000000H, 03ff7157900000000H
	DQ 03ff7157840000000H, 03ff7157780000000H
	DQ 03ff71576c0000000H, 03ff7157640000000H
	DQ 03ff7157580000000H, 03ff71574c0000000H
	DQ 03ff7157400000000H, 03ff7157340000000H
	DQ 03ff7157280000000H, 03ff71571c0000000H
	DQ 03ff7157100000000H, 03ff7157040000000H
	DQ 03ff7156fc0000000H, 03ff7156f00000000H
	DQ 03ff7156e40000000H, 03ff7156d80000000H
	DQ 03ff7156cc0000000H, 03ff7156c00000000H
	DQ 03ff7156b40000000H, 03ff7156a80000000H
	DQ 03ff7156a00000000H, 03ff7156940000000H
	DQ 03ff7156880000000H, 03ff71567c0000000H
	DQ 03ff7156700000000H, 03ff7156640000000H
	DQ 03ff7156580000000H, 03ff71564c0000000H
	DQ 03ff7156400000000H, 03ff7156380000000H
	DQ 03ff71562c0000000H, 03ff7156200000000H
	DQ 03ff7156140000000H, 03ff7156080000000H
	DQ 03ff7155fc0000000H, 03ff7155f00000000H
	DQ 03ff7155e40000000H, 03ff7155d80000000H
	DQ 03ff7155d00000000H, 03ff7155c40000000H
	DQ 03ff7155b80000000H, 03ff7155ac0000000H
	DQ 03ff7155a00000000H, 03ff7155940000000H
	DQ 03ff7155880000000H, 03ff71557c0000000H
	DQ 03ff7155700000000H, 03ff7155680000000H
	DQ 03ff71555c0000000H, 03ff7155500000000H
	DQ 03ff7155440000000H, 03ff7155380000000H
	DQ 03ff71552c0000000H, 03ff7155200000000H
	DQ 03ff7155140000000H, 03ff71550c0000000H
	DQ 03ff7155000000000H, 03ff7154f40000000H
	DQ 03ff7154e80000000H, 03ff7154dc0000000H
	DQ 03ff7154d00000000H, 03ff7154c40000000H
	DQ 03ff7154b80000000H, 03ff7154ac0000000H
	DQ 03ff7154a40000000H, 03ff7154980000000H
	DQ 03ff71548c0000000H, 03ff7154800000000H
	DQ 03ff7154740000000H, 0

log2_t3	DQ 0, 0
	DQ 03eb80000c0000000H, 03d4722f0009be959H
	DQ 03ec80001a0000000H, 03d45e6576cb6dc2eH
	DQ 03ed10001a0000000H, 03d480762a98bdb6aH
	DQ 03ed7000300000000H, 03d231a4c495ec799H
	DQ 03edd0004b0000000H, 03d4926846928cda3H
	DQ 03ee1800368000000H, 03d4527509fdde667H
	DQ 03ee4000470000000H, 03d44fbd1292ae6daH
	DQ 03ee70005d8000000H, 03d4ef91cb226fd03H
	DQ 03eea000778000000H, 03d40978c9dc43b2eH
	DQ 03eed000948000000H, 03d33ae75bbe97951H
	DQ 03eef800af0000000H, 03d2d81b9a1639c05H
	DQ 03ef140068c000000H, 03d3d3aa4a1dd8452H
	DQ 03ef2c007b8000000H, 03d4d7bbe110bfb09H
	DQ 03ef4400900000000H, 03d43fbcb9ab61086H
	DQ 03ef5c00a60000000H, 03d421d94dff79062H
	DQ 03ef7000b98000000H, 03d43b8e9647408a2H
	DQ 03ef8800d24000000H, 03d4fd8ce39e1fdd4H
	DQ 03efa000ecc000000H, 03d439ab84e20bc42H
	DQ 03efb80108c000000H, 03d3dfd83269c6ac2H
	DQ 03efcc01214000000H, 03d3ca32ecd8004e0H
	DQ 03efe401400000000H, 03d47b472936c6005H
	DQ 03effc01608000000H, 03d31736ce8ef8e21H
	DQ 03f00a00c14000000H, 03d0617cfc138ccabH
	DQ 03f01400cfe000000H, 03d4e6d11d620108aH
	DQ 03f02000e26000000H, 03d2451827455b88dH
	DQ 03f02c00f58000000H, 03d435e7b8e426950H
	DQ 03f03801098000000H, 03d3296f937d77647H
	DQ 03f044011e4000000H, 03d2b6df6e16cae71H
	DQ 03f04e01302000000H, 03d2ff9376a2ea421H
	DQ 03f05a01464000000H, 03d438ebd204c10d2H
	DQ 03f066015d4000000H, 03d2b09d7e2fc6debH
	DQ 03f07201750000000H, 03d099925641f4f35H
	DQ 03f07c01896000000H, 03cedfbf4f07288e3H
	DQ 03f08801a28000000H, 03d32a0616748ca2aH
	DQ 03f09401bc6000000H, 03d49cc1e9cba43abH
	DQ 03f0a001d72000000H, 03d41ebd38173f5dbH
	DQ 03f0ac01f2a000000H, 03d41af6954471a92H
	DQ 03f0b6020a2000000H, 03d44a88bd59f4b89H
	DQ 03f0c202272000000H, 03d137160b27044e6H
	DQ 03f0ce0244c000000H, 03d47d7f6c97ef2fcH
	DQ 03f0da02634000000H, 03d44e605e1bb0db2H
	DQ 03f0e4027d4000000H, 03d459d8417d4ebcfH
	DQ 03f0f0029d4000000H, 03cf5ca7f05f05027H
	DQ 03f0fc02bde000000H, 03d4363b1c234f566H
	DQ 03f104016fb000000H, 03d3b7b6ed1035771H
	DQ 03f109017df000000H, 03d38699e204367efH
	DQ 03f10f018f6000000H, 03d44924bd9581118H
	DQ 03f11501a14000000H, 03d2252e80eb13b47H
	DQ 03f11b01b37000000H, 03d4c3c3381ce38a0H
	DQ 03f12101c61000000H, 03d4b88d24672a90dH
	DQ 03f12601d5e000000H, 03d4e1fc955055fefH
	DQ 03f12c01e94000000H, 03d36e18a547f3bc2H
	DQ 03f13201fd0000000H, 03ce9cbf2c6119ad4H
	DQ 03f13802111000000H, 03d4d03232a579871H
	DQ 03f13d02222000000H, 03d4d5c820ab96aa1H
	DQ 03f14302370000000H, 03d2ff6235a37497cH
	DQ 03f149024c3000000H, 03d4a4461e61bb95eH
	DQ 03f14f0261d000000H, 03d4431272c3ec2f0H
	DQ 03f15402742000000H, 03d424e2b9e3a8113H
	DQ 03f15a028a7000000H, 03d4a40baad7a3180H
	DQ 03f16002a13000000H, 03d33b2fef1b1988bH
	DQ 03f16602b85000000H, 03d01893f34559377H
	DQ 03f16c02cfc000000H, 03d4ffe120fb3ef44H
	DQ 03f17102e3b000000H, 03d120082c162d124H
	DQ 03f17702fbe000000H, 03d3e587c5b282967H
	DQ 03f17d03148000000H, 03d1df8f956673eacH
	DQ 03f183032d7000000H, 03d4ff8cd42de4f13H
	DQ 03f1880342a000000H, 03c83f84104915062H
	DQ 03f18e035c5000000H, 03d3484a765ad0e81H
	DQ 03f19403766000000H, 03d4c2a7e827b5b7cH
	DQ 03f19a0390e000000H, 03d45b9d9e619a5feH
	DQ 03f19f03a74000000H, 03d4389fde2d65d47H
	DQ 03f1a503c27000000H, 03d4b2175bb6d7bccH
	DQ 03f1ab03de1000000H, 03d34c0cf5c760a80H
	DQ 03f1b103fa1000000H, 03d046edae6d3e9a5H
	DQ 03f1b704166000000H, 03d4fd521af377bfcH
	DQ 03f1bc042e6000000H, 03d0cf59fe6ab1bfdH
	DQ 03f1c2044b7000000H, 03d3ccd20cc753db5H
	DQ 03f1c80468f000000H, 03d152df2a92669ccH
	DQ 03f1ce0486c000000H, 03d4e8cfdbe6ff5d7H
	DQ 03f1d3049ff000000H, 03d4e51b637245449H
	DQ 03f1d904be9000000H, 03d30855ccdda9dd0H
	DQ 03f1df04dd8000000H, 03d49dc0197d07430H
	DQ 03f1e504fce000000H, 03d431dc9bd27e20aH
	DQ 03f1ea05175000000H, 03d40ae402534fea4H
	DQ 03f1f005376000000H, 03d47fa77710aad2aH
	DQ 03f1f60557e000000H, 03d2bbdb4e113204bH
	DQ 03f1fc0578b000000H, 03d4d8d3b6e50d246H
	DQ 03f20102ccf800000H, 03d4bd3fc06a15de9H
	DQ 03f20382daf800000H, 03d4d93a1498ec6c9H
	DQ 03f20682ebf800000H, 03d33cb6df935a7f0H
	DQ 03f20982fd2000000H, 03d4de1089920cfdaH
	DQ 03f20c830e8000000H, 03d4985b012a6b1acH
	DQ 03f20f031d2000000H, 03d4913e1b9ba2290H
	DQ 03f212032ee000000H, 03d1624a57980edbcH
	DQ 03f2150340c800000H, 03d441ee709125ff3H
	DQ 03f2180352e800000H, 03d3a45e575f48b5dH
	DQ 03f21a83622800000H, 03d3501dd1e238a6cH
	DQ 03f21d8374a000000H, 03d4191bc1ea6aa2cH
	DQ 03f22083875000000H, 03ce323237921f7b0H
	DQ 03f223839a2800000H, 03d46b179d0781ff4H
	DQ 03f22683ad3800000H, 03d44c09dda134362H
	DQ 03f22903bd4000000H, 03d4652e31de50175H
	DQ 03f22c03d0b000000H, 03d137d77dcd68a32H
	DQ 03f22f03e44800000H, 03d4636fb2840cc02H
	DQ 03f23203f81800000H, 03d41a8e1979c27f4H
	DQ 03f2348408c000000H, 03d410dbf84163334H
	DQ 03f237841ce800000H, 03d4a8e042a7d4e75H
	DQ 03f23a84314800000H, 03d3772593772be29H
	DQ 03f23d8445d800000H, 03d223d4b2e8c031dH
	DQ 03f24004572000000H, 03d0c8072ca9dad06H
	DQ 03f243046c0800000H, 03d315a83ee313d33H
	DQ 03f24604812000000H, 03d473dc4088b7c68H
	DQ 03f24904967000000H, 03d3af34ea9dceae1H
	DQ 03f24c04abf000000H, 03d36c20ba0653485H
	DQ 03f24e84be0000000H, 03d39a63c847be3ffH
	DQ 03f25184d3d800000H, 03d48ca7750a55975H
	DQ 03f25484e9e800000H, 03d38db2a2d1381bbH
	DQ 03f25785002800000H, 03d2ef2461fbe7983H
	DQ 03f25a0512d800000H, 03d2c153bc40c395cH
	DQ 03f25d05297000000H, 03d4064fc5a39c232H
	DQ 03f26005404000000H, 03d070d1f7c4b597eH
	DQ 03f26305573800000H, 03d4a28e9bdbbc457H
	DQ 03f265856a8800000H, 03d474989ecc252f3H
	DQ 03f2688581e000000H, 03d4e13090fc01d57H
	DQ 03f26b85997000000H, 03d391227c8678403H
	DQ 03f26e85b13000000H, 03d155e22f244140dH
	DQ 0bf170fd210000000H, 0bd24caa429329aeeH
	DQ 0bf16dfd2ce000000H, 0bd4cb96d8562dc37H
	DQ 0bf16bfd34d000000H, 0bd2813e19b9dbfb8H
	DQ 0bf168fd409000000H, 0bd34c1a453011cc5H
	DQ 0bf165fd4c3000000H, 0bd4cd61ac43e09bcH
	DQ 0bf162fd57c000000H, 0bd4d64cef90ca8baH
	DQ 0bf15ffd634000000H, 0bd3819d713b1c267H
	DQ 0bf15cfd6ea000000H, 0bd319cda711db032H
	DQ 0bf159fd79e000000H, 0bd43a950c71a6171H
	DQ 0bf156fd851000000H, 0bd393b25eece00b9H
	DQ 0bf153fd902000000H, 0bd43ab308b5fe712H
	DQ 0bf151fd977000000H, 0bd4ca5e736256734H
	DQ 0bf14efda26000000H, 0bd40886b3b9c924dH
	DQ 0bf14bfdad3000000H, 0bd428441ff31aa38H
	DQ 0bf148fdb7f000000H, 0bd14cb421675c431H
	DQ 0bf145fdc29000000H, 0bcf8fb590baebb8dH
	DQ 0bf142fdcd1000000H, 0bd3a1f2ca38e93f3H
	DQ 0bf13ffdd78000000H, 0bd2dc25e83d52ed1H
	DQ 0bf13cfde1d000000H, 0bd3fd5b6efa081f3H
	DQ 0bf13afde8a000000H, 0bd49d89dd4f2bf07H
	DQ 0bf137fdf2d000000H, 0bd3e4f3d5d3a13b4H
	DQ 0bf134fdfce000000H, 0bd428fd96a5f7723H
	DQ 0bf131fe06e000000H, 0bd20452b288690a5H
	DQ 0bf12efe10c000000H, 0bd1d5f7c7e56ea2dH
	DQ 0bf12bfe1a8000000H, 0bd415fc47d421debH
	DQ 0bf128fe243000000H, 0bd3a598ca8dc214bH
	DQ 0bf125fe2dc000000H, 0bd4712f1d7350f14H
	DQ 0bf122fe374000000H, 0bd3e24878efa43e1H
	DQ 0bf120fe3d8000000H, 0bd48adffee23f9f0H
	DQ 0bf11dfe46d000000H, 0bd4d81e00aec2d96H
	DQ 0bf11afe501000000H, 0bd406eddef9956b1H
	DQ 0bf117fe593000000H, 0bd4174f65e105551H
	DQ 0bf114fe624000000H, 0bcf284c306b71311H
	DQ 0bf111fe6b2000000H, 0bd4dcc69dfedbec3H
	DQ 0bf10efe740000000H, 0bd323b7cee38aa4bH
	DQ 0bf10bfe7cc000000H, 0bd144104fd28c140H
	DQ 0bf108fe856000000H, 0bd34171a36d6a695H
	DQ 0bf106fe8b1000000H, 0bd4354a0acea06cdH
	DQ 0bf103fe939000000H, 0bd2eb1b1fae67526H
	DQ 0bf100fe9bf000000H, 0bd343a73fc467e03H
	DQ 0bf0fbfd486000000H, 0bd4aa705ed090ecaH
	DQ 0bf0f5fd58c000000H, 0bd4949cd0d4cde8eH
	DQ 0bf0effd690000000H, 0bd2816308340bd3dH
	DQ 0bf0e9fd790000000H, 0bcfb47fd2e8624a6H
	DQ 0bf0e3fd88c000000H, 0bd338fca5233867dH
	DQ 0bf0ddfd986000000H, 0bcf9cf14342e7c21H
	DQ 0bf0d9fda2a000000H, 0bd3388827d84b6e0H
	DQ 0bf0d3fdb1e000000H, 0bd3b3e0a6d6a2247H
	DQ 0bf0cdfdc0e000000H, 0bd4f92aec1df2a86H
	DQ 0bf0c7fdcfc000000H, 0bd4f9f3aa2200d30H
	DQ 0bf0c1fdde8000000H, 0bd3b894b32ad9b9fH
	DQ 0bf0bbfded0000000H, 0bd3405d8d2c46051H
	DQ 0bf0b5fdfb4000000H, 0bd445a0bd420a715H
	DQ 0bf0affe096000000H, 0bd39940136e0a90fH
	DQ 0bf0abfe12a000000H, 0bd46b0a6f2af86bbH
	DQ 0bf0a5fe206000000H, 0bd4bf4a2ca335408H
	DQ 0bf09ffe2e0000000H, 0bd3ea2d6b12e4d93H
	DQ 0bf099fe3b6000000H, 0bd40c6fd5fb7f840H
	DQ 0bf093fe48a000000H, 0bce555685c9c3116H
	DQ 0bf08dfe558000000H, 0bd4dfc70dfa2e7c3H
	DQ 0bf087fe626000000H, 0bd337897b84ac785H
	DQ 0bf081fe6f0000000H, 0bd1ca71ac6acd2d7H
	DQ 0bf07bfe7b6000000H, 0bd370c682f1de078H
	DQ 0bf077fe838000000H, 0bd45185d76c79d4cH
	DQ 0bf071fe8fa000000H, 0bd33bb0cdd985699H
	DQ 0bf06bfe9b8000000H, 0bd3976c00642b301H
	DQ 0bf065fea72000000H, 0bd4db1e6f5a163e7H
	DQ 0bf05ffeb2a000000H, 0bd4cc11808263596H
	DQ 0bf059febe0000000H, 0bd33d1dff912d171H
	DQ 0bf053fec92000000H, 0bd24a5ae52911a3aH
	DQ 0bf04dfed40000000H, 0bd3d050f249f8edcH
	DQ 0bf047fedec000000H, 0bd27d102dd924b0eH
	DQ 0bf043fee5c000000H, 0bd3e62957baad081H
	DQ 0bf03dfef02000000H, 0bd4376ad4524f2a0H
	DQ 0bf037fefa6000000H, 0bd2752913877e949H
	DQ 0bf031ff046000000H, 0bd292cb26a5ff847H
	DQ 0bf02bff0e2000000H, 0bd44da42ec6a2baeH
	DQ 0bf025ff17c000000H, 0bd4181e4056b600bH
	DQ 0bf01fff212000000H, 0bd4c420ca7722725H
	DQ 0bf019ff2a6000000H, 0bd451ab99454bc09H
	DQ 0bf015ff306000000H, 0bd4f4702fac61211H
	DQ 0bf00fff396000000H, 0bd23ccbf691e23e3H
	DQ 0bf009ff420000000H, 0bd48b7d85ede8a3bH
	DQ 0bf003ff4a8000000H, 0bd4a94f94a602836H
	DQ 0beffbfea5c000000H, 0bd35151ebd4248b6H
	DQ 0befeffeb60000000H, 0bd31312ebaebde60H
	DQ 0befe3fec5c000000H, 0bd44bf0e08b2a851H
	DQ 0befd7fed54000000H, 0bd3dfbe044563cddH
	DQ 0befcbfee44000000H, 0bd47553a6bb2cf4dH
	DQ 0befc3feee4000000H, 0bd02b3272c9e1514H
	DQ 0befb7fefc8000000H, 0bd4655cdd79568b8H
	DQ 0befabff0a8000000H, 0bd4998c8c6a29955H
	DQ 0bef9fff184000000H, 0bd35e84003879074H
	DQ 0bef93ff258000000H, 0bd34cfa09595f318H
	DQ 0bef87ff324000000H, 0bd47f3d66389e086H
	DQ 0bef7bff3ec000000H, 0bd43982f0dd1df79H
	DQ 0bef6fff4ac000000H, 0bd4d54d70b7407c7H
	DQ 0bef63ff568000000H, 0bd4529cb1e4119e9H
	DQ 0bef5bff5e0000000H, 0bd4ea8cf63b0e57aH
	DQ 0bef4fff694000000H, 0bd1a872dd1f9867bH
	DQ 0bef43ff73c000000H, 0bd46113f80238647H
	DQ 0bef37ff7e0000000H, 0bd46e9d9772d7da6H
	DQ 0bef2bff880000000H, 0bd276ac184b1770cH
	DQ 0bef1fff918000000H, 0bd171e07ff78e451H
	DQ 0bef13ff9a8000000H, 0bd3c0a102a88bdf6H
	DQ 0bef07ffa34000000H, 0bd2cfa098be9e4a8H
	DQ 0beef7ff570000000H, 0bd3d205955bedc7eH
	DQ 0beee7ff618000000H, 0bd47b79acbd1c3d4H
	DQ 0beecfff710000000H, 0bd37b870ff9b8582H
	DQ 0beeb7ff7f8000000H, 0bd3c31fb1038dd6dH
	DQ 0bee9fff8d0000000H, 0bd4e6de6a68aa227H
	DQ 0bee87ff9a0000000H, 0bd4cdaf09ce4e699H
	DQ 0bee6fffa68000000H, 0bd32c03059eee94bH
	DQ 0bee57ffb20000000H, 0bd1fead0c4719fccH
	DQ 0bee3fffbc8000000H, 0bd39656642e976adH
	DQ 0bee2fffc30000000H, 0bd46c7329db21925H
	DQ 0bee17ffcc8000000H, 0bd389eab4517a5ceH
	DQ 0bedffffaa0000000H, 0bd3fdf0e3da560d7H
	DQ 0bedcfffba0000000H, 0bd0a7c3d4511fbcbH
	DQ 0bed9fffc80000000H, 0bd0780884d13df75H
	DQ 0bed6fffd40000000H, 0bd3ec0a3e439ae99H
	DQ 0bed3fffdf0000000H, 0bd36c139bbface01H
	DQ 0bed0fffe80000000H, 0bd4578e60a3c176bH
	DQ 0becbfffe00000000H, 0bd3b5254714383f2H
	DQ 0bec7fffe80000000H, 0bd4764e185e2f8bbH
	DQ 0bec1ffff20000000H, 0bd4c67c0d84712a6H
	DQ 0beb7ffff40000000H, 0bd3f05250dd0685fH
	DQ 0bea7ffff80000000H, 0bd40b553538e0e0cH
	DQ 0, 0


;   log2 polynomial coefficients
clv     DQ 03fc47fd462b3b816H, 03e79c3a6966457eeH	; c1|c3
	DQ 0bfb550472a8bb463H, 0bfd62e4346694107H	; c2|c4


;-------Table T, D  so that movapd gives [ D | T ]
;-------Note that the exponent field of T is set to 000  (instead of 3ffH)
exp2_tbl DQ 03ff0000000000000H, 00000000000000000H
	 DQ 03ff0163da9fb3335H, 03c9b61299ab8cdb7H
	 DQ 03ff02c9a3e778061H, 0bc719083535b085dH
	 DQ 03ff04315e86e7f85H, 0bc90a31c1977c96eH
	 DQ 03ff059b0d3158574H, 03c8d73e2a475b465H
	 DQ 03ff0706b29ddf6deH, 0bc8c91dfe2b13c26H
	 DQ 03ff0874518759bc8H, 03c6186be4bb284ffH
	 DQ 03ff09e3ecac6f383H, 03c91487818316135H
	 DQ 03ff0b5586cf9890fH, 03c98a62e4adc610aH
	 DQ 03ff0cc922b7247f7H, 03c901edc16e24f71H
	 DQ 03ff0e3ec32d3d1a2H, 03c403a1727c57b52H
	 DQ 03ff0fb66affed31bH, 0bc6b9bedc44ebd7bH
	 DQ 03ff11301d0125b51H, 0bc96c51039449b39H
	 DQ 03ff12abdc06c31ccH, 0bc51b514b36ca5c7H
	 DQ 03ff1429aaea92de0H, 0bc932fbf9af1369eH
	 DQ 03ff15a98c8a58e51H, 03c82406ab9eeab09H
	 DQ 03ff172b83c7d517bH, 0bc819041b9d78a75H
	 DQ 03ff18af9388c8deaH, 0bc911023d1970f6bH
	 DQ 03ff1a35beb6fcb75H, 03c8e5b4c7b4968e4H
	 DQ 03ff1bbe084045cd4H, 0bc995386352ef607H
	 DQ 03ff1d4873168b9aaH, 03c9e016e00a2643cH
	 DQ 03ff1ed5022fcd91dH, 0bc91df98027bb78bH
	 DQ 03ff2063b88628cd6H, 03c8dc775814a8494H
	 DQ 03ff21f49917ddc96H, 03c82a97e9494a5edH
	 DQ 03ff2387a6e756238H, 03c99b07eb6c70572H
	 DQ 03ff251ce4fb2a63fH, 03c8ac155bef4f4a4H
	 DQ 03ff26b4565e27cddH, 03c82bd339940e9d9H
	 DQ 03ff284dfe1f56381H, 0bc9a4c3a8c3f0d7dH
	 DQ 03ff29e9df51fdee1H, 03c8612e8afad1255H
	 DQ 03ff2b87fd0dad990H, 0bc410adcd6381aa3H
	 DQ 03ff2d285a6e4030bH, 03c90024754db41d4H
	 DQ 03ff2ecafa93e2f56H, 03c71ca0f45d52383H
	 DQ 03ff306fe0a31b715H, 03c86f46ad23182e4H
	 DQ 03ff32170fc4cd831H, 03c8a9ce78e18047cH
	 DQ 03ff33c08b26416ffH, 03c932721843659a5H
	 DQ 03ff356c55f929ff1H, 0bc8b5cee5c4e4628H
	 DQ 03ff371a7373aa9cbH, 0bc963aeabf42eae1H
	 DQ 03ff38cae6d05d866H, 0bc9e958d3c9904bcH
	 DQ 03ff3a7db34e59ff7H, 0bc75e436d661f5e2H
	 DQ 03ff3c32dc313a8e5H, 0bc9efff8375d29c3H
	 DQ 03ff3dea64c123422H, 03c8ada0911f09ebbH
	 DQ 03ff3fa4504ac801cH, 0bc97d023f956f9f3H
	 DQ 03ff4160a21f72e2aH, 0bc5ef3691c309278H
	 DQ 03ff431f5d950a897H, 0bc81c7dde35f7998H
	 DQ 03ff44e086061892dH, 03c489b7a04ef80cfH
	 DQ 03ff46a41ed1d0057H, 03c9c944bd1648a76H
	 DQ 03ff486a2b5c13cd0H, 03c73c1a3b69062f0H
	 DQ 03ff4a32af0d7d3deH, 03c99cb62f3d1be56H
	 DQ 03ff4bfdad5362a27H, 03c7d4397afec42e2H
	 DQ 03ff4dcb299fddd0dH, 03c98ecdbbc6a7833H
	 DQ 03ff4f9b2769d2ca7H, 0bc94b309d25957e3H
	 DQ 03ff516daa2cf6642H, 0bc8f768569bd93eeH
	 DQ 03ff5342b569d4f82H, 0bc807abe1db13cacH
	 DQ 03ff551a4ca5d920fH, 0bc8d689cefede59aH
	 DQ 03ff56f4736b527daH, 03c99bb2c011d93acH
	 DQ 03ff58d12d497c7fdH, 03c8295e15b9a1de7H
	 DQ 03ff5ab07dd485429H, 03c96324c054647acH
	 DQ 03ff5c9268a5946b7H, 03c3c4b1b816986a2H
	 DQ 03ff5e76f15ad2148H, 03c9ba6f93080e65dH
	 DQ 03ff605e1b976dc09H, 0bc93e2429b56de47H
	 DQ 03ff6247eb03a5585H, 0bc9383c17e40b496H
	 DQ 03ff6434634ccc320H, 0bc8c483c759d8932H
	 DQ 03ff6623882552225H, 0bc9bb60987591c33H
	 DQ 03ff68155d44ca973H, 03c6038ae44f73e64H
	 DQ 03ff6a09e667f3bcdH, 0bc9bdd3413b26455H
	 DQ 03ff6c012750bdabfH, 0bc72895667ff0b0cH
	 DQ 03ff6dfb23c651a2fH, 0bc6bbe3a683c88aaH
	 DQ 03ff6ff7df9519484H, 0bc883c0f25860ef6H
	 DQ 03ff71f75e8ec5f74H, 0bc816e4786887a99H
	 DQ 03ff73f9a48a58174H, 0bc90a8d96c65d53bH
	 DQ 03ff75feb564267c9H, 0bc90245957316dd3H
	 DQ 03ff780694fde5d3fH, 03c9866b80a02162cH
	 DQ 03ff7a11473eb0187H, 0bc841577ee04992fH
	 DQ 03ff7c1ed0130c132H, 03c9f124cd1164dd5H
	 DQ 03ff7e2f336cf4e62H, 03c705d02ba15797eH
	 DQ 03ff80427543e1a12H, 0bc927c86626d972aH
	 DQ 03ff82589994cce13H, 0bc9d4c1dd41532d7H
	 DQ 03ff8471a4623c7adH, 0bc88d684a341cdfbH
	 DQ 03ff868d99b4492edH, 0bc9fc6f89bd4f6baH
	 DQ 03ff88ac7d98a6699H, 03c9994c2f37cb53aH
	 DQ 03ff8ace5422aa0dbH, 03c96e9f156864b26H
	 DQ 03ff8cf3216b5448cH, 0bc70d55e32e9e3aaH
	 DQ 03ff8f1ae99157736H, 03c85cc13a2e3976cH
	 DQ 03ff9145b0b91ffc6H, 0bc9dd6792e582523H
	 DQ 03ff93737b0cdc5e5H, 0bc675fc781b57ebbH
	 DQ 03ff95a44cbc8520fH, 0bc764b7c96a5f039H
	 DQ 03ff97d829fde4e50H, 0bc9d185b7c1b85d0H
	 DQ 03ff9a0f170ca07baH, 0bc9173bd91cee632H
	 DQ 03ff9c49182a3f090H, 03c7c7c46b071f2beH
	 DQ 03ff9e86319e32323H, 03c7824ca78e64c6eH
	 DQ 03ffa0c667b5de565H, 0bc9359495d1cd532H
	 DQ 03ffa309bec4a2d33H, 03c96305c7ddc36abH
	 DQ 03ffa5503b23e255dH, 0bc9d2f6edb8d41e1H
	 DQ 03ffa799e1330b358H, 03c9bcb7ecac563c6H
	 DQ 03ffa9e6b5579fdbfH, 03c90fac90ef7fd31H
	 DQ 03ffac36bbfd3f37aH, 0bc8f9234cae76cd0H
	 DQ 03ffae89f995ad3adH, 03c97a1cd345dcc81H
	 DQ 03ffb0e07298db666H, 0bc9bdef54c80e424H
	 DQ 03ffb33a2b84f15fbH, 0bc62805e3084d707H
	 DQ 03ffb59728de5593aH, 0bc9c71dfbbba6de3H
	 DQ 03ffb7f76f2fb5e47H, 0bc75584f7e54ac3aH
	 DQ 03ffba5b030a1064aH, 0bc9efcd30e54292eH
	 DQ 03ffbcc1e904bc1d2H, 03c823dd07a2d9e84H
	 DQ 03ffbf2c25bd71e09H, 0bc9efdca3f6b9c72H
	 DQ 03ffc199bdd85529cH, 03c811065895048ddH
	 DQ 03ffc40ab5fffd07aH, 03c9b4537e083c60aH
	 DQ 03ffc67f12e57d14bH, 03c92884dff483cacH
	 DQ 03ffc8f6d9406e7b5H, 03c71acbc48805c44H
	 DQ 03ffcb720dcef9069H, 03c7503cbd1e949dbH
	 DQ 03ffcdf0b555dc3faH, 0bc8dd83b53829d72H
	 DQ 03ffd072d4a07897cH, 0bc9cbc3743797a9cH
	 DQ 03ffd2f87080d89f2H, 0bc9d487b719d8577H
	 DQ 03ffd5818dcfba487H, 03c82ed02d75b3706H
	 DQ 03ffd80e316c98398H, 0bc911ec18beddfe8H
	 DQ 03ffda9e603db3285H, 03c9c2300696db532H
	 DQ 03ffdd321f301b460H, 03c92da5778f018c2H
	 DQ 03ffdfc97337b9b5fH, 0bc91a5cd4f184b5bH
	 DQ 03ffe264614f5a129H, 0bc97b627817a1496H
	 DQ 03ffe502ee78b3ff6H, 03c839e8980a9cc8fH
	 DQ 03ffe7a51fbc74c83H, 03c92d522ca0c8de1H
	 DQ 03ffea4afa2a490daH, 0bc9e9c23179c2893H
	 DQ 03ffecf482d8e67f1H, 0bc9c93f3b411ad8cH
	 DQ 03ffefa1bee615a27H, 03c9dc7f486a4b6b0H
	 DQ 03fff252b376bba97H, 03c93a1a5bf0d8e43H
	 DQ 03fff50765b6e4540H, 03c99d3e12dd8a18aH
	 DQ 03fff7bfdad9cbe14H, 0bc9dbb12d0063509H
	 DQ 03fffa7c1819e90d8H, 03c874853f3a5931eH
	 DQ 03fffd3c22b8f71f1H, 03c62eb74966579e7H
	

Shifter  DQ 04338000000000000H, 04338000000000000H	; 2^52+2^51|2^52+2^51
SIGMASK  DQ 0000fffffffffffffH, 0000fffffffffffffH
ONEMASK  DQ 03ff0000000000000H, 03ff0000000000000H
ABSVALMASK DQ 7fffffffffffffffH, 7fffffffffffffffH

	; exponential polynomial coefficients
cev     DQ 03f55d87fe78a6731H, 03fac6b08d704a0bfH  ; c3|c5
	DQ 03f83b2ab6fba4e77H, 03fcebfbdff82c58eH  ; c2|c4
	DQ 03fe62e42fefa39efH  ; c1




HALFSIG  DQ 0fffffffff8000000H
LHN      DQ 0bff7154740000000H   ; -log2(e) rounded to 27 bits
sNaN     DQ 07ff0000000000001H
INF      DQ 07ff0000000000000H
NEG_INF  DQ 0fff0000000000000H
NEG_ZERO DQ 08000000000000000H
EMIN     DQ 00010000000000000H
QIND     DQ 0fff8000000000000H	; QNAN indefinite

    ALIGN 16
CONST ENDS


$movsd MACRO op1, op2
LOCAL begin_movsd, end_movsd
begin_movsd:
movupd op1, op2
end_movsd:
org begin_movsd
db 0F2h
org end_movsd
ENDM



_TEXT SEGMENT PARA PUBLIC USE32 'CODE'
    ALIGN 16

PUBLIC _pow_pentium4, _CIpow_pentium4 
_CIpow_pentium4 PROC NEAR
	push   ebp
	mov    ebp,esp
        sub     esp,16               ; prepare place for argument
        and     esp,0fffffff0h
        fxch    st(1)
        fstp    qword ptr [esp]               ; base
        fstp    qword ptr [esp+8]             ; exponent
        call    _pow_pentium4
	leave
        ret
_pow_pentium4   label proc
   ; load first argument
   movlpd xmm0, QWORD PTR [esp+4]
   ; load constants
   movlpd xmm7, QWORD PTR [SIGMASK]
   movlpd xmm2, QWORD PTR [ONEMASK]

   andpd xmm7, xmm0 
   $movsd xmm4, xmm0
   psrlq xmm0, 64-12-8
   ; get first 7 bits after leading 1
   pextrw eax, xmm0, 0
   ; xmm7=first argument, with exponent set to 0+bias
   orpd xmm7, xmm2
   ; extract sign/exponent + next 4 bits
   pextrw ecx, xmm4, 3

   and eax, 0ffH
   add eax, 1
   and eax, 1feH
   ; get r1=x*rcp_t1
   mulsd  xmm7, QWORD PTR [rcp_t1+eax*4]
   ; load first reciprocal value (based on first 7 bits)
   movlpd xmm5, QWORD PTR [rcp_t1+eax*4]
   add eax, eax
   ; load first log2_table values (high, low) in xmm6
   movapd xmm6, QWORD PTR [log2_t1+eax*4]

   ; check sign/exponent of x
   mov edx, 7fefH
   ; x infinity/NaN or negative ?
   sub edx, ecx
   ; x denormal ?
   sub ecx, 0010H
   or ecx, edx
   cmp ecx, 80000000H
   jae SPECIAL_X

   mov ecx, 0
   ; set xmm1=2^8*(bias-0.5-2^{-8})
   mov edx, 3fe7fH
BACK_MAIN:
BACK_DENORMAL:
   movd xmm1, edx
   ; get k (exponent) + j (j=0 if mantissa<1.5, 1 otherwise)
   psubq xmm0, xmm1
   psrlq xmm0, 8
   ; convert to DP format
   cvtdq2pd xmm0, xmm0
   
   ; xmm1=mask for splitting argments in high/low parts
   movlpd xmm1, QWORD PTR [HALFSIG]

   ; copy r1 to xmm3, set exponent to 0+bias
   $movsd xmm3, xmm7 ;andpd xmm3, xmm7
   ; extract bits 7..14
   psrlq xmm7, 64-12-14
   pextrw eax, xmm7, 0

   ; set exponent of argument to 0+bias
   andpd xmm4, QWORD PTR [SIGMASK]

   and eax, 0ffH
   add eax, 1
   and eax, 1feH
   ; load second reciprocal value (based on 7 bit index)
   ; get r2=x*rcp_t1*rcp_t2
   mulsd xmm3, QWORD PTR [rcp_t2+eax*4]
   ; rcp_t1*rcp_t2 (exact multiplication)
   mulsd xmm5, QWORD PTR [rcp_t2+eax*4]
   add eax, eax
   ; load next log2_table values (high, low) to xmm6
   addpd xmm6, QWORD PTR [log2_t2+eax*4]
  
   orpd  xmm4, QWORD PTR [ONEMASK]
   ; add k
   addsd xmm6, xmm0
   ; get xH = high part of x
   andpd xmm1, xmm4

   ; copy r2 to xmm2
   $movsd xmm2, xmm3
   ; extract bits 13...21
   psrlq xmm3, 64-12-21
   pextrw eax, xmm3, 0

   ; xmm0 = mask for splitting term in high/low parts
   movlpd xmm0, QWORD PTR [HALFSIG]
   ; get xL = low part of x
   subsd xmm4, xmm1
   ; xmm7=-log2(e) in double precision (scaling factor for reduced argument)
   movlpd xmm7, QWORD PTR [LHN]

   and eax, 1ffH
   add eax, 1
   and eax, 3feH
   ; load third reciprocal value (based on 8 bit index)
   ; get rcp_t1*rcp_t2*rcp_t3 (exact multiplication)
   mulsd xmm5, QWORD PTR [rcp_t3+eax*4]
   ; get r3=x*rcp_t1*rcp_t2*rcp_t3
   mulsd xmm2, QWORD PTR [rcp_t3+eax*4]
   ; load next log2_table values (high, low) to xmm6
   addpd xmm6, QWORD PTR [log2_t3+eax*8] 


   ; xmm0=rcp_H
   andpd xmm0, xmm5
   ; xmm5=rcp_L
   subsd xmm5, xmm0
   ; reduced argument 
   addsd xmm7, xmm2

   ; copy rcp_H
   $movsd xmm3, xmm0
   ; rcp_H*xH
   mulsd xmm0, xmm1
   ; xH*rcp_L
   mulsd xmm1, xmm5
   ; rcp_H*xL
   mulsd xmm3, xmm4

   ; calculate rounding error for reduced argument: R-rcp_H*xH
   subsd xmm2, xmm0
   ; rcp_L*xL
   mulsd xmm4, xmm5
   ; copy xmm6=D1+D2+D3|k+T1+T2+T3
   $movsd xmm0, xmm6
   ; R-rcp_H*xH-rcp_L*xH
   subsd xmm2, xmm1
   ; add reduced argument to high order term: xmm6=D1+D2+D3|k+T1+T2+T3+Rh
   addsd xmm6, xmm7
  
   ; load y
   movlpd xmm1, QWORD PTR [esp+12]
   ; get sign/exponent
   pextrw eax, xmm1, 3

   ; R-rcp_H*xH-rcp_L*xH-rcp_H*xL
   subsd xmm2, xmm3
   ; get -Rh
   subsd xmm0, xmm6
   ; xmm3=HALFSIG mask
   movlpd xmm3, QWORD PTR [HALFSIG]

   ; get exponent for log2(x)
   pextrw edx, xmm6, 3

   ; E=R-rcp_H*xH-rcp_L*xH-rcp_H*xL-rcp_L*xL
   subsd xmm2, xmm4
 ; xmm4=k+T1+T2+T3+Rh
 $movsd xmm4, xmm6
   ; get Rl=R-Rh
   addsd xmm0, xmm7
   ; R=R-E
   subsd xmm7, xmm2
 ; xmm6=D1+D2+D3|k+T1+T2+T3+Rh+Eh
 subsd xmm6, xmm2
   ; xmm7=R|R
   unpcklpd xmm7, xmm7

   ; check if y is infinity/NaN
   and eax, 7ff0H
   cmp eax, 7ff0H
   jae SPECIAL_Y
   and edx, 7ff0H
   sub eax, 3ff0H
   add eax, edx
   ; y*log2(x)>=2^{11} ? (i.e. 2^{11}-eps-x<0)
   mov edx, 40a0H
   sub edx, eax
   ; avoid underflow on intermediate calculations (|y*log2(x)|<2^{-56} ?)
   sub eax, 3c70H
   or edx, eax
   cmp edx, 80000000H
   ; small input or UF/OF
   jae RETURN_ONE

BACK_XY_CHECK:
 ; -Eh
 subsd xmm4, xmm6
 ; -El
 subsd xmm2, xmm4
   ; xmm4=HALFSIG mask
   movlpd xmm4, QWORD PTR [HALFSIG]
   ; yH
   andpd xmm3, xmm1
   ; HH (high part of k+T1+T2+T3+Rh+Eh)
   andpd xmm4, xmm6

   ; add correction to reduced argument: Rl+El
   subsd xmm0, xmm2

   xorpd xmm2, xmm2
   mov edx, 4060H ;70H
   pinsrw xmm2, edx, 3

   ; copy yH
   $movsd xmm5, xmm3 
   ; yH*HH
   mulsd xmm3, xmm4
   ; HL
   subsd xmm6, xmm4
   ; yL
   subsd xmm1, xmm5
	
   ; get 2^7*(yH*HH)
   mulsd xmm3, xmm2  ;paddd xmm3, xmm2

   ; yH*HL
   mulsd xmm5, xmm6
   ; xmm2=cl1|cl3
   movapd xmm2, QWORD PTR [clv]
   ; HH*yL
   mulsd xmm4, xmm1

   ; get int(2^7*H)
   cvtsd2si eax, xmm3
   ; HL*yL
   mulsd xmm6, xmm1
   ; xmm1=cl2|cl4
   movapd xmm1, QWORD PTR [clv+16]

   ; yH*HL+yL*HH
   addsd xmm5, xmm4
   ; get D1+D2+D3
   pshufd xmm4, xmm6, 0eeH
   ; yH*HL+yL*HH+yL*HL
   addsd xmm5, xmm6

   ; underflow/possible overflow condition ?
   mov edx, 1ff7fH
   ; eax>=(2^10-1)*2^7
   sub edx, eax
   ; eax+bias*2^7<=59*2^7 ?
   add eax, 1e1ffH
   or edx, eax
   ; restore eax value
   sub eax, 1e1ffH
   ; check sign bit
   cmp edx, 0
   jle UF_OF_CASES


   ; get table index, and exponent of result
   ; ecx contains expected sign of the result, scaled by 2^11
   add ecx, eax
   and eax, 7fH
   ; get exponent of result (scaled by 2^7)
   and ecx, 0ffffff80h
   ; add exponent bias*2^7
   add ecx, 1ff80h

   ; D1+D2+D3+(Rl+El)
   addsd xmm4, xmm0
   ; xmm0=xmm3=2^7*H
   $movsd xmm0, xmm3
   
   ; (2^7)*H+Shifter (to round to integer)
   addsd xmm3, QWORD PTR [Shifter]


   ; cl1*R|cl3*R
   mulpd xmm2, xmm7

   ; int((2^7)*H)=((2^7)*H+Shifter)-Shifter
   subsd xmm3, QWORD PTR [Shifter]

   ; R^2|R^2
   mulpd xmm7, xmm7

   ; R_exp_h'=R_exp_h*(2^7)=(2^7)*H-int((2^7)*H)
   subsd xmm0, xmm3

   ; load table values
   add eax, eax
   add eax, eax
   add eax, eax
   add eax, eax
   ; D|T
   movapd xmm3, QWORD PTR [exp2_tbl+eax] 

   ; load ce3|ce5
   movapd xmm6, QWORD PTR [cev]


   ; cl2*R^2|cl4*R^2
   mulpd xmm1, xmm7
   ; cl1*R+cl2*R^2|cl3*R+cl4*R^2
   addpd xmm2, xmm1
   ; unpack cl1*R+cl2*R^2
   pshufd xmm1, xmm2, 0eeh
   ; *|cl3*R^3+cl4*R^4
   mulsd xmm2, xmm7
   ; xmm7=0
   xorpd xmm7, xmm7
   mov edx, 3f80H
   ; Pl14
   addsd xmm2, xmm1
   ; xmm7=scaling constant 
   pinsrw xmm7, edx, 3 
   ; low part of log2(x): D1+D2+D3+(Rl+E)+P14
   addsd xmm2, xmm4

   ; load ce1
   movlpd xmm4, QWORD PTR [cev+32]
   ; load 2^k 
   movd xmm1, ecx

UF_BACK:
   ; y*(D1+D2+D3+(Rl+E)+P14)
   mulsd xmm2, QWORD PTR [esp+12]
   ; get R_exp_h=2^{-7}*R_exp_h'
   mulsd xmm0, xmm7

   psllq xmm1, 52-7
   ; xmm1=2^k|2^k
   pshufd xmm1, xmm1, 044h

   ; load ce2|ce4
   movapd xmm7, QWORD PTR [cev+16]
   ; low part of y*log2(x): yH*HL+yL*HH+yL*HL+y*(D1+D2+D3+(Rl+E)+P14)
   addsd xmm5, xmm2

   ; get D*2^k|T*2^k
   mulpd xmm3, xmm1
   ; get R_exp=R_exp_h+yH*HL+yL*HH+yL*HL+y*(D1+D2+D3+(Rl+E)+P14)
   addsd xmm0, xmm5
   ; xmm0=R_exp|R_exp
   unpcklpd xmm0, xmm0

   ; ce3*R_exp|ce5*R_exp
   mulpd xmm6, xmm0
   ; ce1*R_exp
   mulsd xmm4, xmm0  
   ; R_exp^2|R_exp^2
   mulpd xmm0, xmm0
   ; ce2+ce3*R_exp|ce4+ce5*R_exp
   addpd xmm7, xmm6
   ; R_exp^2*(ce2+ce3*R_exp)|R_exp^2*(ce4+ce5*R_exp)
   mulpd xmm7, xmm0
   ; R_exp^2*(T*2^k)
   mulsd xmm0, xmm3
   ; unpack R_exp^2*(ce2+ce3*R_exp)
   pshufd xmm6, xmm7, 0eeh
   ; R_exp^4*(T*2^k)*(ce4+ce5*R_exp)
   mulsd xmm0, xmm7
   ; unpack D*2^k
   pshufd xmm5, xmm3, 0eeh
   ; R_exp^2*(T*2^k)*(ce2+ce3*R_exp)
   mulsd xmm6, xmm3
   ; ce1*(T*2^k)*R_exp
   mulsd xmm4, xmm3  

   ; P45*(T*2^k)+D*2^k  
   addsd xmm0, xmm5 
sub esp, 16
   ; P25*(T*2^k)+D*2^k
   addsd xmm0, xmm6
   ; P15*(T*2^k)+D*2^k
   addsd xmm0, xmm4

   ; T+P15*(T*2^k)+D*2^k
   addsd xmm0, xmm3

	movlpd    QWORD PTR [esp+4], xmm0       ; return result
	fld       QWORD PTR [esp+4]             ;
add esp, 16
	ret



SPECIAL_X:
   ; load y
   movlpd xmm1, QWORD PTR [esp+12]
   movlpd xmm3, QWORD PTR [ABSVALMASK]
   ; load low half of y in eax
   movd eax, xmm1
   $movsd xmm2, xmm1
   ; eliminate sign, load high half of y in ecx
   andpd xmm1, xmm3
   psrlq xmm1, 32
   movd ecx, xmm1
   ; y infinity/NaN ?
   cmp ecx, 7ff00000H
   jae Y_INF_NAN_CHECK_X
   ; y=+/- 0?
   or eax, ecx
   cmp eax, 0
   jz Y_ZERO

   ; denormal, positive x ? 
   cmp edx, 0
   jge DENORMAL_POS_X
   ; reconstruct sign/expon from edx=7fefH-s/exp
   neg edx
   add edx, 7fefH

   ; y integer ?
   ; xmm3=0fff00..0
   psllq xmm3,64-12
   ; set exponent of y to all 1's
   orpd xmm2, xmm3
   ; load bias-12
   mov ecx, 3ffH-12
   movd xmm3, ecx
   ; get exponent+64-52
   psrlq xmm1, 32-12
   psubd xmm1, xmm3
   ; xmm3=0
   pxor xmm3, xmm3
   ; if exponent+12<0, set shift count to 0
   pmaxsw xmm1, xmm3
   ; get fractional tail of y
   psllq xmm2, xmm1
   ; fractional tail=0 ? (i.e. y integer ?)
   pcmpeqd xmm2, xmm3
   pmovmskb eax, xmm2    

   ; take absolute value of x
   mov ecx, edx
   and edx, 7fffH
   ; check if x infinity/NaN
   cmp edx, 7ff0H
   jae INF_NAN_X

   ; x negative, finite
   ; y not integer ?
   and eax, 0ffH
   cmp eax, 0ffH
   jnz RET_INVALID

   ; y integer
   ; y odd integer ?
   movlpd xmm1, QWORD PTR [esp+12]
   movlpd xmm2, QWORD PTR [esp+12]
   ; load bias-11
   mov ecx, 3ffH-11
   movd xmm3, ecx
   ; get exponent+64-53
   andpd xmm1, QWORD PTR [ABSVALMASK]
   psrlq xmm1, 64-12
   psubd xmm1, xmm3
   ; xmm3=100..0
   movlpd xmm3, QWORD PTR [NEG_ZERO]
   ; get last integer bit, fractional tail of y
   psllq xmm2, xmm1
   ; last int. bit=0 ? (i.e. y is an odd integer ?)
   pcmpeqd xmm2, xmm3
   pmovmskb eax, xmm2
   and eax, 0ffH
   ; if eax!=ffH, set ecx=2^11, else set ecx=0
   mov ecx, 3ff01H
   ; set ecx=2^11*2^7 if y is an odd integer
   add ecx, eax
   and ecx, 40000H

   ; x denormal ?
   cmp edx, 0010H
   jb DENORMAL_X

   ; set xmm1=2^8*(bias-0.5-2^{-8})
   mov edx, 0bfe7fH

   ; load constants, return to main path
   movlpd xmm3, QWORD PTR [SIGMASK]
   movlpd xmm2, QWORD PTR [ONEMASK]
      
   jmp BACK_MAIN

Y_INF_NAN_CHECK_X:
   ; x NaN?
   movlpd xmm7, QWORD PTR [esp+4]
   movlpd xmm4, QWORD PTR [esp+4]
   movd edx, xmm7
   psrlq xmm7, 32
   movd eax, xmm7

   mov ecx, eax
   and eax, 7fffffffH
   cmp eax, 7ff00000H
   jb Y_INF_NAN
   ja X_NAN

   cmp edx, 0
   ja X_NAN
   jmp Y_INF_NAN

DENORMAL_POS_X:
   mov ecx, 0
DENORMAL_X:
   ; xmm0=2^64
   xorpd xmm0, xmm0
   mov eax, (3ffH+64)*16
   pinsrw xmm0, eax, 3 
   ; load constants
   movlpd xmm7, QWORD PTR [SIGMASK]
   movlpd xmm2, QWORD PTR [ONEMASK]

   ; scale x by 2^64
   mulsd xmm0, xmm4

   ; x=+/-0 ?
   movd edx, xmm4
   psrlq xmm4, 32
   movd eax, xmm4
   cmp edx, 0
   jz ZERO_X

BACK_DEN:
   andpd xmm7, xmm0 
   $movsd xmm4, xmm0
   andpd xmm0, QWORD PTR [ABSVALMASK]
   psrlq xmm0, 64-12-8
   ; get first 7 bits after leading 1
   pextrw eax, xmm0, 0
   orpd xmm7, xmm2

   and eax, 0ffH
   add eax, 1
   and eax, 1feH
   ; get r1=x*rcp_t1
   mulsd  xmm7, QWORD PTR [rcp_t1+eax*4]
   ; load first reciprocal value (based on first 7 bits)
   movlpd xmm5, QWORD PTR [rcp_t1+eax*4]
   add eax, eax
   ; load first log2_table values (high, low) in xmm6
   movapd xmm6, QWORD PTR [log2_t1+eax*4]

   ; 2^8*(bias+64-0.5-2^{-8})
   mov edx, 43e7fH 
   jmp BACK_DENORMAL

ZERO_X:
   mov edx, eax
   and edx, 7fffffffH
   cmp edx, 0
   jnz BACK_DEN

   ; get sign of y
   mov edx, DWORD PTR [esp+16]
   and edx, 80000000H
   cmp edx, 0
   jz ZERO_X_POS_Y 

   ; return -infinity if (y odd and x=-0), +infinity otherwise
   ; ecx=0 or 2^11*2^7
   shl ecx, 20-7
   ; eax=2^31 if (y odd and x=-0)
   and eax, ecx
   mov edx, 7ff00000H
   ; set sign of infinity
   or edx, eax
   ; load result
   movd xmm0, edx
   psllq xmm0, 32

   ; raise divide by zero
   movlpd xmm1, QWORD PTR [ONEMASK]
   movlpd xmm2, QWORD PTR [esp+4]
   divsd xmm1, xmm2

   mov edx, 27
   jmp CALL_LIBM_ERROR


ZERO_X_POS_Y:

   ; x=-0, and y odd integer ?
   ; ecx=0 or 2^11*2^7
   shl ecx, 20-7
   ; eax=2^31 if (y odd and x=-0)
   and eax, ecx
   cmp eax, 0
   jnz RET_NEG_ZERO

   ; return +0
   fldz
   ret


INF_NAN_X:
	; y finite, not zero
	; x NaN ?
        movlpd xmm3, QWORD PTR [SIGMASK]
	xorpd xmm1, xmm1
	; get significand bits
        andpd xmm3, xmm4
	; significand bits = 0 ?
	pcmpeqd xmm1, xmm3
	pmovmskb ecx, xmm1
	and ecx, 0ffH
	cmp ecx, 0ffH
        jnz X_NAN

	; x=+infinity ?
	pextrw ecx, xmm4, 3
	and ecx, 8000H
	cmp ecx,0
	jz X_INF

	; x=-infinity
	; y integer ?
   	and eax, 0ffH
   	cmp eax, 0ffH
	jnz X_NINF
	; y odd integer ?
	movlpd xmm1, QWORD PTR [esp+12]
	movlpd xmm2, QWORD PTR [esp+12]
   ; load bias-11
   mov ecx, 3ffH-11
   movd xmm3, ecx
   ; get exponent+64-53
   andpd xmm1, QWORD PTR [ABSVALMASK]
   psrlq xmm1, 64-12
   psubd xmm1, xmm3
   ; xmm3=0
   pxor xmm3, xmm3
   ; get last integer bit, fractional tail of y
   psllq xmm2, xmm1
   ; last int. bit=0 ? (i.e. y is an even integer ?)
   pcmpeqd xmm2, xmm3
   pmovmskb eax, xmm2
   and eax, 0ffH
   cmp eax, 0ffH
   jz X_NINF

   ; x=-infinity, y an odd integer
   movlpd xmm1, QWORD PTR [esp+12]
   pextrw eax, xmm1, 3
   and eax, 8000H
   cmp eax, 0
   ; y>0 ?
   jz RET_NINF
   ; y<0, return -0

RET_NEG_ZERO:
   fld [NEG_ZERO]
   ret	
    

RET_NINF:
   fld [NEG_INF]
   ret

X_NINF:
   ; x=-infinity, y not an odd integer
   movlpd xmm1, QWORD PTR [esp+12]
   pextrw eax, xmm1, 3
   and eax, 8000H
   cmp eax, 0
   ; y>0 ? (return infinity)
   jz RET_INF
   ; y<0, return 0
   fldz
   ret
 
X_INF:
	; y<0 ?
	movlpd xmm1, QWORD PTR [esp+12]
	pextrw eax, xmm1, 3
	and eax, 8000H
	cmp eax, 0
	jz RET_INF

	; y<0, return 0
	fldz
	ret


X_NAN:
    addsd xmm4, xmm4
; sub esp, 16
;   movlpd QWORD PTR [esp+4], xmm4
;   fld    QWORD PTR [esp+4]
; add esp, 16	
;   ret
    $movsd xmm0, xmm4
    mov edx, 1006
    jmp CALL_LIBM_ERROR

RET_INVALID:
    ; x=-0?
    movlpd xmm2, QWORD PTR [esp+4]
    movd eax, xmm2
    psrlq xmm2, 32
    movd edx, xmm2
    and edx, 7fffffffH
    or eax, edx
    mov ecx, 0
    cmp eax, 0
    jz ZERO_X

    ; raise INVALID exception
    movlpd xmm1, QWORD PTR [sNaN]
    movlpd xmm0, QWORD PTR [QIND]
    mulsd xmm1, xmm1
    mov edx, 28
    jmp CALL_LIBM_ERROR


SPECIAL_Y:

    ; load x, y
    movlpd xmm4, QWORD PTR [esp+4]
    movlpd xmm2, QWORD PTR [esp+12]
    ; x=+/-1 ?
    ; load lower bits of x
    movd eax, xmm4
    cmp eax, 0
    jnz Y_INF_NAN

    psrlq xmm4, 32
    movd edx, xmm4
    ; x=1 ?
    cmp edx, 3ff00000H
    jz RET_ONE
	
    ; x=-1 ?
    cmp edx, 0bff00000H
    jnz Y_INF_NAN

    ; y=NaN ? (xmm1 contains y)
    movlpd xmm3, QWORD PTR [SIGMASK]
    xorpd xmm1, xmm1
    ; get significand bits, to determine if y=NaN
    andpd xmm3, xmm2
    ; significand bits = 0 ?
    pcmpeqd xmm1, xmm3
    pmovmskb eax, xmm1
    cmp eax, 0ffH
    jnz RET_Y_NAN

    ; y=+/-infinity, return 1    
    fld1
    ret 


Y_INF_NAN:

    movlpd xmm3, QWORD PTR [SIGMASK]
    xorpd xmm1, xmm1
    ; get significand bits, to determine if y=NaN
    andpd xmm3, xmm2
    ; significand bits = 0 ?
    pcmpeqd xmm1, xmm3
    pmovmskb eax, xmm1
    and eax, 0ffH
    cmp eax, 0ffH
    jnz RET_Y_NAN

    ; y infinity, get sign
    pextrw eax, xmm2, 3
    ; get x
    movlpd xmm4, QWORD PTR [esp+4]
    and eax, 8000H
    ; x=-1 ? (ecx,edx=high, low parts of x)
    xor ecx, 0bff00000H
    or  edx, ecx
    cmp edx, 0
    ; if x=-1, return 1
    jz RET_ONE     
    cmp eax, 0
    jz Y_INF

    ; |x|<1 ?  ( |x|=1 will not take this path)
    pextrw eax, xmm4, 3
    and eax, 7ff0H
    cmp eax, 3ff0H
    jb RET_INF

    ; |x|>1, y=-infinity, return 0
    fldz 
    ret


Y_INF:
    ; y=+infinity
    ; |x|>=1 ?  ( |x|=1 will not take this path)
    pextrw eax, xmm4, 3
    and eax, 7ff0H
    cmp eax, 3ff0H
    jae RET_INF

    ; |x|<1, return 0
    fldz
    ret
    
RET_INF:
    fld QWORD PTR [INF]
    ret  


RET_Y_NAN:
    addsd xmm2, xmm2
; sub esp, 16
;   movlpd QWORD PTR [esp+4], xmm2
;   fld QWORD PTR [esp+4]
; add esp, 16
;   ret
    $movsd xmm0, xmm2
    mov edx, 1006
    jmp CALL_LIBM_ERROR

Y_ZERO: 

    ; x=0 ?
    movd eax, xmm4
    psrlq xmm4, 32
    movd edx, xmm4
    and edx, 7fffffffH
    mov ecx, eax
    or eax, edx
    movlpd xmm0, QWORD PTR [ONEMASK]
    mov edx, 26
    cmp eax, 0
    jz CALL_LIBM_ERROR

    ; x=NaN ?
    movd eax, xmm4
    mov edx, 29
    and eax, 7fffffffH
    cmp eax, 7ff00000H
    ; x=NaN
    ja CALL_LIBM_ERROR
    ; x!=NaN
    jb Y_ZERO_RET
    ; x=NaN ?
    cmp ecx,0
    ja CALL_LIBM_ERROR
    
Y_ZERO_RET:
    ; return 1 for any x
  sub esp, 16
    movlpd QWORD PTR [esp+4], xmm0
    fld QWORD PTR [esp+4]
  add esp, 16

    ret

RET_ONE:
    ; used for x=+/-1, special y
;     fld1
;     ret


     movlpd xmm1, QWORD PTR [QIND]
     movlpd xmm0, QWORD PTR [esp+12]
     ; set Invalid flag, if necessary
     addsd xmm0, xmm1
     
     mov edx, 28
     ; jmp cALL_LIBM_ERROR


CALL_LIBM_ERROR:
	;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
	sub esp, 28
	movlpd QWORD PTR [esp+16], xmm0
	mov DWORD PTR [esp+12],edx
	mov edx, esp
	add edx,16
	mov DWORD PTR [esp+8],edx
	add edx,16+8
	mov DWORD PTR [esp+4],edx
	sub edx, 8
	mov DWORD PTR [esp],edx
	call NEAR PTR __libm_error_support
;	movlpd xmm0, QWORD PTR [esp+16]

;	movlpd    QWORD PTR [esp+16], xmm0       ; return result
	fld       QWORD PTR [esp+16]             ;
	add esp,28
	ret


UF_OF_CASES:
   cmp eax,0
   jle UNDERFLOW_CASES

   ; if eax>=2^11*2^7, oF occurs
   cmp eax, 40000H
   jae RET_INF_OF

   push esi
   ; overflow
   ; get table index, and exponent of result
   mov edx, eax
   ; ecx contains expected sign of the result, scaled by 2^11
   and eax, 7fH
   ; add exponent (bias+bias)*2^7
   add ecx, 3ff00h
   ; edx+=(bias+(-bias)-1)*2^7  ; the same -1
   sub edx, 128
   and edx, 0ffffff80H
   push edi
   mov edi, 3ff0H
   jmp OF_CONT


UNDERFLOW_CASES:

   cmp eax, (2-1024)*256
   jle RET_ZERO_UF

   push esi
   ; get table index, and exponent of result
   mov edx, eax
   ; ecx contains expected sign of the result, scaled by 2^11
   and eax, 7fH
   ; add exponent (bias+1-bias)*2^7
   add ecx, 80h
   ; edx=exponent*2^7
   and edx, 0ffffff80H
   ; edx+=(bias+bias-1)*2^7
   add edx, 3fe80H
   push edi
   mov edi, 0

OF_CONT:
   ; D1+D2+D3+(Rl+E)
   addsd xmm4, xmm0
   ; xmm0=xmm3=2^7*H
   $movsd xmm0, xmm3
   
   ; (2^7)*H+Shifter (to round to integer)
   addsd xmm3, QWORD PTR [Shifter]

   ; esi=edx-bias*2^7
   mov esi, edx
   sub esi, 1ff80H

   ; cl1*R|cl3*R
   mulpd xmm2, xmm7

   ; int((2^7)*H)=((2^7)*H+Shifter)-Shifter
   subsd xmm3, QWORD PTR [Shifter]

   ; R^2|R^2
   mulpd xmm7, xmm7

   ; R_exp_h'=R_exp_h*(2^7)=(2^7)*H-int((2^7)*H)
   subsd xmm0, xmm3

   ; load table values
   add eax, eax
   add eax, eax
   add eax, eax
   add eax, eax
   ; D|T
   movapd xmm3, QWORD PTR [exp2_tbl+eax] 

   ; load ce3|ce5
   movapd xmm6, QWORD PTR [cev]


   ; cl2*R^2|cl4*R^2
   mulpd xmm1, xmm7
   ; cl1*R+cl2*R^2|cl3*R+cl4*R^2
   addpd xmm2, xmm1
   ; unpack cl1*R+cl2*R^2
   pshufd xmm1, xmm2, 0eeh
   ; *|cl3*R^3+cl4*R^4
   mulsd xmm2, xmm7
   ; Pl14
   addsd xmm2, xmm1
   ; low part of log2(x): D1+D2+D3+(Rl+E)+P14
   addsd xmm2, xmm4

   ; load ce1
   movlpd xmm4, QWORD PTR [cev+32]
   ; load 2^k2 
   movd xmm1, edx
   ; edx=-(edx-bias*2^7)/2^7
   sub edx, 1ff80H
   neg edx
   sar edx, 7

   add edx, 2
   ; if edx>=32, set edx to 64+
   mov eax, edx
   and eax, 32
   add edx, eax

   ; xmm7=0
   xorpd xmm7, xmm7
   mov eax, 3f80H
   ; xmm7=scaling constant 
   pinsrw xmm7, eax, 3 

   ; y*(D1+D2+D3+(Rl+E)+P14)
   mulsd xmm2, QWORD PTR [esp+12+4+4]
   ; get R_exp_h=2^{-7}*R_exp_h'
   mulsd xmm0, xmm7

   psllq xmm1, 52-7
   ; xmm1=2^k2|2^k2
   pshufd xmm1, xmm1, 044h

   ; load ce2|ce4
   movapd xmm7, QWORD PTR [cev+16]
   ; low part of y*log2(x): yH*HL+yL*HH+yL*HL+y*(D1+D2+D3+(Rl+E)+P14)
   addsd xmm5, xmm2

   ; get D*2^k|T*2^k
   mulpd xmm3, xmm1
   ; get R_exp=R_exp_h+yH*HL+yL*HH+yL*HL+y*(D1+D2+D3+(Rl+E)+P14)
   addsd xmm0, xmm5
   ; xmm0=R_exp|R_exp
   unpcklpd xmm0, xmm0

   ; ce3*R_exp|ce5*R_exp
   mulpd xmm6, xmm0
   ; ce1*R_exp
   mulsd xmm4, xmm0  
   ; R_exp^2|R_exp^2
   mulpd xmm0, xmm0
   ; ce2+ce3*R_exp|ce4+ce5*R_exp
   addpd xmm7, xmm6
   ; R_exp^2*(ce2+ce3*R_exp)|R_exp^2*(ce4+ce5*R_exp)
   mulpd xmm7, xmm0
   ; R_exp^2*(T*2^k)
   mulsd xmm0, xmm3
   ; unpack R_exp^2*(ce2+ce3*R_exp)
   pshufd xmm6, xmm7, 0eeh
   ; R_exp^4*(T*2^k)*(ce4+ce5*R_exp)
   mulsd xmm0, xmm7
   ; unpack D*2^k
   pshufd xmm5, xmm3, 0eeh
   ; R_exp^2*(T*2^k)*(ce2+ce3*R_exp)
   mulsd xmm6, xmm3
   ; ce1*(T*2^k)*R_exp
   mulsd xmm4, xmm3 

   ; xmm7=2^k'
   movd  xmm7, ecx
   psllq xmm7, 52-7 

   movd xmm2, edx
   pcmpeqd xmm1, xmm1
   psllq xmm1, xmm2

   ; P45*(T*2^k)+D*2^k  
   addsd xmm0, xmm5 
   ; P25*(T*2^k)+D*2^k
   addsd xmm0, xmm6

   ; Th
   andpd xmm1, xmm3

   ; P15*(T*2^k)+D*2^k
   addsd xmm0, xmm4
   ; xmm6=0
   xorpd xmm6, xmm6

   pcmpeqd xmm4, xmm4
   psllq xmm4, xmm2

   ; Tl
   subsd xmm3, xmm1
   ; xmm2=Th
   $movsd xmm2, xmm1

   ; (Th+(P15*(T*2^k)+D*2^k)_high)_high
   addsd xmm1, xmm0
   andpd xmm1, xmm4
   ; xmm6=(possible OF)?1:0
   pinsrw xmm6, edi, 3
   pop edi

   ; -(P15*(T*2^k)+D*2^k)_high
   subsd xmm2, xmm1

   ; (P15*(T*2^k)+D*2^k)_low
   addsd xmm0, xmm2

   ; Tl+(P15*(T*2^k)+D*2^k)_low
   addsd xmm0, xmm3

   cmp esi, 0
   jg  SCALE2

   pop esi
   ; final scaling by 2^k'
   mulsd xmm0, xmm7
   mulsd xmm1, xmm7

   ; final addition
   addsd xmm0, xmm1

   mulsd xmm6, xmm0
   addsd xmm0, xmm6

   ; overflow, or underflow
   pextrw eax, xmm0, 3
   and eax, 7ff0H
   mov edx, 24
   cmp eax, 7ff0H
   jz CALL_LIBM_ERROR

   mov edx, 25
   cmp eax, 0
   jz CALL_LIBM_ERROR

sub esp, 16
	movlpd    QWORD PTR [esp+4], xmm0       ; return result
	fld       QWORD PTR [esp+4]             ;
add esp, 16
	ret


SCALE2: 
   pop esi

   ; final addition
   addsd xmm0, xmm1
   ; final scaling by 2^k'
   mulsd xmm0, xmm7

   mulsd xmm6, xmm0
   addsd xmm0, xmm6

   ; overflow, or underflow
   pextrw eax, xmm0, 3
   and eax, 7ff0H
   mov edx, 24
   cmp eax, 7ff0H
   jz CALL_LIBM_ERROR

   mov edx, 25
   cmp eax, 0
   jz CALL_LIBM_ERROR

sub esp, 16
	movlpd    QWORD PTR [esp+4], xmm0       ; return result
	fld       QWORD PTR [esp+4]             ;
add esp, 16
	ret


RET_ZERO_UF:

   movlpd xmm0, QWORD PTR [EMIN]
   ; sign
   movd xmm1, ecx
   mulsd xmm0, xmm0

   ; set sign
   psllq xmm1, 63-18
   orpd xmm0, xmm1

   mov edx, 25
   jmp CALL_LIBM_ERROR

RET_INF_OF:

   mov edx, 24

   ; check sign
   cmp ecx, 0
   jz RET_INF_OF2

   movlpd xmm0, QWORD PTR [NEG_INF]
   jmp CALL_LIBM_ERROR

RET_INF_OF2:

   movlpd xmm0, QWORD PTR [INF]
   jmp CALL_LIBM_ERROR


RETURN_ONE:
   ; y|y
   pshufd xmm4, xmm1, 44H
   ; y*log2(x)_high
   mulpd xmm4, xmm6
   ; get exponent
   pextrw eax, xmm4, 3
   and eax, 7ff0H
   ; y*log2(x)>=2^{11} ? (i.e. 2^{11}-eps-x<0)
   mov edx, 40a0H
   sub edx, eax
   ; avoid underflow on intermediate calculations (|y*log2(x)|<2^{-56} ?)
   sub eax, 3c70H
   or edx, eax
   cmp edx, 80000000H
   ; if no OF/UF occurs, return to main path
   jb BACK_XY_CHECK




CONT_OF_UF:
   ; overflow/underflow ?
   cmp eax, 80000000H
   jb OF_UF

RET_ONE2:
   ; return +/- 1
   or ecx, 1ff80H
   movd xmm0, ecx
   psllq xmm0, 52-7

sub esp, 16
   movlpd [esp+4], xmm0
   fld QWORD PTR [esp+4]
add esp, 16
   ret

OF_UF:

   movlpd xmm4, [esp+4]
   pextrw edx, xmm4, 3
   and edx, 7ff0H
   sub edx, 3ff0H

   pextrw eax, xmm1, 3
   xor eax, edx
   and eax, 8000H
   cmp eax, 0
   jnz RET_ZERO_UF
   jmp RET_INF_OF


_CIpow_pentium4 ENDP

    ALIGN 16
_TEXT ENDS

    END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\tan.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;
;*******************************************************************************

_TAN_ equ 1
include trig.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\sin.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;
;*******************************************************************************

_SIN_ equ 1
include trig.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\temp_context.h ===
//
// This is a temp file that defines to be defined data structures - WINNT.H
//

#define CONTEXT_EXTENDED_REGISTERS  (CONTEXT_i386 | 0x00000020L) // cpu specific extensions

#define MAXIMUM_SUPPORTED_EXTENSION     512

//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) is is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//  The layout of the record conforms to a standard call frame.
//

typedef struct _TEMP_CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    DWORD ContextFlags;

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //

    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //

    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;              // MUST BE SANITIZED
    DWORD   EFlags;             // MUST BE SANITIZED
    DWORD   Esp;
    DWORD   SegSs;

    //
    // This section is specified/returned if the ContextFlags word
    // contains the flag CONTEXT_EXTENDED_REGISTERS.
    // The format and contexts are processor specific
    //

    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];

} TEMP_CONTEXT, *PTEMP_CONTEXT;


typedef struct _TEMP_EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PTEMP_CONTEXT ContextRecord;
} TEMP_EXCEPTION_POINTERS, *PTEMP_EXCEPTION_POINTERS;


#define SIZE_OF_X87_REGISTERS       128
#define SIZE_OF_XMMI_REGISTERS      128
#define SIZE_OF_FX_REGISTERS        128
#define NUMBER_OF_REGISTERS         8


typedef struct _FLOATING_EXTENDED_SAVE_AREA {
    USHORT  ControlWord;
    USHORT  StatusWord;
    USHORT  TagWord;
    USHORT  ErrorOpcode;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    ULONG   MXCsr;
    ULONG   Reserved2;
    UCHAR   X87RegisterArea[SIZE_OF_FX_REGISTERS];
    UCHAR   XMMIRegisterArea[SIZE_OF_FX_REGISTERS];
    UCHAR   Reserved4[224];
} FLOATING_EXTENDED_SAVE_AREA, *PFLOATING_EXTENDED_SAVE_AREA;


typedef struct _MMX_AREA {
    MMX64    Mmx;
    _U64     Reserved;
} MMX_AREA, *PMMX_AREA;

typedef struct _X87_AREA {
    MMX_AREA Mm[NUMBER_OF_REGISTERS];
} X87_AREA, *PX87_AREA;

typedef struct _XMMI_AREA {
    XMMI128  Xmmi[NUMBER_OF_REGISTERS];
} XMMI_AREA, *PXMMI_AREA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\trig.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;        support for sin(), cos() and tan() functions
;
;Revision History:
;
;*******************************************************************************

.xlist
        include cruntime.inc
        include elem87.inc
.list

        .data
extrn   _indefinite:tbyte
extrn   __fastflag:dword
extrn   _pi_by_2_to_61:tbyte
extrn   _DEFAULT_CW_in_mem:word


ifdef           _COS_
    _NAME_ db 'cos',0
    _FUNC_    equ <cos>
    _IFUNC_   equ <_CIcos>
elseifdef       _TAN_
    _NAME_ db 'tan',0
    _FUNC_    equ <tan>
    _IFUNC_   equ <_CItan>
elseifdef       _SIN_
    _SIN_  equ 1
    _NAME_ db 'sin',0
    _FUNC_    equ <sin>
    _IFUNC_   equ <_CIsin>
endif
        CODESEG

extrn   _startOneArgErrorHandling:near
extrn   _fload_withFB:near
extrn   _convertTOStoQNaN:near
extrn   _checkTOS_withFB:near
extrn   _math_exit:near
extrn   _fast_exit:near


; arg                ErrorType        result
;-------------------------------------------
;+/-infinity         DOMAIN           indefinite      |  ? Do we really need
;QNaN                DOMAIN_QNAN      QNaN            |  ? to distinguish them???
;SNaN                DOMAIN           indefinite      |  ? it costs 14 bytes per function
;indefinite is  like QNaN
;denormal        fld converts it to normal (80 bits)

        public _FUNC_,_IFUNC_
_IFUNC_ proc
        sub     esp,DBLSIZE+4                   ; for argument
        fst     qword ptr [esp]
        call    _checkTOS_withFB
        call    start
        add     esp, DBLSIZE+4
        ret

_FUNC_        label        proc
        lea     edx, [esp+4]
        call    _fload_withFB
start:
        push    edx                           ; allocate space for Control Word
        fstcw   [esp]                         ; store Control Word

; at this point we have on stack: cw(4), ret_addr(4), arg1(8bytes)

        jz      inf_or_nan
        cmp     word ptr[esp], default_CW
        je      CW_is_set_to_default

; fsin/fcos/fptan are not affected by precizion bits.
; So we may ignore user's CW

        fldcw   _DEFAULT_CW_in_mem
CW_is_set_to_default:

ifdef         _COS_
        fcos
        fstsw   ax
elseifdef _SIN_
        fsin
        fstsw   ax
elseifdef _TAN_
        fptan
        fstsw   ax
endif
        sahf
        jp      reduce_arg
ifdef    _TAN_
        fstp    st(0)
endif
exit:
        cmp     __fastflag, 0
        jnz     _fast_exit

; prepare in registers arguments for math_exit
ifdef _COS_
        mov     edx,OP_COS
elseifdef _SIN_
        mov     edx,OP_SIN
elseifdef _TAN_
        mov     edx,OP_TAN
endif
        lea     ecx,[_NAME_]
        jmp     _math_exit


reduce_arg:
        fld     TBYTE PTR [_pi_by_2_to_61]
        fxch    st(1)
redux_loop:
        fprem1
        fstsw   ax
        sahf
        jp      redux_loop

;reapply
        fstp    st(1)
ifdef         _COS_
        fcos
elseifdef _SIN_
        fsin
elseifdef _TAN_
        fptan
        fstp    st(0)
endif
        jmp     exit

not_infinity:
        call    _convertTOStoQNaN             ; eax MUST contain high dword
        jmp     _Error_handling               ; eax=error number
inf_or_nan:
        test    eax, 000fffffh
        jnz     not_infinity
        cmp     dword ptr[esp+8], 0
        jne     not_infinity
        fstp    st(0)
        fld     [_indefinite]
        mov     eax,DOMAIN
_Error_handling:
        cmp     __fastflag, 0
        jnz     _fast_exit

ifdef _COS_
        mov     edx,OP_COS
elseifdef _SIN_
        mov     edx,OP_SIN
elseifdef _TAN_
        mov     edx,OP_TAN
endif
        lea     ecx,[_NAME_]
        call    _startOneArgErrorHandling
        pop     edx                           ; remove saved CW from stack
        ret

_IFUNC_        endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\xmmi2_fp_emul.c ===
/*****************************************************************************
 *                                                                           *
 *                           Intel Confidential                              *
 *                                                                           *
 *                                                                           *
 * XMMI2_FP_emulate(): WNI FP instruction emulation for the FP IEEE filter   *
 *                                                                           *
 *                                                                           *
 * History:                                                                  *
 *    Marius Cornea-Hasegan, Nov 1999; added DAZ Oct 2000                    *
 *    marius.cornea@intel.com                                                *
 *                                                                           *
 *****************************************************************************/

//#define _DEBUG_FPU

// XMMI2_FP_Emulation () receives the input operands of an XMMI2 FP instruction 
// (operating on double-precision floating-point numbers and/or signed 
// integers), that might cause a floating-point exception (enabled or not).
//
// Arguments: PXMMI_ENV XmmiEnv
//
//  The type of every field (INPUT or OUTPUT) is indicated below:
//
//  typedef struct _XMMI_ENV {
//      ULONG Masks;                  //Mask values from MxCsr   INPUT
//      ULONG Fz;                     //Flush to Zero            INPUT
//      ULONG Rc;                     //Rounding                 INPUT
//      ULONG Precision;              //Precision                INPUT
//      ULONG Imm8;                   //imm8 predicate           INPUT
//      ULONG EFlags;                 //EFlags                   INPUT/OUTPUT
//      _FPIEEE_RECORD *Ieee;         //FP IEEE Record           INPUT/OUTPUT,
//                                                               field dependent
//  } XMMI_ENV, *PXMMI_ENV;
// 
//  The _FP_IEEE record and the _FPIEEE_VALUE are defined as:
//  
//  typedef struct {
//      unsigned int RoundingMode : 2;                   OUTPUT
//      unsigned int Precision : 3;                      OUTPUT
//      unsigned int Operation :12;                      INPUT
//      _FPIEEE_EXCEPTION_FLAGS Cause;                   OUTPUT
//      _FPIEEE_EXCEPTION_FLAGS Enable;                  OUTPUT
//      _FPIEEE_EXCEPTION_FLAGS Status;                  OUTPUT
//      _FPIEEE_VALUE Operand1;                          INPUT
//      _FPIEEE_VALUE Operand2;                          INPUT
//      _FPIEEE_VALUE Result;                            INPUT/OUTPUT,
//                                                       field dependent
//  } _FPIEEE_RECORD, *PFPIEEE_RECORD;
//  
//  typedef struct {
//      union {
//          _FP32    Fp64Value;
//          _FP64    Fp64Value;
//          _FP80    Fp80Value;
//          _FP128   Fp128Value;
//          _I16     I16Value;
//          _I32     I32Value;
//          _I64     I64Value;
//          _U16     U16Value;
//          _U32     U32Value;
//          _U64     U64Value;
//          _BCD80   Bcd80Value;
//          char     *StringValue;
//          int      CompareValue;
//      } Value;                                         INPUT for operands,
//                                                       OUTPUT for result
//
//      unsigned int OperandValid : 1;                   INPUT for operands
//                                                       INPUT/OUTPUT for result
//      unsigned int Format : 4;                         INPUT
//  
//  } _FPIEEE_VALUE;
//
// Return Value: 
//   ExceptionRaised if an enabled floating-point exception condition is 
//       detected; in this case, the fields of XmmiEnv->Ieee are filled in
//       appropriately to be passed directly to a user exception handler; the
//       XmmiEnv->Ieee->Cause bits indicate the cause of the exception, but if
//       a denormal exception occurred, then no XmmiEnv->Ieee->Cause bit is set;
//       upon return from the user handler,the caller of XMMI2_FP_emulate should
//       interpret the result for a compare instruction (CMPPD, CMPPD, COMISD,
//       UCOMISD); the Enable, Rounding, and Precision fields in _FPIEEE_RECORD
//       have to be checked too for possible changes by the user handler
//      
//   NoExceptionRaised if no floating-point exception condition occurred, or
//       if a disabled floating-point exception occurred; in this case,
//       XmmiEnv->Ieee->Result.Value contains the instruction's result, 
//       XmmiEnv->Ieee->Status contains the IEEE floating-point status flags
//
// Implementation Notes:
//
//   - the operation code in XmmiEnv->Ieee->Operation is changed as expected
//     by a user exception handler (even if no exception is raised):
//     from OP_ADDPD, OP_ADDSD to _FpCodeAdd
//     from OP_SUBPD, OP_SUBSD to _FpCodeSubtract
//     from OP_MULPD, OP_MULSD to _FpCodeMultiply
//     from OP_DIVPD, OP_DIVSD to _FpCodeDivide
//     from OP_CMPPD, OP_CMPSD to _FpCodeCompare
//     from OP_COMISD, OP_UCOMISD to _FpCodeCompare
//     from OP_CVTDQ2PS, OP_CVTPS2DQ, OP_CVTPD2PI, OP_CVTSD2SI, OP_CVTPD2DQ,
//         OP_CVTPS2PD, OP_CVTSS2SD, OP_CVTPD2PS, OP_CVTSD2SS to _FpCodeConvert
//     from OP_CVTTPS2DQ, OP_CVTTPD2PI, OP_CVTTSD2SI, OP_CVTTPD2DQ
//         to _FpCodeConvertTrunc
//     from OP_MAXPD, OP_MAXSD to _FpCodeMax
//     from OP_MINPD, OP_MINSD to _FpCodeMin
//     from OP_SQRTPD, OP_SQRTSD to _FpCodeSquareRoot
//
//

#include <wtypes.h>
#include <trans.h>
#include <float.h>
#include "xmmi_types.h"
#include "filter.h"
#ifdef _XMMI_DEBUG
#include "temp_context.h"
#include "debug.h"
#endif

// masks for individual status word bits
#define P_MASK 0x20
#define U_MASK 0x10
#define O_MASK 0x08
#define Z_MASK 0x04
#define D_MASK 0x02
#define I_MASK 0x01

// 32-bit constants
static unsigned ZEROFA[] = {0x00000000};
#define  ZEROF *(float *) ZEROFA
static unsigned NZEROFA[] = {0x80000000};
#define  NZEROF *(float *) NZEROFA

// 64-bit constants
static unsigned ZERODA[] = {0x00000000, 0x00000000};
#define  ZEROD *(double *) ZERODA
static unsigned NZERODA[] = {0x00000000, 0x80000000};
#define  NZEROD *(double *) NZERODA
static unsigned POSINFDA[] = {0x00000000, 0x7ff00000};
#define POSINFD *(float *)POSINFDA
static unsigned NEGINFDA[] = {0x00000000, 0xfff00000};
#define NEGINFD *(float *)NEGINFDA
#ifdef _DEBUG_FPU
static unsigned QNANINDEFDA[] = {0x00000000, 0xffc00000};
#define QNANINDEFD *(float *)QNANINDEFDA
#endif
static unsigned MIN_SINGLE_NORMALA [] = {0x00000000, 0x38100000};
    // +1.0 * 2^-126
#define MIN_SINGLE_NORMAL *(double *)MIN_SINGLE_NORMALA
static unsigned MAX_SINGLE_NORMALA [] = {0x70000000, 0x47efffff};
    // +1.1...1*2^127
#define MAX_SINGLE_NORMAL *(double *)MAX_SINGLE_NORMALA
static unsigned TWO_TO_192A[] = {0x00000000, 0x4bf00000};
#define TWO_TO_192 *(double *)TWO_TO_192A
static unsigned TWO_TO_M192A[] = {0x00000000, 0x33f00000};
#define TWO_TO_M192 *(double *)TWO_TO_M192A

// 80-bit constants
static unsigned POSINFDEA[] = {0x00000000, 0x80000000, 0x00007fff};
#define POSINFDE *(float *)POSINFDEA
static unsigned NEGINFDEA[] = {0x00000000, 0x80000000, 0x0000ffff};
#define NEGINFDE *(float *)NEGINFDEA
static unsigned MIN_DOUBLE_NORMALA [] = {0x00000000, 0x80000000, 0x00003c01}; 
    // +1.0 * 2^-1022
#define MIN_DOUBLE_NORMAL *(double *)MIN_DOUBLE_NORMALA
static unsigned MAX_DOUBLE_NORMALA [] = {0xfffff800, 0xffffffff, 0x000043fe}; 
    // +1.1...1*2^1023
#define MAX_DOUBLE_NORMAL *(double *)MAX_DOUBLE_NORMALA
static unsigned TWO_TO_1536A[] = {0x00000000, 0x80000000, 0x000045ff};
#define TWO_TO_1536 *(double *)TWO_TO_1536A
static unsigned TWO_TO_M1536A[] = {0x00000000, 0x80000000, 0x000039ff};
#define TWO_TO_M1536 *(double *)TWO_TO_M1536A


// auxiliary functions
static void Fill_FPIEEE_RECORD (PXMMI_ENV XmmiEnv);
static int iszerod (double);
static int isinfd (double);
static int issnand (double);
static int isnand (double);
static double quietd (double);
static int isdenormald (double);
static int isdenormalf (float f);



ULONG
XMMI2_FP_Emulation (PXMMI_ENV XmmiEnv)

{

  float opd24, res24;
  double opd1, opd2, res, dbl_res24;
  int iopd1; // for conversions from int to float
  int ires; // for conversions from float to int
  char dbl_ext_res64[10];
      // needed to check tininess, to provide a scaled result to
      // an underflow/overflow trap handler, and in flush-to-zero
  double dbl_res64;
  unsigned int result_tiny;
  unsigned int result_huge;
  unsigned int rc, sw;
  unsigned short sw1, sw2, sw3, sw4;
  unsigned long imm8;
  unsigned int invalid_exc;
  unsigned int denormal_exc;
  unsigned __int64 cmp_res;

  unsigned char min_double_normal[10];
  unsigned char max_double_normal[10];
  unsigned char posinfde[10];
  unsigned char neginfde[10];
  unsigned char two_to_1536[10];
  unsigned char two_to_m1536[10];

  // Note that ExceptionCode is always STATUS_FLOAT_MULTIPLE_FAULTS in the
  // calling routine, so we have to check first for faults, and then for traps

#ifdef _DEBUG_FPU
  unsigned int in_top;
  unsigned int out_top;
  char fp_env[108];
  unsigned short int *control_word, *status_word, *tag_word;

  // read status word
  sw = _status87 ();
  in_top = (sw >> 11) & 0x07;
  if (in_top != 0x0)
      printf ("XMMI2_FP_Emulation WARNING: in_top = %d\n", in_top);
  __asm {
    fnsave fp_env;
  }
  control_word = (unsigned short *)fp_env;
  status_word = (unsigned short *)(fp_env + 2);
  tag_word = (unsigned short *)(fp_env + 8);
  if (*tag_word != 0xffff)
      printf ("XMMI2_FP_Emulation WARNING: tag_word = %x\n",
      *tag_word);
#endif

  _asm {
    fninit;
  }

#ifdef _DEBUG_FPU
  // read status word
  sw = _status87 ();
  in_top = (sw >> 11) & 0x07;
  if (in_top != 0x0) 
    printf ("XMMI2_FP_Emulation () XMMI2_FP_Emulation () ERROR: in_top = %d\n", in_top);
  __asm {
    fnsave fp_env;
  }
  tag_word = (unsigned short *)(fp_env + 8);
  if (*tag_word != 0xffff) {
   printf ("XMMI2_FP_Emulation () XMMI2_FP_Emulation () ERROR: tag_word = %x\n",
        *tag_word);
    printf ("control, status, tag = %x %x %x %x %x %x\n", 
        fp_env[0] & 0xff, fp_env[1] & 0xff, fp_env[4] & 0xff, 
        fp_env[5] & 0xff, fp_env[8] & 0xff, fp_env[9] & 0xff);
  }
#endif


#ifdef _XMMI_DEBUG
  print_FPIEEE_RECORD (XmmiEnv);
#endif

  result_tiny = 0;
  result_huge = 0;

  XmmiEnv->Ieee->RoundingMode = XmmiEnv->Rc;
  XmmiEnv->Ieee->Precision = XmmiEnv->Precision;

  switch (XmmiEnv->Ieee->Operation) {

    case OP_ADDPD:
    case OP_ADDSD:
    case OP_SUBPD:
    case OP_SUBSD:
    case OP_MULPD:
    case OP_MULSD:
    case OP_DIVPD:
    case OP_DIVSD:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp64Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp64Value;
      if (XmmiEnv->Daz) {
        if (isdenormald (opd1)) opd1 = opd1 * 0.0;
        if (isdenormald (opd2)) opd2 = opd2 * 0.0;
      }

      // adjust operation code
      switch (XmmiEnv->Ieee->Operation) {

        case OP_ADDPD:
        case OP_ADDSD:

          XmmiEnv->Ieee->Operation = _FpCodeAdd;
          break;

        case OP_SUBPD:
        case OP_SUBSD:

          XmmiEnv->Ieee->Operation = _FpCodeSubtract;
          break;

        case OP_MULPD:
        case OP_MULSD:

          XmmiEnv->Ieee->Operation = _FpCodeMultiply;
          break;

        case OP_DIVPD:
        case OP_DIVSD:

          XmmiEnv->Ieee->Operation = _FpCodeDivide;
          break;

        default:
          ; // will never occur

      }

      // execute the operation and check whether the invalid, denormal, or 
      // divide by zero flags are set and the respective exceptions enabled

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      _control87 (rc | _PC_53 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // compute result and round to the destination precision, with
      // "unbounded" exponent (first IEEE rounding)
      switch (XmmiEnv->Ieee->Operation) {

        case _FpCodeAdd:
          // perform the add
          __asm {
            fnclex;
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            faddp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  QWORD PTR dbl_res64;
          }
          __asm {
            fnclex; 
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            faddp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  TBYTE PTR dbl_ext_res64; // exact
          }

          break;

        case _FpCodeSubtract:
          // perform the subtract
          __asm {
            fnclex;
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            fsubp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  QWORD PTR dbl_res64;
          }
          __asm {
            fnclex; 
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            fsubp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  TBYTE PTR dbl_ext_res64; // exact
          }
          break;

        case _FpCodeMultiply:
          // perform the multiply
          __asm {
            fnclex;
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            fmulp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  QWORD PTR dbl_res64; // exact
          }
          __asm {
            fnclex; 
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            fmulp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  TBYTE PTR dbl_ext_res64; // exact
          }
          break;

        case _FpCodeDivide:
          // perform the divide
          __asm {
            fnclex;
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            fdivp st(1), st(0); // may set the inexact, divide by zero, or
                                // invalid status flags
            // store result
            fstp  QWORD PTR dbl_res64; // exact
          }

          __asm {
            fnclex; 
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            fdivp st(1), st(0); // may set the inexact, divide by zero, or 
                                // invalid status flags
            // store result
            fstp  TBYTE PTR dbl_ext_res64; // exact
          }

          break;

        default:
          ; // will never occur

      }

      // read status word
      sw = _status87 ();
      if (sw & _SW_ZERODIVIDE) sw = sw & ~0x00080000; // clear D flag for den/0

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 1: in_top =%d != out_top = %d\n",
              in_top, out_top);
          exit (1);
        }
#endif

        return (ExceptionRaised);

      }

      // checking for NaN operands has priority over denormal exceptions; also
      // fix for the differences in treating two NaN inputs between the XMMI 
      // instructions and other x86 instructions
      if (isnand (opd1) || isnand (opd2)) {
        XmmiEnv->Ieee->Result.OperandValid = 1;

        if (isnand (opd1) && isnand (opd2))
            XmmiEnv->Ieee->Result.Value.Fp64Value = quietd (opd1);
        else
            XmmiEnv->Ieee->Result.Value.Fp64Value = dbl_res64;
 
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        if (sw & _SW_INVALID) {
          XmmiEnv->Ieee->Status.InvalidOperation = 1;
          XmmiEnv->Flags |= I_MASK;
        } else {
          XmmiEnv->Ieee->Status.InvalidOperation = 0;
        }

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 2: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);
      }

      // if denormal flag is set, and denormal exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & D_MASK) && (sw & _SW_DENORMAL)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 3: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        XmmiEnv->Flags |= D_MASK;
        return (ExceptionRaised);

      }

      // if divide by zero flag is set, and divide by zero exceptions are 
      // enabled, take trap (for divide only)
      if (!(XmmiEnv->Masks & Z_MASK) && (sw & _SW_ZERODIVIDE)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.ZeroDivide = 1;
        XmmiEnv->Flags |= Z_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.ZeroDivide = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 4: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // done if the result is a NaN (QNaN Indefinite)
      res = dbl_res64;
      if (isnand (res)) {
#ifdef _DEBUG_FPU
      if (res != QNANINDEFD)
          fprintf (stderr, "XMMI2_FP_Emulation () INTERNAL XMMI2_FP_Emulation"
             " () ERROR: res = %f = %x is not QNaN Indefinite\n", 
              (double)res, *(unsigned int *)&res);
#endif
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp64Value = res; // exact
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        XmmiEnv->Ieee->Status.InvalidOperation = 1; // sw & _SW_INVALID true
        XmmiEnv->Flags |= I_MASK;
  
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 5: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);
      }

      // dbl_ext_res64 is not a NaN at this point

      if (sw & _SW_DENORMAL) XmmiEnv->Flags |= D_MASK;

      // Note: (dbl_ext_res64 == 0.0 && sw & _SW_INEXACT) cannot occur

      // check if the result is tiny
      // if (-MIN_DOUBLE_NORMAL < dbl_ext_res64 && dbl_ext_res64 < 0.0 ||
      //     0.0 < dbl_ext_res64 && dbl_ext_res64 < MIN_DOUBLE_NORMAL)
      //   result_tiny = 1;

      memcpy (min_double_normal,  (char *)MIN_DOUBLE_NORMALA, 10);
      memcpy (max_double_normal,  (char *)MAX_DOUBLE_NORMALA, 10);
      memcpy (posinfde,  (char *)POSINFDEA, 10);
      memcpy (neginfde,  (char *)NEGINFDEA, 10);
      memcpy (two_to_1536, (char *)TWO_TO_1536A, 10);
      memcpy (two_to_m1536, (char *)TWO_TO_M1536A, 10);

      __asm {

        // -MIN_DOUBLE_NORMAL < dbl_ext_res64 
        fld  TBYTE PTR dbl_ext_res64;
        fld  TBYTE PTR min_double_normal;
        fchs; // -1.0*2^e_min in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw1;

        // dbl_ext_res64 < 0.0
        fldz;
        fld  TBYTE PTR dbl_ext_res64; // dbl_ext_res64 in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw2;

        // 0.0 < dbl_ext_res64 
        fld  TBYTE PTR dbl_ext_res64;
        fldz; // 0.0 in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw3;

        // dbl_ext_res64 < MIN_DOUBLE_NORMAL
        fld  TBYTE PTR min_double_normal; 
        fld  TBYTE PTR dbl_ext_res64; // dbl_ext_res64 in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw4;

      }

      if (((sw1 & 0x4500) == 0x0100) && ((sw2 & 0x4500) == 0x0100) ||
          ((sw3 & 0x4500) == 0x0100) && ((sw4 & 0x4500) == 0x0100)) {
        result_tiny = 1;
      }

      // check if the result is huge
      // if (NEGINFD<dbl_ext_res64 && dbl_ext_res64<-MAX_DOUBLE_NORMAL ||
      //     MAX_DOUBLE_NORMAL<dbl_ext_res64 && dbl_ext_res64<POSINFD)
      //   result_huge = 1;

      __asm {

        // NEGINFD < dbl_ext_res64
        fld  TBYTE PTR dbl_ext_res64;
        fld  TBYTE PTR neginfde; // -inf in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw1;

        // dbl_ext_res64 < -MAX_DOUBLE_NORMAL
        fld  TBYTE PTR max_double_normal;
        fchs;
        fld  TBYTE PTR dbl_ext_res64; // dbl_ext_res64 in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw2;

        // MAX_DOUBLE_NORMAL < dbl_ext_res64
        fld  TBYTE PTR dbl_ext_res64;
        fld  TBYTE PTR max_double_normal; // +1.1...1*2^e_max in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw3;

        // dbl_ext_res64 < POSINFD
        fld  TBYTE PTR posinfde; 
        fld  TBYTE PTR dbl_ext_res64; // dbl_res_ext24 in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw4;

      }

      if (((sw1 & 0x4500) == 0x0100) && ((sw2 & 0x4500) == 0x0100) ||
          ((sw3 & 0x4500) == 0x0100) && ((sw4 & 0x4500) == 0x0100)) {
        result_huge = 1;
      }


      // at this point, there are no enabled I, D, or Z exceptions; the instr.
      // might lead to an enabled underflow, enabled underflow and inexact, 
      // enabled overflow, enabled overflow and inexact, enabled inexact, or
      // none of these; if there are no U or O enabled exceptions, re-execute
      // the instruction using iA32 stack double precision format, and the 
      // user's rounding mode; exceptions must have been disabled before calling
      // this function; an inexact exception may be reported on the 64-bit
      // faddp, fsubp, fdivp, or on both the 64-bit and 53-bit conversions,
      // while an overflow or underflow (with traps disabled !) may be reported
      // on the conversion from dbl_res to res

      // check whether there is an underflow, overflow, or inexact trap to be 
      // taken

      // if the underflow traps are enabled and the result is tiny, take 
      // underflow trap
      if (!(XmmiEnv->Masks & U_MASK) && result_tiny) {

        // dbl_ext_res64 = TWO_TO_1536 * dbl_ext_res64; // exact
        __asm {
          fld  TBYTE PTR dbl_ext_res64;
          fld  TBYTE PTR two_to_1536;
          fmulp st(1), st(0);
          // store result
          fstp  QWORD PTR dbl_res64;
        }

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
        XmmiEnv->Ieee->Cause.Underflow = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;

        XmmiEnv->Ieee->Result.Value.Fp64Value = dbl_res64; // exact

        if (sw & _SW_INEXACT) {
          XmmiEnv->Ieee->Status.Inexact = 1;
          XmmiEnv->Flags |= P_MASK;
        }

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 6: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if overflow traps are enabled and the result is huge, take
      // overflow trap
      if (!(XmmiEnv->Masks & O_MASK) &&  result_huge) {

        // dbl_ext_res64 = TWO_TO_M1536 * dbl_ext_res64; // exact
        __asm {
          fld  TBYTE PTR dbl_ext_res64;
          fld  TBYTE PTR two_to_m1536;
          fmulp st(1), st(0);
          // store result
          fstp  QWORD PTR dbl_res64;
        }

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Overflow = 1;
        XmmiEnv->Flags |= O_MASK;
        XmmiEnv->Ieee->Cause.Overflow = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp64Value = dbl_res64; // exact 
 
        if (sw & _SW_INEXACT) {
          XmmiEnv->Ieee->Status.Inexact = 1;
          XmmiEnv->Flags |= P_MASK;
        }


#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 7: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // set user rounding mode, 64-bit precision (to avoid a double rounding
      // error in case the result requires denormalization), and disable all
      // exceptions 
      _control87 (rc | _PC_53 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // calculate result for the case an inexact trap has to be taken, or
      // when no trap occurs (second IEEE rounding)
      // may set P, U or O; may also involve denormalizing the result

      switch (XmmiEnv->Ieee->Operation) {

        case _FpCodeAdd:
          // perform the add
          __asm {
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal status flag
            fld  QWORD PTR opd2; // may set the denormal status flag
            faddp st(1), st(0); // rounded to 64 bits, may set the inexact 
                                // or divide by zero status flags
            // store result
            fstp  QWORD PTR res;
          }
          break;

        case _FpCodeSubtract:
          // perform the subtract
          __asm {
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal status flag
            fld  QWORD PTR opd2; // may set the denormal status flag
            fsubp st(1), st(0); // rounded to 64 bits, may set the inexact
                                //  status flag
            // store result
            fstp  QWORD PTR res;
          }
          break;

        case _FpCodeMultiply:
          // perform the multiply
          __asm {
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal status flag
            fld  QWORD PTR opd2; // may set the denormal status flag
            fmulp st(1), st(0); // rounded to 64 bits, exact
            // store result
            fstp  QWORD PTR res;
          }

          break;

        case _FpCodeDivide:
          // perform the divide
          __asm {
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal status flag
            fld  QWORD PTR opd2; // may set the denormal status flag
            fdivp st(1), st(0); // rounded to 64 bits, may set the inexact
                                // or divide by zero status flags
            // store result
            fstp  QWORD PTR res;
          }
          break;

        default:
          ; // will never occur

      }

      // read status word
      sw = _status87 ();

      if ((sw & _SW_INEXACT) && result_tiny) sw = sw | _SW_UNDERFLOW;

      // if inexact traps are enabled and result is inexact, take inexact trap
      if (!(XmmiEnv->Masks & P_MASK) && 
          ((sw & _SW_INEXACT) || (XmmiEnv->Fz && result_tiny))) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        if (result_tiny) {
          XmmiEnv->Ieee->Status.Underflow = 1;
          XmmiEnv->Flags |= U_MASK;
          // Note: the condition above is equivalent to
          // if (sw & _SW_UNDERFLOW) XmmiEnv->Ieee->Status.Underflow = 1; 
        }
        if (result_huge) {
          XmmiEnv->Ieee->Status.Overflow = 1;
          XmmiEnv->Flags |= O_MASK;
          // Note: the condition above is equivalent to
          // if (sw & _SW_OVERFLOW) XmmiEnv->Ieee->Status.Overflow = 1;
        }

        // if ftz = 1 and result is tiny, result = 0.0
        // (no need to check for underflow traps disabled: result tiny and
        // underflow traps enabled would have caused taking an underflow
        // trap above)
        if (XmmiEnv->Fz && result_tiny) {
            // Note: the condition above is equivalent to
            // if (XmmiEnv->Fz && (sw & _SW_UNDERFLOW))
          if (res > 0.0)
            res = ZEROD;
          else if (res < 0.0)
            res = NZEROD;
          // else leave res unchanged
        }

        XmmiEnv->Ieee->Result.Value.Fp64Value = res; 
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 8: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if it got here, then there is no trap to be taken; the following must
      // hold: ((the MXCSR U exceptions are disabled  or
      //
      // the MXCSR underflow exceptions are enabled and the underflow flag is
      // clear and (the inexact flag is set or the inexact flag is clear and
      // the 53-bit result with unbounded exponent is not tiny)))
      // and (the MXCSR overflow traps are disabled or the overflow flag is
      // clear) and (the MXCSR inexact traps are disabled or the inexact flag
      // is clear)
      //
      // in this case, the result has to be delivered (the status flags are 
      // sticky, so they are all set correctly already)

#ifdef _DEBUG_FPU
      // error if the condition stated above does not hold
      if (!((XmmiEnv->Masks & U_MASK || (!(XmmiEnv->Masks & U_MASK) && 
          !(sw & _SW_UNDERFLOW) && ((sw & _SW_INEXACT) || 
          !(sw & _SW_INEXACT) && !result_tiny))) &&
          ((XmmiEnv->Masks & O_MASK) || !(sw & _SW_OVERFLOW)) &&
          ((XmmiEnv->Masks & P_MASK) || !(sw & _SW_INEXACT)))) {
        fprintf (stderr, "XMMI2_FP_Emulation () INTERNAL XMMI2_FP_Emulation () ERROR for "
            "ADDPS/ADDSS/SUBPS/SUBSS/MULPS/MULSS/DIVPS/DIVSS\n");
      }
#endif

      XmmiEnv->Ieee->Result.OperandValid = 1;

      if (sw & _SW_UNDERFLOW) {
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
      } else {
        XmmiEnv->Ieee->Status.Underflow = 0;
      }
      if (sw & _SW_OVERFLOW) {
        XmmiEnv->Ieee->Status.Overflow = 1;
        XmmiEnv->Flags |= O_MASK;
      } else {
        XmmiEnv->Ieee->Status.Overflow = 0;
      }
      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }

      // if ftz = 1, and result is tiny (underflow traps must be disabled),
      // result = 0.0
      if (XmmiEnv->Fz && result_tiny) {
        if (res > 0.0)
          res = ZEROD;
        else if (res < 0.0)
          res = NZEROD;
        // else leave res unchanged

        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
      }

      XmmiEnv->Ieee->Result.Value.Fp64Value = res; 

      // note that there is no way to
      // communicate to the caller that the denormal flag was set - we count
      // on the XMMI instruction to have set the denormal flag in MXCSR if
      // needed, regardless of the other components of the input operands
      // (invalid or not; the caller will have to update the underflow, 
      // overflow, and inexact flags in MXCSR)
      if (sw & _SW_ZERODIVIDE) {
        XmmiEnv->Ieee->Status.ZeroDivide = 1;
        XmmiEnv->Flags |= Z_MASK;
      } else {
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
      }
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 9: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CMPPD:
    case OP_CMPSD:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp64Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp64Value;
      if (XmmiEnv->Daz) {
        if (isdenormald (opd1)) opd1 = opd1 * 0.0;
        if (isdenormald (opd2)) opd2 = opd2 * 0.0;
      }
      imm8 = XmmiEnv->Imm8 & 0x07;

      // adjust operation code
      XmmiEnv->Ieee->Operation = _FpCodeCompare;

      // check whether an invalid exception has to be raised

      switch (imm8) {

        case IMM8_EQ:
        case IMM8_UNORD:
        case IMM8_NEQ:
        case IMM8_ORD:
          if (issnand (opd1) || issnand (opd2))
              invalid_exc = 1; // SNaN operands signal invalid
          else
              invalid_exc = 0; // QNaN or other operands do not signal invalid
          // guard against the case when an SNaN operand was converted to 
          // QNaN by compiler generated code
          sw = _status87 ();
          if (sw & _SW_INVALID) invalid_exc = 1;
          break;
        case IMM8_LT:
        case IMM8_LE:
        case IMM8_NLT:
        case IMM8_NLE:
          if (isnand (opd1) || isnand (opd2))
              invalid_exc = 1; // SNaN/QNaN operands signal invalid
          else
              invalid_exc = 0; // other operands do not signal invalid
          break;
        default:
          ; // will never occur

      }

      // if invalid_exc = 1, and invalid exceptions are enabled, take trap
      if (invalid_exc && !(XmmiEnv->Masks & I_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

        // Note: the calling function will have to interpret the value returned
        // by the user handler, if execution is to be continued

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
         printf ("XMMI2_FP_Emulation () ERROR 10: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // checking for NaN operands has priority over denormal exceptions
      if (isnand (opd1) || isnand (opd2)) {

        switch (imm8) {

          case IMM8_EQ:
          case IMM8_LT:
          case IMM8_LE:
          case IMM8_ORD:
            cmp_res = 0x0;
            break;
          case IMM8_UNORD:
          case IMM8_NEQ:
          case IMM8_NLT:
          case IMM8_NLE:
            cmp_res = 0xffffffffffffffff;
            break;
          default:
            ; // will never occur

        }

        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp64Value = *((double *)&cmp_res); 
            // may make U32Value
  
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        // Note that the denormal flag will not be updated by _fpieee_flt (),
        // even if an operand is denormal
        if (invalid_exc) {
          XmmiEnv->Ieee->Status.InvalidOperation = 1;
          XmmiEnv->Flags |= I_MASK;
        } else {
          XmmiEnv->Ieee->Status.InvalidOperation = 0;
        }
  
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
         printf ("XMMI2_FP_Emulation () ERROR 11: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);

      }

      // check whether a denormal exception has to be raised

      if (isdenormald (opd1) || isdenormald (opd2)) {
          denormal_exc = 1;
          XmmiEnv->Flags |= D_MASK;
      } else {
          denormal_exc = 0;
      }

      // if denormal_exc = 1, and denormal exceptions are enabled, take trap
      if (denormal_exc && !(XmmiEnv->Masks & D_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
         printf ("XMMI2_FP_Emulation () ERROR 12: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // no exception has to be raised, and no operand is a NaN; calculate 
      // and deliver the result

      if (opd1 < opd2) {

        switch (imm8) {
  
          case IMM8_LT:
          case IMM8_LE:
          case IMM8_NEQ:
          case IMM8_ORD:
            cmp_res = 0xffffffffffffffff;
            break;
          case IMM8_EQ:
          case IMM8_UNORD:
          case IMM8_NLT:
          case IMM8_NLE:
            cmp_res = 0x0;
            break;

          default:
            ; // will never occur
  
        }

      } else if (opd1 > opd2) {

        switch (imm8) {
  
          case IMM8_NEQ:
          case IMM8_NLT:
          case IMM8_NLE:
          case IMM8_ORD:
            cmp_res = 0xffffffffffffffff;
            break;

          case IMM8_EQ:
          case IMM8_LT:
          case IMM8_LE:
          case IMM8_UNORD:
            cmp_res = 0x0;
            break;

          default:
            ; // will never occur
  
        }

      } else if (opd1 == opd2) {

        switch (imm8) {
  
          case IMM8_EQ:
          case IMM8_LE:
          case IMM8_NLT:
          case IMM8_ORD:
            cmp_res = 0xffffffffffffffff;
            break;

          case IMM8_LT:
          case IMM8_UNORD:
          case IMM8_NEQ:
          case IMM8_NLE:
            cmp_res = 0x0;
            break;

          default:
            ; // will never occur
  
        }

      } else { // could eliminate this case

#ifdef _DEBUG_FPU
        fprintf (stderr, "XMMI2_FP_Emulation () INTERNAL XMMI2_FP_Emulation ()"
            " ERROR for CMPPS/CMPSS\n");
#endif

      }

      XmmiEnv->Ieee->Result.OperandValid = 1;
      XmmiEnv->Ieee->Result.Value.Fp64Value = *((double *)&cmp_res); 
          // may make U32Value

      XmmiEnv->Ieee->Status.Inexact = 0;
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      // Note that the denormal flag will not be updated by _fpieee_flt (),
      // even if an operand is denormal
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 13: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_COMISD:
    case OP_UCOMISD:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp64Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp64Value;
      if (XmmiEnv->Daz) {
        if (isdenormald (opd1)) opd1 = opd1 * 0.0;
        if (isdenormald (opd2)) opd2 = opd2 * 0.0;
      }

      // check whether an invalid exception has to be raised

      switch (XmmiEnv->Ieee->Operation) {

        case OP_COMISD:

          if (isnand (opd1) || isnand (opd2)) {
              invalid_exc = 1;
          } else
              invalid_exc = 0;
          break;

        case OP_UCOMISD:

          if (issnand (opd1) || issnand (opd2))
              invalid_exc = 1;
          else
              invalid_exc = 0;
          // guard against the case when an SNaN operand was converted to 
          // QNaN by compiler generated code
          sw = _status87 ();
          if (sw & _SW_INVALID) invalid_exc = 1;
          break;

        default:
          ; // will never occur

      }

      // adjust operation code
      XmmiEnv->Ieee->Operation = _FpCodeCompare;

      // if invalid_exc = 1, and invalid exceptions are enabled, take trap
      if (invalid_exc && !(XmmiEnv->Masks & I_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

        // Note: the calling function will have to interpret the value returned
        // by the user handler, if execution is to be continued

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 14: in_top =%d != out_top = "
              "%d\n", in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // EFlags:
      // 333222222222211111111110000000000
      // 210987654321098765432109876543210
      //                      O   SZ A P C

      // checking for NaN operands has priority over denormal exceptions
      if (isnand (opd1) || isnand (opd2)) {


        // OF, SF, AF = 000, ZF, PF, CF = 111
        XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff76f) | 0x00000045;

        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        // Note that the denormal flag will not be updated by _fpieee_flt (),
        // even if an operand is denormal
        if (invalid_exc) {
          XmmiEnv->Ieee->Status.InvalidOperation = 1;
          XmmiEnv->Flags |= I_MASK;
        } else {
          XmmiEnv->Ieee->Status.InvalidOperation = 0;
        }

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 15: in_top =%d != out_top = "
              "%d\n", in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);

      }

      // check whether a denormal exception has to be raised

      if (isdenormald (opd1) || isdenormald (opd2)) {
          denormal_exc = 1;
          XmmiEnv->Flags |= D_MASK;
      } else {
          denormal_exc = 0;
      }

      // if denormal_exc = 1, and denormal exceptions are enabled, take trap
      if (denormal_exc && !(XmmiEnv->Masks & D_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 16: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // no exception has to be raised, and no operand is a NaN; calculate 
      // and deliver the result

      // 333222222222211111111110000000000
      // 210987654321098765432109876543210
      //                      O   SZ A P C

      if (opd1 > opd2) {

        // OF, SF, AF = 000, ZF, PF, CF = 000
        XmmiEnv->EFlags = XmmiEnv->EFlags & 0xfffff72a;

      } else if (opd1 < opd2) {

        // OF, SF, AF = 000, ZF, PF, CF = 001
        XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff72b) | 0x00000001;

      } else if (opd1 == opd2) {

        // OF, SF, AF = 000, ZF, PF, CF = 100
        XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff76a) | 0x00000040;

      } else { // could eliminate this case

#ifdef _DEBUG_FPU
        fprintf (stderr, "XMMI2_FP_Emulation () INTERNAL XMMI2_FP_Emulation () "
            "ERROR for COMISS/UCOMISS\n");
#endif

      }

      XmmiEnv->Ieee->Status.Inexact = 0;
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      // Note that the denormal flag will not be updated by _fpieee_flt (),
      // even if an operand is denormal
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 17: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CVTDQ2PS:

      iopd1 = XmmiEnv->Ieee->Operand1.Value.I32Value;

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      // execute the operation and check whether the inexact flag is set
      // and the respective exception is enabled

      _control87 (rc | _PC_24 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the conversion
      __asm {
        fnclex; 
        fild  DWORD PTR iopd1; // exact
        fstp  DWORD PTR res24; // may set P
      }
 
      // read status word
      sw = _status87 ();

      // if inexact traps are enabled and result is inexact, take inexact trap
      if (!(XmmiEnv->Masks & P_MASK) && (sw & _SW_INEXACT)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Operation = _FpCodeConvert;
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp32Value = res24; // exact

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 18: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if it got here, then there is no trap to be taken; in this case, 
      // the result has to be delivered

      XmmiEnv->Ieee->Result.OperandValid = 1;
      XmmiEnv->Ieee->Result.Value.Fp32Value = res24; // exact

      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 19: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CVTPS2DQ:
    case OP_CVTTPS2DQ:

      opd24 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd24)) opd24 = opd24 * (float)0.0;
      }

      // adjust the operation code
      switch (XmmiEnv->Ieee->Operation) {

        case OP_CVTPS2DQ:

          XmmiEnv->Ieee->Operation = _FpCodeConvert;
          break;

        case OP_CVTTPS2DQ:

          XmmiEnv->Ieee->Operation = _FpCodeConvertTrunc;
          break;

        default:
          ; // will never occur

      }

      switch (XmmiEnv->Ieee->Operation) {

        case _FpCodeConvert:

          switch (XmmiEnv->Rc) {
            case _FpRoundNearest:
              rc = _RC_NEAR;
              break;
            case _FpRoundMinusInfinity:
              rc = _RC_DOWN;
              break;
            case _FpRoundPlusInfinity:
              rc = _RC_UP;
              break;
            case _FpRoundChopped:
              rc = _RC_CHOP;
              break;
            default:
              ; // internal error
          }

          break;

        case _FpCodeConvertTrunc:

          rc = _RC_CHOP;
          break;

        default:
          ; // will never occur

      }

      // execute the operation and check whether the inexact flag is set
      // and the respective exceptions enabled

      _control87 (rc | _PC_24 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the conversion
      __asm {
        fnclex; 
        fld DWORD PTR opd24; // may set the denormal [ignored] or invalid
                             // status flags
        fistp DWORD PTR ires; // may set the inexact or invalid status
                               // flags (for NaN or out-of-range)
      }

      // read status word
      sw = _status87 ();

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 20: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // at this point, there are no enabled invalid exceptions; the
      // instruction might have lead to an enabled inexact exception, or to
      // no exception at all

      XmmiEnv->Ieee->Result.Value.I32Value = ires;

      // if inexact traps are enabled and result is inexact, take inexact trap
      // (no flush-to-zero situation is possible)
      if (!(XmmiEnv->Masks & P_MASK) && (sw & _SW_INEXACT)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 21: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if it got here, then there is no trap to be taken; return result

      XmmiEnv->Ieee->Result.OperandValid = 1;

      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      if (sw & _SW_INVALID) {
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
      } else {
        XmmiEnv->Ieee->Status.InvalidOperation = 0;
      }

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 22: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CVTPD2PI:
    case OP_CVTSD2SI:
    case OP_CVTPD2DQ:
    case OP_CVTTPD2PI:
    case OP_CVTTSD2SI:
    case OP_CVTTPD2DQ:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp64Value;
      if (XmmiEnv->Daz) {
        if (isdenormald (opd1)) opd1 = opd1 * 0.0;
      }

      // adjust the operation code
      switch (XmmiEnv->Ieee->Operation) {

        case OP_CVTPD2PI:
        case OP_CVTSD2SI:
        case OP_CVTPD2DQ:

          XmmiEnv->Ieee->Operation = _FpCodeConvert;
          break;

        case OP_CVTTPD2PI:
        case OP_CVTTSD2SI:
        case OP_CVTTPD2DQ:

          XmmiEnv->Ieee->Operation = _FpCodeConvertTrunc;
          break;

        default:
          ; // will never occur

      }

      switch (XmmiEnv->Ieee->Operation) {

        case _FpCodeConvert:

          switch (XmmiEnv->Rc) {
            case _FpRoundNearest:
              rc = _RC_NEAR;
              break;
            case _FpRoundMinusInfinity:
              rc = _RC_DOWN;
              break;
            case _FpRoundPlusInfinity:
              rc = _RC_UP;
              break;
            case _FpRoundChopped:
              rc = _RC_CHOP;
              break;
            default:
              ; // internal error
          }

          break;

        case _FpCodeConvertTrunc:

          rc = _RC_CHOP;
          break;

        default:
          ; // will never occur

      }

      // execute the operation and check whether the inexact flag is set
      // and the respective exceptions enabled

      _control87 (rc | _PC_53 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the conversion
      __asm {
        fnclex; 
        fld  QWORD PTR opd1; // may set the denormal [ignored] or invalid
                             // status flags
        fistp  DWORD PTR ires; // may set the inexact or invalid status
                               // flags (for NaN or out-of-range)
      }

      // read status word
      sw = _status87 ();

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 20: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // at this point, there are no enabled invalid exceptions; the
      // instruction might have lead to an enabled inexact exception, or to
      // no exception at all

      XmmiEnv->Ieee->Result.Value.I32Value = ires;

      // if inexact traps are enabled and result is inexact, take inexact trap
      // (no flush-to-zero situation is possible)
      if (!(XmmiEnv->Masks & P_MASK) && (sw & _SW_INEXACT)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 21: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if it got here, then there is no trap to be taken; return result

      XmmiEnv->Ieee->Result.OperandValid = 1;

      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      if (sw & _SW_INVALID) {
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
      } else {
        XmmiEnv->Ieee->Status.InvalidOperation = 0;
      }

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 22: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CVTPS2PD:
    case OP_CVTSS2SD:

      opd24 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd24)) opd24 = opd24 * (float)0.0;
      }

      // adjust the operation code
      XmmiEnv->Ieee->Operation = _FpCodeConvert;

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      // execute the operation and check whether the invalid or denormal 
      // flag is set and the respective exception is enabled

      _control87 (rc | _PC_53 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC); // redun.

      // perform the conversion
      __asm {
        fnclex; 
        fld DWORD PTR opd24; // may set the denormal or invalid
                             // status flags; exact
        fstp QWORD PTR res; // store as a double; exact
      }

      // read status word
      sw = _status87 ();

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 20: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      if (sw & _SW_DENORMAL) XmmiEnv->Flags |= D_MASK; // whether enabled or not

      // if denormal flag is set, and denormal exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & D_MASK) && (sw & _SW_DENORMAL)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 28: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // at this point, there are no enabled invalid or denormal exceptions;
      // the instruction did not lead to an enabled exception; return result

      XmmiEnv->Ieee->Result.Value.Fp64Value = res;
      XmmiEnv->Ieee->Result.OperandValid = 1;

      XmmiEnv->Ieee->Status.Inexact = 0;
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      if (sw & _SW_INVALID) {
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
      } else {
        XmmiEnv->Ieee->Status.InvalidOperation = 0;
      }

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 22: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CVTPD2PS:
    case OP_CVTSD2SS:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp64Value;
      if (XmmiEnv->Daz) {
        if (isdenormald (opd1)) opd1 = opd1 * 0.0;
      }

      // adjust the operation code
      XmmiEnv->Ieee->Operation = _FpCodeConvert;

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      // execute the operation and check whether the invalid or denormal 
      // flag is set and the respective exception is enabled

      _control87 (rc | _PC_24 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the conversion
      __asm {
        fnclex; 
        fld QWORD PTR opd1; // may set the denormal or invalid
                             // status flags; exact
        fstp DWORD PTR res24; // store as a single; may set the underflow/
                              // overflow and/or the inexact status flags
      }

      // read status word
      sw = _status87 ();

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 20: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      if (sw & _SW_DENORMAL) XmmiEnv->Flags |= D_MASK; // whether enabled or not

      // if denormal flag is set, and denormal exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & D_MASK) && (sw & _SW_DENORMAL)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 28: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // done if opd1 is 0.0, inf, or NaN
      if (isnand (opd1) || isinfd (opd1) || iszerod (opd1)) {
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp32Value = res24;
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        if (sw & _SW_INVALID) {
          XmmiEnv->Ieee->Status.InvalidOperation = 1;
          XmmiEnv->Flags |= I_MASK;
        } else {
          XmmiEnv->Ieee->Status.InvalidOperation = 0;
        }
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 5: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);
      }

      // at this point, there are no enabled I, or D exceptions, and the input
      // operand is not 0, infinity, or NaN; the instruction
      // might lead to an enabled underflow, enabled underflow and inexact,
      // enabled overflow, enabled overflow and inexact, enabled inexact, or
      // none of these; if there are no U or O enabled exceptions, the result
      // is res24

      // check whether there is an underflow, overflow, or inexact trap to be
      // taken

      // calculate the result to 24 bits, with 'unbounded' exponent
      __asm {
        fnclex;
        fld QWORD PTR opd1; // may set the denormal or invalid
                             // status flags (same as above)
        fld1; // +1.0
        fmulp st(1), st(0); // rounded to 24 bits; may set P
        fstp QWORD PTR dbl_res24; // store as a double; may set the underflow/
                              // overflow and/or the inexact status flags,
                              // but no new trap flags are set here
      }

      if (-MIN_SINGLE_NORMAL < dbl_res24 && dbl_res24 < MIN_SINGLE_NORMAL) {
        result_tiny = 1;
      }

      // check if the result is huge
      if (dbl_res24 < -MAX_SINGLE_NORMAL || MAX_SINGLE_NORMAL < dbl_res24) {
        result_huge = 1;
      }

      // if the underflow traps are enabled and the result is tiny, take
      // underflow trap
      if (!(XmmiEnv->Masks & U_MASK) && result_tiny) {
        // leave source and destination operands unchanged
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
        XmmiEnv->Ieee->Cause.Underflow = 1;
        XmmiEnv->Ieee->Result.OperandValid = 0;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 6: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      }

      // if overflow traps are enabled and the result is huge, take
      // overflow trap
      if (!(XmmiEnv->Masks & O_MASK) &&  result_huge) {
        // leave source and destination operands unchanged
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Overflow = 1;
        XmmiEnv->Flags |= O_MASK;
        XmmiEnv->Ieee->Cause.Overflow = 1;
        XmmiEnv->Ieee->Result.OperandValid = 0;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 7: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      }


      // at this point, there are no enabled exceptions, or an enabled 
      // inexact exception; return the result from res24

      // if inexact traps are enabled and result is inexact, take inexact trap
      if (!(XmmiEnv->Masks & P_MASK) &&
          ((sw & _SW_INEXACT) || (XmmiEnv->Fz && result_tiny))) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        if (result_tiny) {
          XmmiEnv->Ieee->Status.Underflow = 1;
          XmmiEnv->Flags |= U_MASK;
          // Note: the condition above is equivalent to
          // if (sw & _SW_UNDERFLOW) XmmiEnv->Ieee->Status.Underflow = 1;
        }
        if (result_huge) {
          XmmiEnv->Ieee->Status.Overflow = 1;
          XmmiEnv->Flags |= O_MASK;
          // Note: the condition above is equivalent to
          // if (sw & _SW_OVERFLOW) XmmiEnv->Ieee->Status.Overflow = 1;
        }

        // if ftz = 1 and result is tiny, result = 0.0
        // (no need to check for underflow traps disabled: result tiny and
        // underflow traps enabled would have caused taking an underflow
        // trap above)
        if (XmmiEnv->Fz && result_tiny) {
            // Note: the condition above is equivalent to
            // if (XmmiEnv->Fz && (sw & _SW_UNDERFLOW))
          if (res24 > 0.0) // it might already be +0.0 from fmulp and/or fstp
            res24 = ZEROF;
          else if (res24 < 0.0) // it might already be -0.0 from fmulp/fstp
            res24 = NZEROF;
          // else leave res24 unchanged
        }

        XmmiEnv->Ieee->Result.Value.Fp32Value = res24;
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 8: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      }

      // if it got here, then there is no trap to be taken
 
      XmmiEnv->Ieee->Result.OperandValid = 1;

      if (sw & _SW_UNDERFLOW) {
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
      } else {
        XmmiEnv->Ieee->Status.Underflow = 0;
      }
      if (sw & _SW_OVERFLOW) {
        XmmiEnv->Ieee->Status.Overflow = 1;
        XmmiEnv->Flags |= O_MASK;
      } else {
        XmmiEnv->Ieee->Status.Overflow = 0;
      }
      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }

      // if ftz = 1, and result is tiny (underflow traps must be disabled),
      // result = 0.0
      if (XmmiEnv->Fz && result_tiny) {
        if (res24 > 0.0)
          res24 = ZEROF;
        else if (res24 < 0.0)
          res24 = NZEROF;
        // else leave res24 unchanged

        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
      }
      XmmiEnv->Ieee->Result.Value.Fp32Value = res24;

      // note that there is no way to
      // communicate to the caller that the denormal flag was set - we count
      // on the XMMI instruction to have set the denormal flag in MXCSR if
      // needed, regardless of the other components of the input operands
      // (invalid or not; the caller will have to update the underflow,
      // overflow, and inexact flags in MXCSR)
      if (sw & _SW_INVALID) {
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
      } else {
        XmmiEnv->Ieee->Status.InvalidOperation = 0;
      }

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 9: in_top =%d != out_top = %d\n",
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);
      break;

    case OP_MAXPD:
    case OP_MAXSD:
    case OP_MINPD:
    case OP_MINSD:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp64Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp64Value;
      if (XmmiEnv->Daz) {
        if (isdenormald (opd1)) opd1 = opd1 * 0.0;
        if (isdenormald (opd2)) opd2 = opd2 * 0.0;
      }

      // adjust operation code
      switch (XmmiEnv->Ieee->Operation) {

        case OP_MAXPD:
        case OP_MAXSD:
          XmmiEnv->Ieee->Operation = _FpCodeFmax;
          break;

        case OP_MINPD:
        case OP_MINSD:
          XmmiEnv->Ieee->Operation = _FpCodeFmin;
          break;

        default:
          ; // will never occur

      }

      // check whether an invalid exception has to be raised

      if (isnand (opd1) || isnand (opd2))
          invalid_exc = 1;
      else
          invalid_exc = 0;

      // if invalid_exc = 1, and invalid exceptions are enabled, take trap
      if (invalid_exc && !(XmmiEnv->Masks & I_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 23: in_top =%d != out_top = "
              "%d\n", in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // checking for NaN operands has priority over denormal exceptions

      if (invalid_exc) {

        XmmiEnv->Ieee->Result.OperandValid = 1;

        XmmiEnv->Ieee->Result.Value.Fp64Value = opd2;
  
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
  
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 24: in_top =%d != out_top = "
             "%d\n", in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);

      }

      // check whether a denormal exception has to be raised

      if (isdenormald (opd1) || isdenormald (opd2)) {
          denormal_exc = 1;
          XmmiEnv->Flags |= D_MASK;
      } else {
          denormal_exc = 0;
      }

      // if denormal_exc = 1, and denormal exceptions are enabled, take trap
      if (denormal_exc && !(XmmiEnv->Masks & D_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 25: in_top =%d != out_top = "
             "%d\n", in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // no exception has to be raised, and no operand is a NaN; calculate 
      // and deliver the result

      if (opd1 < opd2) {

        switch (XmmiEnv->Ieee->Operation) {
          case _FpCodeFmax:
            XmmiEnv->Ieee->Result.Value.Fp64Value = opd2;
            break;
          case _FpCodeFmin:
            XmmiEnv->Ieee->Result.Value.Fp64Value = opd1;
            break;
          default:
            ; // will never occur
        }

      } else if (opd1 > opd2) {

        switch (XmmiEnv->Ieee->Operation) {
          case _FpCodeFmax:
            XmmiEnv->Ieee->Result.Value.Fp64Value = opd1;
            break;
          case _FpCodeFmin:
            XmmiEnv->Ieee->Result.Value.Fp64Value = opd2;
            break;
          default:
            ; // will never occur
        }

      } else if (opd1 == opd2) {

        XmmiEnv->Ieee->Result.Value.Fp64Value = opd2;

      } else { // could eliminate this case

#ifdef _DEBUG_FPU
        fprintf (stderr, 
            "XMMI2_FP_Emulation () INTERNAL XMMI2_FP_Emulation () ERROR for MAXPS/MAXSS/MINPS/MINSS\n");
#endif

      }

      XmmiEnv->Ieee->Result.OperandValid = 1;

      XmmiEnv->Ieee->Status.Inexact = 0;
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      // Note that the denormal flag will not be updated by _fpieee_flt (),
      // even if an operand is denormal
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 26: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_SQRTPD:
    case OP_SQRTSD:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp64Value;
      if (XmmiEnv->Daz) {
        if (isdenormald (opd1)) opd1 = opd1 * 0.0;
      }

      // adjust operation code
      XmmiEnv->Ieee->Operation = _FpCodeSquareRoot;

      // execute the operation and check whether the invalid, denormal, or 
      // inexact flags are set and the respective exceptions enabled

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      _control87 (rc | _PC_53 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the square root
      __asm {
        fnclex; 
        fld  QWORD PTR opd1; // may set the denormal or invalid status flags
        fsqrt; // may set the inexact or invalid status flags
        fstp  QWORD PTR res; // exact
      }
 
      // read status word
      sw = _status87 ();
      if (sw & _SW_INVALID) sw = sw & ~0x00080000; // clr D flag for sqrt(-den)

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 27: in_top =%d != out_top = "
              "%d\n", in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      if (sw & _SW_DENORMAL) XmmiEnv->Flags |= D_MASK;

      // if denormal flag is set, and denormal exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & D_MASK) && (sw & _SW_DENORMAL)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 28: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // the result cannot be tiny

      // at this point, there are no enabled I or D or exceptions; the instr.
      // might lead to an enabled inexact exception or to no exception (this
      // includes the case of a NaN or negative operand); exceptions must have 
      // been disabled before calling this function; an inexact exception is
      // reported on the fsqrt

      // if (the MXCSR inexact traps are disabled or the inexact flag is clear)
      // then deliver the result (the status flags are sticky, so they are
      // all set correctly already)
 
      // if it got here, then there is either an inexact trap to be taken, or
      // no trap at all

      XmmiEnv->Ieee->Result.Value.Fp64Value = res; // exact

      // if inexact traps are enabled and result is inexact, take inexact trap
      if (!(XmmiEnv->Masks & P_MASK) && (sw & _SW_INEXACT)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 29: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // no trap was taken

      XmmiEnv->Ieee->Result.OperandValid = 1;
 
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }

      // note that there is no way to
      // communicate to the caller that the denormal flag was set - we count
      // on the XMMI instruction to have set the denormal flag in MXCSR if
      // needed, regardless of the other components of the input operands
      // (invalid or not); the caller will have to update the inexact flag
      // in MXCSR
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      if (sw & _SW_INVALID) {
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags = I_MASK; // no other flags set if invalid is set
      } else {
        XmmiEnv->Ieee->Status.InvalidOperation = 0;
      }

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 30: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_UNSPEC:

#ifdef _DEBUG_FPU
      fprintf (stderr, 
         "XMMI2_FP_Emulation internal error: unknown operation code OP_UNSPEC\n");
#endif

      break;

    default:
#ifdef _DEBUG_FPU
      fprintf (stderr, 
          "XMMI2_FP_Emulation internal error: unknown operation code %d\n", 
          XmmiEnv->Ieee->Operation);
#endif
      break;
  }

}


static int
iszerod (double d)

{

  unsigned int *dp;

  dp = (unsigned int *)&d;

  if (((dp[1] & 0x7fffffff) == 0x0) && (dp[0] == 0x0))
    return (1);
  else
    return (0);

}


static int
isinfd (double d)

{

  unsigned int *dp;

  dp = (unsigned int *)&d;

  if (((dp[1] & 0x7fffffff) == 0x7ff80000) && (dp[0] == 0x0))
    return (1);
  else
    return (0);

}


static int
issnand (double d)

{

  unsigned int *dp;

  dp = (unsigned int *)&d;

  if (((dp[1] & 0x7ff80000) == 0x7ff00000) && 
      (((dp[1] & 0x0007ffff) != 0) || (dp[0] != 0)))
    return (1);
  else
    return (0);

}


static int
isnand (double d)

{

  unsigned int *qp;

  qp = (unsigned int *)&d;

  if (((qp[1] & 0x7ff00000) == 0x7ff00000) &&
      (((qp[1] & 0x000fffff) != 0x00000000) || qp[0] != 0x00000000))
    return (1);
  else
    return (0);

}


static double
quietd (double d)

{

  // makes a signaling NaN quiet, and leaves a quiet NaN unchanged; does
  // not check that the input value d is a NaN

  unsigned int *dp;

  dp = (unsigned int *)&d;

  dp[1] = dp[1] | 0x00080000;
  return (d);

}


static int
isdenormald (double d)

{

  unsigned int *dp;

  dp = (unsigned int *)&d;

  if (((dp[1] & 0x7ff00000) == 0x0) && 
      (((dp[1] & 0x000fffff) != 0) || (dp[0] != 0)))
    return (1);
  else
    return (0);

}


static int
isdenormalf (float f)

{

  // checks whether f is a denormal

  unsigned int *fp;

  fp = (unsigned int *)&f;

  if ((fp[0] & 0x7f800000) == 0x0 && (fp[0] & 0x007fffff) != 0x0)
    return (1);
  else
    return (0);

}


static void Fill_FPIEEE_RECORD (PXMMI_ENV XmmiEnv)

{

  // fill in part of the FP IEEE record

  XmmiEnv->Ieee->RoundingMode = XmmiEnv->Rc;
  XmmiEnv->Ieee->Precision = XmmiEnv->Precision;
  XmmiEnv->Ieee->Enable.Inexact = !(XmmiEnv->Masks & P_MASK);
  XmmiEnv->Ieee->Enable.Underflow = !(XmmiEnv->Masks & U_MASK);
  XmmiEnv->Ieee->Enable.Overflow = !(XmmiEnv->Masks & O_MASK);
  XmmiEnv->Ieee->Enable.ZeroDivide = !(XmmiEnv->Masks & Z_MASK);
  XmmiEnv->Ieee->Enable.InvalidOperation = !(XmmiEnv->Masks & I_MASK);
  XmmiEnv->Ieee->Status.Inexact = 0;
  XmmiEnv->Ieee->Status.Underflow = 0;
  XmmiEnv->Ieee->Status.Overflow = 0;
  XmmiEnv->Ieee->Status.ZeroDivide = 0;
  XmmiEnv->Ieee->Status.InvalidOperation = 0;
  // Cause = Enable & Status
  XmmiEnv->Ieee->Cause.Inexact = 0;
  XmmiEnv->Ieee->Cause.Underflow = 0;
  XmmiEnv->Ieee->Cause.Overflow = 0;
  XmmiEnv->Ieee->Cause.ZeroDivide = 0;
  XmmiEnv->Ieee->Cause.InvalidOperation = 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\xmmi_fp_emul.c ===
/*****************************************************************************
 *                                                                           *
 *                           Intel Confidential                              *
 *                                                                           *
 *                                                                           *
 * XMMI_FP_emulate () - XMMI FP instruction emulation for the FP IEEE filter *
 *                                                                           *
 *                                                                           *
 * History:                                                                  *
 *    Marius Cornea-Hasegan, Mar 1998; modified Jun 1998; added DAZ Oct 2000 *
 *    marius.cornea@intel.com                                                *
 *                                                                           *
 *****************************************************************************/

// #define _DEBUG_FPU
// #define _XMMI_DEBUG

// XMMI_FP_Emulation () receives the input operands of a XMMI FP instruction 
// (operating on single-precision floating-point numbers and/or signed 
// integers), that might cause a floating-point exception (enabled or not).
//
// Arguments: PXMMI_ENV XmmiEnv
//
//  The type of every field (INPUT or OUTPUT) is indicated below:
//
//  typedef struct _XMMI_ENV {
//      ULONG Masks;                  //Mask values from MxCsr   INPUT
//      ULONG Fz;                     //Flush to Zero            INPUT
//      ULONG Rc;                     //Rounding                 INPUT
//      ULONG Precision;              //Precision                INPUT
//      ULONG Imm8;                   //imm8 predicate           INPUT
//      ULONG EFlags;                 //EFlags                   INPUT/OUTPUT
//      _FPIEEE_RECORD *Ieee;         //FP IEEE Record           INPUT/OUTPUT,
//                                                               field dependent
//  } XMMI_ENV, *PXMMI_ENV;
// 
//  The _FP_IEEE record and the _FPIEEE_VALUE are defined as:
//  
//  typedef struct {
//      unsigned int RoundingMode : 2;                   OUTPUT
//      unsigned int Precision : 3;                      OUTPUT
//      unsigned int Operation :12;                      INPUT
//      _FPIEEE_EXCEPTION_FLAGS Cause;                   OUTPUT
//      _FPIEEE_EXCEPTION_FLAGS Enable;                  OUTPUT
//      _FPIEEE_EXCEPTION_FLAGS Status;                  OUTPUT
//      _FPIEEE_VALUE Operand1;                          INPUT
//      _FPIEEE_VALUE Operand2;                          INPUT
//      _FPIEEE_VALUE Result;                            INPUT/OUTPUT,
//                                                       field dependent
//  } _FPIEEE_RECORD, *_PFPIEEE_RECORD;
//  
//  typedef struct {
//      union {
//          _FP32    Fp32Value;
//          _FP64    Fp64Value;
//          _FP80    Fp80Value;
//          _FP128   Fp128Value;
//          _I16     I16Value;
//          _I32     I32Value;
//          _I64     I64Value;
//          _U16     U16Value;
//          _U32     U32Value;
//          _U64     U64Value;
//          _BCD80   Bcd80Value;
//          char     *StringValue;
//          int      CompareValue;
//      } Value;                                         INPUT for operands,
//                                                       OUTPUT for result
//
//      unsigned int OperandValid : 1;                   INPUT for operands
//                                                       INPUT/OUTPUT for result
//      unsigned int Format : 4;                         INPUT
//  
//  } _FPIEEE_VALUE;
//
// Return Value: 
//   ExceptionRaised if an enabled floating-point exception condition is 
//       detected; in this case, the fields of XmmiEnv->Ieee are filled in
//       appropriately to be passed directly to a user exception handler; the
//       XmmiEnv->Ieee->Cause bits indicate the cause of the exception, but if
//       a denormal exception occurred, then no XmmiEnv->Ieee->Cause bit is set;
//       upon return from the user handler, the caller of XMMI_FP_emulate should
//       interpret the result for a compare instruction (CMPPS, CMPPS, COMISS,
//       UCOMISS); the Enable, Rounding, and Precision fields in _FPIEEE_RECORD
//       have to be checked too for possible changes by the user handler
//      
//   NoExceptionRaised if no floating-point exception condition occurred, or
//       if a disabled floating-point exception occurred; in this case,
//       XmmiEnv->Ieee->Result.Value contains the instruction's result, 
//       XmmiEnv->Ieee->Status contains the IEEE floating-point status flags
//
// Implementation Notes:
//
//   - the operation code in XmmiEnv->Ieee->Operation is changed as expected
//     by a user exception handler (even if no exception is raised):
//     from OP_ADDPS, OP_ADDSS to _FpCodeAdd
//     from OP_SUBPS, OP_SUBSS to _FpCodeSubtract
//     from OP_MULPS, OP_MULSS to _FpCodeMultiply
//     from OP_DIVPS, OP_DIVSS to _FpCodeDivide
//     from OP_CMPPS, OP_CMPSS to _FpCodeCompare
//     from OP_COMISS, OP_UCOMISS to _FpCodeCompare
//     from OP_CVTPI2PS, OP_CVTSI2SS to _FpCodeConvert
//     from OP_CVTPS2PI, OP_CVTSS2SI to _FpCodeConvert
//     from OP_CVTTPS2PI, OP_CVTTSS2SI to _FpCodeConvertTrunc
//     from OP_MAXPS, OP_MAXSS to _FpCodeMax
//     from OP_MINPS, OP_MINSS to _FpCodeMin
//     from OP_SQRTPS, OP_SQRTSS to _FpCodeSquareRoot
//
//
//   - for ADDPS, ADDSS, SUBPS, SUBSS, MULPS, MULSS, DIVPS, DIVSS:
//
//     - execute the operation with x86 instructions (fld, 
//       faddp/fsubp/fmulp/fdivp, and fstp), using the user
//       rounding mode, 24-bit significands, and 11-bit exponents for results
//     - if the invalid flag is set and the invalid exceptions are enabled, 
//       take an invalid trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately)
//     - if any input operand is a NaN:
//       - if both operands are NaNs, return the first operand ("quietized" 
//         if SNaN)
//       - if only one operand is a NaN, return it ("quietized" if SNaN)
//       - set the invalid flag if needed, and return NoExceptionRaised
//     - if the denormal flag is set and the denormal exceptions are enabled, 
//       take a denormal trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately [no Cause bit set])
//     - if the divide by zero flag is set (for DIVPS and DIVSS only) and the
//       divide by zero exceptions are enabled, take a divide by zero trap 
//       (i.e. return RaiseException with the IEEE record filled out 
//       appropriately)
//     - if the result is a NaN (QNaN Indefinite), the operation must have been
//       Inf - Inf, Inf * 0, Inf / Inf, or 0 / 0; set the invalid status flag
//       and return NoExceptionRaised
//     - determine whether the result is tiny or huge
//     - if the underflow traps are enabled and the result is tiny, take an
//       underflow trap (i.e. return RaiseException with the IEEE record 
//       filled out appropriately)
//     - if the overflow traps are enabled and the result is huge, take an
//       overflow trap (i.e. return RaiseException with the IEEE record 
//       filled out appropriately)
//     - re-do the operation with x86 instructions, using the user rounding
//       mode, 53-bit significands, and 11-bit exponents for results (this will
//       allow rounding to 24 bits without a double rounding error - needed for
//       the case the result requires denormalization) [cannot denormalize
//       without a possible double rounding error starting from a 24-bit
//       significand]
//     - round to 24 bits (or to less than 24 bits if denormalization is 
//       needed), for the case an inexact trap has to be taken, or if no
//       exception occurs
//     - if the result is inexact and the inexact exceptions are enabled, 
//       take an inexact trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately); if the flush-to-zero mode is enabled and
//       the result is tiny, the result is flushed to zero
//     - if no exception has to be raised, the flush-to-zero mode is enabled,
//       and the result is tiny, then the result is flushed to zero; set the 
//       status flags and return NoExceptionRaised
//
//   - for CMPPS, CMPSS
//
//     - for EQ, UNORD, NEQ, ORD, SNaN operands signal invalid
//     - for LT, LE, NLT, NLE, QNaN/SNaN operands (one or both) signal invalid
//     - if the invalid exception condition is met and the invalid exceptions
//       are enabled, take an invalid trap (i.e. return RaiseException with the
//       IEEE record filled out appropriately)
//     - if any operand is a NaN and the compare type is EQ, LT, LE, or ORD, 
//       set the result to "false", set the value of the invalid status flag,
//       and return NoExceptionRaised
//     - if any operand is a NaN and the compare type is NEQ, NLT, NLE, or
//       UNORD, set the result to "false", set the value of the invalid status 
//       flag, and return NoExceptionRaised
//     - if any operand is denormal and the denormal exceptions are enabled, 
//       take a denormal trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately [no Cause bit set])
//     - if no exception has to be raised, determine the result and return
//       NoExceptionRaised
//
//   - for COMISS, UCOMISS
//
//     - for COMISS, QNaN/SNaN operands (one or both) signal invalid
//     - for UCOMISS, SNaN operands (one or both) signal invalid
//     - if the invalid exception condition is met and the invalid exceptions
//       are enabled, take invalid trap (i.e. return RaiseException with the
//       IEEE record filled out appropriately)
//     - if any operand is a NaN, set OF, SF, AF = 000, ZF, PF, CF = 111,
//       set the value of the invalid status flag, and return NoExceptionRaised
//     - if any operand is denormal and the denormal exceptions are enabled, 
//       take a denormal trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately [no Cause bit set])
//     - if no exception has to be raised, determine the result and set EFlags,
//       set the value of the invalid status flag, and return NoExceptionRaised
//
//   - for CVTPI2PS, CVTSI2SS
//
//     - execute the operation with x86 instructions (fild and fstp), using the
//       user rounding mode, 24-bit significands, and an 8-bit exponent for
//       the result
//     - if the inexact flag is set and the inexact exceptions are enabled, 
//       set the result and take an inexact trap (i.e. return RaiseException
//       with the IEEE record filled out appropriately)
//     - if no exception has to be raised, set the result, the value of the
//       inexact status flag and return NoExceptionRaised
//
//   - for CVTPS2PI, CVTSS2SI, CVTTPS2PI, CVTTSS2SI
//
//     - execute the operation with x86 instructions (fld and fistp), using
//       the user rounding mode for CVT* and chop for CVTT*
//     - if the invalid flag is set and the invalid exceptions are enabled, 
//       take an invalid trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately) [the invalid operation condition occurs for 
//       any input operand that does not lead through conversion to a valid
//       32-bit signed integer; the result is in such cases the Integer
//       Indefinite value]
//     - set the result value
//     - if the inexact flag is set and the inexact exceptions are enabled, 
//       take an inexact trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately)
//     - if no exception has to be raised, set the value of the invalid status
//       flag and of the inexact status flag and return NoExceptionRaised
//
//   - for MAXPS, MAXSS, MINPS, MINSS
//
//     - check for invalid exception (QNaN/SNaN operands signal invalid)
//     - if the invalid exception condition is met and the invalid exceptions
//       are enabled, take an invalid trap (i.e. return RaiseException with the
//       IEEE record filled out appropriately)
//     - if any operand is a NaN, set the result to the value of the second 
//       operand, set the invalid status flag to 1, and return NoExceptionRaised
//     - if any operand is denormal and the denormal exceptions are enabled, 
//       take a denormal trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately [no Cause bit set])
//     - if no exception has to be raised, determine the result and return
//       NoExceptionRaised
//
//   - for SQRTPS, SQRTSS
//
//     - execute the operation with x86 instructions (fld, fsqrt, and fstp),
//       using the user rounding mode, 24-bit significands, and an 8-bit
//       exponent for the result
//     - if the invalid flag is set and the invalid exceptions are enabled, 
//       take an invalid trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately)
//     - if the denormal flag is set and the denormal exceptions are enabled, 
//       take a denormal trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately [no Cause bit set])
//     - if the result is inexact and the inexact exceptions are enabled, 
//       take an inexact trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately)
//     - if no exception has to be raised, set the status flags and return
//       NoExceptionRaised
//


#include <wtypes.h>
#include <trans.h>
#include <float.h>
#include "xmmi_types.h"
#include "filter.h"
#ifdef _XMMI_DEBUG
#include "temp_context.h"
#include "debug.h"
#endif

// masks for individual status word bits
#define P_MASK 0x20
#define U_MASK 0x10
#define O_MASK 0x08
#define Z_MASK 0x04
#define D_MASK 0x02
#define I_MASK 0x01


// 32-bit constants
static unsigned ZEROFA[] = {0x00000000};
#define  ZEROF *(float *) ZEROFA
static unsigned NZEROFA[] = {0x80000000};
#define  NZEROF *(float *) NZEROFA
static unsigned POSINFFA[] = {0x7f800000};
#define POSINFF *(float *)POSINFFA
static unsigned NEGINFFA[] = {0xff800000};
#define NEGINFF *(float *)NEGINFFA

#ifdef _XMMI_DEBUG
static unsigned QNANINDEFFA[] = {0xffc00000};
#define QNANINDEFF *(float *)QNANINDEFFA
#endif


// 64-bit constants
static unsigned MIN_SINGLE_NORMALA [] = {0x00000000, 0x38100000}; 
    // +1.0 * 2^-126
#define MIN_SINGLE_NORMAL *(double *)MIN_SINGLE_NORMALA
static unsigned MAX_SINGLE_NORMALA [] = {0xe0000000, 0x47efffff}; 
    // +1.1...1*2^127
#define MAX_SINGLE_NORMAL *(double *)MAX_SINGLE_NORMALA
static unsigned TWO_TO_192A[] = {0x00000000, 0x4bf00000};
#define TWO_TO_192 *(double *)TWO_TO_192A
static unsigned TWO_TO_M192A[] = {0x00000000, 0x33f00000};
#define TWO_TO_M192 *(double *)TWO_TO_M192A


// auxiliary functions
static void Fill_FPIEEE_RECORD (PXMMI_ENV XmmiEnv);
static int issnanf (float f);
static int isnanf (float f);
static float quietf (float f);
static int isdenormalf (float f);



ULONG
XMMI_FP_Emulation (PXMMI_ENV XmmiEnv)

{

  float opd1, opd2, res;
  int iopd1; // for conversions from int to float
  int ires; // for conversions from float to int
  double dbl_res24; // needed to check tininess, to provide a scaled result to
      // an underflow/overflow trap handler, and in flush-to-zero
  unsigned int result_tiny;
  unsigned int result_huge;
  unsigned int rc, sw;
  unsigned long imm8;
  unsigned int invalid_exc;
  unsigned int denormal_exc;
  unsigned int cmp_res;


  // Note that ExceptionCode is always STATUS_FLOAT_MULTIPLE_FAULTS in the
  // calling routine, so we have to check first for faults, and then for traps


#ifdef _DEBUG_FPU
  unsigned int in_top;
  unsigned int out_top;
  char fp_env[108];
  unsigned short int *control_word, *status_word, *tag_word;

  // read status word
  sw = _status87 ();
  in_top = (sw >> 11) & 0x07;
  if (in_top != 0x0) printf ("XMMI_FP_Emulate WARNING: in_top = %d\n", in_top);
  __asm {
    fnsave fp_env;
  }
  control_word = (unsigned short *)fp_env;
  status_word = (unsigned short *)(fp_env + 2);
  tag_word = (unsigned short *)(fp_env + 8);
  if (*tag_word != 0xffff) printf ("XMMI_FP_Emulate WARNING: tag_word = %x\n", *tag_word);
#endif

  _asm {
    fninit;
  }

#ifdef _DEBUG_FPU
  // read status word
  sw = _status87 ();
  in_top = (sw >> 11) & 0x07;
  if (in_top != 0x0) 
    printf ("XMMI_FP_Emulate () XMMI_FP_Emulate () ERROR: in_top = %d\n", in_top);
  __asm {
    fnsave fp_env;
  }
  tag_word = (unsigned short *)(fp_env + 8);
  if (*tag_word != 0xffff) {
    printf ("XMMI_FP_Emulate () XMMI_FP_Emulate () ERROR: tag_word = %x\n",
        *tag_word);
    printf ("control, status, tag = %x %x %x %x %x %x\n",
        fp_env[0] & 0xff, fp_env[1] & 0xff, fp_env[4] & 0xff, 
        fp_env[5] & 0xff, fp_env[8] & 0xff, fp_env[9] & 0xff);
  }
#endif


#ifdef _XMMI_DEBUG
  print_FPIEEE_RECORD (XmmiEnv);
#endif

  result_tiny = 0;
  result_huge = 0;

  XmmiEnv->Ieee->RoundingMode = XmmiEnv->Rc;
  XmmiEnv->Ieee->Precision = XmmiEnv->Precision;

  switch (XmmiEnv->Ieee->Operation) {

    case OP_ADDPS:
    case OP_ADDSS:
    case OP_SUBPS:
    case OP_SUBSS:
    case OP_MULPS:
    case OP_MULSS:
    case OP_DIVPS:
    case OP_DIVSS:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd1)) opd1 = opd1 * (float)0.0;
        if (isdenormalf (opd2)) opd2 = opd2 * (float)0.0;
      }

      // adjust operation code
      switch (XmmiEnv->Ieee->Operation) {

        case OP_ADDPS:
        case OP_ADDSS:

          XmmiEnv->Ieee->Operation = _FpCodeAdd;
          break;

        case OP_SUBPS:
        case OP_SUBSS:

          XmmiEnv->Ieee->Operation = _FpCodeSubtract;
          break;

        case OP_MULPS:
        case OP_MULSS:

          XmmiEnv->Ieee->Operation = _FpCodeMultiply;
          break;

        case OP_DIVPS:
        case OP_DIVSS:

          XmmiEnv->Ieee->Operation = _FpCodeDivide;
          break;

        default:
          ; // will never occur

      }

      // execute the operation and check whether the invalid, denormal, or 
      // divide by zero flags are set and the respective exceptions enabled

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      _control87 (rc | _PC_24 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // compute result and round to the destination precision, with
      // "unbounded" exponent (first IEEE rounding)
      switch (XmmiEnv->Ieee->Operation) {

        case _FpCodeAdd:
          // perform the add
          __asm {
            fnclex; 
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal or invalid status flags
            fld  DWORD PTR opd2; // may set the denormal or invalid status flags
            faddp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  QWORD PTR dbl_res24; // exact
          }
          break;

        case _FpCodeSubtract:
          // perform the subtract
          __asm {
            fnclex; 
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal or invalid status flags
            fld  DWORD PTR opd2; // may set the denormal or invalid status flags
            fsubp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  QWORD PTR dbl_res24; // exact
          }
          break;

        case _FpCodeMultiply:
          // perform the multiply
          __asm {
            fnclex; 
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal or invalid status flags
            fld  DWORD PTR opd2; // may set the denormal or invalid status flags
            fmulp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  QWORD PTR dbl_res24; // exact
          }
          break;

        case _FpCodeDivide:
          // perform the divide
          __asm {
            fnclex; 
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal or invalid status flags
            fld  DWORD PTR opd2; // may set the denormal or invalid status flags
            fdivp st(1), st(0); // may set the inexact, divide by zero, or 
                                // invalid status flags
            // store result
            fstp  QWORD PTR dbl_res24; // exact
          }
          break;

        default:
          ; // will never occur

      }

      // read status word
      sw = _status87 ();
      if (sw & _SW_ZERODIVIDE) sw = sw & ~0x00080000; // clear D flag for den/0

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 1: in_top =%d != out_top = %d\n",
              in_top, out_top);
          exit (1);
        }
#endif

        return (ExceptionRaised);

      }

      // checking for NaN operands has priority over denormal exceptions; also
      // fix for the differences in treating two NaN inputs between the XMMI 
      // instructions and other x86 instructions
      if (isnanf (opd1) || isnanf (opd2)) {
        XmmiEnv->Ieee->Result.OperandValid = 1;

        if (isnanf (opd1) && isnanf (opd2))
            XmmiEnv->Ieee->Result.Value.Fp32Value = quietf (opd1);
        else
            XmmiEnv->Ieee->Result.Value.Fp32Value = (float)dbl_res24; 
                // conversion to single precision is exact
 
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        if (sw & _SW_INVALID) {
          XmmiEnv->Ieee->Status.InvalidOperation = 1;
          XmmiEnv->Flags |= I_MASK;
        } else {
          XmmiEnv->Ieee->Status.InvalidOperation = 0;
        }

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 2: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);
      }

      // if denormal flag is set, and denormal exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & D_MASK) && (sw & _SW_DENORMAL)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 3: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        XmmiEnv->Flags |= D_MASK;
        return (ExceptionRaised);

      }

      // if divide by zero flag is set, and divide by zero exceptions are 
      // enabled, take trap (for divide only)
      if (!(XmmiEnv->Masks & Z_MASK) && (sw & _SW_ZERODIVIDE)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.ZeroDivide = 1;
        XmmiEnv->Flags |= Z_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.ZeroDivide = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 4: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // done if the result is a NaN (QNaN Indefinite)
      res = (float)dbl_res24;
      if (isnanf (res)) {
#ifdef _XMMI_DEBUG
        if (res != QNANINDEFF)
            fprintf (stderr, "XMMI_FP_Emulation () INTERNAL XMMI_FP_Emulate () ERROR: "
                "res = %f = %x is not QNaN Indefinite\n", 
                 (double)res, *(unsigned int *)&res);
#endif
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp32Value = res; // exact
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        XmmiEnv->Ieee->Status.InvalidOperation = 1; // sw & _SW_INVALID true
        XmmiEnv->Flags |= I_MASK;
  
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 5: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);
      }

      // dbl_res24 is not a NaN at this point

      if (sw & _SW_DENORMAL) XmmiEnv->Flags |= D_MASK;

      // check if the result is tiny
      // Note: (dbl_res24 == 0.0 && sw & _SW_INEXACT) cannot occur
      if (-MIN_SINGLE_NORMAL < dbl_res24 && dbl_res24 < 0.0 ||
            0.0 < dbl_res24 && dbl_res24 < MIN_SINGLE_NORMAL) {
        result_tiny = 1;
      }

      // check if the result is huge
      if (NEGINFF < dbl_res24 && dbl_res24 < -MAX_SINGLE_NORMAL || 
          MAX_SINGLE_NORMAL < dbl_res24 && dbl_res24 < POSINFF) { 
        result_huge = 1;
      }

      // at this point, there are no enabled I, D, or Z exceptions; the instr.
      // might lead to an enabled underflow, enabled underflow and inexact, 
      // enabled overflow, enabled overflow and inexact, enabled inexact, or
      // none of these; if there are no U or O enabled exceptions, re-execute
      // the instruction using iA32 stack single precision format, and the 
      // user's rounding mode; exceptions must have been disabled; an inexact
      // exception may be reported on the 24-bit faddp, fsubp, fmulp, or fdivp,
      // while an overflow or underflow (with traps disabled !) may be reported
      // on the fstp

      // check whether there is a underflow, overflow, or inexact trap to be 
      // taken

      // if the underflow traps are enabled and the result is tiny, take 
      // underflow trap
      if (!(XmmiEnv->Masks & U_MASK) && result_tiny) {
        dbl_res24 = TWO_TO_192 * dbl_res24; // exact
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
        XmmiEnv->Ieee->Cause.Underflow = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp32Value = (float)dbl_res24; // exact

        if (sw & _SW_INEXACT) {
          XmmiEnv->Ieee->Status.Inexact = 1;
          XmmiEnv->Flags |= P_MASK;
        }

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 6: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if overflow traps are enabled and the result is huge, take
      // overflow trap
      if (!(XmmiEnv->Masks & O_MASK) &&  result_huge) {
        dbl_res24 = TWO_TO_M192 * dbl_res24; // exact
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Overflow = 1;
        XmmiEnv->Flags |= O_MASK;
        XmmiEnv->Ieee->Cause.Overflow = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp32Value = (float)dbl_res24; // exact 
 
        if (sw & _SW_INEXACT) {
          XmmiEnv->Ieee->Status.Inexact = 1;
          XmmiEnv->Flags |= P_MASK;
        }


#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 7: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // calculate result for the case an inexact trap has to be taken, or
      // when no trap occurs (second IEEE rounding)

      switch (XmmiEnv->Ieee->Operation) {

        case _FpCodeAdd:
          // perform the add
          __asm {
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal status flag
            fld  DWORD PTR opd2; // may set the denormal status flag
            faddp st(1), st(0); // rounded to 24 bits, may set the inexact 
                                // status flag
            // store result
            fstp  DWORD PTR res; // exact, will not set any flag
          }
          break;

        case _FpCodeSubtract:
          // perform the subtract
          __asm {
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal status flag
            fld  DWORD PTR opd2; // may set the denormal status flag
            fsubp st(1), st(0); // rounded to 24 bits, may set the inexact
                                //  status flag
            // store result
            fstp  DWORD PTR res; // exact, will not set any flag
          }
          break;

        case _FpCodeMultiply:
          // perform the multiply
          __asm {
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal status flag
            fld  DWORD PTR opd2; // may set the denormal status flag
            fmulp st(1), st(0); // rounded to 24 bits, may set the inexact
                                // status flag
            // store result
            fstp  DWORD PTR res; // exact, will not set any flag
          }
          break;

        case _FpCodeDivide:
          // perform the divide
          __asm {
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal status flag
            fld  DWORD PTR opd2; // may set the denormal status flag
            fdivp st(1), st(0); // rounded to 24 bits, may set the inexact
                                // or divide by zero status flags
            // store result
            fstp  DWORD PTR res; // exact, will not set any flag
          }
          break;

        default:
          ; // will never occur

      }

      // read status word
      sw = _status87 ();

      // if inexact traps are enabled and result is inexact, take inexact trap
      if (!(XmmiEnv->Masks & P_MASK) && 
          ((sw & _SW_INEXACT) || (XmmiEnv->Fz && result_tiny))) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        if (result_tiny) {
          XmmiEnv->Ieee->Status.Underflow = 1;
          XmmiEnv->Flags |= U_MASK;
          // Note: the condition above is equivalent to
          // if (sw & _SW_UNDERFLOW) XmmiEnv->Ieee->Status.Underflow = 1; 
        }
        if (result_huge) {
          XmmiEnv->Ieee->Status.Overflow = 1;
          XmmiEnv->Flags |= O_MASK;
          // Note: the condition above is equivalent to
          // if (sw & _SW_OVERFLOW) XmmiEnv->Ieee->Status.Overflow = 1;
        }

        // if ftz = 1 and result is tiny, result = 0.0
        // (no need to check for underflow traps disabled: result tiny and
        // underflow traps enabled would have caused taking an underflow
        // trap above)
        if (XmmiEnv->Fz && result_tiny) {
            // Note: the condition above is equivalent to
            // if (XmmiEnv->Fz && (sw & _SW_UNDERFLOW))
          if (res > 0.0)
            res = ZEROF;
          else if (res < 0.0)
            res = NZEROF;
          // else leave res unchanged
        }

        XmmiEnv->Ieee->Result.Value.Fp32Value = res; 
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 8: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if it got here, then there is no trap to be taken; the following must
      // hold: ((the MXCSR U exceptions are disabled  or
      //
      // the MXCSR underflow exceptions are enabled and the underflow flag is
      // clear and (the inexact flag is set or the inexact flag is clear and
      // the 24-bit result with unbounded exponent is not tiny)))
      // and (the MXCSR overflow traps are disabled or the overflow flag is
      // clear) and (the MXCSR inexact traps are disabled or the inexact flag
      // is clear)
      //
      // in this case, the result has to be delivered (the status flags are 
      // sticky, so they are all set correctly already)

#ifdef _XMMI_DEBUG
      // error if the condition stated above does not hold
      if (!((XmmiEnv->Masks & U_MASK || (!(XmmiEnv->Masks & U_MASK) && 
          !(sw & _SW_UNDERFLOW) && ((sw & _SW_INEXACT) || 
          !(sw & _SW_INEXACT) && !result_tiny))) &&
          ((XmmiEnv->Masks & O_MASK) || !(sw & _SW_OVERFLOW)) &&
          ((XmmiEnv->Masks & P_MASK) || !(sw & _SW_INEXACT)))) {
        fprintf (stderr, "XMMI_FP_Emulation () INTERNAL XMMI_FP_Emulate () ERROR for "
            "ADDPS/ADDSS/SUBPS/SUBSS/MULPS/MULSS/DIVPS/DIVSS\n");
      }
#endif

      XmmiEnv->Ieee->Result.OperandValid = 1;

      if (sw & _SW_UNDERFLOW) {
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
      } else {
        XmmiEnv->Ieee->Status.Underflow = 0;
      }
      if (sw & _SW_OVERFLOW) {
        XmmiEnv->Ieee->Status.Overflow = 1;
        XmmiEnv->Flags |= O_MASK;
      } else {
        XmmiEnv->Ieee->Status.Overflow = 0;
      }
      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }

      // if ftz = 1, and result is tiny (underflow traps must be disabled),
      // result = 0.0
      if (XmmiEnv->Fz && result_tiny) {
        if (res > 0.0)
          res = ZEROF;
        else if (res < 0.0)
          res = NZEROF;
        // else leave res unchanged

        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
      }

      XmmiEnv->Ieee->Result.Value.Fp32Value = res; 

      // note that there is no way to
      // communicate to the caller that the denormal flag was set - we count
      // on the XMMI instruction to have set the denormal flag in MXCSR if
      // needed, regardless of the other components of the input operands
      // (invalid or not; the caller will have to update the underflow, 
      // overflow, and inexact flags in MXCSR)
      if (sw & _SW_ZERODIVIDE) {
        XmmiEnv->Ieee->Status.ZeroDivide = 1;
        XmmiEnv->Flags |= Z_MASK;
      } else {
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
      }
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 9: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CMPPS:
    case OP_CMPSS:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd1)) opd1 = opd1 * (float)0.0;
        if (isdenormalf (opd2)) opd2 = opd2 * (float)0.0;
      }
      imm8 = XmmiEnv->Imm8 & 0x07;

      // adjust operation code
      XmmiEnv->Ieee->Operation = _FpCodeCompare;

      // check whether an invalid exception has to be raised

      switch (imm8) {

        case IMM8_EQ:
        case IMM8_UNORD:
        case IMM8_NEQ:
        case IMM8_ORD:
          if (issnanf (opd1) || issnanf (opd2))
              invalid_exc = 1; // SNaN operands signal invalid
          else
              invalid_exc = 0; // QNaN or other operands do not signal invalid
          // guard against the case when an SNaN operand was converted to 
          // QNaN by compiler generated code
          sw = _status87 ();
          if (sw & _SW_INVALID) invalid_exc = 1;
          break;
        case IMM8_LT:
        case IMM8_LE:
        case IMM8_NLT:
        case IMM8_NLE:
          if (isnanf (opd1) || isnanf (opd2))
              invalid_exc = 1; // SNaN/QNaN operands signal invalid
          else
              invalid_exc = 0; // other operands do not signal invalid
          break;
        default:
          ; // will never occur

      }

      // if invalid_exc = 1, and invalid exceptions are enabled, take trap
      if (invalid_exc && !(XmmiEnv->Masks & I_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

        // Note: the calling function will have to interpret the value returned
        // by the user handler, if execution is to be continued

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 10: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // checking for NaN operands has priority over denormal exceptions
      if (isnanf (opd1) || isnanf (opd2)) {

        switch (imm8) {

          case IMM8_EQ:
          case IMM8_LT:
          case IMM8_LE:
          case IMM8_ORD:
            cmp_res = 0x0;
            break;
          case IMM8_UNORD:
          case IMM8_NEQ:
          case IMM8_NLT:
          case IMM8_NLE:
            cmp_res = 0xffffffff;
            break;
          default:
            ; // will never occur

        }

        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp32Value = *((float *)&cmp_res); 
            // may make U32Value
  
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        // Note that the denormal flag will not be updated by _fpieee_flt (),
        // even if an operand is denormal
        if (invalid_exc) {
          XmmiEnv->Ieee->Status.InvalidOperation = 1;
          XmmiEnv->Flags |= I_MASK;
        } else {
          XmmiEnv->Ieee->Status.InvalidOperation = 0;
        }
  
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 11: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);

      }

      // check whether a denormal exception has to be raised

      if (isdenormalf (opd1) || isdenormalf (opd2)) {
          denormal_exc = 1;
          XmmiEnv->Flags |= D_MASK;
      } else {
          denormal_exc = 0;
      }

      // if denormal_exc = 1, and denormal exceptions are enabled, take trap
      if (denormal_exc && !(XmmiEnv->Masks & D_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 12: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // no exception has to be raised, and no operand is a NaN; calculate 
      // and deliver the result

      if (opd1 < opd2) {

        switch (imm8) {
  
          case IMM8_LT:
          case IMM8_LE:
          case IMM8_NEQ:
          case IMM8_ORD:
            cmp_res = 0xffffffff;
            break;
          case IMM8_EQ:
          case IMM8_UNORD:
          case IMM8_NLT:
          case IMM8_NLE:
            cmp_res = 0x0;
            break;

          default:
            ; // will never occur
  
        }

      } else if (opd1 > opd2) {

        switch (imm8) {
  
          case IMM8_NEQ:
          case IMM8_NLT:
          case IMM8_NLE:
          case IMM8_ORD:
            cmp_res = 0xffffffff;
            break;

          case IMM8_EQ:
          case IMM8_LT:
          case IMM8_LE:
          case IMM8_UNORD:
            cmp_res = 0x0;
            break;

          default:
            ; // will never occur
  
        }

      } else if (opd1 == opd2) {

        switch (imm8) {
  
          case IMM8_EQ:
          case IMM8_LE:
          case IMM8_NLT:
          case IMM8_ORD:
            cmp_res = 0xffffffff;
            break;

          case IMM8_LT:
          case IMM8_UNORD:
          case IMM8_NEQ:
          case IMM8_NLE:
            cmp_res = 0x0;
            break;

          default:
            ; // will never occur
  
        }

      } else { // could eliminate this case

#ifdef _DEBUG_FPU
        fprintf (stderr, "XMMI_FP_Emulation () INTERNAL XMMI_FP_Emulate () ERROR for CMPPS/CMPSS\n");
#endif

      }

      XmmiEnv->Ieee->Result.OperandValid = 1;
      XmmiEnv->Ieee->Result.Value.Fp32Value = *((float *)&cmp_res); 
          // may make U32Value

      XmmiEnv->Ieee->Status.Inexact = 0;
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      // Note that the denormal flag will not be updated by _fpieee_flt (),
      // even if an operand is denormal
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 13: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_COMISS:
    case OP_UCOMISS:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd1)) opd1 = opd1 * (float)0.0;
        if (isdenormalf (opd2)) opd2 = opd2 * (float)0.0;
      }

      // check whether an invalid exception has to be raised

      switch (XmmiEnv->Ieee->Operation) {

        case OP_COMISS:

          if (isnanf (opd1) || isnanf (opd2)) {
              invalid_exc = 1;
          } else
              invalid_exc = 0;
          break;

        case OP_UCOMISS:

          if (issnanf (opd1) || issnanf (opd2))
              invalid_exc = 1;
          else
              invalid_exc = 0;
          // guard against the case when an SNaN operand was converted to 
          // QNaN by compiler generated code
          sw = _status87 ();
          if (sw & _SW_INVALID) invalid_exc = 1;
          break;

        default:
          ; // will never occur

      }

      // adjust operation code
      XmmiEnv->Ieee->Operation = _FpCodeCompare;

      // if invalid_exc = 1, and invalid exceptions are enabled, take trap
      if (invalid_exc && !(XmmiEnv->Masks & I_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

        // Note: the calling function will have to interpret the value returned
        // by the user handler, if execution is to be continued

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 14: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // EFlags:
      // 333222222222211111111110000000000
      // 210987654321098765432109876543210
      //                      O   SZ A P C

      // checking for NaN operands has priority over denormal exceptions
      if (isnanf (opd1) || isnanf (opd2)) {


        // OF, SF, AF = 000, ZF, PF, CF = 111
        XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff76f) | 0x00000045;

        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        // Note that the denormal flag will not be updated by _fpieee_flt (),
        // even if an operand is denormal
        if (invalid_exc) {
          XmmiEnv->Ieee->Status.InvalidOperation = 1;
          XmmiEnv->Flags |= I_MASK;
        } else {
          XmmiEnv->Ieee->Status.InvalidOperation = 0;
        }

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 15: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);

      }

      // check whether a denormal exception has to be raised

      if (isdenormalf (opd1) || isdenormalf (opd2)) {
          denormal_exc = 1;
          XmmiEnv->Flags |= D_MASK;
      } else {
          denormal_exc = 0;
      }

      // if denormal_exc = 1, and denormal exceptions are enabled, take trap
      if (denormal_exc && !(XmmiEnv->Masks & D_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 16: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // no exception has to be raised, and no operand is a NaN; calculate 
      // and deliver the result

      // 333222222222211111111110000000000
      // 210987654321098765432109876543210
      //                      O   SZ A P C

      if (opd1 > opd2) {

        // OF, SF, AF = 000, ZF, PF, CF = 000
        XmmiEnv->EFlags = XmmiEnv->EFlags & 0xfffff72a;

      } else if (opd1 < opd2) {

        // OF, SF, AF = 000, ZF, PF, CF = 001
        XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff72b) | 0x00000001;

      } else if (opd1 == opd2) {

        // OF, SF, AF = 000, ZF, PF, CF = 100
        XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff76a) | 0x00000040;

      } else { // could eliminate this case

#ifdef _DEBUG_FPU
        fprintf (stderr, "XMMI_FP_Emulation () INTERNAL XMMI_FP_Emulate () ERROR for COMISS/UCOMISS\n");
#endif

      }

      XmmiEnv->Ieee->Status.Inexact = 0;
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      // Note that the denormal flag will not be updated by _fpieee_flt (),
      // even if an operand is denormal
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 17: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CVTPI2PS:
    case OP_CVTSI2SS:

      iopd1 = XmmiEnv->Ieee->Operand1.Value.I32Value;

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      // execute the operation and check whether the inexact flag is set
      // and the respective exception is enabled

      _control87 (rc | _PC_24 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the conversion
      __asm {
        fnclex; 
        fild  DWORD PTR iopd1; // exact
        fstp  DWORD PTR res; // may set P
      }
 
      // read status word
      sw = _status87 ();

      // if inexact traps are enabled and result is inexact, take inexact trap
      if (!(XmmiEnv->Masks & P_MASK) && (sw & _SW_INEXACT)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Operation = _FpCodeConvert;
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp32Value = res; // exact

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 18: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if it got here, then there is no trap to be taken; in this case, 
      // the result has to be delivered

      XmmiEnv->Ieee->Result.OperandValid = 1;
      XmmiEnv->Ieee->Result.Value.Fp32Value = res; // exact

      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 19: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CVTPS2PI:
    case OP_CVTSS2SI:
    case OP_CVTTPS2PI:
    case OP_CVTTSS2SI:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd1)) opd1 = opd1 * (float)0.0;
      }

      // adjust the operation code
      switch (XmmiEnv->Ieee->Operation) {

        case OP_CVTPS2PI:
        case OP_CVTSS2SI:

          XmmiEnv->Ieee->Operation = _FpCodeConvert;
          break;

        case OP_CVTTPS2PI:
        case OP_CVTTSS2SI:

          XmmiEnv->Ieee->Operation = _FpCodeConvertTrunc;
          break;

        default:
          ; // will never occur

      }

      switch (XmmiEnv->Ieee->Operation) {

        case _FpCodeConvert:

          switch (XmmiEnv->Rc) {
            case _FpRoundNearest:
              rc = _RC_NEAR;
              break;
            case _FpRoundMinusInfinity:
              rc = _RC_DOWN;
              break;
            case _FpRoundPlusInfinity:
              rc = _RC_UP;
              break;
            case _FpRoundChopped:
              rc = _RC_CHOP;
              break;
            default:
              ; // internal error
          }

          break;

        case _FpCodeConvertTrunc:

          rc = _RC_CHOP;
          break;

        default:
          ; // will never occur

      }

      // execute the operation and check whether the inexact flag is set
      // and the respective exceptions enabled

      _control87 (rc | _PC_24 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the conversion
      __asm {
        fnclex; 
        fld  DWORD PTR opd1; // may set the denormal [ignored] or invalid
                             // status flags
        fistp  DWORD PTR ires; // may set the inexact or invalid status
                               // flags (for NaN or out-of-range)
      }

      // read status word
      sw = _status87 ();

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 20: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // at this point, there are no enabled invalid exceptions; the
      // instruction might have lead to an enabled inexact exception, or to
      // no exception at all

      XmmiEnv->Ieee->Result.Value.I32Value = ires;

      // if inexact traps are enabled and result is inexact, take inexact trap
      // (no flush-to-zero situation is possible)
      if (!(XmmiEnv->Masks & P_MASK) && (sw & _SW_INEXACT)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 21: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if it got here, then there is no trap to be taken; return result

      XmmiEnv->Ieee->Result.OperandValid = 1;

      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      if (sw & _SW_INVALID) {
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
      } else {
        XmmiEnv->Ieee->Status.InvalidOperation = 0;
      }

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 22: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_MAXPS:
    case OP_MAXSS:
    case OP_MINPS:
    case OP_MINSS:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd1)) opd1 = opd1 * (float)0.0;
        if (isdenormalf (opd2)) opd2 = opd2 * (float)0.0;
      }

      // adjust operation code
      switch (XmmiEnv->Ieee->Operation) {

        case OP_MAXPS:
        case OP_MAXSS:
          XmmiEnv->Ieee->Operation = _FpCodeFmax;
          break;

        case OP_MINPS:
        case OP_MINSS:
          XmmiEnv->Ieee->Operation = _FpCodeFmin;
          break;

        default:
          ; // will never occur

      }

      // check whether an invalid exception has to be raised

      if (isnanf (opd1) || isnanf (opd2))
          invalid_exc = 1;
      else
          invalid_exc = 0;

      // if invalid_exc = 1, and invalid exceptions are enabled, take trap
      if (invalid_exc && !(XmmiEnv->Masks & I_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 23: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // checking for NaN operands has priority over denormal exceptions

      if (invalid_exc) {

        XmmiEnv->Ieee->Result.OperandValid = 1;

        XmmiEnv->Ieee->Result.Value.Fp32Value = opd2;
  
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
  
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 24: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);

      }

      // check whether a denormal exception has to be raised

      if (isdenormalf (opd1) || isdenormalf (opd2)) {
          denormal_exc = 1;
          XmmiEnv->Flags |= D_MASK;
      } else {
          denormal_exc = 0;
      }

      // if denormal_exc = 1, and denormal exceptions are enabled, take trap
      if (denormal_exc && !(XmmiEnv->Masks & D_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 25: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // no exception has to be raised, and no operand is a NaN; calculate 
      // and deliver the result

      if (opd1 < opd2) {

        switch (XmmiEnv->Ieee->Operation) {
          case _FpCodeFmax:
            XmmiEnv->Ieee->Result.Value.Fp32Value = opd2;
            break;
          case _FpCodeFmin:
            XmmiEnv->Ieee->Result.Value.Fp32Value = opd1;
            break;
          default:
            ; // will never occur
        }

      } else if (opd1 > opd2) {

        switch (XmmiEnv->Ieee->Operation) {
          case _FpCodeFmax:
            XmmiEnv->Ieee->Result.Value.Fp32Value = opd1;
            break;
          case _FpCodeFmin:
            XmmiEnv->Ieee->Result.Value.Fp32Value = opd2;
            break;
          default:
            ; // will never occur
        }

      } else if (opd1 == opd2) {

        XmmiEnv->Ieee->Result.Value.Fp32Value = opd2;

      } else { // could eliminate this case

#ifdef _DEBUG_FPU
        fprintf (stderr, "XMMI_FP_Emulation () INTERNAL XMMI_FP_Emulate () ERROR for MAXPS/MAXSS/MINPS/MINSS\n");
#endif

      }

      XmmiEnv->Ieee->Result.OperandValid = 1;

      XmmiEnv->Ieee->Status.Inexact = 0;
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      // Note that the denormal flag will not be updated by _fpieee_flt (),
      // even if an operand is denormal
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 26: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_SQRTPS:
    case OP_SQRTSS:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd1)) opd1 = opd1 * (float)0.0;
      }

      // adjust operation code
      XmmiEnv->Ieee->Operation = _FpCodeSquareRoot;

      // execute the operation and check whether the invalid, denormal, or 
      // inexact flags are set and the respective exceptions enabled

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      _control87 (rc | _PC_24 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the square root
      __asm {
        fnclex; 
        fld  DWORD PTR opd1; // may set the denormal or invalid status flags
        fsqrt; // may set the inexact or invalid status flags
        fstp  DWORD PTR res; // exact
      }
 
      // read status word
      sw = _status87 ();
      if (sw & _SW_INVALID) sw = sw & ~0x00080000; // clr D flag for sqrt(-den)

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 27: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      if (sw & _SW_DENORMAL) XmmiEnv->Flags |= D_MASK;

      // if denormal flag is set, and denormal exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & D_MASK) && (sw & _SW_DENORMAL)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 28: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // the result cannot be tiny

      // at this point, there are no enabled I or D or exceptions; the instr.
      // might lead to an enabled inexact exception or to no exception (this
      // includes the case of a NaN or negative operand); exceptions must have 
      // been disabled before calling this function; an inexact exception is
      // reported on the fsqrt

      // if (the MXCSR inexact traps are disabled or the inexact flag is clear)
      // then deliver the result (the status flags are sticky, so they are
      // all set correctly already)
 
      // if it got here, then there is either an inexact trap to be taken, or
      // no trap at all

      XmmiEnv->Ieee->Result.Value.Fp32Value = res; // exact

      // if inexact traps are enabled and result is inexact, take inexact trap
      if (!(XmmiEnv->Masks & P_MASK) && (sw & _SW_INEXACT)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 29: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // no trap was taken

      XmmiEnv->Ieee->Result.OperandValid = 1;
 
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }

      // note that there is no way to
      // communicate to the caller that the denormal flag was set - we count
      // on the XMMI instruction to have set the denormal flag in MXCSR if
      // needed, regardless of the other components of the input operands
      // (invalid or not); the caller will have to update the inexact flag
      // in MXCSR
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      if (sw & _SW_INVALID) {
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags = I_MASK; // no other flags set if invalid is set
      } else {
        XmmiEnv->Ieee->Status.InvalidOperation = 0;
      }

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 30: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_UNSPEC:

#ifdef _DEBUG_FPU
      fprintf (stderr, "XMMI_FP_Emulation internal error: unknown operation code OP_UNSPEC\n");
#endif

      break;

    default:
#ifdef _DEBUG_FPU
      fprintf (stderr, "XMMI_FP_Emulation internal error: unknown operation code %d\n", XmmiEnv->Ieee->Operation);
#endif
      break;
  }

}



static int
issnanf (float f)

{

  // checks whether f is a signaling NaN

  unsigned int *fp;

  fp = (unsigned int *)&f;

  if (((fp[0] & 0x7fc00000) == 0x7f800000) && ((fp[0] & 0x003fffff) != 0))
    return (1);
  else
    return (0);

}


static int
isnanf (float f)

{

  // checks whether f is a NaN

  unsigned int *fp;

  fp = (unsigned int *)&f;

  if (((fp[0] & 0x7f800000) == 0x7f800000) && ((fp[0] & 0x007fffff) != 0))
    return (1);
  else
    return (0);

}


static float
quietf (float f)

{

  // makes a signaling NaN quiet, and leaves a quiet NaN unchanged; does
  // not check that the input value f is a NaN

  unsigned int *fp;

  fp = (unsigned int *)&f;

  *fp = *fp | 0x00400000;
  return (f);

}


static int
isdenormalf (float f)

{

  // checks whether f is a denormal

  unsigned int *fp;

  fp = (unsigned int *)&f;

  if ((fp[0] & 0x7f800000) == 0x0 && (fp[0] & 0x007fffff) != 0x0)
    return (1);
  else
    return (0);

}


static void Fill_FPIEEE_RECORD (PXMMI_ENV XmmiEnv)

{

  // fill in part of the FP IEEE record

  XmmiEnv->Ieee->RoundingMode = XmmiEnv->Rc;
  XmmiEnv->Ieee->Precision = XmmiEnv->Precision;
  XmmiEnv->Ieee->Enable.Inexact = !(XmmiEnv->Masks & P_MASK);
  XmmiEnv->Ieee->Enable.Underflow = !(XmmiEnv->Masks & U_MASK);
  XmmiEnv->Ieee->Enable.Overflow = !(XmmiEnv->Masks & O_MASK);
  XmmiEnv->Ieee->Enable.ZeroDivide = !(XmmiEnv->Masks & Z_MASK);
  XmmiEnv->Ieee->Enable.InvalidOperation = !(XmmiEnv->Masks & I_MASK);
  XmmiEnv->Ieee->Status.Inexact = 0;
  XmmiEnv->Ieee->Status.Underflow = 0;
  XmmiEnv->Ieee->Status.Overflow = 0;
  XmmiEnv->Ieee->Status.ZeroDivide = 0;
  XmmiEnv->Ieee->Status.InvalidOperation = 0;
  // Cause = Enable & Status
  XmmiEnv->Ieee->Cause.Inexact = 0;
  XmmiEnv->Ieee->Cause.Underflow = 0;
  XmmiEnv->Ieee->Cause.Overflow = 0;
  XmmiEnv->Ieee->Cause.ZeroDivide = 0;
  XmmiEnv->Ieee->Cause.InvalidOperation = 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\testfdiv.c ===
/***
*testfdiv.c - routine to test for correct operation of x86 FDIV instruction.
*
*	Copyright (c) 1994-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Detects early steppings of Pentium with incorrect FDIV tables using
*	'official' Intel test values. Returns 1 if flawed Pentium is detected,
*	0 otherwise.
*
*Revision History:
*	12-19-94  JWM	file added
*	12-22-94  JWM	Now safe for TNT, et al
*	01-13-95  JWM	underscores added for ANSI compatibility
*	12-12-95  SKS	Skip redundant Pentium test on uni-processor systems
*	12-13-95  SKS	Call LoadLibrary() rather than GetModuleHandle()
*			since "kernel32.dll" is always going to be present.
*	01-18-96  JWM	Now handles possible failure of SetThreadAffinityMask(),
*			incorporating various suggestions of MarkL.
*	05-29-96  JWM	No longer loops through affinity mask; instead, uses MarkL's
*			new IsProcessorFeaturePresent() API if possible, only tests
*			1st processor if not.
*
*******************************************************************************/

#include <windows.h>

int _ms_p5_test_fdiv(void)
{
    double dTestDivisor = 3145727.0;
    double dTestDividend = 4195835.0;
    double dRslt;

    _asm {
        fld    qword ptr [dTestDividend]
        fdiv   qword ptr [dTestDivisor]
        fmul   qword ptr [dTestDivisor]
        fsubr  qword ptr [dTestDividend]
        fstp   qword ptr [dRslt]
    }

    return (dRslt > 1.0);
}

/* 
 * Multiprocessor Pentium test: returns 1 if any processor is a flawed
 * Pentium, 0 otherwise.
 */

int _ms_p5_mp_test_fdiv(void)
{

    #define PF_FLOATING_POINT_PRECISION_ERRATA 0
    HINSTANCE LibInst;
    FARPROC pIsProcessorFeaturePresent;

    if ((LibInst = GetModuleHandle("KERNEL32")) &&
         (pIsProcessorFeaturePresent = GetProcAddress(LibInst, "IsProcessorFeaturePresent")))
        return (*pIsProcessorFeaturePresent)(PF_FLOATING_POINT_PRECISION_ERRATA);
    else
        return _ms_p5_test_fdiv();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\triga.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;        support for asin() and acos() functions
;
;Revision History:
;
;*******************************************************************************

.xlist
        include cruntime.inc
        include elem87.inc
.list

        .data

ifdef         _ACOS_
    _NAME_ db 'acos',0,0,0,0
    _FUNC_    equ <acos>
    _IFUNC_   equ <_CIacos>
elseifdef _ASIN_
    _SIN_  equ 1
    _NAME_ db 'asin',0,0,0,0
    _FUNC_    equ <asin>
    _IFUNC_   equ <_CIasin>
endif

extrn   _indefinite:tbyte
extrn   __fastflag:dword
extrn   _piby2:tbyte

        CODESEG

extrn   _startOneArgErrorHandling:near
extrn   _fload_withFB:near
extrn   _convertTOStoQNaN:near
extrn   _checkTOS_withFB:near
extrn   _math_exit:near
extrn   _fast_exit:near
extrn   _load_CW:near


; arg                ErrorType        result
;------------------------------------------------
; |x| >1             DOMAIN           indefinite
;+/-infinity         DOMAIN           indefinite      |  ? Do we really need
;QNaN                DOMAIN_QNAN      QNaN            |  ? to distinguish them???
;SNaN                DOMAIN           indefinite      |  ? it costs 14 bytes per function
;indefinite is  like QNaN
;denormal        fld converts it to normal (80 bits)

        public _FUNC_,_IFUNC_
_IFUNC_ proc
        sub     esp,DBLSIZE+4                   ; for argument
        fst     qword ptr [esp]
        call    _checkTOS_withFB
        call    start
        add     esp, DBLSIZE+4
        ret

_FUNC_        label        proc
        lea     edx, [esp+4]
        call    _fload_withFB
start:
        push    edx                           ; allocate space for Control Word
        fstcw   [esp]                         ; store Control Word

; at this point we have on stack: cw(4), ret_addr(4), arg1(8bytes)

        jz      inf_or_nan
        cmp     word ptr[esp], default_CW
        je      CW_is_set_to_default
        call    _load_CW                      ; use user's precision bits
CW_is_set_to_default:
        cmp     eax,3ff00000H                 ; check if |x|>=1
        jae     x_huge

        fld1                                  ; load 1.0
        fadd    st, st(1)                     ; 1+x
        fld1                                  ; load 1.0
        fsub    st, st(2)                     ; 1-x
        fmul                                  ; (1+x)(1-x)
        fsqrt                                 ; sqrt((1+x)(1-x))
ifdef        _ACOS_
        fxch
endif
        fpatan                                ; fpatan(x,sqrt((1+x)(1-x)))

exit:
        cmp     __fastflag, 0
        jnz     _fast_exit

; prepare in registers arguments for math_exit
ifdef _ACOS_
        mov     edx,OP_ACOS
elseifdef _ASIN_
        mov     edx,OP_ASIN
endif
        lea     ecx,[_NAME_]
        jmp     _math_exit


x_huge: ja      not_in_range
        mov     eax,[esp+0cH]
        mov     ecx,eax
        and     eax,000fffffH
        or      eax,[esp+8]
        jnz     not_in_range
        and     ecx,80000000H
        fstp    st(0)                         ; remove TOS
ifdef        _ASIN_
        fld     _piby2                        ; asin(1) = pi/2
        jz      exit
        fchs                                  ; asin(-1) = -pi/2
        jmp     exit
elseifdef _ACOS_
        jz      ret_zero
        fldpi
        jmp     exit
ret_zero:
        fldz
        jmp     exit
endif



not_infinity:
        call    _convertTOStoQNaN             ; eax MUST contain high dword
        jmp     _Error_handling               ; eax=error number
inf_or_nan:
        test    eax, 000fffffh
        jnz     not_infinity
        cmp     dword ptr[esp+8], 0
        jne     not_infinity
not_in_range:
        fstp    st(0)
        fld     [_indefinite]
        mov     eax,DOMAIN
_Error_handling:
        cmp     __fastflag, 0
        jnz     _fast_exit

ifdef _ACOS_
        mov     edx,OP_ACOS
elseifdef _ASIN_
        mov     edx,OP_ASIN
endif
        lea     ecx,[_NAME_]
        call    _startOneArgErrorHandling
        pop     edx                           ; remove saved CW from stack
        ret

_IFUNC_        endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\acos.s ===
.file "acos.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.

// History
//==============================================================
// 2/02/00  Initial version 
// 8/17/00  New and much faster algorithm.
// 8/30/00  Avoided bank conflicts on loads, shortened |x|=1 and x=0 paths,
//          fixed mfb split issue stalls.

// Description
//=========================================
// The acos function computes the principle value of the arc sine of x.
// A doman error occurs for arguments not in the range [-1,+1].

// The acos function returns the arc cosine in the range [0, +pi] radians.
// acos(1) returns +0, acos(-1) returns pi, acos(0) returns pi/2.
// acos(x) returns a Nan and raises the invalid exception for |x| >1

// The acos function is just like asin except that pi/2 is added at the end.

//
// Assembly macros
//=========================================


// predicate registers
//acos_pred_LEsqrt2by2            = p7
//acos_pred_GTsqrt2by2            = p8

// integer registers
ASIN_Addr1                      = r33
ASIN_Addr2                      = r34
ASIN_FFFE                       = r35

GR_SAVE_B0                      = r36
GR_SAVE_PFS                     = r37
GR_SAVE_GP                      = r38

GR_Parameter_X                  = r39
GR_Parameter_Y                  = r40
GR_Parameter_RESULT             = r41
GR_Parameter_Tag                = r42

// floating point registers
acos_coeff_P1                   = f32
acos_coeff_P2                   = f33
acos_coeff_P3                   = f34
acos_coeff_P4                   = f35

acos_coeff_P5                   = f36
acos_coeff_P6                   = f37
acos_coeff_P7                   = f38
acos_coeff_P8                   = f39
acos_coeff_P9                   = f40

acos_coeff_P10                  = f41
acos_coeff_P11                  = f42
acos_coeff_P12                  = f43
acos_coeff_P13                  = f44
acos_coeff_P14                  = f45

acos_coeff_P15                  = f46
acos_coeff_P16                  = f47
acos_coeff_P17                  = f48
acos_coeff_P18                  = f49
acos_coeff_P19                  = f50

acos_coeff_P20                  = f51
acos_coeff_P21                  = f52
acos_const_sqrt2by2             = f53
acos_const_piby2                = f54
acos_abs_x                      = f55

acos_tx                         = f56
acos_tx2                        = f57
acos_tx3                        = f58
acos_tx4                        = f59
acos_tx8                        = f60

acos_tx11                       = f61
acos_1poly_p8                   = f62
acos_1poly_p19                  = f63
acos_1poly_p4                   = f64
acos_1poly_p15                  = f65

acos_1poly_p6                   = f66
acos_1poly_p17                  = f67
acos_1poly_p0                   = f68
acos_1poly_p11                  = f69
acos_1poly_p2                   = f70

acos_1poly_p13                  = f71
acos_series_tx                  = f72
acos_t                          = f73
acos_t2                         = f74
acos_t3                         = f75

acos_t4                         = f76
acos_t8                         = f77
acos_t11                        = f78
acos_poly_p8                    = f79
acos_poly_p19                   = f80

acos_poly_p4                    = f81
acos_poly_p15                   = f82
acos_poly_p6                    = f83
acos_poly_p17                   = f84
acos_poly_p0                    = f85

acos_poly_p11                   = f86
acos_poly_p2                    = f87
acos_poly_p13                   = f88
acos_series_t                   = f89
acos_1by2                       = f90

acos_3by2                       = f91
acos_5by2                       = f92
acos_11by4                      = f93
acos_35by8                      = f94
acos_63by8                      = f95

acos_231by16                    = f96 
acos_y0                         = f97 
acos_H0                         = f98 
acos_S0                         = f99 
acos_d                          = f100

acos_l1                         = f101
acos_d2                         = f102
acos_T0                         = f103
acos_d1                         = f104
acos_e0                         = f105

acos_l2                         = f106
acos_d3                         = f107
acos_T3                         = f108
acos_S1                         = f109
acos_e1                         = f110

acos_z                          = f111
answer2                         = f112
acos_sgn_x                      = f113
acos_429by16                    = f114
acos_18by4                      = f115

acos_3by4                       = f116
acos_l3                         = f117
acos_T6                         = f118
acos_const_add                  = f119

// Data tables
//==============================================================

.data

.align 16

acos_coeff_1_table:
data8 0xE4E7E0A423A21249  , 0x00003FF8 //P7
data8 0xC2F7EE0200FCE2A5  , 0x0000C003 //P18
data8 0xB745D7F6C65C20E0  , 0x00003FF9 //P5
data8 0xF75E381A323D4D94  , 0x0000C002 //P16
data8 0x8959C2629C1024C0  , 0x0000C002 //P20
data8 0xAFF68E7D241292C5  , 0x00003FF8 //P9
data8 0xB6DB6DB7260AC30D  , 0x00003FFA //P3
data8 0xD0417CE2B41CB7BF  , 0x0000C000 //P14
data8 0x81D570FEA724E3E4  , 0x0000BFFD //P12
data8 0xAAAAAAAAAAAAC277  , 0x00003FFC //P1
data8 0xF534912FF3E7B76F  , 0x00003FFF //P21
data8 0xc90fdaa22168c235  , 0x00003fff // pi/2
data8 0x0000000000000000  , 0x00000000 // pad to avoid bank conflicts


acos_coeff_2_table:
data8 0x8E26AF5F29B39A2A  , 0x00003FF9 //P6
data8 0xB4F118A4B1015470  , 0x00004003 //P17
data8 0xF8E38E10C25990E0  , 0x00003FF9 //P4
data8 0x80F50489AEF1CAC6  , 0x00004002 //P15
data8 0x92728015172CFE1C  , 0x00004003 //P19
data8 0xBBC3D831D4595971  , 0x00003FF8 //P8
data8 0x999999999952A5C3  , 0x00003FFB //P2
data8 0x855576BE6F0975EC  , 0x00003FFF //P13
data8 0xF12420E778077D89  , 0x00003FFA //P11
data8 0xB6590FF4D23DE003  , 0x00003FF3 //P10
data8 0xb504f333f9de6484  , 0x00003ffe // sqrt(2)/2



.align 32
.global acos

.section .text
.proc  acos
.align 32


acos:
 
{     .mfi 
     alloc      r32               = ar.pfs,1,6,4,0
     fma.s1    acos_tx        =    f8,f8,f0
     addl      ASIN_Addr2     =    @ltoff(acos_coeff_2_table),gp
} 
{     .mfi 
     mov       ASIN_FFFE      =    0xFFFE
     fnma.s1   acos_t         =    f8,f8,f1
     addl      ASIN_Addr1     =    @ltoff(acos_coeff_1_table),gp
}
;;

 
{     .mfi 
     setf.exp       acos_1by2      =    ASIN_FFFE
     fmerge.s       acos_abs_x     =    f1,f8
     nop.i          999              ;;
} 
 

{     .mmf 
     ld8       ASIN_Addr1     =    [ASIN_Addr1]
     ld8       ASIN_Addr2     =    [ASIN_Addr2]
     fmerge.s  acos_sgn_x     =    f8,f1
} 
;;


{     .mfi 
     nop.m                      999
     fcmp.lt.s1  p11,p12  = f8, f0
     nop.i          999              ;;
} 
 
 
{     .mfi 
     ldfe      acos_coeff_P7  =    [ASIN_Addr1],16
     fma.s1    acos_tx2       =    acos_tx,acos_tx,f0
     nop.i                      999
} 
{     .mfi 
     ldfe      acos_coeff_P6  =    [ASIN_Addr2],16
     fma.s1    acos_t2        =    acos_t,acos_t,f0
     nop.i                      999;;
}

 
{     .mmf 
     ldfe      acos_coeff_P18 =    [ASIN_Addr1],16
     ldfe      acos_coeff_P17 =    [ASIN_Addr2],16
     fclass.m.unc p8,p0  = f8, 0xc3	//@qnan |@snan
} 
;;

 
{     .mmf 
     ldfe      acos_coeff_P5  =    [ASIN_Addr1],16
     ldfe      acos_coeff_P4  =    [ASIN_Addr2],16
     frsqrta.s1     acos_y0,p0     =    acos_t
} 
;;

 
{     .mfi 
     ldfe      acos_coeff_P16 =    [ASIN_Addr1],16
     fcmp.gt.s1 p9,p0 = acos_abs_x,f1
     nop.i                      999
} 
{     .mfb 
     ldfe      acos_coeff_P15 =    [ASIN_Addr2],16
(p8) fma.d     f8 = f8,f1,f0
(p8) br.ret.spnt b0
}
;;

 
{     .mmf 
     ldfe      acos_coeff_P20 =    [ASIN_Addr1],16
     ldfe      acos_coeff_P19 =    [ASIN_Addr2],16
     fclass.m.unc p10,p0 = f8, 0x07	//@zero
} 
;;

 
{     .mfi 
     ldfe      acos_coeff_P9  =    [ASIN_Addr1],16
     fma.s1    acos_t4        =    acos_t2,acos_t2,f0
(p9) mov GR_Parameter_Tag = 58 
} 
{     .mfi 
     ldfe      acos_coeff_P8  =    [ASIN_Addr2],16
     fma.s1    acos_3by2      =    acos_1by2,f1,f1
     nop.i                      999;;
}

 
{     .mfi 
     ldfe      acos_coeff_P2  =    [ASIN_Addr2],16
     fma.s1    acos_tx4       =    acos_tx2,acos_tx2,f0
     nop.i 999
} 
{     .mfb 
     ldfe      acos_coeff_P3  =    [ASIN_Addr1],16
     fma.s1    acos_t3        =    acos_t,acos_t2,f0
(p9) br.cond.spnt  __libm_error_region
}
;;

 
{     .mfi 
     ldfe      acos_coeff_P13 =    [ASIN_Addr2],16
     fma.s1    acos_H0        =    acos_y0,acos_1by2,f0
     nop.i                      999
} 
{     .mfi 
     ldfe      acos_coeff_P14 =    [ASIN_Addr1],16
     fma.s1    acos_S0        =    acos_y0,acos_t,f0
     nop.i                      999;;
}

 
{     .mfi 
     ldfe      acos_coeff_P11 =    [ASIN_Addr2],16
     fcmp.eq.s1  p6,p0  = acos_abs_x, f1
     nop.i                      999
} 
{     .mfi 
     ldfe      acos_coeff_P12 =    [ASIN_Addr1],16
     fma.s1    acos_tx3       =    acos_tx,acos_tx2,f0
     nop.i 999
}
;;

 
{     .mfi 
     ldfe      acos_coeff_P10 =    [ASIN_Addr2],16
     fma.s1    acos_1poly_p6  =    acos_tx,acos_coeff_P7,acos_coeff_P6
     nop.i                      999
} 
{     .mfi 
     ldfe      acos_coeff_P1  =    [ASIN_Addr1],16
     fma.s1    acos_poly_p6   =    acos_t,acos_coeff_P7,acos_coeff_P6
     nop.i                      999;;
}

 
{     .mfi 
     ldfe      acos_const_sqrt2by2 =    [ASIN_Addr2],16
     fma.s1    acos_5by2           =    acos_3by2,f1,f1
     nop.i                           999
} 
{     .mfi 
     ldfe      acos_coeff_P21 =    [ASIN_Addr1],16
     fma.s1    acos_11by4     =    acos_3by2,acos_3by2,acos_1by2
     nop.i                      999;;
}

 
{     .mfi 
     ldfe      acos_const_piby2    =    [ASIN_Addr1],16
     fma.s1    acos_poly_p17       =    acos_t,acos_coeff_P18,acos_coeff_P17
     nop.i                      999
} 
{     .mfb 
     nop.m                 999
     fma.s1    acos_3by4 =    acos_3by2,acos_1by2,f0
(p10) br.cond.spnt  ACOS_ZERO    // Branch to short path if x=0
}
;;

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p15  =    acos_t,acos_coeff_P16,acos_coeff_P15
     nop.i                      999
} 
{     .mfb 
     nop.m                 999
     fnma.s1   acos_d    =    acos_S0,acos_H0,acos_1by2
(p6) br.cond.spnt  ACOS_ABS_ONE    // Branch to short path if |x|=1
}
;;

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p19  =    acos_t,acos_coeff_P20,acos_coeff_P19
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p4   =    acos_t,acos_coeff_P5,acos_coeff_P4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p17 =    acos_tx,acos_coeff_P18,acos_coeff_P17
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p8   =    acos_t,acos_coeff_P9,acos_coeff_P8
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fms.s1    acos_35by8     =    acos_5by2,acos_11by4,acos_5by2
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_63by8     =    acos_5by2,acos_11by4,f1
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p13  =    acos_t,acos_coeff_P14,acos_coeff_P13
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_18by4     =    acos_3by2,acos_5by2,acos_3by4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    acos_l1   =    acos_5by2,acos_d,acos_3by2
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fma.s1    acos_d2   =    acos_d,acos_d,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p15  =    acos_t2,acos_poly_p17,acos_poly_p15
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    acos_T0   =    acos_d,acos_S0,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p19  =    acos_t2,acos_coeff_P21,acos_poly_p19
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p4   =    acos_t2,acos_poly_p6,acos_poly_p4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    acos_d1   =    acos_35by8,acos_d,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_231by16   =    acos_3by2,acos_35by8,acos_63by8
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p2   =    acos_t,acos_coeff_P3,acos_coeff_P2
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p8   =    acos_t2,acos_coeff_P10,acos_poly_p8
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p11  =    acos_t,acos_coeff_P12,acos_coeff_P11
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    acos_e0   =    acos_d2,acos_l1,acos_d
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p15 =    acos_tx,acos_coeff_P16,acos_coeff_P15
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p0   =    acos_t,acos_coeff_P1,f1
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p19 =    acos_tx,acos_coeff_P20,acos_coeff_P19
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p4  =    acos_tx,acos_coeff_P5,acos_coeff_P4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p8  =    acos_tx,acos_coeff_P9,acos_coeff_P8
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    acos_l2   =    acos_231by16,acos_d,acos_63by8
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    acos_d3   =    acos_d2,acos_d,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fma.s1    acos_T3   =    acos_d2,acos_T0,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_429by16   =    acos_18by4,acos_11by4,acos_231by16
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    acos_S1   =    acos_e0,acos_S0,acos_S0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p4   =    acos_t4,acos_poly_p8,acos_poly_p4
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p15  =    acos_t4,acos_poly_p19,acos_poly_p15
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p0   =    acos_t2,acos_poly_p2,acos_poly_p0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p11  =    acos_t2,acos_poly_p13,acos_poly_p11
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    acos_t8   =    acos_t4,acos_t4,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fma.s1    acos_e1   =    acos_d2,acos_l2,acos_d1
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p4  =    acos_tx2,acos_1poly_p6,acos_1poly_p4
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p15 =    acos_tx2,acos_1poly_p17,acos_1poly_p15
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p8  =    acos_tx2,acos_coeff_P10,acos_1poly_p8
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p19 =    acos_tx2,acos_coeff_P21,acos_1poly_p19
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p2  =    acos_tx,acos_coeff_P3,acos_coeff_P2
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p13 =    acos_tx,acos_coeff_P14,acos_coeff_P13
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p0  =    acos_tx,acos_coeff_P1,f1
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p11 =    acos_tx,acos_coeff_P12,acos_coeff_P11
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    acos_l3   =    acos_429by16,acos_d,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fma.s1    acos_z    =    acos_e1,acos_T3,acos_S1
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p11  =    acos_t4,acos_poly_p15,acos_poly_p11
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    acos_T6   =    acos_T3,acos_d3,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    acos_t11  =    acos_t8,acos_t3,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p0   =    acos_t4,acos_poly_p4,acos_poly_p0
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p4  =    acos_tx4,acos_1poly_p8,acos_1poly_p4
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p15 =    acos_tx4,acos_1poly_p19,acos_1poly_p15
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p0  =    acos_tx2,acos_1poly_p2,acos_1poly_p0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p11 =    acos_tx2,acos_1poly_p13,acos_1poly_p11
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                                                         999
//     fcmp.le.s1     acos_pred_LEsqrt2by2,acos_pred_GTsqrt2by2    =    acos_abs_x,acos_const_sqrt2by2
     fcmp.le.s1     p7,p8    =    acos_abs_x,acos_const_sqrt2by2
     nop.i                                                         999
} 
{     .mfi 
     nop.m                 999
     fma.s1    acos_tx8  =    acos_tx4,acos_tx4,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    acos_z    =    acos_l3,acos_T6,acos_z
     nop.i                 999;;
} 
 
{     .mfi
     nop.m                      999
     fma.s1    acos_series_t  =    acos_t11,acos_poly_p11,acos_poly_p0
     nop.i                      999
}
{    .mfi
     nop.m 999
(p11) fma.s1 acos_const_add = acos_const_piby2, f1, acos_const_piby2
     nop.i 999
}
;;

{ .mfi
      nop.m 999
(p12) fma.s1 acos_const_add = f1,f0,f0
      nop.i 999
}
;;
 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p0  =    acos_tx4,acos_1poly_p4,acos_1poly_p0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p11 =    acos_tx4,acos_1poly_p15,acos_1poly_p11
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    acos_tx11 =    acos_tx8,acos_tx3,f0
     nop.i                 999;;
} 
 
{     .mfi 
                         nop.m                 999
//(acos_pred_GTsqrt2by2)   fnma.s1      answer2   =    acos_z,acos_series_t,acos_const_piby2
(p8)   fnma.s1      answer2   =    acos_z,acos_series_t,f0
                         nop.i                 999;;
} 
 
{     .mfi 
     nop.m                      999
     fma.s1    acos_series_tx =    acos_tx11,acos_1poly_p11,acos_1poly_p0
     nop.i                      999;;
} 
 
{     .mfi 
                         nop.m                 999
//(acos_pred_GTsqrt2by2)   fnma.d     f8   =    acos_sgn_x,answer2,acos_const_piby2
(p8)   fnma.d     f8   =    acos_sgn_x,answer2,acos_const_add
                         nop.i                 999;;
} 
 
{     .mfb 
                         nop.m                 999
//(acos_pred_LEsqrt2by2)   fnma.d     f8   =    f8,acos_series_tx,acos_const_piby2
(p7)   fnma.d     f8   =    f8,acos_series_tx,acos_const_piby2
     br.ret.sptk b0 ;;
} 


ACOS_ZERO:
// Here if x=0
{     .mfb 
      nop.m                 999
      fma.d    f8 =    acos_const_piby2,f1,f0
      br.ret.sptk b0 ;;
} 


.pred.rel "mutex",p11,p12
ACOS_ABS_ONE:
// Here if |x|=1
{     .mfi 
      nop.m                 999
(p11) fma.d    f8 =    acos_const_piby2,f1,acos_const_piby2 // acos(-1)=pi
      nop.i                 999
} 
{     .mfb 
      nop.m                 999
(p12) fma.d    f8 =    f1,f0,f0 // acos(1)=0
      br.ret.sptk b0 ;;
} 


.endp acos

.proc __libm_error_region
__libm_error_region:
.prologue
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
                nop.f 999
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfs [GR_Parameter_Y] = f1,16         // Store Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
};;

.body
        frcpa.s0 f9,p0 = f0,f0
;;

{ .mib
        stfd [GR_Parameter_X] = f8            // Store Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
        nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfd [GR_Parameter_Y] = f9,-16           // Store Parameter 3 on stack
        adds r32 = 48,sp
        br.call.sptk b0=__libm_error_support#   // Call error handling function
};;
{ .mmi
        ldfd  f8 = [r32]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return

};;

.endp __libm_error_region

.type   __libm_error_support,@function
.global __libm_error_support
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\i386\xmmi_types.h ===
/******************************Intel Confidential******************************/
/*++ 

Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.

Module Name:

    xmmi_types.h

Abstract:

    This module contains the xmmi data definitions.
   
Author:

    Ping L. Sager

Revision History:

--*/

//Debug
#ifdef _DEBUG
//Uncomment this line to debug.  This switch is also used to generated test cases.
//#define _XMMI_DEBUG
#endif

#ifndef _XMMI_TYPES_H
#define _XMMI_TYPES_H

#ifndef LITTLE_ENDIAN
#define LITTLE_ENDIAN       1
#endif

#define XMMI_INSTR          0
#define XMMI2_INSTR         1
#define XMMI2_OTHER         2
#define INSTR_SET_SUPPORTED 2   
#define INSTR_IN_OPTABLE    32

#define NoExceptionRaised   0
#define ExceptionRaised     1

//
// Definitions used to parse the memory references
// 
#define EAX_INDEX           0
#define ECX_INDEX           1
#define EDX_INDEX           2
#define EBX_INDEX           3
#define ESP_INDEX           4
#define EBP_INDEX           5
#define ESI_INDEX           6
#define EDI_INDEX           7

#define GET_REG(r)      (pctxt->r)
#define GET_REG_VIA_NDX(l,n) { \
    switch((n)&7) {   \
    case EAX_INDEX: l = pctxt->Eax; break; \
    case ECX_INDEX: l = pctxt->Ecx; break; \
    case EDX_INDEX: l = pctxt->Edx; break; \
    case EBX_INDEX: l = pctxt->Ebx; break; \
    case ESP_INDEX: l = pctxt->Esp; break; \
    case EBP_INDEX: l = pctxt->Ebp; break; \
    case ESI_INDEX: l = pctxt->Esi; break; \
    case EDI_INDEX: l = pctxt->Edi; break; \
    default: l=0; }                        \
}

#define GET_USER_UBYTE(p)   (*((UCHAR *)(p)))
#define GET_USER_ULONG(p)   (*((ULONG *)(p)))

//
// XMMI Instruction register set
//
typedef enum _XMMI_REGISTER_SET {
    xmmi0 =  0, 
    xmmi1 =  1, 
    xmmi2 =  2, 
    xmmi3 =  3,
    xmmi4 =  4, 
    xmmi5 =  5, 
    xmmi6 =  6, 
    xmmi7 =  7
} XMMI_REGISTER_SET;

#define MaskCW_RC   3   /* Rounding Control */
typedef enum _XMMI_ROUNDING_CONTROL {
    rc_near = 0,        /*   near */
    rc_down = 1,        /*   down */
    rc_up   = 2,        /*   up   */
    rc_chop = 3         /*   chop */
} XMMI_ROUNDING_CONTROL;


#define HAS_IMM8            1

#pragma pack(1)

//
// Instruction Information Table structure
//

typedef struct {
    ULONG Operation:12;       // Fp Operation code
    ULONG Op1Location:5;      // Location of 1st operand
    ULONG Op2Location:5;      // Location of 2nd operand
    ULONG Op3Location:3;      // imm8
    ULONG ResultLocation:5;   // Location of result
    ULONG NumArgs:2;          // # of args to the instruction 
} XMMI_INSTR_INFO, *PXMMI_INSTR_INFO;

//
// Instruction format
//

typedef struct {
    ULONG   Opcode1a:4;
    ULONG   Opcode1b:4;
    ULONG   RM:3;
    ULONG   Reg:3;
    ULONG   Mod:2;
    ULONG   Pad:16;
} XMMIINSTR, *PXMMIINSTR;


#ifdef LITTLE_ENDIAN

//
// Single Precision Type
//
typedef struct _FP32_TYPE {
    ULONG Significand:23;
    ULONG Exponent:8;   
    ULONG Sign:1;
} FP32_TYPE, *PFP32_TYPE;

//
// Double Precision Type
//
typedef struct _FP64_TYPE {
    ULONG SignificandLo;
    ULONG SignificandHi:20;
    ULONG Exponent:11;
    ULONG Sign:1;
} FP64_TYPE, *PFP64_TYPE;

//
// Exception Flags
//
typedef struct _XMMI_EXCEPTION_FLAGS {
    ULONG   ie:1;
    ULONG   de:1;
    ULONG   ze:1;
    ULONG   oe:1;
    ULONG   ue:1;
    ULONG   pe:1;
} XMMI_EXCEPTION_FLAGS, *PXMMI_EXCEPTION_FLAGS;

//
// Exception Masks
//
typedef struct _XMMI_EXCEPTION_MASKS {
    ULONG   im:1;
    ULONG   dm:1;
    ULONG   zm:1;
    ULONG   om:1;
    ULONG   um:1;
    ULONG   pm:1;
} XMMI_EXCEPTION_MASKS, *PXMMI_EXCEPTION_MASKS;

//
// Control/Status register
//
typedef struct _MXCSR {
    ULONG   ie:1;                      /* bit  0,  invalid operand exception */  
    ULONG   de:1;                      /* bit  1,  denormalized operand exception */       
    ULONG   ze:1;                      /* bit  2,  divide-by-zero exception */   
    ULONG   oe:1;                      /* bit  3,  numeric overflow exception */
    ULONG   ue:1;                      /* bit  4,  numeric underflow exception */
    ULONG   pe:1;                      /* bit  5,  inexact precision result exception */                                        
    ULONG   daz:1;                     /* bit  6,  reserved field before WMT C-Step */
    ULONG   im:1;                      /* bit  7,  invalid operand mask */
    ULONG   dm:1;                      /* bit  8,  denormalized operand mask */
    ULONG   zm:1;                      /* bit  9,  divide-by-zero mask */
    ULONG   om:1;                      /* bit  10, numeric overflow mask */
    ULONG   um:1;                      /* bit  11, numeric underflow mask */
    ULONG   pm:1;                      /* bit  12, inexact precision result mask */
    ULONG   Rc:2;                      /* bits 13-14, rounding control */
    ULONG   Fz:1;                      /* bit  15, flush to zero */
    ULONG   reserved2:16;              /* bits 16-31, reserved field */
} MXCSR, *PMXCSR;

#endif /* LITTLE_ENDIAN */

#pragma pack()

typedef struct _MXCSRReg {
    union {
        ULONG ul;
        MXCSR mxcsr;
    } u;
} MXCSRReg, *PMXCSRReg;

#define MXCSR_FLAGS_MASK 0x0000003f
#define MXCSR_MASKS_MASK 0x00001f80

//
// Define XMMI data types
//

/* type of 32 bit items */
typedef struct _XMMI32 {
    union {        
        ULONG     ul[1];
        USHORT    uw[2];
        UCHAR     ub[4];       
        LONG      l[1];        
        SHORT     w[2];        
        CHAR      b[4];       
        float     fs[1];      
        FP32_TYPE fp32;   
    } u;
} XMMI32, *PXMMI32;  

/* type of 64 bit items */
typedef struct _MMX64 {
    union {       
        DWORDLONG dl;       
        __int64   ull;
        ULONG     ul[2];        
        USHORT    uw[4];        
        UCHAR     ub[8];        
        LONGLONG  ll;        
        LONG      l[2];        
        SHORT     w[4];       
        CHAR      b[8];        
        float     fs[2];        
        FP32_TYPE fp32[2];        
        double    fd;        
        FP64_TYPE fp64;  
        _U64      u64;
    } u;
} MMX64, *PMMX64;  

/* type of 128 bit items */  
typedef struct _XMMI128 {   
    union {        
        DWORDLONG dl[2];       
        __int64   ull[2];
        ULONG     ul[4];        
        USHORT    uw[8];        
        UCHAR     ub[16];        
        LONGLONG  ll[2];        
        LONG      l[4];        
        SHORT     w[8];        
        CHAR      b[16];        
        float     fs[4];       
        FP32_TYPE fp32[4];        
        double    fd[2];       
        FP64_TYPE fp64[2];
        _FP128    fp128;
    } u;
} XMMI128, *PXMMI128;  


//
// Define fp enviornment data structure to store fp internal states for each data item in SIMD
//
typedef struct _XMMI_ENV {
    ULONG Masks;                  //Mask values from MxCsr
    ULONG Flags;                  //Exception flags
    ULONG Fz;                     //Flush to Zero
    ULONG Daz;                    //denormals are zero
    ULONG Rc;                     //Rounding
    ULONG Precision;              //Precision
    ULONG Imm8;                   //imm8 predicate
    ULONG EFlags;                 //EFLAGS
    _FPIEEE_RECORD *Ieee;         //Value description
} XMMI_ENV, *PXMMI_ENV;
    
// 
// Define fp environment data structure to keep track of fp internal states for SIMD
//
typedef struct _OPERAND {
    ULONG   OpLocation;               //Location of the operand
    ULONG   OpReg;                    //Register Number
    _FPIEEE_VALUE Op;                 //Value description
} OPERAND, *POPERAND;

typedef struct _XMMI_FP_ENV {
    ULONG IFlags;                     //Exception Flag values from the Processor MXCsr
    ULONG OFlags;                     //Exception Flag values from the Emulator (ORed)
    ULONG Raised[4];                  //Exception is raised or not for each data item
    ULONG Flags[4];                   //Exception Flag values for each data item
    ULONG OriginalOperation;          //Original opcode
    ULONG Imm8;                       //imm8 encoding
    ULONG EFlags;                     //EFlags values from the Emulator (ORed)
    OPERAND Operand1;                 //Operand1 (128 bits)
    OPERAND Operand2;                 //Operand2 (128 bits)
    OPERAND Result;                   //Result   (128 bits)
} XMMI_FP_ENV, *PXMMI_FP_ENV;
   
//
// encodings of imm8 for CMPPS, CMPSS
//

#define IMM8_EQ    0x00
#define IMM8_LT    0x01
#define IMM8_LE    0x02
#define IMM8_UNORD 0x03
#define IMM8_NEQ   0x04
#define IMM8_NLT   0x05
#define IMM8_NLE   0x06
#define IMM8_ORD   0x07

#ifdef _XMMI_DEBUG

#define DPrint(l,m)                { \
    if (l & DebugFlag) {             \
        printf m;                    \
        if (Console) _cprintf m;     \
    }                                \
}

#define PRINTF(m)                  { \
    printf m;                        \
    if (Console) _cprintf m;         \
}

#else

    #define DPrint(l,m)
    #define PRINTF(m)


#endif // DEBUG

#endif /* _XMMI_TYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\acosf.s ===
.file "acosf.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.

// History
//==============================================================
// 2/02/00  Initial revision
// 6/28/00  Improved speed
// 6/31/00  Changed register allocation because of some duplicate macros
//          moved nan exit bundle up to gain a cycle.
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 8/17/00  Changed predicate register macro-usage to direct predicate
//          names due to an assembler bug.
// 10/17/00 Improved speed of x=0 and x=1 paths, set D flag if x denormal.


// Description
//=========================================
// The acosf function computes the principle value of the arc sine of x.
// A doman error occurs for arguments not in the range [-1,+1].

// The acosf function returns the arc cosine in the range [0, +pi] radians.
// acos(1) returns +0
// acos(x) returns a Nan and raises the invalid exception for |x| >1 

// |x| <= sqrt(2)/2. get Ax and Bx

// poly_p1 = x p1
// poly_p3 = x2 p4 + p3
// poly_p1 = x2 (poly_p1) + x  = x2(x p1) + x
// poly_p2 = x2( poly_p3) + p2 = x2(x2 p4 + p3) + p2

// poly_Ax = x5(x2( poly_p3) + p2) + x2(x p1) + x
//         = x5(x2(x2 p4 + p3) + p2) + x2(x p1) + x

// poly_p7 = x2 p8 + p7
// poly_p5 = x2 p6 + p5

// poly_p7 = x4 p9 + (x2 p8 + p7)
// poly_Bx = x4 (x4 p9 + (x2 p8 + p7)) + x2 p6 + p5

// sinf1 = x11(x4 (x4 p9 + (x2 p8 + p7)) + x2 p6 + p5) + x5(x2(x2 p4 + p3) + p2) + x2(x p1) + x
//       = x19 p9 + x17 p8 + x15 p7 x13 p6 + x11 p5 + x9 p4 + x7 p3 + x5 p2 + x3 p1 + x
// answer1 = pi/2 - sinf1



// |x| >  sqrt(2)/2

// Get z = sqrt(1-x2)

// Get polynomial in t = 1-x2

// t2      = t t
// t4      = t2 t2

// poly_p4 = t p5 + p4
// poly_p1 = t p1 + 1

// poly_p6 = t p7 + p6
// poly_p2 = t p3 + p2

// poly_p8 = t p9 + p8

// poly_p4 = t2 poly_p6 + poly_p4
//         = t2 (t p7 + p6) + (t p5 + p4)

// poly_p2 = t2 poly_p2 + poly_p1
//         = t2 (t p3 + p2) + (t p1 + 1)

// poly_p4 = t4 poly_p8 + poly_p4
//         = t4 (t p9 + p8) + (t2 (t p7 + p6) + (t p5 + p4))

// P(t)    = poly_p2 + t4 poly_p8
//         = t2 (t p3 + p2) + (t p1 + 1) + t4 (t4 (t p9 + p8) + (t2 (t p7 + p6) + (t p5 + p4)))
//         = t3 p3 + t2 p2 + t p1 + 1 + t9 p9 + t8 p8 + t7 p7 + t6 p6 + t5 p5 + t4 p4


//  answer2 = sign(x) z P(t)       if x>0
//          = sign(x) z P(t) + pi  if x<0


//
// Assembly macros
//=========================================

// predicate registers
//acosf_pred_LEsqrt2by2            = p7
//acosf_pred_GTsqrt2by2            = p8

// integer registers
ACOSF_Addr1                      = r33
ACOSF_Addr2                      = r34
ACOSF_GR_1by2                    = r35

ACOSF_GR_3by2                    = r36
ACOSF_GR_5by2                    = r37

GR_SAVE_B0                    = r38
GR_SAVE_PFS                   = r39
GR_SAVE_GP                    = r40

GR_Parameter_X                = r41
GR_Parameter_Y                = r42
GR_Parameter_RESULT           = r43
GR_Parameter_TAG              = r44

// floating point registers

acosf_y                          = f32
acosf_abs_x                      = f33
acosf_x2                         = f34
acosf_sgn_x                      = f35

acosf_1by2                       = f36
acosf_3by2                       = f37
acosf_5by2                       = f38
acosf_coeff_P3                   = f39
acosf_coeff_P8                   = f40

acosf_coeff_P1                   = f41
acosf_coeff_P4                   = f42
acosf_coeff_P5                   = f43
acosf_coeff_P2                   = f44
acosf_coeff_P7                   = f45

acosf_coeff_P6                   = f46
acosf_coeff_P9                   = f47
acosf_x2                         = f48
acosf_x3                         = f49
acosf_x4                         = f50

acosf_x8                         = f51
acosf_x5                         = f52
acosf_const_piby2                = f53
acosf_const_sqrt2by2             = f54
acosf_x11                        = f55

acosf_poly_p1                    = f56
acosf_poly_p3                    = f57
acosf_sinf1                      = f58
acosf_poly_p2                    = f59
acosf_poly_Ax                    = f60

acosf_poly_p7                    = f61
acosf_poly_p5                    = f62
acosf_sgnx_t4                    = f63
acosf_poly_Bx                    = f64
acosf_t                          = f65

acosf_yby2                       = f66
acosf_B                          = f67
acosf_B2                         = f68
acosf_Az                         = f69
acosf_dz                         = f70

acosf_Sz                         = f71
acosf_d2z                        = f72
acosf_Fz                         = f73
acosf_z                          = f74
acosf_sgnx_z                     = f75

acosf_t2                         = f76
acosf_2poly_p4                   = f77
acosf_2poly_p6                   = f78
acosf_2poly_p1                   = f79
acosf_2poly_p2                   = f80

acosf_2poly_p8                   = f81
acosf_t4                         = f82
acosf_Pt                         = f83
acosf_sgnx_2poly_p2              = f84
acosf_sgn_x_piby2                = f85

acosf_poly_p7a                   = f86
acosf_2poly_p4a                  = f87
acosf_2poly_p4b                  = f88
acosf_2poly_p2a                  = f89
acosf_poly_p1a                   = f90





// Data tables
//==============================================================

.data

.align 16

acosf_coeff_1_table:
data8 0x3FC5555607DCF816 // P1
data8 0x3F9CF81AD9BAB2C6 // P4
data8 0x3FC59E0975074DF3 // P7
data8 0xBFA6F4CC2780AA1D // P6
data8 0x3FC2DD45292E93CB // P9
data8 0x3fe6a09e667f3bcd // sqrt(2)/2

acosf_coeff_2_table:
data8 0x3FA6F108E31EFBA6 // P3
data8 0xBFCA31BF175D82A0 // P8
data8 0x3FA30C0337F6418B // P5
data8 0x3FB332C9266CB1F9 // P2
data8 0x3ff921fb54442d18 // pi_by_2


.align 32
.global acosf

.section .text
.proc  acosf
.align 32

acosf:
 
// Load the addresses of the two tables.
// Then, load the coefficients and other constants.

{     .mfi 
     alloc      r32            = ar.pfs,1,8,4,0
     fnma.s1   acosf_t        =    f8,f8,f1
     dep.z ACOSF_GR_1by2 =    0x3f,24,8    // 0x3f000000
} 
{     .mfi 
     addl ACOSF_Addr1    =    @ltoff(acosf_coeff_1_table),gp
     fma.s1    acosf_x2       =    f8,f8,f0
     addl      ACOSF_Addr2    =    @ltoff(acosf_coeff_2_table),gp ;;
}

 
{     .mfi 
     ld8       ACOSF_Addr1    =    [ACOSF_Addr1]
     fmerge.s  acosf_abs_x    =    f1,f8
     dep ACOSF_GR_3by2 =    1,r0,22,8     // 0x3fc00000
} 
{     .mlx 
     nop.m                      999
     movl      ACOSF_GR_5by2  =    0x40200000;;
}

 

{     .mfi 
     setf.s    acosf_1by2     =    ACOSF_GR_1by2
     fmerge.s  acosf_sgn_x    =    f8,f1
     nop.i                      999
} 
{     .mfi 
     ld8       ACOSF_Addr2    =    [ACOSF_Addr2]
     nop.f 0
     nop.i                      999;;
}

 
{     .mfi 
     setf.s    acosf_5by2     =    ACOSF_GR_5by2
     fcmp.lt.s1 p11,p12 = f8,f0
     nop.i                      999;;
}

{ .mmf 
     ldfpd     acosf_coeff_P1,acosf_coeff_P4 =    [ACOSF_Addr1],16
     setf.s    acosf_3by2     =    ACOSF_GR_3by2
     fclass.m.unc p8,p0      = f8, 0xc3 ;;	//@qnan | @snan
}

 
{     .mfi 
     ldfpd     acosf_coeff_P7,acosf_coeff_P6 =    [ACOSF_Addr1],16
     fma.s1    acosf_t2                      =    acosf_t,acosf_t,f0
     nop.i                                     999
} 
{     .mfi 
     ldfpd     acosf_coeff_P3,acosf_coeff_P8 =    [ACOSF_Addr2],16
     fma.s1    acosf_x4                      =    acosf_x2,acosf_x2,f0
     nop.i                                     999;;
}

 
{     .mfi 
     ldfpd     acosf_coeff_P9,acosf_const_sqrt2by2     =    [ACOSF_Addr1]
     fclass.m.unc p10,p0      = f8, 0x07	//@zero
     nop.i                                     999
} 
{     .mfi 
     ldfpd     acosf_coeff_P5,acosf_coeff_P2 =    [ACOSF_Addr2],16
     fma.s1    acosf_x3  =    f8,acosf_x2,f0
     nop.i                                     999;;
}

 
{     .mfi 
     ldfd      acosf_const_piby2   =    [ACOSF_Addr2]
     frsqrta.s1     acosf_B,p0                   =    acosf_t
     nop.i                                               999
} 
{     .mfb 
     nop.m                                               999
(p8) fma.s f8                = f8,f1,f0
(p8) br.ret.spnt   b0 ;;  // Exit if x=nan
}

 
{     .mfb 
     nop.m                 999
     fcmp.eq.s1 p6,p0 = acosf_abs_x,f1
(p10) br.cond.spnt  ACOSF_ZERO ;;     // Branch if x=0
} 
 
{     .mfi 
     nop.m                 999
     fcmp.gt.s1 p9,p0 = acosf_abs_x,f1
     nop.i                 999;;
} 
 
{     .mfi 
     nop.m                 999
     fma.s1    acosf_x8  =    acosf_x4,acosf_x4,f0
     nop.i                 999
} 
{     .mfb 
     nop.m                      999
     fma.s1    acosf_t4  =    acosf_t2,acosf_t2,f0
(p6) br.cond.spnt  ACOSF_ABS_ONE ;;     // Branch if |x|=1
} 

{     .mfi 
     nop.m                 999
     fma.s1    acosf_x5  =    acosf_x2,acosf_x3,f0
     nop.i                 999
}
{     .mfb 
(p9) mov            GR_Parameter_TAG = 59
     fma.s1    acosf_yby2     =    acosf_t,acosf_1by2,f0
(p9) br.cond.spnt  __libm_error_region ;;    // Branch if |x|>1
}


{     .mfi 
     nop.m                 999
     fma.s1    acosf_Az  =    acosf_t,acosf_B,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fma.s1    acosf_B2  =    acosf_B,acosf_B,f0
     nop.i                 999;;
}
 
{     .mfi 
     nop.m                      999
     fma.s1    acosf_poly_p1  =    f8,acosf_coeff_P1,f0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acosf_2poly_p1 =    acosf_coeff_P1,acosf_t,f1
     nop.i                      999;;
}

{     .mfi 
     nop.m                      999
     fma.s1    acosf_poly_p3  =    acosf_coeff_P4,acosf_x2,acosf_coeff_P3
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acosf_2poly_p6 =    acosf_coeff_P7,acosf_t,acosf_coeff_P6
     nop.i                      999;;
} 

{     .mfi 
     nop.m                      999
     fma.s1    acosf_poly_p7  =    acosf_x2,acosf_coeff_P8,acosf_coeff_P7
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acosf_2poly_p2 =    acosf_coeff_P3,acosf_t,acosf_coeff_P2
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acosf_poly_p5  =    acosf_x2,acosf_coeff_P6,acosf_coeff_P5
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acosf_2poly_p4 =    acosf_coeff_P5,acosf_t,acosf_coeff_P4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    acosf_x11 =    acosf_x8,acosf_x3,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fnma.s1   acosf_dz  =    acosf_B2,acosf_yby2,acosf_1by2
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acosf_poly_p1a =    acosf_x2,acosf_poly_p1,f8
     nop.i                      999
}
{     .mfi 
     nop.m                      999
     fma.s1    acosf_2poly_p8 =    acosf_coeff_P9,acosf_t,acosf_coeff_P8
     nop.i                      999;;
}

 
// Get the absolute value of x and determine the region in which x lies

{     .mfi 
     nop.m                      999
     fcmp.le.s1     p7,p8 = acosf_abs_x,acosf_const_sqrt2by2
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acosf_poly_p2  =    acosf_x2,acosf_poly_p3,acosf_coeff_P2
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acosf_poly_p7a =    acosf_x4,acosf_coeff_P9,acosf_poly_p7
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acosf_2poly_p2a =    acosf_2poly_p2,acosf_t2,acosf_2poly_p1
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                                                         999
(p8) fma.s1    acosf_sgnx_t4  =    acosf_sgn_x,acosf_t4,f0
     nop.i                                                         999
} 
{     .mfi 
     nop.m                      999
(p8) fma.s1    acosf_2poly_p4a =    acosf_2poly_p6,acosf_t2,acosf_2poly_p4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
(p8) fma.s1    acosf_Sz  =    acosf_5by2,acosf_dz,acosf_3by2
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
(p8) fma.s1    acosf_d2z =    acosf_dz,acosf_dz,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                           999
(p8) fnma.d.s1   acosf_sgn_x_piby2 =    acosf_sgn_x,acosf_const_piby2,acosf_const_piby2
     nop.i                           999
} 
{     .mfi 
     nop.m                      999
(p7) fma.s1    acosf_poly_Ax  =    acosf_x5,acosf_poly_p2,acosf_poly_p1a
     nop.i                 999;;
} 
 
{     .mfi 
     nop.m                      999
(p7) fma.s1    acosf_poly_Bx  =    acosf_x4,acosf_poly_p7a,acosf_poly_p5
     nop.i                      999
} 
{     .mfi 
     nop.m                           999
(p8) fma.s1    acosf_sgnx_2poly_p2 =    acosf_sgn_x,acosf_2poly_p2a,f0
     nop.i                           999;;
} 
 
{     .mfi 
     nop.m                      999
     fcmp.eq.s0 p6,p0 = f8,f0      // Only purpose is to set D if x denormal
     nop.i                      999
}
{     .mfi 
     nop.m                      999
(p8) fma.s1    acosf_2poly_p4b =    acosf_2poly_p8,acosf_t4,acosf_2poly_p4a
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
(p8) fma.s1    acosf_Fz  =    acosf_d2z,acosf_Sz,acosf_dz
     nop.i                 999;;
} 

 
{     .mfi 
     nop.m                 999
(p8) fma.d.s1  acosf_Pt  =    acosf_2poly_p4b,acosf_sgnx_t4,acosf_sgnx_2poly_p2
     nop.i                 999;;
} 
 
{     .mfi 
     nop.m                 999
(p8) fma.d.s1  acosf_z   =    acosf_Az,acosf_Fz,acosf_Az
     nop.i                 999 ;;
} 
 
{     .mfi 
     nop.m                      999
(p7) fma.d.s1  acosf_sinf1    =    acosf_x11,acosf_poly_Bx,acosf_poly_Ax
     nop.i                      999;;
} 
 
.pred.rel "mutex",p8,p7    //acosf_pred_GTsqrt2by2,acosf_pred_LEsqrt2by2
{     .mfi 
      nop.m            999
(p8)  fma.s     f8   =    acosf_z,acosf_Pt,acosf_sgn_x_piby2
      nop.i            999
} 
 
{     .mfb 
      nop.m            999
(p7)  fms.s     f8   =    acosf_const_piby2,f1,acosf_sinf1
      br.ret.sptk b0 ;;
} 

ACOSF_ZERO:
// Here if x=0
{     .mfb 
      nop.m                 999
      fma.s    f8 =    acosf_const_piby2,f1,f0  // acosf(0)=pi/2
      br.ret.sptk b0 ;;
} 


.pred.rel "mutex",p11,p12
ACOSF_ABS_ONE:
// Here if |x|=1
{     .mfi 
      nop.m                 999
(p11) fma.s    f8 =    acosf_const_piby2,f1,acosf_const_piby2 // acosf(-1)=pi
      nop.i                 999
} 
{     .mfb 
      nop.m                 999
(p12) fma.s    f8 =    f1,f0,f0 // acosf(1)=0
      br.ret.sptk b0 ;;
} 

.endp acosf


// Stack operations when calling error support.
//       (1)               (2)
//   sp   -> +          psp -> +
//           |                 |
//           |                 | <- GR_Y
//           |                 |
//           | <-GR_Y      Y2->|
//           |                 |
//           |                 | <- GR_X
//           |                 |
//  sp-64 -> +          sp ->  +
//    save ar.pfs          save b0
//    save gp


// Stack operations when calling error support.
//     (3) (call)              (4)
//  psp -> +                   sp -> +
//         |                         |
//    R3 ->| <- GR_RESULT            | -> f8
//         |                         |
//    Y2 ->| <- GR_Y                 |
//         |                         |
//    X1 ->|                         |
//         |                         |
//  sp ->  +                         +
//                              restore gp
//                              restore ar.pfs


.proc __libm_error_region
__libm_error_region:
.prologue
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
                nop.f 999
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfs [GR_Parameter_Y] = f1,16         // Store Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
};;

.body
{ .mfi
        nop.m 0
        frcpa.s0 f9,p0 = f0,f0
        nop.i 0
};;

{ .mib
        stfs [GR_Parameter_X] = f8            // Store Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
        nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfs [GR_Parameter_Y] = f9           // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#   // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region

.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\atan.s ===
.file "atan.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version
// 4/13/00: Improved speed
// 4/19/00: Removed the qualifying predicate from the fmerge.s that
//          takes the absolute value.
// 6/16/00: Reassigned FP registers to eliminate stalls on loads
// 8/30/00: Saved 5 cycles in main path by rearranging large argument logic
//          and delaying use of result of fcmp in load by 1 group
//
// API
//==============================================================
// double atan( double x);
//
// Overview of operation
//==============================================================
// atan(x) = sign(X)pi/2 - atan(1/x)
//
// We have two paths: |x| > 1 and |x| <= 1
//
// |x| >  1
// ==========================================
//
// c  = frcpa(x) which is approximately 1/x
//
// xc = 1- B
// B  = 1-xc
//
// Approximate 1/(1-B)^k by a polynomial in B, poly(B)
// k is 45.
//
// poly(B)     = 1 + r1 B + r2 B^2 + ...+ r10 B^10
//
// c^k         = (1-B)^k/x^k
// c^k/(1-B)^k = 1/x^k 
// c^k poly(B) = 1/x^k

// poly(x)     = series(atan(1/x)) = 1/x - 1/3x^3 + 1/5x^5 - 1/7x^7 .... + 1/45 x^45
//                                 = 1/x^45 ( x^44 - x^42/3 + x^40/5 - x^38/7 ... +1)
//                                 = 1/x^45 ( y^22 - y^21/3 + y^20/5 - y^19/7 ... +1)
//        
//                                 = c^45 poly(B) poly(x)
//                                 = c^45 r(B) q(y)

// q(y) = q0 + q1 y + q2 y^2 + ... + q22 y^22
// where q22 is 1.0

// atan(x) = sign(X)pi/2 -  c^45 r(B) q(y)

// |x| <=  1
// ==========================================
// poly(x)    = series(atan(x))   = x - x^3/3 + x^5/5 + .....
// poly(x)    = series(atan(x))   = x  + x^3(- 1/3 + x^2/5 + ..... +x^47/47)
// poly(x)    = series(atan(x))   = x  + x^3(p0 + x^2/5 + ..... + x^44/47)
// poly(x)    = series(atan(x))   = x  + x^3(p0 + y/5 + ..... + y^22/47)
   
// where p0 is about -1/3.

// atan(x) = poly(x)



// Special Values
//==============================================================
// atan(QNAN)  = QNAN
// atan(SNAN)  = quieted SNAN
// atan(+-inf) = +- pi/2     
// atan(+-0)   = +-0



// Registers used
//==============================================================

// predicate registers used: 
// p6 -> p11

// floating-point registers used:  
// f32 -> f127

// general registers used
// r32 -> r37

// Assembly macros
//==============================================================
atan_Pi_by_2                  = f32
atan_S_PI                     = f33
atan_ABS_f8                   = f34

atan_R0                       = f35
atan_R1                       = f36
atan_R2                       = f37
atan_R3                       = f38 
atan_R4                       = f39 
atan_R5                       = f40 
atan_R6                       = f41
atan_R7                       = f42
atan_R8                       = f43 
atan_R9                       = f44 
atan_R10                      = f45 

atan_Q0                       = f46

atan_Q1                       = f47 
atan_Q2                       = f48
atan_Q3                       = f49
atan_Q4                       = f50
atan_Q5                       = f51 
atan_Q6                       = f52 
atan_Q7                       = f53 
atan_Q8                       = f54 
atan_Q9                       = f55 
atan_Q10                      = f56 

atan_Q11                      = f57 
atan_Q12                      = f58
atan_Q13                      = f59
atan_Q14                      = f60
atan_Q15                      = f61 
atan_Q16                      = f62 
atan_Q17                      = f63 
atan_Q18                      = f64 
atan_Q19                      = f65 
atan_Q20                      = f66 
atan_Q21                      = f67 
atan_Q22                      = f68 

// P and Q constants are mutually exclusive 
// so they can share macro definitions
atan_P0                       = f46

atan_P1                       = f47 
atan_P2                       = f48
atan_P3                       = f49
atan_P4                       = f10
atan_P5                       = f11 
atan_P6                       = f12 
atan_P7                       = f13 
atan_P10                      = f103 

atan_P11                      = f114 
atan_P12                      = f58
atan_P13                      = f59
atan_P14                      = f60
atan_P15                      = f61 
atan_P16                      = f62 
atan_P17                      = f63 
atan_P18                      = f64 
atan_P19                      = f65 
atan_P20                      = f14 
atan_P21                      = f99 
atan_P22                      = f68 
// end of P constant macros

atan_C                        = f69
atan_Y                        = f70
atan_B                        = f71
atan_Z                        = f72
atan_V11                      = f73
atan_V12                      = f74

atan_V7                       = f75
atan_V8                       = f76

atan_W13                      = f77
atan_W11                      = f78

atan_V3                       = f79
atan_V4                       = f80

atan_G11                      = f81
atan_G12                      = f82
atan_G7                       = f83
atan_G8                       = f84

atan_Z1                       = f85
atan_W7                       = f86

atan_G3                       = f87
atan_W8                       = f88
atan_V9                       = f89
atan_V10                      = f90

atan_G10                      = f91
atan_W3                       = f92
atan_G4                       = f93
atan_G9                       = f94
                                
atan_G6                       = f95
atan_W4                       = f96
atan_Z2                       = f97
atan_V6                       = f98
                              
atan_V2                       = f99
atan_W6                       = f100
atan_W10                      = f101
atan_Y3                       = f102
                              
atan_G2                       = f103

atan_Y8                       = f104
                              
atan_G5                       = f105
atan_Z3                       = f106
atan_Z4                       = f107
atan_W2                       = f108
atan_V5                       = f109
                            
atan_W5                       = f110
atan_G1                       = f111
atan_Y11                      = f112
                             
atan_Z5                       = f113
atan_Z6                       = f114
atan_V1                       = f115
atan_W1                       = f116
                              
atan_Z7                       = f117
atan_Q                        = f118
atan_Z                        = f119
atan_abs_f8                   = f120                            

atan_V13                      = f121
atan_Xcub                     = f122
atan_Y12                      = f123
atan_P                        = f124

atan_NORM_f8                  = f125

atan_P8                       = f126
atan_P9                       = f127




atan_GR_AD_R                 = r14
atan_GR_AD_Q                 = r15
atan_GR_AD_P                 = r16
atan_GR_10172                = r17 
atan_GR_exp_f8               = r18 
atan_GR_signexp_f8           = r19
atan_GR_exp_mask             = r20




/////////////////////////////////////////////////////////////


.data

.align 16

double_atan_constants_R:
   data8 0xB36B46B9C5443CED, 0x0000401C  //R8
   data8 0x842633E0D126261F, 0x0000401F  //R9
   data8 0xBE04FFFFFFFF46E0, 0x00004010  //R4
   data8 0xE8C62000244D66E2, 0x00004013  //R5
   data8 0xF2790C001E3789B3, 0x00004016  //R6
   data8 0xDCD2CCF97D7C764F, 0x00004019  //R7
   data8 0xB40000000000000B, 0x00004004  //R1
   data8 0xB265F3D38F5EE28F, 0x00004021  //R10
   data8 0x8160000000000001, 0x00004009  //R2
   data8 0xFD5BFFFFFFFE55CD, 0x0000400C  //R3
   data8 0xC90FDAA22168C235, 0x00003FFF  // pi/2 

double_atan_constants_Q:
   data8 0xEBD602FA7761BC33, 0x00003FF9  //Q8
   data8 0x8CB1CABD6A91913C, 0x0000BFFA  //Q9
   data8 0x84C665C37D623CD2, 0x00003FF7  //Q4
   data8 0x8DE0D1673DAEA9BC, 0x0000BFF8  //Q5
   data8 0xF658ADBE2C6E6FCC, 0x00003FF8  //Q6

   data8 0xB56307BE1DD3FFB6, 0x0000BFF9  //Q7
   data8 0xAAAAAAAAAAAA8000, 0x0000BFFD  //Q21
   data8 0x8000000000000000, 0x00003FFF  //Q22
   data8 0x924924923A9D710C, 0x0000BFFC  //Q19
   data8 0xCCCCCCCCCC9380E7, 0x00003FFC  //Q20
 
   data8 0xA644DC250EFA2800, 0x00003FED  //Q0
   data8 0x83DEAE24EEBF5E44, 0x0000BFF1  //Q1
   data8 0xC758CCC64793D4EC, 0x00003FF3  //Q2
   data8 0xBFDC0B54E7C89DCE, 0x0000BFF5  //Q3
   data8 0x888855199D1290AF, 0x0000BFFB  //Q15

   data8 0x9D89D3BE514B0178, 0x00003FFB  //Q16
   data8 0xBA2E8B4DEC70282A, 0x0000BFFB  //Q17
   data8 0xE38E38DF9E9FC83B, 0x00003FFB  //Q18
   data8 0x9F8781CC990029D9, 0x00003FFA  //Q10
   data8 0xB0B39472DEBA3C79, 0x0000BFFA  //Q11

   data8 0xC2AFAEF8C85B0BC6, 0x00003FFA  //Q12
   data8 0xD780E539797525DD, 0x0000BFFA  //Q13
   data8 0xF0EDC449AC786DF9, 0x00003FFA  //Q14



double_atan_constants_P:
   data8 0xB1899EC590CDB8DF, 0x0000BFFA //P10
   data8 0xA1E79850A67D59B0, 0x00003FFA //P11
   data8 0x911D8B30C2A96E6D, 0x0000BFF3 //P20
   data8 0xB87233C68A640706, 0x00003FF0 //P21
   data8 0xD78E4B82F3C29D7A, 0x0000BFFA //P8

   data8 0xC2EBE37AF932C14F, 0x00003FFA //P9
   data8 0xBA2E8B94AA104DD6, 0x0000BFFB //P4
   data8 0x9D89D7A640B71D38, 0x00003FFB //P5
   data8 0x88887CA2CE9B2A40, 0x0000BFFB //P6
   data8 0xF0F017D57A919C1E, 0x00003FFA //P7

   data8 0xD0D635F230C80E06, 0x0000BFF8 //P16
   data8 0xE847BECA7209B479, 0x00003FF7 //P17
   data8 0xD14C6A2AAE0D5B07, 0x0000BFF6 //P18
   data8 0x915F612A5C469117, 0x00003FF5 //P19
   data8 0x921EDE5FD0DBBBE2, 0x0000BFFA //P12

   data8 0xFFD303C2C8535445, 0x00003FF9 //P13
   data8 0xD30DF50E295386F7, 0x0000BFF9 //P14
   data8 0x9E81F2B1BBD210A8, 0x00003FF9 //P15
   data8 0xAAAAAAAAAAAAA800, 0x0000BFFD //P0
   data8 0xCCCCCCCCCCC7D476, 0x00003FFC //P1

   data8 0x9249249247838066, 0x0000BFFC //P2
   data8 0xE38E38E302290D68, 0x00003FFB //P3
   data8 0xDF7F0A816F7E5025, 0x0000BFEC //P22


.align 32
.global atan#

////////////////////////////////////////////////////////



.section .text
.proc  atan#
.align 32

atan: 

{ .mmf
(p0)  addl      atan_GR_AD_P   = @ltoff(double_atan_constants_P), gp
(p0)  addl      atan_GR_AD_Q   = @ltoff(double_atan_constants_Q), gp
(p0)  fmerge.s  atan_ABS_f8  = f0,f8                       
}
;;

{ .mmf
      ld8 atan_GR_AD_P = [atan_GR_AD_P]
      ld8 atan_GR_AD_Q = [atan_GR_AD_Q]
(p0)  frcpa.s1     atan_C,p8 = f1,f8                                  
}
;;

{ .mmf
(p0)  addl      atan_GR_AD_R   = @ltoff(double_atan_constants_R), gp
(p0)  addl      atan_GR_exp_mask = 0x1ffff, r0
(p0)  fma.s1       atan_Y = f8,f8,f0                                  
}
;;

// This fnorm takes faults or sets fault flags
{ .mmf
(p0)  mov       atan_GR_10172 = 0x10172
      ld8 atan_GR_AD_R = [atan_GR_AD_R]
(p0)  fnorm     atan_NORM_f8  = f8
}
;;


// qnan snan inf norm     unorm 0 -+
// 1    1    0   0        0     1 11
// c                      7

// p9 set if we have a NAN or +-0

{ .mmf
(p0)  ldfe      atan_Q8  = [atan_GR_AD_Q],16 
(p0)  ldfe      atan_P10    = [atan_GR_AD_P],16                   
(p0)  fclass.m.unc p9, p0   = f8, 0xc7                         
}
;;


{ .mmi
(p0)  ldfe      atan_Q9  = [atan_GR_AD_Q],16 
(p0)  ldfe      atan_P11    = [atan_GR_AD_P],16                   
      nop.i 999   
}
;;

        
{ .mmf
(p0)  ldfe      atan_Q4      = [atan_GR_AD_Q],16 
(p0)  ldfe      atan_P20     = [atan_GR_AD_P],16                   
(p9)  fma.d.s0  f8          = f8,f1,f0
;;
}

// Exit if we have a NAN or +-0
{ .mmb
(p0)  ldfe      atan_Q5     = [atan_GR_AD_Q],16 
(p0)  ldfe      atan_P21    = [atan_GR_AD_P],16                   
(p9)  br.ret.spnt b0
;;
}


// p6 is TRUE if |x| <= 1
// p7 is TRUE if |x| >  1
{ .mmf
(p0)  ldfe      atan_Q6  = [atan_GR_AD_Q],16 
(p0)  ldfe      atan_P8  = [atan_GR_AD_P],16                   
(p0)  fcmp.le.unc  p6,p7 = atan_ABS_f8, f1 
;;
}


{ .mfi
(p0)  ldfe         atan_Q7  = [atan_GR_AD_Q],16 
(p0)  fma.s1       atan_Z   = atan_C, atan_C, f0                        
      nop.i 999   
}
{ .mfi
(p0)  ldfe         atan_P9  = [atan_GR_AD_P],16                   
(p0)  fnma.s1      atan_B   = atan_C,f8, f1                             
      nop.i 999    ;;
}


{ .mfi
(p0)  ldfe         atan_Q21  = [atan_GR_AD_Q],16 
(p0)  fma.s1       atan_V12  = atan_Y, atan_Y, f0                      
      nop.i 999   
}
{ .mfi
(p0)  ldfe         atan_P4    = [atan_GR_AD_P],16                   
(p0)  fma.s1       atan_Xcub  = f8, atan_Y  , f0                        
      nop.i 999   
;;
}


{ .mmi
(p7)  ldfe      atan_Q22         = [atan_GR_AD_Q],16 
(p6)  ldfe      atan_P5          = [atan_GR_AD_P],16                   
(p6)  cmp.eq.unc  p8,p0 = r0,r0
;;
}


{ .mmi
(p7)  ldfe      atan_Q19   = [atan_GR_AD_Q],16 
(p6)  ldfe      atan_P6    = [atan_GR_AD_P],16                   
(p7)  cmp.eq.unc  p9,p0 = r0,r0
;;
}


{ .mmi
(p7)  ldfe      atan_Q20  = [atan_GR_AD_Q],16 
(p6)  ldfe      atan_P7    = [atan_GR_AD_P],16                   
      nop.i 999   
;;
}

{ .mfi
(p7)  ldfe      atan_Q0  = [atan_GR_AD_Q],16 
(p6)  fma.s1       atan_V13 = atan_Y, atan_P11, atan_P10              
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P16    = [atan_GR_AD_P],16                   
(p7)  fma.s1       atan_V11 = atan_Y, atan_Q9, atan_Q8                
      nop.i 999    ;;
}


{ .mfi
(p7)  ldfe      atan_Q1  = [atan_GR_AD_Q],16 
(p7)  fma.s1       atan_G12 = atan_B, atan_B, f0                      
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P17    = [atan_GR_AD_P],16                   
(p0)  fma.s1       atan_V9  = atan_V12, atan_V12, f0                  
      nop.i 999    ;;
}


{ .mfi
(p7)  ldfe      atan_Q2  = [atan_GR_AD_Q],16 
(p6)  fma.s1       atan_W11 = atan_Y, atan_P21, atan_P20              
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P18    = [atan_GR_AD_P],16                   
(p7)  fma.s1       atan_V7  = atan_Y, atan_Q5, atan_Q4                
      nop.i 999    ;;
}

{ .mfi
(p7)  ldfe      atan_Q3  = [atan_GR_AD_Q],16 
(p7)  fma.s1    atan_Z1  = atan_Z, atan_Z, f0                      
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P19    = [atan_GR_AD_P],16                   
(p7)  fma.s1       atan_Y3  = atan_Y  , atan_V12, f0                  
      nop.i 999    ;;
}

{ .mfi
(p7)  ldfe      atan_R8  = [atan_GR_AD_R],16 
(p6)  fma.s1       atan_V11 = atan_Y, atan_P9, atan_P8                
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P12    = [atan_GR_AD_P],16                   
(p7)  fma.s1       atan_V8  = atan_Y, atan_Q7, atan_Q6                
      nop.i 999    ;;
}

{ .mmi
(p7)  ldfe      atan_R9     = [atan_GR_AD_R],16 
(p6)  ldfe      atan_P13    = [atan_GR_AD_P],16                   
      nop.i 999   
;;
}

{ .mfi
(p7)  ldfe      atan_R4  = [atan_GR_AD_R],16 
(p6)  fma.s1    atan_V7  = atan_Y, atan_P5, atan_P4                 
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P14    = [atan_GR_AD_P],16                   
(p7)  fma.s1       atan_W13 = atan_Y, atan_Q22, atan_Q21              
      nop.i 999    ;;
}


{ .mfi
(p7)  ldfe      atan_R5  = [atan_GR_AD_R],16 
(p6)  fma.s1    atan_Y12 = atan_V9 , atan_V9 , f0                   
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P15    = [atan_GR_AD_P],16                   
(p7)  fma.s1    atan_Y8 = atan_V9 , atan_V9 , f0                   
      nop.i 999    ;;
}


{ .mfi
(p7)  ldfe      atan_R6  = [atan_GR_AD_R],16 
(p6)  fma.s1    atan_V8  = atan_Y, atan_P7, atan_P6                 
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P0     = [atan_GR_AD_P],16                   
(p7)  fma.s1       atan_W11 = atan_Y, atan_Q20, atan_Q19              
      nop.i 999    ;;
}


{ .mfi
(p7)  ldfe      atan_R7  = [atan_GR_AD_R],16 
(p7)  fma.s1    atan_Z2  = atan_Z1 , atan_Z1,  f0                  
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P1     = [atan_GR_AD_P],16                   
(p6)  fma.s1       atan_V10 = atan_V12, atan_V13, atan_V11             
      nop.i 999    ;;
}

{ .mfi
(p7)  ldfe      atan_Q15 = [atan_GR_AD_Q],16 
(p6)  fma.s1    atan_W7  = atan_Y, atan_P17, atan_P16               
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P2     = [atan_GR_AD_P],16                   
(p7)  fma.s1       atan_V3  = atan_Y, atan_Q1 , atan_Q0               
      nop.i 999    ;;
}

{ .mfi
(p7)  ldfe      atan_Q16 = [atan_GR_AD_Q],16 
(p7)  fma.s1    atan_G9  = atan_G12, atan_G12, f0                  
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P3     = [atan_GR_AD_P],16                   
(p7)  fma.s1       atan_V6  = atan_V12, atan_V8,  atan_V7             
      nop.i 999    ;;
}


{ .mfi
(p7)  ldfe      atan_R1     = [atan_GR_AD_R],16 
(p6)  fma.s1       atan_W8  = atan_Y, atan_P19, atan_P18               
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P22    = [atan_GR_AD_P],16                   
(p7)  fma.s1       atan_V4  = atan_Y, atan_Q3 , atan_Q2               
      nop.i 999    ;;
}


{ .mfi
      getf.exp     atan_GR_signexp_f8  = atan_NORM_f8
(p7)  fma.s1       atan_Y11 = atan_Y3 , atan_Y8 , f0                  
      nop.i 999   
}
{ .mfi
(p7)  ldfe      atan_Q17    = [atan_GR_AD_Q],16 
(p6)  fma.s1       atan_V6  = atan_V12, atan_V8,  atan_V7             
      nop.i 999    ;;
}


{ .mfi
(p7)  ldfe      atan_Q18    = [atan_GR_AD_Q],16 
(p6)  fma.s1       atan_W3  = atan_Y, atan_P13, atan_P12               
      nop.i 999   
}
{ .mfi
(p7)  ldfe      atan_R10    = [atan_GR_AD_R],16 
(p7)  fma.s1       atan_G11 = atan_B, atan_R9 , atan_R8               
      nop.i 999    ;;
}


{ .mfi
(p7)  ldfe      atan_Q10    = [atan_GR_AD_Q],16 
(p7)  fma.s1    atan_Z3     = atan_Z1 , atan_Z2 , f0                  
(p0)  and       atan_GR_exp_f8 = atan_GR_signexp_f8,atan_GR_exp_mask
}
{ .mfi
(p7)  ldfe      atan_R2     = [atan_GR_AD_R],16 
(p7)  fma.s1       atan_Z4  = atan_Z2 , atan_Z2 , f0                  
      nop.i 999    ;;
}


{ .mfi
(p7)  ldfe      atan_Q11 = [atan_GR_AD_Q],16 
(p6)  fma.s1    atan_W4  = atan_Y, atan_P15, atan_P14               
      nop.i 999
}
{ .mfi
(p7)  ldfe      atan_R3     = [atan_GR_AD_R],16 
(p7)  fma.s1       atan_G7  = atan_B, atan_R5 , atan_R4               
(p0)  cmp.le.unc   p11,p0  = atan_GR_10172,atan_GR_exp_f8 
;;
}


{ .mmf
(p9)  ldfe      atan_Q12 = [atan_GR_AD_Q],16 
(p0)  ldfe      atan_S_PI     = [atan_GR_AD_R],16 
(p8)  fma.s1       atan_W6  = atan_V12, atan_W8,  atan_W7             
;;
}



{ .mfi
(p9)  ldfe      atan_Q13 = [atan_GR_AD_Q],16 
(p8)  fma.s1       atan_V3  = atan_Y, atan_P1 , atan_P0                
(p11) cmp.ne.and p6,p7 = r0,r0
}
{ .mfi
      nop.m 999
(p8)  fma.s1       atan_V5  = atan_V9 , atan_V10, atan_V6             
      nop.i 999    ;;
}


.pred.rel "mutex",p6,p7,p11
{ .mfi
(p7)  ldfe      atan_Q14 = [atan_GR_AD_Q],16 
(p6)  fma.s1       atan_Y12 = atan_V9 , atan_Y12, f0                   
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1    atan_G8  = atan_B, atan_R7 , atan_R6               
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p6)  fma.s1       atan_V4  = atan_Y, atan_P3 , atan_P2                
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_W7  = atan_Y, atan_Q16, atan_Q15              
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p6)  fma.s1       atan_W10 = atan_V12, atan_P22, atan_W11            
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_G3  = atan_B, atan_R1 , f1                    
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p6)  fma.s1    atan_W2  = atan_V12, atan_W4 , atan_W3             
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_V2  = atan_V12, atan_V4 , atan_V3              
      nop.i 999    ;;
}

{ .mfi
      nop.m 999
(p7)  fma.s1       atan_W8  = atan_Y, atan_Q18, atan_Q17              
      nop.i 999   
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_G10 = atan_G12, atan_R10, atan_G11            
      nop.i 999    ;;
}

{ .mfi
      nop.m 999
(p7)  fma.s1       atan_V10 = atan_V12, atan_Q10, atan_V11            
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_G6  = atan_G12, atan_G8 , atan_G7             
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p6)  fma.s1       atan_V2  = atan_V12, atan_V4,  atan_V3             
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_G4  = atan_B  , atan_R3 , atan_R2             
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p6)  fma.s1       atan_W5  = atan_V9 , atan_W10, atan_W6             
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_W3  = atan_Y  , atan_Q12, atan_Q11            
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p7)  fma.s1       atan_Z5  = atan_Z3 , atan_Z4 , f0                  
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_W10 = atan_V12, atan_W13, atan_W11            
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p7)  fma.s1       atan_W4  = atan_Y  , atan_Q14, atan_Q13            
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_W6  = atan_V12, atan_W8,  atan_W7             
      nop.i 999    ;;
}

{ .mfi
      nop.m 999
(p7)  fma.s1       atan_V5  = atan_V9 , atan_V10, atan_V6             
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_G5  = atan_G9 , atan_G10, atan_G6             
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p6)  fma.s1       atan_V1  = atan_V9 , atan_V5 , atan_V2             
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_G2  = atan_G12, atan_G4 , atan_G3             
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p6)  fma.s1       atan_W1  = atan_V9 , atan_W5 , atan_W2             
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_Z6  = atan_Z4 , atan_C  , f0                  
      nop.i 999    ;;
}

{ .mfi
      nop.m 999
(p0)  fmerge.s    atan_S_PI = f8, atan_S_PI
      nop.i 999     ;;
}


{ .mfi
      nop.m 999
(p7)  fma.s1       atan_W5  = atan_V9 , atan_W10, atan_W6             
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_W2  = atan_V12, atan_W4 , atan_W3             
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p7)  fma.s1       atan_G1  = atan_G9 , atan_G5 , atan_G2             
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_V1  = atan_V9 , atan_V5 , atan_V2             
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p6)  fma.s1       atan_P   = atan_Y12, atan_W1 , atan_V1              
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_Z7  = atan_Z5 , atan_Z6 , f0                  
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p7)  fma.s1       atan_W1  = atan_V9 , atan_W5 , atan_W2             
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p11) fma.d.s0  f8 = atan_S_PI,f1,f0
      nop.i 999
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_Z   = atan_G1 , atan_Z7 , f0                  
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p7)  fma.s1       atan_Q   = atan_Y11, atan_W1 , atan_V1             
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p6)  fma.d.s0    f8       = atan_P  , atan_Xcub  , f8               
      nop.i 999    
}
{ .mfb
      nop.m 999
(p7)  fnma.d.s0    f8       = atan_Z  , atan_Q  , atan_S_PI           
(p0)  br.ret.sptk    b0    ;;
}

.endp atan
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\asinf.s ===
.file "asinf.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// Contributed 2/02/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.

// History
//==============================================================
// 2/02/00  Initial revision
// 6/28/00  Improved speed 
// 6/31/00  Changed register allocation because of some duplicate macros
//          moved nan exit bundle up to gain a cycle. 
// 8/08/00  Improved speed by avoiding SIR flush.
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 8/17/00  Changed predicate register macro-usage to direct predicate
//          names due to an assembler bug.
// 10/17/00 Improved speed of x=0 and x=1 paths, set D flag if x denormal.

// Description
//=========================================
// The asinf function computes the arc sine of x in the range [-pi,+pi].
// A doman error occurs for arguments not in the range [-1,+1].
// asinf(+-0) returns +-0
// asinf(x) returns a Nan and raises the invalid exception for |x| >1 

// The acosf function returns the arc cosine in the range [0, +pi] radians.
// A doman error occurs for arguments not in the range [-1,+1].
// acosf(1) returns +0
// acosf(x) returns a Nan and raises the invalid exception for |x| >1


// |x| <= sqrt(2)/2. get Ax and Bx

// poly_p1 = x p1
// poly_p3 = x2 p4 + p3
// poly_p1 = x2 (poly_p1) + x  = x2(x p1) + x
// poly_p2 = x2( poly_p3) + p2 = x2(x2 p4 + p3) + p2

// poly_Ax = x5(x2( poly_p3) + p2) + x2(x p1) + x
//         = x5(x2(x2 p4 + p3) + p2) + x2(x p1) + x

// poly_p7 = x2 p8 + p7
// poly_p5 = x2 p6 + p5

// poly_p7 = x4 p9 + (poly_p7)
// poly_p7 = x4 p9 + (x2 p8 + p7)
// poly_Bx = x4 (x4 p9 + (x2 p8 + p7)) + x2 p6 + p5

// answer1 = x11(x4 (x4 p9 + (x2 p8 + p7)) + x2 p6 + p5) + x5(x2(x2 p4 + p3) + p2) + x2(x p1) + x
//         = x19 p9 + x17 p8 + x15 p7 x13 p6 + x11 p5 + x9 p4 + x7 p3 + x5 p2 + x3 p1 + x



// |x| >  sqrt(2)/2

// Get z = sqrt(1-x2)

// Get polynomial in t = 1-x2

// t2      = t t
// t4      = t2 t2

// poly_p4 = t p5 + p4
// poly_p1 = t p1 + 1

// poly_p6 = t p7 + p6
// poly_p2 = t p3 + p2

// poly_p8 = t p9 + p8

// poly_p4 = t2 poly_p6 + poly_p4
//         = t2 (t p7 + p6) + (t p5 + p4)

// poly_p2 = t2 poly_p2 + poly_p1
//         = t2 (t p3 + p2) + (t p1 + 1)

// poly_p4 = t4 poly_p8 + poly_p4
//         = t4 (t p9 + p8) + (t2 (t p7 + p6) + (t p5 + p4))

// P(t)    = poly_p2 + t4 poly_p8
//         = t2 (t p3 + p2) + (t p1 + 1) + t4 (t4 (t p9 + p8) + (t2 (t p7 + p6) + (t p5 + p4)))
//         = t3 p3 + t2 p2 + t p1 + 1 + t9 p9 + t8 p8 + t7 p7 + t6 p6 + t5 p5 + t4 p4


//  answer2 = - sign(x) z P(t) + (sign(x) pi/2)
//


// Assembly macros
//=========================================

// predicate registers
//asinf_pred_LEsqrt2by2            = p7
//asinf_pred_GTsqrt2by2            = p8

// integer registers
ASINF_Addr1                      = r33
ASINF_Addr2                      = r34
ASINF_GR_1by2                    = r35

ASINF_GR_3by2                    = r36
ASINF_GR_5by2                    = r37

GR_SAVE_B0                    = r38
GR_SAVE_PFS                   = r39
GR_SAVE_GP                    = r40

GR_Parameter_X                = r41
GR_Parameter_Y                = r42
GR_Parameter_RESULT           = r43
GR_Parameter_TAG              = r44

// floating point registers

asinf_y                          = f32
asinf_abs_x                      = f33
asinf_x2                         = f34
asinf_sgn_x                      = f35

asinf_1by2                       = f36
asinf_3by2                       = f37
asinf_5by2                       = f38
asinf_coeff_P3                   = f39
asinf_coeff_P8                   = f40

asinf_coeff_P1                   = f41
asinf_coeff_P4                   = f42
asinf_coeff_P5                   = f43
asinf_coeff_P2                   = f44
asinf_coeff_P7                   = f45

asinf_coeff_P6                   = f46
asinf_coeff_P9                   = f47
asinf_x2                         = f48
asinf_x3                         = f49
asinf_x4                         = f50

asinf_x8                         = f51
asinf_x5                         = f52
asinf_const_piby2                = f53
asinf_const_sqrt2by2             = f54
asinf_x11                        = f55

asinf_poly_p1                    = f56
asinf_poly_p3                    = f57
asinf_sinf1                      = f58
asinf_poly_p2                    = f59
asinf_poly_Ax                    = f60

asinf_poly_p7                    = f61
asinf_poly_p5                    = f62
asinf_sgnx_t4                    = f63
asinf_poly_Bx                    = f64
asinf_t                          = f65

asinf_yby2                       = f66
asinf_B                          = f67
asinf_B2                         = f68
asinf_Az                         = f69
asinf_dz                         = f70

asinf_Sz                         = f71
asinf_d2z                        = f72
asinf_Fz                         = f73
asinf_z                          = f74
asinf_sgnx_z                     = f75

asinf_t2                         = f76
asinf_2poly_p4                   = f77
asinf_2poly_p6                   = f78
asinf_2poly_p1                   = f79
asinf_2poly_p2                   = f80

asinf_2poly_p8                   = f81
asinf_t4                         = f82
asinf_Pt                         = f83
asinf_sgnx_2poly_p2              = f84
asinf_sgn_x_piby2                = f85

asinf_poly_p7a                   = f86
asinf_2poly_p4a                  = f87
asinf_2poly_p4b                  = f88
asinf_2poly_p2a                  = f89
asinf_poly_p1a                   = f90





// Data tables
//==============================================================

.data

.align 16

asinf_coeff_1_table:
data8 0x3FC5555607DCF816 // P1
data8 0x3F9CF81AD9BAB2C6 // P4
data8 0x3FC59E0975074DF3 // P7
data8 0xBFA6F4CC2780AA1D // P6
data8 0x3FC2DD45292E93CB // P9
data8 0x3fe6a09e667f3bcd // sqrt(2)/2

asinf_coeff_2_table:
data8 0x3FA6F108E31EFBA6 // P3
data8 0xBFCA31BF175D82A0 // P8
data8 0x3FA30C0337F6418B // P5
data8 0x3FB332C9266CB1F9 // P2
data8 0x3ff921fb54442d18 // pi_by_2


.align 32
.global asinf

.section .text
.proc  asinf
.align 32

asinf:
 
// Load the addresses of the two tables.
// Then, load the coefficients and other constants.

{     .mfi 
     alloc      r32            = ar.pfs,1,8,4,0
     fnma.s1   asinf_t        =    f8,f8,f1
     dep.z ASINF_GR_1by2 =    0x3f,24,8    // 0x3f000000
} 
{     .mfi 
     addl ASINF_Addr1    =    @ltoff(asinf_coeff_1_table),gp
     fma.s1    asinf_x2       =    f8,f8,f0
     addl      ASINF_Addr2    =    @ltoff(asinf_coeff_2_table),gp ;;
}

 
{     .mfi 
     ld8       ASINF_Addr1    =    [ASINF_Addr1]
     fmerge.s  asinf_abs_x    =    f1,f8
     dep ASINF_GR_3by2 =    1,r0,22,8     // 0x3fc00000
} 
{     .mlx 
     nop.m                      999
     movl      ASINF_GR_5by2  =    0x40200000;;
}

 

{     .mfi 
     setf.s    asinf_1by2     =    ASINF_GR_1by2
     fmerge.s  asinf_sgn_x    =    f8,f1
     nop.i                      999
} 
{     .mfi 
     ld8       ASINF_Addr2    =    [ASINF_Addr2]
     nop.f 0
     nop.i                      999;;
}

 
{     .mfi 
     setf.s    asinf_5by2     =    ASINF_GR_5by2
     fcmp.lt.s1 p11,p12 = f8,f0
     nop.i                      999;;
}

{ .mmf 
     ldfpd     asinf_coeff_P1,asinf_coeff_P4 =    [ASINF_Addr1],16
     setf.s    asinf_3by2     =    ASINF_GR_3by2
     fclass.m.unc p8,p0      = f8, 0xc3 ;;	//@qnan | @snan
}

 
{     .mfi 
     ldfpd     asinf_coeff_P7,asinf_coeff_P6 =    [ASINF_Addr1],16
     fma.s1    asinf_t2                      =    asinf_t,asinf_t,f0
     nop.i                                     999
} 
{     .mfi 
     ldfpd     asinf_coeff_P3,asinf_coeff_P8 =    [ASINF_Addr2],16
     fma.s1    asinf_x4                      =    asinf_x2,asinf_x2,f0
     nop.i                                     999;;
}

 
{     .mfi 
     ldfpd     asinf_coeff_P9,asinf_const_sqrt2by2     =    [ASINF_Addr1]
     fclass.m.unc p10,p0      = f8, 0x07	//@zero
     nop.i                                     999
} 
{     .mfi 
     ldfpd     asinf_coeff_P5,asinf_coeff_P2 =    [ASINF_Addr2],16
     fma.s1    asinf_x3  =    f8,asinf_x2,f0
     nop.i                                     999;;
}

 
{     .mfi 
     ldfd      asinf_const_piby2   =    [ASINF_Addr2]
     frsqrta.s1     asinf_B,p0                   =    asinf_t
     nop.i                                               999
} 
{     .mfb 
     nop.m                                               999
(p8) fma.s f8                = f8,f1,f0
(p8) br.ret.spnt   b0 ;;  // Exit if x=nan
}

 
{     .mfb 
     nop.m                 999
     fcmp.eq.s1 p6,p0 = asinf_abs_x,f1
(p10) br.ret.spnt  b0 ;;     // Exit if x=0
} 
 
{     .mfi 
     nop.m                 999
     fcmp.gt.s1 p9,p0 = asinf_abs_x,f1
     nop.i                 999;;
} 
 
{     .mfi 
     nop.m                 999
     fma.s1    asinf_x8  =    asinf_x4,asinf_x4,f0
     nop.i                 999
} 
{     .mfb 
     nop.m                      999
     fma.s1    asinf_t4  =    asinf_t2,asinf_t2,f0
(p6) br.cond.spnt  ASINF_ABS_ONE ;;     // Branch if |x|=1
} 

{     .mfi 
     nop.m                 999
     fma.s1    asinf_x5  =    asinf_x2,asinf_x3,f0
     nop.i                 999
}
{     .mfb 
(p9) mov            GR_Parameter_TAG = 62
     fma.s1    asinf_yby2     =    asinf_t,asinf_1by2,f0
(p9) br.cond.spnt  __libm_error_region ;;    // Branch if |x|>1
}


{     .mfi 
     nop.m                 999
     fma.s1    asinf_Az  =    asinf_t,asinf_B,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fma.s1    asinf_B2  =    asinf_B,asinf_B,f0
     nop.i                 999;;
}
 
{     .mfi 
     nop.m                      999
     fma.s1    asinf_poly_p1  =    f8,asinf_coeff_P1,f0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asinf_2poly_p1 =    asinf_coeff_P1,asinf_t,f1
     nop.i                      999;;
}

{     .mfi 
     nop.m                      999
     fma.s1    asinf_poly_p3  =    asinf_coeff_P4,asinf_x2,asinf_coeff_P3
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asinf_2poly_p6 =    asinf_coeff_P7,asinf_t,asinf_coeff_P6
     nop.i                      999;;
} 

{     .mfi 
     nop.m                      999
     fma.s1    asinf_poly_p7  =    asinf_x2,asinf_coeff_P8,asinf_coeff_P7
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asinf_2poly_p2 =    asinf_coeff_P3,asinf_t,asinf_coeff_P2
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asinf_poly_p5  =    asinf_x2,asinf_coeff_P6,asinf_coeff_P5
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asinf_2poly_p4 =    asinf_coeff_P5,asinf_t,asinf_coeff_P4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.d.s1    asinf_x11 =    asinf_x8,asinf_x3,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fnma.s1   asinf_dz  =    asinf_B2,asinf_yby2,asinf_1by2
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asinf_poly_p1a =    asinf_x2,asinf_poly_p1,f8
     nop.i                      999
}
{     .mfi 
     nop.m                      999
     fma.s1    asinf_2poly_p8 =    asinf_coeff_P9,asinf_t,asinf_coeff_P8
     nop.i                      999;;
}

 
// Get the absolute value of x and determine the region in which x lies

{     .mfi 
     nop.m                      999
     fcmp.le.s1     p7,p8 = asinf_abs_x,asinf_const_sqrt2by2
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asinf_poly_p2  =    asinf_x2,asinf_poly_p3,asinf_coeff_P2
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asinf_poly_p7a =    asinf_x4,asinf_coeff_P9,asinf_poly_p7
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asinf_2poly_p2a =    asinf_2poly_p2,asinf_t2,asinf_2poly_p1
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                                                         999
(p8) fma.s1    asinf_sgnx_t4  =    asinf_sgn_x,asinf_t4,f0
     nop.i                                                         999
} 
{     .mfi 
     nop.m                      999
(p8) fma.s1    asinf_2poly_p4a =    asinf_2poly_p6,asinf_t2,asinf_2poly_p4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
(p8) fma.s1    asinf_Sz  =    asinf_5by2,asinf_dz,asinf_3by2
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
(p8) fma.s1    asinf_d2z =    asinf_dz,asinf_dz,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                           999
(p8) fma.s1   asinf_sgn_x_piby2 =    asinf_sgn_x,asinf_const_piby2,f0
     nop.i                           999
} 
{     .mfi 
     nop.m                      999
(p7) fma.d.s1    asinf_poly_Ax  =    asinf_x5,asinf_poly_p2,asinf_poly_p1a
     nop.i                 999;;
} 
 
{     .mfi 
     nop.m                      999
(p7) fma.d.s1    asinf_poly_Bx  =    asinf_x4,asinf_poly_p7a,asinf_poly_p5
     nop.i                      999
} 
{     .mfi 
     nop.m                           999
(p8) fma.s1    asinf_sgnx_2poly_p2 =    asinf_sgn_x,asinf_2poly_p2a,f0
     nop.i                           999;;
} 
 
{     .mfi 
     nop.m                      999
     fcmp.eq.s0 p6,p0 = f8,f0      // Only purpose is to set D if x denormal
     nop.i                      999
}
{     .mfi 
     nop.m                      999
(p8) fma.s1    asinf_2poly_p4b =    asinf_2poly_p8,asinf_t4,asinf_2poly_p4a
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
(p8) fma.s1    asinf_Fz  =    asinf_d2z,asinf_Sz,asinf_dz
     nop.i                      999;;
} 

 
{     .mfi 
     nop.m                 999
(p8) fma.d.s1  asinf_Pt  =    asinf_2poly_p4b,asinf_sgnx_t4,asinf_sgnx_2poly_p2
     nop.i                 999;;
} 
 
{     .mfi 
     nop.m                 999
(p8) fma.d.s1  asinf_z   =    asinf_Az,asinf_Fz,asinf_Az
     nop.i                 999;;
} 
 
.pred.rel "mutex",p8,p7    //asinf_pred_GTsqrt2by2,asinf_pred_LEsqrt2by2
{     .mfi 
                         nop.m            999
(p8)  fnma.s     f8   =    asinf_z,asinf_Pt,asinf_sgn_x_piby2
                         nop.i            999
} 
 
{     .mfb 
                         nop.m            999
(p7)  fma.s    f8    =    asinf_x11,asinf_poly_Bx,asinf_poly_Ax
                         br.ret.sptk b0 ;;
} 

ASINF_ABS_ONE:
// Here for short exit if |x|=1
{     .mfb 
     nop.m                      999
     fma.s    f8 =    asinf_sgn_x,asinf_const_piby2,f0
     br.ret.sptk b0
} 
;;

.endp asinf

// Stack operations when calling error support.
//       (1)               (2)                  
//   sp   -> +          psp -> +               
//           |                 |     
//           |                 | <- GR_Y      
//           |                 |             
//           | <-GR_Y      Y2->|            
//           |                 |           
//           |                 | <- GR_X  
//           |                 |         
//  sp-64 -> +          sp ->  +        
//    save ar.pfs          save b0     
//    save gp                         


// Stack operations when calling error support.
//     (3) (call)              (4)
//  psp -> +                   sp -> +
//         |                         |
//    R3 ->| <- GR_RESULT            | -> f8
//         |                         |
//    Y2 ->| <- GR_Y                 |
//         |                         |
//    X1 ->|                         |
//         |                         |
//  sp ->  +                         +
//                              restore gp
//                              restore ar.pfs

.proc __libm_error_region
__libm_error_region:
.prologue
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
                nop.f 999
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfs [GR_Parameter_Y] = f1,16         // Store Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
};;

.body
{ .mfi
        nop.m 0
        frcpa.s0 f9,p0 = f0,f0
        nop.i 0
};;

{ .mib
        stfs [GR_Parameter_X] = f8            // Store Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
        nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfs [GR_Parameter_Y] = f9           // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#   // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region

.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\ceil.s ===
.file "ceil.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
.align 32
.global ceil#

.section .text
.proc  ceil#
.align 32

// History
//==============================================================
// 2/02/00: Initial version
// 6/13/00: Improved speed
// 6/27/00: Eliminated incorrect invalid flag setting

// API
//==============================================================
// double ceil(double x)

// general input registers:  

ceil_GR_FFFF      = r14
ceil_GR_signexp   = r15
ceil_GR_exponent  = r16
ceil_GR_expmask   = r17
ceil_GR_bigexp    = r18


// predicate registers used: 

// p6  ==> Input is NaN, infinity, zero
// p7  ==> Input is denormal
// p8  ==> Input is <0
// p9  ==> Input is >=0
// p10 ==> Input is already an integer (bigger than largest integer)
// p11 ==> Input is not a large integer
// p12 ==> Input is a smaller integer
// p13 ==> Input is not an even integer, so inexact must be set
// p14 ==> Input is between -1 and 0, so result will be -0 and inexact


// floating-point registers used: 

CEIL_SIGNED_ZERO  = f7
CEIL_NORM_f8      = f9                        
CEIL_FFFF         = f10 
CEIL_INEXACT      = f11 
CEIL_FLOAT_INT_f8 = f12
CEIL_INT_f8       = f13
CEIL_adj          = f14
CEIL_MINUS_ONE    = f15

// Overview of operation
//==============================================================

// double ceil(double x)
// Return an integer value (represented as a double) that is the smallest 
// value not less than x
// This is x rounded toward +infinity to an integral value.
// Inexact is set if x != ceil(x)
// **************************************************************************

// Set denormal flag for denormal input and
// and take denormal fault if necessary.

// Is the input an integer value already?

// double_extended
// if the exponent is > 1003e => 3F(true) = 63(decimal)
// we have a significand of 64 bits 1.63-bits.
// If we multiply by 2^63, we no longer have a fractional part
// So input is an integer value already.

// double
// if the exponent is >= 10033 => 34(true) = 52(decimal)
// 34 + 3ff = 433
// we have a significand of 53 bits 1.52-bits. (implicit 1)
// If we multiply by 2^52, we no longer have a fractional part
// So input is an integer value already.

// single
// if the exponent is > 10016 => 17(true) = 23(decimal)
// we have a significand of 24 bits 1.23-bits. (implicit 1)
// If we multiply by 2^23, we no longer have a fractional part
// So input is an integer value already.

// If x is NAN, ZERO, or INFINITY, then  return

// qnan snan inf norm     unorm 0 -+
// 1    1    1   0        0     1 11     0xe7


ceil:

{ .mfi
      getf.exp ceil_GR_signexp  = f8
      fcvt.fx.trunc.s1     CEIL_INT_f8  = f8
      addl        ceil_GR_bigexp = 0x10033, r0
}
{ .mfi
      addl        ceil_GR_FFFF      = -1,r0
      fcmp.lt.s1  p8,p9 = f8,f0
      mov         ceil_GR_expmask    = 0x1FFFF ;;
}

// p7 ==> denorm
{ .mfi
      setf.sig    CEIL_FFFF  = ceil_GR_FFFF
      fclass.m    p7,p0 = f8, 0x0b
      nop.i 999
}
{ .mfi
      nop.m 999
      fnorm           CEIL_NORM_f8  = f8
      nop.i 999 ;;
}

// Form 0 with sign of input in case negative zero is needed
{ .mfi
      nop.m 999
      fmerge.s           CEIL_SIGNED_ZERO = f8, f0
      nop.i 999
}
{ .mfi
      nop.m 999
      fsub.s1           CEIL_MINUS_ONE = f0, f1
      nop.i 999 ;;
}

// p6 ==> NAN, INF, ZERO
{ .mfb
      nop.m 999
      fclass.m      p6,p10 = f8, 0xe7
(p7)  br.cond.spnt  CEIL_DENORM ;;
}

.pred.rel "mutex",p8,p9
CEIL_COMMON:
// Set adjustment to add to trunc(x) for result
//   If x>0,  adjustment is 1.0
//   If x<=0, adjustment is 0.0
{ .mfi
      and      ceil_GR_exponent = ceil_GR_signexp, ceil_GR_expmask
(p9)  fadd.s1  CEIL_adj = f1,f0
      nop.i 999
}
{ .mfi
      nop.m 999
(p8)  fadd.s1  CEIL_adj = f0,f0
      nop.i 999 ;;
}

{ .mfi
(p10) cmp.ge.unc    p10,p11 = ceil_GR_exponent, ceil_GR_bigexp
(p6)  fnorm.d f8 = f8
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p11) fcvt.xf         CEIL_FLOAT_INT_f8   = CEIL_INT_f8
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10) fnorm.d f8 = CEIL_NORM_f8
      nop.i 999 ;;
}

// Is -1 < x < 0?  If so, result will be -0.  Special case it with p14 set.
{ .mfi
      nop.m 999
(p8)  fcmp.gt.unc.s1 p14,p0 = CEIL_NORM_f8, CEIL_MINUS_ONE
      nop.i 999 ;;
}

{ .mfi
(p14) cmp.ne  p11,p0 = r0,r0
(p14) fnorm.d f8 = CEIL_SIGNED_ZERO
      nop.i 999
}
{ .mfi
      nop.m 999
(p14) fmpy.s0     CEIL_INEXACT = CEIL_FFFF,CEIL_FFFF
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p11) fadd.d   f8 = CEIL_FLOAT_INT_f8,CEIL_adj
      nop.i 999 ;;
}
{ .mfi
      nop.m 999
(p11) fcmp.eq.unc.s1  p12,p13  = CEIL_FLOAT_INT_f8, CEIL_NORM_f8
      nop.i 999 ;;
}

// Set inexact if result not equal to input
{ .mfi
      nop.m 999
(p13) fmpy.s0     CEIL_INEXACT = CEIL_FFFF,CEIL_FFFF
      nop.i 999
}
// Set result to input if integer
{ .mfb
      nop.m 999
(p12) fnorm.d f8 = CEIL_NORM_f8
      br.ret.sptk    b0 ;;
}

// Here if input denorm
CEIL_DENORM:
{ .mfb
      getf.exp ceil_GR_signexp  = CEIL_NORM_f8
      fcvt.fx.trunc.s1     CEIL_INT_f8  = CEIL_NORM_f8
      br.cond.sptk  CEIL_COMMON ;;
}

.endp ceil
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\atan2f.s ===
.file "atan2f.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// Contributed 6/1/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.

// History
//==============================================================
// ?/??/00  Initial version
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 8/17/00  Changed predicate register macro-usage to direct predicate
//          names due to an assembler bug.

// Description
//=========================================
// The atan2 function computes the principle value of the arc tangent of y/x using
// the signs of both arguments to determine the quadrant of the return value.
// A domain error may occur if both arguments are zero.

// The atan2 function returns the arc tangent of y/x in the range [-pi,+pi] radians.


// Special values
//==============================================================
//              Y                 x          Result
//             +number           +inf        +0
//             -number           +inf        -0
//             +number           -inf        +pi
//             -number           -inf        -pi
//
//             +inf              +number     +pi/2
//             -inf              +number     -pi/2
//             +inf              -number     +pi/2
//             -inf              -number     -pi/2
//
//             +inf              +inf        +pi/4
//             -inf              +inf        -pi/4
//             +inf              -inf        +3pi/4
//             -inf              -inf        -3pi/4
//
//             +1                +1          +pi/4
//             -1                +1          -pi/4
//             +1                -1          +3pi/4
//             -1                -1          -3pi/4
//
//             +number           +0          +pi/2    // does not raise DBZ
//             -number           +0          -pi/2    // does not raise DBZ
//             +number           -0          +pi/2    // does not raise DBZ
//             -number           -0          -pi/2    // does not raise DBZ
//
//             +0                +number     +0
//             -0                +number     -0
//             +0                -number     +pi
//             -0                -number     -pi
//
//             +0                +0          +0      // does not raise invalid
//             -0                +0          -0      // does not raise invalid
//             +0                -0          +pi     // does not raise invalid
//             -0                -0          -pi     // does not raise invalid
//
//            Nan             anything      quiet Y
//            anything        NaN           quiet X

// atan(+-0/+-0) sets double error tag to 37
// atan(+-0/+-0) sets single error tag to 38
// These are domain errors.


//
// Assembly macros
//=========================================


// integer registers
atan2f_GR_Addr_1              = r33
atan2f_GR_Addr_2              = r34
GR_SAVE_B0                    = r35

GR_SAVE_PFS                   = r36
GR_SAVE_GP                    = r37

GR_Parameter_X                = r38
GR_Parameter_Y                = r39
GR_Parameter_RESULT           = r40
GR_Parameter_TAG              = r41

// floating point registers
atan2f_coef_p1         = f32
atan2f_coef_p7         = f33
atan2f_coef_p8         = f34
atan2f_coef_p3         = f35
atan2f_coef_p4         = f36
atan2f_coef_p9         = f37
atan2f_coef_p10        = f38
atan2f_coef_p2         = f39
atan2f_coef_p5         = f40

atan2f_coef_p6         = f41
atan2f_const_1         = f43
atan2f_const_pi        = f44
atan2f_abs_Y           = f45

atan2f_abs_X           = f46
atan2f_sgn_Y           = f47
atan2f_sgn_X           = f48
atan2f_A               = f49
atan2f_Asq             = f50

atan2f_Acub            = f51
atan2f_A4              = f52
atan2f_A5              = f53
atan2f_A6              = f54
atan2f_A11             = f55

atan2f_poly_A1         = f56
atan2f_poly_A2         = f57
atan2f_poly_A3         = f58
atan2f_poly_A4         = f59
atan2f_poly_A5         = f60

atan2f_poly_atan_A     = f61
atan2f_answer          = f62
atan2f_C               = f63
atan2f_G_numer         = f64
atan2f_G_denom         = f65

atan2f_H1              = f66
atan2f_H_beta          = f67
atan2f_H2              = f68
atan2f_H_beta2         = f69
atan2f_H3              = f70

atan2f_g               = f71
atan2f_gsq             = f72
atan2f_poly_atan_G     = f73


atan2f_Z               = f74
atan2f_Zsq             = f75

atan2f_Zcub            = f76
atan2f_Z4              = f77
atan2f_Z5              = f78
atan2f_Z6              = f79
atan2f_Z11             = f80

atan2f_poly_Z1         = f81
atan2f_poly_Z2         = f82
atan2f_poly_Z3         = f83
atan2f_poly_Z4         = f84
atan2f_poly_Z5         = f85

atan2f_T_numer         = f86
atan2f_T_denom         = f87
atan2f_S1              = f88
atan2f_S_beta          = f89
atan2f_S2              = f90

atan2f_S_beta2         = f91
atan2f_S3              = f92
atan2f_t               = f93
atan2f_tsq             = f94
atan2f_poly_atan_T     = f95

atan2f_poly_atan_Z     = f96
atan2f_const_piby4           = f97
atan2f_const_3piby4          = f98
atan2f_const_piby2           = f99


// predicate registers
//atan2f_Pred_Swap       = p6
//atan2f_Pred_noSwap     = p7
//atan2f_Pred_Xpos       = p8
//atan2f_Pred_Xneg       = p9


.data

.align 16

atan2f_coef_table1:
data8 0xBFD5555512191621 // p1
data8 0xBFA6E10BA401393F // p7
data8 0x3FBC4F512B1865F5 // p4
data8 0xBF7DEAADAA336451 // p9
data8 0xBFB68EED6A8CFA32 // p5
data8 0x3FB142A73D7C54E3 // p6
data8 0x3fe921fb54442d18 // pi/4
data8 0x4002d97c7f3321d2 // 3pi/4

atan2f_coef_table2:
data8 0x3F97105B4160F86B // p8
data8 0xBFC2473C5145EE38 // p3
data8 0x3F522E5D33BC9BAA // p10
data8 0x3FC9997E7AFBFF4E // p2
data8 0x3ff921fb54442d18 // pi/2
data8 0x400921fb54442d18 // pi



.global atan2f

.text
.proc  atan2f
.align 32

atan2f:

 
 
{     .mfi 
     alloc      r32           = ar.pfs,1,5,4,0
     frcpa.s1  atan2f_Z,p0     =    f1,f8
     addl      atan2f_GR_Addr_2         =    @ltoff(atan2f_coef_table2),gp
} 
{     .mfi 
     addl      atan2f_GR_Addr_1    =    @ltoff(atan2f_coef_table1),gp
     nop.f                           999
     nop.i                           999;;
}

 
{     .mfi 
     nop.m                                999
     frcpa.s1  atan2f_A,p0     =    f1,f9
     nop.i                                999;;
} 
 
{     .mfi 
     ld8       atan2f_GR_Addr_1    =    [atan2f_GR_Addr_1]
     fmerge.s  atan2f_sgn_X        =    f9,f1
     nop.i                           999
} 
{     .mfi 
     ld8       atan2f_GR_Addr_2    =    [atan2f_GR_Addr_2]
     nop.f                           999
     nop.i                           999;;
}

 
{     .mfi 
     nop.m                      999
     fmerge.s  atan2f_sgn_Y   =    f8,f1
     nop.i                      999;;
} 
 
{     .mfi 
     nop.m                      999
     fmerge.s  atan2f_abs_X   =    f0,f9
     nop.i                      999;;
} 
 
{     .mfi 
     ldfpd     atan2f_coef_p1,atan2f_coef_p7 =    [atan2f_GR_Addr_1],16
     fmerge.s  atan2f_abs_Y                  =    f0,f8
     nop.i                                     999
} 
{     .mfi 
     ldfpd     atan2f_coef_p8,atan2f_coef_p3 =    [atan2f_GR_Addr_2],16
     fma.s1    atan2f_Z                      =    atan2f_Z,f9,f0
     nop.i                                     999;;
}

 
{     .mfi 
     ldfpd     atan2f_coef_p4,atan2f_coef_p9 =    [atan2f_GR_Addr_1],16
     fclass.m  p10,p0                        =    f9,0xe7	// @inf|@snan|@qnan|@zero
     nop.i                                     999
} 
{     .mfi 
     ldfpd     atan2f_coef_p10,atan2f_coef_p2     =    [atan2f_GR_Addr_2],16
     fma.s1    atan2f_A                           =    atan2f_A,f8,f0
     nop.i                                          999;;
}

 
{     .mfi 
     ldfpd          atan2f_const_piby2,atan2f_const_pi =    [atan2f_GR_Addr_2]
//     fcmp.ge.s1     atan2f_Pred_Xpos,atan2f_Pred_Xneg  =    atan2f_sgn_X,f1
     fcmp.ge.s1     p8,p9  =    atan2f_sgn_X,f1
     nop.i                                               999
} 
{     .mfi 
     ldfpd     atan2f_coef_p5,atan2f_coef_p6 =    [atan2f_GR_Addr_1],16
     nop.f                                     999
     nop.i                                     999;;
}

 
{     .mfi 
     ldfpd     atan2f_const_piby4,atan2f_const_3piby4  =    [atan2f_GR_Addr_1]
     fclass.m  p11,p0                                  =    f8,0xe7	// @inf|@snan|@qnan|@zero
     nop.i                                               999;;
} 
 
{     .mfi 
                    nop.m                      999
//(atan2f_Pred_Xpos)  fma.s1    atan2f_const_1 =    atan2f_sgn_Y,f0,f0
(p8)  fma.s1    atan2f_const_1 =    atan2f_sgn_Y,f0,f0
                    nop.i                      999
} 
{     .mfi 
                    nop.m                      999
//(atan2f_Pred_Xneg)  fma.s1    atan2f_const_1 =    atan2f_sgn_Y,f1,f0
(p9)  fma.s1    atan2f_const_1 =    atan2f_sgn_Y,f1,f0
                    nop.i                      999;;
}

 
{     .mfb 
     nop.m                      999
     fma.s1    atan2f_Zsq     =    atan2f_Z,atan2f_Z,f0
(p10)           br.cond.spnt ATAN2F_XY_INF_NAN_ZERO
} 
{     .mfb 
     nop.m                      999
     fma.s1    atan2f_T_denom =    atan2f_Z,f9,f8
(p11)           br.cond.spnt ATAN2F_XY_INF_NAN_ZERO
}
;;

 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_Asq     =    atan2f_A,atan2f_A,f0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_G_denom =    atan2f_A,f8,f9
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fnma.s1   atan2f_G_numer =    atan2f_A,f9,f8
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fnma.s1   atan2f_T_numer =    atan2f_Z,f8,f9
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                                                    999
//     fcmp.gt.s1     atan2f_Pred_Swap,atan2f_Pred_noSwap     =    atan2f_abs_Y,atan2f_abs_X
     fcmp.gt.s1     p6,p7     =    atan2f_abs_Y,atan2f_abs_X
     nop.i                                                    999;;
} 
 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_poly_A4 =    atan2f_A,atan2f_coef_p1,f0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_poly_Z4 =    atan2f_Z,atan2f_coef_p1,f0
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_poly_Z2 =    atan2f_Zsq,atan2f_coef_p8,atan2f_coef_p7
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_poly_Z5 =    atan2f_Zsq,atan2f_coef_p4,atan2f_coef_p3
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    atan2f_Z4 =    atan2f_Zsq,atan2f_Zsq,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_poly_Z1 =    atan2f_Zsq,atan2f_coef_p10,atan2f_coef_p9
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                                999
     frcpa.s1  atan2f_S1,p0    =    f1,atan2f_T_denom
     nop.i                                999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_Zcub    =    atan2f_Z,atan2f_Zsq,f0
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                                999
     frcpa.s1  atan2f_H1,p0    =    f1,atan2f_G_denom
     nop.i                                999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_poly_A5 =    atan2f_Asq,atan2f_coef_p4,atan2f_coef_p3
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_poly_A1 =    atan2f_Asq,atan2f_coef_p10,atan2f_coef_p9
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_poly_A2 =    atan2f_Asq,atan2f_coef_p8,atan2f_coef_p7
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_Acub    =    atan2f_A,atan2f_Asq,f0
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    atan2f_A4 =    atan2f_Asq,atan2f_Asq,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_poly_Z4 =    atan2f_Zsq,atan2f_poly_Z4,atan2f_Z
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_poly_Z5 =    atan2f_Zsq,atan2f_poly_Z5,atan2f_coef_p2
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fnma.s1   atan2f_S_beta  =    atan2f_S1,atan2f_T_denom,f1
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    atan2f_t  =    atan2f_S1,atan2f_T_numer,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_poly_Z3 =    atan2f_Zsq,atan2f_coef_p6,atan2f_coef_p5
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_poly_Z1 =    atan2f_Z4,atan2f_poly_Z1,atan2f_poly_Z2
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    atan2f_Z5 =    atan2f_Zsq,atan2f_Zcub,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fma.s1    atan2f_Z6 =    atan2f_Zsq,atan2f_Z4,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fnma.s1   atan2f_H_beta  =    atan2f_H1,atan2f_G_denom,f1
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    atan2f_g  =    atan2f_H1,atan2f_G_numer,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_poly_A4 =    atan2f_Asq,atan2f_poly_A4,atan2f_A
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_poly_A5 =    atan2f_Asq,atan2f_poly_A5,atan2f_coef_p2
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_poly_A3 =    atan2f_Asq,atan2f_coef_p6,atan2f_coef_p5
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_poly_A1 =    atan2f_A4,atan2f_poly_A1,atan2f_poly_A2
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    atan2f_A5 =    atan2f_Asq,atan2f_Acub,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fma.s1    atan2f_A6 =    atan2f_Asq,atan2f_A4,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_tsq     =    atan2f_t,atan2f_t,f0
     nop.i                      999
} 
{     .mfi 
     nop.m                           999
     fma.s1    atan2f_poly_atan_T  =    atan2f_t,atan2f_coef_p1,f0
     nop.i                           999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    atan2f_S2 =    atan2f_S1,atan2f_S_beta,atan2f_S1
     nop.i                 999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_S_beta2 =    atan2f_S_beta,atan2f_S_beta,f0
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_poly_Z1 =    atan2f_Z4,atan2f_poly_Z1,atan2f_poly_Z3
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_poly_Z4 =    atan2f_Z5,atan2f_poly_Z5,atan2f_poly_Z4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                           999
     fma.s1    atan2f_poly_atan_G  =    atan2f_g,atan2f_coef_p1,f0
     nop.i                           999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_Z11     =    atan2f_Z5,atan2f_Z6,f0
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_H_beta2 =    atan2f_H_beta,atan2f_H_beta,f0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_gsq     =    atan2f_g,atan2f_g,f0
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_poly_A4 =    atan2f_A5,atan2f_poly_A5,atan2f_poly_A4
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    atan2f_H2 =    atan2f_H1,atan2f_H_beta,atan2f_H1
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_A11     =    atan2f_A5,atan2f_A6,f0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atan2f_poly_A1 =    atan2f_A4,atan2f_poly_A1,atan2f_poly_A3
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    atan2f_S3 =    atan2f_S2,atan2f_S_beta2,atan2f_S2
     nop.i                 999
} 
{     .mfi 
     nop.m                           999
     fma.s1    atan2f_poly_atan_T  =    atan2f_tsq,atan2f_poly_atan_T,f0
     nop.i                           999;;
}

 
{     .mfi 
                    nop.m                 999
//(atan2f_Pred_Swap)  fma.s1    atan2f_C  =    atan2f_sgn_Y,atan2f_const_piby2,f0
(p6)  fma.s1    atan2f_C  =    atan2f_sgn_Y,atan2f_const_piby2,f0
                    nop.i                 999
} 
{     .mfi 
     nop.m                           999
     fma.s1    atan2f_poly_atan_Z  =    atan2f_Z11,atan2f_poly_Z1,atan2f_poly_Z4
     nop.i                           999;;
}

 
{     .mfi 
                         nop.m                 999
//(atan2f_Pred_noSwap)     fma.s1    atan2f_C  =    atan2f_const_1,atan2f_const_pi,f0
(p7)     fma.s1    atan2f_C  =    atan2f_const_1,atan2f_const_pi,f0
                         nop.i                 999
} 
{     .mfi 
     nop.m                           999
     fma.s1    atan2f_poly_atan_G  =    atan2f_gsq,atan2f_poly_atan_G,f0
     nop.i                           999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    atan2f_H3 =    atan2f_H2,atan2f_H_beta2,atan2f_H2
     nop.i                 999;;
} 
 
{     .mfi 
     nop.m                           999
     fma.s1    atan2f_poly_atan_A  =    atan2f_A11,atan2f_poly_A1,atan2f_poly_A4
     nop.i                           999;;
} 
 
{     .mfi 
     nop.m                           999
     fma.s1    atan2f_poly_atan_T  =    atan2f_T_numer,atan2f_S3,atan2f_poly_atan_T
     nop.i                           999;;
} 
 
{     .mfi 
                    nop.m                      999
//(atan2f_Pred_Swap)  fms.s1    atan2f_answer  =    f1,atan2f_C,atan2f_poly_atan_Z
(p6)  fms.s1    atan2f_answer  =    f1,atan2f_C,atan2f_poly_atan_Z
                    nop.i                      999;;
} 
 
{     .mfi 
     nop.m                           999
     fma.s1    atan2f_poly_atan_G  =    atan2f_G_numer,atan2f_H3,atan2f_poly_atan_G
     nop.i                           999;;
} 
 
{     .mfi 
                         nop.m                      999
//(atan2f_Pred_noSwap)     fma.s1    atan2f_answer  =    f1,atan2f_C,atan2f_poly_atan_A
(p7)     fma.s1    atan2f_answer  =    f1,atan2f_C,atan2f_poly_atan_A
                         nop.i                      999;;
} 
 
{     .mfi 
                    nop.m                 999
//(atan2f_Pred_Swap)  fms.s     f8    =    f1,atan2f_answer,atan2f_poly_atan_T
(p6)  fms.s     f8    =    f1,atan2f_answer,atan2f_poly_atan_T
                    nop.i                 999;;
} 
 
{     .mfb 
                         nop.m                 999
//(atan2f_Pred_noSwap)     fma.s     f8    =    f1,atan2f_answer,atan2f_poly_atan_G
(p7)     fma.s     f8    =    f1,atan2f_answer,atan2f_poly_atan_G
                         br.ret.sptk b0
} 


ATAN2F_XY_INF_NAN_ZERO:
// p10 = (y is NAN)
//   answer is quiet y

// p11 = (y is not NAN)
//   p12 = (X is NAN)
//   answer is quiet x

               fclass.m   p10,p11                    = f8,0xc3	// @snan | @qnan
;;
(p10)          fnorm.s f10 = f9
(p10)          fnorm.s f8  = f8
(p10)          br.ret.spnt b0

(p11)          fclass.m   p12,p0                     = f9,0xc3	// @snan | @qnan
;;
(p12)          fnorm.s f8 = f9
(p12)          br.ret.spnt b0

// p10 = x is +inf
//   p12 = (x is +inf) AND (y is +- inf)
//   answer is (sign of y)pi/4
//   p13 = (x is +inf) AND (y is +- number)
//   answer is (sign of y)0



               fclass.m   p10,p0                    = f9,0x21	// @inf| @pos
;;

(p10)          fclass.m.unc  p12,p13                = f8,0x23	// @inf
;;

(p12)          fma.s   f8                           = atan2f_sgn_Y, atan2f_const_piby4,f0
(p12)          br.ret.spnt b0

;;
(p13)          fmerge.s   f8                        = f8,f0
(p13)          br.ret.spnt b0


// p11 = x is -inf
//   p14 = (x is -inf) AND (y is +- inf)
//   amswer is (sign of y)3pi/4
//   p15 = (x is -inf) AND (y is +- number)
//   answer is (sign of y)pi

// p12 = x is +- number
//   p13 = (x is +- number) AND (y is +- inf)
//   answer is (sign of y)pi/2



               fclass.m.unc   p11,p12               = f9,0x22	// @inf | @neg
;;

(p11)          fclass.m.unc   p14,p15               = f8,0x23	// @inf
;;
(p14)          fma.s   f8                           = atan2f_sgn_Y, atan2f_const_3piby4,f0
(p14)          br.ret.spnt b0

(p15)          fma.s   f8                           = atan2f_sgn_Y, atan2f_const_pi,f0
(p15)          br.ret.spnt b0

(p12)          fclass.m.unc   p13,p0                = f8,0x23	// @inf
;;

(p13)          fma.s          f8                    = atan2f_sgn_Y, atan2f_const_piby2,f0
(p13)          br.ret.spnt b0

// p10 = (x is +-0)
//   p13 = (x is +-0) AND (y is +-number)
//   answer is (sign of y) pi/2
//   p12 =  (x is +-0) AND (y is +-0)
//   answer is goto error_region


// p11 = (x is +- number)
//   p12 = (x is +- number) AND (y is +- 0)
//      p13 = (x is + number) AND (y is +- 0)
//      answer is (sign of y)0
//      p14 = NOT (x is + number) AND (y is +- 0)
//         p15 = (x is - number) AND (y is +- 0)
//         answer is (sign of y)pi


               fclass.m       p10,p11               = f9,0x7	// @zero
;;

(p10)          fclass.m.unc   p12,p13               = f8,0x7	// @zero
;;

(p13)          fma.s          f8                    = atan2f_sgn_Y, atan2f_const_piby2,f0
(p13)          br.ret.spnt    b0

(p12)          br.cond.spnt   __libm_error_region
;;

(p11)          fclass.m.unc   p12,p0                = f8,0x7	// @zero
;;

(p12)          fclass.m.unc   p13, p14              = f9,0x19	// @norm| @unorm | @pos
;;

(p13)          fmerge.s       f8                    = f8, f0
(p13)          br.ret.spnt    b0

(p14)          fclass.m.unc   p15, p0               = f9,0x1a	// @norm| @unorm | @neg
;;

(p15)          fma.s          f8                    = atan2f_sgn_Y, atan2f_const_pi,f0
(p15)          br.ret.spnt    b0


.endp atan2f

.proc __libm_error_region
__libm_error_region:
.prologue
         mov            GR_Parameter_TAG      = 38
         fclass.m       p10,p11               = f9,0x5	// @zero | @pos
;;
(p10)    fmerge.s       f10                   = f8, f0
(p11)    fma.s          f10                   = atan2f_sgn_Y, atan2f_const_pi,f0
;;

{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 999
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}

{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
}
;;

{ .mmi
        stfs [GR_Parameter_Y] = f9,16         // Store Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
}
;;


.body
{ .mib
        stfs [GR_Parameter_X] = f8            // Store Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
        nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfs [GR_Parameter_Y] = f10       // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#   // Call error handling function
}
;;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
}
;;

{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
}
;;

.endp __libm_error_region

.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\atan2.s ===
.file "atan2.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version
// 4/04/00  Unwind support added
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 8/17/00  Changed predicate register macro-usage to direct predicate
//          names due to an assembler bug.
// 9/28/00  Updated to set invalid on SNaN inputs
//
// API
//==============================================================
// double atan2(double Y, double X)
//
// Overview of operation
//==============================================================
//
// There are two basic paths: swap true and swap false.
// atan2(Y,X) ==> atan2(V/U) where U >= V. If Y > X, we must swap.
//
// p6  swap True
// p7  swap False
// p8  X+   (If swap=True p8=p9=0)
// p9  X-
//
// all the other predicates p10 thru p15 and false for the main path
//
// Special values
//==============================================================
//              Y                 x          Result
//             +number           +inf        +0
//             -number           +inf        -0
//             +number           -inf        +pi
//             -number           -inf        -pi
//
//             +inf              +number     +pi/2
//             -inf              +number     -pi/2
//             +inf              -number     +pi/2
//             -inf              -number     -pi/2
//
//             +inf              +inf        +pi/4
//             -inf              +inf        -pi/4
//             +inf              -inf        +3pi/4
//             -inf              -inf        -3pi/4
//
//             +1                +1          +pi/4
//             -1                +1          -pi/4
//             +1                -1          +3pi/4
//             -1                -1          -3pi/4
//
//             +number           +0          +pi/2
//             -number           +0          -pi/2
//             +number           -0          +pi/2
//             -number           -0          -pi/2
//
//             +0                +number     +0 
//             -0                +number     -0 
//             +0                -number     +pi
//             -0                -number     -pi
//
//             +0                +0          +0 
//             -0                +0          -0 
//             +0                -0          +pi
//             -0                -0          -pi
//
//            Nan             anything      quiet Y
//            anything        NaN           quiet X

// atan(+-0/+-0) sets double error tag to 37
// atan(+-0/+-0) sets single error tag to 38


// Assembly macros
//==============================================================

EXP_AD_P1                    = r33
EXP_AD_P2                    = r34


GR_SAVE_B0                   = r35
GR_SAVE_GP                   = r36
GR_SAVE_PFS                  = r37

GR_Parameter_X               = r38
GR_Parameter_Y               = r39
GR_Parameter_RESULT          = r40
atan2_GR_tag                 = r41


atan2_X                      = f9
atan2_Y                      = f8

atan2_u1_X                   = f32
atan2_u1_Y                   = f33
atan2_Umax                   = f34
atan2_Vmin                   = f35
atan2_two                    = f36
atan2_absX                   = f37
atan2_z1_X                   = f38
atan2_z1_Y                   = f39
atan2_B1X                    = f40
atan2_B1Y                    = f41
atan2_wp                     = f42
atan2_B1sq                   = f43
atan2_z                      = f44
atan2_w                      = f45

atan2_P0                     = f46
atan2_P1                     = f47
atan2_P2                     = f48
atan2_P3                     = f49
atan2_P4                     = f50
atan2_P5                     = f51
atan2_P6                     = f52
atan2_P7                     = f53
atan2_P8                     = f54
atan2_P9                     = f55
atan2_P10                    = f56
atan2_P11                    = f57
atan2_P12                    = f58
atan2_P13                    = f59
atan2_P14                    = f60
atan2_P15                    = f61
atan2_P16                    = f62
atan2_P17                    = f63
atan2_P18                    = f64
atan2_P19                    = f65
atan2_P20                    = f66
atan2_P21                    = f67
atan2_P22                    = f68
atan2_Pi_by_2                = f69

atan2_V13                    = f70
atan2_W11                    = f71
atan2_E                      = f72
atan2_gamma                  = f73
atan2_V11                    = f74
atan2_V12                    = f75
atan2_V7                     = f76
atan2_V8                     = f77
atan2_W7                     = f78
atan2_W8                     = f79
atan2_W3                     = f80
atan2_W4                     = f81
atan2_V3                     = f82
atan2_V4                     = f83
atan2_F                      = f84
atan2_gV                     = f85
atan2_V10                    = f86
atan2_zcub                   = f87
atan2_V6                     = f88
atan2_V9                     = f89
atan2_W10                    = f90
atan2_W6                     = f91
atan2_W2                     = f92
atan2_V2                     = f93

atan2_alpha                  = f94
atan2_alpha_1                = f95
atan2_gVF                    = f96
atan2_V5                     = f97
atan2_W12                    = f98
atan2_W5                     = f99
atan2_alpha_sq               = f100
atan2_Cp                     = f101
atan2_V1                     = f102

atan2_NORM_X                 = f103

atan2_W1                     = f104
atan2_alpha_cub              = f105
atan2_C                      = f106
atan2_P                      = f107
atan2_d                      = f108
atan2_A_hi                   = f109
atan2_dsq                    = f110
atan2_pd                     = f111
atan2_A_lo                   = f112
atan2_A                      = f113

atan2_Pp                     = f114
atan2_NORM_X                 = f115

atan2_sgnY                   = f116
atan2_pi                     = f117
atan2_sgnX                   = f118
atan2_sgnXY                  = f119

atan2_3pi_by_4               = f120
atan2_pi_by_4                = f121

atan2_NORM_Y                 = f122

//atan2_sF                     = p7
//atan2_sT                     = p6

// These coefficients are for atan2. 
// You can also use this set to substitute those used in the |X| <= 1 case for atan; 
// BUT NOT vice versa.

/////////////////////////////////////////////////////////////


.data

.align 16

atan2_tb1:
data8 0xB199DD6D2675C40F ,  0x0000BFFA // P10
data8 0xA21922DC45605EA1 ,  0x00003FFA // P11
data8 0xD78F28FC2A592781 ,  0x0000BFFA // P8
data8 0xC2F01E5DDD100DBE ,  0x00003FFA // P9
data8 0x9D89D7D55C3287A5 ,  0x00003FFB // P5
data8 0xF0F03ADB3FC930D3 ,  0x00003FFA // P7
data8 0xF396268151CFB11C ,  0x00003FF7 // P17 
data8 0x9D3436AABE218776 ,  0x00003FF5 // P19
data8 0x80D601879218B53A ,  0x00003FFA // P13
data8 0xA2270D30A90AA220 ,  0x00003FF9 // P15
data8 0xCCCCCCCCCCC906CD ,  0x00003FFC // P1
data8 0xE38E38E320A8A098 ,  0x00003FFB // P3
data8 0xFE7E52D2A89995B3 ,  0x0000BFEC // P22
data8 0xC90FDAA22168C235 ,  0x00003FFE // pi/4

atan2_tb2:
data8 0x9F90FB984D8E39D0 ,  0x0000BFF3 // P20
data8 0xCE585A259BD8374C ,  0x00003FF0 // P21
data8 0xBA2E8B9793955C77 ,  0x0000BFFB // P4
data8 0x88887EBB209E3543 ,  0x0000BFFB // P6
data8 0xD818B4BB43D84BF2 ,  0x0000BFF8 // P16
data8 0xDEC343E068A6D2A8 ,  0x0000BFF6 // P18
data8 0x9297B23CCFFB291F ,  0x0000BFFA // P12
data8 0xD5F4F2182E7A8725 ,  0x0000BFF9 // P14
data8 0xAAAAAAAAAAAAA8A9 ,  0x0000BFFD // P0
data8 0x9249249247E37913 ,  0x0000BFFC // P2
data8 0xC90FDAA22168C235 ,  0x00003FFF // pi/2
data8 0xC90FDAA22168C235 ,  0x00004000 // pi
data8 0x96cbe3f9990e91a8 ,  0x00004000 // 3pi/4




.align 32
.global atan2#

////////////////////////////////////////////////////////

.section .text
.proc  atan2#
.align 32
atan2:
// qnan snan inf norm     unorm 0 -+
// 0    0    1   0        0     0 11


//         Y NAN?     p10 p11
// p10 ==> quiet Y and return
// p11     X NAN?     p12, p13 
// p12 ==> quiet X and return

{ .mfi
           alloc        r32           = ar.pfs,1,5,4,0
           frcpa.s1     atan2_u1_X,p6 = f1,atan2_X
           addl         EXP_AD_P2   = @ltoff(atan2_tb2), gp
}
{ .mfi
           addl         EXP_AD_P1   = @ltoff(atan2_tb1), gp
           fclass.m.unc p10,p11 = f8, 0xc3
           nop.i 999
;;
}

{ .mfi
           ld8  EXP_AD_P1 = [EXP_AD_P1]
           frcpa.s1     atan2_u1_Y,p7 = f1,atan2_Y
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_two  = f1,f1,f1 
           nop.i 999
;;
}


{ .mfi
           ld8 EXP_AD_P2 = [ EXP_AD_P2]
           famax.s1     atan2_Umax =  f8,f9
           nop.i 999
}
;;

{ .mfi
           nop.m 999
           fmerge.s     atan2_absX = f0,atan2_X
           nop.i 999
}
;;

// p10 Y NAN, quiet and return
{ .mfi
           ldfe         atan2_P10  = [EXP_AD_P1],16
           fmerge.s     atan2_sgnY = atan2_Y,f1
           nop.i 999
}
{ .mfb
           nop.m 999
(p10)      fma.d f8 = f8,f9,f0 
(p10)      br.ret.spnt b0
;;
}


{ .mmf
           ldfe         atan2_P11  = [EXP_AD_P1],16
           ldfe         atan2_P20  = [EXP_AD_P2],16
           fmerge.s     atan2_sgnX = atan2_X,f1
;;
}


{ .mfi 
           ldfe         atan2_P8   = [EXP_AD_P1],16
           fma.s1       atan2_z1_X = atan2_u1_X, atan2_Y, f0
           nop.i 999
}
{ .mfi 

           ldfe         atan2_P21  = [EXP_AD_P2],16
           fma.s1       atan2_z1_Y = atan2_u1_Y, atan2_X, f0
           nop.i 999
;;
}

{ .mfi 
           ldfe         atan2_P9   = [EXP_AD_P1],16
           fnma.s1      atan2_B1X  = atan2_u1_X, atan2_X, atan2_two
           nop.i 999
}
{ .mfi 

           ldfe         atan2_P4   = [EXP_AD_P2],16
           fnma.s1      atan2_B1Y  = atan2_u1_Y, atan2_Y, atan2_two
           nop.i 999
;;
}

// p6 (atan2_sT) true if swap
// p7 (atan2_sF) true if no swap
// p11 ==> Y !NAN;  X NAN?

{ .mfi
           ldfe         atan2_P5   = [EXP_AD_P1],16
//           fcmp.eq.unc.s1 atan2_sF,atan2_sT    = atan2_Umax, atan2_X
           fcmp.eq.unc.s1 p7,p6    = atan2_Umax, atan2_X
           nop.i 999
}
{ .mfi
           ldfe         atan2_P6   = [EXP_AD_P2],16
(p11)      fclass.m.unc p12,p13    = f9, 0xc3
           nop.i 999
;;
}

{ .mmf
           ldfe         atan2_P7   = [EXP_AD_P1],16
           ldfe         atan2_P16  = [EXP_AD_P2],16
           famin.s1     atan2_Vmin =  f8,f9
;;
}

// p8 true if X positive
// p9 true if X negative
// both are false is swap is true
{ .mfi
           ldfe         atan2_P17  = [EXP_AD_P1],16
//(atan2_sF) fcmp.eq.unc.s1 p8,p9    = atan2_sgnX,f1
(p7) fcmp.eq.unc.s1 p8,p9    = atan2_sgnX,f1
           nop.i 999
}
{ .mfi
           ldfe         atan2_P18  = [EXP_AD_P2],16
           fma.s1       atan2_sgnXY     = atan2_sgnX, atan2_sgnY, f0 
           nop.i 999
;;
}


{ .mfi
           ldfe         atan2_P19  = [EXP_AD_P1],16
//(atan2_sF) fma.s1       atan2_wp   = atan2_z1_X, atan2_z1_X, f0
(p7) fma.s1       atan2_wp   = atan2_z1_X, atan2_z1_X, f0
           nop.i 999
}
{ .mfi
           ldfe         atan2_P12  = [EXP_AD_P2],16
//(atan2_sT) fma.s1       atan2_wp   = atan2_z1_Y, atan2_z1_Y, f0
(p6) fma.s1       atan2_wp   = atan2_z1_Y, atan2_z1_Y, f0
           nop.i 999
;;
}


{ .mfi
           ldfe         atan2_P13  = [EXP_AD_P1],16
//(atan2_sF) fma.s1       atan2_z         = atan2_z1_X, atan2_B1X, f0
(p7) fma.s1       atan2_z         = atan2_z1_X, atan2_B1X, f0
           nop.i 999
}
{ .mfi
           ldfe         atan2_P14  = [EXP_AD_P2],16
//(atan2_sT) fma.s1       atan2_z         = atan2_z1_Y, atan2_B1Y, f0
(p6) fma.s1       atan2_z         = atan2_z1_Y, atan2_B1Y, f0
           nop.i 999
;;
}


{ .mfi
           ldfe         atan2_P15       = [EXP_AD_P1],16
//(atan2_sF) fma.s1       atan2_B1sq = atan2_B1X, atan2_B1X, f0
(p7) fma.s1       atan2_B1sq = atan2_B1X, atan2_B1X, f0
           nop.i 999
}
{ .mfi
           ldfe         atan2_P0        = [EXP_AD_P2],16
//(atan2_sT) fma.s1       atan2_B1sq = atan2_B1Y, atan2_B1Y, f0
(p6) fma.s1       atan2_B1sq = atan2_B1Y, atan2_B1Y, f0
           nop.i 999
;;
}


// p12 ==> X NAN, quiet and return
{ .mfi
           ldfe         atan2_P1        = [EXP_AD_P1],16
           fmerge.s     atan2_Umax      = f0,atan2_Umax
           nop.i 999
}
{ .mfb
           ldfe         atan2_P2        = [EXP_AD_P2],16
(p12)      fma.d        f8 = f9,f8,f0
(p12)      br.ret.spnt b0
;;
}


// p10 ==> x  inf     y ?
// p11 ==> x !inf     y ?
{ .mfi
           ldfe         atan2_P3        = [EXP_AD_P1],16
           fmerge.s     atan2_Vmin      = f0,atan2_Vmin
           nop.i 999
}
{ .mfi
           ldfe         atan2_Pi_by_2   = [EXP_AD_P2],16
           fclass.m.unc p10,p11 = f9, 0x23
           nop.i 999
;;
}


{ .mmf
           ldfe         atan2_P22       = [EXP_AD_P1],16
           ldfe         atan2_pi        = [EXP_AD_P2],16
           nop.f 999
;;
}

{ .mfi
           nop.m 999 
           fma.s0       atan2_NORM_X    = f9,f1,f0
           nop.i 999
}
{ .mfi
           nop.m 999 
           fma.s0       atan2_NORM_Y    = f8,f1,f0
           nop.i 999
;;
}



{ .mfi
           ldfe         atan2_pi_by_4       = [EXP_AD_P1],16
           fma.s1       atan2_w         = atan2_wp, atan2_B1sq,f0
           nop.i 999
}
{ .mfi
           ldfe         atan2_3pi_by_4       = [EXP_AD_P2],16
//(atan2_sT) fmerge.ns    atan2_sgnXY     = atan2_sgnXY, atan2_sgnXY
(p6) fmerge.ns    atan2_sgnXY     = atan2_sgnXY, atan2_sgnXY
           nop.i 999
;;
}

// p12 ==> x  inf     y inf
// p13 ==> x  inf     y !inf
{ .mfi
           nop.m 999
           fmerge.s     atan2_z         = f0, atan2_z
           nop.i 999
}

{ .mfi
           nop.m 99
(p10)      fclass.m.unc p12,p13 = f8, 0x23
           nop.i 999
}
{ .mfi
           nop.m 99
(p11)      fclass.m.unc p14,p15 = f8, 0x23
           nop.i 999
;;
}

{ .mfi
           nop.m 999
(p12)      fcmp.eq.unc.s1 p10,p11       = atan2_sgnX,f1
           nop.i 99
;;
}


{ .mfb
           nop.m 999
(p14)      fma.d       f8 = atan2_sgnY, atan2_Pi_by_2, f0
(p14)      br.ret.spnt b0
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_V13       = atan2_w, atan2_P11, atan2_P10
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_W11       = atan2_w, atan2_P21, atan2_P20
           nop.i 999
;;
}


{ .mfi
           nop.m 999
           fma.s1       atan2_E         = atan2_Vmin, atan2_z, atan2_Umax
           nop.i 999
}
{ .mfi
           nop.m 999
           fnma.s1      atan2_gamma     = atan2_Umax, atan2_z, f1
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_V11       = atan2_w, atan2_P9, atan2_P8
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_V12       = atan2_w, atan2_w, f0
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_V7        = atan2_w, atan2_P5 , atan2_P4 
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_V8        = atan2_w, atan2_P7 , atan2_P6 
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_W7        = atan2_w, atan2_P17, atan2_P16 
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_W8        = atan2_w, atan2_P19, atan2_P18
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_W3        = atan2_w, atan2_P13, atan2_P12 
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_W4        = atan2_w, atan2_P15, atan2_P14
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_V3        = atan2_w, atan2_P1 , atan2_P0 
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_V4        = atan2_w, atan2_P3 , atan2_P2
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_zcub      = atan2_z, atan2_w, f0
           nop.i 999
}
{ .mfi
           nop.m 999
           fnma.s1       atan2_gV        = atan2_Umax, atan2_z, atan2_Vmin 
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           frcpa.s1     atan2_F,p15     = f1, atan2_E
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_V10       = atan2_V12, atan2_V13, atan2_V11
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_V6        = atan2_V12, atan2_V8 , atan2_V7 
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_V9        = atan2_V12, atan2_V12, f0
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_W10       = atan2_V12, atan2_P22 , atan2_W11
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_W6        = atan2_V12, atan2_W8 , atan2_W7
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_W2        = atan2_V12, atan2_W4  , atan2_W3
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_V2        = atan2_V12, atan2_V4 , atan2_V3
           nop.i 999
;;
}


// Both X and Y are INF
// p10 ==> X +
// p11 ==> X -
.pred.rel "mutex",p10,p11
{ .mfb
           nop.m 999
(p10)      fma.d       f8              = atan2_sgnY, atan2_pi_by_4, f0
(p10)      br.ret.spnt b0
}
{ .mfb
           nop.m 999
(p11)      fma.d       f8              = atan2_sgnY, atan2_3pi_by_4, f0
(p11)      br.ret.spnt b0
;;
}


.pred.rel "mutex",p8,p9,p6
{ .mfi
           nop.m 999
           fnma.s1      atan2_alpha     = atan2_E, atan2_F, f1
           nop.i 999
}
{ .mfi
           nop.m 999
           fnma.s1      atan2_alpha_1   = atan2_E, atan2_F, atan2_two
           nop.i 999
;;
}


{ .mfi
           nop.m 999
//(atan2_sT) fmerge.s     atan2_P         = atan2_Y, atan2_Pi_by_2
(p6) fmerge.s     atan2_P         = atan2_Y, atan2_Pi_by_2
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_gVF       = atan2_gV, atan2_F, f0
           nop.i 999
;;
}


{ .mfi
           nop.m 999
           fma.s1       atan2_V5        = atan2_V9, atan2_V10, atan2_V6
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_W12       = atan2_V9, atan2_V9, f0
           nop.i 999
;;
}



{ .mfi
           nop.m 999
(p8)       fmerge.s     atan2_P         = atan2_sgnY, f0
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_W5        = atan2_V9, atan2_W10, atan2_W6
           nop.i 999
;;
}




{ .mfi
           nop.m 999
(p9)       fmerge.s     atan2_P         = atan2_sgnY, atan2_pi
           nop.i 999
;;
}


{ .mfi
           nop.m 999
           fma.s1       atan2_alpha_sq  = atan2_alpha, atan2_alpha, f0  
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_Cp        = atan2_alpha, atan2_alpha_1, f1  
           nop.i 999
;;
}


{ .mfi
           nop.m 999
           fma.s1       atan2_V1        = atan2_V9, atan2_V5, atan2_V2
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_W12       = atan2_V9, atan2_W12, f0
           nop.i 999
;;
}


// p13 ==> x  inf     y !inf
{ .mfi
           nop.m 999
           fma.s1       atan2_W1        = atan2_V9, atan2_W5, atan2_W2
           nop.i 999
}
{ .mfi
           nop.m 999
(p13)      fcmp.eq.unc.s1 p10,p11       = atan2_sgnX,f1
           nop.i 999
;;
}


{ .mfi
           nop.m 999
           fma.s1       atan2_alpha_cub = atan2_alpha, atan2_alpha_sq, f0
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_C         = atan2_gVF, atan2_Cp, f0
           nop.i 999
;;
}

.pred.rel "mutex",p10,p11 
// x inf y !inf
{ .mfb
           nop.m 999
(p10)      fmerge.s     f8              = atan2_sgnY, f0
(p10)      br.ret.spnt b0
}
{ .mfb
           nop.m 999
(p11)      fma.d        f8              = atan2_sgnY, atan2_pi, f0
(p11)      br.ret.spnt b0
;;
}



// p10 ==> y   0     x?
// p11 ==> y  !0     x?
{ .mfi
           nop.m 999
           fclass.m.unc p10,p11 = f8, 0x07
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_Pp        = atan2_W12, atan2_W1, atan2_V1
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_d         = atan2_alpha_cub, atan2_C, atan2_C
           nop.i 999
;;
}

// p12 ==>  y0     x0
// p13 ==>  y0     x!0
// p14 ==>  y!0    x0
// p15 ==>  y!0    x!0
{ .mfi
           nop.m 999
(p10)      fclass.m.unc p12,p13 = f9, 0x07 
           nop.i 999
}
{ .mfi
           nop.m 999
(p11)      fclass.m.unc p14,p15 = f9, 0x07 
           nop.i 999
;;
}




{ .mfb
           nop.m 999
(p13)      fcmp.eq.unc.s1 p10,p11       = atan2_sgnX,f1
(p12)      br.spnt ATAN2_ERROR
;;
}



{ .mfi
           nop.m 999
           fma.s1       atan2_pd        = atan2_P0, atan2_d, f0
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_dsq       = atan2_d, atan2_d, f0
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_A_hi      = atan2_zcub, atan2_Pp, atan2_z
           nop.i 999
}
{ .mfb
           nop.m 999
(p14)      fma.d       f8 = atan2_sgnY, atan2_Pi_by_2, f0
(p14)      br.ret.spnt b0                
;;
}



{ .mfb
           nop.m 999
(p10)      fmerge.s     f8              = atan2_sgnY, f0
(p10)      br.ret.spnt b0
}
{ .mfb
           nop.m 999
(p11)      fma.d        f8              = atan2_sgnY, atan2_pi, f0
(p11)      br.ret.spnt b0
;;
}



{ .mfi
           nop.m 999
           fma.s1       atan2_A_lo      = atan2_pd, atan2_dsq, atan2_d
           nop.i 999
;;
}


{ .mfi
           nop.m 999
           fma.s1       atan2_A         = atan2_A_hi, f1, atan2_A_lo
           nop.i 999
;;
}

{ .mfb
           nop.m 999
           fma.d        f8              = atan2_sgnXY, atan2_A, atan2_P
           br.ret.sptk  b0     
}

ATAN2_ERROR:

{ .mfi
          nop.m 999
          fcmp.eq.unc.s1 p10,p11       = atan2_sgnX,f1
          nop.i 999
}
;;

{ .mfi
          mov        atan2_GR_tag     = 37 
(p10)     fmerge.s     f10             = atan2_sgnY, f0
          nop.i 999 
}
{ .mfi
          nop.m 999
(p11)     fma.d        f10            = atan2_sgnY, atan2_pi, f0
          nop.i 999
;;
}
.endp atan2#


// Stack operations when calling error support.
//       (1)               (2)                          (3) (call)              (4)
//   sp   -> +          psp -> +                     psp -> +                   sp -> +
//           |                 |                            |                         |
//           |                 | <- GR_Y               R3 ->| <- GR_RESULT            | -> f8
//           |                 |                            |                         |
//           | <-GR_Y      Y2->|                       Y2 ->| <- GR_Y                 |
//           |                 |                            |                         |
//           |                 | <- GR_X               X1 ->|                         |
//           |                 |                            |                         |
//  sp-64 -> +          sp ->  +                     sp ->  +                         +
//    save ar.pfs          save b0                                               restore gp
//    save gp                                                                    restore ar.pfs


.proc __libm_error_region
__libm_error_region:
.prologue
// (1)
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 999
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                          // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                      // Save gp
};;


// (2)
{ .mmi
        stfd [GR_Parameter_Y] = f8,16         // STORE Parameter 2 on stack
        add GR_Parameter_X = 16,sp            // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                     // Save b0
};;

.body
// (3)
{ .mib
        stfd [GR_Parameter_X] = f9                   // STORE Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y // Parameter 3 address
        nop.b 0                                 
}
{ .mib
        stfd [GR_Parameter_Y] = f10                  // STORE Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#        // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

// (4)
{ .mmi
        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region

.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\atanf.s ===
.file "atanf.s"

// THIS IS NOT OPTIMIZED AND NOT OFFICIAL

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.


// History
//==============================================================
// ?/??/00  Initial revision 
// 8/17/00  Changed predicate register macro-usage to direct predicate
//          names due to an assembler bug.

//
// Assembly macros
//==============================================================

// integer registers used
EXP_Addr1          = r33
EXP_Addr2          = r34

// floating point registers used
atanf_coeff_R4     = f32
atanf_coeff_R5     = f33
atanf_coeff_R1     = f34
atanf_coeff_R2     = f35

atanf_coeff_R3     = f36
atanf_coeff_P1     = f37
atanf_coeff_Q6     = f38
atanf_coeff_Q7     = f39
atanf_coeff_Q8     = f40

atanf_coeff_Q9     = f41
atanf_coeff_Q4     = f42
atanf_coeff_Q5     = f43
atanf_coeff_Q2     = f44
atanf_coeff_Q3     = f45

atanf_coeff_P5     = f46
atanf_coeff_P6     = f47
atanf_coeff_Q0     = f48
atanf_coeff_Q1     = f49
atanf_coeff_P7     = f50

atanf_coeff_P8     = f51
atanf_coeff_P3     = f52
atanf_coeff_P4     = f53
atanf_coeff_P9     = f54
atanf_coeff_P10    = f55

atanf_coeff_P2     = f56
atanf_piby2        = f57
atanf_z            = f58
atanf_b            = f59
atanf_zsq          = f60

atanf_sgn_x        = f61
atanf_sgnx_piby2   = f62
atanf_abs_x        = f63
atanf_t            = f64
atanf_xcub         = f65

atanf_tsq          = f66
atanf_t4           = f67
atanf_x5           = f68
atanf_x6           = f69
atanf_x11          = f70

atanf_poly_p1      = f71
atanf_poly_p2      = f72
atanf_poly_p3      = f73
atanf_poly_p4      = f74
atanf_poly_p5      = f75

atanf_poly_q1      = f76
atanf_poly_q2      = f77
atanf_poly_q3      = f78
atanf_poly_q4      = f79
atanf_poly_q5      = f80

atanf_poly_q       = f81
atanf_poly_r1      = f81
atanf_poly_r2      = f82
atanf_poly_r3      = f83
atanf_bsq          = f84
atanf_z4           = f85

atanf_z5           = f86
atanf_z8           = f87
atanf_z13          = f88
atanf_poly_r2      = f89
atanf_poly_r1      = f90

atanf_z8_bsq       = f91
atanf_poly_r       = f92
atanf_z21_poly_r   = f93
atanf_answer       = f8


// predicate registers used
//atanf_pred_LE1     = p6
//atanf_pred_GT1     = p7


.data

.align 16

atanf_coeff_1_table:
data8 0x40c4c241be751ff2  // r4
data8 0x40e9f300c2f3070b  // r5
data8 0x409babffef772075  // r3
data8 0xbfd5555512191621  // p1
data8 0x3fc9997e7afbff4e  // p2  = q8
data8 0xbfd5555512191621  // p1  = q9
data8 0x3f97105b4160f86b  // p8  = q2
data8 0xbfa6e10ba401393f  // p7  = q3
data8 0x3f522e5d33bc9baa  // p10 = q0
data8 0xbf7deaadaa336451  // p9  = q1
data8 0xbfc2473c5145ee38  // p3
data8 0x3fbc4f512b1865f5  // p4
data8 0x3fc9997e7afbff4e  // p2
data8 0x3ff921fb54442d18  // pi/2



atanf_coeff_2_table:
data8 0x4035000000004284  // r1
data8 0x406cdffff336a59b  // r2
data8 0x3fbc4f512b1865f5  // p4 = q6
data8 0xbfc2473c5145ee38  // p3 = q7
data8 0x3fb142a73d7c54e3  // p6 = q4
data8 0xbfb68eed6a8cfa32  // p5 = q5
data8 0xbfb68eed6a8cfa32  // p5
data8 0x3fb142a73d7c54e3  // p6
data8 0xbfa6e10ba401393f  // p7
data8 0x3f97105b4160f86b  // p8
data8 0xbf7deaadaa336451  // p9
data8 0x3f522e5d33bc9baa  // p10



.global atanf 

.text
.proc  atanf

.align 32
atanf:


{     .mfi 
     alloc      r32                  = ar.pfs,1,2,0,0
     frcpa.s1  atanf_z,p0   =    f1,f8
     addl      EXP_Addr2           =    @ltoff(atanf_coeff_2_table),gp
} 
{     .mfi 
     addl      EXP_Addr1 =    @ltoff(atanf_coeff_1_table),gp
     fma.s1    atanf_t   =    f8,f8,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fmerge.s  atanf_sgn_x    =    f8,f1
     nop.i                      999;;
} 
 
{     .mfi 
     ld8       EXP_Addr1      =    [EXP_Addr1]
     fmerge.s  atanf_abs_x    =    f1,f8
     nop.i                      999
} 
{     .mfi 
     ld8       EXP_Addr2 =    [EXP_Addr2]
     nop.f                 999
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fclass.m  p8,p0   =    f8,0x7	// @zero
     nop.i                      999;;
} 
 
{     .mfi 
     nop.m                      999
     fcmp.eq.unc.s0 p9,p10    =    f8,f1
     nop.i                      999;;
} 
 
{     .mfi 
     ldfpd     atanf_coeff_R4,atanf_coeff_R5 =    [EXP_Addr1],16
     fnma.s1   atanf_b                       =    f8,atanf_z,f1
     nop.i                                     999
} 
{     .mfi 
     ldfpd     atanf_coeff_R1,atanf_coeff_R2 =    [EXP_Addr2],16
     fma.s1    atanf_zsq                     =    atanf_z,atanf_z,f0
     nop.i                                     999;;
}

 
{     .mfi 
     ldfpd     atanf_coeff_R3,atanf_coeff_P1 =    [EXP_Addr1],16
     fma.s1    atanf_xcub                    =    f8,atanf_t,f0
     nop.i                                     999
} 
{     .mfi 
     ldfpd     atanf_coeff_Q6,atanf_coeff_Q7 =    [EXP_Addr2],16
     fma.s1    atanf_tsq                     =    atanf_t,atanf_t,f0
     nop.i                                     999;;
}

 
{     .mfi 
     ldfpd          atanf_coeff_Q8,atanf_coeff_Q9 =    [EXP_Addr1],16
//     fcmp.le.s1     atanf_pred_LE1,atanf_pred_GT1 =    atanf_abs_x,f1
     fcmp.le.s1     p6,p7 =    atanf_abs_x,f1
     nop.i                                          999
} 
{     .mfi 
     ldfpd     atanf_coeff_Q4,atanf_coeff_Q5 =    [EXP_Addr2],16
     nop.f                                     999
     nop.i                                     999;;
}

 
{     .mfi 
     ldfpd     atanf_coeff_Q2,atanf_coeff_Q3 =    [EXP_Addr1],16
     fclass.m  p8,p0                  =    f8,0xe7	// @inf|@qnan|@snan|@zero
     nop.i                                     999
} 
{     .mfi 
     ldfpd     atanf_coeff_P5,atanf_coeff_P6 =    [EXP_Addr2],16
     nop.f                                     999
     nop.i                                     999;;
}

 
{     .mfi 
     ldfpd     atanf_coeff_Q0,atanf_coeff_Q1 =    [EXP_Addr1],16
     nop.f                                     999
     nop.i                                     999
} 
{     .mfi 
     ldfpd     atanf_coeff_P7,atanf_coeff_P8 =    [EXP_Addr2],16
     nop.f                                     999
     nop.i                                     999;;
}

 
{     .mfi 
     ldfpd     atanf_coeff_P3,atanf_coeff_P4 =    [EXP_Addr1],16
     fma.s1    atanf_bsq                     =    atanf_b,atanf_b,f0
     nop.i                                     999
} 
{     .mfi 
     ldfpd     atanf_coeff_P9,atanf_coeff_P10     =    [EXP_Addr2]
     fma.s1    atanf_z4                           =    atanf_zsq,atanf_zsq,f0
     nop.i                                          999;;
}

 
{     .mfi 
     ldfpd     atanf_coeff_P2,atanf_piby2    =    [EXP_Addr1]
     fma.s1    atanf_x6                      =    atanf_t,atanf_tsq,f0
     nop.i                                     999
} 
{     .mfi 
     nop.m                 999
     fma.s1    atanf_t4  =    atanf_tsq,atanf_tsq,f0
     nop.i                 999;;
}

 
{     .mfb 
     nop.m                 999
     fma.s1    atanf_x5  =    atanf_t,atanf_xcub,f0
(p8)  br.cond.spnt   ATANF_X_INF_NAN_ZERO
} 
;;
 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_r1  =    atanf_b,atanf_coeff_R1,f1
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_r3  =    atanf_b,atanf_coeff_R5,atanf_coeff_R4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_r2  =    atanf_b,atanf_coeff_R3,atanf_coeff_R2
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    atanf_z8  =    atanf_z4,atanf_z4,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_q2  =    atanf_t,atanf_coeff_Q5,atanf_coeff_Q4
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_q3  =    atanf_t,atanf_coeff_Q7,atanf_coeff_Q6
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    atanf_z5  =    atanf_z,atanf_z4,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_q1  =    atanf_t,atanf_coeff_Q9,atanf_coeff_Q8
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_q4  =    atanf_t,atanf_coeff_Q1,atanf_coeff_Q0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_q5  =    atanf_t,atanf_coeff_Q3,atanf_coeff_Q2
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_p4  =    f8,atanf_coeff_P1,f0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_p5  =    atanf_t,atanf_coeff_P4,atanf_coeff_P3
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_r1  =    atanf_z8,atanf_poly_r1,f0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_z8_bsq   =    atanf_z8,atanf_bsq,f0
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_q2  =    atanf_tsq,atanf_poly_q3,atanf_poly_q2
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_r2  =    atanf_bsq,atanf_poly_r3,atanf_poly_r2
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_p2  =    atanf_t,atanf_coeff_P8,atanf_coeff_P7
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_q1  =    atanf_poly_q1,f1,atanf_tsq
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    atanf_z13 =    atanf_z5,atanf_z8,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_p1  =    atanf_t,atanf_coeff_P10,atanf_coeff_P9
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_p4  =    atanf_t,atanf_poly_p4,f8
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_q4  =    atanf_tsq,atanf_poly_q5,atanf_poly_q4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_p3  =    atanf_t,atanf_coeff_P6,atanf_coeff_P5
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_p5  =    atanf_t,atanf_poly_p5,atanf_coeff_P2
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    atanf_x11 =    atanf_x5,atanf_x6,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_r   =    atanf_z8_bsq,atanf_poly_r2,atanf_poly_r1
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                           999
     fma       atanf_sgnx_piby2    =    atanf_sgn_x,atanf_piby2,f0
     nop.i                           999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_q2  =    atanf_t4,atanf_poly_q1,atanf_poly_q2
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_p1  =    atanf_tsq,atanf_poly_p1,atanf_poly_p2
     nop.i                      999;;
} 
 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_p4  =    atanf_x5,atanf_poly_p5,atanf_poly_p4
     nop.i                      999;;
} 
 
{     .mfi 
     nop.m                           999
     fma.s1    atanf_z21_poly_r    =    atanf_z13,atanf_poly_r,f0
     nop.i                           999;;
} 
 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_q   =    atanf_t4,atanf_poly_q2,atanf_poly_q4
     nop.i                      999;;
} 
 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_p1  =    atanf_tsq,atanf_poly_p1,atanf_poly_p3
     nop.i                      999;;
} 
 
{     .mfi 
                    nop.m                      999
//(atanf_pred_GT1)    fnma.s    atanf_answer   =    atanf_poly_q,atanf_z21_poly_r,atanf_sgnx_piby2
(p7)    fnma.s    atanf_answer   =    atanf_poly_q,atanf_z21_poly_r,atanf_sgnx_piby2
                    nop.i                      999;;
} 
 
{     .mfb 
                    nop.m                      999
//(atanf_pred_LE1)    fma.s     atanf_answer   =    atanf_x11,atanf_poly_p1,atanf_poly_p4
(p6)    fma.s     atanf_answer   =    atanf_x11,atanf_poly_p1,atanf_poly_p4
                    br.ret.sptk b0
} 



ATANF_X_INF_NAN_ZERO:

      fclass.m p8,p9 = f8,0x23	// @inf
;;
(p8)  fmerge.s f8 = f8, atanf_piby2
;;
      fnorm.s f8 = f8
      br.ret.sptk b0

.endp atanf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\asin.s ===
.file "asin.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.

// History
//==============================================================
// 2/02/00  Initial version 
// 8/17/00  New and much faster algorithm.
// 8/31/00  Avoided bank conflicts on loads, shortened |x|=1 path, 
//          fixed mfb split issue stalls.

// Description
//=========================================
// The asin function computes the principle value of the arc sine of x.
// asin(0) returns 0, asin(1) returns pi/2, asin(-1) returns -pi/2.
// A doman error occurs for arguments not in the range [-1,+1].

// The asin function returns the arc sine in the range [-pi/2, +pi/2] radians.

//
// Assembly macros
//=========================================


// predicate registers
//asin_pred_LEsqrt2by2            = p7
//asin_pred_GTsqrt2by2            = p8

// integer registers
ASIN_Addr1                      = r33
ASIN_Addr2                      = r34
ASIN_FFFE                       = r35

GR_SAVE_B0                      = r36
GR_SAVE_PFS                     = r37
GR_SAVE_GP                      = r38

GR_Parameter_X                  = r39
GR_Parameter_Y                  = r40
GR_Parameter_RESULT             = r41
GR_Parameter_Tag                = r42

// floating point registers
asin_coeff_P1                   = f32
asin_coeff_P2                   = f33
asin_coeff_P3                   = f34
asin_coeff_P4                   = f35

asin_coeff_P5                   = f36
asin_coeff_P6                   = f37
asin_coeff_P7                   = f38
asin_coeff_P8                   = f39
asin_coeff_P9                   = f40

asin_coeff_P10                  = f41
asin_coeff_P11                  = f42
asin_coeff_P12                  = f43
asin_coeff_P13                  = f44
asin_coeff_P14                  = f45

asin_coeff_P15                  = f46
asin_coeff_P16                  = f47
asin_coeff_P17                  = f48
asin_coeff_P18                  = f49
asin_coeff_P19                  = f50

asin_coeff_P20                  = f51
asin_coeff_P21                  = f52
asin_const_sqrt2by2             = f53
asin_const_piby2                = f54
asin_abs_x                      = f55

asin_tx                         = f56
asin_tx2                        = f57
asin_tx3                        = f58
asin_tx4                        = f59
asin_tx8                        = f60

asin_tx11                       = f61
asin_1poly_p8                   = f62
asin_1poly_p19                  = f63
asin_1poly_p4                   = f64
asin_1poly_p15                  = f65

asin_1poly_p6                   = f66
asin_1poly_p17                  = f67
asin_1poly_p0                   = f68
asin_1poly_p11                  = f69
asin_1poly_p2                   = f70

asin_1poly_p13                  = f71
asin_series_tx                  = f72
asin_t                          = f73
asin_t2                         = f74
asin_t3                         = f75

asin_t4                         = f76
asin_t8                         = f77
asin_t11                        = f78
asin_poly_p8                    = f79
asin_poly_p19                   = f80

asin_poly_p4                    = f81
asin_poly_p15                   = f82
asin_poly_p6                    = f83
asin_poly_p17                   = f84
asin_poly_p0                    = f85

asin_poly_p11                   = f86
asin_poly_p2                    = f87
asin_poly_p13                   = f88
asin_series_t                   = f89
asin_1by2                       = f90

asin_3by2                       = f91
asin_5by2                       = f92
asin_11by4                      = f93
asin_35by8                      = f94
asin_63by8                      = f95

asin_231by16                    = f96 
asin_y0                         = f97 
asin_H0                         = f98 
asin_S0                         = f99 
asin_d                          = f100

asin_l1                         = f101
asin_d2                         = f102
asin_T0                         = f103
asin_d1                         = f104
asin_e0                         = f105

asin_l2                         = f106
asin_d3                         = f107
asin_T3                         = f108
asin_S1                         = f109
asin_e1                         = f110

asin_z                          = f111
answer2                         = f112
asin_sgn_x                      = f113
asin_429by16                    = f114
asin_18by4                      = f115

asin_3by4                       = f116
asin_l3                         = f117
asin_T6                         = f118

// Data tables
//==============================================================

.data

.align 16

asin_coeff_1_table:
data8 0xE4E7E0A423A21249  , 0x00003FF8 //P7
data8 0xC2F7EE0200FCE2A5  , 0x0000C003 //P18
data8 0xB745D7F6C65C20E0  , 0x00003FF9 //P5
data8 0xF75E381A323D4D94  , 0x0000C002 //P16
data8 0x8959C2629C1024C0  , 0x0000C002 //P20
data8 0xAFF68E7D241292C5  , 0x00003FF8 //P9
data8 0xB6DB6DB7260AC30D  , 0x00003FFA //P3
data8 0xD0417CE2B41CB7BF  , 0x0000C000 //P14
data8 0x81D570FEA724E3E4  , 0x0000BFFD //P12
data8 0xAAAAAAAAAAAAC277  , 0x00003FFC //P1
data8 0xF534912FF3E7B76F  , 0x00003FFF //P21
data8 0xc90fdaa22168c235  , 0x00003fff // pi/2
data8 0x0000000000000000  , 0x00000000 // pad to avoid data bank conflict


asin_coeff_2_table:
data8 0x8E26AF5F29B39A2A  , 0x00003FF9 //P6
data8 0xB4F118A4B1015470  , 0x00004003 //P17
data8 0xF8E38E10C25990E0  , 0x00003FF9 //P4
data8 0x80F50489AEF1CAC6  , 0x00004002 //P15
data8 0x92728015172CFE1C  , 0x00004003 //P19
data8 0xBBC3D831D4595971  , 0x00003FF8 //P8
data8 0x999999999952A5C3  , 0x00003FFB //P2
data8 0x855576BE6F0975EC  , 0x00003FFF //P13
data8 0xF12420E778077D89  , 0x00003FFA //P11
data8 0xB6590FF4D23DE003  , 0x00003FF3 //P10
data8 0xb504f333f9de6484  , 0x00003ffe // sqrt(2)/2



.align 32
.global asin

.section .text
.proc  asin
.align 32


asin:
 
{     .mfi 
     alloc      r32               = ar.pfs,1,6,4,0
     fma.s1    asin_tx        =    f8,f8,f0
     addl      ASIN_Addr2     =    @ltoff(asin_coeff_2_table),gp
} 
{     .mfi 
     mov       ASIN_FFFE      =    0xFFFE
     fnma.s1   asin_t         =    f8,f8,f1
     addl      ASIN_Addr1     =    @ltoff(asin_coeff_1_table),gp
}
;;

 
{     .mfi 
     setf.exp       asin_1by2      =    ASIN_FFFE
     fmerge.s       asin_abs_x     =    f1,f8
     nop.i          999              ;;
} 
 
{     .mmf 
     ld8       ASIN_Addr1     =    [ASIN_Addr1]
     ld8       ASIN_Addr2     =    [ASIN_Addr2]
     fmerge.s  asin_sgn_x     =    f8,f1 ;;
} 

 
{     .mfi 
     ldfe      asin_coeff_P7  =    [ASIN_Addr1],16
     fma.s1    asin_tx2       =    asin_tx,asin_tx,f0
     nop.i                      999
} 
{     .mfi 
     ldfe      asin_coeff_P6  =    [ASIN_Addr2],16
     fma.s1    asin_t2        =    asin_t,asin_t,f0
     nop.i                      999;;
}

 
{     .mmf 
     ldfe      asin_coeff_P18 =    [ASIN_Addr1],16
     ldfe      asin_coeff_P17 =    [ASIN_Addr2],16
     fclass.m.unc p8,p0  = f8, 0xc3	//@qnan |@snan
} 
;;
 
{     .mmf 
     ldfe           asin_coeff_P5  =    [ASIN_Addr1],16
     ldfe      asin_coeff_P4  =    [ASIN_Addr2],16
     frsqrta.s1     asin_y0,p0     =    asin_t
} 
;;
 
{     .mfi 
     ldfe      asin_coeff_P16 =    [ASIN_Addr1],16
     fcmp.gt.s1 p9,p0 = asin_abs_x,f1
     nop.i                      999
} 
{     .mfb 
     ldfe      asin_coeff_P15 =    [ASIN_Addr2],16
(p8) fma.d     f8 = f8,f1,f0
(p8) br.ret.spnt b0
}
;;

 
{     .mmf 
     ldfe      asin_coeff_P20 =    [ASIN_Addr1],16
     ldfe      asin_coeff_P19 =    [ASIN_Addr2],16
     fclass.m.unc p8,p0 = f8, 0x07	//@zero
} 
;;
 

{     .mfi 
     ldfe      asin_coeff_P9  =    [ASIN_Addr1],16
     fma.s1    asin_t4        =    asin_t2,asin_t2,f0
(p9) mov GR_Parameter_Tag = 61 
} 
{     .mfi 
     ldfe      asin_coeff_P8  =    [ASIN_Addr2],16
     fma.s1    asin_3by2      =    asin_1by2,f1,f1
     nop.i                      999;;
}

 
{     .mfi 
     ldfe      asin_coeff_P2  =    [ASIN_Addr2],16
     fma.s1    asin_tx4       =    asin_tx2,asin_tx2,f0
     nop.i                      999
} 
{     .mfb 
     ldfe      asin_coeff_P3  =    [ASIN_Addr1],16
     fma.s1    asin_t3        =    asin_t,asin_t2,f0
(p8) br.ret.spnt b0
}
;;

 
{     .mfi 
     ldfe      asin_coeff_P13 =    [ASIN_Addr2],16
     fma.s1    asin_H0        =    asin_y0,asin_1by2,f0
     nop.i                      999
} 
{     .mfb 
     ldfe      asin_coeff_P14 =    [ASIN_Addr1],16
     fma.s1    asin_S0        =    asin_y0,asin_t,f0
(p9) br.cond.spnt  __libm_error_region
}
;;

 
{     .mfi 
     ldfe      asin_coeff_P11 =    [ASIN_Addr2],16
     fcmp.eq.s1 p6,p0 = asin_abs_x,f1
     nop.i                      999
} 
{     .mfi 
     ldfe      asin_coeff_P12 =    [ASIN_Addr1],16
     fma.s1    asin_tx3       =    asin_tx,asin_tx2,f0
     nop.i                      999;;
}

 
{     .mfi 
     ldfe      asin_coeff_P10 =    [ASIN_Addr2],16
     fma.s1    asin_1poly_p6  =    asin_tx,asin_coeff_P7,asin_coeff_P6
     nop.i                      999
} 
{     .mfi 
     ldfe      asin_coeff_P1  =    [ASIN_Addr1],16
     fma.s1    asin_poly_p6   =    asin_t,asin_coeff_P7,asin_coeff_P6
     nop.i                      999;;
}

 
{     .mfi 
     ldfe      asin_const_sqrt2by2 =    [ASIN_Addr2],16
     fma.s1    asin_5by2           =    asin_3by2,f1,f1
     nop.i                           999
} 
{     .mfi 
     ldfe      asin_coeff_P21 =    [ASIN_Addr1],16
     fma.s1    asin_11by4     =    asin_3by2,asin_3by2,asin_1by2
     nop.i                      999;;
}

 
{     .mfi 
     ldfe      asin_const_piby2    =    [ASIN_Addr1],16
     fma.s1    asin_poly_p17       =    asin_t,asin_coeff_P18,asin_coeff_P17
     nop.i                           999
} 
{     .mfb 
     nop.m                 999
     fma.s1    asin_3by4 =    asin_3by2,asin_1by2,f0
(p6) br.cond.spnt  ASIN_ABS_1      // Branch to short exit if |x|=1
}
;;

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p15  =    asin_t,asin_coeff_P16,asin_coeff_P15
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fnma.s1   asin_d    =    asin_S0,asin_H0,asin_1by2
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p19  =    asin_t,asin_coeff_P20,asin_coeff_P19
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p4   =    asin_t,asin_coeff_P5,asin_coeff_P4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p17 =    asin_tx,asin_coeff_P18,asin_coeff_P17
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p8   =    asin_t,asin_coeff_P9,asin_coeff_P8
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fms.s1    asin_35by8     =    asin_5by2,asin_11by4,asin_5by2
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_63by8     =    asin_5by2,asin_11by4,f1
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p13  =    asin_t,asin_coeff_P14,asin_coeff_P13
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_18by4     =    asin_3by2,asin_5by2,asin_3by4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    asin_l1   =    asin_5by2,asin_d,asin_3by2
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fma.s1    asin_d2   =    asin_d,asin_d,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p15  =    asin_t2,asin_poly_p17,asin_poly_p15
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    asin_T0   =    asin_d,asin_S0,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p19  =    asin_t2,asin_coeff_P21,asin_poly_p19
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p4   =    asin_t2,asin_poly_p6,asin_poly_p4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    asin_d1   =    asin_35by8,asin_d,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_231by16   =    asin_3by2,asin_35by8,asin_63by8
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p2   =    asin_t,asin_coeff_P3,asin_coeff_P2
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p8   =    asin_t2,asin_coeff_P10,asin_poly_p8
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p11  =    asin_t,asin_coeff_P12,asin_coeff_P11
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    asin_e0   =    asin_d2,asin_l1,asin_d
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p15 =    asin_tx,asin_coeff_P16,asin_coeff_P15
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p0   =    asin_t,asin_coeff_P1,f1
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p19 =    asin_tx,asin_coeff_P20,asin_coeff_P19
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p4  =    asin_tx,asin_coeff_P5,asin_coeff_P4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p8  =    asin_tx,asin_coeff_P9,asin_coeff_P8
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    asin_l2   =    asin_231by16,asin_d,asin_63by8
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    asin_d3   =    asin_d2,asin_d,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fma.s1    asin_T3   =    asin_d2,asin_T0,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_429by16   =    asin_18by4,asin_11by4,asin_231by16
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    asin_S1   =    asin_e0,asin_S0,asin_S0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p4   =    asin_t4,asin_poly_p8,asin_poly_p4
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p15  =    asin_t4,asin_poly_p19,asin_poly_p15
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p0   =    asin_t2,asin_poly_p2,asin_poly_p0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p11  =    asin_t2,asin_poly_p13,asin_poly_p11
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    asin_t8   =    asin_t4,asin_t4,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fma.s1    asin_e1   =    asin_d2,asin_l2,asin_d1
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p4  =    asin_tx2,asin_1poly_p6,asin_1poly_p4
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p15 =    asin_tx2,asin_1poly_p17,asin_1poly_p15
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p8  =    asin_tx2,asin_coeff_P10,asin_1poly_p8
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p19 =    asin_tx2,asin_coeff_P21,asin_1poly_p19
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p2  =    asin_tx,asin_coeff_P3,asin_coeff_P2
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p13 =    asin_tx,asin_coeff_P14,asin_coeff_P13
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p0  =    asin_tx,asin_coeff_P1,f1
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p11 =    asin_tx,asin_coeff_P12,asin_coeff_P11
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    asin_l3   =    asin_429by16,asin_d,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fma.s1    asin_z    =    asin_e1,asin_T3,asin_S1
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p11  =    asin_t4,asin_poly_p15,asin_poly_p11
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    asin_T6   =    asin_T3,asin_d3,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    asin_t11  =    asin_t8,asin_t3,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p0   =    asin_t4,asin_poly_p4,asin_poly_p0
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p4  =    asin_tx4,asin_1poly_p8,asin_1poly_p4
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p15 =    asin_tx4,asin_1poly_p19,asin_1poly_p15
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p0  =    asin_tx2,asin_1poly_p2,asin_1poly_p0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p11 =    asin_tx2,asin_1poly_p13,asin_1poly_p11
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                                                         999
//     fcmp.le.s1     asin_pred_LEsqrt2by2,asin_pred_GTsqrt2by2    =    asin_abs_x,asin_const_sqrt2by2
     fcmp.le.s1     p7,p8    =    asin_abs_x,asin_const_sqrt2by2
     nop.i                                                         999
} 
{     .mfi 
     nop.m                 999
     fma.s1    asin_tx8  =    asin_tx4,asin_tx4,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    asin_z    =    asin_l3,asin_T6,asin_z
     nop.i                 999;;
} 
 
{     .mfi 
     nop.m                      999
     fma.s1    asin_series_t  =    asin_t11,asin_poly_p11,asin_poly_p0
     nop.i                      999;;
} 
 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p0  =    asin_tx4,asin_1poly_p4,asin_1poly_p0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p11 =    asin_tx4,asin_1poly_p15,asin_1poly_p11
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    asin_tx11 =    asin_tx8,asin_tx3,f0
     nop.i                 999;;
} 
 
{     .mfi 
                         nop.m                 999
//(asin_pred_GTsqrt2by2)   fnma.s1      answer2   =    asin_z,asin_series_t,asin_const_piby2
(p8)   fnma.s1      answer2   =    asin_z,asin_series_t,asin_const_piby2
                         nop.i                 999;;
} 
 
{     .mfi 
     nop.m                      999
     fma.s1    asin_series_tx =    asin_tx11,asin_1poly_p11,asin_1poly_p0
     nop.i                      999;;
} 
 
{     .mfi 
                         nop.m                 999
//(asin_pred_GTsqrt2by2)   fma.d     f8   =    asin_sgn_x,answer2,f0
(p8)   fma.d     f8   =    asin_sgn_x,answer2,f0
                         nop.i                 999;;
} 
 
{     .mfb 
                         nop.m                 999
//(asin_pred_LEsqrt2by2)   fma.d     f8   =    f8,asin_series_tx,f0
(p7)   fma.d     f8   =    f8,asin_series_tx,f0
       br.ret.sptk b0
} 
;;


ASIN_ABS_1:
// Here for short exit if |x|=1
{     .mfb 
     nop.m                      999
     fma.d    f8 =    asin_sgn_x,asin_const_piby2,f0
     br.ret.sptk b0
} 
;;


.endp asin

.proc __libm_error_region
__libm_error_region:
.prologue
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
                nop.f 999
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfs [GR_Parameter_Y] = f1,16         // Store Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
};;

.body
        frcpa.s0 f9,p0 = f0,f0
;;

{ .mib
        stfd [GR_Parameter_X] = f8            // Store Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
        nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfd [GR_Parameter_Y] = f9,-16           // Store Parameter 3 on stack
        adds r32 = 48,sp
        br.call.sptk b0=__libm_error_support#   // Call error handling function
};;
{ .mmi
        ldfd  f8 = [r32]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return

};;

.endp __libm_error_region

.type   __libm_error_support,@function
.global __libm_error_support
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\cosh.s ===
.file "cosh.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version 
// 4/04/00  Unwind support added
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
//
// API
//==============================================================
// double = cosh(double)
// input  floating point f8
// output floating point f8


// Overview of operation
//==============================================================
// There are four paths

// 1. |x| < 0.25        COSH_BY_POLY
// 2. |x| < 32          COSH_BY_TBL
// 3. |x| < 2^14        COSH_BY_EXP
// 4. |x_ >= 2^14       COSH_HUGE

// For paths 1, and 2 SAFE is always 1.
// For path  4, Safe is always 0.
// SAFE = 1 means we cannot overflow.


// Assembly macros
//==============================================================
cosh_FR_X            = f44
cosh_FR_SGNX         = f40

cosh_FR_Inv_log2by64 = f9
cosh_FR_log2by64_lo  = f11
cosh_FR_log2by64_hi  = f10

cosh_FR_A1           = f9
cosh_FR_A2           = f10
cosh_FR_A3           = f11

cosh_FR_Rcub         = f12
cosh_FR_M_temp       = f13
cosh_FR_R_temp       = f13
cosh_FR_Rsq          = f13
cosh_FR_R            = f14

cosh_FR_M            = f38

cosh_FR_B1           = f15
cosh_FR_B2           = f32
cosh_FR_B3           = f33

cosh_FR_peven_temp1  = f34
cosh_FR_peven_temp2  = f35
cosh_FR_peven        = f36

cosh_FR_podd_temp1   = f34
cosh_FR_podd_temp2   = f35
cosh_FR_podd         = f37

cosh_FR_J_temp       = f9
cosh_FR_J            = f10

cosh_FR_Mmj          = f39

cosh_FR_N_temp1      = f11
cosh_FR_N_temp2      = f12
cosh_FR_N            = f13

cosh_FR_spos         = f14
cosh_FR_sneg         = f15

cosh_FR_Tjhi         = f32
cosh_FR_Tjlo         = f33
cosh_FR_Tmjhi        = f34
cosh_FR_Tmjlo        = f35

GR_mJ           = r35
GR_J            = r36

AD_mJ           = r38
AD_J            = r39

cosh_FR_C_hi         = f9
cosh_FR_C_hi_temp    = f10
cosh_FR_C_lo_temp1   = f11 
cosh_FR_C_lo_temp2   = f12 
cosh_FR_C_lo_temp3   = f13 

cosh_FR_C_lo         = f38
cosh_FR_S_hi         = f39

cosh_FR_S_hi_temp1   = f10
cosh_FR_Y_hi         = f11 
cosh_FR_Y_lo_temp    = f12 
cosh_FR_Y_lo         = f13 
cosh_FR_COSH         = f9

cosh_FR_X2           = f9
cosh_FR_X4           = f10

cosh_FR_P1           = f14
cosh_FR_P2           = f15
cosh_FR_P3           = f32
cosh_FR_P4           = f33
cosh_FR_P5           = f34
cosh_FR_P6           = f35

cosh_FR_TINY_THRESH  = f9

cosh_FR_COSH_temp    = f10
cosh_FR_SCALE        = f11 

cosh_FR_hi_lo = f10

cosh_FR_poly_podd_temp1    =  f11 
cosh_FR_poly_podd_temp2    =  f13
cosh_FR_poly_peven_temp1   =  f11
cosh_FR_poly_peven_temp2   =  f13

GR_SAVE_PFS                    = r41
GR_SAVE_B0                     = r42
GR_SAVE_GP                     = r43

GR_Parameter_X                 = r44
GR_Parameter_Y                 = r45
GR_Parameter_RESULT            = r46


// Data tables
//==============================================================

.data

.align 16
double_cosh_arg_reduction:
   data8 0xB8AA3B295C17F0BC, 0x00004005
   data8 0xB17217F7D1000000, 0x00003FF8
   data8 0xCF79ABC9E3B39804, 0x00003FD0

double_cosh_p_table:
   data8 0x8000000000000000, 0x00003FFE
   data8 0xAAAAAAAAAAAAAB80, 0x00003FFA
   data8 0xB60B60B60B4FE884, 0x00003FF5
   data8 0xD00D00D1021D7370, 0x00003FEF
   data8 0x93F27740C0C2F1CC, 0x00003FE9
   data8 0x8FA02AC65BCBD5BC, 0x00003FE2

double_cosh_ab_table:
   data8 0xAAAAAAAAAAAAAAAC, 0x00003FFC
   data8 0x88888888884ECDD5, 0x00003FF8
   data8 0xD00D0C6DCC26A86B, 0x00003FF2
   data8 0x8000000000000002, 0x00003FFE
   data8 0xAAAAAAAAAA402C77, 0x00003FFA
   data8 0xB60B6CC96BDB144D, 0x00003FF5

double_cosh_j_table:
   data8 0xB504F333F9DE6484, 0x00003FFE, 0x1EB2FB13, 0x00000000
   data8 0xB6FD91E328D17791, 0x00003FFE, 0x1CE2CBE2, 0x00000000
   data8 0xB8FBAF4762FB9EE9, 0x00003FFE, 0x1DDC3CBC, 0x00000000
   data8 0xBAFF5AB2133E45FB, 0x00003FFE, 0x1EE9AA34, 0x00000000
   data8 0xBD08A39F580C36BF, 0x00003FFE, 0x9EAEFDC1, 0x00000000
   data8 0xBF1799B67A731083, 0x00003FFE, 0x9DBF517B, 0x00000000
   data8 0xC12C4CCA66709456, 0x00003FFE, 0x1EF88AFB, 0x00000000
   data8 0xC346CCDA24976407, 0x00003FFE, 0x1E03B216, 0x00000000
   data8 0xC5672A115506DADD, 0x00003FFE, 0x1E78AB43, 0x00000000
   data8 0xC78D74C8ABB9B15D, 0x00003FFE, 0x9E7B1747, 0x00000000
   data8 0xC9B9BD866E2F27A3, 0x00003FFE, 0x9EFE3C0E, 0x00000000
   data8 0xCBEC14FEF2727C5D, 0x00003FFE, 0x9D36F837, 0x00000000
   data8 0xCE248C151F8480E4, 0x00003FFE, 0x9DEE53E4, 0x00000000
   data8 0xD06333DAEF2B2595, 0x00003FFE, 0x9E24AE8E, 0x00000000
   data8 0xD2A81D91F12AE45A, 0x00003FFE, 0x1D912473, 0x00000000
   data8 0xD4F35AABCFEDFA1F, 0x00003FFE, 0x1EB243BE, 0x00000000
   data8 0xD744FCCAD69D6AF4, 0x00003FFE, 0x1E669A2F, 0x00000000
   data8 0xD99D15C278AFD7B6, 0x00003FFE, 0x9BBC610A, 0x00000000
   data8 0xDBFBB797DAF23755, 0x00003FFE, 0x1E761035, 0x00000000
   data8 0xDE60F4825E0E9124, 0x00003FFE, 0x9E0BE175, 0x00000000
   data8 0xE0CCDEEC2A94E111, 0x00003FFE, 0x1CCB12A1, 0x00000000
   data8 0xE33F8972BE8A5A51, 0x00003FFE, 0x1D1BFE90, 0x00000000
   data8 0xE5B906E77C8348A8, 0x00003FFE, 0x1DF2F47A, 0x00000000
   data8 0xE8396A503C4BDC68, 0x00003FFE, 0x1EF22F22, 0x00000000
   data8 0xEAC0C6E7DD24392F, 0x00003FFE, 0x9E3F4A29, 0x00000000
   data8 0xED4F301ED9942B84, 0x00003FFE, 0x1EC01A5B, 0x00000000
   data8 0xEFE4B99BDCDAF5CB, 0x00003FFE, 0x1E8CAC3A, 0x00000000
   data8 0xF281773C59FFB13A, 0x00003FFE, 0x9DBB3FAB, 0x00000000
   data8 0xF5257D152486CC2C, 0x00003FFE, 0x1EF73A19, 0x00000000
   data8 0xF7D0DF730AD13BB9, 0x00003FFE, 0x9BB795B5, 0x00000000
   data8 0xFA83B2DB722A033A, 0x00003FFE, 0x1EF84B76, 0x00000000
   data8 0xFD3E0C0CF486C175, 0x00003FFE, 0x9EF5818B, 0x00000000
   data8 0x8000000000000000, 0x00003FFF, 0x00000000, 0x00000000
   data8 0x8164D1F3BC030773, 0x00003FFF, 0x1F77CACA, 0x00000000
   data8 0x82CD8698AC2BA1D7, 0x00003FFF, 0x1EF8A91D, 0x00000000
   data8 0x843A28C3ACDE4046, 0x00003FFF, 0x1E57C976, 0x00000000
   data8 0x85AAC367CC487B15, 0x00003FFF, 0x9EE8DA92, 0x00000000
   data8 0x871F61969E8D1010, 0x00003FFF, 0x1EE85C9F, 0x00000000
   data8 0x88980E8092DA8527, 0x00003FFF, 0x1F3BF1AF, 0x00000000
   data8 0x8A14D575496EFD9A, 0x00003FFF, 0x1D80CA1E, 0x00000000
   data8 0x8B95C1E3EA8BD6E7, 0x00003FFF, 0x9D0373AF, 0x00000000
   data8 0x8D1ADF5B7E5BA9E6, 0x00003FFF, 0x9F167097, 0x00000000
   data8 0x8EA4398B45CD53C0, 0x00003FFF, 0x1EB70051, 0x00000000
   data8 0x9031DC431466B1DC, 0x00003FFF, 0x1F6EB029, 0x00000000
   data8 0x91C3D373AB11C336, 0x00003FFF, 0x1DFD6D8E, 0x00000000
   data8 0x935A2B2F13E6E92C, 0x00003FFF, 0x9EB319B0, 0x00000000
   data8 0x94F4EFA8FEF70961, 0x00003FFF, 0x1EBA2BEB, 0x00000000
   data8 0x96942D3720185A00, 0x00003FFF, 0x1F11D537, 0x00000000
   data8 0x9837F0518DB8A96F, 0x00003FFF, 0x1F0D5A46, 0x00000000
   data8 0x99E0459320B7FA65, 0x00003FFF, 0x9E5E7BCA, 0x00000000
   data8 0x9B8D39B9D54E5539, 0x00003FFF, 0x9F3AAFD1, 0x00000000
   data8 0x9D3ED9A72CFFB751, 0x00003FFF, 0x9E86DACC, 0x00000000
   data8 0x9EF5326091A111AE, 0x00003FFF, 0x9F3EDDC2, 0x00000000
   data8 0xA0B0510FB9714FC2, 0x00003FFF, 0x1E496E3D, 0x00000000
   data8 0xA27043030C496819, 0x00003FFF, 0x9F490BF6, 0x00000000
   data8 0xA43515AE09E6809E, 0x00003FFF, 0x1DD1DB48, 0x00000000
   data8 0xA5FED6A9B15138EA, 0x00003FFF, 0x1E65EBFB, 0x00000000
   data8 0xA7CD93B4E965356A, 0x00003FFF, 0x9F427496, 0x00000000
   data8 0xA9A15AB4EA7C0EF8, 0x00003FFF, 0x1F283C4A, 0x00000000
   data8 0xAB7A39B5A93ED337, 0x00003FFF, 0x1F4B0047, 0x00000000
   data8 0xAD583EEA42A14AC6, 0x00003FFF, 0x1F130152, 0x00000000
   data8 0xAF3B78AD690A4375, 0x00003FFF, 0x9E8367C0, 0x00000000
   data8 0xB123F581D2AC2590, 0x00003FFF, 0x9F705F90, 0x00000000
   data8 0xB311C412A9112489, 0x00003FFF, 0x1EFB3C53, 0x00000000
   data8 0xB504F333F9DE6484, 0x00003FFF, 0x1F32FB13, 0x00000000

.align 32
.global cosh#

.section .text
.proc  cosh#
.align 32

cosh: 

// X NAN?

{ .mfi
      alloc r32 = ar.pfs,0,12,4,0                  
(p0)  fclass.m.unc  p6,p7 = f8, 0xc3	//@snan | @qnan 
      nop.i 999
}
;;


{ .mfb
      nop.m 999
(p6)  fma.d.s0   f8 = f8,f1,f8                  
(p6)  br.ret.spnt     b0 ;;                          
}


// X infinity 
{ .mfi
      nop.m 999
(p0)  fclass.m.unc  p6,p0 = f8, 0x23	//@inf 
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
(p6)     fmerge.s      f8 = f0,f8                  
(p6)  br.ret.spnt     b0 ;;                          
}



// Put 0.25 in f9; p6 true if x < 0.25
{ .mlx
         nop.m 999
(p0)     movl            r32 = 0x000000000000fffd ;;         
}

{ .mfi
(p0)  setf.exp        f9 = r32                         
      nop.f 999
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fmerge.s      cosh_FR_X    = f0,f8                
      nop.i 999
}

{ .mfi
      nop.m 999
(p0)  fmerge.s      cosh_FR_SGNX = f8,f1                
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fcmp.lt.unc     p0,p7 = cosh_FR_X,f9                    
      nop.i 999 ;;
}

{ .mib
      nop.m 999
      nop.i 999
(p7)  br.cond.sptk    COSH_BY_TBL 
}
;;


// COSH_BY_POLY: 
// POLY cannot overflow so there is no need to call __libm_error_support
// Get the values of P_x from the table

{ .mmi
      nop.m 999
(p0)  addl           r34   = @ltoff(double_cosh_p_table), gp
      nop.i 999
}
;;

{ .mmi
      ld8 r34 = [r34]
      nop.m 999
      nop.i 999
}
;;


// Calculate cosh_FR_X2 = ax*ax and cosh_FR_X4 = ax*ax*ax*ax
{ .mmf
         nop.m 999
(p0)     ldfe       cosh_FR_P1 = [r34],16                 
(p0)     fma.s1     cosh_FR_X2 = cosh_FR_X, cosh_FR_X, f0 ;;           
}

{ .mmi
(p0)     ldfe       cosh_FR_P2 = [r34],16 ;;                 
(p0)     ldfe       cosh_FR_P3 = [r34],16                 
         nop.i 999 ;;
}

{ .mmi
(p0)     ldfe       cosh_FR_P4 = [r34],16 ;;                 
(p0)     ldfe       cosh_FR_P5 = [r34],16                 
         nop.i 999 ;;
}

{ .mfi
(p0)     ldfe       cosh_FR_P6 = [r34],16                 
(p0)     fma.s1     cosh_FR_X4 = cosh_FR_X2, cosh_FR_X2, f0         
         nop.i 999 ;;
}

// Calculate cosh_FR_podd = x4 *(x4 * P_5 + P_3) + P_1
{ .mfi
         nop.m 999
(p0)     fma.s1     cosh_FR_poly_podd_temp1 = cosh_FR_X4, cosh_FR_P5, cosh_FR_P3                
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fma.s1     cosh_FR_podd            = cosh_FR_X4, cosh_FR_poly_podd_temp1, cosh_FR_P1   
         nop.i 999
}

// Calculate cosh_FR_peven =  p_even = x4 *(x4 * (x4 * P_6 + P_4) + P_2)
{ .mfi
         nop.m 999
(p0)     fma.s1     cosh_FR_poly_peven_temp1 = cosh_FR_X4, cosh_FR_P6, cosh_FR_P4               
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fma.s1     cosh_FR_poly_peven_temp2 = cosh_FR_X4, cosh_FR_poly_peven_temp1, cosh_FR_P2 
         nop.i 999 ;;
}

{ .mfi
         nop.m 999
(p0)     fma.s1     cosh_FR_peven       = cosh_FR_X4, cosh_FR_poly_peven_temp2, f0         
         nop.i 999 ;;
}

// Y_lo = x2*p_odd + p_even
// Calculate f8 = Y_hi + Y_lo 
{ .mfi
         nop.m 999
(p0)     fma.s1     cosh_FR_Y_lo         = cosh_FR_X2, cosh_FR_podd,  cosh_FR_peven    
         nop.i 999 ;;
}

{ .mfb
         nop.m 999
(p0)     fma.d.s0   f8                   = f1, f1, cosh_FR_Y_lo                        
(p0)  br.ret.sptk     b0 ;;                          
}


COSH_BY_TBL: 

// Now that we are at TBL; so far all we know is that |x| >= 0.25.
// The first two steps are the same for TBL and EXP, but if we are HUGE
// Double
// Go to HUGE if |x| >= 2^10, 10009 (register-biased) is e = 10 (true)
// Single
// Go to HUGE if |x| >= 2^7,  10006 (register-biased) is e =  7 (true)
// we want to leave now. Go to HUGE if |x| >= 2^14
// 1000d (register-biased) is e = 14 (true)

{ .mlx
      nop.m 999
(p0)     movl            r32 = 0x0000000000010009 ;;              
}

{ .mfi
(p0)     setf.exp        f9 = r32                              
      nop.f 999
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)     fcmp.ge.unc     p6,p7 = cosh_FR_X,f9                  
      nop.i 999 ;;
}

{ .mib
      nop.m 999
      nop.i 999
(p6)     br.cond.spnt    COSH_HUGE ;;                             
}

// r32 = 1
// r34 = N-1 
// r35 = N
// r36 = j
// r37 = N+1

// TBL can never overflow
// cosh(x) = cosh(B+R)
//         = cosh(B) cosh(R) + sinh(B) sinh(R) 
// cosh(R) can be approximated by 1 + p_even
// sinh(R) can be approximated by p_odd

// ******************************************************
// STEP 1 (TBL and EXP)
// ******************************************************
// Get the following constants.
// f9  = Inv_log2by64
// f10 = log2by64_hi
// f11 = log2by64_lo

{ .mmi
(p0)     adds                 r32 = 0x1,r0      
(p0)     addl           r34   = @ltoff(double_cosh_arg_reduction), gp
         nop.i 999
}
;;

// We want 2^(N-1) and 2^(-N-1). So bias N-1 and -N-1 and
// put them in an exponent.
// cosh_FR_spos = 2^(N-1) and cosh_FR_sneg = 2^(-N-1)
// r39 = 0xffff + (N-1)  = 0xffff +N -1
// r40 = 0xffff - (N +1) = 0xffff -N -1

{ .mlx
         ld8 r34 = [r34]
(p0)     movl                r38 = 0x000000000000fffe ;; 
}

{ .mmi
(p0)     ldfe            cosh_FR_Inv_log2by64 = [r34],16 ;;            
(p0)     ldfe            cosh_FR_log2by64_hi  = [r34],16            
         nop.i 999 ;;
}

{ .mbb
(p0)     ldfe            cosh_FR_log2by64_lo  = [r34],16            
         nop.b 999
         nop.b 999 ;;
}

// Get the A coefficients
// f9  = A_1
// f10 = A_2
// f11 = A_3

{ .mmi
      nop.m 999
(p0)  addl           r34   = @ltoff(double_cosh_ab_table), gp
      nop.i 999
}
;;

{ .mmi
      ld8 r34 = [r34]
      nop.m 999
      nop.i 999
}
;;


// Calculate M and keep it as integer and floating point.
// M = round-to-integer(x*Inv_log2by64)
// cosh_FR_M = M = truncate(ax/(log2/64))
// Put the significand of M in r35
//    and the floating point representation of M in cosh_FR_M

{ .mfi
      nop.m 999
(p0)  fma.s1          cosh_FR_M      = cosh_FR_X, cosh_FR_Inv_log2by64, f0 
      nop.i 999
}

{ .mfi
(p0)  ldfe            cosh_FR_A1 = [r34],16            
      nop.f 999
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fcvt.fx.s1      cosh_FR_M_temp = cosh_FR_M                      
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fnorm.s1        cosh_FR_M      = cosh_FR_M_temp                 
      nop.i 999 ;;
}

{ .mfi
(p0)  getf.sig        r35       = cosh_FR_M_temp                 
      nop.f 999
      nop.i 999 ;;
}

// M is still in r35. Calculate j. j is the signed extension of the six lsb of M. It
// has a range of -32 thru 31.
// r35 = M
// r36 = j 
{ .mii
      nop.m 999
      nop.i 999 ;;
(p0)  and            r36 = 0x3f, r35 ;;   
}

// Calculate R
// f13 = f44 - f12*f10 = x - M*log2by64_hi
// f14 = f13 - f8*f11 = R = (x - M*log2by64_hi) - M*log2by64_lo

{ .mfi
      nop.m 999
(p0)  fnma.s1        cosh_FR_R_temp = cosh_FR_M, cosh_FR_log2by64_hi, cosh_FR_X      
      nop.i 999
}

{ .mfi
(p0)  ldfe            cosh_FR_A2 = [r34],16            
      nop.f 999
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fnma.s1        cosh_FR_R      = cosh_FR_M, cosh_FR_log2by64_lo, cosh_FR_R_temp 
      nop.i 999
}

// Get the B coefficients
// f15 = B_1
// f32 = B_2
// f33 = B_3

{ .mmi
(p0)     ldfe            cosh_FR_A3 = [r34],16 ;;            
(p0)     ldfe            cosh_FR_B1 = [r34],16            
         nop.i 999 ;;
}

{ .mmi
(p0)     ldfe            cosh_FR_B2 = [r34],16 ;;            
(p0)     ldfe            cosh_FR_B3 = [r34],16            
         nop.i 999 ;;
}

{ .mii
         nop.m 999
(p0)     shl            r34 = r36,  0x2 ;;   
(p0)     sxt1           r37 = r34 ;;         
}

// ******************************************************
// STEP 2 (TBL and EXP)
// ******************************************************
// Calculate Rsquared and Rcubed in preparation for p_even and p_odd
// f12 = R*R*R
// f13 = R*R
// f14 = R <== from above

{ .mfi
      nop.m 999
(p0)     fma.s1          cosh_FR_Rsq  = cosh_FR_R,   cosh_FR_R, f0  
(p0)     shr            r36 = r37,  0x2 ;;   
}

// r34 = M-j = r35 - r36
// r35 = N = (M-j)/64

{ .mii
(p0)     sub                  r34 = r35, r36    
         nop.i 999 ;;
(p0)     shr                  r35 = r34, 0x6 ;;    
}

{ .mii
(p0)     sub                 r40 = r38, r35           
(p0)     adds                 r37 = 0x1, r35    
(p0)     add                 r39 = r38, r35 ;;           
}

// Get the address of the J table, add the offset,
// addresses are sinh_AD_mJ and sinh_AD_J, get the T value
// f32 = T(j)_hi
// f33 = T(j)_lo
// f34 = T(-j)_hi
// f35 = T(-j)_lo

{ .mmi
(p0)     sub                  r34 = r35, r32    
(p0)     addl    r37   = @ltoff(double_cosh_j_table), gp
         nop.i 999
}
;;

{ .mfi
      ld8 r37 = [r37]
(p0)  fma.s1          cosh_FR_Rcub = cosh_FR_Rsq, cosh_FR_R, f0  
      nop.i 999
}

// ******************************************************
// STEP 3 Now decide if we need to branch to EXP
// ******************************************************
// Put 32 in f9; p6 true if x < 32

{ .mlx
         nop.m 999
(p0)     movl                r32 = 0x0000000000010004 ;;               
}

// Calculate p_even
// f34 = B_2 + Rsq *B_3
// f35 = B_1 + Rsq*f34      = B_1 + Rsq * (B_2 + Rsq *B_3)
// f36 = peven = Rsq * f35 = Rsq * (B_1 + Rsq * (B_2 + Rsq *B_3))

{ .mfi
      nop.m 999
(p0)  fma.s1          cosh_FR_peven_temp1 = cosh_FR_Rsq, cosh_FR_B3,          cosh_FR_B2  
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fma.s1          cosh_FR_peven_temp2 = cosh_FR_Rsq, cosh_FR_peven_temp1, cosh_FR_B1  
      nop.i 999
}

// Calculate p_odd
// f34 = A_2 + Rsq *A_3
// f35 = A_1 + Rsq * (A_2 + Rsq *A_3)
// f37 = podd = R + Rcub * (A_1 + Rsq * (A_2 + Rsq *A_3))

{ .mfi
      nop.m 999
(p0)  fma.s1          cosh_FR_podd_temp1 = cosh_FR_Rsq,        cosh_FR_A3,         cosh_FR_A2  
      nop.i 999 ;;
}

{ .mfi
(p0)  setf.exp            cosh_FR_N_temp1 = r39            
      nop.f 999
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fma.s1          cosh_FR_peven       = cosh_FR_Rsq, cosh_FR_peven_temp2, f0     
      nop.i 999
}

{ .mfi
      nop.m 999
(p0)  fma.s1          cosh_FR_podd_temp2 = cosh_FR_Rsq,        cosh_FR_podd_temp1, cosh_FR_A1  
      nop.i 999 ;;
}

{ .mfi
(p0)  setf.exp            f9  = r32                              
      nop.f 999
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fma.s1          cosh_FR_podd       = cosh_FR_podd_temp2, cosh_FR_Rcub,       cosh_FR_R   
      nop.i 999
}

// sinh_GR_mj contains the table offset for -j
// sinh_GR_j  contains the table offset for +j
// p6 is true when j <= 0

{ .mlx
(p0)     setf.exp            cosh_FR_N_temp2 = r40            
(p0)     movl                r40 = 0x0000000000000020 ;;    
}

{ .mfi
(p0)     sub                 GR_mJ = r40,  r36           
(p0)     fmerge.se           cosh_FR_spos    = cosh_FR_N_temp1, f1 
(p0)     adds                GR_J  = 0x20, r36 ;;           
}

{ .mii
         nop.m 999
(p0)     shl                  GR_mJ = GR_mJ, 5 ;;   
(p0)     add                  AD_mJ = r37, GR_mJ ;; 
}

{ .mmi
         nop.m 999
(p0)     ldfe                 cosh_FR_Tmjhi = [AD_mJ],16                 
(p0)     shl                  GR_J  = GR_J, 5 ;;    
}

{ .mfi
(p0)     ldfs                 cosh_FR_Tmjlo = [AD_mJ],16                 
(p0)     fcmp.lt.unc.s1      p6,p7 = cosh_FR_X,f9                          
(p0)     add                  AD_J  = r37, GR_J ;;  
}

{ .mmi
(p0)     ldfe                 cosh_FR_Tjhi  = [AD_J],16 ;;                  
(p0)     ldfs                 cosh_FR_Tjlo  = [AD_J],16                  
         nop.i 999 ;;
}

{ .mfb
         nop.m 999
(p0)     fmerge.se           cosh_FR_sneg    = cosh_FR_N_temp2, f1 
(p7)     br.cond.spnt        COSH_BY_EXP ;;                            
}

// ******************************************************
// If NOT branch to EXP
// ******************************************************
// Calculate C_hi
// ******************************************************
// cosh_FR_C_hi_temp = cosh_FR_sneg * cosh_FR_Tmjhi
// cosh_FR_C_hi = cosh_FR_spos * cosh_FR_Tjhi + (cosh_FR_sneg * cosh_FR_Tmjhi)

{ .mfi
      nop.m 999
(p0)  fma.s1         cosh_FR_C_hi_temp = cosh_FR_sneg, cosh_FR_Tmjhi, f0                   
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fma.s1         cosh_FR_C_hi      = cosh_FR_spos, cosh_FR_Tjhi,  cosh_FR_C_hi_temp    
      nop.i 999
}

// ******************************************************
// Calculate S_hi
// ******************************************************
// cosh_FR_S_hi_temp1 = cosh_FR_sneg * cosh_FR_Tmjhi
// cosh_FR_S_hi = cosh_FR_spos * cosh_FR_Tjhi - cosh_FR_C_hi_temp1

{ .mfi
      nop.m 999
(p0)  fma.s1        cosh_FR_S_hi_temp1 =  cosh_FR_sneg, cosh_FR_Tmjhi, f0                
      nop.i 999 ;;
}

// ******************************************************
// Calculate C_lo
// ******************************************************
// cosh_FR_C_lo_temp1 = cosh_FR_spos * cosh_FR_Tjhi - cosh_FR_C_hi
// cosh_FR_C_lo_temp2 = cosh_FR_sneg * cosh_FR_Tmjlo + (cosh_FR_spos * cosh_FR_Tjhi - cosh_FR_C_hi)
// cosh_FR_C_lo_temp1 = cosh_FR_sneg * cosh_FR_Tmjlo
// cosh_FR_C_lo_temp3 = cosh_FR_spos * cosh_FR_Tjlo + (cosh_FR_sneg * cosh_FR_Tmjlo)
// cosh_FR_C_lo = cosh_FR_C_lo_temp3 + cosh_FR_C_lo_temp2

{ .mfi
      nop.m 999
(p0)  fms.s1        cosh_FR_C_lo_temp1 = cosh_FR_spos, cosh_FR_Tjhi,  cosh_FR_C_hi        
      nop.i 999
}

{ .mfi
      nop.m 999
(p0)  fms.s1        cosh_FR_S_hi       =  cosh_FR_spos, cosh_FR_Tjhi, cosh_FR_S_hi_temp1 
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fma.s1        cosh_FR_C_lo_temp2 = cosh_FR_sneg, cosh_FR_Tmjhi, cosh_FR_C_lo_temp1  
      nop.i 999
}

{ .mfi
      nop.m 999
(p0)  fma.s1        cosh_FR_C_lo_temp1 = cosh_FR_sneg, cosh_FR_Tmjlo, f0                  
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fma.s1        cosh_FR_C_lo_temp3 =  cosh_FR_spos, cosh_FR_Tjlo,  cosh_FR_C_lo_temp1 
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fma.s1        cosh_FR_C_lo       =  cosh_FR_C_lo_temp3, f1,   cosh_FR_C_lo_temp2    
      nop.i 999 ;;
}

// ******************************************************
// cosh_FR_Y_lo_temp = cosh_FR_C_hi * cosh_FR_peven + cosh_FR_C_lo
// cosh_FR_Y_lo = cosh_FR_S_hi * cosh_FR_podd + cosh_FR_Y_lo_temp
// cosh_FR_COSH = Y_hi + Y_lo

{ .mfi
      nop.m 999
(p0)  fma.s1         cosh_FR_Y_lo_temp =  cosh_FR_C_hi, cosh_FR_peven, cosh_FR_C_lo       
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fma.s1         cosh_FR_Y_lo      =  cosh_FR_S_hi, cosh_FR_podd, cosh_FR_Y_lo_temp   
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
(p0)  fma.d.s0       f8 =  cosh_FR_C_hi, f1, cosh_FR_Y_lo                       
(p0)  br.ret.sptk     b0 ;;                          
}

COSH_BY_EXP: 

// When p7 is true,  we know that an overflow is not going to happen
// When p7 is false, we must check for possible overflow
// p7 is the over_SAFE flag
// f44 = Scale * (Y_hi + Y_lo)
//     =  cosh_FR_spos * (cosh_FR_Tjhi + cosh_FR_Y_lo)

{ .mfi
      nop.m 999
(p0)  fma.s1         cosh_FR_Y_lo_temp =  cosh_FR_peven, f1,       cosh_FR_podd           
      nop.i 999
}

// Now we are in EXP. This is the only path where an overflow is possible
// but not for certain. So this is the only path where over_SAFE has any use.
// r34 still has N-1
// There is a danger of double-extended overflow   if N-1 > 16382 = 0x3ffe
// There is a danger of double overflow            if N-1 > 0x3fe = 1022

{ .mlx
       nop.m 999
(p0)   movl                r32          = 0x00000000000003fe ;;                       
}

{ .mfi
(p0)  cmp.gt.unc          p0,p7        = r34, r32                                 
      nop.f 999
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fma.s1         cosh_FR_Y_lo      =  cosh_FR_Tjhi,  cosh_FR_Y_lo_temp, cosh_FR_Tjlo       
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fma.s1         cosh_FR_COSH_temp =  cosh_FR_Y_lo,  f1, cosh_FR_Tjhi                 
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fma.d.s0       f44 = cosh_FR_spos,  cosh_FR_COSH_temp, f0                       
      nop.i 999 ;;
}

// If over_SAFE is set, return
{ .mfb
       nop.m 999
(p7)   fmerge.s            f8 = f44,f44
(p7)  br.ret.sptk     b0 ;;                          
}

// Else see if we overflowed
// S0 user supplied status
// S2 user supplied status + WRE + TD  (Overflows)
// If WRE is set then an overflow will not occur in EXP.
// The input value that would cause a register (WRE) value to overflow is about 2^15
// and this input would go into the HUGE path.
// Answer with WRE is in f43.

{ .mfi
      nop.m 999
(p0)  fsetc.s2            0x7F,0x42                                               
      nop.i 999;;
}

{ .mfi
      nop.m 999
(p0)  fma.d.s2            f43  = cosh_FR_spos,  cosh_FR_COSH_temp, f0                      
      nop.i 999 ;;
}

// 103FF => 103FF -FFFF = 400(true)
// 400 + 3FF = 7FF, which is 1 more that the exponent of the largest
// double (7FE). So 0 103FF 8000000000000000  is one ulp more than
// largest double in register bias
// Now  set p8 if the answer with WRE is greater than or equal this value
// Also set p9 if the answer with WRE is less than or equal to negative this value

{ .mlx
       nop.m 999
(p0)   movl                r32          = 0x00000000000103ff ;;                     
}

{ .mmf
       nop.m 999
(p0)   setf.exp            f41          = r32                                    
(p0)   fsetc.s2            0x7F,0x40 ;;                                               
}

{ .mfi
      nop.m 999
(p0)  fcmp.ge.unc.s1      p8, p0       = f43, f41                               
      nop.i 999
}

{ .mfi
      nop.m 999
(p0)  fmerge.ns           f42 = f41, f41                                          
      nop.i 999 ;;
}

// The error tag for overflow is 64
{ .mii
      nop.m 999
      nop.i 999 ;;
(p8)  mov                 r47 = 64 ;;                                               
}

{ .mfb
      nop.m 999
(p0)  fcmp.le.unc.s1      p9, p0 =  f43, f42                                      
(p8)  br.cond.spnt __libm_error_region ;;
}

{ .mii
      nop.m 999
      nop.i 999 ;;
(p9)  mov                 r47 = 64                                               
}

{ .mib
      nop.m 999
      nop.i 999
(p9)  br.cond.spnt __libm_error_region ;;
}

{ .mfb
      nop.m 999
(p0)  fmerge.s            f8 = f44,f44                                            
(p0)  br.ret.sptk     b0 ;;                          
}


// for COSH_HUGE, put 24000 in exponent; take sign from input; add 1
// SAFE: SAFE is always 0 for HUGE

COSH_HUGE: 

{ .mlx
      nop.m 999
(p0)  movl                r32 = 0x0000000000015dbf ;;                                
}

{ .mfi
(p0)  setf.exp            f9  = r32                                               
      nop.f 999
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fma.s1              cosh_FR_hi_lo = f1, f9, f1                              
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fma.d.s0            f44 = f9, cosh_FR_hi_lo, f0                             
(p0)  mov                 r47 = 64                                               
}
;;

.endp cosh#

// Stack operations when calling error support.
//       (1)               (2)                          (3) (call)              (4)
//   sp   -> +          psp -> +                     psp -> +                   sp -> +
//           |                 |                            |                         |
//           |                 | <- GR_Y               R3 ->| <- GR_RESULT            | -> f8
//           |                 |                            |                         |
//           | <-GR_Y      Y2->|                       Y2 ->| <- GR_Y                 |
//           |                 |                            |                         |
//           |                 | <- GR_X               X1 ->|                         |
//           |                 |                            |                         |
//  sp-64 -> +          sp ->  +                     sp ->  +                         +
//    save ar.pfs          save b0                                               restore gp
//    save gp                                                                    restore ar.pfs

.proc __libm_error_region
__libm_error_region:
.prologue
// (1)
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                          // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                      // Save gp
};;


// (2)
{ .mmi
        stfd [GR_Parameter_Y] = f0,16         // STORE Parameter 2 on stack
        add GR_Parameter_X = 16,sp            // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                     // Save b0
};;

.body
// (3)
{ .mib
        stfd [GR_Parameter_X] = f8                    // STORE Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y  // Parameter 3 address
        nop.b 0                                 
}
{ .mib
        stfd [GR_Parameter_Y] = f44                   // STORE Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#         // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

// (4)
{ .mmi
        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region

.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\fabs.s ===
.file "fabs.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version 
//
// API
//==============================================================
// double fabs  (double x)
//
// Overview of operation
//==============================================================
// returns absolute value of x 

// floating-point registers used: 1
// f8, input

.align 32
.global fabs#

.section .text
.proc  fabs#
.align 32



fabs: 

// set invalid or denormal flags and take fault if
// necessary

{ .mfi
      nop.m 999
      fcmp.eq.unc.s0 p6,p7 = f8,f1             
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
      fmerge.s       f8 = f0,f8                   
(p0)  br.ret.sptk    b0 ;;                        
}

.endp fabs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\ceilf.s ===
.file "ceilf.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
.align 32
.global ceilf#

.section .text
.proc  ceilf#
.align 32

// History
//==============================================================
// 2/02/00: Initial version
// 6/13/00: Improved speed
// 6/27/00: Eliminated incorrect invalid flag setting

// API
//==============================================================
// float ceilf(float x)

// general input registers:  

ceil_GR_FFFF      = r14
ceil_GR_signexp   = r15
ceil_GR_exponent  = r16
ceil_GR_expmask   = r17
ceil_GR_bigexp    = r18


// predicate registers used: 

// p6  ==> Input is NaN, infinity, zero
// p7  ==> Input is denormal
// p8  ==> Input is <0
// p9  ==> Input is >=0
// p10 ==> Input is already an integer (bigger than largest integer)
// p11 ==> Input is not a large integer
// p12 ==> Input is a smaller integer
// p13 ==> Input is not an even integer, so inexact must be set
// p14 ==> Input is between -1 and 0, so result will be -0 and inexact


// floating-point registers used: 

CEIL_SIGNED_ZERO  = f7
CEIL_NORM_f8      = f9                        
CEIL_FFFF         = f10 
CEIL_INEXACT      = f11 
CEIL_FLOAT_INT_f8 = f12
CEIL_INT_f8       = f13
CEIL_adj          = f14
CEIL_MINUS_ONE    = f15

// Overview of operation
//==============================================================

// float ceilf(float x)
// Return an integer value (represented as a float) that is the smallest 
// value not less than x
// This is x rounded toward +infinity to an integral value.
// Inexact is set if x != ceilf(x)
// **************************************************************************

// Set denormal flag for denormal input and
// and take denormal fault if necessary.

// Is the input an integer value already?

// double_extended
// if the exponent is > 1003e => 3F(true) = 63(decimal)
// we have a significand of 64 bits 1.63-bits.
// If we multiply by 2^63, we no longer have a fractional part
// So input is an integer value already.

// double
// if the exponent is >= 10033 => 34(true) = 52(decimal)
// 34 + 3ff = 433
// we have a significand of 53 bits 1.52-bits. (implicit 1)
// If we multiply by 2^52, we no longer have a fractional part
// So input is an integer value already.

// single
// if the exponent is > 10016 => 17(true) = 23(decimal)
// we have a significand of 24 bits 1.23-bits. (implicit 1)
// If we multiply by 2^23, we no longer have a fractional part
// So input is an integer value already.

// If x is NAN, ZERO, or INFINITY, then  return

// qnan snan inf norm     unorm 0 -+
// 1    1    1   0        0     1 11     0xe7


ceilf:

{ .mfi
      getf.exp ceil_GR_signexp  = f8
      fcvt.fx.trunc.s1     CEIL_INT_f8  = f8
      addl        ceil_GR_bigexp = 0x10016, r0
}
{ .mfi
      addl        ceil_GR_FFFF      = -1,r0
      fcmp.lt.s1  p8,p9 = f8,f0
      mov         ceil_GR_expmask    = 0x1FFFF ;;
}

// p7 ==> denorm
{ .mfi
      setf.sig    CEIL_FFFF  = ceil_GR_FFFF
      fclass.m    p7,p0 = f8, 0x0b
      nop.i 999
}
{ .mfi
      nop.m 999
      fnorm           CEIL_NORM_f8  = f8
      nop.i 999 ;;
}

// Form 0 with sign of input in case negative zero is needed
{ .mfi
      nop.m 999
      fmerge.s           CEIL_SIGNED_ZERO = f8, f0
      nop.i 999
}
{ .mfi
      nop.m 999
      fsub.s1           CEIL_MINUS_ONE = f0, f1
      nop.i 999 ;;
}

// p6 ==> NAN, INF, ZERO
{ .mfb
      nop.m 999
      fclass.m      p6,p10 = f8, 0xe7
(p7)  br.cond.spnt  CEIL_DENORM ;;
}

.pred.rel "mutex",p8,p9
CEIL_COMMON:
// Set adjustment to add to trunc(x) for result
//   If x>0,  adjustment is 1.0
//   If x<=0, adjustment is 0.0
{ .mfi
      and      ceil_GR_exponent = ceil_GR_signexp, ceil_GR_expmask
(p9)  fadd.s1  CEIL_adj = f1,f0
      nop.i 999
}
{ .mfi
      nop.m 999
(p8)  fadd.s1  CEIL_adj = f0,f0
      nop.i 999 ;;
}

{ .mfi
(p10) cmp.ge.unc    p10,p11 = ceil_GR_exponent, ceil_GR_bigexp
(p6)  fnorm.s f8 = f8
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p11) fcvt.xf         CEIL_FLOAT_INT_f8   = CEIL_INT_f8
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10) fnorm.s f8 = CEIL_NORM_f8
      nop.i 999 ;;
}

// Is -1 < x < 0?  If so, result will be -0.  Special case it with p14 set.
{ .mfi
      nop.m 999
(p8)  fcmp.gt.unc.s1 p14,p0 = CEIL_NORM_f8, CEIL_MINUS_ONE
      nop.i 999 ;;
}

{ .mfi
(p14) cmp.ne  p11,p0 = r0,r0
(p14) fnorm.s f8 = CEIL_SIGNED_ZERO
      nop.i 999
}
{ .mfi
      nop.m 999
(p14) fmpy.s0     CEIL_INEXACT = CEIL_FFFF,CEIL_FFFF
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p11) fadd.s   f8 = CEIL_FLOAT_INT_f8,CEIL_adj
      nop.i 999 ;;
}
{ .mfi
      nop.m 999
(p11) fcmp.eq.unc.s1  p12,p13  = CEIL_FLOAT_INT_f8, CEIL_NORM_f8
      nop.i 999 ;;
}

// Set inexact if result not equal to input
{ .mfi
      nop.m 999
(p13) fmpy.s0     CEIL_INEXACT = CEIL_FFFF,CEIL_FFFF
      nop.i 999
}
// Set result to input if integer
{ .mfb
      nop.m 999
(p12) fnorm.s f8 = CEIL_NORM_f8
      br.ret.sptk    b0 ;;
}

// Here if input denorm
CEIL_DENORM:
{ .mfb
      getf.exp ceil_GR_signexp  = CEIL_NORM_f8
      fcvt.fx.trunc.s1     CEIL_INT_f8  = CEIL_NORM_f8
      br.cond.sptk  CEIL_COMMON ;;
}

.endp ceilf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\filter.c ===
//#########################################################################
//**
//**  Copyright  (C) 1996-2000 Intel Corporation. All rights reserved. 
//**
//** The information and source code contained herein is the exclusive 
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization 
//** from the company.
//**
//###########################################################################

//#define FPIEEE_FLT_DEBUG


/*****************************************************************************
 *  fpieee_flt.c - FP IEEE exception filter routine
 *
 *
 *  History:
 *    Marius Cornea 09/07/00
 *    marius.cornea@intel.com
 *
 *****************************************************************************/

#include "fpieee_flt.h"

/* the following two will be [re-]written (by Bernard Lint ?) */
static _FP128
GetFloatRegisterValue (unsigned int f, PCONTEXT Context);

static void
SetFloatRegisterValue (unsigned int f, _FP128 Value, PCONTEXT Context);

// Note: the I32* and U32* functions are needed because of the _I32 and _U32
// types in fpieee.h, different from the unsigned long used in _FP128

static _FP128 FPIeeeToFP128 (_FPIEEE_RECORD *);
static _FP128 FP32ToFP128 (_FP32);
static _FP128 FP32ToFP128modif (_FP32, int);
static void FP128ToFPIeee (_FPIEEE_RECORD *, int);
static _FP32 LowHalf (_FP128);
static _FP32 HighHalf (_FP128);
static int I32LowHalf (_FP128);
static int I32HighHalf (_FP128);
static unsigned int U32LowHalf (_FP128);
static unsigned int U32HighHalf (_FP128);
static _FP128 Combine (_FP32, _FP32);
static _FP128 I32Combine (int, int);
static _FP128 U32Combine (unsigned int, unsigned int);
static void UpdateRoundingMode (unsigned int, unsigned int, unsigned __int64 *,
    char *);
static void UpdatePrecision (unsigned int, unsigned int, unsigned __int64 *, char *);

/*
 *
 * _fpieee_flt () - IEEE FP filter routine
 *
 * Description:
 *   invokes the user trap handler for IEEE fp exceptions (P,U,O,Z,I) that are 
 *   enabled, providing it with the necessary information in an FPIEEE_RECORD
 *   data structure
 *
 *
 * Input parameters:
 *   unsigned __int64 eXceptionCode: the NT exception code
 *   PEXCEPTION_POINTERS p: a pointer to the NT EXCEPTION_POINTERS struct
 *   int handler (_FPIEEE_RECORD *): the user supplied ieee trap handler
 *
 *
 * Return value:
 *   returns the value returned by the user handler
 *
 */

int _fpieee_flt (unsigned long eXceptionCode,
                PEXCEPTION_POINTERS p,
                int (*handler)(_FPIEEE_RECORD *))

{

  PEXCEPTION_RECORD ExceptionRecord;
  PCONTEXT Context;
  unsigned __int64 *ExceptionInformation;
  char *ExceptionAddress;
  _FPIEEE_RECORD FpieeeRecord;
  int handler_return_value;
  unsigned int PR, PR1, PR2;
  unsigned __int64 BundleHigh;
  unsigned __int64 BundleLow;
  unsigned int ISRhigh;
  unsigned int ISRlow;
  unsigned int ei;
  unsigned int I_dis;
  unsigned int U_dis;
  unsigned int O_dis;
  unsigned int Z_dis;
  unsigned int D_dis;
  unsigned int V_dis;
  unsigned __int64 OpCode;
  unsigned __int64 FPSR;
  unsigned __int64 CFM;
  unsigned int rrbpr;
  unsigned int rrbfr;

  /* arguments to emulation functions */
  unsigned int sf;
  unsigned int qp;
  unsigned int f1;
  unsigned int f2;
  unsigned int f3;
  unsigned int f4;
  unsigned int p1;
  unsigned int p2;

  unsigned int pc;
  unsigned int rc;
  unsigned int wre;

  _FP128 FR1;
  _FP128 FR2;
  _FP128 FR3;
  _FP128 FR4;

  unsigned int EnableDenormal;
  unsigned int StatusDenormal;
  unsigned int CauseDenormal;

  unsigned int Operation;
  unsigned int Precision;
  unsigned int RoundingMode;
  unsigned int ResultFormat;

  unsigned __int64 old_fpsr;
  unsigned __int64 usr_fpsr;
  unsigned __int64 new_fpsr;

  /* for SIMD instructions */
  unsigned int SIMD_instruction;
  _FPIEEE_EXCEPTION_FLAGS LowStatus;
  _FPIEEE_EXCEPTION_FLAGS HighStatus;
  _FPIEEE_EXCEPTION_FLAGS LowCause;
  _FPIEEE_EXCEPTION_FLAGS HighCause;
  _FP128 newFR2;
  _FP128 newFR3;
  _FP128 newFR4;
  _FP32 FR1Low;
  _FP32 FR2Low;
  _FP32 FR3Low;
  _FP32 FR1High;
  _FP32 FR2High;
  _FP32 FR3High;
  unsigned int LowStatusDenormal;
  unsigned int HighStatusDenormal;
  unsigned int LowCauseDenormal;
  unsigned int HighCauseDenormal;
  int I32Low, I32High;
  unsigned int U32Low, U32High;



#ifdef FPIEEE_FLT_DEBUG
  printf ("********** FPIEEE_FLT_DEBUG **********\n");
  switch (eXceptionCode) {
    case STATUS_FLOAT_INVALID_OPERATION:
      printf ("STATUS_FLOAT_INVALID_OPERATION\n");
      break;
    case STATUS_FLOAT_DIVIDE_BY_ZERO:
      printf ("STATUS_FLOAT_DIVIDE_BY_ZERO\n");
      break;
    case STATUS_FLOAT_DENORMAL_OPERAND:
      printf ("STATUS_FLOAT_DENORMAL_OPERAND\n");
      break;
    case STATUS_FLOAT_INEXACT_RESULT:
      printf ("STATUS_FLOAT_INEXACT_RESULT\n");
      break;
    case STATUS_FLOAT_OVERFLOW:
      printf ("STATUS_FLOAT_OVERFLOW\n");
      break;
    case STATUS_FLOAT_UNDERFLOW:
      printf ("STATUS_FLOAT_UNDERFLOW\n");
      break;
    case STATUS_FLOAT_MULTIPLE_FAULTS:
      printf ("STATUS_FLOAT_MULTIPLE_FAULTS\n");
      break;
    case STATUS_FLOAT_MULTIPLE_TRAPS:
      printf ("STATUS_FLOAT_MULTIPLE_TRAPS\n");
      break;
    default:
      printf ("STATUS_FLOAT NOT IDENTIFIED\n");
      printf ("FPIEEE_FLT_DEBUG eXceptionCode = %8x\n", eXceptionCode);
      fflush (stdout);
      return (EXCEPTION_CONTINUE_SEARCH);
  }
#endif

  /* can get here only if ExceptionRecord->ExceptionCode 
   * corresponds to an IEEE exception */


  /* search for another handler if not an IEEE exception */
  if (eXceptionCode != STATUS_FLOAT_INVALID_OPERATION &&
        eXceptionCode != STATUS_FLOAT_DIVIDE_BY_ZERO &&
        eXceptionCode != STATUS_FLOAT_DENORMAL_OPERAND &&
        eXceptionCode != STATUS_FLOAT_UNDERFLOW &&
        eXceptionCode != STATUS_FLOAT_OVERFLOW &&
        eXceptionCode != STATUS_FLOAT_INEXACT_RESULT &&
        eXceptionCode != STATUS_FLOAT_MULTIPLE_FAULTS &&
        eXceptionCode != STATUS_FLOAT_MULTIPLE_TRAPS) {

        return (EXCEPTION_CONTINUE_SEARCH);

  }

  ExceptionRecord = p->ExceptionRecord;
  ExceptionInformation = ExceptionRecord->ExceptionInformation;
  Context = p->ContextRecord;

  FPSR = Context->StFPSR; // FP status register
#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG FPSR = %8x %8x\n", 
      (int)(FPSR >> 32) & 0xffffffff, (int)FPSR & 0xffffffff);
#endif

  if (ExceptionRecord->ExceptionInformation[0]) {

    /* this is a software generated exception; ExceptionInformation[0]
     * points to a data structure of type _FPIEEE_RECORD */

    // exception code should not be STATUS_FLOAT_MULTIPLE_FAULTS or
    // STATUS_FLOAT_MULTIPLE_TRAPS for a software generated exception
    if (eXceptionCode == STATUS_FLOAT_MULTIPLE_FAULTS ||
        eXceptionCode == STATUS_FLOAT_MULTIPLE_TRAPS) {
      fprintf (stderr, "IEEE Filter Internal Error: eXceptionCode \
          STATUS_FLOAT_MULTIPLE_FAULTS or STATUS_FLOAT_MULTIPLE_TRAPS \
          not supported in software generated IEEE exception\n");
      exit (1);
    }

    handler_return_value = handler((_FPIEEE_RECORD *)(ExceptionInformation[0]));

    return (handler_return_value);

  }

  /* get the instruction that caused the exception */

  ISRhigh = (unsigned int)
      ((ExceptionRecord->ExceptionInformation[4] >> 32) & 0x0ffffffff);
  ISRlow =  (unsigned int)
      (ExceptionRecord->ExceptionInformation[4] & 0x0ffffffff);
#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG ISRhigh = %x\n", ISRhigh);
  printf ("FPIEEE_FLT_DEBUG ISRlow = %x\n", ISRlow);
#endif

  /* excepting instruction in bundle: slot 0, 1, or 2 */
  ei = (ISRhigh >> 9) & 0x03;
#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG ei = %x\n", ei);
#endif

  ExceptionAddress = ExceptionRecord->ExceptionAddress;
#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG Context->StIIP = %I64x\n", Context->StIIP);
  printf ("FPIEEE_FLT_DEBUG ExceptionAddress = %I64x\n", ExceptionAddress);
#endif
  ExceptionAddress = (char *)((__int64)ExceptionAddress & 0xfffffffffffffff0);

  BundleLow = *((unsigned __int64 *)ExceptionAddress);
  BundleHigh = *(((unsigned __int64 *)ExceptionAddress) + 1);
#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG BundleLow = %8x %8x\n",
      (int)(BundleLow >> 32) & 0xffffffff, (int)BundleLow & 0xffffffff);
  printf ("FPIEEE_FLT_DEBUG BundleHigh = %8x %8x\n",
      (int)(BundleHigh >> 32) & 0xffffffff, (int)BundleHigh & 0xffffffff);
#endif

  CFM = Context->StIFS & 0x03fffffffff;
  rrbpr = (unsigned int)((CFM >> 32) & 0x3f);
  rrbfr = (unsigned int)((CFM >> 25) & 0x7f);
#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG: rrbpr = %x rrbfr = %x\n", rrbpr, rrbfr);
  printf ("FPIEEE_FLT_DEBUG: CFM = %8x %8x\n", 
      (int)(CFM >> 32) & 0xffffffff, (int)CFM & 0xffffffff);
#endif

  /* cut the faulting instruction opcode (41 bits) */
  if (ei == 0 ) { // no template for this case
    // OpCode = (BundleLow >> 5) & (unsigned __int64)0x01ffffffffff;
    fprintf (stderr, "IEEE Filter Internal Error: illegal template FXX\n");
    exit (1);
  } else if (ei == 1) { // templates: MFI, MFB
    OpCode = ((BundleHigh & (unsigned __int64)0x07fffff) << 18) |
        ((BundleLow >> 46) & (unsigned __int64)0x03ffff);
  } else if (ei == 2) { // templates: MMF
    OpCode = (BundleHigh >> 23) & (unsigned __int64)0x01ffffffffff;
  } else {
    // OpCode = 0; may need this to avoid compiler warning
    fprintf (stderr, "IEEE Filter Internal Error: instr. slot 3 is invalid\n");
    exit (1);
  }

#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG OpCode = %8x %8x\n",
      (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
#endif

  /* decode the instruction opcode; we could get here only
   * for FP instructions that caused an FP fault or trap
   */

  /* sf and qp have the same offset, for all the FP instructions */
  sf = (unsigned int)((OpCode >> 34) & (unsigned __int64)0x000000000003);

  // the floating-point exceptions must already be masked, but set the user
  // FPSR, with exceptions masked; note that they are not unmasked [again]
  // inside the IEEE handler; if execution is continued, exception masking
  // will be restored with the FPSR)

  // three different values of the FPSR are used:
  //   FPSR is the value at the time of the exception occurence; it will
  //       be modified to clear the user status flags and it will be
  //       updated to reflect changes made by the user exception handler
  //   old_fpsr is the value at the time _fpieee_flt () was invoked by
  //       the OS; it will be restored before returning from this function
  //   new_fpsr is old_fpsr with fp exceptions disabled (and status flags
  //       cleared)
  //   usr_fpsr is the value at the time of the exception occurence (just
  //       as FPSR, but without any change); it is used when re-executing
  //       the low or the high part of the excepting instruction for a
  //       SIMD instruction
  usr_fpsr = Context->StFPSR; // save for possible re-execution-FPSR may change
  __get_fpsr (&old_fpsr);
  new_fpsr = (old_fpsr | 0x3f) & ~((unsigned __int64)0x07e000 << (13 * sf));
      // user fpsr with disabled fp exceptions and clear flags
  __set_fpsr (&new_fpsr);


  /* this is a hardware generated exception; need to fill in the 
   * FPIEEE_RECORD data structure */

  /* get the qualifying predicate */
  qp = (unsigned int)(OpCode & (unsigned __int64)0x00000000003F);
  if (qp >= 16) qp = 16 + (rrbpr + qp - 16) % 48;
#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG: qp = %x\n", qp);
#endif
  /* read the rounding control and precision control from the FPSR */
  rc = (unsigned int)((FPSR >> (6 + 4 + 13 * sf)) & 0x03);
#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG: rc = %x\n", rc);
#endif
  pc = (unsigned int)((FPSR >> (6 + 2 + 13 * sf)) & 0x03);
#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG: pc = %x\n", pc);
#endif
  wre = (unsigned int)((FPSR >> (6 + 1 + 13 * sf)) & 0x01);
#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG: wre = %x\n", wre);
#endif

  /* read predicate register qp */
  PR = (unsigned int)((Context->Preds >> qp) & 0x01);
#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG: PR = %x\n", PR);
#endif

  if (PR == 0) {
    fprintf (stderr, "IEEE Filter Internal Error: qualifying \
        predicate PR[%2.2x] = 0\n", qp);
     exit (1);
  }

  /* fill in the rounding mode */
  switch (rc) {

    case rc_rn:
      RoundingMode = FpieeeRecord.RoundingMode = _FpRoundNearest;
      break;
    case rc_rm:
      RoundingMode = FpieeeRecord.RoundingMode = _FpRoundMinusInfinity;
      break;
    case rc_rp:
      RoundingMode = FpieeeRecord.RoundingMode = _FpRoundPlusInfinity;
      break;
    case rc_rz:
      RoundingMode = FpieeeRecord.RoundingMode = _FpRoundChopped;
      break;

  }

  /* fill in the precision mode */
  switch (pc) {

    case sf_single:
      Precision = FpieeeRecord.Precision = _FpPrecision24;
      break;

    case sf_double:
      Precision = FpieeeRecord.Precision = _FpPrecision53;
      break;

    case sf_double_extended:
      Precision = FpieeeRecord.Precision = _FpPrecision64;
      break;

    default:
      fprintf (stderr, "IEEE Filter Internal Error: pc = %x is invalid\n", pc);
      exit (1);

  }

  /* decode the fp environment information further more */

  /* I_dis = (sf != 0 && td == 1) || id == 1
   * U_dis = (sf != 0 && td == 1) || ud == 1
   * ... */
  I_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) ||
      ((FPSR >> 5) & 0x01);
  U_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) ||
      ((FPSR >> 4) & 0x01);
  O_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) ||
      ((FPSR >> 3) & 0x01);
  Z_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) ||
      ((FPSR >> 2) & 0x01);
  D_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) ||
      ((FPSR >> 1) & 0x01);
  V_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) ||
      ((FPSR >> 0) & 0x01);

#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG: I_dis = %x\n", I_dis);
  printf ("FPIEEE_FLT_DEBUG: U_dis = %x\n", U_dis);
  printf ("FPIEEE_FLT_DEBUG: O_dis = %x\n", O_dis);
  printf ("FPIEEE_FLT_DEBUG: Z_dis = %x\n", Z_dis);
  printf ("FPIEEE_FLT_DEBUG: D_dis = %x\n", D_dis);
  printf ("FPIEEE_FLT_DEBUG: V_dis = %x\n", V_dis);
#endif

  FpieeeRecord.Enable.InvalidOperation = !V_dis;
  EnableDenormal = !D_dis;
  FpieeeRecord.Enable.ZeroDivide = !Z_dis;
  FpieeeRecord.Enable.Overflow = !O_dis;
  FpieeeRecord.Enable.Underflow = !U_dis;
  FpieeeRecord.Enable.Inexact = !I_dis;

  // determine whether this is a scalar (non-SIMD), or a parallel (SIMD)
  // instruction
  if ((OpCode & F1_MIN_MASK) == F1_PATTERN) {
    // F1 instruction

    switch (OpCode & F1_MASK) {
      case FMA_PATTERN:
      case FMA_S_PATTERN:
      case FMA_D_PATTERN:
      case FMS_PATTERN:
      case FMS_S_PATTERN:
      case FMS_D_PATTERN:
      case FNMA_PATTERN:
      case FNMA_S_PATTERN:
      case FNMA_D_PATTERN:
        SIMD_instruction = 0;
        break;
      case FPMA_PATTERN:
      case FPMS_PATTERN:
      case FPNMA_PATTERN:
        SIMD_instruction = 1;
        break;
      default:
        // unrecognized instruction type
        fprintf (stderr, "IEEE Filter Internal Error: \
instruction opcode %8x %8x not recognized\n", 
            (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
        __set_fpsr (&old_fpsr); /* restore caller fpsr */
        return (EXCEPTION_CONTINUE_SEARCH);
    }

  } else if ((OpCode & F4_MIN_MASK) == F4_PATTERN) {
    // F4 instruction

    switch (OpCode & F4_MASK) {
      case FCMP_EQ_PATTERN:
      case FCMP_LT_PATTERN:
      case FCMP_LE_PATTERN:
      case FCMP_UNORD_PATTERN:
      case FCMP_EQ_UNC_PATTERN:
      case FCMP_LT_UNC_PATTERN:
      case FCMP_LE_UNC_PATTERN:
      case FCMP_UNORD_UNC_PATTERN:
        SIMD_instruction = 0;
        break;
      default:
        // unrecognized instruction type
        fprintf (stderr, "IEEE Filter Internal Error: \
instruction opcode %8x %8x not recognized\n",
            (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
        __set_fpsr (&old_fpsr); /* restore caller fpsr */
        return (EXCEPTION_CONTINUE_SEARCH);
    }

  } else if ((OpCode & F6_MIN_MASK) == F6_PATTERN) {
    // F6 instruction

    switch (OpCode & F6_MASK) {
      case FRCPA_PATTERN:
        SIMD_instruction = 0;
        break;
      case FPRCPA_PATTERN:
        SIMD_instruction = 1;
        break;
      default:
        // unrecognized instruction type
        fprintf (stderr, "IEEE Filter Internal Error: \
instruction opcode %8x %8x not recognized\n",
            (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
        __set_fpsr (&old_fpsr); /* restore caller fpsr */
        return (EXCEPTION_CONTINUE_SEARCH);
    }

  } else if ((OpCode & F7_MIN_MASK) == F7_PATTERN) {
    // F7 instruction

    switch (OpCode & F7_MASK) {
      case FRSQRTA_PATTERN:
        SIMD_instruction = 0;
        break;
      case FPRSQRTA_PATTERN:
        SIMD_instruction = 1;
        break;
      default:
        // unrecognized instruction type
        fprintf (stderr, "IEEE Filter Internal Error: \
instruction opcode %8x %8x not recognized\n",
            (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
        __set_fpsr (&old_fpsr); /* restore caller fpsr */
        return (EXCEPTION_CONTINUE_SEARCH);
    }

  } else if ((OpCode & F8_MIN_MASK) == F8_PATTERN) {
    // F8 instruction

    switch (OpCode & F8_MASK) {
      case FMIN_PATTERN:
      case FMAX_PATTERN:
      case FAMIN_PATTERN:
      case FAMAX_PATTERN:
        SIMD_instruction = 0;
        break;
      case FPMIN_PATTERN:
      case FPMAX_PATTERN:
      case FPAMIN_PATTERN:
      case FPAMAX_PATTERN:
      case FPCMP_EQ_PATTERN:
      case FPCMP_LT_PATTERN:
      case FPCMP_LE_PATTERN:
      case FPCMP_UNORD_PATTERN:
      case FPCMP_NEQ_PATTERN:
      case FPCMP_NLT_PATTERN:
      case FPCMP_NLE_PATTERN:
      case FPCMP_ORD_PATTERN:
        SIMD_instruction = 1;
        break;
      default:
        // unrecognized instruction type
        fprintf (stderr, "IEEE Filter Internal Error: \
instruction opcode %8x %8x not recognized\n",
            (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
        __set_fpsr (&old_fpsr); /* restore caller fpsr */
        return (EXCEPTION_CONTINUE_SEARCH);
    }

  } else if ((OpCode & F10_MIN_MASK) == F10_PATTERN) {
    // F10 instruction

    switch (OpCode & F10_MASK) {
      case FCVT_FX_PATTERN:
      case FCVT_FXU_PATTERN:
      case FCVT_FX_TRUNC_PATTERN:
      case FCVT_FXU_TRUNC_PATTERN:
        SIMD_instruction = 0;
        break;
      case FPCVT_FX_PATTERN:
      case FPCVT_FXU_PATTERN:
      case FPCVT_FX_TRUNC_PATTERN:
      case FPCVT_FXU_TRUNC_PATTERN:
        SIMD_instruction = 1;
        break;
      default:
        // unrecognized instruction type
        fprintf (stderr, "IEEE Filter Internal Error: \
instruction opcode %8x %8x not recognized\n",
            (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
        __set_fpsr (&old_fpsr); /* restore caller fpsr */
        return (EXCEPTION_CONTINUE_SEARCH);
    }

  } else {

    // unrecognized instruction type
    fprintf (stderr, "IEEE Filter Internal Error: \
instruction opcode %8x %8x not recognized\n",
        (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
    __set_fpsr (&old_fpsr); /* restore caller fpsr */
    return (EXCEPTION_CONTINUE_SEARCH);

  }

  if (eXceptionCode == STATUS_FLOAT_INVALID_OPERATION ||
      eXceptionCode == STATUS_FLOAT_DENORMAL_OPERAND ||
      eXceptionCode == STATUS_FLOAT_DIVIDE_BY_ZERO) {

    FpieeeRecord.Status.InvalidOperation = ((ISRlow & 0x0001) != 0);
    StatusDenormal = ((ISRlow & 0x0002) != 0);
    FpieeeRecord.Status.ZeroDivide = ((ISRlow & 0x0004) != 0);
    FpieeeRecord.Status.Overflow = 0;
    FpieeeRecord.Status.Underflow = 0;
    FpieeeRecord.Status.Inexact = 0;

  } else if (eXceptionCode == STATUS_FLOAT_UNDERFLOW ||
      eXceptionCode == STATUS_FLOAT_OVERFLOW ||
      eXceptionCode == STATUS_FLOAT_INEXACT_RESULT) {

    /* note that U and I or O and I may be set simultaneously in ISRlow */
    FpieeeRecord.Status.InvalidOperation = 0;
    StatusDenormal = 0;
    FpieeeRecord.Status.ZeroDivide = 0;
    FpieeeRecord.Status.Overflow = ((ISRlow & 0x0800) != 0);
    FpieeeRecord.Status.Underflow = ((ISRlow & 0x1000) != 0);
    FpieeeRecord.Status.Inexact = ((ISRlow & 0x2000) != 0);

  } else if (eXceptionCode == STATUS_FLOAT_MULTIPLE_FAULTS) {

    LowStatus.InvalidOperation = ((ISRlow & 0x0010) != 0);
    HighStatus.InvalidOperation = ((ISRlow & 0x0001) != 0);
    LowStatusDenormal = ((ISRlow & 0x0020) != 0);
    HighStatusDenormal = ((ISRlow & 0x0002) != 0);
    LowStatus.ZeroDivide = ((ISRlow & 0x0040) != 0);
    HighStatus.ZeroDivide = ((ISRlow & 0x0004) != 0);
    LowStatus.Overflow = 0;
    HighStatus.Overflow = 0;
    LowStatus.Underflow = 0;
    HighStatus.Underflow = 0;
    LowStatus.Inexact = 0;
    HighStatus.Inexact = 0;

  } else if (eXceptionCode == STATUS_FLOAT_MULTIPLE_TRAPS) {

    /* note that U and I or O and I may be set simultaneously in ISRlow */
    LowStatus.InvalidOperation = 0;
    HighStatus.InvalidOperation = 0;
    LowStatusDenormal = 0;
    HighStatusDenormal = 0;
    LowStatus.ZeroDivide = 0;
    HighStatus.ZeroDivide = 0;
    LowStatus.Overflow = ((ISRlow & 0x0080) != 0);
    HighStatus.Overflow = ((ISRlow & 0x0800) != 0);
    LowStatus.Underflow = ((ISRlow & 0x0100) != 0);
    HighStatus.Underflow = ((ISRlow & 0x1000) != 0);
    LowStatus.Inexact = ((ISRlow & 0x0200) != 0);
    HighStatus.Inexact = ((ISRlow & 0x2000) != 0);

  } // else { ; } // this case was checked above

  if (eXceptionCode == STATUS_FLOAT_MULTIPLE_FAULTS) {

    LowCause.InvalidOperation =
        FpieeeRecord.Enable.InvalidOperation && LowStatus.InvalidOperation;
    HighCause.InvalidOperation =
        FpieeeRecord.Enable.InvalidOperation && HighStatus.InvalidOperation;
    LowCauseDenormal = EnableDenormal && LowStatusDenormal;
    HighCauseDenormal = EnableDenormal && HighStatusDenormal;
    LowCause.ZeroDivide =
        FpieeeRecord.Enable.ZeroDivide && LowStatus.ZeroDivide;
    HighCause.ZeroDivide =
        FpieeeRecord.Enable.ZeroDivide && HighStatus.ZeroDivide;
    LowCause.Overflow = 0;
    HighCause.Overflow = 0;
    LowCause.Underflow = 0;
    HighCause.Underflow = 0;
    LowCause.Inexact = 0;
    HighCause.Inexact = 0;

    /* search for another handler if not an IEEE or denormal fault */
    if (!LowCause.InvalidOperation && !HighCause.InvalidOperation &&
        !LowCauseDenormal && !HighCauseDenormal &&
        !LowCause.ZeroDivide && !HighCause.ZeroDivide) {
      __set_fpsr (&old_fpsr); /* restore caller fpsr */
#ifdef FPIEEE_FLT_DEBUG
      printf ("FPIEEE_FLT_DEBUG: STATUS_FLOAT_MULTIPLE_FAULTS BUT NO Cause\n");
#endif
      return (EXCEPTION_CONTINUE_SEARCH);
    }

  } else if (eXceptionCode == STATUS_FLOAT_MULTIPLE_TRAPS) {

    LowCause.InvalidOperation = 0;
    HighCause.InvalidOperation = 0;
    LowCauseDenormal = 0;
    HighCauseDenormal = 0;
    LowCause.ZeroDivide = 0;
    HighCause.ZeroDivide = 0;
    LowCause.Overflow = FpieeeRecord.Enable.Overflow && LowStatus.Overflow;
    HighCause.Overflow = FpieeeRecord.Enable.Overflow && HighStatus.Overflow;
    LowCause.Underflow = FpieeeRecord.Enable.Underflow && LowStatus.Underflow;
    HighCause.Underflow = FpieeeRecord.Enable.Underflow && HighStatus.Underflow;
    if (LowCause.Overflow || LowCause.Underflow)
      LowCause.Inexact = 0;
    else
      LowCause.Inexact = FpieeeRecord.Enable.Inexact && LowStatus.Inexact;
    if (HighCause.Overflow || HighCause.Underflow)
      HighCause.Inexact = 0;
    else
      HighCause.Inexact = FpieeeRecord.Enable.Inexact && HighStatus.Inexact;

    /* search for another handler if not an IEEE or denormal trap */
    if (!LowCause.Overflow && !HighCause.Overflow &&
        !LowCause.Underflow && !HighCause.Underflow &&
        !LowCause.Inexact && !HighCause.Inexact) {
      __set_fpsr (&old_fpsr); /* restore caller fpsr */
#ifdef FPIEEE_FLT_DEBUG
      printf ("FPIEEE_FLT_DEBUG: STATUS_FLOAT_MULTIPLE_FAULTS BUT NO Cause\n");
#endif
      return (EXCEPTION_CONTINUE_SEARCH);
    }

  } else { // if (!SIMD_instruction)

    FpieeeRecord.Cause.InvalidOperation = FpieeeRecord.Enable.InvalidOperation
        && FpieeeRecord.Status.InvalidOperation;
    CauseDenormal = EnableDenormal && StatusDenormal;
    FpieeeRecord.Cause.ZeroDivide =
        FpieeeRecord.Enable.ZeroDivide && FpieeeRecord.Status.ZeroDivide;
    FpieeeRecord.Cause.Overflow =
        FpieeeRecord.Enable.Overflow && FpieeeRecord.Status.Overflow;
    FpieeeRecord.Cause.Underflow =
        FpieeeRecord.Enable.Underflow && FpieeeRecord.Status.Underflow;
    if (FpieeeRecord.Cause.Overflow || FpieeeRecord.Cause.Underflow)
      FpieeeRecord.Cause.Inexact = 0;
    else
      FpieeeRecord.Cause.Inexact =
          FpieeeRecord.Enable.Inexact && FpieeeRecord.Status.Inexact;

    /* search for another handler if not an IEEE exception */
    if (!FpieeeRecord.Cause.InvalidOperation &&
        !FpieeeRecord.Cause.ZeroDivide &&
        !CauseDenormal &&
        !FpieeeRecord.Cause.Overflow &&
        !FpieeeRecord.Cause.Underflow &&
        !FpieeeRecord.Cause.Inexact) {
      __set_fpsr (&old_fpsr); /* restore caller fpsr */
#ifdef FPIEEE_FLT_DEBUG
      printf ("FPIEEE_FLT_DEBUG: NON-SIMD FP EXCEPTION BUT NO Cause\n");
#endif
      return (EXCEPTION_CONTINUE_SEARCH);
    }

  }

  if ((eXceptionCode == STATUS_FLOAT_INVALID_OPERATION || 
      eXceptionCode == STATUS_FLOAT_DENORMAL_OPERAND ||
      eXceptionCode == STATUS_FLOAT_DIVIDE_BY_ZERO ||
      eXceptionCode == STATUS_FLOAT_OVERFLOW ||
      eXceptionCode == STATUS_FLOAT_UNDERFLOW ||
      eXceptionCode == STATUS_FLOAT_INEXACT_RESULT) && SIMD_instruction ||
      (eXceptionCode == STATUS_FLOAT_MULTIPLE_FAULTS ||
      eXceptionCode == STATUS_FLOAT_MULTIPLE_TRAPS) && !SIMD_instruction) {
    fprintf (stderr, "IEEE Filter Internal Error: Exception Code %8x and \
SIMD_instruction = %x not compatible for F1 instruction opcode %8x %8x\n",
          eXceptionCode, SIMD_instruction,
          (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
      exit (1);
  }

  /* decode the rest of the instruction */
  if ((OpCode & F1_MIN_MASK) == F1_PATTERN) {
    /* F1 instruction */
    // FMA, FMS, FNMA, FPMA, FPMS, FPNMA

#ifdef FPIEEE_FLT_DEBUG
    printf ("FPIEEE_FLT_DEBUG: F1 instruction\n");
#endif

    if (!SIMD_instruction && FpieeeRecord.Cause.ZeroDivide || 
        SIMD_instruction && (LowCause.ZeroDivide || HighCause.ZeroDivide)) {
      fprintf (stderr, "IEEE Filter Internal Error: Cause.ZeroDivide for \
F1 instruction opcode %8x %8x\n", 
          (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
      exit (1);
    }

    /* extract f4, f3, f2, and f1 */
    f4 = (unsigned int)((OpCode >> 27) & (unsigned __int64)0x00000000007F);
    if (f4 >= 32) f4 = 32 + (rrbfr + f4 - 32) % 96;
    f3 = (unsigned int)((OpCode >> 20) & (unsigned __int64)0x00000000007F);
    if (f3 >= 32) f3 = 32 + (rrbfr + f3 - 32) % 96;
    f2 = (unsigned int)((OpCode >> 13) & (unsigned __int64)0x00000000007F);
    if (f2 >= 32) f2 = 32 + (rrbfr + f2 - 32) % 96;
    f1 = (unsigned int)((OpCode >>  6) & (unsigned __int64)0x00000000007F);
    if (f1 >= 32) f1 = 32 + (rrbfr + f1 - 32) % 96;

#ifdef FPIEEE_FLT_DEBUG
    printf ("FPIEEE_FLT_DEBUG: f1 = %x\n", f1);
    printf ("FPIEEE_FLT_DEBUG: f2 = %x\n", f2);
    printf ("FPIEEE_FLT_DEBUG: f3 = %x\n", f3);
    printf ("FPIEEE_FLT_DEBUG: f4 = %x\n", f4);
#endif

    /* get source floating-point register values */
    FR3 = GetFloatRegisterValue (f3, Context);
    FR4 = GetFloatRegisterValue (f4, Context);
    FR2 = GetFloatRegisterValue (f2, Context);

#ifdef FPIEEE_FLT_DEBUG
    printf ("FPIEEE_FLT_DEBUG: FR2 = %08x %08x %08x %08x\n",
        FR2.W[3], FR2.W[2], FR2.W[1], FR2.W[0]);
    printf ("FPIEEE_FLT_DEBUG: FR3 = %08x %08x %08x %08x\n",
        FR3.W[3], FR3.W[2], FR3.W[1], FR3.W[0]);
    printf ("FPIEEE_FLT_DEBUG: FR4 = %08x %08x %08x %08x\n",
        FR4.W[3], FR4.W[2], FR4.W[1], FR4.W[0]);
#endif

    if (!SIMD_instruction) {

      // *** this is a non-SIMD instruction ***

      FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
      FpieeeRecord.Operand1.OperandValid = 1;
      FpieeeRecord.Operand1.Value.Fp128Value = FR3;
      FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
      FpieeeRecord.Operand2.OperandValid = 1;
      FpieeeRecord.Operand2.Value.Fp128Value = FR4;
      FpieeeRecord.Operand3.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
      FpieeeRecord.Operand3.OperandValid = 1;
      FpieeeRecord.Operand3.Value.Fp128Value = FR2;

      switch (OpCode & F1_MASK) {

        case FMA_PATTERN:

#ifdef FPIEEE_FLT_DEBUG
          printf ("FPIEEE_FLT_DEBUG F1 INSTRUCTION FMA\n");
#endif
          FpieeeRecord.Operation = _FpCodeFma;
          if (wre == 0)
            FpieeeRecord.Result.Format = _FpFormatFp80; /* 1+15+24/53/64 bits */
          else
            FpieeeRecord.Result.Format = _FpFormatFp82; /* 1+17+24/53/64 bits */
          break;

        case FMA_S_PATTERN:

          FpieeeRecord.Operation = _FpCodeFmaSingle;
          if (wre == 0)
            FpieeeRecord.Result.Format = _FpFormatFp32; /* 1+8+24 bits */
          else
            FpieeeRecord.Result.Format = _FpFormatFp82; /* 1+17+24 bits */
          break;

        case FMA_D_PATTERN:

#ifdef FPIEEE_FLT_DEBUG
          printf ("FPIEEE_FLT_DEBUG F1 INSTRUCTION FMA_D\n");
#endif
          FpieeeRecord.Operation = _FpCodeFmaDouble;
          if (wre == 0)
            FpieeeRecord.Result.Format = _FpFormatFp64; /* 1+11+53 bits */
          else
            FpieeeRecord.Result.Format = _FpFormatFp82; /* 1+17+53 bits */
          break;


        case FMS_PATTERN:

#ifdef FPIEEE_FLT_DEBUG
          printf ("FPIEEE_FLT_DEBUG F1 INSTRUCTION FMS\n");
#endif
          FpieeeRecord.Operation = _FpCodeFms;
          if (wre == 0)
            FpieeeRecord.Result.Format = _FpFormatFp80; /* 1+15+24/53/64 bits */
          else
            FpieeeRecord.Result.Format = _FpFormatFp82; /* 1+17+24/53/64 bits */
          break;

        case FMS_S_PATTERN:

#ifdef FPIEEE_FLT_DEBUG
          printf ("FPIEEE_FLT_DEBUG F1 INSTRUCTION FMS_S\n");
#endif
          FpieeeRecord.Operation = _FpCodeFmsSingle;
          if (wre == 0)
            FpieeeRecord.Result.Format = _FpFormatFp32; /* 1+8+24 bits */
          else
            FpieeeRecord.Result.Format = _FpFormatFp82; /* 1+17+24 bits */
          break;

        case FMS_D_PATTERN:

#ifdef FPIEEE_FLT_DEBUG
          printf ("FPIEEE_FLT_DEBUG F1 INSTRUCTION FMS_D\n");
#endif
          FpieeeRecord.Operation = _FpCodeFmsDouble;
          if (wre == 0)
            FpieeeRecord.Result.Format = _FpFormatFp64; /* 1+11+53 bits */
          else
            FpieeeRecord.Result.Format = _FpFormatFp82; /* 1+17+53 bits */
          break;

        case FNMA_PATTERN:

#ifdef FPIEEE_FLT_DEBUG
          printf ("FPIEEE_FLT_DEBUG F1 INSTRUCTION FNMA\n");
#endif
          FpieeeRecord.Operation = _FpCodeFnma;
          if (wre == 0)
            FpieeeRecord.Result.Format = _FpFormatFp80; /* 1+15+24/53/64 bits */
          else
            FpieeeRecord.Result.Format = _FpFormatFp82; /* 1+17+24/53/64 bits */
          break;

        case FNMA_S_PATTERN:

#ifdef FPIEEE_FLT_DEBUG
          printf ("FPIEEE_FLT_DEBUG F1 INSTRUCTION FNMA_S\n");
#endif
          FpieeeRecord.Operation = _FpCodeFnmaSingle;
          if (wre == 0)
            FpieeeRecord.Result.Format = _FpFormatFp32; /* 1+8+24 bits */
          else
            FpieeeRecord.Result.Format = _FpFormatFp82; /* 1+17+24 bits */
          break;

        case FNMA_D_PATTERN:

#ifdef FPIEEE_FLT_DEBUG
          printf ("FPIEEE_FLT_DEBUG F1 INSTRUCTION FNMA_D\n");
#endif
          FpieeeRecord.Operation = _FpCodeFnmaDouble;
          if (wre == 0)
            FpieeeRecord.Result.Format = _FpFormatFp64; /* 1+11+53 bits */
          else
            FpieeeRecord.Result.Format = _FpFormatFp82; /* 1+17+53 bits */
          break;

        default:
          /* unrecognized instruction type */
          fprintf (stderr, "IEEE Filter Internal Error: \
              non-SIMD F1 instruction opcode %8x %8x not recognized\n", 
              (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
          exit (1);

      }

      if (FpieeeRecord.Cause.InvalidOperation || CauseDenormal) {

        /* this is a fault - the result contains an invalid value */
        FpieeeRecord.Result.OperandValid = 0;
        handler_return_value = handler (&FpieeeRecord);

      } else if (FpieeeRecord.Cause.Overflow) {
 
        // this is a trap - the result contains a valid value
        FpieeeRecord.Result.OperandValid = 1;
        // get the result
        FpieeeRecord.Result.Value.Fp128Value =
            GetFloatRegisterValue (f1, Context);
#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG OVERFLOW: RES = %08x %08x %08x %08x\n",
            FpieeeRecord.Result.Value.Fp128Value.W[3],
            FpieeeRecord.Result.Value.Fp128Value.W[2],
            FpieeeRecord.Result.Value.Fp128Value.W[1],
            FpieeeRecord.Result.Value.Fp128Value.W[0]);
#endif

        // before calling the user handler, adjust the result to the
        // range imposed by the format
        FP128ToFPIeee (&FpieeeRecord, -1); // -1 indicates scaling direction 
        handler_return_value = handler (&FpieeeRecord);

      } else if (FpieeeRecord.Cause.Underflow) {

        // this is a trap - the result contains a valid value
        FpieeeRecord.Result.OperandValid = 1;
        // get the result
        FpieeeRecord.Result.Value.Fp128Value =
            GetFloatRegisterValue (f1, Context);
        // before calling the user handler, adjust the result to the
        // range imposed by the format
        FP128ToFPIeee (&FpieeeRecord, +1); // +1 indicates scaling direction 
        handler_return_value = handler (&FpieeeRecord);

      } else if (FpieeeRecord.Cause.Inexact) {

        // this is a trap - the result contains a valid value
        FpieeeRecord.Result.OperandValid = 1;
        // get the result
        FpieeeRecord.Result.Value.Fp128Value =
            GetFloatRegisterValue (f1, Context);
        // before calling the user handler, adjust the result to the
        // range imposed by the format
        FP128ToFPIeee (&FpieeeRecord, 0); // 0 indicates no scaling
        handler_return_value = handler (&FpieeeRecord);

      }

      if (handler_return_value == EXCEPTION_CONTINUE_EXECUTION) {

        // convert the result to 82-bit format
        FR1 = FPIeeeToFP128 (&FpieeeRecord);
#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG 1: CONVERTED FR1 = %08x %08x %08x %08x\n",
            FR1.W[3], FR1.W[2], FR1.W[1], FR1.W[0]);
#endif

        /* change the FPSR with values (possibly) set by the user handler, 
         * for continuing execution where the interruption occured */

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F1");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F1");

        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis << 5
            | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        Context->StFPSR = FPSR;

        // set the result before continuing execution
        SetFloatRegisterValue (f1, FR1, Context);
        if (f1 < 32)
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl bit
        else
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh bit

        // if this is a fault, need to advance the instruction pointer
        if (FpieeeRecord.Cause.InvalidOperation || CauseDenormal) {

          if (ei == 0) { // no template for this case
            Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
            Context->StIPSR = Context->StIPSR | 0x0000020000000000;
          } else if (ei == 1) { // templates: MFI, MFB
            Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
            Context->StIPSR = Context->StIPSR | 0x0000040000000000;
          } else { // if (ei == 2) // templates: MMF
            Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
            Context->StIIP = Context->StIIP + 0x10;
          }

        }

      }

    } else { // if (SIMD_instruction)

      // *** this is a SIMD instruction ***

      // the half (halves) of the instruction that caused an enabled exception, 
      // are presented to the user-defined handler in the form of non-SIMD in-
      // struction(s); the half (if any) that did not cause an enabled exception
      // (i.e. caused no exception, or caused an exception that is disabled),
      // is re-executed if it is associated with a fault in the other half; in
      // this case, the other half is padded to calculate 0.0 * 0.0 + 0.0, that
      // will cause no exception; if it is associated with a trap in the other
      // half, its result is left unchanged

      switch (OpCode & F1_MASK) {

        case FPMA_PATTERN:
          Operation = _FpCodeFmaSingle;
          break;

        case FPMS_PATTERN:
          Operation = _FpCodeFmsSingle;
          break;

        case FPNMA_PATTERN:
          Operation = _FpCodeFnmaSingle;
          break;

        default:
          /* unrecognized instruction type */
          fprintf (stderr, "IEEE Filter Internal Error: \
              SIMD instruction opcode %8x %8x not recognized\n", 
              (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
          exit (1);

      }

      if (eXceptionCode == STATUS_FLOAT_MULTIPLE_FAULTS) {

        // hand the half (halves) that caused an enabled fault to the 
        // user handler; re-execute the other half (if any);
        // combine the results

        // Note that the convention chosen is for the processing to be 
        // performed in the order low first, high second, as SIMD operands
        // are stored in this order in memory in the little endian format 
        // (this order would have to be changed for big endian)

        if (LowCause.InvalidOperation || LowCauseDenormal) {

          // invoke the user handler and check the return value

          // fill in the remaining fields of the _FPIEEE_RECORD (rounding
          // and precision already filled in)

          FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
          FpieeeRecord.Operand1.OperandValid = 1;
          FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128 (LowHalf(FR3));
          FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
          FpieeeRecord.Operand2.OperandValid = 1;
          FpieeeRecord.Operand2.Value.Fp128Value = FP32ToFP128 (LowHalf(FR4));
          FpieeeRecord.Operand3.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
          FpieeeRecord.Operand3.OperandValid = 1;
          FpieeeRecord.Operand3.Value.Fp128Value = FP32ToFP128 (LowHalf(FR2));

          FpieeeRecord.Result.Format = _FpFormatFp32; /* 1 + 8 + 24 bits */
          FpieeeRecord.Result.OperandValid = 0;

          FpieeeRecord.Operation = Operation;

          FpieeeRecord.Status.InvalidOperation = LowStatus.InvalidOperation;
          StatusDenormal = LowStatusDenormal;
          FpieeeRecord.Status.ZeroDivide = LowStatus.ZeroDivide;
          FpieeeRecord.Status.Overflow = LowStatus.Overflow;
          FpieeeRecord.Status.Underflow = LowStatus.Underflow;
          FpieeeRecord.Status.Inexact = LowStatus.Inexact;

          FpieeeRecord.Cause.InvalidOperation = LowCause.InvalidOperation;
          CauseDenormal = LowCauseDenormal;
          FpieeeRecord.Cause.ZeroDivide = LowCause.ZeroDivide; // 0
          FpieeeRecord.Cause.Overflow = LowCause.Overflow;
          FpieeeRecord.Cause.Underflow = LowCause.Underflow;
          FpieeeRecord.Cause.Inexact = LowCause.Inexact;

          // invoke the user-defined exception handler
          handler_return_value = handler (&FpieeeRecord);

          // return if not EXCEPTION_CONTINUE_EXECUTION
          if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

            __set_fpsr (&old_fpsr); /* restore caller fpsr */
            return (handler_return_value);

          }

          // clear the IEEE exception flags in the FPSR and
          // update the FPSR with values (possibly) set by the user handler
          // for the rounding mode, the precision mode, and the trap enable
          // bits; if the high half needs to be re-executed, the new FPSR
          // will be used, with status flags cleared; if it is 
          // forwarded to the user-defined handler, the new rounding and 
          // precision modes are also used (they are
          // already set in FpieeeRecord)

          UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F1");
          UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F1");

          // Update the trap disable bits
          I_dis = !FpieeeRecord.Enable.Inexact;
          U_dis = !FpieeeRecord.Enable.Underflow;
          O_dis = !FpieeeRecord.Enable.Overflow;
          Z_dis = !FpieeeRecord.Enable.ZeroDivide;
          V_dis = !FpieeeRecord.Enable.InvalidOperation;
          // Note that D_dis cannot be updated by the IEEE user handler

          FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis
              << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

          // save the result for the low half
          FR1Low = FpieeeRecord.Result.Value.Fp32Value;

          // since there has been a call to the user handler and FPSR might
          // have changed (the Enable bits in particular), recalculate the 
          // Cause bits (if the HighEnable-s changed, there might be a 
          // change in the HighCause values) 
          // Note that the Status bits used are the original ones

          HighCause.InvalidOperation = FpieeeRecord.Enable.InvalidOperation &&
              HighStatus.InvalidOperation;
          HighCauseDenormal = EnableDenormal && HighStatusDenormal;
          HighCause.ZeroDivide =
              FpieeeRecord.Enable.ZeroDivide && HighStatus.ZeroDivide; // 0
          HighCause.Overflow = 0;
          HighCause.Underflow = 0;
          HighCause.Inexact = 0;

        } else { // if not (LowCause.InvalidOperation || LowCauseDenormal)

          // re-execute the low half of the instruction

          // modify the high halves of FR2, FR3, FR4
          newFR2 = Combine ((float)0.0, LowHalf (FR2));
          newFR3 = Combine ((float)0.0, LowHalf (FR3));
          newFR4 = Combine ((float)0.0, LowHalf (FR4));

#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG: WILL re-execute the low half\n");
        printf ("FPIEEE_FLT_DEBUG: usr_fpsr = %8x %8x\n",
            (int)(usr_fpsr >> 32) & 0xffffffff, (int)usr_fpsr & 0xffffffff);
        printf ("FPIEEE_FLT_DEBUG: newFR2 = %08x %08x %08x %08x\n",
            newFR2.W[3], newFR2.W[2], newFR2.W[1], newFR2.W[0]);
        printf ("FPIEEE_FLT_DEBUG: newFR3 = %08x %08x %08x %08x\n",
            newFR3.W[3], newFR3.W[2], newFR3.W[1], newFR3.W[0]);
        printf ("FPIEEE_FLT_DEBUG: newFR4 = %08x %08x %08x %08x\n",
            newFR4.W[3], newFR4.W[2], newFR4.W[1], newFR4.W[0]);
#endif

          switch (OpCode & F1_MASK) {

            case FPMA_PATTERN:
#ifdef FPIEEE_FLT_DEBUG
              printf ("FPIEEE_FLT_DEBUG: re-execute low half FPMA\n");
#endif
              _xrun3args (FPMA, &FPSR, &FR1, &newFR3, &newFR4, &newFR2);
#ifdef FPIEEE_FLT_DEBUG
              printf ("FPIEEE_FLT_DEBUG: FR1 AFT = %08x %08x %08x %08x\n",
                  FR1.W[3], FR1.W[2], FR1.W[1], FR1.W[0]);
#endif
              break;

            case FPMS_PATTERN:
#ifdef FPIEEE_FLT_DEBUG
            printf ("FPIEEE_FLT_DEBUG: re-execute low half FPMS\n");
#endif
            _xrun3args (FPMS, &FPSR, &FR1, &newFR3, &newFR4, &newFR2);
#ifdef FPIEEE_FLT_DEBUG
            printf ("FPIEEE_FLT_DEBUG: FR1 AFT = %08x %08x %08x %08x\n",
                FR1.W[3], FR1.W[2], FR1.W[1], FR1.W[0]);
#endif
              break;

            case FPNMA_PATTERN:
#ifdef FPIEEE_FLT_DEBUG
            printf ("FPIEEE_FLT_DEBUG: re-execute low half FPNMA\n");
#endif
            _xrun3args (FPNMA, &FPSR, &FR1, &newFR3, &newFR4, &newFR2);
#ifdef FPIEEE_FLT_DEBUG
            printf ("FPIEEE_FLT_DEBUG: FR1 AFT = %08x %08x %08x %08x\n",
                FR1.W[3], FR1.W[2], FR1.W[1], FR1.W[0]);
#endif
              break;

            default:
              // unrecognized instruction type
              fprintf (stderr, "IEEE Filter Internal Error: \
                  SIMD instruction opcode %8x %8x not recognized\n", 
                  (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
              exit (1);

          }

          FR1Low = LowHalf (FR1);

        } // end 'if not (LowCause.InvalidOperation || LowCauseDenormal)'

        if (HighCause.InvalidOperation || HighCauseDenormal) {

          // invoke the user-defined exception handler and check the return 
          // value; since this might be the second call to the user handler,
          // make sure all the _FPIEEE_RECORD fields are correct;
          // return if handler_return_value is not
          // EXCEPTION_CONTINUE_EXECUTION, otherwise combine the results

          // the rounding mode is either the initial one, or the one
          // set during the call to the user handler for the low half,
          // if there has been an enabled exception for it

          // the precision mode is either the initial one, or the one
          // set during the call to the user handler for the low half,
          // if there has been an enabled exception for it

          // the enable flags are either the initial ones, or the ones
          // set during the call to the user handler for the low half,
          // if there has been an enabled exception for it

          FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1+8+24 bits */
          FpieeeRecord.Operand1.OperandValid = 1;
          // operands have always _FpFormatFp82 and use Fp128Value
          FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128(HighHalf(FR3));
          FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1+8+24 bits */
          FpieeeRecord.Operand2.OperandValid = 1;
          // operands have always _FpFormatFp82 and use Fp128Value
          FpieeeRecord.Operand2.Value.Fp128Value = FP32ToFP128(HighHalf(FR4));
          FpieeeRecord.Operand3.Format = _FpFormatFp82; /* 1+8+24 bits */
          FpieeeRecord.Operand3.OperandValid = 1;
          // operands have always _FpFormatFp82 and use Fp128Value
          FpieeeRecord.Operand3.Value.Fp128Value = FP32ToFP128(HighHalf(FR2));
          FpieeeRecord.Result.Format = _FpFormatFp32; /* 1 + 8 + 24 bits */
          FpieeeRecord.Result.OperandValid = 0;

          FpieeeRecord.Operation = Operation;

          FpieeeRecord.Status.InvalidOperation = HighStatus.InvalidOperation;
          StatusDenormal = HighStatusDenormal;
          FpieeeRecord.Status.ZeroDivide = HighStatus.ZeroDivide;
          FpieeeRecord.Status.Overflow = HighStatus.Overflow;
          FpieeeRecord.Status.Underflow = HighStatus.Underflow;
          FpieeeRecord.Status.Inexact = HighStatus.Inexact;

          FpieeeRecord.Cause.InvalidOperation = HighCause.InvalidOperation;
          CauseDenormal = HighCauseDenormal;
          FpieeeRecord.Cause.ZeroDivide = HighCause.ZeroDivide; // 0
          FpieeeRecord.Cause.Overflow = HighCause.Overflow;
          FpieeeRecord.Cause.Underflow = HighCause.Underflow;
          FpieeeRecord.Cause.Inexact = HighCause.Inexact;

          // invoke the user-defined exception handler
          handler_return_value = handler (&FpieeeRecord);

          // return if not EXCEPTION_CONTINUE_EXECUTION
          if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

            __set_fpsr (&old_fpsr); /* restore caller fpsr */
            return (handler_return_value);

          }

          // clear the IEEE exception flags in the FPSR and
          // update the FPSR with values (possibly) set by the user handler
          // for the rounding mode, the precision mode, and the trap enable
          // bits; if the high half needs to be re-executed, the new FPSR
          // will be used, with status flags cleared; if it is
          // forwarded to the user-defined handler, the new rounding and
          // precision modes are also used (they are
          // already set in FpieeeRecord)

          /* change the FPSR with values (possibly) set by the user handler,
           * for continuing execution where the interruption occured */
  
          UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F1");
          UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F1");
  
          V_dis = !FpieeeRecord.Enable.InvalidOperation;
          Z_dis = !FpieeeRecord.Enable.ZeroDivide;
          O_dis = !FpieeeRecord.Enable.Overflow;
          U_dis = !FpieeeRecord.Enable.Underflow;
          I_dis = !FpieeeRecord.Enable.Inexact;
          // Note that D_dis cannot be updated by the IEEE user handler

          FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis
              << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

          // save the result for the high half
          FR1High = FpieeeRecord.Result.Value.Fp32Value;

        } else { //if not (HighCause.InvalidOperation || HighCauseDenormal)

          // re-execute the high half of the instruction

          // modify the low halves of FR2, FR3, FR4
          newFR2 = Combine (HighHalf (FR2), (float)0.0);
          newFR3 = Combine (HighHalf (FR3), (float)0.0);
          newFR4 = Combine (HighHalf (FR4), (float)0.0);

#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG: WILL re-execute the high half\n");
        printf ("FPIEEE_FLT_DEBUG: usr_fpsr = %8x %8x\n",
            (int)(usr_fpsr >> 32) & 0xffffffff, (int)usr_fpsr & 0xffffffff);
        printf ("FPIEEE_FLT_DEBUG: newFR2 = %08x %08x %08x %08x\n",
            newFR2.W[3], newFR2.W[2], newFR2.W[1], newFR2.W[0]);
        printf ("FPIEEE_FLT_DEBUG: newFR3 = %08x %08x %08x %08x\n",
            newFR3.W[3], newFR3.W[2], newFR3.W[1], newFR3.W[0]);
        printf ("FPIEEE_FLT_DEBUG: newFR4 = %08x %08x %08x %08x\n",
            newFR4.W[3], newFR4.W[2], newFR4.W[1], newFR4.W[0]);
        printf ("FPIEEE_FLT_DEBUG: FR1 BEF = %08x %08x %08x %08x\n",
            FR1.W[3], FR1.W[2], FR1.W[1], FR1.W[0]);
#endif

          switch (OpCode & F1_MASK) {

            case FPMA_PATTERN:
              _xrun3args (FPMA, &FPSR, &FR1, &newFR3, &newFR4, &newFR2);
              break;

            case FPMS_PATTERN:
              _xrun3args (FPMS, &FPSR, &FR1, &newFR3, &newFR4, &newFR2);
              break;

            case FPNMA_PATTERN:
              _xrun3args (FPNMA, &FPSR, &FR1, &newFR3, &newFR4, &newFR2);
              break;

            default:
              // unrecognized instruction type 
              fprintf (stderr, "IEEE Filter Internal Error: \
                  SIMD instruction opcode %8x %8x not recognized\n", 
                  (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
              exit (1);

          }

          FR1High = HighHalf (FR1);

        } // end 'if not (HighCause.InvalidOperation || HighCauseDenormal)'

        if (!LowCause.InvalidOperation && !HighCause.InvalidOperation &&
            !LowCauseDenormal && !HighCauseDenormal) {

          // should never get here
          fprintf (stderr, "IEEE Filter Internal Error: no enabled \
              exception (multiple fault) recognized in F1 instruction\n");
          exit (1);

        }

        // set the result
        Context->StFPSR = FPSR;

        // set the result before continuing execution
        FR1 = Combine (FR1High, FR1Low);
        SetFloatRegisterValue (f1, FR1, Context);
        if (f1 < 32)
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl
        else
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh

        // this is a fault; need to advance the instruction pointer
        if (ei == 0) { // no template for this case
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000020000000000;
        } else if (ei == 1) { // templates: MFI, MFB
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000040000000000;
        } else { // if (ei == 2) // templates: MMF
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIIP = Context->StIIP + 0x10;
        }

      } else if (eXceptionCode == STATUS_FLOAT_MULTIPLE_TRAPS) {

        // Note that the convention chosen is for the processing to be 
        // performed in the order low first, high second, as SIMD operands
        // are stored in this order in memory in the little endian format
        // (this order would have to be changed for big endian); unlike
        // in the case of multiple faults, where execution of the user
        // exception handler for the low half could determine changes in
        // the high half, for traps in the high half, the rounding mode, 
        // precision mode, and trap enable bits are the initial ones (as
        // there is not enough information available to always adjust
        // correctly the result and/or the status flags after changes in
        // rounding mode and/or trap enable bits during a call to the
        // user-defined exception handler for the low half of the SIMD
        // instruction); the modifications to the FPSR are ONLY those 
        // performed by the last call to the user defined exception handler

        // this is a trap - get the result
        FR1 = GetFloatRegisterValue (f1, Context);

        if (LowCause.Underflow || LowCause.Overflow || LowCause.Inexact) {

          // invoke the user handler and check the return value

          // fill in the remaining fields of the _FPIEEE_RECORD (rounding
          // and precision already filled in)

          FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
          FpieeeRecord.Operand1.OperandValid = 1;
          FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128 (LowHalf(FR3));
          FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
          FpieeeRecord.Operand2.OperandValid = 1;
          FpieeeRecord.Operand2.Value.Fp128Value = FP32ToFP128 (LowHalf(FR4));
          FpieeeRecord.Operand3.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
          FpieeeRecord.Operand3.OperandValid = 1;
          FpieeeRecord.Operand3.Value.Fp128Value = FP32ToFP128 (LowHalf(FR2));

          FpieeeRecord.Result.Format = _FpFormatFp32; /* 1 + 8 + 24 bits */
          FpieeeRecord.Result.OperandValid = 1;
          if (LowCause.Underflow) FpieeeRecord.Result.Value.Fp128Value = 
                FP32ToFP128modif (LowHalf (FR1), -0x80);
          else if (LowCause.Overflow) FpieeeRecord.Result.Value.Fp128Value = 
                FP32ToFP128modif (LowHalf (FR1), 0x80);
          else if (LowCause.Inexact) FpieeeRecord.Result.Value.Fp128Value = 
                FP32ToFP128modif (LowHalf (FR1), 0x0);

          FpieeeRecord.Operation = Operation;

          FpieeeRecord.Status.InvalidOperation = LowStatus.InvalidOperation;
          FpieeeRecord.Status.ZeroDivide = LowStatus.ZeroDivide;
          StatusDenormal = LowStatusDenormal;
          FpieeeRecord.Status.Overflow = LowStatus.Overflow;
          FpieeeRecord.Status.Underflow = LowStatus.Underflow;
          FpieeeRecord.Status.Inexact = LowStatus.Inexact;

          FpieeeRecord.Cause.InvalidOperation = LowCause.InvalidOperation;
          FpieeeRecord.Cause.ZeroDivide = LowCause.ZeroDivide; // 0
          CauseDenormal = LowCauseDenormal;
          FpieeeRecord.Cause.Overflow = LowCause.Overflow;
          FpieeeRecord.Cause.Underflow = LowCause.Underflow;
          FpieeeRecord.Cause.Inexact = LowCause.Inexact;

          // before calling the user handler, adjust the result to the
          // range imposed by the format
          if (LowCause.Overflow) {

            FP128ToFPIeee (&FpieeeRecord, -1); // -1 indicates scaling direction

          } else if (LowCause.Underflow) {

            FP128ToFPIeee (&FpieeeRecord, +1); // +1 indicates scaling direction

          } else { // if (LowCause.Inexact) { // }

            FP128ToFPIeee (&FpieeeRecord, 0); // 0 indicates no scaling

          }

          // invoke the user-defined exception handler
          handler_return_value = handler (&FpieeeRecord);

          // return if not EXCEPTION_CONTINUE_EXECUTION
          if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

            __set_fpsr (&old_fpsr); /* restore caller fpsr */
            return (handler_return_value);

          }

          // clear the IEEE exception flags in the FPSR and
          // update the FPSR with values (possibly) set by the user handler
          // for the rounding mode, the precision mode, and the trap enable
          // bits; if the high half needs to be re-executed, the old FPSR
          // will be used; same if it is forwarded to the user-defined handler

          UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F1");
          UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F1");

          // Update the trap disable bits
          V_dis = !FpieeeRecord.Enable.InvalidOperation;
          Z_dis = !FpieeeRecord.Enable.ZeroDivide;
          O_dis = !FpieeeRecord.Enable.Overflow;
          U_dis = !FpieeeRecord.Enable.Underflow;
          I_dis = !FpieeeRecord.Enable.Inexact;
          // Note that D_dis cannot be updated by the IEEE user handler

          FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis
              << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

          // save the result for the low half
          FR1Low = FpieeeRecord.Result.Value.Fp32Value;

        } else { 
          // if not (LowCause.Underflow || LowCause.Overflow || 
          //    LowCause.Inexact)

          // nothing to do for the low half of the instruction - the result
          // is correct

          FR1Low = LowHalf (FR1); // for uniformity

        } // end 'if not (LowCause.Underflow,  Overflow, or Inexact)'


        if (HighCause.Underflow || HighCause.Overflow || HighCause.Inexact) {

          // invoke the user-defined exception handler and check the return 
          // value; since this might be the second call to the user handler,
          // make sure all the _FPIEEE_RECORD fields are correct;
          // return if handler_return_value is not 
          // EXCEPTION_CONTINUE_EXECUTION, otherwise combine the results

          // the rounding mode is the initial one
          FpieeeRecord.RoundingMode = RoundingMode;

          // the precision mode is the initial one
          FpieeeRecord.Precision = Precision;

          // the enable flags are the initial ones
          FPSR = Context->StFPSR;
          V_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 0) & 0x01);
          D_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 1) & 0x01);
          Z_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 2) & 0x01);
          O_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 3) & 0x01);
          U_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 4) & 0x01);
          I_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 5) & 0x01);

          FpieeeRecord.Enable.InvalidOperation = !V_dis;
          EnableDenormal = !D_dis;
          FpieeeRecord.Enable.ZeroDivide = !Z_dis;
          FpieeeRecord.Enable.Overflow = !O_dis;
          FpieeeRecord.Enable.Underflow = !U_dis;
          FpieeeRecord.Enable.Inexact = !I_dis;

          FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1+8+24 bits */
          FpieeeRecord.Operand1.OperandValid = 1;
          FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128(HighHalf(FR3));
          FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1+8+24 bits */
          FpieeeRecord.Operand2.OperandValid = 1;
          FpieeeRecord.Operand2.Value.Fp128Value = FP32ToFP128(HighHalf(FR4));
          FpieeeRecord.Operand3.Format = _FpFormatFp82; /* 1+8+24 bits */
          FpieeeRecord.Operand3.OperandValid = 1;
          FpieeeRecord.Operand3.Value.Fp128Value = FP32ToFP128(HighHalf(FR2));

          FpieeeRecord.Result.Format = _FpFormatFp32; /* 1 + 8 + 24 bits */
          FpieeeRecord.Result.OperandValid = 1;
          if (HighCause.Underflow) FpieeeRecord.Result.Value.Fp128Value = 
                FP32ToFP128modif (HighHalf (FR1), -0x80);
          else if (HighCause.Overflow) FpieeeRecord.Result.Value.Fp128Value = 
                FP32ToFP128modif (HighHalf (FR1), 0x80);
          else if (HighCause.Inexact) FpieeeRecord.Result.Value.Fp128Value = 
                FP32ToFP128modif (HighHalf (FR1), 0x0);

          FpieeeRecord.Operation = Operation;

          // use the initial values
          FpieeeRecord.Status.InvalidOperation = HighStatus.InvalidOperation;
          FpieeeRecord.Status.ZeroDivide = HighStatus.ZeroDivide;
          FpieeeRecord.Status.Overflow = HighStatus.Overflow;
          FpieeeRecord.Status.Underflow = HighStatus.Underflow;
          FpieeeRecord.Status.Inexact = HighStatus.Inexact;

          FpieeeRecord.Cause.InvalidOperation = HighCause.InvalidOperation;
          FpieeeRecord.Cause.ZeroDivide = HighCause.ZeroDivide; // 0
          FpieeeRecord.Cause.Overflow = HighCause.Overflow;
          FpieeeRecord.Cause.Underflow = HighCause.Underflow;
          FpieeeRecord.Cause.Inexact = HighCause.Inexact;

          // before calling the user handler, adjust the result to the
          // range imposed by the format
          if (HighCause.Overflow) {

            FP128ToFPIeee (&FpieeeRecord, -1); // -1 indicates scaling direction

          } else if (HighCause.Underflow) {

            FP128ToFPIeee (&FpieeeRecord, +1); // +1 indicates scaling direction

          } else { // if (HighCause.Inexact) { // }

            FP128ToFPIeee (&FpieeeRecord, 0); // 0 indicates no scaling

          }

          // invoke the user-defined exception handler
          handler_return_value = handler (&FpieeeRecord);

          // return if not EXCEPTION_CONTINUE_EXECUTION
          if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

            __set_fpsr (&old_fpsr); /* restore caller fpsr */
            return (handler_return_value);

          }

          // update the FPSR with values (possibly) set by the user handler
          // for the rounding mode, the precision mode, and the trap enable
          // bits; if the high half needs to be re-executed, the old FPSR
          // will be used; same if it is forwarded to the user-defined handler

          /* change the FPSR with values (possibly) set by the user handler,
           * for continuing execution where the interruption occured */
  
          UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F1");
          UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F1");
  
          I_dis = !FpieeeRecord.Enable.Inexact;
          U_dis = !FpieeeRecord.Enable.Underflow;
          O_dis = !FpieeeRecord.Enable.Overflow;
          Z_dis = !FpieeeRecord.Enable.ZeroDivide;
          V_dis = !FpieeeRecord.Enable.InvalidOperation;
          // Note that D_dis cannot be updated by the IEEE user handler

          FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis
              << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

          // save the result for the high half
          FR1High = FpieeeRecord.Result.Value.Fp32Value;

        } else { 
          // if not (HighCause.Underflow, Overflow, or Inexact)

          // nothing to do for the high half of the instruction - the result
          // is correct

          FR1High = HighHalf (FR1); // for uniformity

        } // end 'if not (HighCause.Underflow, Overflow, or Inexact)'

        if (!LowCause.Underflow && !LowCause.Overflow && !LowCause.Inexact &&
            !HighCause.Underflow && !HighCause.Overflow && 
            !HighCause.Inexact) {

          // should never get here
          fprintf (stderr, "IEEE Filter Internal Error: no enabled \
              [multiple trap] exception recognized in F1 instruction\n");
          exit (1);

        }

        // set the result
        Context->StFPSR = FPSR;

        // set the result before continuing execution
        FR1 = Combine (FR1High, FR1Low);
        SetFloatRegisterValue (f1, FR1, Context);
        if (f1 < 32)
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl
        else
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh

      } // else { ; } // this case was caught above

    }

  } else if ((OpCode & F4_MIN_MASK) == F4_PATTERN) {
    /* F4 instruction, always non-SIMD */
    // FCMP

#ifdef FPIEEE_FLT_DEBUG
    printf ("FPIEEE_FLT_DEBUG: F4 instruction\n");
#endif

    if (FpieeeRecord.Cause.ZeroDivide ||
        FpieeeRecord.Cause.Overflow ||
        FpieeeRecord.Cause.Underflow ||
        FpieeeRecord.Cause.Inexact) {
      fprintf (stderr, "IEEE Filter Internal Error: Cause.ZeroDivide, \
Cause.Overflow, Cause.Underflow, or Cause.Inexact for \
F4 instruction opcode %8x %8x\n",
          (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
      exit (1);
    }

    /* ignore the EM computation model */

    /* extract p1, p2, f2, and f3 */
    p1 = (unsigned int)((OpCode >>  6) & (unsigned __int64)0x00000000003F);
    if (p1 >= 16) p1 = 16 + (rrbpr + p1 - 16) % 48;
    p2 = (unsigned int)((OpCode >> 27) & (unsigned __int64)0x00000000003f);
    if (p2 >= 16) p2 = 16 + (rrbpr + p2 - 16) % 48;
    f2 = (unsigned int)((OpCode >> 13) & (unsigned __int64)0x00000000007F);
    if (f2 >= 32) f2 = 32 + (rrbfr + f2 - 32) % 96;
    f3 = (unsigned int)((OpCode >> 20) & (unsigned __int64)0x00000000007F);
    if (f3 >= 32) f3 = 32 + (rrbfr + f3 - 32) % 96;

    /* get source floating-point register values */
    FR2 = GetFloatRegisterValue (f2, Context);
    FR3 = GetFloatRegisterValue (f3, Context);

    if (FpieeeRecord.Cause.InvalidOperation || CauseDenormal) {

      // *** this is a non-SIMD instruction ***

      FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
      FpieeeRecord.Operand1.OperandValid = 1;
      FpieeeRecord.Operand1.Value.Fp128Value = FR2;
      FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
      FpieeeRecord.Operand2.OperandValid = 1;
      FpieeeRecord.Operand2.Value.Fp128Value = FR3;
      FpieeeRecord.Operand3.OperandValid = 0;

      switch (OpCode & F4_MASK) {

        case FCMP_EQ_PATTERN:
        case FCMP_LT_PATTERN:
        case FCMP_LE_PATTERN:
        case FCMP_UNORD_PATTERN:
        case FCMP_EQ_UNC_PATTERN:
        case FCMP_LT_UNC_PATTERN:
        case FCMP_LE_UNC_PATTERN:
        case FCMP_UNORD_UNC_PATTERN:
          FpieeeRecord.Operation = _FpCodeCompare;
          FpieeeRecord.Result.Format = _FpFormatCompare;
          break;
  
        default:
          /* unrecognized instruction type */
          fprintf (stderr, "IEEE Filter Internal Error: \
              instruction opcode %8x %8x not recognized\n", 
              (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
          exit (1);

      }

      /* this is a fault - the result contains an invalid value */
      FpieeeRecord.Result.OperandValid = 0;

      handler_return_value = handler (&FpieeeRecord);

      if (handler_return_value == EXCEPTION_CONTINUE_EXECUTION) {

        // set the values of the result predicates
        switch (OpCode & F4_MASK) {
    
          case FCMP_EQ_PATTERN:
          case FCMP_EQ_UNC_PATTERN:
    
            switch (FpieeeRecord.Result.Value.CompareValue) {

              case _FpCompareEqual:
                PR1 = 1;
                PR2 = 0;
                break;

              case _FpCompareGreater:
              case _FpCompareLess:
              case _FpCompareUnordered:
                PR1 = 0;
                PR2 = 1;
                break;

              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F4 instruction\n", 
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
    
            }
            break;
    
          case FCMP_LT_PATTERN:
          case FCMP_LT_UNC_PATTERN:
    
            switch (FpieeeRecord.Result.Value.CompareValue) {
    
              case _FpCompareLess:
                PR1 = 1;
                PR2 = 0;
                break;
    
              case _FpCompareEqual:
              case _FpCompareGreater:
              case _FpCompareUnordered:
                PR1 = 0;
                PR2 = 1;
                break;
    
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F4 instruction\n", 
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
    
            }
    
            break;
    
          case FCMP_LE_PATTERN:
          case FCMP_LE_UNC_PATTERN:
    
            switch (FpieeeRecord.Result.Value.CompareValue) {
    
              case _FpCompareEqual:
              case _FpCompareLess:
                PR1 = 1;
                PR2 = 0;
                break;
    
              case _FpCompareGreater:
              case _FpCompareUnordered:
                PR1 = 0;
                PR2 = 1;
                break;
    
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F4 instruction\n", 
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
    
            }
    
            break;
    
          case FCMP_UNORD_PATTERN:
          case FCMP_UNORD_UNC_PATTERN:
    
            switch (FpieeeRecord.Result.Value.CompareValue) {
    
              case _FpCompareUnordered:
                PR1 = 1;
                PR2 = 0;
                break;
    
              case _FpCompareEqual:
              case _FpCompareLess:
              case _FpCompareGreater:
                PR1 = 0;
                PR2 = 1;
                break;
    
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F4 instruction\n", 
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
    
            }
    
            break;
    
          default:
            // never gets here - this case filtered above
            fprintf (stderr, "IEEE Filter Internal Error: \
                instruction opcode %8x %8x is not valid at this point\n", 
                (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
            exit (1);
    
        }

        /* change the FPSR with values (possibly) set by the user handler, 
         * for continuing execution where the interruption occured */

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F4");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F4");

        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;
        // Note that D_dis cannot be updated by the IEEE user handler

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis 
            << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        Context->StFPSR = FPSR;

        // set the destination predicate register values before 
        // continuing execution
        Context->Preds &= (~(((unsigned __int64)1) << p1));
        Context->Preds |= (((unsigned __int64)(PR1 & 0x01)) << p1);
        Context->Preds &= (~(((unsigned __int64)1) << p2));
        Context->Preds |= (((unsigned __int64)(PR2 & 0x01)) << p2);

        // this is a fault - need to advance the instruction pointer
        if (ei == 0) { // no template for this case
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000020000000000;
        } else if (ei == 1) { // templates: MFI, MFB
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000040000000000;
        } else { // if (ei == 2) // templates: MMF
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIIP = Context->StIIP + 0x10;
        }

      }

    } else {

      fprintf (stderr, "IEEE Filter Internal Error: \
          exception code %x invalid or not recognized in F4 instruction\n",
          eXceptionCode);
      exit (1);

    }

  } else if ((OpCode & F6_MIN_MASK) == F6_PATTERN) {
    /* F6 instruction */
    // FRCPA, FPRCPA

#ifdef FPIEEE_FLT_DEBUG
    printf ("FPIEEE_FLT_DEBUG: F6 instruction\n");
#endif

    /* Note: the IEEE filter should be reached for these instructions
     * only when the value of  FR[f2]/FR[f3] is expected */

    /* extract p2, f3, f2, and f1 */
    p2 = (unsigned int)((OpCode >> 27) & (unsigned __int64)0x00000000003f);
    if (p2 >= 16) p2 = 16 + (rrbpr + p2 - 16) % 48;
    f3 = (unsigned int)((OpCode >> 20) & (unsigned __int64)0x00000000007F);
    if (f3 >= 32) f3 = 32 + (rrbfr + f3 - 32) % 96;
    f2 = (unsigned int)((OpCode >> 13) & (unsigned __int64)0x00000000007F);
    if (f2 >= 32) f2 = 32 + (rrbfr + f2 - 32) % 96;
    f1 = (unsigned int)((OpCode >>  6) & (unsigned __int64)0x00000000007F);
    if (f1 >= 32) f1 = 32 + (rrbfr + f1 - 32) % 96;

#ifdef FPIEEE_FLT_DEBUG
    printf ("FPIEEE_FLT_DEBUG: f1 = %x\n", f1);
    printf ("FPIEEE_FLT_DEBUG: f2 = %x\n", f2);
    printf ("FPIEEE_FLT_DEBUG: f3 = %x\n", f3);
    printf ("FPIEEE_FLT_DEBUG: p2 = %x\n", p2);
#endif

    /* get source floating-point register values */
    FR2 = GetFloatRegisterValue (f2, Context);
    FR3 = GetFloatRegisterValue (f3, Context);

    if (!SIMD_instruction) {

      // *** this is a non-SIMD instruction, FRCPA ***

      FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
      FpieeeRecord.Operand1.OperandValid = 1;
      FpieeeRecord.Operand1.Value.Fp128Value = FR2;
      FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
      FpieeeRecord.Operand2.OperandValid = 1;
      FpieeeRecord.Operand2.Value.Fp128Value = FR3;
      FpieeeRecord.Operand3.OperandValid = 0;

      switch (OpCode & F6_MASK) {

        case FRCPA_PATTERN:
          FpieeeRecord.Operation = _FpCodeDivide;
          FpieeeRecord.Result.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
          break;

        default:
          /* unrecognized instruction type */
          fprintf (stderr, "IEEE Filter Internal Error: \
              instruction opcode %8x %8x not recognized for FRCPA\n", 
              (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
          exit (1);

      }

      if (FpieeeRecord.Cause.InvalidOperation || CauseDenormal ||
          FpieeeRecord.Cause.ZeroDivide) {

        /* this is a fault - the result contains an invalid value */
        FpieeeRecord.Result.OperandValid = 0;

      } else if (FpieeeRecord.Cause.Overflow ||
          FpieeeRecord.Cause.Underflow ||
          FpieeeRecord.Cause.Inexact) {

        // this is a trap - the result contains a valid value
        FpieeeRecord.Result.OperandValid = 1;
        // get the result
        FpieeeRecord.Result.Value.Fp128Value =
            GetFloatRegisterValue (f1, Context);
        if (FpieeeRecord.Cause.Overflow)
            FP128ToFPIeee (&FpieeeRecord, -1); // -1 indicates scaling direction
        if (FpieeeRecord.Cause.Underflow)
            FP128ToFPIeee (&FpieeeRecord, +1); // +1 indicates scaling direction

      } else {

        // should never get here - this case was filtered above
        fprintf (stderr, "IEEE Filter Internal Error: exception cause invalid \
            or not recognized in F6 instruction; ISRlow = %x\n", ISRlow);
         exit (1);

      }

      handler_return_value = handler (&FpieeeRecord);

      // convert the result to 82-bit format
      FR1 = FPIeeeToFP128 (&FpieeeRecord);
#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG 2: CONVERTED FR1 = %08x %08x %08x %08x\n",
            FR1.W[3], FR1.W[2], FR1.W[1], FR1.W[0]);
#endif

      if (handler_return_value == EXCEPTION_CONTINUE_EXECUTION) {

        // set the result predicate
        PR2 = 0;

        /* change the FPSR with values (possibly) set by the user handler, 
         * for continuing execution where the interruption occured */

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F6");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F6");

        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis 
            << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        Context->StFPSR = FPSR;

        // set the result before continuing execution
#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG F6: WILL SetFloatRegisterValue f1 = 0x%x FR1 = %08x %08x %08x %08x\n",
            f1, FR1.W[3], FR1.W[2], FR1.W[1], FR1.W[0]);
#endif
        SetFloatRegisterValue (f1, FR1, Context);
        if (f1 < 32)
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl bit
        else
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh bit
        Context->Preds &= (~(((unsigned __int64)1) << p2));
        Context->Preds |= (((unsigned __int64)(PR2 & 0x01)) << p2);

      }

      // if this is a fault, need to advance the instruction pointer
      if (FpieeeRecord.Cause.InvalidOperation || CauseDenormal ||
          FpieeeRecord.Cause.ZeroDivide) {

        if (ei == 0) { // no template for this case
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000020000000000;
        } else if (ei == 1) { // templates: MFI, MFB
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000040000000000;
        } else { // if (ei == 2) // templates: MMF
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIIP = Context->StIIP + 0x10;
        }

      }

    } else { // if (SIMD_instruction)

      // *** this is a SIMD instruction, FPRCPA ***

      // the half (halves) of the instruction that caused an enabled exception, 
      // are presented to the user-defined handler in the form of non-SIMD in-
      // struction(s); the half (if any) that did not cause an enabled exception
      // (i.e. caused no exception, or caused an exception that is disabled),
      // is re-executed since it is associated with a fault in the other half;
      // the other half is padded to calculate 1.0 / 1.0, that will cause no 
      // exception

      switch (OpCode & F6_MASK) {

        case FPRCPA_PATTERN:
          Operation = _FpCodeDivide;
          break;

        default:
          /* unrecognized instruction type */
          fprintf (stderr, "IEEE Filter Internal Error: SIMD \
              instruction opcode %8x %8x not recognized as FPRCPA\n", 
              (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
          exit (1);

      }

      // hand the half (halves) that caused an enabled fault to the 
      // user handler; re-execute the other half (if any);
      // combine the results

      // Note that the convention chosen is for the processing to be 
      // performed in the order low first, high second, as SIMD operands
      // are stored in this order in memory in the little endian format 
      // (this order would have to be changed for big endian)

      if (LowCause.InvalidOperation || LowCauseDenormal ||
          LowCause.ZeroDivide) {

        // invoke the user handler and check the return value

        // fill in the remaining fields of the _FPIEEE_RECORD (rounding
        // and precision already filled in)

        FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
        FpieeeRecord.Operand1.OperandValid = 1;
        FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128 (LowHalf (FR2));
        FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
        FpieeeRecord.Operand2.OperandValid = 1;
        FpieeeRecord.Operand2.Value.Fp128Value = FP32ToFP128 (LowHalf (FR3));
        FpieeeRecord.Operand3.OperandValid = 0;

        FpieeeRecord.Result.Format = _FpFormatFp32; /* 1 + 8 + 24 bits */
        FpieeeRecord.Result.OperandValid = 0;

        FpieeeRecord.Operation = Operation;

        FpieeeRecord.Status.Inexact = LowStatus.Inexact;
        FpieeeRecord.Status.Underflow = LowStatus.Underflow;
        FpieeeRecord.Status.Overflow = LowStatus.Overflow;
        StatusDenormal = LowStatusDenormal;
        FpieeeRecord.Status.ZeroDivide = LowStatus.ZeroDivide;
        FpieeeRecord.Status.InvalidOperation = LowStatus.InvalidOperation;

        FpieeeRecord.Cause.Inexact = LowCause.Inexact;
        FpieeeRecord.Cause.Underflow = LowCause.Underflow;
        FpieeeRecord.Cause.Overflow = LowCause.Overflow;
        CauseDenormal = LowCauseDenormal;
        FpieeeRecord.Cause.ZeroDivide = LowCause.ZeroDivide;
        FpieeeRecord.Cause.InvalidOperation = LowCause.InvalidOperation;

        // invoke the user-defined exception handler
        handler_return_value = handler (&FpieeeRecord);

        // return if not EXCEPTION_CONTINUE_EXECUTION
        if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

          __set_fpsr (&old_fpsr); /* restore caller fpsr */
          return (handler_return_value);

        }

        // clear the IEEE exception flags in the FPSR and
        // update the FPSR with values (possibly) set by the user handler
        // for the rounding mode, the precision mode, and the trap enable
        // bits; if the high half needs to be re-executed, the new FPSR
        // will be used, with status flags cleared; if it is 
        // forwarded to the user-defined handler, the new rounding and 
        // precision modes are also used (they are
        // already set in FpieeeRecord)

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F6");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F6");

        // Update the trap disable bits
        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis
            << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        // save the result for the low half
        FR1Low = FpieeeRecord.Result.Value.Fp32Value;

        // since there has been a call to the user handler and the FPSR 
        // might have changed (the Enable bits in particular), recalculate
        // the Cause bits (if the HighEnable-s changed, there might be a 
        // change in the HighCause values) 
        // Note that the Status bits used are the original ones

        HighCause.Inexact = 0;
        HighCause.Underflow = 0;
        HighCause.Overflow = 0;
        HighCause.ZeroDivide =
            FpieeeRecord.Enable.ZeroDivide && HighStatus.ZeroDivide;
        HighCauseDenormal = EnableDenormal && HighStatusDenormal;
        HighCause.InvalidOperation =
            FpieeeRecord.Enable.InvalidOperation &&
            HighStatus.InvalidOperation;

      } else { // if not (LowCause.InvalidOperation || LowCauseDenormal ||
          // LowCause.ZeroDivide)

        // do not re-execute the low half of the instruction - it would only
        // return an approximation of 1 / (low FR3); calculate instead the 
        // quotient (low FR2) / (low FR3) in single precision, using the 
        // correct rounding mode (the low half of the instruction did not 
        // cause any exception)

        // extract the low halves of FR2 and FR3
        FR2Low = LowHalf (FR2);
        FR3Low = LowHalf (FR3);

        // employ the user FPSR when calling _thmB; note that
        // the exception masks are those set by the user, and that an
        // underflow, overflow, or inexact exception might be raised

        // perform the single precision divide
        _thmB (&FR2Low, &FR3Low, &FR1Low, &FPSR); // FR1Low = FR2Low / FR3Low

#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG: F6 low res _thmB = %f = %x\n",
            FR1Low, *(unsigned int *)&FR1Low);
#endif

      } // end 'if not (LowCause.InvalidOperation || LowCauseDenormal ||
          // LowCause.ZeroDivide)'

      if (HighCause.InvalidOperation || HighCauseDenormal ||
          HighCause.ZeroDivide) {

        // invoke the user-defined exception handler and check the return 
        // value; since this might be the second call to the user handler,
        // make sure all the _FPIEEE_RECORD fields are correct;
        // return if handler_return_value is not
        // EXCEPTION_CONTINUE_EXECUTION, otherwise combine the results

        // the rounding mode is either the initial one, or the one
        // set during the call to the user handler for the low half,
        // if there has been an enabled exception for it

        // the precision mode is either the initial one, or the one
        // set during the call to the user handler for the low half,
        // if there has been an enabled exception for it

        // the enable flags are either the initial ones, or the ones
        // set during the call to the user handler for the low half,
        // if there has been an enabled exception for it

        FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1+8+24 bits */
        FpieeeRecord.Operand1.OperandValid = 1;
        FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128 (HighHalf (FR2));
        FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1+8+24 bits */
        FpieeeRecord.Operand2.OperandValid = 1;
        FpieeeRecord.Operand2.Value.Fp128Value = FP32ToFP128 (HighHalf (FR3));
        FpieeeRecord.Operand3.OperandValid = 0;

        FpieeeRecord.Result.Format = _FpFormatFp32; /* 1 + 8 + 24 bits */
        FpieeeRecord.Result.OperandValid = 0;

        FpieeeRecord.Operation = Operation;

        FpieeeRecord.Status.Inexact = HighStatus.Inexact;
        FpieeeRecord.Status.Underflow = HighStatus.Underflow;
        FpieeeRecord.Status.Overflow = HighStatus.Overflow;
        StatusDenormal = HighStatusDenormal;
        FpieeeRecord.Status.ZeroDivide = HighStatus.ZeroDivide;
        FpieeeRecord.Status.InvalidOperation = HighStatus.InvalidOperation;

        FpieeeRecord.Cause.Inexact = HighCause.Inexact;
        FpieeeRecord.Cause.Underflow = HighCause.Underflow;
        FpieeeRecord.Cause.Overflow = HighCause.Overflow;
        CauseDenormal = HighCauseDenormal;
        FpieeeRecord.Cause.ZeroDivide = HighCause.ZeroDivide;
        FpieeeRecord.Cause.InvalidOperation = HighCause.InvalidOperation;

        // invoke the user-defined exception handler
        handler_return_value = handler (&FpieeeRecord);

        // return if not EXCEPTION_CONTINUE_EXECUTION
        if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

          __set_fpsr (&old_fpsr); /* restore caller fpsr */
          return (handler_return_value);

        }

        // clear the IEEE exception flags in the FPSR and
        // update the FPSR with values (possibly) set by the user handler
        // for the rounding mode, the precision mode, and the trap enable
        // bits; if the high half needs to be re-executed, the new FPSR
        // will be used, with status flags cleared; if it is
        // forwarded to the user-defined handler, the new rounding and
        // precision modes are also used (they are
        // already set in FpieeeRecord)

        /* change the FPSR with values (possibly) set by the user handler,
         * for continuing execution where the interruption occured */

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F6");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F6");

        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis 
            << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        // save the result for the high half
        FR1High = FpieeeRecord.Result.Value.Fp32Value;

      } else { //if not (HighCause.InvalidOperation || HighCauseDenormal ||
          // HighCause.ZeroDivide)

        // do not re-execute the high half of the instruction - it would only
        // return an approximation of 1 / (high FR3); calculate instead the 
        // quotient (high FR2) / (high FR3) in single precision, using the 
        // correct rounding mode (the high half of the instruction did not 
        // cause any exception)

        // extract the high halves of FR2 and FR3
        FR2High = HighHalf (FR2);
        FR3High = HighHalf (FR3);

        // employ the user FPSR when calling _thmB; note that
        // the exception masks are those set by the user, and that an
        // underflow, overflow, or inexact exception might be raised

        // perform the single precision divide
        _thmB (&FR2High, &FR3High, &FR1High, &FPSR); // FR1High = FR2High/FR3High

#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG: F6 high res from _thmB = %f = %x\n",
            FR1High, *(unsigned int *)&FR1High);
#endif

      } // end 'if not (HighCause.InvalidOperation || HighCauseDenormal ||
          // HighCause.ZeroDivide)'

      if (!LowCause.InvalidOperation && !LowCause.ZeroDivide &&
          !LowCauseDenormal && !HighCause.InvalidOperation && 
          !HighCauseDenormal && !HighCause.ZeroDivide) {

        // should never get here
        fprintf (stderr, "IEEE Filter Internal Error: no enabled \
            exception (multiple fault) recognized in F6 instruction\n");
        exit (1);

      }

      // set the result predicate
      PR2 = 0;

      Context->StFPSR = FPSR;

      FR1 = Combine (FR1High, FR1Low);
      // set the results before continuing execution
      SetFloatRegisterValue (f1, FR1, Context);
      if (f1 < 32)
        Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl bit
      else
        Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh bit
      Context->Preds &= (~(((unsigned __int64)1) << p2));
      Context->Preds |= (((unsigned __int64)(PR2 & 0x01)) << p2);

      // if this is a fault, need to advance the instruction pointer
      if (FpieeeRecord.Cause.InvalidOperation || CauseDenormal ||
          FpieeeRecord.Cause.ZeroDivide) {

        if (ei == 0) { // no template for this case
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000020000000000;
        } else if (ei == 1) { // templates: MFI, MFB
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000040000000000;
        } else { // if (ei == 2) // templates: MMF
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIIP = Context->StIIP + 0x10;
        }

      }

    }

  } else if ((OpCode & F7_MIN_MASK) == F7_PATTERN) {
    /* F7 instruction */
    // FRSQRTA, FPRSQRTA

#ifdef FPIEEE_FLT_DEBUG
    printf ("FPIEEE_FLT_DEBUG: F7 instruction\n");
#endif

    if (!SIMD_instruction && 
        (FpieeeRecord.Cause.ZeroDivide ||
        FpieeeRecord.Cause.Overflow ||
        FpieeeRecord.Cause.Underflow) ||
        SIMD_instruction && 
        (LowCause.ZeroDivide || HighCause.ZeroDivide ||
        LowCause.Overflow || HighCause.Overflow ||
        LowCause.Underflow || HighCause.Underflow)) {
      fprintf (stderr, "IEEE Filter Internal Error: Cause.ZeroDivide, \
Cause.Overflow, or Cause.Underflow for \
F7 instruction opcode %8x %8x\n",
          (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
      exit (1);
    }

    /* Note: the IEEE filter should be reached for these instructions
     * only when the value of  sqrt(FR3) is expected */

    /* extract p2, f3, and f1 */
    p2 = (unsigned int)((OpCode >> 27) & (unsigned __int64)0x00000000003f);
    if (p2 >= 16) p2 = 16 + (rrbpr + p2 - 16) % 48;
    f3 = (unsigned int)((OpCode >> 20) & (unsigned __int64)0x00000000007F);
    if (f3 >= 32) f3 = 32 + (rrbfr + f3 - 32) % 96;
    f1 = (unsigned int)((OpCode >>  6) & (unsigned __int64)0x00000000007F);
    if (f1 >= 32) f1 = 32 + (rrbfr + f1 - 32) % 96;

    /* get source floating-point register value */
    FR3 = GetFloatRegisterValue (f3, Context);

    if (!SIMD_instruction) {

      // *** this is a non-SIMD instruction, FRSQRTA ***

      FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
      FpieeeRecord.Operand1.OperandValid = 1;
      FpieeeRecord.Operand1.Value.Fp128Value = FR3;
      FpieeeRecord.Operand2.OperandValid = 0;
      FpieeeRecord.Operand3.OperandValid = 0;

      switch (OpCode & F7_MASK) {

        case FRSQRTA_PATTERN:
          FpieeeRecord.Operation = _FpCodeSquareRoot;
          FpieeeRecord.Result.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
          break;

        default:
          /* unrecognized instruction type */
          fprintf (stderr, "IEEE Filter Internal Error: \
              instruction opcode %8x %8x not recognized for FRSQRTA\n", 
              (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
          exit (1);

      }

      if (FpieeeRecord.Cause.InvalidOperation || CauseDenormal) {

        /* this is a fault - the result contains an invalid value */
        FpieeeRecord.Result.OperandValid = 0;

      } else if (FpieeeRecord.Cause.Inexact) {

        // this is a trap - the result contains a valid value
        FpieeeRecord.Result.OperandValid = 1;
        // get the result
        FpieeeRecord.Result.Value.Fp128Value =
            GetFloatRegisterValue (f1, Context);

      } else {

        fprintf (stderr, "IEEE Filter Internal Error: exception code %x invalid\
          or not recognized in F7 instruction\n", eXceptionCode);
        exit (1);

      }

      handler_return_value = handler (&FpieeeRecord);

      if (handler_return_value == EXCEPTION_CONTINUE_EXECUTION) {

        // convert the result to 82-bit format
        FR1 = FPIeeeToFP128 (&FpieeeRecord);
#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG 3: CONVERTED FR1 = %08x %08x %08x %08x\n",
            FR1.W[3], FR1.W[2], FR1.W[1], FR1.W[0]);
#endif

        /* change the FPSR with values (possibly) set by the user handler, 
         * for continuing execution where the interruption occured */

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F7");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F7");

        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis
            << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        Context->StFPSR = FPSR;

        // set the result before continuing execution
        SetFloatRegisterValue (f1, FR1, Context);
        if (f1 < 32)
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl bit
        else
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh bit
        PR2 = 0;
        Context->Preds &= (~(((unsigned __int64)1) << p2));
        Context->Preds |= (((unsigned __int64)(PR2 & 0x01)) << p2);

        // if this is a fault, need to advance the instruction pointer
        if (FpieeeRecord.Cause.InvalidOperation || CauseDenormal) {

          if (ei == 0) { // no template for this case
            Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
            Context->StIPSR = Context->StIPSR | 0x0000020000000000;
          } else if (ei == 1) { // templates: MFI, MFB
            Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
            Context->StIPSR = Context->StIPSR | 0x0000040000000000;
          } else { // if (ei == 2) // templates: MMF
            Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
            Context->StIIP = Context->StIIP + 0x10;
          }

        }

      }

    } else { // if (SIMD_instruction)

      // *** this is a SIMD instruction, FPRSQRTA ***

      // the half (halves) of the instruction that caused an enabled exception, 
      // are presented to the user-defined handler in the form of non-SIMD in-
      // struction(s); the half (if any) that did not cause an enabled exception
      // (i.e. caused no exception, or caused an exception that is disabled),
      // is re-executed since it is associated with a fault in the other half;
      // the other half is padded to calculate sqrt (0.0), that will cause no 
      // exception (all are masked), but will generate a pair of square roots
      // in FR1

      switch (OpCode & F7_MASK) {

        case FPRSQRTA_PATTERN:
          Operation = _FpCodeSquareRoot;
          break;

        default:
          /* unrecognized instruction type */
          fprintf (stderr, "IEEE Filter Internal Error: SIMD \
              instruction opcode %8x %8x not recognized as FPRSQRTA\n", 
              (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
          exit (1);

      }

      // hand the half (halves) that caused an enabled fault to the 
      // user handler; re-execute the other half (if any);
      // combine the results

      // Note that the convention chosen is for the processing to be 
      // performed in the order low first, high second, as SIMD operands
      // are stored in this order in memory in the little endian format 
      // (this order would have to be changed for big endian)

      if (LowCause.InvalidOperation || LowCauseDenormal) {

        // invoke the user handler and check the return value

        // fill in the remaining fields of the _FPIEEE_RECORD (rounding
        // and precision already filled in)

        FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
        FpieeeRecord.Operand1.OperandValid = 1;
        FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128 (LowHalf (FR3));
        FpieeeRecord.Operand2.OperandValid = 0;
        FpieeeRecord.Operand3.OperandValid = 0;

        FpieeeRecord.Result.Format = _FpFormatFp32; /* 1 + 8 + 24 bits */
        FpieeeRecord.Result.OperandValid = 0;

        FpieeeRecord.Operation = Operation;

        FpieeeRecord.Status.Inexact = LowStatus.Inexact;
        FpieeeRecord.Status.Underflow = LowStatus.Underflow;
        FpieeeRecord.Status.Overflow = LowStatus.Overflow;
        StatusDenormal = LowStatusDenormal;
        FpieeeRecord.Status.ZeroDivide = LowStatus.ZeroDivide;
        FpieeeRecord.Status.InvalidOperation = LowStatus.InvalidOperation;

        FpieeeRecord.Cause.Inexact = LowCause.Inexact;
        FpieeeRecord.Cause.Underflow = LowCause.Underflow;
        FpieeeRecord.Cause.Overflow = LowCause.Overflow;
        CauseDenormal = LowCauseDenormal;
        FpieeeRecord.Cause.ZeroDivide = LowCause.ZeroDivide;
        FpieeeRecord.Cause.InvalidOperation = LowCause.InvalidOperation;

        // invoke the user-defined exception handler
        handler_return_value = handler (&FpieeeRecord);

        // return if not EXCEPTION_CONTINUE_EXECUTION
        if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

          __set_fpsr (&old_fpsr); /* restore caller fpsr */
          return (handler_return_value);

        }

        // clear the IEEE exception flags in the FPSR and
        // update the FPSR with values (possibly) set by the user handler
        // for the rounding mode, the precision mode, and the trap enable
        // bits; if the high half needs to be re-executed, the new FPSR
        // will be used, with status flags cleared; if it is 
        // forwarded to the user-defined handler, the new rounding and 
        // precision modes are also used (they are
        // already set in FpieeeRecord)

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F7");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F7");

        // Update the trap disable bits
        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis
            << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        // save the result for the low half
        FR1Low = FpieeeRecord.Result.Value.Fp32Value;

        // since there has been a call to the user handler and the FPSR 
        // might have changed (the Enable bits in particular), recalculate
        // the Cause bits (if the HighEnable-s changed, there might be a 
        // change in the HighCause values) 
        // Note that the Status bits used are the original ones

        HighCause.Inexact = 0;
        HighCause.Underflow = 0;
        HighCause.Overflow = 0;
        HighCause.ZeroDivide =
            FpieeeRecord.Enable.ZeroDivide && HighStatus.ZeroDivide;
        HighCauseDenormal = EnableDenormal && HighStatusDenormal;
        HighCause.InvalidOperation =
            FpieeeRecord.Enable.InvalidOperation &&
            HighStatus.InvalidOperation;

      } else { // if not (LowCause.InvalidOperation || LowCauseDenormal)

        // do not re-execute the low half of the instruction - it would only
        // return an approximation of 1 / sqrt (low FR3); calculate instead
        // sqrt (low FR3) in single precision, using the correct rounding mode
        // (the low half of the instruction did not cause any exception)

        // extract the low half of FR3
        FR3Low = LowHalf (FR3);

        // employ the user FPSR when calling _thmH; note that
        // the exception masks are those set by the user, and that an
        // inexact exception might be raised

        // perform the single precision square root
        _thmH (&FR3Low, &FR1Low, &FPSR); // FR1Low = sqrt (FR3Low)

#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG: F7 low res from _thmH = %f = %x\n",
            FR1Low, *(unsigned int *)&FR1Low);
#endif

      } // end 'if not (LowCause.InvalidOperation || LowCauseDenormal)'

      if (HighCause.InvalidOperation || HighCauseDenormal) {

        // invoke the user-defined exception handler and check the return 
        // value; since this might be the second call to the user handler,
        // make sure all the _FPIEEE_RECORD fields are correct;
        // return if handler_return_value is not
        // EXCEPTION_CONTINUE_EXECUTION, otherwise combine the results

        // the rounding mode is either the initial one, or the one
        // set during the call to the user handler for the low half,
        // if there has been an enabled exception for it

        // the precision mode is either the initial one, or the one
        // set during the call to the user handler for the low half,
        // if there has been an enabled exception for it

        // the enable flags are either the initial ones, or the ones
        // set during the call to the user handler for the low half,
        // if there has been an enabled exception for it

        FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1+8+24 bits */
        FpieeeRecord.Operand1.OperandValid = 1;
        FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128 (HighHalf (FR3));
        FpieeeRecord.Operand2.OperandValid = 0;
        FpieeeRecord.Operand3.OperandValid = 0;

        FpieeeRecord.Result.Format = _FpFormatFp32; /* 1 + 8 + 24 bits */
        FpieeeRecord.Result.OperandValid = 0;

        FpieeeRecord.Operation = Operation;

        FpieeeRecord.Status.Inexact = HighStatus.Inexact;
        FpieeeRecord.Status.Underflow = HighStatus.Underflow;
        FpieeeRecord.Status.Overflow = HighStatus.Overflow;
        StatusDenormal = HighStatusDenormal;
        FpieeeRecord.Status.ZeroDivide = HighStatus.ZeroDivide;
        FpieeeRecord.Status.InvalidOperation = HighStatus.InvalidOperation;

        FpieeeRecord.Cause.Inexact = HighCause.Inexact;
        FpieeeRecord.Cause.Underflow = HighCause.Underflow;
        FpieeeRecord.Cause.Overflow = HighCause.Overflow;
        CauseDenormal = HighCauseDenormal;
        FpieeeRecord.Cause.ZeroDivide = HighCause.ZeroDivide;
        FpieeeRecord.Cause.InvalidOperation = HighCause.InvalidOperation;

        // invoke the user-defined exception handler
        handler_return_value = handler (&FpieeeRecord);

        // return if not EXCEPTION_CONTINUE_EXECUTION
        if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

          __set_fpsr (&old_fpsr); /* restore caller fpsr */
          return (handler_return_value);

        }

        // clear the IEEE exception flags in the FPSR and
        // update the FPSR with values (possibly) set by the user handler
        // for the rounding mode, the precision mode, and the trap enable
        // bits; if the high half needs to be re-executed, the new FPSR
        // will be used, with status flags cleared; if it is
        // forwarded to the user-defined handler, the new rounding and
        // precision modes are also used (they are
        // already set in FpieeeRecord)

        /* change the FPSR with values (possibly) set by the user handler,
         * for continuing execution where the interruption occured */

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F7");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F7");

        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis 
            << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        // save the result for the high half
        FR1High = FpieeeRecord.Result.Value.Fp32Value;

      } else { //if not (HighCause.InvalidOperation || HighCauseDenormal)

        // do not re-execute the high half of the instruction - it would only
        // return an approximation of 1 / sqrt (high FR3); calculate instead 
        // sqrt (high FR3) in single precision, using the correct rounding mode
        // (the high half of the instruction did not cause any exception)

        // extract the high half of FR3
        FR3High = HighHalf (FR3);

#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG: F7 FR3High = %f = %x\n", 
            FR3High, *((unsigned int *)&FR3High));
#endif

        // employ the user FPSR when calling _thmH; note that
        // the exception masks are those set by the user, and that an
        // inexact exception might be raised

        // perform the single precision square root
        _thmH (&FR3High, &FR1High, &FPSR); // FR1High = sqrt (FR3High)

#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG: F7 high res from _thmH = %f = %x\n",
            FR1High, *(unsigned int *)&FR1High);
#endif

      } // end 'if not (HighCause.InvalidOperation || HighCause.ZeroDivide)'

      if (!LowCause.InvalidOperation && !LowCauseDenormal &&
          !HighCause.InvalidOperation && !HighCauseDenormal) {

        // should never get here
        fprintf (stderr, "IEEE Filter Internal Error: no enabled \
exception (multiple fault) recognized in F7 instruction\n");
        exit (1);

      }

      // set the result predicate
      PR2 = 0;

      Context->StFPSR = FPSR;

      FR1 = Combine (FR1High, FR1Low);
      // set the results before continuing execution
      SetFloatRegisterValue (f1, FR1, Context);
      if (f1 < 32)
        Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl bit
      else
        Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh bit
      Context->Preds &= (~(((unsigned __int64)1) << p2));
      Context->Preds |= (((unsigned __int64)(PR2 & 0x01)) << p2);

      // if this is a fault, need to advance the instruction pointer
      if (FpieeeRecord.Cause.InvalidOperation || CauseDenormal) {

        if (ei == 0) { // no template for this case
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000020000000000;
        } else if (ei == 1) { // templates: MFI, MFB
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
        Context->StIPSR = Context->StIPSR | 0x0000040000000000;
        } else { // if (ei == 2) // templates: MMF
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIIP = Context->StIIP + 0x10;
        }

      }

    }

  } else if ((OpCode & F8_MIN_MASK) == F8_PATTERN) {
    /* F8 instruction */
    // FMIN, FMAX, FAMIN, FAMAX, FPMIN, FPMAX, FPAMIN, FPAMAX

#ifdef FPIEEE_FLT_DEBUG
    printf ("FPIEEE_FLT_DEBUG: F8 instruction\n");
#endif

    if (!SIMD_instruction &&
        (FpieeeRecord.Cause.ZeroDivide ||
        FpieeeRecord.Cause.Overflow ||
        FpieeeRecord.Cause.Underflow ||
        FpieeeRecord.Cause.Inexact) ||
        SIMD_instruction &&
        (LowCause.ZeroDivide || HighCause.ZeroDivide ||
        LowCause.Overflow || HighCause.Overflow ||
        LowCause.Underflow || HighCause.Underflow ||
        LowCause.Inexact || HighCause.Inexact)) {
      fprintf (stderr, "IEEE Filter Internal Error: Cause.ZeroDivide, \
Cause.Overflow, Cause.Underflow, or Cause.Inexact for \
F8 instruction opcode %8x %8x\n",
          (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
      exit (1);
    }

    /* extract f3, f2, and f1 */
    f3 = (unsigned int)((OpCode >> 20) & (unsigned __int64)0x00000000007F);
    if (f3 >= 32) f3 = 32 + (rrbfr + f3 - 32) % 96;
    f2 = (unsigned int)((OpCode >> 13) & (unsigned __int64)0x00000000007F);
    if (f2 >= 32) f2 = 32 + (rrbfr + f2 - 32) % 96;
    f1 = (unsigned int)((OpCode >>  6) & (unsigned __int64)0x00000000007F);
    if (f1 >= 32) f1 = 32 + (rrbfr + f1 - 32) % 96;

    /* get source floating-point register values */
    FR2 = GetFloatRegisterValue (f2, Context);
    FR3 = GetFloatRegisterValue (f3, Context);

    if (!SIMD_instruction) {

      // *** this is a non-SIMD instruction ***
      // (FMIN, FMAX, FAMIN, FAMAX)

      FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
      FpieeeRecord.Operand1.OperandValid = 1;
      FpieeeRecord.Operand1.Value.Fp128Value = FR2;
      FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
      FpieeeRecord.Operand2.OperandValid = 1;
      FpieeeRecord.Operand2.Value.Fp128Value = FR3;
      FpieeeRecord.Operand3.OperandValid = 0;

      switch (OpCode & F8_MASK) {

        case FMIN_PATTERN:
          FpieeeRecord.Operation = _FpCodeFmin;
          break;

        case FMAX_PATTERN:
          FpieeeRecord.Operation = _FpCodeFmax;
          break;

        case FAMIN_PATTERN:
          FpieeeRecord.Operation = _FpCodeFamin;
          break;

        case FAMAX_PATTERN:
          FpieeeRecord.Operation = _FpCodeFamax;
          break;

        default:
          /* unrecognized instruction type */
          fprintf (stderr, "IEEE Filter Internal Error: \
              non-SIMD F8 instruction opcode %8x %8x not recognized\n", 
              (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
          exit (1);

      }

      FpieeeRecord.Result.Format = _FpFormatFp82; /* 1+17+24/53/64 bits */

      /* this is a fault - the result contains an invalid value */
      FpieeeRecord.Result.OperandValid = 0;

      handler_return_value = handler (&FpieeeRecord);

      // convert the result to 82-bit format
      FR1 = FPIeeeToFP128 (&FpieeeRecord);
#ifdef FPIEEE_FLT_DEBUG
      printf ("FPIEEE_FLT_DEBUG 4: CONVERTED FR1 = %08x %08x %08x %08x\n",
          FR1.W[3], FR1.W[2], FR1.W[1], FR1.W[0]);
#endif

      if (handler_return_value == EXCEPTION_CONTINUE_EXECUTION) {

        /* change the FPSR with values (possibly) set by the user handler, 
         * for continuing execution where the interruption occured */

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F8");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F8");

        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis 
            << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        Context->StFPSR = FPSR;

        // set the result before continuing execution
        SetFloatRegisterValue (f1, FR1, Context);
        if (f1 < 32)
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl bit
        else
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh bit

        // this is a fault; need to advance the instruction pointer
        if (ei == 0) { // no template for this case
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000020000000000;
        } else if (ei == 1) { // templates: MFI, MFB
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000040000000000;
        } else { // if (ei == 2) // templates: MMF
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIIP = Context->StIIP + 0x10;
        }

      }

    } else { // if (SIMD_instruction)

      // *** this is a SIMD instruction *** 
      // (FPMIN, FPMAX, FPAMIN, FPAMAX, FPCMP)

      // the half (halves) of the instruction that caused an enabled exception, 
      // are presented to the user-defined handler in the form of non-SIMD in-
      // struction(s); the half (if any) that did not cause an enabled exception
      // (i.e. caused no exception, or caused an exception that is disabled),
      // is re-executed; in this case, the other half is padded to calculate 
      // FPXXX (0.0, 0.0), that will cause no exception

      switch (OpCode & F8_MASK) {

        case FPMIN_PATTERN:
          Operation = _FpCodeFmin;
          ResultFormat = _FpFormatFp32; /* 1 + 8 + 24 bits */
          break;

        case FPMAX_PATTERN:
          Operation = _FpCodeFmax;
          ResultFormat = _FpFormatFp32; /* 1 + 8 + 24 bits */
          break;

        case FPAMIN_PATTERN:
          Operation = _FpCodeFamin;
          ResultFormat = _FpFormatFp32; /* 1 + 8 + 24 bits */
          break;

        case FPAMAX_PATTERN:
          Operation = _FpCodeFamax;
          ResultFormat = _FpFormatFp32; /* 1 + 8 + 24 bits */
          break;

        case FPCMP_EQ_PATTERN:
        case FPCMP_LT_PATTERN:
        case FPCMP_LE_PATTERN:
        case FPCMP_UNORD_PATTERN:
        case FPCMP_NEQ_PATTERN:
        case FPCMP_NLT_PATTERN:
        case FPCMP_NLE_PATTERN:
        case FPCMP_ORD_PATTERN:
          Operation = _FpCodeCompare;
          ResultFormat = _FpFormatCompare;
          break;

        default:
          /* unrecognized instruction type */
          fprintf (stderr, "IEEE Filter Internal Error: \
              F8 SIMD instruction opcode %8x %8x not recognized\n", 
              (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
          exit (1);

      }

      // hand the half (halves) that caused an enabled fault to the 
      // user handler; re-execute the other half (if any);
      // combine the results

      // Note that the convention chosen is for the processing to be 
      // performed in the order low first, high second, as SIMD operands
      // are stored in this order in memory in the little endian format 
      // (this order would have to be changed for big endian)

      if (LowCause.InvalidOperation  || LowCauseDenormal) {

        // invoke the user handler and check the return value

        // fill in the remaining fields of the _FPIEEE_RECORD (rounding
        // and precision already filled in)

        FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
        FpieeeRecord.Operand1.OperandValid = 1;
        FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128 (LowHalf (FR2));
        FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
        FpieeeRecord.Operand2.OperandValid = 1;
        FpieeeRecord.Operand2.Value.Fp128Value = FP32ToFP128 (LowHalf (FR3));
        FpieeeRecord.Operand3.OperandValid = 0;

        FpieeeRecord.Result.Format = ResultFormat;
        FpieeeRecord.Result.OperandValid = 0;
        FpieeeRecord.Operation = Operation;

        FpieeeRecord.Status.Inexact = LowStatus.Inexact;
        FpieeeRecord.Status.Underflow = LowStatus.Underflow;
        FpieeeRecord.Status.Overflow = LowStatus.Overflow;
        FpieeeRecord.Status.ZeroDivide = LowStatus.ZeroDivide;
        StatusDenormal = LowStatusDenormal;
        FpieeeRecord.Status.InvalidOperation = LowStatus.InvalidOperation;

        FpieeeRecord.Cause.Inexact = LowCause.Inexact;
        FpieeeRecord.Cause.Underflow = LowCause.Underflow;
        FpieeeRecord.Cause.Overflow = LowCause.Overflow;
        FpieeeRecord.Cause.ZeroDivide = LowCause.ZeroDivide;
        CauseDenormal = LowCauseDenormal;
        FpieeeRecord.Cause.InvalidOperation = LowCause.InvalidOperation;

        // invoke the user-defined exception handler
        handler_return_value = handler (&FpieeeRecord);

        // return if not EXCEPTION_CONTINUE_EXECUTION
        if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

          __set_fpsr (&old_fpsr); /* restore caller fpsr */
          return (handler_return_value);

        }

        // clear the IEEE exception flags in the FPSR and
        // update the FPSR with values (possibly) set by the user handler
        // for the rounding mode, the precision mode, and the trap enable
        // bits; if the high half needs to be re-executed, the new FPSR
        // will be used, with status flags cleared; if it is 
        // forwarded to the user-defined handler, the new rounding and 
        // precision modes are also used (they are
        // already set in FpieeeRecord)

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F8");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F8");

        // Update the trap disable bits
        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis
            << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        // save the result for the low half
        switch (OpCode & F8_MASK) {

          case FPMIN_PATTERN:
          case FPMAX_PATTERN:
          case FPAMIN_PATTERN:
          case FPAMAX_PATTERN:
            FR1Low = FpieeeRecord.Result.Value.Fp32Value;
            break;

          case FPCMP_EQ_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareEqual:
                U32Low = 0x0ffffffff;
                break;
              case _FpCompareGreater:
              case _FpCompareLess:
              case _FpCompareUnordered:
                U32Low = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_LT_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareLess:
                U32Low = 0x0ffffffff;
                break;
              case _FpCompareGreater:
              case _FpCompareEqual:
              case _FpCompareUnordered:
                U32Low = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_LE_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareEqual:
              case _FpCompareLess:
                U32Low = 0x0ffffffff;
                break;
              case _FpCompareGreater:
              case _FpCompareUnordered:
                U32Low = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_UNORD_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareUnordered:
                U32Low = 0x0ffffffff;
                break;
              case _FpCompareEqual:
              case _FpCompareGreater:
              case _FpCompareLess:
                U32Low = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_NEQ_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareGreater:
              case _FpCompareLess:
              case _FpCompareUnordered:
                U32Low = 0x0ffffffff;
                break;
              case _FpCompareEqual:
                U32Low = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_NLT_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareEqual:
              case _FpCompareGreater:
                U32Low = 0x0ffffffff;
                break;
              case _FpCompareLess:
              case _FpCompareUnordered:
                U32Low = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_NLE_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareGreater:
                U32Low = 0x0ffffffff;
                break;
              case _FpCompareEqual:
              case _FpCompareLess:
              case _FpCompareUnordered:
                U32Low = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_ORD_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareEqual:
              case _FpCompareGreater:
              case _FpCompareLess:
                U32Low = 0x0ffffffff;
                break;
              case _FpCompareUnordered:
                U32Low = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          default: ; // this case was verified above

        }

        // since there has been a call to the user handler and FPSR might
        // have changed (the Enable bits in particular), recalculate the 
        // Cause bits (if the HighEnable-s changed, there might be a 
        // change in the HighCause values) 
        // Note that the Status bits used are the original ones

        HighCause.Inexact = 0;
        HighCause.Underflow = 0;
        HighCause.Overflow = 0;
        HighCause.ZeroDivide =
            FpieeeRecord.Enable.ZeroDivide && HighStatus.ZeroDivide;
        HighCauseDenormal = EnableDenormal && HighStatusDenormal;
        HighCause.InvalidOperation =
            FpieeeRecord.Enable.InvalidOperation &&
            HighStatus.InvalidOperation;
        // Note: the user handler does not affect the denormal enable bit

      } else if (LowCause.ZeroDivide) {

        fprintf (stderr, "IEEE Filter Internal Error: \
            LowCause.ZeroDivide in F8 instruction\n");
        exit (1);

      } else { // if not (LowCause.InvalidOperation || LowCauseDenormal ||
         // LowCause.ZeroDivide)

        // re-execute the low half of the instruction

        // modify the high halves of FR2, FR3
        switch (OpCode & F8_MASK) {

          case FPMIN_PATTERN:
          case FPMAX_PATTERN:
          case FPAMIN_PATTERN:
          case FPAMAX_PATTERN:
            newFR2 = Combine ((float)0.0, LowHalf (FR2));
            newFR3 = Combine ((float)0.0, LowHalf (FR3));
            break;

          case FPCMP_EQ_PATTERN:
          case FPCMP_LT_PATTERN:
          case FPCMP_LE_PATTERN:
          case FPCMP_UNORD_PATTERN:
          case FPCMP_NEQ_PATTERN:
          case FPCMP_NLT_PATTERN:
          case FPCMP_NLE_PATTERN:
          case FPCMP_ORD_PATTERN:
            newFR2 = U32Combine (0, U32LowHalf (FR2));
            newFR3 = U32Combine (0, U32LowHalf (FR3));

            break;

          default: ; // this case was verified above

        }

        switch (OpCode & F8_MASK) {

          case FPMIN_PATTERN:
            _xrun2args (FPMIN, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPMAX_PATTERN:
            _xrun2args (FPMAX, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPAMIN_PATTERN:
            _xrun2args (FPAMIN, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPAMAX_PATTERN:
            _xrun2args (FPAMAX, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_EQ_PATTERN:
            _xrun2args (FPCMP_EQ, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_LT_PATTERN:
            _xrun2args (FPCMP_LT, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_LE_PATTERN:
            _xrun2args (FPCMP_LE, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_UNORD_PATTERN:
            _xrun2args (FPCMP_UNORD, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_NEQ_PATTERN:
            _xrun2args (FPCMP_NEQ, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_NLT_PATTERN:
            _xrun2args (FPCMP_NLT, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_NLE_PATTERN:
            _xrun2args (FPCMP_NLE, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_ORD_PATTERN:
            _xrun2args (FPCMP_ORD, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          default:
            // unrecognized instruction type
            fprintf (stderr, "IEEE Filter Internal Error: \
                F8 SIMD instruction opcode %8x %8x not recognized\n", 
                (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
            exit (1);

        }

        switch (OpCode & F8_MASK) {

          case FPMIN_PATTERN:
          case FPMAX_PATTERN:
          case FPAMIN_PATTERN:
          case FPAMAX_PATTERN:
            FR1Low = LowHalf (FR1);
            break;

          case FPCMP_EQ_PATTERN:
          case FPCMP_LT_PATTERN:
          case FPCMP_LE_PATTERN:
          case FPCMP_UNORD_PATTERN:
          case FPCMP_NEQ_PATTERN:
          case FPCMP_NLT_PATTERN:
          case FPCMP_NLE_PATTERN:
          case FPCMP_ORD_PATTERN:
            U32Low = U32LowHalf (FR1);
            break;

          default: ; // this case was verified above

        }

      } // end 'if not (LowCause.InvalidOperation || LowCauseDenormal ||
         // LowCause.ZeroDivide)'

      if (HighCause.InvalidOperation || HighCauseDenormal) {

        // invoke the user-defined exception handler and check the return 
        // value; since this might be the second call to the user handler,
        // make sure all the _FPIEEE_RECORD fields are correct;
        // return if handler_return_value is not
        // EXCEPTION_CONTINUE_EXECUTION, otherwise combine the results

        // the rounding mode is either the initial one, or the one
        // set during the call to the user handler for the low half,
        // if there has been an enabled exception for it

        // the precision mode is either the initial one, or the one
        // set during the call to the user handler for the low half,
        // if there has been an enabled exception for it

        // the enable flags are either the initial ones, or the ones
        // set during the call to the user handler for the low half,
        // if there has been an enabled exception for it

        FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1+8+24 bits */
        FpieeeRecord.Operand1.OperandValid = 1;
        FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128 (HighHalf (FR2));
        FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1+8+24 bits */
        FpieeeRecord.Operand2.OperandValid = 1;
        FpieeeRecord.Operand2.Value.Fp128Value = FP32ToFP128 (HighHalf (FR3));
        FpieeeRecord.Operand3.OperandValid = 0;

        FpieeeRecord.Result.Format = ResultFormat;
        FpieeeRecord.Result.OperandValid = 0;

        FpieeeRecord.Operation = Operation;

        FpieeeRecord.Status.Inexact = HighStatus.Inexact;
        FpieeeRecord.Status.Underflow = HighStatus.Underflow;
        FpieeeRecord.Status.Overflow = HighStatus.Overflow;
        FpieeeRecord.Status.ZeroDivide = HighStatus.ZeroDivide;
        StatusDenormal = HighStatusDenormal;
        FpieeeRecord.Status.InvalidOperation = HighStatus.InvalidOperation;

        FpieeeRecord.Cause.Inexact = HighCause.Inexact;
        FpieeeRecord.Cause.Underflow = HighCause.Underflow;
        FpieeeRecord.Cause.Overflow = HighCause.Overflow;
        FpieeeRecord.Cause.ZeroDivide = HighCause.ZeroDivide;
        CauseDenormal = HighCauseDenormal;
        FpieeeRecord.Cause.InvalidOperation = HighCause.InvalidOperation;

        // invoke the user-defined exception handler
        handler_return_value = handler (&FpieeeRecord);

        // return if not EXCEPTION_CONTINUE_EXECUTION
        if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

          __set_fpsr (&old_fpsr); /* restore caller fpsr */
          return (handler_return_value);

        }

        // clear the IEEE exception flags in the FPSR and
        // update the FPSR with values (possibly) set by the user handler
        // for the rounding mode, the precision mode, and the trap enable
        // bits; if the high half needs to be re-executed, the new FPSR
        // will be used, with status flags cleared; if it is
        // forwarded to the user-defined handler, the new rounding and
        // precision modes are also used (they are
        // already set in FpieeeRecord)

        /* change the FPSR with values (possibly) set by the user handler,
         * for continuing execution where the interruption occured */

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F8");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F8");

        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis 
            << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        // save the result for the high half
        switch (OpCode & F8_MASK) {

          case FPMIN_PATTERN:
          case FPMAX_PATTERN:
          case FPAMIN_PATTERN:
          case FPAMAX_PATTERN:
            FR1High = FpieeeRecord.Result.Value.Fp32Value;
            break;

          case FPCMP_EQ_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareEqual:
                U32High = 0x0ffffffff;
                break;
              case _FpCompareGreater:
              case _FpCompareLess:
              case _FpCompareUnordered:
                U32High = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_LT_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareLess:
                U32High = 0x0ffffffff;
                break;
              case _FpCompareGreater:
              case _FpCompareEqual:
              case _FpCompareUnordered:
                U32High = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_LE_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareEqual:
              case _FpCompareLess:
                U32High = 0x0ffffffff;
                break;
              case _FpCompareGreater:
              case _FpCompareUnordered:
                U32High = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_UNORD_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareUnordered:
                U32High = 0x0ffffffff;
                break;
              case _FpCompareEqual:
              case _FpCompareGreater:
              case _FpCompareLess:
                U32High = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_NEQ_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareGreater:
              case _FpCompareLess:
              case _FpCompareUnordered:
                U32High = 0x0ffffffff;
                break;
              case _FpCompareEqual:
                U32High = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_NLT_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareEqual:
              case _FpCompareGreater:
                U32High = 0x0ffffffff;
                break;
              case _FpCompareLess:
              case _FpCompareUnordered:
                U32High = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_NLE_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareGreater:
                U32High = 0x0ffffffff;
                break;
              case _FpCompareEqual:
              case _FpCompareLess:
              case _FpCompareUnordered:
                U32High = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_ORD_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareEqual:
              case _FpCompareGreater:
              case _FpCompareLess:
                U32High = 0x0ffffffff;
                break;
              case _FpCompareUnordered:
                U32High = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          default: ; // this case was verified above

        }

      } else if (HighCause.ZeroDivide) {

        fprintf (stderr, "IEEE Filter Internal Error: \
            HighCause.ZeroDivide in F8 instruction\n");
        exit (1);

      } else { //if not (HighCause.InvalidOperation || HighCauseDenormal ||
          // HighCause.ZeroDivide)

        // re-execute the high half of the instruction

        // modify the low halves of FR2, and FR3
        switch (OpCode & F8_MASK) {

          case FPMIN_PATTERN:
          case FPMAX_PATTERN:
          case FPAMIN_PATTERN:
          case FPAMAX_PATTERN:
            newFR2 = Combine (HighHalf (FR2), (float)0.0);
            newFR3 = Combine (HighHalf (FR3), (float)0.0);
            break;

          case FPCMP_EQ_PATTERN:
          case FPCMP_LT_PATTERN:
          case FPCMP_LE_PATTERN:
          case FPCMP_UNORD_PATTERN:
          case FPCMP_NEQ_PATTERN:
          case FPCMP_NLT_PATTERN:
          case FPCMP_NLE_PATTERN:
          case FPCMP_ORD_PATTERN:
            newFR2 = U32Combine (U32HighHalf (FR2), 0);
            newFR3 = U32Combine (U32HighHalf (FR3), 0);
            break;

          default: ; // this case was verified above

        }

        switch (OpCode & F8_MASK) {

          case FPMIN_PATTERN:
            _xrun2args (FPMIN, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPMAX_PATTERN:
            _xrun2args (FPMAX, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPAMIN_PATTERN:
            _xrun2args (FPAMIN, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPAMAX_PATTERN:
            _xrun2args (FPAMAX, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_EQ_PATTERN:
            _xrun2args (FPCMP_EQ, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_LT_PATTERN:
            _xrun2args (FPCMP_LT, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_LE_PATTERN:
            _xrun2args (FPCMP_LE, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_UNORD_PATTERN:
            _xrun2args (FPCMP_UNORD, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_NEQ_PATTERN:
            _xrun2args (FPCMP_NEQ, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_NLT_PATTERN:
            _xrun2args (FPCMP_NLT, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_NLE_PATTERN:
            _xrun2args (FPCMP_NLE, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_ORD_PATTERN:
            _xrun2args (FPCMP_ORD, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          default:
            // unrecognized instruction type
            fprintf (stderr, "IEEE Filter Internal Error: \
                F8 SIMD instruction opcode %8x %8x not recognized\n", 
                (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
            exit (1);

        }

        switch (OpCode & F8_MASK) {

          case FPMIN_PATTERN:
          case FPMAX_PATTERN:
          case FPAMIN_PATTERN:
          case FPAMAX_PATTERN:
            FR1High = HighHalf (FR1);
            break;

          case FPCMP_EQ_PATTERN:
          case FPCMP_LT_PATTERN:
          case FPCMP_LE_PATTERN:
          case FPCMP_UNORD_PATTERN:
          case FPCMP_NEQ_PATTERN:
          case FPCMP_NLT_PATTERN:
          case FPCMP_NLE_PATTERN:
          case FPCMP_ORD_PATTERN:
            U32High = U32HighHalf (FR1);
            break;

          default: ; // this case was verified above

        }

      } // end 'if not (HighCause.InvalidOperation || HighCauseDenormal ||
          // HighCause.ZeroDivide)

      if (!LowCause.InvalidOperation && !LowCauseDenormal &&
          !HighCause.InvalidOperation && !HighCauseDenormal) {

        // should never get here
        fprintf (stderr, "IEEE Filter Internal Error: no enabled \
            exception (multiple fault) recognized in F8 instruction\n");
        exit (1);

      }

      Context->StFPSR = FPSR;

      switch (OpCode & F8_MASK) {

        case FPMIN_PATTERN:
        case FPMAX_PATTERN:
        case FPAMIN_PATTERN:
        case FPAMAX_PATTERN:
          FR1 = Combine (FR1High, FR1Low);
          break;

        case FPCMP_EQ_PATTERN:
        case FPCMP_LT_PATTERN:
        case FPCMP_LE_PATTERN:
        case FPCMP_UNORD_PATTERN:
        case FPCMP_NEQ_PATTERN:
        case FPCMP_NLT_PATTERN:
        case FPCMP_NLE_PATTERN:
        case FPCMP_ORD_PATTERN:
          FR1 = U32Combine (U32High, U32Low);
          break;

        default: ; // this case was verified above

      }

      // set the result before continuing execution
      SetFloatRegisterValue (f1, FR1, Context);
      if (f1 < 32)
        Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl bit
      else
        Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh bit

      // this is a fault; need to advance the instruction pointer
      if (ei == 0) { // no template for this case
        Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
        Context->StIPSR = Context->StIPSR | 0x0000020000000000;
      } else if (ei == 1) { // templates: MFI, MFB
        Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
        Context->StIPSR = Context->StIPSR | 0x0000040000000000;
      } else { // if (ei == 2) // templates: MMF
        Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
        Context->StIIP = Context->StIIP + 0x10;
      }

    }

  } else if ((OpCode & F10_MIN_MASK) == F10_PATTERN) {
    /* F10 instruction */
    // FCVT, FPCVT

#ifdef FPIEEE_FLT_DEBUG
    printf ("FPIEEE_FLT_DEBUG: F10 instruction\n");
#endif

    if (!SIMD_instruction &&
        (FpieeeRecord.Cause.ZeroDivide ||
        FpieeeRecord.Cause.Overflow ||
        FpieeeRecord.Cause.Underflow) ||
        SIMD_instruction &&
        (LowCause.ZeroDivide || HighCause.ZeroDivide ||
        LowCause.Overflow || HighCause.Overflow ||
        LowCause.Underflow || HighCause.Underflow)) {
      fprintf (stderr, "IEEE Filter Internal Error: Cause.ZeroDivide, \
Cause.Overflow, Cause.Underflow, or Cause.Inexact for \
F10 instruction opcode %8x %8x\n",
          (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
      exit (1);
    }

    /* extract f2 and f1 */
    f2 = (unsigned int)((OpCode >> 13) & (unsigned __int64)0x00000000007F);
    if (f2 >= 32) f2 = 32 + (rrbfr + f2 - 32) % 96;
    f1 = (unsigned int)((OpCode >>  6) & (unsigned __int64)0x00000000007F);
    if (f1 >= 32) f1 = 32 + (rrbfr + f1 - 32) % 96;

    /* get source floating-point register value */
    FR2 = GetFloatRegisterValue (f2, Context);

    if (!SIMD_instruction) {

      // *** this is a non-SIMD instruction, FCVT ***

      FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
      FpieeeRecord.Operand1.OperandValid = 1;
      FpieeeRecord.Operand1.Value.Fp128Value = FR2;
      FpieeeRecord.Operand2.OperandValid = 0;
      FpieeeRecord.Operand3.OperandValid = 0;

      switch (OpCode & F10_MASK) {

        case FCVT_FX_TRUNC_PATTERN:
          FpieeeRecord.Operation = _FpCodeConvertTrunc;
          FpieeeRecord.Result.Format = _FpFormatI64; 
          break;

        case FCVT_FXU_TRUNC_PATTERN:
          FpieeeRecord.Operation = _FpCodeConvertTrunc;
          FpieeeRecord.Result.Format = _FpFormatU64;
          break;

        case FCVT_FX_PATTERN:
          FpieeeRecord.Operation = _FpCodeConvert;
          FpieeeRecord.Result.Format = _FpFormatI64; 
          break;

        case FCVT_FXU_PATTERN:
          FpieeeRecord.Operation = _FpCodeConvert;
          FpieeeRecord.Result.Format = _FpFormatU64;
          break;

        default:
          /* unrecognized instruction type */
          fprintf (stderr, "IEEE Filter Internal Error: F10\
              non-SIMD instruction opcode %8x %8x not recognized\n", 
              (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
          exit (1);

      }

      if (FpieeeRecord.Cause.InvalidOperation || CauseDenormal) {

        /* this is a fault - the result contains an invalid value */
        FpieeeRecord.Result.OperandValid = 0;

        handler_return_value = handler (&FpieeeRecord);

        // convert the result to 82-bit format
        switch (OpCode & F10_MASK) {
          case FCVT_FX_PATTERN:
          case FCVT_FX_TRUNC_PATTERN:
            FR1.W[0] = FpieeeRecord.Result.Value.I64Value.W[0];
            FR1.W[1] = FpieeeRecord.Result.Value.I64Value.W[1];
            break;
          case FCVT_FXU_TRUNC_PATTERN:
          case FCVT_FXU_PATTERN:
            FR1.W[0] = FpieeeRecord.Result.Value.U64Value.W[0];
            FR1.W[1] = FpieeeRecord.Result.Value.U64Value.W[1];
            break;
          default: ; // this case caught above
        }
        FR1.W[2] = 0x0001003e;

      } else if (FpieeeRecord.Cause.Inexact) {

        // this is a trap - get the result
        switch (OpCode & F10_MASK) {

          case FCVT_FX_PATTERN:
          case FCVT_FX_TRUNC_PATTERN:
            FR1 = GetFloatRegisterValue (f1, Context);
            FpieeeRecord.Result.Value.I64Value.W[0] = FR1.W[0];
            FpieeeRecord.Result.Value.I64Value.W[1] = FR1.W[1];
            break;

          case FCVT_FXU_TRUNC_PATTERN:
          case FCVT_FXU_PATTERN:
            FR1 = GetFloatRegisterValue (f1, Context);
            FpieeeRecord.Result.Value.U64Value.W[0] = FR1.W[0];
            FpieeeRecord.Result.Value.U64Value.W[1] = FR1.W[1];
            break;

          default: // should never get here
            /* unrecognized instruction type */
            fprintf (stderr, "IEEE Filter Internal Error: F10 SIMD \
                instruction opcode %8x %8x not recognized\n", 
                (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
            exit (1);

        }

        // the result contains a valid value
        FpieeeRecord.Result.OperandValid = 1;

        handler_return_value = handler (&FpieeeRecord);

        // convert the result to 82-bit format
        switch (OpCode & F10_MASK) {
          case FCVT_FX_PATTERN:
          case FCVT_FX_TRUNC_PATTERN:
            FR1.W[0] = FpieeeRecord.Result.Value.I64Value.W[0];
            FR1.W[1] = FpieeeRecord.Result.Value.I64Value.W[1];
            break;
          case FCVT_FXU_TRUNC_PATTERN:
          case FCVT_FXU_PATTERN:
            FR1.W[0] = FpieeeRecord.Result.Value.U64Value.W[0];
            FR1.W[1] = FpieeeRecord.Result.Value.U64Value.W[1];
            break;
          default: ; // this case caught above
        }
        FR1.W[2] = 0x0001003e;
        FR1.W[3] = 0x00000000;

      } else {

        // should never get here - this case was filtered above
        fprintf (stderr, "IEEE Filter Internal Error: \
            exception code %x not recognized in non-SIMD F10 instruction\n",
            eXceptionCode);
        exit (1);

    }

      if (handler_return_value == EXCEPTION_CONTINUE_EXECUTION) {

        /* change the FPSR with values (possibly) set by the user handler, 
         * for continuing execution where the interruption occured */

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F10");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F10");

        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis 
            << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        Context->StFPSR = FPSR;

        // set the result before continuing execution
        SetFloatRegisterValue (f1, FR1, Context);
        if (f1 < 32)
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl bit
        else
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh bit

        // if this is a fault, need to advance the instruction pointer
        if (FpieeeRecord.Cause.InvalidOperation || CauseDenormal) {

          if (ei == 0) { // no template for this case
            Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
            Context->StIPSR = Context->StIPSR | 0x0000020000000000;
          } else if (ei == 1) { // templates: MFI, MFB
            Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
            Context->StIPSR = Context->StIPSR | 0x0000040000000000;
          } else { // if (ei == 2) // templates: MMF
            Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
            Context->StIIP = Context->StIIP + 0x10;
          }

        }

      }

    } else { // if (SIMD_instruction)

      // *** this is a SIMD instruction, FPCVT ***

      // the half (halves) of the instruction that caused an enabled exception, 
      // are presented to the user-defined handler in the form of non-SIMD in-
      // struction(s); the half (if any) that did not cause an enabled exception
      // (i.e. caused no exception, or caused an exception that is disabled),
      // is re-executed if it is associated with a fault in the other half; in
      // this case, the other half is padded to convert 0.0, that
      // will cause no exception; if it is associated with a trap in the other
      // half, its result is left unchanged

      switch (OpCode & F10_MASK) {

        case FPCVT_FX_TRUNC_PATTERN:
        case FPCVT_FXU_TRUNC_PATTERN:
          Operation = _FpCodeConvertTrunc;
          break;

        case FPCVT_FX_PATTERN:
        case FPCVT_FXU_PATTERN:
          Operation = _FpCodeConvert;
          break;

        default:
          /* unrecognized instruction type */
          fprintf (stderr, "IEEE Filter Internal Error: \
              instruction opcode %8x %8x not recognized\n", 
              (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
          exit (1);

      }

      switch (OpCode & F10_MASK) {

        case FPCVT_FX_TRUNC_PATTERN:
        case FPCVT_FX_PATTERN:
          ResultFormat = _FpFormatI32;
          break;
        case FPCVT_FXU_TRUNC_PATTERN:
        case FPCVT_FXU_PATTERN:
          ResultFormat = _FpFormatU32;
          // break;

        // default: this case caught above

      }

      if (eXceptionCode == STATUS_FLOAT_MULTIPLE_FAULTS) {

        // hand the half (halves) that caused an enabled fault to the 
        // user handler; re-execute the other half (if any);
        // combine the results

        // Note that the convention chosen is for the processing to be 
        // performed in the order low first, high second, as SIMD operands
        // are stored in this order in memory in the little endian format 
        // (this order would have to be changed for big endian)

        if (LowCause.InvalidOperation  || LowCauseDenormal) {

          // invoke the user handler and check the return value

          // fill in the remaining fields of the _FPIEEE_RECORD (rounding
          // and precision already filled in)

          FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
          FpieeeRecord.Operand1.OperandValid = 1;
          FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128 (LowHalf(FR2));
          FpieeeRecord.Operand2.OperandValid = 0;
          FpieeeRecord.Operand3.OperandValid = 0;

          FpieeeRecord.Result.Format = ResultFormat;
          FpieeeRecord.Result.OperandValid = 0;

          FpieeeRecord.Operation = Operation;

          FpieeeRecord.Status.Inexact = LowStatus.Inexact;
          FpieeeRecord.Status.Underflow = LowStatus.Underflow;
          FpieeeRecord.Status.Overflow = LowStatus.Overflow;
          FpieeeRecord.Status.ZeroDivide = LowStatus.ZeroDivide;
          FpieeeRecord.Status.InvalidOperation = LowStatus.InvalidOperation;

          FpieeeRecord.Cause.Inexact = LowCause.Inexact;
          FpieeeRecord.Cause.Underflow = LowCause.Underflow;
          FpieeeRecord.Cause.Overflow = LowCause.Overflow;
          FpieeeRecord.Cause.ZeroDivide = LowCause.ZeroDivide;
          FpieeeRecord.Cause.InvalidOperation = LowCause.InvalidOperation;

          // invoke the user-defined exception handler
          handler_return_value = handler (&FpieeeRecord);

          // return if not EXCEPTION_CONTINUE_EXECUTION
          if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

            __set_fpsr (&old_fpsr); /* restore caller fpsr */
            return (handler_return_value);

          }

          // clear the IEEE exception flags in the FPSR and
          // update the FPSR with values (possibly) set by the user handler
          // for the rounding mode, the precision mode, and the trap enable
          // bits; if the high half needs to be re-executed, the new FPSR
          // will be used, with status flags cleared; if it is 
          // forwarded to the user-defined handler, the new rounding and 
          // precision modes are also used (they are
          // already set in FpieeeRecord)

          UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F10");
          UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F10");

          // Update the trap disable bits
          I_dis = !FpieeeRecord.Enable.Inexact;
          U_dis = !FpieeeRecord.Enable.Underflow;
          O_dis = !FpieeeRecord.Enable.Overflow;
          Z_dis = !FpieeeRecord.Enable.ZeroDivide;
          V_dis = !FpieeeRecord.Enable.InvalidOperation;

          FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis 
              << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

          // save the result for the low half
          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
            case FPCVT_FX_PATTERN:
              I32Low = FpieeeRecord.Result.Value.I32Value;
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
            case FPCVT_FXU_PATTERN:
              U32Low = FpieeeRecord.Result.Value.U32Value;
              // break;

            // default: this case caught above

          }

          // since there has been a call to the user handler and FPSR might
          // have changed (the Enable bits in particular), recalculate the 
          // Cause bits (if the HighEnable-s changed, there might be a 
          // change in the HighCause values) 
          // Note that the Status bits used are the original ones

          HighCause.Inexact = 0;
          HighCause.Underflow = 0;
          HighCause.Overflow = 0;
          HighCause.ZeroDivide =
              FpieeeRecord.Enable.ZeroDivide && HighStatus.ZeroDivide;
          HighCauseDenormal = EnableDenormal && HighStatusDenormal;
          HighCause.InvalidOperation =
              FpieeeRecord.Enable.InvalidOperation &&
              HighStatus.InvalidOperation;
          // Note: the user handler does not affect the denormal enable bit

        } else if (LowCause.ZeroDivide) {

          fprintf (stderr, "IEEE Filter Internal Error: \
              LowCause.ZeroDivide in F10 instruction\n");
          exit (1);

        } else { // if not (LowCause.InvalidOperation || LowCauseDenormal ||
            // LowCause.ZeroDivide)

          // re-execute the low half of the instruction

          // modify the high half of FR2
          newFR2 = Combine ((float)0.0, LowHalf (FR2));

          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
              _xrun1args (FPCVT_FX_TRUNC, &FPSR, &FR1, &newFR2);
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
              _xrun1args (FPCVT_FXU_TRUNC, &FPSR, &FR1, &newFR2);
              break;

            case FPCVT_FX_PATTERN:
              _xrun1args (FPCVT_FX, &FPSR, &FR1, &newFR2);
              break;

            case FPCVT_FXU_PATTERN:
              _xrun1args (FPCVT_FXU, &FPSR, &FR1, &newFR2);
              break;

            default: ; // this case was caught above

          }

          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
            case FPCVT_FX_PATTERN:
              I32Low = I32LowHalf (FR1);
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
            case FPCVT_FXU_PATTERN:
              U32Low = U32LowHalf (FR1);
              // break;

            default: ; // this case was caught above

          }

        } // end 'if not (LowCause.InvalidOperation || LowCauseDenormal ||
            // LowCause.ZeroDivide)'

        if (HighCause.InvalidOperation || HighCauseDenormal) {

          // invoke the user-defined exception handler and check the return 
          // value; since this might be the second call to the user handler,
          // make sure all the _FPIEEE_RECORD fields are correct;
          // return if handler_return_value is not
          // EXCEPTION_CONTINUE_EXECUTION, otherwise combine the results

          // the rounding mode is either the initial one, or the one
          // set during the call to the user handler for the low half,
          // if there has been an enabled exception for it

          // the precision mode is either the initial one, or the one
          // set during the call to the user handler for the low half,
          // if there has been an enabled exception for it

          // the enable flags are either the initial ones, or the ones
          // set during the call to the user handler for the low half,
          // if there has been an enabled exception for it

          FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1+8+24 bits */
          FpieeeRecord.Operand1.OperandValid = 1;
          FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128(HighHalf(FR2));
          FpieeeRecord.Operand2.OperandValid = 0;
          FpieeeRecord.Operand3.OperandValid = 0;

          FpieeeRecord.Result.Format = ResultFormat;
          FpieeeRecord.Result.OperandValid = 0;

          FpieeeRecord.Operation = Operation;

          FpieeeRecord.Status.Inexact = HighStatus.Inexact;
          FpieeeRecord.Status.Underflow = HighStatus.Underflow;
          FpieeeRecord.Status.Overflow = HighStatus.Overflow;
          FpieeeRecord.Status.ZeroDivide = HighStatus.ZeroDivide;
          StatusDenormal = HighStatusDenormal;
          FpieeeRecord.Status.InvalidOperation = HighStatus.InvalidOperation;

          FpieeeRecord.Cause.Inexact = HighCause.Inexact;
          FpieeeRecord.Cause.Underflow = HighCause.Underflow;
          FpieeeRecord.Cause.Overflow = HighCause.Overflow;
          FpieeeRecord.Cause.ZeroDivide = HighCause.ZeroDivide;
          CauseDenormal = HighCauseDenormal;
          FpieeeRecord.Cause.InvalidOperation = HighCause.InvalidOperation;

          // invoke the user-defined exception handler
          handler_return_value = handler (&FpieeeRecord);

          // return if not EXCEPTION_CONTINUE_EXECUTION
          if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

            __set_fpsr (&old_fpsr); /* restore caller fpsr */
            return (handler_return_value);

          }

          // clear the IEEE exception flags in the FPSR and
          // update the FPSR with values (possibly) set by the user handler
          // for the rounding mode, the precision mode, and the trap enable
          // bits

          /* change the FPSR with values (possibly) set by the user handler,
           * for continuing execution where the interruption occured */
  
          UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F10");
          UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F10");

          // update the trap disable bits
          I_dis = !FpieeeRecord.Enable.Inexact;
          U_dis = !FpieeeRecord.Enable.Underflow;
          O_dis = !FpieeeRecord.Enable.Overflow;
          Z_dis = !FpieeeRecord.Enable.ZeroDivide;
          V_dis = !FpieeeRecord.Enable.InvalidOperation;

          FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis 
              << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

          // save the result for the high half
          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
            case FPCVT_FX_PATTERN:
              I32High = FpieeeRecord.Result.Value.I32Value;
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
            case FPCVT_FXU_PATTERN:
              U32High = FpieeeRecord.Result.Value.U32Value;
              // break;

            default: ; // this case was caught above

          }

        } else if (HighCause.ZeroDivide) {

          fprintf (stderr, "IEEE Filter Internal Error: \
              HighCause.ZeroDivide in F10 instruction\n");
          exit (1);

        } else { //if not (HighCause.InvalidOperation || HighCauseDenormal ||
           // HighCause.ZeroDivide)

          // re-execute the high half of the instruction

          // modify the low half of FR2
          newFR2 = Combine (HighHalf (FR2), (float)0.0);

          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
              _xrun1args (FPCVT_FX_TRUNC, &FPSR, &FR1, &newFR2);
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
              _xrun1args (FPCVT_FXU_TRUNC, &FPSR, &FR1, &newFR2);
              break;

            case FPCVT_FX_PATTERN:
              _xrun1args (FPCVT_FX, &FPSR, &FR1, &newFR2);
              break;

            case FPCVT_FXU_PATTERN:
              _xrun1args (FPCVT_FXU, &FPSR, &FR1, &newFR2);
              // break;

            default: ; // this case was caught above

          }

          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
            case FPCVT_FX_PATTERN:
              I32High = I32HighHalf (FR1);
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
            case FPCVT_FXU_PATTERN:
              U32High = U32HighHalf (FR1);
              // break;

            default: ; // this case was caught above

          }

        } // end 'if not (HighCause.InvalidOperation || HighCauseDenormal ||
            // HighCause.ZeroDivide)'

        if (!LowCause.InvalidOperation && !LowCauseDenormal &&
            !HighCause.InvalidOperation && !HighCauseDenormal) {

          // should never get here
          fprintf (stderr, "IEEE Filter Internal Error: no enabled \
              exception (multiple fault) recognized in F10 instruction\n");
          exit (1);

        }

        Context->StFPSR = FPSR;

        // set the result before continuing execution
        switch (OpCode & F10_MASK) {

          case FPCVT_FX_TRUNC_PATTERN:
          case FPCVT_FX_PATTERN:
            FR1 = I32Combine (I32High, I32Low);
            break;

          case FPCVT_FXU_TRUNC_PATTERN:
          case FPCVT_FXU_PATTERN:
            FR1 = U32Combine (U32High, U32Low);
            // break;

          default: ; // this case was caught above

        }

        // set the result before continuing execution
        SetFloatRegisterValue (f1, FR1, Context);
        if (f1 < 32)
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl
        else
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh

        // this is a fault; need to advance the instruction pointer
        if (ei == 0) { // no template for this case
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000020000000000;
        } else if (ei == 1) { // templates: MFI, MFB
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000040000000000;
        } else { // if (ei == 2) // templates: MMF
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIIP = Context->StIIP + 0x10;
        }

      } else if (eXceptionCode == STATUS_FLOAT_MULTIPLE_TRAPS) {

        // Note that the convention chosen is for the processing to be 
        // performed in the order low first, high second, as SIMD operands
        // are stored in this order in memory in the little endian format
        // (this order would have to be changed for big endian); unlike
        // in the case of multiple faults, where execution of the user
        // exception handler for the low half could determine changes in
        // the high half, for traps in the high half, the rounding mode, 
        // precision mode, and trap enable bits are the initial ones (as
        // there is not enough information available to always adjust
        // correctly the result and/or the status flags after changes in
        // rounding mode and/or trap enable bits during a call to the
        // user-defined exception handler for the low half of the SIMD
        // instruction); the modifications to the FPSR are ONLY those 
        // performed by the last call to the user defined exception handler

        // this is a trap - get the result
        FR1 = GetFloatRegisterValue (f1, Context);

        if (LowCause.Inexact) {

          // invoke the user handler and check the return value

          // fill in the remaining fields of the _FPIEEE_RECORD (rounding
          // and precision already filled in)

          FpieeeRecord.Operand1.Format = _FpFormatFp32; /* 1 + 8 + 24 bits */
          FpieeeRecord.Operand1.OperandValid = 1;
          FpieeeRecord.Operand1.Value.Fp32Value = LowHalf (FR2);
          FpieeeRecord.Operand2.OperandValid = 0;
          FpieeeRecord.Operand3.OperandValid = 0;

          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
            case FPCVT_FX_PATTERN:
              FpieeeRecord.Result.Value.I32Value = I32LowHalf (FR1);
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
            case FPCVT_FXU_PATTERN:
              FpieeeRecord.Result.Value.U32Value = U32LowHalf (FR1);
              // break;

            // default: this case caught above

          }
          FpieeeRecord.Result.Format = ResultFormat;
          FpieeeRecord.Result.OperandValid = 1;

          FpieeeRecord.Operation = Operation;

          FpieeeRecord.Status.Inexact = LowStatus.Inexact;
          FpieeeRecord.Status.Underflow = LowStatus.Underflow;
          FpieeeRecord.Status.Overflow = LowStatus.Overflow;
          FpieeeRecord.Status.ZeroDivide = LowStatus.ZeroDivide;
          StatusDenormal = LowStatusDenormal;
          FpieeeRecord.Status.InvalidOperation = LowStatus.InvalidOperation;

          FpieeeRecord.Cause.Inexact = LowCause.Inexact;
          FpieeeRecord.Cause.Underflow = LowCause.Underflow;
          FpieeeRecord.Cause.Overflow = LowCause.Overflow;
          FpieeeRecord.Cause.ZeroDivide = LowCause.ZeroDivide;
          CauseDenormal = LowCauseDenormal;
          FpieeeRecord.Cause.InvalidOperation = LowCause.InvalidOperation;

          // invoke the user-defined exception handler
          handler_return_value = handler (&FpieeeRecord);

          // return if not EXCEPTION_CONTINUE_EXECUTION
          if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

            __set_fpsr (&old_fpsr); /* restore caller fpsr */
            return (handler_return_value);

          }

          // clear the IEEE exception flags in the FPSR and
          // update the FPSR with values (possibly) set by the user handler
          // for the rounding mode, the precision mode, and the trap enable
          // bits; if the high half needs to be re-executed, the old FPSR
          // will be used; same if it is forwarded to the user-defined handler

          UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F10");
          UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F10");

          // Update the trap disable bits
          I_dis = !FpieeeRecord.Enable.Inexact;
          U_dis = !FpieeeRecord.Enable.Underflow;
          O_dis = !FpieeeRecord.Enable.Overflow;
          Z_dis = !FpieeeRecord.Enable.ZeroDivide;
          V_dis = !FpieeeRecord.Enable.InvalidOperation;

          FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis 
              << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

          // save the result for the low half
          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
            case FPCVT_FX_PATTERN:
              I32Low = FpieeeRecord.Result.Value.I32Value;
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
            case FPCVT_FXU_PATTERN:
              U32Low = FpieeeRecord.Result.Value.U32Value;
              // break;

            default: ; // this case was caught above

          }

        } else if (LowCause.Underflow || LowCause.Overflow) {

          fprintf (stderr, "IEEE Filter Internal Error: \
              LowCause.Underflow or LowCause.Overflow in F10 instruction\n");
          exit (1);

        } else { // if not (LowCause.Inexact, Underflow, or Overflow)

          // nothing to do for the low half of the instruction - the result
          // is correct
          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
            case FPCVT_FX_PATTERN:
              I32Low = I32LowHalf (FR1); // for uniformity
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
            case FPCVT_FXU_PATTERN:
              U32Low = U32LowHalf (FR1); // for uniformity
              // break;

            default: ; // this case was caught above

          }

        } // end 'if not (LowCause.Underflow, Overflow, Inexact)'

        if (HighCause.Inexact) {

          // invoke the user-defined exception handler and check the return 
          // value; since this might be the second call to the user handler,
          // make sure all the _FPIEEE_RECORD fields are correct;
          // return if handler_return_value is not 
          // EXCEPTION_CONTINUE_EXECUTION, otherwise combine the results

          // the rounding mode is the initial one
          FpieeeRecord.RoundingMode = RoundingMode;

          // the precision mode is the initial one
          FpieeeRecord.Precision = Precision;

          // the enable flags are the initial ones
          FPSR = Context->StFPSR;
          I_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 5) & 0x01);
          U_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 4) & 0x01);
          O_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 3) & 0x01);
          Z_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 2) & 0x01);
          D_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 1) & 0x01);
          V_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 0) & 0x01);

          FpieeeRecord.Enable.Inexact = !I_dis;
          FpieeeRecord.Enable.Underflow = !U_dis;
          FpieeeRecord.Enable.Overflow = !O_dis;
          FpieeeRecord.Enable.ZeroDivide = !Z_dis;
          EnableDenormal = !D_dis;
          FpieeeRecord.Enable.InvalidOperation = !V_dis;

          FpieeeRecord.Operand1.Format = _FpFormatFp32; /* 1+8+24 bits */
          FpieeeRecord.Operand1.OperandValid = 1;
          FpieeeRecord.Operand1.Value.Fp32Value = HighHalf (FR2);
          FpieeeRecord.Operand2.OperandValid = 0;
          FpieeeRecord.Operand3.OperandValid = 0;

          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
            case FPCVT_FX_PATTERN:
              FpieeeRecord.Result.Value.I32Value = I32HighHalf (FR1);
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
            case FPCVT_FXU_PATTERN:
              FpieeeRecord.Result.Value.U32Value = U32HighHalf (FR1);
              // break;

            // default: this case caught above

          }
          FpieeeRecord.Result.Format = ResultFormat;
          FpieeeRecord.Result.OperandValid = 1;

          FpieeeRecord.Operation = Operation;

          // use the initial values
          FpieeeRecord.Status.Inexact = HighStatus.Inexact;
          FpieeeRecord.Status.Underflow = HighStatus.Underflow;
          FpieeeRecord.Status.Overflow = HighStatus.Overflow;
          FpieeeRecord.Status.ZeroDivide = HighStatus.ZeroDivide;
          StatusDenormal = HighStatusDenormal;
          FpieeeRecord.Status.InvalidOperation = HighStatus.InvalidOperation;

          FpieeeRecord.Cause.Inexact = HighCause.Inexact;
          FpieeeRecord.Cause.Underflow = HighCause.Underflow;
          FpieeeRecord.Cause.Overflow = HighCause.Overflow;
          FpieeeRecord.Cause.ZeroDivide = HighCause.ZeroDivide;
          CauseDenormal = HighCauseDenormal;
          FpieeeRecord.Cause.InvalidOperation = HighCause.InvalidOperation;

          // invoke the user-defined exception handler
          handler_return_value = handler (&FpieeeRecord);

          // return if not EXCEPTION_CONTINUE_EXECUTION
          if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

            __set_fpsr (&old_fpsr); /* restore caller fpsr */
            return (handler_return_value);

          }

          // clear the IEEE exception flags in the FPSR;
          // update the FPSR with values (possibly) set by the user handler
          // for the rounding mode, the precision mode, and the trap enable
          // bits, before continuing execution where the interruption occured
          UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F10");
          UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F10");

          I_dis = !FpieeeRecord.Enable.Inexact;
          U_dis = !FpieeeRecord.Enable.Underflow;
          O_dis = !FpieeeRecord.Enable.Overflow;
          Z_dis = !FpieeeRecord.Enable.ZeroDivide;
          V_dis = !FpieeeRecord.Enable.InvalidOperation;

          FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis 
              << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

          // save the result for the high half
          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
            case FPCVT_FX_PATTERN:
              I32High = FpieeeRecord.Result.Value.I32Value;
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
            case FPCVT_FXU_PATTERN:
              U32High = FpieeeRecord.Result.Value.U32Value;
              // break;

            default: ; // this case was caught above

          }

        } else if (HighCause.Underflow || HighCause.Overflow) {

          fprintf (stderr, "IEEE Filter Internal Error: \
             HighCause.Underflow or HighCause.Overflow in F10 instruction\n");
          exit (1);

        } else { // if not (HighCause.Inexact, Underflow, or Overflow)

          // nothing to do for the high half of the instruction - the result
          // is correct
          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
            case FPCVT_FX_PATTERN:
              I32High = I32HighHalf (FR1); // for uniformity
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
            case FPCVT_FXU_PATTERN:
              U32High = U32HighHalf (FR1); // for uniformity
              // break;

            default: ; // this case was caught above

          }

        } // end 'if not (HighCause.Underflow, Overflow, or Inexact)'

        if (!LowCause.Inexact && !HighCause.Inexact) {

          // should never get here
          fprintf (stderr, "IEEE Filter Internal Error: no enabled \
              [multiple trap] exception recognized in F10 instruction\n");
          exit (1);

        }

        Context->StFPSR = FPSR;

        // set the result before continuing execution
        switch (OpCode & F10_MASK) {

          case FPCVT_FX_TRUNC_PATTERN:
          case FPCVT_FX_PATTERN:
            FR1 = I32Combine (I32High, I32Low);
            break;

          case FPCVT_FXU_TRUNC_PATTERN:
          case FPCVT_FXU_PATTERN:
            FR1 = U32Combine (U32High, U32Low);
            // break;

          default: ; // this case was caught above

        }

        // set the result before continuing execution
        SetFloatRegisterValue (f1, FR1, Context);
        if (f1 < 32)
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl
        else
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh

      } else {

        fprintf (stderr, "IEEE Filter Internal Error: exception \
            code %x invalid or not recognized in F10 SIMD instruction\n",
            eXceptionCode);
        exit (1);

      }

    }

  } else {

    /* unrecognized instruction type */
    fprintf (stderr, "IEEE Filter Internal Error: \
 instruction opcode %8x %8x not recognized\n", 
        (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
    exit (1);

  }

  /* the context record contains at this point the result(s) */
  __set_fpsr (&old_fpsr); /* restore caller fpsr */

  return (handler_return_value);

}




static _FP128
FPIeeeToFP128 (_FPIEEE_RECORD *pFpieeeRecord)

{

  _FP128 ReturnValue;

  unsigned __int64 significand;
  unsigned int exponent;
  unsigned int sign;
  _FP32 f32;
  _FP64 f64;
  _FP80 f80;
  unsigned int u32;
  unsigned __int64 u64;
  unsigned __int64 *pu64;
  char *p;


  // expand the result in the FPIEEE record to 1 + 17 + 64 = 82 bits; write
  // then in memory spill format, and return value

  switch (pFpieeeRecord->Result.Format) {

    case _FpFormatFp32: 
      // 1 + 8 + 24 bits, for _FpPrecision24
      // got _FP32 Fp32Value (float)
      f32 = pFpieeeRecord->Result.Value.Fp32Value;
      u32 = *((unsigned int *)&f32);
      sign = u32 >> 31;
      exponent = (u32 >> 23) & 0x0ff; // cut off the sign bit
      if (exponent == 0x0ff) {
        exponent = 0x01ffff; // special value
      } else if (exponent != 0) {
        exponent = exponent - 0x07f + 0x0ffff;
      }
      significand = ((unsigned __int64)(u32 & 0x07fffff) << 40); 
          // cut 23 bits and shift left
      if (exponent != 0) { 
        significand = (((unsigned __int64)1) << 63) | significand; 
          // not denormal - add J-bit
      }
#ifdef FPIEEE_FLT_DEBUG
      printf ("FPIEEE_FLT_DEBUG FPIeeeToFP128 32 sign exp signif =\
 %x %x %8x %8x\n", sign, exponent, 
          (int)(significand >> 32) & 0xffffffff, (int)significand & 0xffffffff);
#endif
      break;

    case _FpFormatFp64: 
      // 1 + 11 + 53 bits, for _FpPrecision53
      // got _FP64 Fp64Value (double)
      f64 = pFpieeeRecord->Result.Value.Fp64Value;
      u64 = *((unsigned __int64 *)&f64);
      sign = (unsigned int)(u64 >> 63);
      exponent = (unsigned int)((u64 >> 52) & 0x07ff); // cut off the sign bit
      significand = ((u64 & 0x0fffffffffffff) << 11);
          // cut 52 bits and shift left
      if (exponent == 0x07ff) { // special value
        exponent = 0x01ffff;
        significand = (((unsigned __int64)1) << 63) | significand;
      } else if (exponent == 0 && significand != (unsigned __int64)0) { // denormal
        exponent = 0xfc01;
      } else if (exponent != 0) {
        exponent = exponent - 0x03ff + 0x0ffff;
        significand = (((unsigned __int64)1) << 63) | significand;
      }
#ifdef FPIEEE_FLT_DEBUG
      printf ("FPIEEE_FLT_DEBUG FPIeeeToFP128 64 sign exp signif =\
 %x %x %8x %8x\n", sign, exponent, 
          (int)(significand >> 32) & 0xffffffff, (int)significand & 0xffffffff);
#endif
      break;

    case _FpFormatFp80: 
      // 1 + 15 + 24 bits if _FpPrecision24
      // 1 + 15 + 53 bits if _FpPrecision53
      // 1 + 15 + 64 bits if _FpPrecision64
      // got _FP80 Fp80Value (typedef struct { unsigned short W[5] })
      f80 = pFpieeeRecord->Result.Value.Fp80Value;
      sign = (f80.W[4] >> 15) & 0x01;
      exponent = f80.W[4] & 0x07fff; // cut off the sign bit
      pu64 = (unsigned __int64 *)&f80;
      significand = *pu64;
      if (exponent == 0x07fff) {
        exponent = 0x01ffff; // special value
      } else if (exponent == 0 && significand != (unsigned __int64)0) {
          // denormal
        ; // exponent remains 0x0 rather than 0xc001
      } else if (exponent != 0) {
        exponent = exponent - 0x03fff + 0x0ffff;
      }
#ifdef FPIEEE_FLT_DEBUG
      printf ("FPIEEE_FLT_DEBUG FPIeeeToFP128 80 sign exp signif =\
 %x %x %8x %8x\n", sign, exponent, 
          (int)(significand >> 32) & 0xffffffff, (int)significand & 0xffffffff);
#endif
      break;

    case _FpFormatFp82: 
      // 1 + 17 + 24 bits if _FpPrecision24
      // 1 + 17 + 53 bits if _FpPrecision53
      // 1 + 17 + 64 bits if _FpPrecision64
      // got _FP128 Fp128Value (typedef struct { unsigned __int64 W[4] })
      ReturnValue = pFpieeeRecord->Result.Value.Fp128Value;
#ifdef FPIEEE_FLT_DEBUG
      printf ("FPIEEE_FLT_DEBUG FPIeeeToFP128: RetVal = %08x %08x %08x %08x\n",
          ReturnValue.W[3], ReturnValue.W[2], 
          ReturnValue.W[1], ReturnValue.W[0]);
#endif
      return (ReturnValue);
      break;

    default:
      // should never get here: unrecognized pFpieeeRecord->Result.Format
      fprintf (stderr, "FPIeeeToFP128 () Error: \
          pFpieeeRecord->Result.Format %x not recognized\n", 
          pFpieeeRecord->Result.Format);
      exit (1);

  }

  p = (char *)(&ReturnValue);
  memcpy (p, (char *)&significand, 8);
  p[8] = exponent & 0x0ff;
  p[9] = (exponent >> 8) & 0x0ff;
  p[10] = (exponent >> 16) | (sign << 1);
  p[11] = 0;
  p[12] = 0;
  p[13] = 0;
  p[14] = 0;
  p[15] = 0;

#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG FPIeeeToFP128: ReturnValue = %08x %08x %08x %08x\n",
      ReturnValue.W[3], ReturnValue.W[2], ReturnValue.W[1], ReturnValue.W[0]);
#endif

  return (ReturnValue);

}




static void 
FP128ToFPIeee (_FPIEEE_RECORD *pFpieeeRecord, int scale)

{

  // called for O, U, or I; the result, a valid number, is received always in 
  // pFpieeeRecord->Result.Value.Fp128Value; it is scaled (if necessary), and
  // put into the Result.Format; effective only 32, 64, 80, and 82-bit formats

  unsigned __int64 significand;
  unsigned int exponent;
  unsigned int sign;
  _FP32 f32;
  _FP64 f64;
  unsigned int u32;
  unsigned __int64 u64;


  switch (pFpieeeRecord->Result.Format) {
    case _FpFormatFp32:
    case _FpFormatFp64:
    case _FpFormatFp80:
    case _FpFormatFp82:
      // extract sign, exponent, and significand
      sign = ((pFpieeeRecord->Result.Value.Fp128Value.W[2] & 0x020000) != 0);
      exponent = pFpieeeRecord->Result.Value.Fp128Value.W[2] & 0x1ffff;
      significand = 
          ((__int64)(pFpieeeRecord->Result.Value.Fp128Value.W[1])) << 32 |
          (((__int64)pFpieeeRecord->Result.Value.Fp128Value.W[0]) & 0xffffffff);
	  if(pFpieeeRecord->Result.Format==_FpFormatFp80 && exponent==0 && significand!=0) exponent=0xc001;
      break;
    default:
      // error - should never get here
      fprintf (stderr, "FP128ToFPIeee () Internal Error: \
          Result.Format %x not recognized\n", pFpieeeRecord->Result.Format);
      exit (1);
  }

  if (exponent == 0 && significand == (__int64)0) { // if the result is zero
    if(!sign) { // if the sign bit is 0, return positive 0 
      switch (pFpieeeRecord->Result.Format) {
        case _FpFormatFp32:  
          u32=0x0;
          pFpieeeRecord->Result.Value.Fp32Value = *((_FP32 *)&u32);
          break;
        case _FpFormatFp64:
          u64 = (__int64)0x0;
          pFpieeeRecord->Result.Value.Fp64Value = *((_FP64 *)&u64);
          break;
        case _FpFormatFp80:
          pFpieeeRecord->Result.Value.Fp80Value.W[4] =  0x0;
          pFpieeeRecord->Result.Value.Fp80Value.W[3] =  0x0;
          pFpieeeRecord->Result.Value.Fp80Value.W[2] =  0x0;
          pFpieeeRecord->Result.Value.Fp80Value.W[1] =  0x0;
          pFpieeeRecord->Result.Value.Fp80Value.W[0] =  0x0;
          break;
        case _FpFormatFp82:
          ; // do nothing, the positive 0 is already there
      }
    } else { // return negative 0 otherwise
      switch (pFpieeeRecord->Result.Format) {
        case _FpFormatFp32:  
          u32=0x80000000;
          pFpieeeRecord->Result.Value.Fp32Value = *((_FP32 *)&u32);
          break;
        case _FpFormatFp64:
          u64 = (((__int64)1) << 63);
          pFpieeeRecord->Result.Value.Fp64Value = *((_FP64 *)&u64);
          break;
        case _FpFormatFp80:
          pFpieeeRecord->Result.Value.Fp80Value.W[4] =  0x8000;
          pFpieeeRecord->Result.Value.Fp80Value.W[3] =  0x0;
          pFpieeeRecord->Result.Value.Fp80Value.W[2] =  0x0;
          pFpieeeRecord->Result.Value.Fp80Value.W[1] =  0x0;
          pFpieeeRecord->Result.Value.Fp80Value.W[0] =  0x0;
          break;
        case _FpFormatFp82:
          ; // do nothing, the negative 0 is already there
      }
    }
    return;
  } 

  if (!pFpieeeRecord->Cause.Overflow && !pFpieeeRecord->Cause.Underflow &&
      (exponent == 0x1ffff)) { // if the result is infinity for inexact exc.
    // if the sign bit is 0, return positive infinity
    if(!sign) { // if positive
      switch (pFpieeeRecord->Result.Format) {
        case _FpFormatFp32:  
          u32=0x7f800000;
          pFpieeeRecord->Result.Value.Fp32Value = *((_FP32 *)&u32);
          break;
        case _FpFormatFp64:
          u64 = 0x7ff0000000000000;
          pFpieeeRecord->Result.Value.Fp64Value = *((_FP64 *)&u64);
          break;
        case _FpFormatFp80:
          pFpieeeRecord->Result.Value.Fp80Value.W[4] =  0x7fff;
          pFpieeeRecord->Result.Value.Fp80Value.W[3] =  0x8000;
          pFpieeeRecord->Result.Value.Fp80Value.W[2] =  0x0;
          pFpieeeRecord->Result.Value.Fp80Value.W[1] =  0x0;
          pFpieeeRecord->Result.Value.Fp80Value.W[0] =  0x0;
          break;
        case _FpFormatFp82:
          ; // do nothing, the positive infinity is already there
      }
    } else { // return negative infinity
      switch (pFpieeeRecord->Result.Format) {
        case _FpFormatFp32:  
          u32=0xff800000;
          pFpieeeRecord->Result.Value.Fp32Value = *((_FP32 *)&u32);
          break;
        case _FpFormatFp64:
          u64 = 0xfff0000000000000;
          pFpieeeRecord->Result.Value.Fp64Value = *((_FP64 *)&u64);
          break;
        case _FpFormatFp80:
          pFpieeeRecord->Result.Value.Fp80Value.W[4] =  0xffff;
          pFpieeeRecord->Result.Value.Fp80Value.W[3] =  0x8000;
          pFpieeeRecord->Result.Value.Fp80Value.W[2] =  0x0;
          pFpieeeRecord->Result.Value.Fp80Value.W[1] =  0x0;
          pFpieeeRecord->Result.Value.Fp80Value.W[0] =  0x0;
          break;
        case _FpFormatFp82:
          ; // do nothing, the negative infinity is already there
      }
    }
    return;
  } 

  // adjust exponent
  // for any operands of fma, 2^(2e_min-2N+2) <= exp (fma) <= 2^(2e_max+2)
  // (same for fms, fnma, fpma, fpms, fpnma)
  switch (pFpieeeRecord->Result.Format) {
	  /* Exponent range for divide: bias+2*EMIN-PREC<=exponent<=bias+2*EMAX+PREC-2 */
    case _FpFormatFp32:
      if ((0xffff-2*(126+23)) <= exponent && exponent <= (0xffff+2*127+22)) {
        // all the valid results from operations on single precision floating-
        // point numbers fit in this range 0xfed5 <= exponent <= 0x100fe
        scale = scale * 192; // 192 = 3/4 * 2^8
        exponent += scale;	
      } else {
        // pFpieeeRecord->Result.Format = _FpFormatFp82 in conjunction (for
        // example) with _FpCodeFmaSingle (which expects 
        // pFpieeeRecord->Result.Format = _FpFormatFp32) will indicate that
        // the result is outside the range where it can be scaled as required
        // by the IEEE standard
        pFpieeeRecord->Result.Format = _FpFormatFp82;
		/* comment out warnings for confidence tests */
        /*printf ("IEEE FILTER fpieee_flt () / FP128ToFPIeee () WARNING: operands"
            " for single precision operation were out of the single precision "
            "range\n");*/
      }
      break;
    case _FpFormatFp64:
      if ((0xffff-2*(1022+52)) <= exponent && exponent <= (0xffff+2*1023+51)) {
        // all the valid results from operations on double precision floating-
        // point numbers fit in this range
        scale = scale * 1536; // 1536 = 3/4 * 2^11
        exponent += scale;
      } else {
        // pFpieeeRecord->Result.Format = _FpFormatFp82 in conjunction (for
        // example) with _FpCodeFmaDouble (which expects 
        // pFpieeeRecord->Result.Format = _FpFormatFp64) will indicate that
        // the result is outside the range where it can be scaled as required
        // by the IEEE standard
        pFpieeeRecord->Result.Format = _FpFormatFp82;
		/* comment out warnings for confidence tests */
        /*printf ("IEEE FILTER fpieee_flt () / FP128ToFPIeee () WARNING: operands"
            " for double precision operation were out of the double precision "
            "range\n");*/
      }
      break;
    case _FpFormatFp80:
      if ((0xffff-2*(16382+63)) <= exponent && exponent <= (0xffff+2*16383+62)) {
        // all the valid results from operations on double-extended precision 
        // floating-point numbers fit in this range
        scale = scale * 24576; // 24576 = 3/4 * 2^15
        exponent += scale;
      } else {
        // pFpieeeRecord->Result.Format = _FpFormatFp82 in conjunction (for
        // example) with _FpCodeFma and FPSR.sf.pc = 0x11 (which expects 
        // pFpieeeRecord->Result.Format = _FpFormatFp80) will indicate that
        // the result is outside the range where it can be scaled as required
        // by the IEEE standard
        pFpieeeRecord->Result.Format = _FpFormatFp82;
		/* comment out warnings for confidence tests */
        /*printf ("IEEE FILTER fpieee_flt () / FP128ToFPIeee () WARNING: operands"
            " for double-extended precision operation were out of the "
            " double-extended precision range\n"); */
      }
      break;
    case _FpFormatFp82:
      if (pFpieeeRecord->Cause.Overflow && (exponent < 0x1ffff))
          exponent += 0x20000;
      if (pFpieeeRecord->Cause.Underflow && (exponent > 0x0))
          exponent -= 0x20000;
      scale = scale * 98304; // 98304 = 3/4 * 2^17
      exponent += scale;
      exponent = exponent & 0x1ffff;
      break;
    default: ; // will never get here
  }

  switch (pFpieeeRecord->Result.Format) {
    case _FpFormatFp32:
      if (significand >> 63) 
          exponent = exponent - 0x0ffff + 0x07f; // unbiased now in [-60, +65]
      else
          exponent = 0;
      u32 = (sign ? 0x80000000 : 0x0) | (exponent << 23) | 
          (unsigned int)((significand >> 40) & 0x7fffff);
      f32 = *((_FP32 *)&u32);
#ifdef FPIEEE_FLT_DEBUG
      printf ("FPIEEE_FLT_DEBUG FP128ToFPIeee HW ADJ f32 = 0x%08x\n",
          *(int *)&f32);
#endif
      pFpieeeRecord->Result.Value.Fp32Value = f32;
      break;
    case _FpFormatFp64:
      if (significand >> 63) 
          exponent = exponent - 0x0ffff + 0x03ff;
      else
          exponent = 0;
      u64 = (sign ? (((__int64)1) << 63) : 0x0) | 
          (((unsigned __int64)exponent) << 52) |
          (unsigned __int64)(((significand >> 11) & 0xfffffffffffff));
      f64 = *((_FP64 *)&u64);
#ifdef FPIEEE_FLT_DEBUG
      printf ("FPIEEE_FLT_DEBUG FP128ToFPIeee HW ADJ f64 = 0x%I64x\n",
          *(unsigned __int64 *)&f64);
#endif
      pFpieeeRecord->Result.Value.Fp64Value = f64;
      break;
    case _FpFormatFp80:
      if (significand >> 63) 
          exponent = exponent - 0x0ffff + 0x03fff;
      else
          exponent = 0;
      pFpieeeRecord->Result.Value.Fp80Value.W[4] = (sign ? 0x8000 : 0x0) |
          (exponent & 0x7fff);
      pFpieeeRecord->Result.Value.Fp80Value.W[3] =
	  (unsigned short)((significand >> 48) & 0xffff);
      pFpieeeRecord->Result.Value.Fp80Value.W[2] =
	  (unsigned short)((significand >> 32) & 0xffff);
      pFpieeeRecord->Result.Value.Fp80Value.W[1] =
	  (unsigned short)((significand >> 16) & 0xffff);
      pFpieeeRecord->Result.Value.Fp80Value.W[0] =
	  (unsigned short)(significand & 0xffff);
#ifdef FPIEEE_FLT_DEBUG
      printf ("FPIEEE_FLT_DEBUG FP128ToFPIeee HW ADJ f80= \
%08x %08x %08x %08x %08x\n",
          pFpieeeRecord->Result.Value.Fp80Value.W[4],
          pFpieeeRecord->Result.Value.Fp80Value.W[3],
          pFpieeeRecord->Result.Value.Fp80Value.W[2],
          pFpieeeRecord->Result.Value.Fp80Value.W[1],
          pFpieeeRecord->Result.Value.Fp80Value.W[0]);
#endif
      break;
    case _FpFormatFp82:
      pFpieeeRecord->Result.Value.Fp128Value.W[3] = 0x0;
      pFpieeeRecord->Result.Value.Fp128Value.W[2] = (sign << 17) | exponent;
      pFpieeeRecord->Result.Value.Fp128Value.W[1] =
	  (unsigned long)(significand >> 32);
      pFpieeeRecord->Result.Value.Fp128Value.W[0] =
	  (unsigned long)(significand & 0xffffffff);
      break;
    default: ; // will never get here
  }

}




static void
UpdateRoundingMode (
    unsigned int RoundingMode, 
    unsigned int sf,
    unsigned __int64 *FPSR, char *name)

{

  switch (RoundingMode) {

    case _FpRoundNearest:
      *FPSR = (*FPSR & ~((unsigned __int64)RC_MASK << (6 + sf * 13 + 4)))
          | ((unsigned __int64)RN_MASK << (6 + sf * 13 + 4));
      break;

    case _FpRoundMinusInfinity:
      *FPSR = (*FPSR & ~((unsigned __int64)RC_MASK << (6 + sf * 13 + 4)))
          | ((unsigned __int64)RM_MASK << (6 + sf * 13 + 4));
      break;

    case _FpRoundPlusInfinity:
      *FPSR = (*FPSR & ~((unsigned __int64)RC_MASK << (6 + sf * 13 + 4)))
          | ((unsigned __int64)RP_MASK << (6 + sf * 13 + 4));
      break;

    case _FpRoundChopped:
      *FPSR = (*FPSR & ~((unsigned __int64)RC_MASK << (6 + sf * 13 + 4)))
          | ((unsigned __int64)RZ_MASK << (6 + sf * 13 + 4));
      break;

    default:
      /* should never get here: unrecognized FpieeeRecord.RoundingMode */
      fprintf (stderr, "IEEE Filter Internal Error: \
          FpieeeRecord.RoundingMode %x not recognized \
          for %s instruction\n", RoundingMode, name);
      exit (1);

  }

}




static void
UpdatePrecision (
    unsigned int Precision,
    unsigned int sf,
    unsigned __int64 *FPSR, char *name)

{

  switch (Precision) {

    case _FpPrecision64:
      *FPSR = (*FPSR & ~((unsigned __int64)PC_MASK << (6 + sf * 13 + 2)))
          | ((unsigned __int64)DBL_EXT_MASK << (6 + sf * 13 + 2));
      break;

    case _FpPrecision53:
      *FPSR = (*FPSR & ~((unsigned __int64)PC_MASK << (6 + sf * 13 + 2)))
          | ((unsigned __int64)DBL_MASK << (6 + sf * 13 + 2));
      break;

    case _FpPrecision24:
      *FPSR = (*FPSR & ~((unsigned __int64)PC_MASK << (6 + sf * 13 + 2)))
          | ((unsigned __int64)SGL_MASK << (6 + sf * 13 + 2));
      break;

    default:
      /* should never get here: unrecognized FpieeeRecord.Precision */
      fprintf (stderr, "IEEE Filter Internal Error: \
          FpieeeRecord.Precision %x not recognized \
          for %s instruction\n", Precision, name);
      exit (1);

  }

}




static _FP128
FP32ToFP128 (_FP32 f32)

{

  _FP128 f128;

  unsigned __int64 significand;
  unsigned int exponent;
  unsigned int sign;
  unsigned int u32;
  char *p;


  // expand the value in f32 to 1 + 17 + 64 = 82 bits; write
  // then in memory spill format, and return value

  // 1 + 8 + 24 bits, for _FpPrecision24
  // got _FP32 f32 (float)
  u32 = *((unsigned int *)&f32);
  sign = u32 >> 31;
  exponent = (u32 >> 23) & 0x0ff; // cut off the sign bit
  if (exponent == 0x0ff) {
    exponent = 0x01ffff; // special value
  } else if (exponent != 0) {
    exponent = exponent - 0x07f + 0x0ffff;
  }
  significand = ((unsigned __int64)(u32 & 0x07fffff) << 40); 
      // cut 23 bits and shift left
  if (exponent != 0) { 
    significand = (((unsigned __int64)1) << 63) | significand; 
      // not denormal - add J-bit
  }

  p = (char *)(&f128);
  memcpy (p, (char *)&significand, 8);
  p[8] = exponent & 0x0ff;
  p[9] = (exponent >> 8) & 0x0ff;
  p[10] = (exponent >> 16) | (sign << 1);
  p[11] = 0;
  p[12] = 0;
  p[13] = 0;
  p[14] = 0;
  p[15] = 0;

  return (f128);

}



static _FP128
FP32ToFP128modif (_FP32 f32, int adj_exp)

{

  _FP128 f128;

  unsigned __int64 significand;
  unsigned int exponent;
  unsigned int sign;
  unsigned int u32;
  char *p;


  // expand the value in f32 to 1 + 17 + 64 = 82 bits; write
  // then in memory spill format, and return value

  // 1 + 8 + 24 bits, for _FpPrecision24
  // got _FP32 f32 (float)
  u32 = *((unsigned int *)&f32);
  sign = u32 >> 31;
  exponent = (u32 >> 23) & 0x0ff; // cut off the sign bit
  significand = ((unsigned __int64)(u32 & 0x07fffff) << 40);
      // cut 23 bits and shift left
  if (exponent == 0x0ff) {
    exponent = 0x01ffff; // special value
    significand = (((unsigned __int64)1) << 63) | significand;
  } else if (exponent == 0 && significand != (unsigned __int64)0) { // denormal
    exponent = 0xff81;
  } else if (exponent != 0) {
    exponent = exponent - 0x07f + 0x0ffff;
    exponent += adj_exp;
    significand = (((unsigned __int64)1) << 63) | significand;
  }

  p = (char *)(&f128);
  memcpy (p, (char *)&significand, 8);
  p[8] = exponent & 0x0ff;
  p[9] = (exponent >> 8) & 0x0ff;
  p[10] = (exponent >> 16) | (sign << 1);
  p[11] = 0;
  p[12] = 0;
  p[13] = 0;
  p[14] = 0;
  p[15] = 0;

  return (f128);

}




static _FP32 
LowHalf (_FP128 FR)

{

  // return the floating-point number from the low half of FR

  _FP32 Low;
  unsigned __int64 ULLow;

  ULLow = FR.W[0];
  Low = *((_FP32 *)&ULLow);

  return (Low);

}




static _FP32
HighHalf (_FP128 FR)

{

  // return the floating-point number from the high half of FR

  _FP32 High;
  unsigned __int64 ULHigh;

  ULHigh = FR.W[1];
  High = *((_FP32 *)&ULHigh);

  return (High);

}




static int
I32LowHalf (_FP128 FR)

{

  // return the int from the low half of FR

  int Low;

  Low = (int)FR.W[0];
  return (Low);

}




static int
I32HighHalf (_FP128 FR)

{

  // return the int from the high half of FR

  unsigned int High;

  High = (unsigned int)FR.W[1];
  return (High);

}




static unsigned int
U32LowHalf (_FP128 FR)

{

  // return the unsigned int from the low half of FR

  unsigned int Low;

  Low = (unsigned int)FR.W[0];
  return (Low);

}




static unsigned int
U32HighHalf (_FP128 FR)

{

  // return the unsigned int from the high half of FR

  unsigned int High;

  High = (unsigned int)FR.W[1];
  return (High);

}




static _FP128 
Combine (_FP32 High, _FP32 Low)

{

  _FP128 FR;
  unsigned int ULLow, ULHigh;

  ULLow = *((unsigned int *)&Low);
  ULHigh = *((unsigned int *)&High);
 
  FR.W[0] = ULLow;
  FR.W[1] = ULHigh;
  FR.W[2] = (unsigned int)0x01003e;
  FR.W[3] = 0;

  return (FR);

}




static _FP128 
I32Combine (int High, int Low)

{

  _FP128 FR;

  FR.W[0] = (unsigned int)Low;
  FR.W[1] = (unsigned int)High;
  FR.W[2] = (unsigned int)0x01003e;
  FR.W[3] = 0;

  return (FR);

}




static _FP128 
U32Combine (unsigned int High, unsigned int Low)

{

  _FP128 FR;

  FR.W[0] = (unsigned int)Low;
  FR.W[1] = (unsigned int)High;
  FR.W[2] = (unsigned int)0x01003e;
  FR.W[3] = 0;

  return (FR);

}




static _FP128
GetFloatRegisterValue (unsigned int f, PCONTEXT Context)

{

  _FP128 FR82;
  unsigned __int64 *p1, *p2;


  p1 = (unsigned __int64 *)&FR82;

  if (f == 0) {

    /* + 0.0 */
    *p1 = 0;
    *(p1 + 1) = 0;

  } else if (f == 1) {

    /* + 1.0 */
    *p1 = 0x8000000000000000;
    *(p1 + 1) = 0x000000000000ffff;

  } else if (f >= 2 && f <= 127) {

    p2 = (unsigned __int64 *)&(Context->FltS0);
    p2 = p2 + 2 * (f - 2);
    *p1 = *p2;
    *(p1 + 1) = *(p2 + 1);

  } else {

    fprintf (stderr, "IEEE Filter / GetFloatRegisterValue () Internal Error: \
FP register number f = %x is not valid\n", f);
    exit (1);

  }

  return (FR82);

}




static void
SetFloatRegisterValue (unsigned int f, _FP128 Value, PCONTEXT Context)

{

  unsigned __int64 *p1, *p2;


  p2 = (unsigned __int64 *)&Value;

  if (f >= 2 && f <= 127) {

    p1 = (unsigned __int64 *)&(Context->FltS0);
    p1 = p1 + 2 * (f - 2);
    *p1 = *p2;
    *(p1 + 1) = *(p2 + 1);

  } else {

    fprintf (stderr, "IEEE Filter / SetFloatRegisterValue () Internal Error: \
FP register number f = %x is not valid\n", f);
    exit (1);

  }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\coshf.s ===
.file "coshf.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version
// 2/16/00  The error tag for coshf overflow changed to 65 (from 64).
// 4/04/00  Unwind support added
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
//
// API
//==============================================================
// float = coshf(float)
// input  floating point f8
// output floating point f8


// Overview of operation
//==============================================================
// There are four paths

// 1. |x| < 0.25        COSH_BY_POLY
// 2. |x| < 32          COSH_BY_TBL
// 3. |x| < 2^14        COSH_BY_EXP
// 4. |x_ >= 2^14       COSH_HUGE

// For paths 1, and 2 SAFE is always 1.
// For path  4, Safe is always 0.
// SAFE = 1 means we cannot overflow.


// Assembly macros
//==============================================================
coshf_FR_X            = f44
coshf_FR_SGNX         = f40

coshf_FR_Inv_log2by64 = f9
coshf_FR_log2by64_lo  = f11
coshf_FR_log2by64_hi  = f10

coshf_FR_A1           = f9
coshf_FR_A2           = f10
coshf_FR_A3           = f11

coshf_FR_Rcub         = f12
coshf_FR_M_temp       = f13
coshf_FR_R_temp       = f13
coshf_FR_Rsq          = f13
coshf_FR_R            = f14

coshf_FR_M            = f38

coshf_FR_B1           = f15
coshf_FR_B2           = f32
coshf_FR_B3           = f33

coshf_FR_peven_temp1  = f34
coshf_FR_peven_temp2  = f35
coshf_FR_peven        = f36

coshf_FR_podd_temp1   = f34
coshf_FR_podd_temp2   = f35
coshf_FR_podd         = f37

coshf_FR_J_temp       = f9
coshf_FR_J            = f10

coshf_FR_Mmj          = f39

coshf_FR_N_temp1      = f11
coshf_FR_N_temp2      = f12
coshf_FR_N            = f13

coshf_FR_spos         = f14
coshf_FR_sneg         = f15

coshf_FR_Tjhi         = f32
coshf_FR_Tjlo         = f33
coshf_FR_Tmjhi        = f34
coshf_FR_Tmjlo        = f35

GR_mJ           = r35
GR_J            = r36

AD_mJ           = r38
AD_J            = r39


GR_SAVE_B0                    = r42
GR_SAVE_PFS                   = r41
GR_SAVE_GP                    = r43 

GR_Parameter_X                = r44
GR_Parameter_Y                = r45
GR_Parameter_RESULT           = r46
GR_Parameter_TAG              = r47

FR_X             = f8
FR_Y             = f0
FR_RESULT        = f44


coshf_FR_C_hi         = f9
coshf_FR_C_hi_temp    = f10
coshf_FR_C_lo_temp1   = f11 
coshf_FR_C_lo_temp2   = f12 
coshf_FR_C_lo_temp3   = f13 

coshf_FR_C_lo         = f38
coshf_FR_S_hi         = f39

coshf_FR_S_hi_temp1   = f10
coshf_FR_Y_hi         = f11 
coshf_FR_Y_lo_temp    = f12 
coshf_FR_Y_lo         = f13 
coshf_FR_COSH         = f9

coshf_FR_X2           = f9
coshf_FR_X4           = f10

coshf_FR_P1           = f14
coshf_FR_P2           = f15
coshf_FR_P3           = f32
coshf_FR_P4           = f33
coshf_FR_P5           = f34
coshf_FR_P6           = f35

coshf_FR_TINY_THRESH  = f9

coshf_FR_COSH_temp    = f10
coshf_FR_SCALE        = f11 

coshf_FR_hi_lo = f10

coshf_FR_poly_podd_temp1    =  f11 
coshf_FR_poly_podd_temp2    =  f13
coshf_FR_poly_peven_temp1   =  f11
coshf_FR_poly_peven_temp2   =  f13

// Data tables
//==============================================================

.data

.align 16
single_coshf_arg_reduction:
   data8 0xB8AA3B295C17F0BC, 0x00004005
   data8 0xB17217F7D1000000, 0x00003FF8
   data8 0xCF79ABC9E3B39804, 0x00003FD0

single_coshf_p_table:
   data8 0x8000000000000000, 0x00003FFE
   data8 0xAAAAAAAAAAAAAB80, 0x00003FFA
   data8 0xB60B60B60B4FE884, 0x00003FF5
   data8 0xD00D00D1021D7370, 0x00003FEF
   data8 0x93F27740C0C2F1CC, 0x00003FE9
   data8 0x8FA02AC65BCBD5BC, 0x00003FE2

single_coshf_ab_table:
   data8 0xAAAAAAAAAAAAAAAC, 0x00003FFC
   data8 0x88888888884ECDD5, 0x00003FF8
   data8 0xD00D0C6DCC26A86B, 0x00003FF2
   data8 0x8000000000000002, 0x00003FFE
   data8 0xAAAAAAAAAA402C77, 0x00003FFA
   data8 0xB60B6CC96BDB144D, 0x00003FF5

single_coshf_j_table:
   data8 0xB504F333F9DE6484, 0x00003FFE, 0x1EB2FB13, 0x00000000
   data8 0xB6FD91E328D17791, 0x00003FFE, 0x1CE2CBE2, 0x00000000
   data8 0xB8FBAF4762FB9EE9, 0x00003FFE, 0x1DDC3CBC, 0x00000000
   data8 0xBAFF5AB2133E45FB, 0x00003FFE, 0x1EE9AA34, 0x00000000
   data8 0xBD08A39F580C36BF, 0x00003FFE, 0x9EAEFDC1, 0x00000000
   data8 0xBF1799B67A731083, 0x00003FFE, 0x9DBF517B, 0x00000000
   data8 0xC12C4CCA66709456, 0x00003FFE, 0x1EF88AFB, 0x00000000
   data8 0xC346CCDA24976407, 0x00003FFE, 0x1E03B216, 0x00000000
   data8 0xC5672A115506DADD, 0x00003FFE, 0x1E78AB43, 0x00000000
   data8 0xC78D74C8ABB9B15D, 0x00003FFE, 0x9E7B1747, 0x00000000
   data8 0xC9B9BD866E2F27A3, 0x00003FFE, 0x9EFE3C0E, 0x00000000
   data8 0xCBEC14FEF2727C5D, 0x00003FFE, 0x9D36F837, 0x00000000
   data8 0xCE248C151F8480E4, 0x00003FFE, 0x9DEE53E4, 0x00000000
   data8 0xD06333DAEF2B2595, 0x00003FFE, 0x9E24AE8E, 0x00000000
   data8 0xD2A81D91F12AE45A, 0x00003FFE, 0x1D912473, 0x00000000
   data8 0xD4F35AABCFEDFA1F, 0x00003FFE, 0x1EB243BE, 0x00000000
   data8 0xD744FCCAD69D6AF4, 0x00003FFE, 0x1E669A2F, 0x00000000
   data8 0xD99D15C278AFD7B6, 0x00003FFE, 0x9BBC610A, 0x00000000
   data8 0xDBFBB797DAF23755, 0x00003FFE, 0x1E761035, 0x00000000
   data8 0xDE60F4825E0E9124, 0x00003FFE, 0x9E0BE175, 0x00000000
   data8 0xE0CCDEEC2A94E111, 0x00003FFE, 0x1CCB12A1, 0x00000000
   data8 0xE33F8972BE8A5A51, 0x00003FFE, 0x1D1BFE90, 0x00000000
   data8 0xE5B906E77C8348A8, 0x00003FFE, 0x1DF2F47A, 0x00000000
   data8 0xE8396A503C4BDC68, 0x00003FFE, 0x1EF22F22, 0x00000000
   data8 0xEAC0C6E7DD24392F, 0x00003FFE, 0x9E3F4A29, 0x00000000
   data8 0xED4F301ED9942B84, 0x00003FFE, 0x1EC01A5B, 0x00000000
   data8 0xEFE4B99BDCDAF5CB, 0x00003FFE, 0x1E8CAC3A, 0x00000000
   data8 0xF281773C59FFB13A, 0x00003FFE, 0x9DBB3FAB, 0x00000000
   data8 0xF5257D152486CC2C, 0x00003FFE, 0x1EF73A19, 0x00000000
   data8 0xF7D0DF730AD13BB9, 0x00003FFE, 0x9BB795B5, 0x00000000
   data8 0xFA83B2DB722A033A, 0x00003FFE, 0x1EF84B76, 0x00000000
   data8 0xFD3E0C0CF486C175, 0x00003FFE, 0x9EF5818B, 0x00000000
   data8 0x8000000000000000, 0x00003FFF, 0x00000000, 0x00000000
   data8 0x8164D1F3BC030773, 0x00003FFF, 0x1F77CACA, 0x00000000
   data8 0x82CD8698AC2BA1D7, 0x00003FFF, 0x1EF8A91D, 0x00000000
   data8 0x843A28C3ACDE4046, 0x00003FFF, 0x1E57C976, 0x00000000
   data8 0x85AAC367CC487B15, 0x00003FFF, 0x9EE8DA92, 0x00000000
   data8 0x871F61969E8D1010, 0x00003FFF, 0x1EE85C9F, 0x00000000
   data8 0x88980E8092DA8527, 0x00003FFF, 0x1F3BF1AF, 0x00000000
   data8 0x8A14D575496EFD9A, 0x00003FFF, 0x1D80CA1E, 0x00000000
   data8 0x8B95C1E3EA8BD6E7, 0x00003FFF, 0x9D0373AF, 0x00000000
   data8 0x8D1ADF5B7E5BA9E6, 0x00003FFF, 0x9F167097, 0x00000000
   data8 0x8EA4398B45CD53C0, 0x00003FFF, 0x1EB70051, 0x00000000
   data8 0x9031DC431466B1DC, 0x00003FFF, 0x1F6EB029, 0x00000000
   data8 0x91C3D373AB11C336, 0x00003FFF, 0x1DFD6D8E, 0x00000000
   data8 0x935A2B2F13E6E92C, 0x00003FFF, 0x9EB319B0, 0x00000000
   data8 0x94F4EFA8FEF70961, 0x00003FFF, 0x1EBA2BEB, 0x00000000
   data8 0x96942D3720185A00, 0x00003FFF, 0x1F11D537, 0x00000000
   data8 0x9837F0518DB8A96F, 0x00003FFF, 0x1F0D5A46, 0x00000000
   data8 0x99E0459320B7FA65, 0x00003FFF, 0x9E5E7BCA, 0x00000000
   data8 0x9B8D39B9D54E5539, 0x00003FFF, 0x9F3AAFD1, 0x00000000
   data8 0x9D3ED9A72CFFB751, 0x00003FFF, 0x9E86DACC, 0x00000000
   data8 0x9EF5326091A111AE, 0x00003FFF, 0x9F3EDDC2, 0x00000000
   data8 0xA0B0510FB9714FC2, 0x00003FFF, 0x1E496E3D, 0x00000000
   data8 0xA27043030C496819, 0x00003FFF, 0x9F490BF6, 0x00000000
   data8 0xA43515AE09E6809E, 0x00003FFF, 0x1DD1DB48, 0x00000000
   data8 0xA5FED6A9B15138EA, 0x00003FFF, 0x1E65EBFB, 0x00000000
   data8 0xA7CD93B4E965356A, 0x00003FFF, 0x9F427496, 0x00000000
   data8 0xA9A15AB4EA7C0EF8, 0x00003FFF, 0x1F283C4A, 0x00000000
   data8 0xAB7A39B5A93ED337, 0x00003FFF, 0x1F4B0047, 0x00000000
   data8 0xAD583EEA42A14AC6, 0x00003FFF, 0x1F130152, 0x00000000
   data8 0xAF3B78AD690A4375, 0x00003FFF, 0x9E8367C0, 0x00000000
   data8 0xB123F581D2AC2590, 0x00003FFF, 0x9F705F90, 0x00000000
   data8 0xB311C412A9112489, 0x00003FFF, 0x1EFB3C53, 0x00000000
   data8 0xB504F333F9DE6484, 0x00003FFF, 0x1F32FB13, 0x00000000

.align 32
.global coshf#

.section .text
.proc  coshf#
.align 32

coshf: 

// X NAN?


{ .mfi
      alloc r32 = ar.pfs,0,12,4,0                  
(p0)  fclass.m.unc  p6,p7 = f8, 0xc3               
	  nop.i 999 ;;                           
}
{ .mfb
      nop.m 999
(p6)  fma.s.s0   f8 = f8,f1,f8                  
(p6)  br.ret.spnt b0 ;;                    
}

{ .mfi
       nop.m 999
       nop.f 999
       nop.i 999 ;;
}

// X infinity 
{ .mfi
       nop.m 999
(p0)  fclass.m.unc  p6,p0 = f8, 0x23               
       nop.i 999 ;;
}

{ .mfb
       nop.m 999
(p6)     fmerge.s      f8 = f0,f8                  
(p6)  br.ret.spnt    b0 ;;                  
}

// Put 0.25 in f9; p6 true if x < 0.25
{ .mlx
       nop.m 999
(p0)     movl            r32 = 0x000000000000fffd ;;         
}

{ .mfi
(p0)     setf.exp        f9 = r32                         
       nop.f 999
       nop.i 999 ;;
}

{ .mfi
       nop.m 999
(p0)  fmerge.s      coshf_FR_X    = f0,f8                
       nop.i 999
}

{ .mfi
       nop.m 999
(p0)  fmerge.s      coshf_FR_SGNX = f8,f1                
       nop.i 999 ;;
}

{ .mfi
       nop.m 999
(p0)     fcmp.lt.unc     p0,p7 = coshf_FR_X,f9                    
       nop.i 999 ;;
}

{ .mib
       nop.m 999
       nop.i 999
(p7)     br.cond.sptk    COSH_BY_TBL ;;                      
}


// COSH_BY_POLY: 

// POLY cannot overflow so there is no need to call __libm_error_support
// Get the values of P_x from the table

{ .mmi
      nop.m 999
(p0)  addl           r34   = @ltoff(single_coshf_p_table), gp
      nop.i 999
}
;;

{ .mmi
      ld8 r34 = [r34]
      nop.m 999
      nop.i 999
}
;;

// Calculate coshf_FR_X2 = ax*ax and coshf_FR_X4 = ax*ax*ax*ax
{ .mmf
       nop.m 999
(p0)     ldfe       coshf_FR_P1 = [r34],16                 
(p0)     fma.s1     coshf_FR_X2 = coshf_FR_X, coshf_FR_X, f0 ;;           
}

{ .mmi
(p0)     ldfe       coshf_FR_P2 = [r34],16 ;;                 
(p0)     ldfe       coshf_FR_P3 = [r34],16                 
       nop.i 999 ;;
}

{ .mmi
(p0)     ldfe       coshf_FR_P4 = [r34],16 ;;                 
(p0)     ldfe       coshf_FR_P5 = [r34],16                 
       nop.i 999 ;;
}

{ .mfi
(p0)     ldfe       coshf_FR_P6 = [r34],16                 
(p0)     fma.s1     coshf_FR_X4 = coshf_FR_X2, coshf_FR_X2, f0         
       nop.i 999 ;;
}

// Calculate coshf_FR_podd = x4 *(x4 * P_5 + P_3) + P_1
{ .mfi
       nop.m 999
(p0)     fma.s1     coshf_FR_poly_podd_temp1 = coshf_FR_X4, coshf_FR_P5, coshf_FR_P3                
       nop.i 999 ;;
}

{ .mfi
       nop.m 999
(p0)     fma.s1     coshf_FR_podd            = coshf_FR_X4, coshf_FR_poly_podd_temp1, coshf_FR_P1   
       nop.i 999
}

// Calculate coshf_FR_peven =  p_even = x4 *(x4 * (x4 * P_6 + P_4) + P_2)
{ .mfi
       nop.m 999
(p0)     fma.s1     coshf_FR_poly_peven_temp1 = coshf_FR_X4, coshf_FR_P6, coshf_FR_P4               
       nop.i 999 ;;
}

{ .mfi
       nop.m 999
(p0)     fma.s1     coshf_FR_poly_peven_temp2 = coshf_FR_X4, coshf_FR_poly_peven_temp1, coshf_FR_P2 
       nop.i 999 ;;
}

{ .mfi
       nop.m 999
(p0)     fma.s1     coshf_FR_peven       = coshf_FR_X4, coshf_FR_poly_peven_temp2, f0         
       nop.i 999 ;;
}

// Y_lo = x2*p_odd + p_even
// Calculate f8 = Y_hi + Y_lo 

{ .mfi
       nop.m 999
(p0)     fma.s1     coshf_FR_Y_lo         = coshf_FR_X2, coshf_FR_podd,  coshf_FR_peven    
       nop.i 999 ;;
}

{ .mfb
       nop.m 999
(p0)     fma.s.s0   f8                   = f1, f1, coshf_FR_Y_lo                        
(p0)     br.ret.sptk    b0 ;;                                                        
}


COSH_BY_TBL: 

// Now that we are at TBL; so far all we know is that |x| >= 0.25.
// The first two steps are the same for TBL and EXP, but if we are HUGE
// Double
// Go to HUGE if |x| >= 2^10, 10009 (register-biased) is e = 10 (true)
// Single
// Go to HUGE if |x| >= 2^7,  10006 (register-biased) is e =  7 (true)
// we want to leave now. Go to HUGE if |x| >= 2^14
// 1000d (register-biased) is e = 14 (true)

{ .mlx
       nop.m 999
(p0)     movl            r32 = 0x0000000000010006 ;;              
}

{ .mfi
(p0)     setf.exp        f9 = r32                              
       nop.f 999
       nop.i 999 ;;
}

{ .mfi
       nop.m 999
(p0)     fcmp.ge.unc     p6,p7 = coshf_FR_X,f9                  
       nop.i 999 ;;
}

{ .mib
       nop.m 999
       nop.i 999
(p6)     br.cond.spnt    COSH_HUGE ;;                             
}

// r32 = 1
// r34 = N-1 
// r35 = N
// r36 = j
// r37 = N+1

// TBL can never overflow
// coshf(x) = coshf(B+R)
//         = coshf(B) coshf(R) + sinh(B) sinh(R) 
// coshf(R) can be approximated by 1 + p_even
// sinh(R) can be approximated by p_odd

// ******************************************************
// STEP 1 (TBL and EXP)
// ******************************************************
// Get the following constants.
// f9  = Inv_log2by64
// f10 = log2by64_hi
// f11 = log2by64_lo

{ .mmi
(p0)     adds                 r32 = 0x1,r0      
(p0)     addl           r34   = @ltoff(single_coshf_arg_reduction), gp
         nop.i 999
}
;;


// We want 2^(N-1) and 2^(-N-1). So bias N-1 and -N-1 and
// put them in an exponent.
// coshf_FR_spos = 2^(N-1) and coshf_FR_sneg = 2^(-N-1)
// r39 = 0xffff + (N-1)  = 0xffff +N -1
// r40 = 0xffff - (N +1) = 0xffff -N -1

{ .mlx
         ld8 r34 = [r34]
(p0)     movl                r38 = 0x000000000000fffe ;; 
}

{ .mmi
(p0)     ldfe            coshf_FR_Inv_log2by64 = [r34],16 ;;            
(p0)     ldfe            coshf_FR_log2by64_hi  = [r34],16            
       nop.i 999 ;;
}

{ .mbb
(p0)     ldfe            coshf_FR_log2by64_lo  = [r34],16            
       nop.b 999
       nop.b 999 ;;
}

// Get the A coefficients
// f9  = A_1
// f10 = A_2
// f11 = A_3

{ .mmi
      nop.m 999
(p0)  addl           r34   = @ltoff(single_coshf_ab_table), gp
      nop.i 999
}
;;

{ .mmi
      ld8 r34 = [r34]
      nop.m 999
      nop.i 999
}
;;


// Calculate M and keep it as integer and floating point.
// M = round-to-integer(x*Inv_log2by64)
// coshf_FR_M = M = truncate(ax/(log2/64))
// Put the significand of M in r35
//    and the floating point representation of M in coshf_FR_M

{ .mfi
       nop.m 999
(p0)     fma.s1          coshf_FR_M      = coshf_FR_X, coshf_FR_Inv_log2by64, f0 
       nop.i 999
}

{ .mfi
(p0)     ldfe            coshf_FR_A1 = [r34],16            
       nop.f 999
       nop.i 999 ;;
}

{ .mfi
       nop.m 999
(p0)     fcvt.fx.s1      coshf_FR_M_temp = coshf_FR_M                      
       nop.i 999 ;;
}

{ .mfi
       nop.m 999
(p0)     fnorm.s1        coshf_FR_M      = coshf_FR_M_temp                 
       nop.i 999 ;;
}

{ .mfi
(p0)     getf.sig        r35       = coshf_FR_M_temp                 
       nop.f 999
       nop.i 999 ;;
}

// M is still in r35. Calculate j. j is the signed extension of the six lsb of M. It
// has a range of -32 thru 31.
// r35 = M
// r36 = j 

{ .mii
       nop.m 999
       nop.i 999 ;;
(p0)     and            r36 = 0x3f, r35 ;;   
}

// Calculate R
// f13 = f44 - f12*f10 = x - M*log2by64_hi
// f14 = f13 - f8*f11 = R = (x - M*log2by64_hi) - M*log2by64_lo

{ .mfi
       nop.m 999
(p0)     fnma.s1        coshf_FR_R_temp = coshf_FR_M, coshf_FR_log2by64_hi, coshf_FR_X      
       nop.i 999
}

{ .mfi
(p0)     ldfe            coshf_FR_A2 = [r34],16            
       nop.f 999
       nop.i 999 ;;
}

{ .mfi
       nop.m 999
(p0)     fnma.s1        coshf_FR_R      = coshf_FR_M, coshf_FR_log2by64_lo, coshf_FR_R_temp 
       nop.i 999
}

// Get the B coefficients
// f15 = B_1
// f32 = B_2
// f33 = B_3

{ .mmi
(p0)     ldfe            coshf_FR_A3 = [r34],16 ;;            
(p0)     ldfe            coshf_FR_B1 = [r34],16            
       nop.i 999 ;;
}

{ .mmi
(p0)     ldfe            coshf_FR_B2 = [r34],16 ;;            
(p0)     ldfe            coshf_FR_B3 = [r34],16            
       nop.i 999 ;;
}

{ .mii
       nop.m 999
(p0)     shl            r34 = r36,  0x2 ;;   
(p0)     sxt1           r37 = r34 ;;         
}

// ******************************************************
// STEP 2 (TBL and EXP)
// ******************************************************
// Calculate Rsquared and Rcubed in preparation for p_even and p_odd
// f12 = R*R*R
// f13 = R*R
// f14 = R <== from above

{ .mfi
       nop.m 999
(p0)     fma.s1          coshf_FR_Rsq  = coshf_FR_R,   coshf_FR_R, f0  
(p0)     shr            r36 = r37,  0x2 ;;   
}

// r34 = M-j = r35 - r36
// r35 = N = (M-j)/64

{ .mii
(p0)     sub                  r34 = r35, r36    
       nop.i 999 ;;
(p0)     shr                  r35 = r34, 0x6 ;;    
}

{ .mii
(p0)     sub                 r40 = r38, r35           
(p0)     adds                 r37 = 0x1, r35    
(p0)     add                 r39 = r38, r35 ;;           
}

// Get the address of the J table, add the offset,
// addresses are sinh_AD_mJ and sinh_AD_J, get the T value
// f32 = T(j)_hi
// f33 = T(j)_lo
// f34 = T(-j)_hi
// f35 = T(-j)_lo

{ .mmi
(p0)     sub                  r34 = r35, r32    
(p0)     addl    r37   = @ltoff(single_coshf_j_table), gp
         nop.i 999
}
;;

{ .mfi
      ld8 r37 = [r37]
(p0)     fma.s1          coshf_FR_Rcub = coshf_FR_Rsq, coshf_FR_R, f0  
       nop.i 999
}

// ******************************************************
// STEP 3 Now decide if we need to branch to EXP
// ******************************************************
// Put 32 in f9; p6 true if x < 32

{ .mlx
       nop.m 999
(p0)     movl                r32 = 0x0000000000010004 ;;               
}

// Calculate p_even
// f34 = B_2 + Rsq *B_3
// f35 = B_1 + Rsq*f34      = B_1 + Rsq * (B_2 + Rsq *B_3)
// f36 = peven = Rsq * f35 = Rsq * (B_1 + Rsq * (B_2 + Rsq *B_3))

{ .mfi
       nop.m 999
(p0)     fma.s1          coshf_FR_peven_temp1 = coshf_FR_Rsq, coshf_FR_B3,          coshf_FR_B2  
       nop.i 999 ;;
}

{ .mfi
       nop.m 999
(p0)     fma.s1          coshf_FR_peven_temp2 = coshf_FR_Rsq, coshf_FR_peven_temp1, coshf_FR_B1  
       nop.i 999
}

// Calculate p_odd
// f34 = A_2 + Rsq *A_3
// f35 = A_1 + Rsq * (A_2 + Rsq *A_3)
// f37 = podd = R + Rcub * (A_1 + Rsq * (A_2 + Rsq *A_3))

{ .mfi
       nop.m 999
(p0)     fma.s1          coshf_FR_podd_temp1 = coshf_FR_Rsq,        coshf_FR_A3,         coshf_FR_A2  
       nop.i 999 ;;
}

{ .mfi
(p0)     setf.exp            coshf_FR_N_temp1 = r39            
       nop.f 999
       nop.i 999 ;;
}

{ .mfi
       nop.m 999
(p0)     fma.s1          coshf_FR_peven       = coshf_FR_Rsq, coshf_FR_peven_temp2, f0     
       nop.i 999
}

{ .mfi
       nop.m 999
(p0)     fma.s1          coshf_FR_podd_temp2 = coshf_FR_Rsq,        coshf_FR_podd_temp1, coshf_FR_A1  
       nop.i 999 ;;
}

{ .mfi
(p0)     setf.exp            f9  = r32                              
       nop.f 999
       nop.i 999 ;;
}

{ .mfi
       nop.m 999
(p0)     fma.s1          coshf_FR_podd       = coshf_FR_podd_temp2, coshf_FR_Rcub,       coshf_FR_R   
       nop.i 999
}

// sinh_GR_mj contains the table offset for -j
// sinh_GR_j  contains the table offset for +j
// p6 is true when j <= 0

{ .mlx
(p0)     setf.exp            coshf_FR_N_temp2 = r40            
(p0)     movl                r40 = 0x0000000000000020 ;;    
}

{ .mfi
(p0)     sub                 GR_mJ = r40,  r36           
(p0)     fmerge.se           coshf_FR_spos    = coshf_FR_N_temp1, f1 
(p0)     adds                GR_J  = 0x20, r36 ;;           
}

{ .mii
       nop.m 999
(p0)     shl                  GR_mJ = GR_mJ, 5 ;;   
(p0)     add                  AD_mJ = r37, GR_mJ ;; 
}

{ .mmi
       nop.m 999
(p0)     ldfe                 coshf_FR_Tmjhi = [AD_mJ],16                 
(p0)     shl                  GR_J  = GR_J, 5 ;;    
}

{ .mfi
(p0)     ldfs                 coshf_FR_Tmjlo = [AD_mJ],16                 
(p0)     fcmp.lt.unc.s1      p6,p7 = coshf_FR_X,f9                          
(p0)     add                  AD_J  = r37, GR_J ;;  
}

{ .mmi
(p0)     ldfe                 coshf_FR_Tjhi  = [AD_J],16 ;;                  
(p0)     ldfs                 coshf_FR_Tjlo  = [AD_J],16                  
       nop.i 999 ;;
}

{ .mfb
       nop.m 999
(p0)     fmerge.se           coshf_FR_sneg    = coshf_FR_N_temp2, f1 
(p7)     br.cond.spnt        COSH_BY_EXP ;;                            
}

// ******************************************************
// If NOT branch to EXP
// ******************************************************
// Calculate C_hi
// ******************************************************
// coshf_FR_C_hi_temp = coshf_FR_sneg * coshf_FR_Tmjhi
// coshf_FR_C_hi = coshf_FR_spos * coshf_FR_Tjhi + (coshf_FR_sneg * coshf_FR_Tmjhi)

{ .mfi
       nop.m 999
(p0)    fma.s1         coshf_FR_C_hi_temp = coshf_FR_sneg, coshf_FR_Tmjhi, f0                   
       nop.i 999 ;;
}

{ .mfi
       nop.m 999
(p0)    fma.s1         coshf_FR_C_hi      = coshf_FR_spos, coshf_FR_Tjhi,  coshf_FR_C_hi_temp    
       nop.i 999
}

// ******************************************************
// Calculate S_hi
// ******************************************************
// coshf_FR_S_hi_temp1 = coshf_FR_sneg * coshf_FR_Tmjhi
// coshf_FR_S_hi = coshf_FR_spos * coshf_FR_Tjhi - coshf_FR_C_hi_temp1

{ .mfi
       nop.m 999
(p0)     fma.s1        coshf_FR_S_hi_temp1 =  coshf_FR_sneg, coshf_FR_Tmjhi, f0                
       nop.i 999 ;;
}

// ******************************************************
// Calculate C_lo
// ******************************************************
// coshf_FR_C_lo_temp1 = coshf_FR_spos * coshf_FR_Tjhi - coshf_FR_C_hi
// coshf_FR_C_lo_temp2 = coshf_FR_sneg * coshf_FR_Tmjlo + (coshf_FR_spos * coshf_FR_Tjhi - coshf_FR_C_hi)
// coshf_FR_C_lo_temp1 = coshf_FR_sneg * coshf_FR_Tmjlo
// coshf_FR_C_lo_temp3 = coshf_FR_spos * coshf_FR_Tjlo + (coshf_FR_sneg * coshf_FR_Tmjlo)
// coshf_FR_C_lo = coshf_FR_C_lo_temp3 + coshf_FR_C_lo_temp2

{ .mfi
       nop.m 999
(p0)     fms.s1        coshf_FR_C_lo_temp1 = coshf_FR_spos, coshf_FR_Tjhi,  coshf_FR_C_hi        
       nop.i 999
}

{ .mfi
       nop.m 999
(p0)     fms.s1        coshf_FR_S_hi       =  coshf_FR_spos, coshf_FR_Tjhi, coshf_FR_S_hi_temp1 
       nop.i 999 ;;
}

{ .mfi
       nop.m 999
(p0)     fma.s1        coshf_FR_C_lo_temp2 = coshf_FR_sneg, coshf_FR_Tmjhi, coshf_FR_C_lo_temp1  
       nop.i 999
}

{ .mfi
       nop.m 999
(p0)     fma.s1        coshf_FR_C_lo_temp1 = coshf_FR_sneg, coshf_FR_Tmjlo, f0                  
       nop.i 999 ;;
}

{ .mfi
       nop.m 999
(p0)     fma.s1        coshf_FR_C_lo_temp3 =  coshf_FR_spos, coshf_FR_Tjlo,  coshf_FR_C_lo_temp1 
       nop.i 999 ;;
}

{ .mfi
       nop.m 999
(p0)     fma.s1        coshf_FR_C_lo       =  coshf_FR_C_lo_temp3, f1,   coshf_FR_C_lo_temp2    
       nop.i 999 ;;
}

// ******************************************************
// coshf_FR_Y_lo_temp = coshf_FR_C_hi * coshf_FR_peven + coshf_FR_C_lo
// coshf_FR_Y_lo = coshf_FR_S_hi * coshf_FR_podd + coshf_FR_Y_lo_temp
// coshf_FR_COSH = Y_hi + Y_lo

{ .mfi
       nop.m 999
(p0)    fma.s1         coshf_FR_Y_lo_temp =  coshf_FR_C_hi, coshf_FR_peven, coshf_FR_C_lo       
       nop.i 999 ;;
}

{ .mfi
       nop.m 999
(p0)    fma.s1         coshf_FR_Y_lo      =  coshf_FR_S_hi, coshf_FR_podd, coshf_FR_Y_lo_temp   
       nop.i 999 ;;
}

{ .mfb
       nop.m 999
(p0)    fma.s.s0       f8 =  coshf_FR_C_hi, f1, coshf_FR_Y_lo                       
(p0)    br.ret.sptk        b0 ;;                                           
}


COSH_BY_EXP: 

// When p7 is true,  we know that an overflow is not going to happen
// When p7 is false, we must check for possible overflow
// p7 is the over_SAFE flag
// f44 = Scale * (Y_hi + Y_lo)
//     =  coshf_FR_spos * (coshf_FR_Tjhi + coshf_FR_Y_lo)

{ .mfi
       nop.m 999
(p0)    fma.s1         coshf_FR_Y_lo_temp =  coshf_FR_peven, f1,       coshf_FR_podd           
       nop.i 999
}

// Now we are in EXP. This is the only path where an overflow is possible
// but not for certain. So this is the only path where over_SAFE has any use.
// r34 still has N-1
// There is a danger of double-extended overflow   if N-1 > 16382 = 0x3ffe
// There is a danger of double overflow            if N-1 > 0x3fe = 1022
// There is a danger of single overflow            if N-1 > 0x7e = 126

{ .mlx
       nop.m 999
(p0)   movl                r32          = 0x000000000000007e ;;                       
}

{ .mfi
(p0)   cmp.gt.unc          p0,p7        = r34, r32                                 
       nop.f 999
       nop.i 999 ;;
}

{ .mfi
       nop.m 999
(p0)    fma.s1         coshf_FR_Y_lo      =  coshf_FR_Tjhi,  coshf_FR_Y_lo_temp, coshf_FR_Tjlo       
       nop.i 999 ;;
}

{ .mfi
       nop.m 999
(p0)    fma.s1         coshf_FR_COSH_temp =  coshf_FR_Y_lo,  f1, coshf_FR_Tjhi                 
       nop.i 999 ;;
}

{ .mfi
       nop.m 999
(p0)    fma.s.s0       f44 = coshf_FR_spos,  coshf_FR_COSH_temp, f0                       
       nop.i 999 ;;
}

// If over_SAFE is set, return
{ .mfb
       nop.m 999
(p7)   fmerge.s            f8 = f44,f44
(p7)   br.ret.sptk        b0 ;;
}

// Else see if we overflowed
// S0 user supplied status
// S2 user supplied status + WRE + TD  (Overflows)
// If WRE is set then an overflow will not occur in EXP.
// The input value that would cause a register (WRE) value to overflow is about 2^15
// and this input would go into the HUGE path.
// Answer with WRE is in f43.

{ .mfi
       nop.m 999
(p0)   fsetc.s2            0x7F,0x42                                               
       nop.i 999;;
}

{ .mfi
       nop.m 999
(p0)   fma.s.s2            f43  = coshf_FR_spos,  coshf_FR_COSH_temp, f0                      
       nop.i 999 ;;
}

// 1 more that the exponent of the largest double (7FE)  = 7FF
// 7FF - 3FF = 400 (true); 400 + FFFF = 103FF (register-biased)
// So 0 103FF 8000000000000000  is one ulp more than
// largest double in register bias
// 1 more that the exponent of the largest single (FE)  = FF
// FF - 7F = 80 (true); 80 + FFFF = 1007F (register-biased)
// Now  set p8 if the answer with WRE is greater than or equal this value
// Also set p9 if the answer with WRE is less than or equal to negative this value

{ .mlx
       nop.m 999
(p0)   movl                r32          = 0x000000000001007f ;;                     
}

{ .mmf
       nop.m 999
(p0)   setf.exp            f41          = r32                                    
(p0)   fsetc.s2            0x7F,0x40 ;;                                               
}

{ .mfi
       nop.m 999
(p0)   fcmp.ge.unc.s1      p8, p0       = f43, f41                               
       nop.i 999
}

{ .mfi
       nop.m 999
(p0)   fmerge.ns           f42 = f41, f41                                        
       nop.i 999 ;;
}

// The error tag for overflow is 65
{ .mii
       nop.m 999
       nop.i 999 ;;
(p8)   mov                 GR_Parameter_TAG = 65 ;;                                              
}

{ .mfb
       nop.m 999
(p0)   fcmp.le.unc.s1      p9, p0 =  f43, f42                                    
(p8)   br.cond.spnt __libm_error_region ;;
}

{ .mii
       nop.m 999
       nop.i 999 ;;
(p9)   mov                 GR_Parameter_TAG = 64                                              
}

{ .mib
       nop.m 999
       nop.i 999
(p9)   br.cond.spnt __libm_error_region ;;
}

{ .mfb
       nop.m 999
(p0)   fmerge.s            f8 = f44,f44                                          
(p0)   br.ret.sptk b0 ;; 
}


COSH_HUGE: 

// for COSH_HUGE, put 24000 in exponent; take sign from input; add 1
// SAFE: SAFE is always 0 for HUGE

{ .mlx
       nop.m 999
(p0)   movl                r32 = 0x0000000000015dbf ;;                               
}

{ .mfi
(p0)   setf.exp            f9  = r32                                              
       nop.f 999
       nop.i 999 ;;
}

{ .mfi
       nop.m 999
(p0)   fma.s1              coshf_FR_hi_lo = f1, f9, f1                            
       nop.i 999 ;;
}

{ .mfi
       nop.m 999
(p0)   fma.s.s0            f44 = f9, coshf_FR_hi_lo, f0                           
(p0)   mov                 GR_Parameter_TAG = 65                                               
}
.endp coshf


.proc __libm_error_region
__libm_error_region:
.prologue
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs 
}
{ .mfi
.fframe 64 
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfs [GR_Parameter_Y] = FR_Y,16         // Save Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0                      
        mov GR_SAVE_B0=b0                       // Save b0 
};;
.body
{ .mib
        stfs [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack 
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y  
	nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfs [GR_Parameter_Y] = FR_RESULT      // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y  
        br.call.sptk.many b0=__libm_error_support#  // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;
{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp 
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};; 

.endp __libm_error_region

.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\exp.s ===
.file "exp.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version 
// 3/07/00  exp(inf)  = inf but now does NOT call error support
//          exp(-inf) = 0   but now does NOT call error support
// 4/04/00  Unwind support added
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 11/30/00 Reworked to shorten main path, widen main path to include all
//          args in normal range, and add quick exit for 0, nan, inf.
// 12/05/00 Loaded constants earlier with setf to save 2 cycles.

// API
//==============================================================
// double exp(double)

// Overview of operation
//==============================================================
// Take the input x. w is "how many log2/128 in x?"
//  w = x * 128/log2
//  n = int(w)
//  x = n log2/128 + r + delta

//  n = 128M + index_1 + 2^4 index_2
//  x = M log2 + (log2/128) index_1 + (log2/8) index_2 + r + delta

//  exp(x) = 2^M  2^(index_1/128)  2^(index_2/8) exp(r) exp(delta)
//       Construct 2^M
//       Get 2^(index_1/128) from table_1;
//       Get 2^(index_2/8)   from table_2;
//       Calculate exp(r) by series
//          r = x - n (log2/128)_high
//          delta = - n (log2/128)_low
//       Calculate exp(delta) as 1 + delta


// Special values 
//==============================================================
// exp(+0)    = 1.0
// exp(-0)    = 1.0

// exp(+qnan) = +qnan 
// exp(-qnan) = -qnan 
// exp(+snan) = +qnan 
// exp(-snan) = -qnan 

// exp(-inf)  = +0 
// exp(+inf)  = +inf

// Overfow and Underfow
//=======================
// exp(-x) = smallest double normal when
//     x = -708.396 = c086232bdd7abcd2

// exp(x) = largest double normal when
//     x = 709.7827 = 40862e42fefa39ef



// Registers used
//==============================================================
// Floating Point registers used: 
// f8, input
// f9 -> f15,  f32 -> f60

// General registers used: 
// r32 -> r60 

// Predicate registers used:
// p6 -> p15

// Assembly macros
//==============================================================

exp_GR_rshf                   = r33
EXP_AD_TB1                    = r34
EXP_AD_TB2                    = r35
EXP_AD_P                      = r36

exp_GR_N                      = r37
exp_GR_index_1                = r38
exp_GR_index_2_16             = r39

exp_GR_biased_M               = r40
exp_GR_index_1_16             = r41
EXP_AD_T1                     = r42
EXP_AD_T2                     = r43
exp_GR_sig_inv_ln2            = r44

exp_GR_17ones                 = r45
exp_GR_one                    = r46
exp_TB1_size                  = r47
exp_TB2_size                  = r48
exp_GR_rshf_2to56             = r49

exp_GR_gt_ln                  = r50
exp_GR_exp_2tom56             = r51

exp_GR_17ones_m1              = r52

GR_SAVE_B0                    = r53
GR_SAVE_PFS                   = r54
GR_SAVE_GP                    = r55
GR_SAVE_SP                    = r56

GR_Parameter_X                = r57
GR_Parameter_Y                = r58
GR_Parameter_RESULT           = r59
GR_Parameter_TAG              = r60


FR_X             = f10
FR_Y             = f1
FR_RESULT        = f8

EXP_RSHF_2TO56   = f6
EXP_INV_LN2_2TO63 = f7
EXP_W_2TO56_RSH  = f9
EXP_2TOM56       = f11
exp_P4           = f12 
exp_P3           = f13 
exp_P2           = f14 
exp_P1           = f15 

exp_ln2_by_128_hi  = f33 
exp_ln2_by_128_lo  = f34 

EXP_RSHF           = f35
EXP_Nfloat         = f36 
exp_W              = f37
exp_r              = f38
exp_f              = f39

exp_rsq            = f40
exp_rcube          = f41

EXP_2M             = f42
exp_S1             = f43
exp_T1             = f44

EXP_MIN_DBL_OFLOW_ARG = f45
EXP_MAX_DBL_ZERO_ARG  = f46
EXP_MAX_DBL_NORM_ARG  = f47
EXP_MAX_DBL_UFLOW_ARG = f48
EXP_MIN_DBL_NORM_ARG  = f49
exp_rP4pP3         = f50
exp_P_lo           = f51
exp_P_hi           = f52
exp_P              = f53
exp_S              = f54

EXP_NORM_f8        = f56   

exp_wre_urm_f8     = f57
exp_ftz_urm_f8     = f57

exp_gt_pln         = f58

exp_S2             = f59
exp_T2             = f60


// Data tables
//==============================================================

.data

.align 16

// ************* DO NOT CHANGE ORDER OF THESE TABLES ********************

// double-extended 1/ln(2)
// 3fff b8aa 3b29 5c17 f0bb be87fed0691d3e88
// 3fff b8aa 3b29 5c17 f0bc 
// For speed the significand will be loaded directly with a movl and setf.sig
//   and the exponent will be bias+63 instead of bias+0.  Thus subsequent
//   computations need to scale appropriately.
// The constant 128/ln(2) is needed for the computation of w.  This is also 
//   obtained by scaling the computations.
//
// Two shifting constants are loaded directly with movl and setf.d. 
//   1. EXP_RSHF_2TO56 = 1.1000..00 * 2^(63-7) 
//        This constant is added to x*1/ln2 to shift the integer part of
//        x*128/ln2 into the rightmost bits of the significand.
//        The result of this fma is EXP_W_2TO56_RSH.
//   2. EXP_RSHF       = 1.1000..00 * 2^(63) 
//        This constant is subtracted from EXP_W_2TO56_RSH * 2^(-56) to give
//        the integer part of w, n, as a floating-point number.
//        The result of this fms is EXP_Nfloat.


exp_table_1:
data8 0x40862e42fefa39f0 // smallest dbl overflow arg
data8 0xc0874c0000000000 // approx largest arg for zero result
data8 0x40862e42fefa39ef // largest dbl arg to give normal dbl result
data8 0xc086232bdd7abcd3 // largest dbl underflow arg
data8 0xc086232bdd7abcd2 // smallest dbl arg to give normal dbl result
data8 0x0                // pad
data8 0xb17217f7d1cf79ab , 0x00003ff7 // ln2/128 hi
data8 0xc9e3b39803f2f6af , 0x00003fb7 // ln2/128 lo

// Table 1 is 2^(index_1/128) where
// index_1 goes from 0 to 15

data8 0x8000000000000000 , 0x00003FFF
data8 0x80B1ED4FD999AB6C , 0x00003FFF
data8 0x8164D1F3BC030773 , 0x00003FFF
data8 0x8218AF4373FC25EC , 0x00003FFF
data8 0x82CD8698AC2BA1D7 , 0x00003FFF
data8 0x8383594EEFB6EE37 , 0x00003FFF
data8 0x843A28C3ACDE4046 , 0x00003FFF
data8 0x84F1F656379C1A29 , 0x00003FFF
data8 0x85AAC367CC487B15 , 0x00003FFF
data8 0x8664915B923FBA04 , 0x00003FFF
data8 0x871F61969E8D1010 , 0x00003FFF
data8 0x87DB357FF698D792 , 0x00003FFF
data8 0x88980E8092DA8527 , 0x00003FFF
data8 0x8955EE03618E5FDD , 0x00003FFF
data8 0x8A14D575496EFD9A , 0x00003FFF
data8 0x8AD4C6452C728924 , 0x00003FFF

// Table 2 is 2^(index_1/8) where
// index_2 goes from 0 to 7
exp_table_2:
data8 0x8000000000000000 , 0x00003FFF
data8 0x8B95C1E3EA8BD6E7 , 0x00003FFF
data8 0x9837F0518DB8A96F , 0x00003FFF
data8 0xA5FED6A9B15138EA , 0x00003FFF
data8 0xB504F333F9DE6484 , 0x00003FFF
data8 0xC5672A115506DADD , 0x00003FFF
data8 0xD744FCCAD69D6AF4 , 0x00003FFF
data8 0xEAC0C6E7DD24392F , 0x00003FFF


exp_p_table:
data8 0x3f8111116da21757 //P_4
data8 0x3fa55555d787761c //P_3
data8 0x3fc5555555555414 //P_2
data8 0x3fdffffffffffd6a //P_1


.align 32
.global exp#

.section .text
.proc  exp#
.align 32
exp: 

{ .mlx
      alloc      r32=ar.pfs,1,24,4,0                               
      movl exp_GR_sig_inv_ln2 = 0xb8aa3b295c17f0bc  // significand of 1/ln2
}
{ .mlx
      addl       EXP_AD_TB1    = @ltoff(exp_table_1), gp
      movl exp_GR_rshf_2to56 = 0x4768000000000000 ;;  // 1.10000 2^(63+56)
}
;;

// We do this fnorm right at the beginning to take any enabled
// faults and to normalize any input unnormals so that SWA is not taken.
{ .mfi
      ld8        EXP_AD_TB1    = [EXP_AD_TB1]
      fclass.m   p8,p0 = f8,0x07  // Test for x=0
      mov        exp_GR_17ones = 0x1FFFF                          
}
{ .mfi
      mov        exp_TB1_size  = 0x100
      fnorm      EXP_NORM_f8   = f8                                          
      mov exp_GR_exp_2tom56 = 0xffff-56
}
;;

// Form two constants we need
//  1/ln2 * 2^63  to compute  w = x * 1/ln2 * 128 
//  1.1000..000 * 2^(63+63-7) to right shift int(w) into the significand

{ .mmf
      setf.sig  EXP_INV_LN2_2TO63 = exp_GR_sig_inv_ln2 // form 1/ln2 * 2^63
      setf.d  EXP_RSHF_2TO56 = exp_GR_rshf_2to56 // Form const 1.100 * 2^(63+56)
      fclass.m   p9,p0 = f8,0x22  // Test for x=-inf
}
;;

{ .mlx
      setf.exp EXP_2TOM56 = exp_GR_exp_2tom56 // form 2^-56 for scaling Nfloat
      movl exp_GR_rshf = 0x43e8000000000000   // 1.10000 2^63 for right shift
}
{ .mfb
      mov        exp_TB2_size  = 0x80
(p8)  fma.d      f8 = f1,f1,f0           // quick exit for x=0
(p8)  br.ret.spnt b0
;;
}

{ .mfi
      ldfpd      EXP_MIN_DBL_OFLOW_ARG, EXP_MAX_DBL_ZERO_ARG = [EXP_AD_TB1],16
      fclass.m   p10,p0 = f8,0x21  // Test for x=+inf
      nop.i 999
}
{ .mfb
      nop.m 999
(p9)  fma.d      f8 = f0,f0,f0           // quick exit for x=-inf
(p9)  br.ret.spnt b0
;;                    
}

{ .mmf
      ldfpd      EXP_MAX_DBL_NORM_ARG, EXP_MAX_DBL_UFLOW_ARG = [EXP_AD_TB1],16
      setf.d  EXP_RSHF = exp_GR_rshf // Form right shift const 1.100 * 2^63
      fclass.m   p11,p0 = f8,0xc3  // Test for x=nan
;;
}

{ .mfb
      ldfd      EXP_MIN_DBL_NORM_ARG = [EXP_AD_TB1],16
      nop.f 999
(p10) br.ret.spnt b0               // quick exit for x=+inf
;;
}

{ .mfi
      ldfe       exp_ln2_by_128_hi  = [EXP_AD_TB1],16
      nop.f 999
      nop.i 999
;;
}


{ .mfb
      ldfe       exp_ln2_by_128_lo  = [EXP_AD_TB1],16
(p11) fmerge.s   f8 = EXP_NORM_f8, EXP_NORM_f8
(p11) br.ret.spnt b0               // quick exit for x=nan
;;
}

// After that last load, EXP_AD_TB1 points to the beginning of table 1

// W = X * Inv_log2_by_128
// By adding 1.10...0*2^63 we shift and get round_int(W) in significand.
// We actually add 1.10...0*2^56 to X * Inv_log2 to do the same thing.

{ .mfi
      nop.m 999
      fma.s1  EXP_W_2TO56_RSH  = EXP_NORM_f8, EXP_INV_LN2_2TO63, EXP_RSHF_2TO56
      nop.i 999
;;
}


// Divide arguments into the following categories:
//  Certain Underflow/zero  p11 - -inf < x <= MAX_DBL_ZERO_ARG 
//  Certain Underflow       p12 - MAX_DBL_ZERO_ARG < x <= MAX_DBL_UFLOW_ARG 
//  Possible Underflow      p13 - MAX_DBL_UFLOW_ARG < x < MIN_DBL_NORM_ARG
//  Certain Safe                - MIN_DBL_NORM_ARG <= x <= MAX_DBL_NORM_ARG
//  Possible Overflow       p14 - MAX_DBL_NORM_ARG < x < MIN_DBL_OFLOW_ARG
//  Certain Overflow        p15 - MIN_DBL_OFLOW_ARG <= x < +inf
//
// If the input is really a double arg, then there will never be "Possible
// Underflow" or "Possible Overflow" arguments.
//

{ .mfi
      add        EXP_AD_TB2 = exp_TB1_size, EXP_AD_TB1
      fcmp.ge.s1  p15,p14 = EXP_NORM_f8,EXP_MIN_DBL_OFLOW_ARG
      nop.i 999
;;                        
}

{ .mfi
      add        EXP_AD_P = exp_TB2_size, EXP_AD_TB2
      fcmp.le.s1  p11,p12 = EXP_NORM_f8,EXP_MAX_DBL_ZERO_ARG
      nop.i 999
;;
}

{ .mfb
      ldfpd      exp_P4, exp_P3  = [EXP_AD_P] ,16
(p14) fcmp.gt.unc.s1  p14,p0 = EXP_NORM_f8,EXP_MAX_DBL_NORM_ARG
(p15) br.cond.spnt EXP_CERTAIN_OVERFLOW
;;
}


// Nfloat = round_int(W) 
// The signficand of EXP_W_2TO56_RSH contains the rounded integer part of W,
// as a twos complement number in the lower bits (that is, it may be negative).
// That twos complement number (called N) is put into exp_GR_N.

// Since EXP_W_2TO56_RSH is scaled by 2^56, it must be multiplied by 2^-56
// before the shift constant 1.10000 * 2^63 is subtracted to yield EXP_Nfloat.
// Thus, EXP_Nfloat contains the floating point version of N


{ .mfi
      nop.m 999
(p12) fcmp.le.unc  p12,p0 = EXP_NORM_f8,EXP_MAX_DBL_UFLOW_ARG
      nop.i 999
}
{ .mfb
      ldfpd      exp_P2, exp_P1  = [EXP_AD_P]                                  
      fms.s1          EXP_Nfloat = EXP_W_2TO56_RSH, EXP_2TOM56, EXP_RSHF 
(p11) br.cond.spnt EXP_CERTAIN_UNDERFLOW_ZERO
;;
}

{ .mfi
      getf.sig        exp_GR_N        = EXP_W_2TO56_RSH
(p13) fcmp.lt.unc  p13,p0 = EXP_NORM_f8,EXP_MIN_DBL_NORM_ARG
      nop.i 999
;;
}


// exp_GR_index_1 has index_1
// exp_GR_index_2_16 has index_2 * 16
// exp_GR_biased_M has M
// exp_GR_index_1_16 has index_1 * 16

// r2 has true M
{ .mfi
      and            exp_GR_index_1 = 0x0f, exp_GR_N
      fnma.s1    exp_r   = EXP_Nfloat, exp_ln2_by_128_hi, EXP_NORM_f8 
      shr            r2 = exp_GR_N,  0x7
}
{ .mfi
      and            exp_GR_index_2_16 = 0x70, exp_GR_N
      fnma.s1    exp_f   = EXP_Nfloat, exp_ln2_by_128_lo, f1 
      nop.i 999
;;                            
}


// EXP_AD_T1 has address of T1                           
// EXP_AD_T2 has address if T2                            

{ .mmi
      addl           exp_GR_biased_M = 0xffff, r2 
      add            EXP_AD_T2 = EXP_AD_TB2, exp_GR_index_2_16 
      shladd         EXP_AD_T1 = exp_GR_index_1, 4, EXP_AD_TB1
;;                            
}


// Create Scale = 2^M
// r = x - Nfloat * ln2_by_128_hi 
// f = 1 - Nfloat * ln2_by_128_lo 

{ .mmi
      setf.exp        EXP_2M = exp_GR_biased_M                              
      ldfe       exp_T2  = [EXP_AD_T2]                                
      nop.i 999
;;
}

// Load T1 and T2
{ .mfi
      ldfe       exp_T1  = [EXP_AD_T1]                                
      nop.f 999
      nop.i 999
;;
}


{ .mfi
        nop.m 999
        fma.s1           exp_rsq = exp_r, exp_r, f0 
        nop.i 999
}
{ .mfi
        nop.m 999
        fma.s1        exp_rP4pP3 = exp_r, exp_P4, exp_P3               
        nop.i 999
;;
}



{ .mfi
        nop.m 999
        fma.s1           exp_rcube = exp_r, exp_rsq, f0 
        nop.i 999 
}
{ .mfi
        nop.m 999
        fma.s1        exp_P_lo  = exp_r, exp_rP4pP3, exp_P2            
        nop.i 999
;;
}


{ .mfi
        nop.m 999
        fma.s1        exp_P_hi  = exp_rsq, exp_P1, exp_r              
        nop.i 999
}
{ .mfi
        nop.m 999
        fma.s1        exp_S2  = exp_f,exp_T2,f0                       
        nop.i 999
;;
}

{ .mfi
        nop.m 999
        fma.s1        exp_S1  = EXP_2M,exp_T1,f0                      
        nop.i 999
;;
}


{ .mfi
        nop.m 999
        fma.s1        exp_P     = exp_rcube, exp_P_lo, exp_P_hi       
        nop.i 999
;;
}

{ .mfi
        nop.m 999
        fma.s1        exp_S   = exp_S1,exp_S2,f0                      
        nop.i 999
;;
}

{ .bbb
(p12)   br.cond.spnt  EXP_CERTAIN_UNDERFLOW
(p13)   br.cond.spnt  EXP_POSSIBLE_UNDERFLOW
(p14)   br.cond.spnt  EXP_POSSIBLE_OVERFLOW
;;
}


{ .mfb
        nop.m 999
        fma.d      f8 = exp_S, exp_P, exp_S 
        br.ret.sptk     b0 ;;               // Normal path exit 
}


EXP_POSSIBLE_OVERFLOW: 

// We got an answer. EXP_MAX_DBL_NORM_ARG < x < EXP_MIN_DBL_OFLOW_ARG
// overflow is a possibility, not a certainty

{ .mfi
	nop.m 999
        fsetc.s2 0x7F,0x42                                          
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
        fma.d.s2      exp_wre_urm_f8 = exp_S, exp_P, exp_S          
	nop.i 999 ;;
}

// We define an overflow when the answer with
//    WRE set
//    user-defined rounding mode
// is ldn +1

// Is the exponent 1 more than the largest double?
// If so, go to ERROR RETURN, else get the answer and 
// leave.

// Largest double is 7FE (biased double)
//                   7FE - 3FF + FFFF = 103FE
// Create + largest_double_plus_ulp
// Create - largest_double_plus_ulp
// Calculate answer with WRE set.

// Cases when answer is ldn+1  are as follows:
//  ldn                   ldn+1
// --+----------|----------+------------
//              | 
//    +inf          +inf      -inf
//                  RN         RN
//                             RZ 

{ .mfi
	nop.m 999
        fsetc.s2 0x7F,0x40                                          
        mov           exp_GR_gt_ln  = 0x103ff ;;                      
}

{ .mfi
        setf.exp      exp_gt_pln    = exp_GR_gt_ln                 
	nop.f 999
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
       fcmp.ge.unc.s1 p6, p0 =  exp_wre_urm_f8, exp_gt_pln 	  
	nop.i 999 ;;
}

{ .mfb
	nop.m 999
	nop.f 999
(p6)   br.cond.spnt EXP_CERTAIN_OVERFLOW ;; // Branch if really overflow
}

{ .mfb
	nop.m 999
       fma.d        f8 = exp_S, exp_P, exp_S                      
       br.ret.sptk     b0 ;;             // Exit if really no overflow
}

EXP_CERTAIN_OVERFLOW:
{ .mmi
      sub   exp_GR_17ones_m1 = exp_GR_17ones, r0, 1 ;;
      setf.exp     f9 = exp_GR_17ones_m1
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
      fmerge.s FR_X = f8,f8
      nop.i 999
}
{ .mfb
      mov        GR_Parameter_TAG = 14
      fma.d       FR_RESULT = f9, f9, f0    // Set I,O and +INF result
      br.cond.sptk  __libm_error_region ;;                             
}

EXP_POSSIBLE_UNDERFLOW: 

// We got an answer. EXP_MAX_DBL_UFLOW_ARG < x < EXP_MIN_DBL_NORM_ARG
// underflow is a possibility, not a certainty

// We define an underflow when the answer with
//    ftz set
// is zero (tiny numbers become zero)

// Notice (from below) that if we have an unlimited exponent range,
// then there is an extra machine number E between the largest denormal and
// the smallest normal.

// So if with unbounded exponent we round to E or below, then we are
// tiny and underflow has occurred.

// But notice that you can be in a situation where we are tiny, namely
// rounded to E, but when the exponent is bounded we round to smallest
// normal. So the answer can be the smallest normal with underflow.

//                           E
// -----+--------------------+--------------------+-----
//      |                    |                    |
//   1.1...10 2^-3fff    1.1...11 2^-3fff    1.0...00 2^-3ffe
//   0.1...11 2^-3ffe                                   (biased, 1)
//    largest dn                               smallest normal

{ .mfi
	nop.m 999
       fsetc.s2 0x7F,0x41                                          
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
       fma.d.s2      exp_ftz_urm_f8 = exp_S, exp_P, exp_S          
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
       fsetc.s2 0x7F,0x40                                          
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
       fcmp.eq.unc.s1 p6, p0 =  exp_ftz_urm_f8, f0 	          
	nop.i 999 ;;
}
{ .mfb
	nop.m 999
	nop.f 999
(p6)   br.cond.spnt EXP_CERTAIN_UNDERFLOW ;; // Branch if really underflow
}
{ .mfb
	nop.m 999
       fma.d        f8 = exp_S, exp_P, exp_S                      
       br.ret.sptk     b0 ;;                // Exit if really no underflow
}

EXP_CERTAIN_UNDERFLOW:
{ .mfi
      nop.m 999
      fmerge.s FR_X = f8,f8
      nop.i 999
}
{ .mfb
      mov        GR_Parameter_TAG = 15
      fma.d       FR_RESULT  = exp_S, exp_P, exp_S // Set I,U and tiny result
      br.cond.sptk  __libm_error_region ;;                             
}

EXP_CERTAIN_UNDERFLOW_ZERO:
{ .mmi
      mov   exp_GR_one = 1 ;;
      setf.exp     f9 = exp_GR_one
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
      fmerge.s FR_X = f8,f8
      nop.i 999
}
{ .mfb
      mov        GR_Parameter_TAG = 15
      fma.d       FR_RESULT = f9, f9, f0    // Set I,U and tiny (+0.0) result
      br.cond.sptk  __libm_error_region ;;                             
}

.endp exp


.proc __libm_error_region
__libm_error_region:
.prologue
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs 
}
{ .mfi
.fframe 64 
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfd [GR_Parameter_Y] = FR_Y,16         // STORE Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0                      
        mov GR_SAVE_B0=b0                       // Save b0 
};;
.body
{ .mib
        stfd [GR_Parameter_X] = FR_X                  // STORE Parameter 1 on stack 
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y  // Parameter 3 address 
	nop.b 0                                      
}
{ .mib
        stfd [GR_Parameter_Y] = FR_RESULT             // STORE Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y  
        br.call.sptk b0=__libm_error_support#         // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;
{ .mmi
        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp 
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};; 

.endp __libm_error_region
.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\expf.s ===
.file "expf.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.

// History
//==============================================================
// 4/04/00  Unwind update
// 4/04/00  Unwind support added
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 8/21/00  Improvements to save 2 cycles on main path, and shorten x=0 case
// 12/07/00 Widen main path, shorten x=inf, nan paths
//
// Assembly macros
//==============================================================
// integer registers used

 exp_GR_0x0f                = r33
 exp_GR_0xf0                = r34

 EXP_AD_P_1                 = r36
 EXP_AD_P_2                 = r37
 EXP_AD_T1                  = r38
 EXP_AD_T2                  = r39
 exp_GR_Mint                = r40

 exp_GR_Mint_p_128          = r41
 exp_GR_Ind1                = r42
 EXP_AD_M1                  = r43
 exp_GR_Ind2                = r44
 EXP_AD_M2                  = r45

 exp_GR_min_oflow           = r46
 exp_GR_max_zero            = r47
 exp_GR_max_norm            = r48
 exp_GR_max_uflow           = r49
 exp_GR_min_norm            = r50

 exp_GR_17ones              = r51
 exp_GR_gt_ln               = r52
 exp_GR_T2_size             = r53

 exp_GR_17ones_m1           = r56
 exp_GR_one                 = r57



GR_SAVE_B0                    = r53
GR_SAVE_PFS                   = r55
GR_SAVE_GP                    = r54 

GR_Parameter_X                = r59
GR_Parameter_Y                = r60
GR_Parameter_RESULT           = r61
GR_Parameter_TAG              = r62

FR_X             = f10
FR_Y             = f1
FR_RESULT        = f8


// floating point registers used

 EXP_MIN_SGL_OFLOW_ARG      = f11
 EXP_MAX_SGL_ZERO_ARG       = f12
 EXP_MAX_SGL_NORM_ARG       = f13
 EXP_MAX_SGL_UFLOW_ARG      = f14
 EXP_MIN_SGL_NORM_ARG       = f15

 exp_coeff_P5               = f32
 exp_coeff_P6               = f33
 exp_coeff_P3               = f34
 exp_coeff_P4               = f35

 exp_coeff_P1               = f36
 exp_coeff_P2               = f37
 exp_Mx                     = f38
 exp_Mfloat                 = f39
 exp_R                      = f40

 exp_P1                     = f41
 exp_P2                     = f42
 exp_P3                     = f43
 exp_Rsq                    = f44
 exp_R4                     = f45

 exp_P4                     = f46
 exp_P5                     = f47
 exp_P6                     = f48
 exp_P7                     = f49
 exp_T1                     = f50

 exp_T2                     = f51
 exp_T                      = f52
 exp_A                      = f53
 exp_norm_f8                = f54
 exp_wre_urm_f8             = f55

 exp_ftz_urm_f8             = f56
 exp_gt_pln                 = f57


.data

.align 16

exp_coeff_1_table:
data8 0x3F56F35FDE4F8563 // p5
data8 0x3F2A378BEFECCFDD // p6
data8 0x3FE00000258C581D // p1
data8 0x3FC555557AE7B3D4 // p2


exp_coeff_2_table:
data8 0x3FA5551BB6592FAE // p3
data8 0x3F8110E8EBFFD485 // p4


exp_T2_table:
data8 0xa175cf9cd7d85844 , 0x00003f46 // exp(-128)
data8 0xdb7279415a1f9eed , 0x00003f47 // exp(-127)
data8 0x95213b242bd8ca5f , 0x00003f49 // exp(-126)
data8 0xcab03c968c989f83 , 0x00003f4a // exp(-125)
data8 0x89bdb674702961ad , 0x00003f4c // exp(-124)
data8 0xbb35a2eec278be35 , 0x00003f4d // exp(-123)
data8 0xfe71b17f373e7e7a , 0x00003f4e // exp(-122)
data8 0xace9a6ec52a39b63 , 0x00003f50 // exp(-121)
data8 0xeb03423fe393cf1c , 0x00003f51 // exp(-120)
data8 0x9fb52c5bcaef1693 , 0x00003f53 // exp(-119)
data8 0xd910b6377ed60bf1 , 0x00003f54 // exp(-118)
data8 0x9382dad8a9fdbfe4 , 0x00003f56 // exp(-117)
data8 0xc87d0a84dea869a3 , 0x00003f57 // exp(-116)
data8 0x883efb4c6d1087b0 , 0x00003f59 // exp(-115)
data8 0xb92d7373dce9a502 , 0x00003f5a // exp(-114)
data8 0xfbaeb020577fb0cb , 0x00003f5b // exp(-113)


exp_T1_table:
data8 0x8000000000000000 , 0x00003fff // exp(16 * 0)
data8 0x87975e8540010249 , 0x00004016 // exp(16 * 1) 
data8 0x8fa1fe625b3163ec , 0x0000402d // exp(16 * 2) 
data8 0x9826b576512a59d7 , 0x00004044 // exp(16 * 3) 
data8 0xa12cc167acbe6902 , 0x0000405b // exp(16 * 4) 
data8 0xaabbcdcc279f59e4 , 0x00004072 // exp(16 * 5) 
data8 0xb4dbfaadc045d16f , 0x00004089 // exp(16 * 6) 
data8 0xbf95e372ccdbf146 , 0x000040a0 // exp(16 * 7) 
data8 0xcaf2a62eea10bbfb , 0x000040b7 // exp(16 * 8) 
data8 0xd6fbeb62fddbd340 , 0x000040ce // exp(16 * 9) 
data8 0xe3bbee32e4a440ea , 0x000040e5 // exp(16 * 10)
data8 0xf13d8517c34199a8 , 0x000040fc // exp(16 * 11)
data8 0xff8c2b166241eedd , 0x00004113 // exp(16 * 12)
data8 0x875a04c0b38d6129 , 0x0000412b // exp(16 * 13)
data8 0x8f610127db6774d7 , 0x00004142 // exp(16 * 14)
data8 0x97e1dd87e5c20bb6 , 0x00004159 // exp(16 * 15)

// Argument Reduction
//  exp_Mx = (int)f8            ==> The value of f8 rounded to int is placed into the
//                                  significand of exp_Mx as a two's
//                                  complement number.

// Later we want to have exp_Mx in a general register. Do this with a getf.sig
// and call the general register exp_GR_Mint

//  exp_Mfloat = (float)(int)f8 ==> the two's complement number in
//                                  significand of exp_Mx is turned
//                                  into a floating point number.
//  R = 1 - exp_Mfloat          ==> reduced argument

// Core Approximation
// Calculate a series in R
//  R * p6 + p5
//  R * p4 + p3
//  R * p2 + p1
//  R^2
//  R^4
//  R^2(R * p6 + p5) + (R * p4 + p3)
//  R^2(R * p2 + p1)
//  R^4(R^2(R * p6 + p5) + (R * p4 + p3)) + (R^2(R * p2 + p1))
//  R + 1
//  exp(R) = (1 + R) + R^4(R^2(R * p6 + p5) + (R * p4 + p3)) + (R^2(R * p2 + p1))
//  exp(R) = 1 + R + R^2 * p1 + R^3 * p2 + R^4 * p3 + R^5 * p4 + R^6 * p5 + R^7 * p6

// Reconstruction
// signficand of exp_Mx is two's complement,
// -103 < x < 89
// The smallest single denormal is 2^-149 = ssdn
//    For e^x = ssdn
//        x   = log(ssdn) = -103.279
//    But with rounding result goes to ssdn until -103.972079
// The largest single normal is  1.<23 1's> 2^126 ~ 2^127 = lsn
//    For e^x = lsn
//        x   = log(lsn) = 88.7228
//
// expf overflows                       when x > 42b17218 = 88.7228
// expf returns largest single denormal when x = c2aeac50
// expf goes to zero when                    x < c2cff1b5 

// Consider range of 8-bit two's complement, -128 ---> 127
// Add 128; range becomes                       0 ---> 255

// The number (=i) in 0 ---> 255 is used as offset into two tables.

// i = abcd efgh = abcd * 16 + efgh = i1 * 16 + i2

// i1 = (exp_GR_Mint + 128)  & 0xf0 (show 0xf0 as -0x10 to avoid assembler error)
//                                  (The immediate in the AND is an 8-bit two's complement)
// i1 = i1 + start of T1 table (EXP_AD_T1)
//    Note that the entries in T1 are double-extended numbers on 16-byte boundaries
//    and that i1 is already shifted left by 16 after the AND.

// i2 must be shifted left by 4 before adding to the start of the table.
// i2 = ((exp_GR_Mint + 128)  & 0x0f) << 4
// i2 = i2 + start of T2 table (EXP_AD_T2)

// T      = T1 * T2
// A      = T * (1 + R)
// answer = T *  (R^2 * p1 + R^3 * p2 + R^4 * p3 + R^5 * p4 + R^6 * p5 + R^7 * p6) +
//          T *  (1 + R)
//        = T * exp(R)


.global expf#

.section .text
.proc  expf#
.align 32
expf:

{ .mfi
     alloc      r32            = ar.pfs,1,26,4,0
     fcvt.fx.s1   exp_Mx       =    f8
     mov       exp_GR_17ones   =    0x1FFFF
}
{ .mlx
     addl      EXP_AD_P_1      =    @ltoff(exp_coeff_1_table),gp
     movl      exp_GR_min_oflow = 0x42b17218    
}
;;

// Fnorm done to take any enabled faults
{ .mfi
     ld8       EXP_AD_P_1      =  [EXP_AD_P_1]
     fclass.m  p6,p0      = f8, 0x07	//@zero
     nop.i 999
}
{ .mfi
     add       exp_GR_max_norm = -1, exp_GR_min_oflow  // 0x42b17217
     fnorm     exp_norm_f8     =    f8
     nop.i 999
}
;;

{ .mfi
     setf.s    EXP_MIN_SGL_OFLOW_ARG = exp_GR_min_oflow  // 0x42b17218
     fclass.m  p7,p0      = f8, 0x22	// Test for x=-inf
     mov       exp_GR_0xf0 = 0x0f0
}
{ .mlx
     setf.s    EXP_MAX_SGL_NORM_ARG = exp_GR_max_norm
     movl      exp_GR_max_zero = 0xc2cff1b5    
}
;;


{ .mlx
     mov       exp_GR_0x0f = 0x00f
     movl      exp_GR_max_uflow = 0xc2aeac50    
}
{ .mfb
     nop.m 999
(p6) fma.s     f8 = f1,f1,f0
(p6) br.ret.spnt   b0        // quick exit for x=0
}
;;

{ .mfi
     setf.s    EXP_MAX_SGL_ZERO_ARG = exp_GR_max_zero
     fclass.m  p8,p0      = f8, 0x21	// Test for x=+inf
     adds      exp_GR_min_norm = 1, exp_GR_max_uflow  // 0xc2aeac51
}
{ .mfb
     ldfpd     exp_coeff_P5,exp_coeff_P6     =    [EXP_AD_P_1],16
(p7) fma.s     f8 = f0,f0,f0
(p7) br.ret.spnt   b0        // quick exit for x=-inf
}
;;

{ .mmf
     ldfpd     exp_coeff_P1,exp_coeff_P2     =    [EXP_AD_P_1],16
     setf.s    EXP_MAX_SGL_UFLOW_ARG = exp_GR_max_uflow
     fclass.m  p9,p0      = f8, 0xc3	// Test for x=nan
}
;;

{ .mmb
     ldfpd     exp_coeff_P3,exp_coeff_P4     =    [EXP_AD_P_1],16
     setf.s    EXP_MIN_SGL_NORM_ARG = exp_GR_min_norm
(p8) br.ret.spnt   b0        // quick exit for x=+inf
}
;;

// EXP_AD_P_1 now points to exp_T2_table
{ .mfi
     mov exp_GR_T2_size           = 0x100
     fcvt.xf   exp_Mfloat     =    exp_Mx
     nop.i 999
}
;;

{ .mfb
     getf.sig  exp_GR_Mint    =    exp_Mx
(p9) fmerge.s     f8 = exp_norm_f8, exp_norm_f8
(p9) br.ret.spnt   b0        // quick exit for x=nan
}
;;

{ .mmi
     nop.m 999
     mov      EXP_AD_T2       =  EXP_AD_P_1
     add      EXP_AD_T1       =  exp_GR_T2_size,EXP_AD_P_1 ;;
}


{ .mmi
     adds      exp_GR_Mint_p_128   =    0x80,exp_GR_Mint ;;
     and       exp_GR_Ind1      =    exp_GR_Mint_p_128, exp_GR_0xf0
     and       exp_GR_Ind2      =    exp_GR_Mint_p_128, exp_GR_0x0f ;;
}

// Divide arguments into the following categories:
//  Certain Underflow/zero  p11 - -inf < x <= MAX_SGL_ZERO_ARG 
//  Certain Underflow       p12 - MAX_SGL_ZERO_ARG < x <= MAX_SGL_UFLOW_ARG 
//  Possible Underflow      p13 - MAX_SGL_UFLOW_ARG < x < MIN_SGL_NORM_ARG
//  Certain Safe                - MIN_SGL_NORM_ARG <= x <= MAX_SGL_NORM_ARG
//  Possible Overflow       p14 - MAX_SGL_NORM_ARG < x < MIN_SGL_OFLOW_ARG
//  Certain Overflow        p15 - MIN_SGL_OFLOW_ARG <= x < +inf
//
// If the input is really a single arg, then there will never be "Possible
// Underflow" or "Possible Overflow" arguments.
//

{ .mfi
     add       EXP_AD_M1 =    exp_GR_Ind1,EXP_AD_T1
     fcmp.ge.s1  p15,p14 = exp_norm_f8,EXP_MIN_SGL_OFLOW_ARG
     nop.i 999
}
{ .mfi
     shladd       EXP_AD_M2                =    exp_GR_Ind2,4,EXP_AD_T2
     fms.s1    exp_R                    =    f1,f8,exp_Mfloat
     nop.i 999 ;;
}

{ .mfi
     ldfe           exp_T1    =    [EXP_AD_M1]
     fcmp.le.s1  p11,p12 = exp_norm_f8,EXP_MAX_SGL_ZERO_ARG
     nop.i 999 ;;
}

{ .mfb
      ldfe           exp_T2   =    [EXP_AD_M2]
(p14) fcmp.gt.s1  p14,p0 = exp_norm_f8,EXP_MAX_SGL_NORM_ARG
(p15) br.cond.spnt EXP_CERTAIN_OVERFLOW ;;
}

{ .mfb
      nop.m 999
(p12) fcmp.le.s1  p12,p0 = exp_norm_f8,EXP_MAX_SGL_UFLOW_ARG
(p11) br.cond.spnt EXP_CERTAIN_UNDERFLOW_ZERO
}
;;

{ .mfi
      nop.m 999
(p13) fcmp.lt.s1  p13,p0 = exp_norm_f8,EXP_MIN_SGL_NORM_ARG
      nop.i 999
}
;;


{ .mfi
     nop.m                 999
     fma.s1    exp_Rsq   =    exp_R,exp_R,f0
     nop.i                 999
}
{ .mfi
     nop.m                 999
     fma.s1    exp_P3    =    exp_R,exp_coeff_P2,exp_coeff_P1
     nop.i                 999 
}
;;

{ .mfi
     nop.m                 999
     fma.s1    exp_P1    =    exp_R,exp_coeff_P6,exp_coeff_P5
     nop.i                 999 
}
{ .mfi
     nop.m                 999
     fma.s1    exp_P2    =    exp_R,exp_coeff_P4,exp_coeff_P3
     nop.i                 999
}
;;


{ .mfi
     nop.m                 999
     fma.s1    exp_P7    =    f1,exp_R,f1
     nop.i                 999
}
;;


{ .mfi
     nop.m                 999
     fma.s1    exp_P5    =    exp_Rsq,exp_P3,f0
     nop.i                 999
}
{ .mfi
     nop.m                 999
     fma.s1    exp_R4    =    exp_Rsq,exp_Rsq,f0
     nop.i                 999 
}
;;

{ .mfi
     nop.m                 999
     fma.s1    exp_T     =    exp_T1,exp_T2,f0
     nop.i                 999 
}
{ .mfi
     nop.m                 999
     fma.s1    exp_P4    =    exp_Rsq,exp_P1,exp_P2
     nop.i                 999 
}
;;

{ .mfi
     nop.m                 999
     fma.s1    exp_A     =    exp_T,exp_P7,f0
     nop.i                 999
}
{ .mfi
     nop.m                 999
     fma.s1    exp_P6    =    exp_R4,exp_P4,exp_P5
     nop.i                 999
}
;;

{ .bbb
(p12) br.cond.spnt EXP_CERTAIN_UNDERFLOW
(p13) br.cond.spnt EXP_POSSIBLE_UNDERFLOW
(p14) br.cond.spnt EXP_POSSIBLE_OVERFLOW
}
;;

{ .mfb
     nop.m            999
     fma.s     f8   =    exp_T,exp_P6,exp_A
     br.ret.sptk     b0
}
;;

EXP_POSSIBLE_OVERFLOW:

// We got an answer. EXP_MAX_SGL_NORM_ARG < x < EXP_MIN_SGL_OFLOW_ARG
// overflow is a possibility, not a certainty
// Set wre in s2 and perform the last operation with s2

// We define an overflow when the answer with
//    WRE set
//    user-defined rounding mode
// is lsn +1

// Is the exponent 1 more than the largest single?
// If so, go to ERROR RETURN, else (no overflow) get the answer and
// leave.

// Largest single is FE (biased single)
//                   FE - 7F + FFFF = 1007E

// Create + largest_single_plus_ulp
// Create - largest_single_plus_ulp

// Calculate answer with WRE set.

// Cases when answer is lsn+1  are as follows:

//           midpoint
//              |
//  lsn         |         lsn+1
// --+----------|----------+------------
//              |
//    +inf          +inf      -inf
//                  RN         RN
//                             RZ
// exp_gt_pln contains the floating point number lsn+1.
// The setf.exp puts 0x1007f in the exponent and 0x800... in the significand.

// If the answer is >= lsn+1, we have overflowed.
// Then p6 is TRUE. Set the overflow tag, save input in FR_X,
// do the final calculation for IEEE result, and branch to error return.

{ .mfi
       mov         exp_GR_gt_ln    = 0x1007F 
       fsetc.s2    0x7F,0x42
       nop.i 999
}
;;

{ .mfi
       setf.exp      exp_gt_pln    = exp_GR_gt_ln
       fma.s.s2    exp_wre_urm_f8  = exp_T,  exp_P6, exp_A
       nop.i 999
}
;;

{ .mfi
       nop.m 999
       fsetc.s2 0x7F,0x40
       nop.i 999
}
;;

{ .mfi
       nop.m 999
       fcmp.ge.unc.s1 p6, p0       =  exp_wre_urm_f8, exp_gt_pln
       nop.i 999
}
;;

{ .mfb
       nop.m 999
       nop.f 999
(p6)   br.cond.spnt EXP_CERTAIN_OVERFLOW  // Branch if really overflow
}
;;

{ .mfb
       nop.m 999
       fma.s        f8             = exp_T,  exp_P6, exp_A
       br.ret.sptk     b0                 // Exit if really no overflow
}
;;

EXP_CERTAIN_OVERFLOW:
{ .mmi
      sub   exp_GR_17ones_m1 = exp_GR_17ones, r0, 1 ;;
      setf.exp     f9 = exp_GR_17ones_m1
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
      fmerge.s FR_X = f8,f8
      nop.i 999
}
{ .mfb
      mov        GR_Parameter_TAG = 16
      fma.s       FR_RESULT = f9, f9, f0    // Set I,O and +INF result
      br.cond.sptk  __libm_error_region ;;                             
}

EXP_POSSIBLE_UNDERFLOW: 

// We got an answer. EXP_MAX_SGL_UFLOW_ARG < x < EXP_MIN_SGL_NORM_ARG
// underflow is a possibility, not a certainty

// We define an underflow when the answer with
//    ftz set
// is zero (tiny numbers become zero)

// Notice (from below) that if we have an unlimited exponent range,
// then there is an extra machine number E between the largest denormal and
// the smallest normal.

// So if with unbounded exponent we round to E or below, then we are
// tiny and underflow has occurred.

// But notice that you can be in a situation where we are tiny, namely
// rounded to E, but when the exponent is bounded we round to smallest
// normal. So the answer can be the smallest normal with underflow.

//                           E
// -----+--------------------+--------------------+-----
//      |                    |                    |
//   1.1...10 2^-7f      1.1...11 2^-7f      1.0...00 2^-7e  
//   0.1...11 2^-7e                                     (biased, 1)
//    largest dn                               smallest normal

// If the answer is = 0, we have underflowed.
// Then p6 is TRUE. Set the underflow tag, save input in FR_X,
// do the final calculation for IEEE result, and branch to error return.

{ .mfi
       nop.m 999
       fsetc.s2 0x7F,0x41
       nop.i 999
}
;;

{ .mfi
       nop.m 999
       fma.s.s2     exp_ftz_urm_f8  = exp_T,  exp_P6, exp_A
       nop.i 999
}
;;


{ .mfi
       nop.m 999
       fsetc.s2 0x7F,0x40
       nop.i 999
}
;;

{ .mfi
       nop.m 999
       fcmp.eq.unc.s1 p6, p0     =  exp_ftz_urm_f8, f0
       nop.i 999
}
;;

{ .mfb
       nop.m 999
       nop.f 999
(p6)   br.cond.spnt EXP_CERTAIN_UNDERFLOW  // Branch if really underflow 
}
;;

{ .mfb
       nop.m 999
       fma.s        f8             = exp_T,  exp_P6, exp_A
       br.ret.sptk     b0                  // Exit if really no underflow
}
;;

EXP_CERTAIN_UNDERFLOW:
{ .mfi
      nop.m 999
      fmerge.s FR_X = f8,f8
      nop.i 999
}
{ .mfb
      mov        GR_Parameter_TAG = 17
      fma.s       FR_RESULT  = exp_T, exp_P6, exp_A // Set I,U and tiny result
      br.cond.sptk  __libm_error_region ;;                             
}

EXP_CERTAIN_UNDERFLOW_ZERO:
{ .mmi
      mov   exp_GR_one = 1 ;;
      setf.exp     f9 = exp_GR_one
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
      fmerge.s FR_X = f8,f8
      nop.i 999
}
{ .mfb
      mov        GR_Parameter_TAG = 17
      fma.s       FR_RESULT = f9, f9, f0    // Set I,U and tiny (+0.0) result
      br.cond.sptk  __libm_error_region ;;                             
}

.endp expf


.proc __libm_error_region
__libm_error_region:
.prologue
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
	nop.f 999
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfs [GR_Parameter_Y] = FR_Y,16         // Store Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
};;
.body
{ .mfi
        stfs [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
        nop.f 0
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y // Parameter 3 address
}
{ .mib
        stfs [GR_Parameter_Y] = FR_RESULT       // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#   // Call error handling function
};;

{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp 
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};; 

.endp __libm_error_region


.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\fabsf.s ===
.file "fabsf.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version
//
// API
//==============================================================
//  float fabsf(float x)
//
// Overview of operation
//==============================================================
// returns absolute value of x 
//
// floating-point registers used: 1
// f8, input

.align 32
.global fabsf#

.section .text
.proc  fabsf#
.align 32

fabsf: 

// set invalid or denormal flags and take fault if
// necessary

{ .mfi
      nop.m 999
      fcmp.eq.unc.s0 p6,p7 = f8,f1             
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
      fabs           f8 = f8                   
(p0)  br.ret.sptk    b0 ;;                        
}

.endp fabsf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\frnd.s ===
.file "frnd.s"
  .section .text
  .proc  _frnd#
  .align 32
  .global _frnd#
  .align 32

_frnd:

  // CONVERT BEGINS HERE WITH ARGUMENT IN f8
{ .mmi
  // save the old fpsr in r2
  mov r2=ar40;;
  mov r3=r2
  nop.i 0
} { .mlx
  nop.m 0
  movl r8=0x02000;;
} { .mmi
  // clear sf0.V bit in r3
  andcm r3=r3,r8;;
  // set traps.PDV
  or r3=0x23,r3
  nop.i 0;;
} { .mib
  mov ar40=r3
  nop.i 0
  nop.b 0;;
} { .mfi
  nop.m 0
  fcvt.fx.s0 f7=f8
  nop.i 0;;
} { .mmi
  mov r3=ar40;;
  nop.m 0
  // examine the sf0.V bit (p6 = 1 if sf0.V set)
  tbit.z p6,p7=r3,0x0d;;
} { .mfb
  nop.m 0
(p6) fcvt.xf f8=f7
  nop.b 0;;
}
  // CONVERT ENDS HERE WITH RESULT IN f8
done:
{ .mmb
  mov ar40=r2
  // store result
  nop.m 0
  // return
  br.ret.sptk b0;;
}

  .endp _frnd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\fpsr.s ===
//##########################################################################
//**
//**  Copyright  (C) 1996-2000 Intel Corporation. All rights reserved.
//**
//** The information and source code contained herein is the exclusive
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization
//** from the company.
//**
//###########################################################################

  .file "fpsr.s"
  .section .text
  .align 32

  .proc __set_fpsr#
  .global __set_fpsr#
__set_fpsr:
  alloc r31=ar.pfs,1,1,0,0  // r32, r33

  // &fpsr is in r32

  // load new fpsr in r33
  ld8 r33 = [r32];;
  // set new value of FPSR
  mov ar40 = r33;;
  // return
  br.ret.sptk b0

  .endp __set_fpsr

  .proc __get_fpsr#
  .global __get_fpsr#
__get_fpsr:
  alloc r31=ar.pfs,1,1,0,0  // r32, r33

  // &fpsr is in r32

  // get old value of FPSR
  mov r33 = ar40;;
  // store new fpsr from r33
  st8 [r32] = r33;;
  // return
  br.ret.sptk b0

  .endp __get_fpsr
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\fpctrl.c ===
/***
*fpctrl.c - fp low level control and status routines
*
*   Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   IEEE control and status routines for internal use.
*   These routines use machine specific constants while _controlfp,
*   _statusfp, and _clearfp use an abstracted control/status word
*
*Revision History:
*
*   03-31-92  GDP   written
*   05-12-92  GJF   Rewrote fdivr as fdivrp st(1),st to work around C8-32
*		    assertions.
*
*/

#include <trans.h>

extern uintptr_t _get_fpsr(void);
extern void _set_fpsr(uintptr_t);
extern void _fclrf(void);

/***	_statfp
*() -
*
*Purpose:
*	return user status word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

uintptr_t _statfp()
{
    unsigned __int64 status;

    status = _get_fpsr();

    return status;
}

/***	_clrfp
*() -
*
*Purpose:
*	return user status word and clear status
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

uintptr_t _clrfp()
{
    uintptr_t status;

    status = _get_fpsr();
    _fclrf();

    return status;
}


/***	_ctrlfp
*() -
*
*Purpose:
*	return and set user control word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

uintptr_t _ctrlfp(uintptr_t newctrl, uintptr_t _mask)
{
    uintptr_t oldCw;
    uintptr_t newCw;

    oldCw = _get_fpsr();

    newCw = (uintptr_t) ((newctrl & _mask) | (oldCw & ~_mask));
    newCw |= (oldCw & ~(unsigned __int64)0x0001f3f);

    _set_fpsr(newCw);

    return oldCw;
}



/***	_set_statfp
*() -
*
*Purpose:
*	force selected exception flags to 1
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void _set_statfp(uintptr_t sw)
{
    unsigned __int64 status;

    status = _get_fpsr();

    status |= sw;

    _set_fpsr(status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\floorf.s ===
.file "floorf.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
.align 32
.global floorf#

.section .text
.proc  floorf#
.align 32

// History
//==============================================================
// 2/02/00: Initial version
// 6/13/00: Improved speed
// 6/27/00: Eliminated incorrect invalid flag setting

// API
//==============================================================
// float floorf(float x)

// general input registers:  

floor_GR_FFFF      = r14
floor_GR_signexp   = r15
floor_GR_exponent  = r16
floor_GR_expmask   = r17
floor_GR_bigexp    = r18


// predicate registers used: 

// p6  ==> Input is NaN, infinity, zero
// p7  ==> Input is denormal
// p8  ==> Input is <0
// p9  ==> Input is >=0
// p10 ==> Input is already an integer (bigger than largest integer)
// p11 ==> Input is not a large integer
// p12 ==> Input is a smaller integer
// p13 ==> Input is not an even integer, so inexact must be set


// floating-point registers used: 

FLOOR_NORM_f8      = f9                        
FLOOR_FFFF         = f10 
FLOOR_INEXACT      = f11 
FLOOR_FLOAT_INT_f8 = f12
FLOOR_INT_f8       = f13
FLOOR_adj          = f14

// Overview of operation
//==============================================================

// float floorf(float x)
// Return an integer value (represented as a float) that is the largest 
// value not greater than x
// This is x rounded toward -infinity to an integral value.
// Inexact is set if x != floorf(x)
// **************************************************************************

// Set denormal flag for denormal input and
// and take denormal fault if necessary.

// Is the input an integer value already?

// double_extended
// if the exponent is > 1003e => 3F(true) = 63(decimal)
// we have a significand of 64 bits 1.63-bits.
// If we multiply by 2^63, we no longer have a fractional part
// So input is an integer value already.

// double
// if the exponent is >= 10033 => 34(true) = 52(decimal)
// 34 + 3ff = 433
// we have a significand of 53 bits 1.52-bits. (implicit 1)
// If we multiply by 2^52, we no longer have a fractional part
// So input is an integer value already.

// single
// if the exponent is > 10016 => 17(true) = 23(decimal)
// we have a significand of 24 bits 1.23-bits. (implicit 1)
// If we multiply by 2^23, we no longer have a fractional part
// So input is an integer value already.

// If x is NAN, ZERO, or INFINITY, then  return

// qnan snan inf norm     unorm 0 -+
// 1    1    1   0        0     1 11     0xe7


floorf:

{ .mfi
      getf.exp floor_GR_signexp  = f8
      fcvt.fx.trunc.s1     FLOOR_INT_f8  = f8
      addl        floor_GR_bigexp = 0x10016, r0
}
{ .mfi
      addl        floor_GR_FFFF      = -1,r0
      fcmp.lt.s1  p8,p9 = f8,f0
      mov         floor_GR_expmask    = 0x1FFFF ;;
}

// p7 ==> denorm
{ .mfi
      setf.sig    FLOOR_FFFF  = floor_GR_FFFF
      fclass.m    p7,p0 = f8, 0x0b
      nop.i 999
}
{ .mfi
      nop.m 999
      fnorm           FLOOR_NORM_f8  = f8
      nop.i 999 ;;
}

// p6 ==> NAN, INF, ZERO
{ .mfb
      nop.m 999
      fclass.m      p6,p10 = f8, 0xe7
(p7)  br.cond.spnt  FLOOR_DENORM ;;
}

.pred.rel "mutex",p8,p9
FLOOR_COMMON:
// Set adjustment to subtract from trunc(x) for result
//   If x<0,  adjustment is 1.0
//   If x>=0, adjustment is 0.0
{ .mfi
      and      floor_GR_exponent = floor_GR_signexp, floor_GR_expmask
(p8)  fadd.s1  FLOOR_adj = f1,f0
      nop.i 999
}
{ .mfi
      nop.m 999
(p9)  fadd.s1  FLOOR_adj = f0,f0
      nop.i 999 ;;
}

{ .mfi
(p10) cmp.ge.unc    p10,p11 = floor_GR_exponent, floor_GR_bigexp
(p6)  fnorm.s f8 = f8
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p11) fcvt.xf         FLOOR_FLOAT_INT_f8   = FLOOR_INT_f8
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10) fnorm.s f8 = FLOOR_NORM_f8
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p11) fsub.s   f8 = FLOOR_FLOAT_INT_f8,FLOOR_adj
      nop.i 999 ;;
}
{ .mfi
      nop.m 999
(p11) fcmp.eq.unc.s1  p12,p13  = FLOOR_FLOAT_INT_f8, FLOOR_NORM_f8
      nop.i 999 ;;
}

// Set inexact if result not equal to input
{ .mfi
      nop.m 999
(p13) fmpy.s0     FLOOR_INEXACT = FLOOR_FFFF,FLOOR_FFFF
      nop.i 999
}
// Set result to input if integer
{ .mfb
      nop.m 999
(p12) fnorm.s f8 = FLOOR_NORM_f8
      br.ret.sptk    b0 ;;
}

// Here if input denorm
FLOOR_DENORM:
{ .mfb
      getf.exp floor_GR_signexp  = FLOOR_NORM_f8
      fcvt.fx.trunc.s1     FLOOR_INT_f8  = FLOOR_NORM_f8
      br.cond.sptk  FLOOR_COMMON ;;
}

.endp floorf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\fmodf.s ===
.file "fmodf.s"
// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Cristina Iordache, Ted Kubaska, 
// Bob Norin, Shane Story, and Ping Tak Peter Tang of the Computational 
// Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.
//
// History
//====================================================================
// 2/02/00  Initial version
// 3/02/00  New Algorithm
// 4/04/00  Unwind support added
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
//
// API
//====================================================================
// float fmodf(float,float);   
//
// Overview of operation
//====================================================================
//  fmod(a,b)=a-i*b,
//  where i is an integer such that, if b!=0, 
//  |i|<|a/b| and |a/b-i|<1

// Algorithm
//====================================================================
// a). if |a|<|b|, return a
// b). get quotient and reciprocal overestimates accurate to 
//     33 bits (q2,y2)
// c). if the exponent difference (exponent(a)-exponent(b))
//     is less than 32, truncate quotient to integer and
//     finish in one iteration
// d). if exponent(a)-exponent(b)>=32 (q2>=2^32)
//     round quotient estimate to single precision (k=RN(q2)),
//     calculate partial remainder (a'=a-k*b), 
//     get quotient estimate (a'*y2), and repeat from c).

// Special cases
//====================================================================
// b=+/-0: return NaN, call libm_error_support
// a=+/-Inf, a=NaN or b=NaN: return NaN

// Registers used
//====================================================================
// Predicate registers: p6-p11
// General registers:   r2,r29,r32 (ar.pfs), r33-r39
// Floating point registers: f6-f15


.section .text

GR_SAVE_B0                    = r33
GR_SAVE_PFS                   = r34
GR_SAVE_GP                    = r35 
GR_SAVE_SP                    = r36

GR_Parameter_X                = r37
GR_Parameter_Y                = r38
GR_Parameter_RESULT           = r39
GR_Parameter_TAG              = r40

FR_X             = f10
FR_Y             = f9
FR_RESULT        = f8



.proc fmodf#
.align 32
.global fmodf#
.align 32

fmodf:
// inputs in f8, f9
// result in f8

{ .mfi
  alloc r32=ar.pfs,1,4,4,0
  // f6=|a|
  fmerge.s f6=f0,f8
  mov r2 = 0x0ffdd
}
  {.mfi
  nop.m 0
  // f7=|b|
  fmerge.s f7=f0,f9
  nop.i 0;;
}

{ .mfi
  setf.exp f11 = r2
  // (1) y0
  frcpa.s1 f10,p6=f6,f7
  nop.i 0
} 

// eliminate special cases
// Y +-NAN, +-inf, +-0?     p7
{ .mfi
      nop.m 999
(p0)  fclass.m.unc  p7,p0 = f9, 0xe7           
      nop.i 999;;
}

// qnan snan inf norm     unorm 0 -+
// 1    1    1   0        0     0 11
// e                      3
// X +-NAN, +-inf, ?        p9

{ .mfi
      nop.m 999
(p0)  fclass.m.unc  p9,p0 = f8, 0xe3           
      nop.i 999 
}

// |x| < |y|? Return x p8
{ .mfi
      nop.m 999
(p0)  fcmp.lt.unc.s1 p8,p0 = f6,f7             
      nop.i 999 ;;
}

{ .mfi
  nop.m 0
  // normalize y (if |x|<|y|)
  (p8) fma.s0 f9=f9,f1,f0
  nop.i 0;;
}

  { .mfi
  mov r2=0x1001f
  // (2) q0=a*y0
  (p6) fma.s1 f13=f6,f10,f0
  nop.i 0
} 
{ .mfi
  nop.m 0
  // (3) e0 = 1 - b * y0
  (p6) fnma.s1 f12=f7,f10,f1
  nop.i 0;;
} 

  {.mfi
  nop.m 0
  // normalize x (if |x|<|y|)
  (p8) fma.s.s0 f8=f8,f1,f0
  nop.i 0
} 
{.bbb
  (p9) br.cond.spnt FMOD_X_NAN_INF
  (p7) br.cond.spnt FMOD_Y_NAN_INF_ZERO
  // if |x|<|y|, return
  (p8) br.ret.spnt    b0;;
}

  {.mfi 
  nop.m 0
  // normalize x
  fma.s0 f6=f6,f1,f0
  nop.i 0
} 
{.mfi
  nop.m 0
  // normalize y
  fma.s0 f7=f7,f1,f0
  nop.i 0;;
}


  {.mfi
  // f15=2^32
  setf.exp f15=r2
  // (4) q1=q0+e0*q0
  (p6) fma.s1 f13=f12,f13,f13
  nop.i 0
} 
{ .mfi
  nop.m 0
  // (5) e1 = e0 * e0 + 2^-34
  (p6) fma.s1 f14=f12,f12,f11
  nop.i 0;;
} 
{.mlx
  nop.m 0
  movl r2=0x33a00000;;
} 
{ .mfi
  nop.m 0
  // (6) y1 = y0 + e0 * y0
  (p6) fma.s1 f10=f12,f10,f10
  nop.i 0;;
} 
{.mfi
  // set f12=1.25*2^{-24}
  setf.s f12=r2
  // (7) q2=q1+e1*q1
  (p6) fma.s1 f13=f13,f14,f13
  nop.i 0;;
} 
{.mfi
  nop.m 0
  fmerge.s f9=f8,f9
  nop.i 0
} 
{ .mfi
  nop.m 0
  // (8) y2 = y1 + e1 * y1
  (p6) fma.s1 f10=f14,f10,f10
  // set p6=0, p10=0
  cmp.ne.and p6,p10=r0,r0;;
} 

.align 32
loop24:
  {.mfi
  nop.m 0
  // compare q2, 2^32
  fcmp.lt.unc.s1 p8,p7=f13,f15
  nop.i 0
}
  {.mfi
  nop.m 0
  // will truncate quotient to integer, if exponent<32 (in advance)
  fcvt.fx.trunc.s1 f11=f13
  nop.i 0;;
}
  {.mfi
  nop.m 0
  // if exponent>32, round quotient to single precision (perform in advance)
  fma.s.s1 f13=f13,f1,f0
  nop.i 0;;
}
  {.mfi
  nop.m 0
  // set f12=sgn(a)
  (p8) fmerge.s f12=f8,f1
  nop.i 0
}
  {.mfi
  nop.m 0
  // normalize truncated quotient
  (p8) fcvt.xf f13=f11
  nop.i 0;;
}  
  { .mfi
  nop.m 0
  // calculate remainder (assuming f13=RZ(Q))
  (p7) fnma.s1 f14=f13,f7,f6
  nop.i 0
}
  {.mfi
  nop.m 0
  // also if exponent>32, round quotient to single precision 
  // and subtract 1 ulp: q=q-q*(1.25*2^{-24})
  (p7) fnma.s.s1 f11=f13,f12,f13
  nop.i 0;;
}

  {.mfi
  nop.m 0
  // (p8) calculate remainder (82-bit format)
  (p8) fnma.s1 f11=f13,f7,f6
  nop.i 0
}
  {.mfi
  nop.m 0
  // (p7) calculate remainder (assuming f11=RZ(Q))
  (p7) fnma.s1 f6=f11,f7,f6
  nop.i 0;;
}


  {.mfi
  nop.m 0
  // Final iteration (p8): is f6 the correct remainder (quotient was not overestimated) ?
  (p8) fcmp.lt.unc.s1 p6,p10=f11,f0
  nop.i 0;;
}
  {.mfi
  nop.m 0
  // get new quotient estimation: a'*y2
  (p7) fma.s1 f13=f14,f10,f0
  nop.i 0
}
  {.mfb
  nop.m 0
  // was f14=RZ(Q) ? (then new remainder f14>=0)
  (p7) fcmp.lt.unc.s1 p7,p9=f14,f0
  nop.b 0;;
}


.pred.rel "mutex",p6,p10
  {.mfb
  nop.m 0
  // add b to estimated remainder (to cover the case when the quotient was overestimated) 
  // also set correct sign by using f9=|b|*sgn(a), f12=sgn(a)
  (p6) fma.s.s0 f8=f11,f12,f9
  nop.b 0
}
  {.mfb
  nop.m 0
  // calculate remainder (single precision)
  // set correct sign of result before returning
  (p10) fma.s.s0 f8=f11,f12,f0
  (p8) br.ret.sptk b0;;
}
  {.mfi
  nop.m 0
  // if f13!=RZ(Q), get alternative quotient estimation: a''*y2
  (p7) fma.s1 f13=f6,f10,f0
  nop.i 0
}
  {.mfb
  nop.m 0
  // if f14 was RZ(Q), set remainder to f14
  (p9) mov f6=f14
  br.cond.sptk loop24;;
}

  {  .mmb
	nop.m 0				    
	nop.m 0				    
	br.ret.sptk b0;;
 }

FMOD_X_NAN_INF: 


// Y zero ?
{.mfi 
  nop.m 0
  fma.s1 f10=f9,f1,f0
  nop.i 0;;
}
{.mfi
 nop.m 0
 fcmp.eq.unc.s1 p11,p0=f10,f0
 nop.i 0;;
}
{.mib
  nop.m 0
  nop.i 0
  // if Y zero
  (p11) br.cond.spnt FMOD_Y_ZERO;;                        
}

// X infinity? Return QNAN indefinite
{ .mfi
      nop.m 999
(p0)  fclass.m.unc  p8,p9 = f8, 0x23 
      nop.i 999;; 
}
// Y NaN ?
{.mfi
	 nop.m 999
(p8) fclass.m p9,p8=f9,0xc3
	 nop.i 0;;
}
{.mfi
	nop.m 999
(p8)  frcpa.s0 f8,p0 = f8,f8           
    nop.i 0
} 
{ .mfi
      nop.m 999
	// also set Denormal flag if necessary
(p8)  fma.s0 f9=f9,f1,f0
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
(p8)  fma.s f8=f8,f1,f0                     
	  nop.b 999 ;;                        
}

{ .mfb
      nop.m 999
(p9)  frcpa.s0 f8,p7=f8,f9                     
      br.ret.sptk    b0 ;;                        
}


FMOD_Y_NAN_INF_ZERO: 

// Y INF
{ .mfi
      nop.m 999
(p0)  fclass.m.unc  p7,p0 = f9, 0x23           
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
(p7)  fma.s f8=f8,f1,f0                     
(p7)  br.ret.spnt    b0 ;;                        
}

// Y NAN?
{ .mfi
      nop.m 999
(p0)  fclass.m.unc  p9,p0 = f9, 0xc3           
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
(p9)  fma.s f8=f9,f1,f0                     
(p9)  br.ret.spnt    b0 ;;                        
}

FMOD_Y_ZERO:
// Y zero? Must be zero at this point
// because it is the only choice left.
// Return QNAN indefinite

{.mfi
  nop.m 0
  // set Invalid
  frcpa f12,p0=f0,f0
  nop.i 999
}
// X NAN?
{ .mfi
      nop.m 999
(p0)  fclass.m.unc  p9,p10 = f8, 0xc3           
      nop.i 999 ;;
}
{ .mfi
      nop.m 999
(p10)  fclass.nm  p9,p10 = f8, 0xff           
      nop.i 999 ;;
}

{.mfi
 nop.m 999
 (p9) frcpa f11,p7=f8,f0
 nop.i 0;;
}

{ .mfi
      nop.m 999
(p10) frcpa f11,p7 = f0,f0           
nop.i 999;;
}

{ .mfi
      nop.m 999
(p0)  fmerge.s      f10 = f8, f8             
      nop.i 999
}

{ .mfi
      nop.m 999
(p0)  fma.s f8=f11,f1,f0                     
      nop.i 999;;
}

EXP_ERROR_RETURN: 


{ .mib
      nop.m 0
(p0)  mov GR_Parameter_TAG=122                                 
(p0)  br.sptk __libm_error_region;; 
}

.endp fmodf

.proc __libm_error_region
__libm_error_region:
.prologue
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs 
}
{ .mfi
.fframe 64 
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfs [GR_Parameter_Y] = FR_Y,16         // Save Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0                      
        mov GR_SAVE_B0=b0                       // Save b0 
};;
.body
{ .mib
        stfs [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack 
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y  
	nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfs [GR_Parameter_Y] = FR_RESULT      // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y  
        br.call.sptk b0=__libm_error_support#;;  // Call error handling function
}
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;
{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp 
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};; 

.endp __libm_error_region

.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\fpieee_flt.h ===
//##########################################################################
//**
//**  Copyright  (C) 1996-2000 Intel Corporation. All rights reserved.
//**
//** The information and source code contained herein is the exclusive
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization
//** from the company.
//**
//###########################################################################

/*****************************************************************************
 *  fpieee_flt.h - include file for the FP IEEE exception filter routine
 *
 *
 *  History:
 *    Marius Cornea 09/07/00
 *    marius.cornea@intel.com
 *
 *****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <fpieee.h>
#include <float.h>
#include <wtypes.h>

#define    rc_rn      0
#define    rc_rm      1
#define    rc_rp      2
#define    rc_rz      3

#define    sf_single                  0
#define    sf_double                  2
#define    sf_double_extended         3

#define EXCEPTION_MAXIMUM_PARAMETERS 15 /* maximum nr of exception parameters */

/******************************************************************
macro that helps add the LL on platforms other than NT
*******************************************************************/
#ifndef CONST_FORMAT
#ifndef WIN32

#define CONST_FORMAT(num) num##LL
#else
#define CONST_FORMAT(num) num

#endif
#endif

/* Define the masks and patterns for the different faulting FP instructions
 * Note: Fn_MIN_MASK and Fn_PATTERN need to be checked if new opcodes
 * are inserted in this function
 */

#define F1_MIN_MASK                     CONST_FORMAT(0x010000000000)
#define F1_PATTERN                      CONST_FORMAT(0x010000000000)

#define F1_MASK                         CONST_FORMAT(0x01F000000000)

#define FMA_PATTERN                     CONST_FORMAT(0x010000000000)
#define FMA_S_PATTERN                   CONST_FORMAT(0x011000000000)
#define FMA_D_PATTERN                   CONST_FORMAT(0x012000000000)
#define FPMA_PATTERN                    CONST_FORMAT(0x013000000000)

#define FMS_PATTERN                     CONST_FORMAT(0x014000000000)
#define FMS_S_PATTERN                   CONST_FORMAT(0x015000000000)
#define FMS_D_PATTERN                   CONST_FORMAT(0x016000000000)
#define FPMS_PATTERN                    CONST_FORMAT(0x017000000000)

#define FNMA_PATTERN                    CONST_FORMAT(0x018000000000)
#define FNMA_S_PATTERN                  CONST_FORMAT(0x019000000000)
#define FNMA_D_PATTERN                  CONST_FORMAT(0x01A000000000)
#define FPNMA_PATTERN                   CONST_FORMAT(0x01B000000000)


#define F4_MIN_MASK                     CONST_FORMAT(0x018000000000)
#define F4_PATTERN                      CONST_FORMAT(0x008000000000)

#define F4_MASK                         CONST_FORMAT(0x01F200001000)

#define FCMP_EQ_PATTERN                 CONST_FORMAT(0x008000000000)
#define FCMP_LT_PATTERN                 CONST_FORMAT(0x009000000000)
#define FCMP_LE_PATTERN                 CONST_FORMAT(0x008200000000)
#define FCMP_UNORD_PATTERN              CONST_FORMAT(0x009200000000)
#define FCMP_EQ_UNC_PATTERN             CONST_FORMAT(0x008000001000)
#define FCMP_LT_UNC_PATTERN             CONST_FORMAT(0x009000001000)
#define FCMP_LE_UNC_PATTERN             CONST_FORMAT(0x008200001000)
#define FCMP_UNORD_UNC_PATTERN          CONST_FORMAT(0x009200001000)


#define F6_MIN_MASK                     CONST_FORMAT(0x019200000000)
#define F6_PATTERN                      CONST_FORMAT(0x000200000000)

#define F6_MASK                         CONST_FORMAT(0x01F200000000)

#define FRCPA_PATTERN                   CONST_FORMAT(0x000200000000)
#define FPRCPA_PATTERN                  CONST_FORMAT(0x002200000000)


#define F7_MIN_MASK                     CONST_FORMAT(0x019200000000)
#define F7_PATTERN                      CONST_FORMAT(0x001200000000)

#define F7_MASK                         CONST_FORMAT(0x01F200000000)

#define FRSQRTA_PATTERN                 CONST_FORMAT(0x001200000000)
#define FPRSQRTA_PATTERN                CONST_FORMAT(0x003200000000)


#define F8_MIN_MASK                     CONST_FORMAT(0x018240000000)
#define F8_PATTERN                      CONST_FORMAT(0x000000000000)

#define F8_MASK                         CONST_FORMAT(0x01E3F8000000)

#define FMIN_PATTERN                    CONST_FORMAT(0x0000A0000000)
#define FMAX_PATTERN                    CONST_FORMAT(0x0000A8000000)
#define FAMIN_PATTERN                   CONST_FORMAT(0x0000B0000000)
#define FAMAX_PATTERN                   CONST_FORMAT(0x0000B8000000)
#define FPMIN_PATTERN                   CONST_FORMAT(0x0020A0000000)
#define FPMAX_PATTERN                   CONST_FORMAT(0x0020A8000000)
#define FPAMIN_PATTERN                  CONST_FORMAT(0x0020B0000000)
#define FPAMAX_PATTERN                  CONST_FORMAT(0x0020B8000000)
#define FPCMP_EQ_PATTERN                CONST_FORMAT(0x002180000000)
#define FPCMP_LT_PATTERN                CONST_FORMAT(0x002188000000)
#define FPCMP_LE_PATTERN                CONST_FORMAT(0x002190000000)
#define FPCMP_UNORD_PATTERN             CONST_FORMAT(0x002198000000)
#define FPCMP_NEQ_PATTERN               CONST_FORMAT(0x0021A0000000)
#define FPCMP_NLT_PATTERN               CONST_FORMAT(0x0021A8000000)
#define FPCMP_NLE_PATTERN               CONST_FORMAT(0x0021B0000000)
#define FPCMP_ORD_PATTERN               CONST_FORMAT(0x0021B8000000)


#define F10_MIN_MASK                    CONST_FORMAT(0x018240000000)
#define F10_PATTERN                     CONST_FORMAT(0x000040000000)

#define F10_MASK                        CONST_FORMAT(0x01E3F8000000)

#define FCVT_FX_PATTERN                 CONST_FORMAT(0x0000C0000000)
#define FCVT_FXU_PATTERN                CONST_FORMAT(0x0000C8000000)
#define FCVT_FX_TRUNC_PATTERN           CONST_FORMAT(0x0000D0000000)
#define FCVT_FXU_TRUNC_PATTERN          CONST_FORMAT(0x0000D8000000)
#define FPCVT_FX_PATTERN                CONST_FORMAT(0x0020C0000000)
#define FPCVT_FXU_PATTERN               CONST_FORMAT(0x0020C8000000)
#define FPCVT_FX_TRUNC_PATTERN          CONST_FORMAT(0x0020D0000000)
#define FPCVT_FXU_TRUNC_PATTERN         CONST_FORMAT(0x0020D8000000)


/* Masks for the rounding control bits */
#define RC_MASK                         CONST_FORMAT(0x03)
#define RN_MASK                         CONST_FORMAT(0x00)
#define RM_MASK                         CONST_FORMAT(0x01)
#define RP_MASK                         CONST_FORMAT(0x02)
#define RZ_MASK                         CONST_FORMAT(0x03)

/* Masks for the precision control bits */
#define PC_MASK                         CONST_FORMAT(0x03)
#define SGL_MASK                        CONST_FORMAT(0x00)
#define DBL_MASK                        CONST_FORMAT(0x02)
#define DBL_EXT_MASK                    CONST_FORMAT(0x03)



// opcodes for instructions that take one input operand (for run1args)
#define         FPRSQRTA                1  [not used - fprsqrta not re-executed]
#define         FPCVT_FX                2
#define         FPCVT_FXU               3
#define         FPCVT_FX_TRUNC          4
#define         FPCVT_FXU_TRUNC         5

// opcodes for instructions that take two input operands (for run2args)
#define         FPRCPA                  1  [not used - fprcpa not re-executed]
#define         FPCMP_EQ                2
#define         FPCMP_LT                3
#define         FPCMP_LE                4
#define         FPCMP_UNORD             5
#define         FPCMP_NEQ               6
#define         FPCMP_NLT               7
#define         FPCMP_NLE               8
#define         FPCMP_ORD               9
#define         FPMIN                   10
#define         FPMAX                   11
#define         FPAMIN                  12
#define         FPAMAX                  13

// opcodes for instructions that take three input operands (for run3args)
#define         FPMA                    1
#define         FPMS                    2
#define         FPNMA                   3


/* prototypes for helpers from support files written in asm */

void __get_fpsr (unsigned __int64 *);
void __set_fpsr (unsigned __int64 *);

void _xrun1args (int, unsigned __int64 *, _FP128 *, _FP128 *);
void _xrun2args (int, unsigned __int64 *, _FP128 *, _FP128 *, _FP128 *);
void _xrun3args (int, unsigned __int64 *, _FP128 *, _FP128 *, _FP128 *, _FP128 *);

void _thmB (_FP32 *, _FP32 *, _FP32 *, unsigned __int64 *);
void _thmH (_FP32 *, _FP32 *, unsigned __int64 *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\fmod.s ===
.file "fmod.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Cristina Iordache, Ted Kubaska,
// Bob Norin, Shane Story, and Ping Tak Peter Tang of the Computational
// Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.
//
// History
//====================================================================
// 2/02/00  Initial version
// 3/02/00  New Algorithm
// 4/04/00  Unwind support added
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
//
// API
//====================================================================
// double fmod(double,double);   
//
// Overview of operation
//====================================================================
//  fmod(a,b)=a-i*b,
//  where i is an integer such that, if b!=0, 
//  |i|<|a/b| and |a/b-i|<1
//
// Algorithm
//====================================================================
// a). if |a|<|b|, return a
// b). get quotient and reciprocal overestimates accurate to 
//     33 bits (q2,y2)
// c). if the exponent difference (exponent(a)-exponent(b))
//     is less than 32, truncate quotient to integer and
//     finish in one iteration
// d). if exponent(a)-exponent(b)>=32 (q2>=2^32)
//     round quotient estimate to single precision (k=RN(q2)),
//     calculate partial remainder (a'=a-k*b), 
//     get quotient estimate (a'*y2), and repeat from c).
//
// Special cases
//====================================================================
// b=+/-0: return NaN, call libm_error_support
// a=+/-Inf, a=NaN or b=NaN: return NaN
//
// Registers used
//====================================================================
// Predicate registers: p6-p11
// General registers:   r2,r29,r32 (ar.pfs), r33-r39
// Floating point registers: f6-f15

.section .text


GR_SAVE_B0                    = r33
GR_SAVE_PFS                   = r34
GR_SAVE_GP                    = r35 
GR_SAVE_SP                    = r36

GR_Parameter_X                = r37
GR_Parameter_Y                = r38
GR_Parameter_RESULT           = r39
GR_Parameter_TAG              = r40

FR_X             = f10
FR_Y             = f9
FR_RESULT        = f8


.proc fmod#
.align 32
.global fmod#
.align 32

fmod:
// inputs in f8, f9
// result in f8

{ .mfi
  alloc r32=ar.pfs,1,4,4,0
  // f6=|a|
  fmerge.s f6=f0,f8
  mov r2 = 0x0ffdd
}
  {.mfi
  nop.m 0
  // f7=|b|
  fmerge.s f7=f0,f9
  nop.i 0;;
}

{ .mfi
  setf.exp f11 = r2
  // (1) y0
  frcpa.s1 f10,p6=f6,f7
  nop.i 0
} 

// Y +-NAN, +-inf, +-0?     p7
{ .mfi
      nop.m 999
(p0)  fclass.m.unc  p7,p0 = f9, 0xe7           
      nop.i 999;;
}

// qnan snan inf norm     unorm 0 -+
// 1    1    1   0        0     0 11
// e                      3
// X +-NAN, +-inf, ?        p9

{ .mfi
      nop.m 999
(p0)  fclass.m.unc  p9,p0 = f8, 0xe3           
      nop.i 999 
}

// |x| < |y|? Return x p8
{ .mfi
      nop.m 999
(p0)  fcmp.lt.unc.s1 p8,p0 = f6,f7             
      nop.i 999 ;;
}

{ .mfi
  nop.m 0
  // normalize y (if |x|<|y|)
  (p8) fma.s0 f9=f9,f1,f0
  nop.i 0;;
}

  { .mfi
  mov r2=0x1001f
  // (2) q0=a*y0
  (p6) fma.s1 f13=f6,f10,f0
  nop.i 0
} 
{ .mfi
  nop.m 0
  // (3) e0 = 1 - b * y0
  (p6) fnma.s1 f12=f7,f10,f1
  nop.i 0;;
} 

  {.mfi
  nop.m 0
  // normalize x (if |x|<|y|)
  (p8) fma.d.s0 f8=f8,f1,f0
  nop.i 0
} 
{.bbb
  (p9) br.cond.spnt FMOD_X_NAN_INF
  (p7) br.cond.spnt FMOD_Y_NAN_INF_ZERO
  // if |x|<|y|, return
  (p8) br.ret.spnt    b0;;
}

  {.mfi 
  nop.m 0
  // normalize x
  fma.s0 f6=f6,f1,f0
  nop.i 0
} 
{.mfi
  nop.m 0
  // normalize y
  fma.s0 f7=f7,f1,f0
  nop.i 0;;
}

  {.mfi
  // f15=2^32
  setf.exp f15=r2
  // (4) q1=q0+e0*q0
  (p6) fma.s1 f13=f12,f13,f13
  nop.i 0
} 
{ .mfi
  nop.m 0
  // (5) e1 = e0 * e0 + 2^-34
  (p6) fma.s1 f14=f12,f12,f11
  nop.i 0;;
} 
{.mlx
  nop.m 0
  movl r2=0x33a00000;;
} 
{ .mfi
  nop.m 0
  // (6) y1 = y0 + e0 * y0
  (p6) fma.s1 f10=f12,f10,f10
  nop.i 0;;
} 
{.mfi
  // set f12=1.25*2^{-24}
  setf.s f12=r2
  // (7) q2=q1+e1*q1
  (p6) fma.s1 f13=f13,f14,f13
  nop.i 0;;
} 
{.mfi
  nop.m 0
  fmerge.s f9=f8,f9
  nop.i 0
} 
{ .mfi
  nop.m 0
  // (8) y2 = y1 + e1 * y1
  (p6) fma.s1 f10=f14,f10,f10
  // set p6=0, p10=0
  cmp.ne.and p6,p10=r0,r0;;
} 

.align 32
loop53:
  {.mfi
  nop.m 0
  // compare q2, 2^32
  fcmp.lt.unc.s1 p8,p7=f13,f15
  nop.i 0
}
  {.mfi
  nop.m 0
  // will truncate quotient to integer, if exponent<32 (in advance)
  fcvt.fx.trunc.s1 f11=f13
  nop.i 0;;
}
  {.mfi
  nop.m 0
  // if exponent>32, round quotient to single precision (perform in advance)
  fma.s.s1 f13=f13,f1,f0
  nop.i 0;;
}
  {.mfi
  nop.m 0
  // set f12=sgn(a)
  (p8) fmerge.s f12=f8,f1
  nop.i 0
}
  {.mfi
  nop.m 0
  // normalize truncated quotient
  (p8) fcvt.xf f13=f11
  nop.i 0;;
}  
  { .mfi
  nop.m 0
  // calculate remainder (assuming f13=RZ(Q))
  (p7) fnma.s1 f14=f13,f7,f6
  nop.i 0
}
  {.mfi
  nop.m 0
  // also if exponent>32, round quotient to single precision 
  // and subtract 1 ulp: q=q-q*(1.25*2^{-24})
  (p7) fnma.s.s1 f11=f13,f12,f13
  nop.i 0;;
}

  {.mfi
  nop.m 0
  // (p8) calculate remainder (82-bit format)
  (p8) fnma.s1 f11=f13,f7,f6
  nop.i 0
}
  {.mfi
  nop.m 0
  // (p7) calculate remainder (assuming f11=RZ(Q))
  (p7) fnma.s1 f6=f11,f7,f6
  nop.i 0;;
}


  {.mfi
  nop.m 0
  // Final iteration (p8): is f6 the correct remainder (quotient was not overestimated) ?
  (p8) fcmp.lt.unc.s1 p6,p10=f11,f0
  nop.i 0;;
}
  {.mfi
  nop.m 0
  // get new quotient estimation: a'*y2
  (p7) fma.s1 f13=f14,f10,f0
  nop.i 0
}
  {.mfb
  nop.m 0
  // was f14=RZ(Q) ? (then new remainder f14>=0)
  (p7) fcmp.lt.unc.s1 p7,p9=f14,f0
  nop.b 0;;
}


.pred.rel "mutex",p6,p10
  {.mfb
  nop.m 0
  // add b to estimated remainder (to cover the case when the quotient was overestimated) 
  // also set correct sign by using f9=|b|*sgn(a), f12=sgn(a)
  (p6) fma.d.s0 f8=f11,f12,f9
  nop.b 0
}
  {.mfb
  nop.m 0
  // calculate remainder (single precision)
  // set correct sign of result before returning
  (p10) fma.d.s0 f8=f11,f12,f0
  (p8) br.ret.sptk b0;;
}
  {.mfi
  nop.m 0
  // if f13!=RZ(Q), get alternative quotient estimation: a''*y2
  (p7) fma.s1 f13=f6,f10,f0
  nop.i 0
}
  {.mfb
  nop.m 0
  // if f14 was RZ(Q), set remainder to f14
  (p9) mov f6=f14
  br.cond.sptk loop53;;
}



FMOD_X_NAN_INF: 

// Y zero ?
{.mfi 
  nop.m 0
  fma.s1 f10=f9,f1,f0
  nop.i 0;;
}
{.mfi
 nop.m 0
 fcmp.eq.unc.s1 p11,p0=f10,f0
 nop.i 0;;
}
{.mib
  nop.m 0
  nop.i 0
  // if Y zero
  (p11) br.cond.spnt FMOD_Y_ZERO;;                        
}

// X infinity? Return QNAN indefinite
{ .mfi
      nop.m 999
(p0)  fclass.m.unc  p8,p9 = f8, 0x23 
      nop.i 999;; 
}
// Y NaN ?
{.mfi
	 nop.m 999
(p8) fclass.m p9,p8=f9,0xc3
	 nop.i 0;;
}
{.mfi
	  nop.m 999
(p8)  frcpa.s0 f8,p0 = f8,f8           
      nop.i 0
} 
{ .mfi
      nop.m 999
	// also set Denormal flag if necessary
(p8)  fma.s0 f9=f9,f1,f0
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
(p8)  fma.d f8=f8,f1,f0                     
	  nop.b 999 ;;                        
}

{ .mfb
      nop.m 999
(p9)  frcpa.s0 f8,p7=f8,f9                     
      br.ret.sptk   b0 ;;                        
}


FMOD_Y_NAN_INF_ZERO: 

// Y INF
{ .mfi
      nop.m 999
(p0)  fclass.m.unc  p7,p0 = f9, 0x23           
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
(p7)  fma.d f8=f8,f1,f0                     
(p7)  br.ret.spnt    b0 ;;                        
}

// Y NAN?
{ .mfi
      nop.m 999
(p0)  fclass.m.unc  p9,p0 = f9, 0xc3           
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
(p9)  fma.d f8=f9,f1,f0                     
(p9)  br.ret.spnt    b0 ;;                        
}

FMOD_Y_ZERO:
// Y zero? Must be zero at this point
// because it is the only choice left.
// Return QNAN indefinite

{.mfi
  nop.m 0
  // set Invalid
  frcpa f12,p0=f0,f0
  nop.i 0
}
// X NAN?
{ .mfi
      nop.m 999
(p0)  fclass.m.unc  p9,p10 = f8, 0xc3           
      nop.i 999 ;;
}
{ .mfi
      nop.m 999
(p10)  fclass.nm  p9,p10 = f8, 0xff           
      nop.i 999 ;;
}

{.mfi
 nop.m 999
 (p9) frcpa f11,p7=f8,f0
 nop.i 0;;
}

{ .mfi
      nop.m 999
(p10)  frcpa         f11,p7 = f9,f9           
(p0)  mov        GR_Parameter_TAG = 121 ;;                                 
}

{ .mfi
      nop.m 999
(p0)  fmerge.s      f10 = f8, f8             
      nop.i 999
}

{ .mfb
      nop.m 999
(p0)  fma.d f8=f11,f1,f0                     
(p0)  br.sptk __libm_error_region;; 
}

.endp fmod

.proc __libm_error_region
__libm_error_region:
.prologue
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs 
}
{ .mfi
.fframe 64 
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfd [GR_Parameter_Y] = FR_Y,16         // Save Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0                      
        mov GR_SAVE_B0=b0                       // Save b0 
};;
.body
{ .mib
        stfd [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack 
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y  
	nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfd [GR_Parameter_Y] = FR_RESULT      // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y  
        br.call.sptk b0=__libm_error_support#  // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;
{ .mmi
        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp 
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};; 

.endp __libm_error_region


.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\floor.s ===
.file "floor.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
.align 32
.global floor#

.section .text
.proc  floor#
.align 32

// History
//==============================================================
// 2/02/00: Initial version
// 3/22/00: Updated to improve performance 
// 6/13/00: Improved speed, fixed setting of inexact flag
// 6/27/00: Eliminated incorrect invalid flag setting

// API
//==============================================================
// double floor(double x)

// general input registers:  

floor_GR_FFFF      = r14
floor_GR_signexp   = r15
floor_GR_exponent  = r16
floor_GR_expmask   = r17
floor_GR_bigexp    = r18


// predicate registers used: 

// p6  ==> Input is NaN, infinity, zero
// p7  ==> Input is denormal
// p8  ==> Input is <0
// p9  ==> Input is >=0
// p10 ==> Input is already an integer (bigger than largest integer)
// p11 ==> Input is not a large integer
// p12 ==> Input is a smaller integer
// p13 ==> Input is not an even integer, so inexact must be set


// floating-point registers used: 

FLOOR_NORM_f8      = f9                        
FLOOR_FFFF         = f10 
FLOOR_INEXACT      = f11 
FLOOR_FLOAT_INT_f8 = f12
FLOOR_INT_f8       = f13
FLOOR_adj          = f14

// Overview of operation
//==============================================================

// double floor(double x)
// Return an integer value (represented as a double) that is the largest 
// value not greater than x
// This is x rounded toward -infinity to an integral value.
// Inexact is set if x != floor(x)
// **************************************************************************

// Set denormal flag for denormal input and
// and take denormal fault if necessary.

// Is the input an integer value already?

// double_extended
// if the exponent is > 1003e => 3F(true) = 63(decimal)
// we have a significand of 64 bits 1.63-bits.
// If we multiply by 2^63, we no longer have a fractional part
// So input is an integer value already.

// double
// if the exponent is >= 10033 => 34(true) = 52(decimal)
// 34 + 3ff = 433
// we have a significand of 53 bits 1.52-bits. (implicit 1)
// If we multiply by 2^52, we no longer have a fractional part
// So input is an integer value already.

// single
// if the exponent is > 10016 => 17(true) = 23(decimal)
// we have a significand of 24 bits 1.23-bits. (implicit 1)
// If we multiply by 2^23, we no longer have a fractional part
// So input is an integer value already.

// If x is NAN, ZERO, or INFINITY, then  return

// qnan snan inf norm     unorm 0 -+
// 1    1    1   0        0     1 11     0xe7


floor:

{ .mfi
      getf.exp floor_GR_signexp  = f8
      fcvt.fx.trunc.s1     FLOOR_INT_f8  = f8
      addl        floor_GR_bigexp = 0x10033, r0
}
{ .mfi
      addl        floor_GR_FFFF      = -1,r0
      fcmp.lt.s1  p8,p9 = f8,f0
      mov         floor_GR_expmask    = 0x1FFFF ;;
}

// p7 ==> denorm
{ .mfi
      setf.sig    FLOOR_FFFF  = floor_GR_FFFF
      fclass.m    p7,p0 = f8, 0x0b
      nop.i 999
}
{ .mfi
      nop.m 999
      fnorm           FLOOR_NORM_f8  = f8
      nop.i 999 ;;
}

// p6 ==> NAN, INF, ZERO
{ .mfb
      nop.m 999
      fclass.m      p6,p10 = f8, 0xe7
(p7)  br.cond.spnt  FLOOR_DENORM ;;
}

.pred.rel "mutex",p8,p9
FLOOR_COMMON:
// Set adjustment to subtract from trunc(x) for result
//   If x<0,  adjustment is 1.0
//   If x>=0, adjustment is 0.0
{ .mfi
      and      floor_GR_exponent = floor_GR_signexp, floor_GR_expmask
(p8)  fadd.s1  FLOOR_adj = f1,f0
      nop.i 999
}
{ .mfi
      nop.m 999
(p9)  fadd.s1  FLOOR_adj = f0,f0
      nop.i 999 ;;
}

{ .mfi
(p10) cmp.ge.unc    p10,p11 = floor_GR_exponent, floor_GR_bigexp
(p6)  fnorm.d f8 = f8
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p11) fcvt.xf         FLOOR_FLOAT_INT_f8   = FLOOR_INT_f8
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10) fnorm.d f8 = FLOOR_NORM_f8
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p11) fsub.d   f8 = FLOOR_FLOAT_INT_f8,FLOOR_adj
      nop.i 999 ;;
}
{ .mfi
      nop.m 999
(p11) fcmp.eq.unc.s1  p12,p13  = FLOOR_FLOAT_INT_f8, FLOOR_NORM_f8
      nop.i 999 ;;
}

// Set inexact if result not equal to input
{ .mfi
      nop.m 999
(p13) fmpy.s0     FLOOR_INEXACT = FLOOR_FFFF,FLOOR_FFFF
      nop.i 999
}
// Set result to input if integer
{ .mfb
      nop.m 999
(p12) fnorm.d f8 = FLOOR_NORM_f8
      br.ret.sptk    b0 ;;
}

// Here if input denorm
FLOOR_DENORM:
{ .mfb
      getf.exp floor_GR_signexp  = FLOOR_NORM_f8
      fcvt.fx.trunc.s1     FLOOR_INT_f8  = FLOOR_NORM_f8
      br.cond.sptk  FLOOR_COMMON ;;
}

.endp floor
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\huge.s ===
#ifdef _NTSDK
#ifdef CRTDLL
.global _HUGE_dll
#else
.global _HUGE
#endif
#else
.global _HUGE
#endif

	.sdata

#ifdef _NTSDK
#ifdef CRTDLL
_HUGE_dll:
#else
_HUGE:
#endif
#else
_HUGE:
#endif

        data8 0x7ff0000000000000


#include "ksia64.h"

        LEAF_ENTRY(_get_fpsr)

        mov       v0 = ar.fpsr
        br.ret.sptk b0

        LEAF_EXIT(_get_fpsr)

        LEAF_ENTRY(_set_fpsr)

        mov       ar.fpsr = a0
        br.ret.sptk b0

        LEAF_EXIT(_get_fpsr)

        LEAF_ENTRY(_scale)

        ldfe	 f10 = [a0]
        ;;
        getf.exp r30 = f10
        sxt4     a1 = a1
        ;;
        add      r30 = a1, r30
        ;;
        setf.exp f10 = r30
        ;;
        stfe	  [a0] = f10
        br.ret.sptk b0

        LEAF_EXIT(_scale)

        LEAF_ENTRY(_convert_fp80tofp64)

        ldfe	f10 = [a0]
        ;;
        fnorm.d f10 = f10
        ;;
        stfd	[a1] = f10
        br.ret.sptk b0

        LEAF_EXIT(_convert_fp80tofp64)

        LEAF_ENTRY(_convert_fp80tofp32)

        ldfe	f10 = [a0]
        ;;
        fnorm.s f10 = f10
        ;;
        stfs	[a1] = f10
        br.ret.sptk b0

        LEAF_EXIT(_convert_fp80tofp32)

        LEAF_ENTRY(_fclrf)
        
        fclrf.s0
        br.ret.sptk b0

        LEAF_EXIT(_fclrf)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\ieee.c ===
/***
*ieee.c - ieee control and status routines
*
*   Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   IEEE control and status routines.
*
*Revision History:
*
*   04-01-02  GDP   Rewritten to use abstract control and status words
*   06-06-01  GB    Added _DN_FLUSH
*
*/

#ifndef _IA64_
#define _IA64_
#endif

#include <trans.h>
#include <float.h>
#include <nt.h>
#include <signal.h>

extern unsigned __int64 _get_fpsr(void);
extern void _set_fpsr(unsigned __int64);
extern void _fclrf(void);

static unsigned int _abstract_sw(unsigned __int64 sw);
static unsigned int _abstract_cw(unsigned __int64 cw);
static unsigned __int64 _hw_cw(unsigned int abstr);

#define FS          (1<<6)
#define CWMASK      0x00001f7f
#define FTZ         0x00000040

/***
* _statusfp() -
*
*Purpose:
*	return abstract fp status word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _statusfp()
{
    unsigned __int64 status;

    status = _get_fpsr();

    return _abstract_sw(status);
}


/***
*_clearfp() -
*
*Purpose:
*	return abstract	status word and clear status
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _clearfp()
{
    unsigned __int64 status;

    status = _get_fpsr();
    _fclrf();

    return _abstract_sw(status);
}



/***	_control87
*() -
*
*Purpose:
*	return and set abstract user fp control word
*	can modify EM_DENORMAL mask
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _control87(unsigned int newctrl, unsigned int mask)
{
    unsigned __int64 oldCw;
    unsigned __int64 newCw;
    unsigned int oldabs;
    unsigned int newabs;

    oldCw = _get_fpsr();

    oldabs = _abstract_cw(oldCw);

    newabs = (newctrl & mask) | (oldabs & ~mask);

    newCw = _hw_cw(newabs) | (oldCw & ~(unsigned __int64)CWMASK);

    _set_fpsr(newCw);

    return newabs;
}					/* _control87() */


/***	_controlfp
*() -
*
*Purpose:
*	return and set abstract user fp control word
*	cannot change denormal mask (ignores _EM_DENORMAL)
*	This is done for portable IEEE behavior on all platforms
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _controlfp(unsigned int newctrl, unsigned int mask)
{
    return _control87(newctrl, mask & ~_EM_DENORMAL);
}


/***
* _abstract_cw() - abstract control word
*
*Purpose:
*   produce a fp control word in abstracted (machine independent) form
*
*Entry:
*   cw:     machine control word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _abstract_cw(unsigned __int64 cw)
{
    unsigned int abstr = 0;


    //
    // Set exception mask bits
    //

    if (cw & IEM_INVALID)
	abstr |= _EM_INVALID;
    if (cw & IEM_ZERODIVIDE)
	abstr |= _EM_ZERODIVIDE;
    if (cw & IEM_OVERFLOW)
	abstr |= _EM_OVERFLOW;
    if (cw & IEM_UNDERFLOW)
	abstr |= _EM_UNDERFLOW;
    if (cw & IEM_INEXACT)
	abstr |= _EM_INEXACT;
    if (cw & IEM_DENORMAL)
	abstr |= _EM_DENORMAL;

    //
    // Set rounding mode
    //

    switch (cw & IMCW_RC) {
    case IRC_NEAR:
	abstr |= _RC_NEAR;
	break;
    case IRC_UP:
	abstr |= _RC_UP;
	break;
    case IRC_DOWN:
	abstr |= _RC_DOWN;
	break;
    case IRC_CHOP:
	abstr |= _RC_CHOP;
	break;
    }

    // Flush to zero mode
    if (cw & FTZ) {
        abstr |= _DN_FLUSH;
    }

    //
    // Set Precision mode
    //

    switch (cw & IMCW_PC) {
    case IPC_64:
	abstr |= _PC_64;
	break;
    case IPC_53:
	abstr |= _PC_53;
	break;
    case IPC_24:
	abstr |= _PC_24;
	break;
    }

    return abstr;
}


/***
* _hw_cw() -  h/w control word
*
*Purpose:
*   produce a machine dependent fp control word
*
*
*Entry:
*   abstr:	abstract control word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned __int64 _hw_cw(unsigned int abstr)
{
    //
    // Set standard infinity and denormal control bits
    //

    unsigned __int64 cw = 0;

    //
    // Set exception mask bits
    //

    if (abstr & _EM_INVALID)
	cw |= IEM_INVALID;
    if (abstr & _EM_ZERODIVIDE)
	cw |= IEM_ZERODIVIDE;
    if (abstr & _EM_OVERFLOW)
	cw |= IEM_OVERFLOW;
    if (abstr & _EM_UNDERFLOW)
	cw |= IEM_UNDERFLOW;
    if (abstr & _EM_INEXACT)
	cw |= IEM_INEXACT;
    if (abstr & _EM_DENORMAL)
	cw |= IEM_DENORMAL;

    //
    // Set rounding mode
    //

    switch (abstr & _MCW_RC) {
    case _RC_NEAR:
	cw |= IRC_NEAR;
	break;
    case _RC_UP:
	cw |= IRC_UP;
	break;
    case _RC_DOWN:
	cw |= IRC_DOWN;
	break;
    case _RC_CHOP:
	cw |= IRC_CHOP;
	break;
    }

    // Flush to zero mode
    if (abstr & _DN_FLUSH) {
        cw |= FTZ;
    }

    //
    // Set Precision mode
    //

    switch (abstr & _MCW_PC) {
    case _PC_64:
	cw |= IPC_64;
	break;
    case _PC_53:
	cw |= IPC_53;
	break;
    case _PC_24:
	cw |= IPC_24;
	break;
    }

    return cw;
}



/***
* _abstract_sw() - abstract fp status word
*
*Purpose:
*   produce an abstract (machine independent) fp status word
*
*
*Entry:
*   sw:     machine status word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _abstract_sw(unsigned __int64 sw)
{
    unsigned int abstr = 0;


    if (sw & ISW_INVALID)
	abstr |= _SW_INVALID;
    if (sw & ISW_ZERODIVIDE)
	abstr |= _SW_ZERODIVIDE;
    if (sw & ISW_OVERFLOW)
	abstr |= _SW_OVERFLOW;
    if (sw & ISW_UNDERFLOW)
	abstr |= _SW_UNDERFLOW;
    if (sw & ISW_INEXACT)
	abstr |= _SW_INEXACT;
    if (sw & ISW_DENORMAL)
	abstr |= _SW_DENORMAL;

    return abstr;
}

/***
* _fpreset() - reset fp system
*
*Purpose:
*	reset fp environment to the default state
*	Also reset saved fp environment if invoked from a user's
*	signal handler
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
void _fpreset()
{
    unsigned __int64 status = ICW | 0x9004802700002; /* fpsr.sf1.pc=3, wre=1, traps.dd=1 */ 
    PEXCEPTION_POINTERS excptrs = (PEXCEPTION_POINTERS) _pxcptinfoptrs;

    //
    // reset fp state
    //

    _set_fpsr(status);

    if (excptrs &&
        excptrs->ContextRecord->ContextFlags & CONTEXT_FLOATING_POINT) {
        // _fpreset has been invoked by a signal handler which in turn
        // has been invoked by the CRT filter routine. In this case
        // the saved fp context should be cleared, so that the change take
        // effect on continuation.

        excptrs->ContextRecord->StFPSR = ICW;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\ldexpf.s ===
.file "ldexpf.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version
// 4/04/00  Unwind support added
// 5/22/00  rewritten to not take swa and be a little faster
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
//12/07/00  Removed code that prevented call to __libm_error_support.
//          Stored r33 instead of f9 as Parameter 2 for call to 
//          __libm_error_support.
//
// API
//==============================================================
// float = ldexpf (float x, int n) 
// input  floating point f8 and integer r33
// output floating point f8
//
// returns x* 2**n  computed by exponent  
// manipulation rather than by actually performing an 
// exponentiation or a multiplication.
//
// Overview of operation
//==============================================================
// ldexpf:
//     p7 is set if x is nan, inf, zero; go to x_nan_inf_zero
//     sign extend r33
//     norm_f8 = fnorm(f8)
//     get exponent of norm_f8
//     add to r33 to get new exponent
//     p6, new_exponent > 103fe => overflow
//     p7, new_exponent > fbcd  => underflow
//     setf new_exponent, merge significand, normalize, return


ldexp_float_int_f9 = f10 
ldexp_int_f9       = f11
ldexp_max_exp      = f12
ldexp_neg_max_exp  = f13
ldexp_new_f9       = f14 

LDEXP_BIG          = f32
LDEXP_NORM_F8      = f33
LDEXP_FFFF         = f34
LDEXP_BIG_SIGN     = f35
LDEXP_13FFE        = f36 
LDEXP_INV_BIG_SIGN = f37 


// general registers used
// r32 has ar.pfs
// r33 has input integer

ldexp_GR_signexp                = r34
ldexp_GR_13FFE                  = r35
ldexp_GR_new_exponent           = r36
ldexp_GE_FBCD                   = r37
ldexp_GR_17ones                 = r38

GR_SAVE_B0                      = r39
GR_SAVE_GP                      = r40
GR_SAVE_PFS                     = r41

ldexp_GR_exponent               = r42
ldexp_GR_103FE                  = r43 
ldexp_GR_FFFF                   = r44

GR_Parameter_X                  = r45
GR_Parameter_Y                  = r46
GR_Parameter_RESULT             = r47
ldexp_GR_tag                    = r48

.global ldexpf

// ===============================================================
// LDEXPF
// ===============================================================

.text
.proc  ldexpf
.align 32

// Be sure to sign extend r33 because the
// integer comes in as 32-bits

ldexpf: 

// x NAN, INF, ZERO, +-

{ .mfi
      alloc          r32=ar.pfs,1,12,4,0        
      fclass.m.unc   p7,p0 = f8, 0xe7	//@qnan | @snan | @inf | @zero
      sxt4           r33 = r33 
}
;;

{ .mfi
      nop.m 999
      fnorm          LDEXP_NORM_F8 = f8        
      nop.i 999
}

{ .mbb
      nop.m 999
(p7)  br.cond.spnt  LDEXP_X_NAN_INF_ZERO 
      nop.b 999
}
;;



// LDEXP_BIG gets a big number, enough to overflow an frcpa
// but not take an architecturally mandated swa.
// We construct this constant rather than load it.

{ .mlx
       mov           ldexp_GR_17ones = 0x1FFFF   
       movl          ldexp_GR_FFFF = 0xffffffffffffffff 
}
{ .mfi
       addl          ldexp_GR_13FFE =  0x13ffe, r0          
       nop.f 999
       nop.i 999 
}
;;

{ .mmb
       setf.exp      LDEXP_13FFE = ldexp_GR_13FFE                   
       setf.sig      LDEXP_FFFF  = ldexp_GR_FFFF                   
       nop.b 999 
}
;;


{ .mfi
	nop.m 999
       fmerge.se     LDEXP_BIG   = LDEXP_13FFE, LDEXP_FFFF       
	nop.i 999
}

// Put the absolute normalized exponent in ldexp_GR_new_exponent
// Assuming that the input int is in r33.
// ldexp_GR_new_exponent gets the input int + the exponent of the input double

{ .mfi
       getf.exp      ldexp_GR_signexp  = LDEXP_NORM_F8                     
       nop.f 999
       nop.i 999 
}
;;

{ .mii
       nop.m 999
       nop.i 999 
       and           ldexp_GR_exponent = ldexp_GR_signexp, ldexp_GR_17ones 
}
;;

// HUGE
// Put big number in ldexp_GR_103FE
// If ldexp_GR_new_exponent is bigger than ldexp_GR_103FE
//    Return a big number of the same sign 
//    double: largest double exponent is 7fe (double-biased)
//                                     103fe (register-biased)
//    f11 gets the big value in f9 with the f8 sign
//    For single,
//    single: largest single exponent is fe (single-biased)
//                            fe - 7f + ffff = 1007e

{ .mii
       add           ldexp_GR_new_exponent = ldexp_GR_exponent, r33                          
       addl          ldexp_GR_103FE        = 0x1007e, r0 
       nop.i 999
}
;;

{ .mfi
       setf.exp       f12 = ldexp_GR_new_exponent                   
       nop.f 999
       cmp.gt.unc    p6,p0                 = ldexp_GR_new_exponent, ldexp_GR_103FE 
}
;;

{ .mfb
       nop.m 999
(p6)   fmerge.s      LDEXP_BIG_SIGN        = f8,  LDEXP_BIG         
       nop.b 999 
}
;;

{ .mfi
       nop.m 999
(p6)   fma.s         f12                   = LDEXP_BIG_SIGN, LDEXP_BIG, f0            
(p6)   mov           ldexp_GR_tag          = 148                    
}

{ .mib
       nop.m 999
       nop.i 999
(p6)   br.spnt LDEXP_HUGE 
}
;;

// TINY
// Put a small number in ldexp_GE_FBCD
// If ldexp_GR_new_exponent is less than ldexp_GE_FBCD
//    Return a small number of the same sign 
// double:
//    0xfbcd is -1074 unbiased, which is the exponent
//    of the smallest double denormal
// single
//   0xff6a is -149  unbiased which is the exponent
//   of the smallest single denormal
//
//    Take the large value in f9 and put in f10 with
//    the sign of f8. Then take reciprocal in f11

{ .mfi
       addl       ldexp_GE_FBCD = 0xff6a, r0            
       nop.f 999 
       nop.i 999
}
;;

{ .mfi
       nop.m 999
       nop.f 999
       cmp.lt.unc    p7,p0 = ldexp_GR_new_exponent, ldexp_GE_FBCD 
}
;;

{ .mfi
       nop.m 999
(p7)   fmerge.s   LDEXP_BIG_SIGN = f8, LDEXP_BIG         
       nop.i 999
}
;;

{ .mfi
       nop.m 999
(p7)   frcpa.s1   LDEXP_INV_BIG_SIGN,p10 = f1,LDEXP_BIG_SIGN             
       nop.i 999 
}
;;

{ .mfi
       nop.m 999
(p7)   fnorm.s    f12 = LDEXP_INV_BIG_SIGN                    
(p7)   mov        ldexp_GR_tag = 149                    
}
{ .mib
       nop.m 999
       nop.i 999
(p7)   br.spnt LDEXP_TINY 
}
;;

// CALCULATION
// Put exponent of answer in f12
// f10 has the normalized f8
//    f13 = exp(f12) sig(f10)
//    f14 = sign(f8) expsig(f13)


{ .mfi
      nop.m 999
      fmerge.se      f13 = f12,LDEXP_NORM_F8               
      nop.i 999 
}
;;

{ .mfi
      nop.m 999
      fmerge.s       f14 = f8,f13                
      nop.i 999 
}
;;

{ .mfb
      nop.m 999
      fnorm.s        f8  = f14                   
      br.ret.sptk    b0 
}
;;


LDEXP_N_NAN_INF:

// Is n a NAN?
{ .mfi
      nop.m 999
(p0)  fclass.m.unc  p6,p0 = f9, 0xc3	//@snan | @qnan
      nop.i 999 
}
;;

{ .mfi
      nop.m 999
(p6)  fma.s         f8    = f8,f9,f0
      nop.i 999
}

// Is n +INF?
{ .mfi
      nop.m 999
(p0)  fclass.m.unc  p7,p0 = f9, 0x21	//@inf | @pos 
      nop.i 999 
}
;;

{ .mfi
      nop.m 999
(p7)  fma.s f8 = f8,f9,f0
      nop.i 999
}

// Is n -inf?
{ .mfi
      nop.m 999
      fclass.m.unc  p8,p9 = f9, 0x22	//@inf | @neg
      nop.i 999
}
;;

{ .mfb
      nop.m 999
(p8)  frcpa f8,p6 = f8,f9
      br.ret.sptk     b0 
}
;;


LDEXP_X_NAN_INF_ZERO:

{ .mfb
      nop.m 999
      fnorm.s         f8 = f8                     // quietize
      br.ret.sptk     b0 
}
;;

.endp ldexpf 

.proc __libm_error_region
__libm_error_region:
LDEXP_HUGE: 
LDEXP_TINY: 
.prologue
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                          // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                      // Save gp
};;

{ .mmi
        st8 [GR_Parameter_Y] = r33,16         // STORE Parameter 2 on stack
        add GR_Parameter_X = 16,sp            // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                     // Save b0
};;

.body
{ .mib
        stfs [GR_Parameter_X] = f8                      // STORE Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y    // Parameter 3 address
        nop.b 0                                
}
{ .mib
        stfs [GR_Parameter_Y] = f12                     // STORE Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y       
        br.call.sptk b0=__libm_error_support#           // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region


.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\isnan.s ===
.file "isnan.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version

.align 32
.global _isnan#

.section .text
.proc  _isnan#
.align 32

// API
//==============================================================
// int _isnan  (double x)

// Overview of operation
//==============================================================
// returns 1 if x is a nan; 0 otherwise 
// takes no exceptions

// Registers used
//==============================================================

// general registers used:     
// r8 for return value

// floating-point registers used: 
// f8

// predicate registers used
// p6, p7

// qnan snan inf norm     unorm 0 -+
// 1    1    0   0        0     0 11

_isnan: 
{ .mfi
      nop.m 999
      fclass.m.unc   p6,p7 = f8,0xc3           
      nop.i 999 ;;
}

{ .mib
(p6)  addl           r8 = 0x1,r0               
(p7)  addl           r8 = 0x0,r0               
      br.ret.sptk    b0 ;;                        
}

.endp _isnan
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\ldexp.s ===
.file "ldexp.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version
// 4/04/00  Unwind support added
// 5/22/00  rewritten to not take swa and be a little faster
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
//12/07/00  Removed code that prevented call to __libm_error_support.
//          Stored r33 instead of f9 as Parameter 2 for call to 
//          __libm_error_support.
//
// API
//==============================================================
// double = ldexp  (double x, int n) 
// input  floating point f8 and integer r33
// output floating point f8
//
// returns x* 2**n  computed by exponent  
// manipulation rather than by actually performing an 
// exponentiation or a multiplication.
//
// Overview of operation
//==============================================================
//
// ldexp:
//     p7 is set if x is nan, inf, zero; go to x_nan_inf_zero
//     sign extend r33
//     norm_f8 = fnorm(f8)
//     get exponent of norm_f8
//     add to r33 to get new exponent
//     p6, new_exponent > 103fe => overflow
//     p7, new_exponent > fbcd  => underflow
//     setf new_exponent, merge significand, normalize, return


ldexp_float_int_f9 = f10 
ldexp_int_f9       = f11
ldexp_max_exp      = f12
ldexp_neg_max_exp  = f13
ldexp_new_f9       = f14 

LDEXP_BIG          = f32
LDEXP_NORM_F8      = f33
LDEXP_FFFF         = f34
LDEXP_BIG_SIGN     = f35
LDEXP_13FFE        = f36 
LDEXP_INV_BIG_SIGN = f37 


// general registers used
// r32 has ar.pfs
// r33 has input integer

ldexp_GR_signexp                = r34
ldexp_GR_13FFE                  = r35
ldexp_GR_new_exponent           = r36
ldexp_GE_FBCD                   = r37
ldexp_GR_17ones                 = r38

GR_SAVE_B0                      = r39
GR_SAVE_GP                      = r40
GR_SAVE_PFS                     = r41

ldexp_GR_exponent               = r42
ldexp_GR_103FE                  = r43 
ldexp_GR_FFFF                   = r44

GR_Parameter_X                  = r45
GR_Parameter_Y                  = r46
GR_Parameter_RESULT             = r47
ldexp_GR_tag                    = r48

.global ldexp

// ===============================================================
// LDEXP
// ===============================================================

.text
.proc  ldexp
.align 32

// Be sure to sign extend r33 because the
// integer comes in as 32-bits

ldexp: 


// x NAN, INF, ZERO, +-

{ .mfi
      alloc          r32=ar.pfs,1,12,4,0        
      fclass.m.unc   p7,p0 = f8, 0xe7	//@qnan | @snan | @inf | @zero
      sxt4           r33 = r33 
}
;;

{ .mfi
      nop.m 999
      fnorm          LDEXP_NORM_F8 = f8        
      nop.i 999
}

{ .mbb
      nop.m 999
(p7)  br.cond.spnt  LDEXP_X_NAN_INF_ZERO 
      nop.b 999
}
;;


// LDEXP_BIG gets a big number, enough to overflow an frcpa
// but not take an architecturally mandated swa.
// We construct this constant rather than load it.

{ .mlx
       mov           ldexp_GR_17ones = 0x1FFFF   
       movl          ldexp_GR_FFFF = 0xffffffffffffffff 
}
{ .mfi
       addl          ldexp_GR_13FFE =  0x13ffe, r0          
       nop.f 999
       nop.i 999 
}
;;

{ .mmb
       setf.exp      LDEXP_13FFE = ldexp_GR_13FFE                   
       setf.sig      LDEXP_FFFF  = ldexp_GR_FFFF                   
       nop.b 999 
}
;;


{ .mfi
	nop.m 999
       fmerge.se     LDEXP_BIG   = LDEXP_13FFE, LDEXP_FFFF       
	nop.i 999
}

// Put the absolute normalized exponent in ldexp_GR_new_exponent
// Assuming that the input int is in r33.
// ldexp_GR_new_exponent gets the input int + the exponent of the input double

{ .mfi
       getf.exp      ldexp_GR_signexp  = LDEXP_NORM_F8                     
       nop.f 999
       nop.i 999 
}
;;

{ .mii
       nop.m 999
       nop.i 999 
       and           ldexp_GR_exponent = ldexp_GR_signexp, ldexp_GR_17ones 
}
;;

// HUGE
// Put big number in ldexp_GR_103FE
// If ldexp_GR_new_exponent is bigger than ldexp_GR_103FE
//    Return a big number of the same sign 
//    double: largest double exponent is 7fe (double-biased)
//                                     103fe (register-biased)
//    f11 gets the big value in f9 with the f8 sign
//    For single,
//    single: largest single exponent is fe (single-biased)
//                            fe - 7f + ffff = 1007e

{ .mii
       add           ldexp_GR_new_exponent = ldexp_GR_exponent, r33                          
       addl          ldexp_GR_103FE        = 0x103fe, r0 
       nop.i 999
}
;;

{ .mfi
       setf.exp       f12 = ldexp_GR_new_exponent                   
       nop.f 999
       cmp.gt.unc    p6,p0 = ldexp_GR_new_exponent, ldexp_GR_103FE 
}
;;

{ .mfb
       nop.m 999
(p6)   fmerge.s      LDEXP_BIG_SIGN        = f8,  LDEXP_BIG         
       nop.b 999 
}
;;

{ .mfi
       nop.m 999
(p6)   fma.d         f12                   = LDEXP_BIG_SIGN, LDEXP_BIG, f0            
(p6)   mov           ldexp_GR_tag          = 146                    
}

{ .mib
       nop.m 999
       nop.i 999
(p6)   br.spnt LDEXP_HUGE 
}
;;

// TINY
// Put a small number in ldexp_GE_FBCD
// If ldexp_GR_new_exponent is less than ldexp_GE_FBCD
//    Return a small number of the same sign 
// double:
//    0xfbcd is -1074 unbiased, which is the exponent
//    of the smallest double denormal
// single
//   0xff6a is -149  unbiased which is the exponent
//   of the smallest single denormal
//
//    Take the large value in f9 and put in f10 with
//    the sign of f8. Then take reciprocal in f11

{ .mfi
       addl       ldexp_GE_FBCD = 0xfbcd, r0            
       nop.f 999 
       nop.i 999
}
;;

{ .mfi
       nop.m 999
       nop.f 999
       cmp.lt.unc    p7,p0 = ldexp_GR_new_exponent, ldexp_GE_FBCD 
}
;;

{ .mfi
       nop.m 999
(p7)   fmerge.s   LDEXP_BIG_SIGN = f8, LDEXP_BIG         
       nop.i 999
}
;;

{ .mfi
       nop.m 999
(p7)   frcpa.s1   LDEXP_INV_BIG_SIGN,p10 = f1,LDEXP_BIG_SIGN             
       nop.i 999 
}
;;

{ .mfi
       nop.m 999
(p7)   fnorm.d    f12 = LDEXP_INV_BIG_SIGN                    
(p7)   mov        ldexp_GR_tag = 147                    
}
{ .mib
       nop.m 999
       nop.i 999
(p7)   br.spnt LDEXP_TINY 
}
;;

// CALCULATION
// Put exponent of answer in f12
// f10 has the normalized f8
//    f13 = exp(f12) sig(f10)
//    f14 = sign(f8) expsig(f13)


{ .mfi
      nop.m 999
      fmerge.se      f13 = f12,LDEXP_NORM_F8               
      nop.i 999 
}
;;

{ .mfi
      nop.m 999
      fmerge.s       f14 = f8,f13                
      nop.i 999 
}
;;

{ .mfb
      nop.m 999
      fnorm.d        f8  = f14                   
      br.ret.sptk    b0 
}
;;


LDEXP_N_NAN_INF:

// Is n a NAN?
{ .mfi
      nop.m 999
(p0)  fclass.m.unc  p6,p0 = f9, 0xc3	//@snan | @qnan
      nop.i 999 
}
;;

{ .mfi
      nop.m 999
(p6)  fma.d         f8    = f8,f9,f0
      nop.i 999
}

// Is n +INF?
{ .mfi
      nop.m 999
(p0)  fclass.m.unc  p7,p0 = f9, 0x21	//@inf | @pos 
      nop.i 999 
}
;;

{ .mfi
      nop.m 999
(p7)  fma.d f8 = f8,f9,f0
      nop.i 999
}

// Is n -inf?
{ .mfi
      nop.m 999
      fclass.m.unc  p8,p9 = f9, 0x22	//@inf | @neg
      nop.i 999
}
;;

{ .mfb
      nop.m 999
(p8)  frcpa f8,p6 = f8,f9
      br.ret.sptk     b0 
}
;;


LDEXP_X_NAN_INF_ZERO:

{ .mfb
      nop.m 999
      fnorm.d         f8 = f8                     // quietize
      br.ret.sptk     b0 
}
;;

.endp ldexp 

.proc __libm_error_region
__libm_error_region:
LDEXP_HUGE: 
LDEXP_TINY: 
.prologue
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                          // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                      // Save gp
};;

{ .mmi
        st8 [GR_Parameter_Y] = r33,16         // STORE Parameter 2 on stack
        add GR_Parameter_X = 16,sp            // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                     // Save b0
};;

.body
{ .mib
        stfd [GR_Parameter_X] = f8                      // STORE Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y    // Parameter 3 address
        nop.b 0                                
}
{ .mib
        stfd [GR_Parameter_Y] = f12                     // STORE Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y       
        br.call.sptk b0=__libm_error_support#           // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

{ .mmi
        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region


.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\hypot.s ===
.file "hypot.asm"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Cristina Iordache, Ted Kubaska, 
// Bob Norin, Shane Story, and Ping Tak Peter Tang of the 
// Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
//*********************************************************************
//
// History: 
// 2/02/00  hand-optimized
// 4/04/00  Unwind support added
// 6/20/00  new version
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
//
//*********************************************************************
//                           ___________
// Function:   hypot(x,y) = |(x^2 + y^2) = for double precision values
//             x and y
//             Also provides cabs functionality.
//
//*********************************************************************
//
// Resources Used:
//
//    Floating-Point Registers: f8  (Input and Return Value)
//                              f9  (Input)
//                              f6 -f15, f32-f34
//
//    General Purpose Registers:
//      r2,r3,r29 (Scratch)
//      r32-r36 (Locals)
//      r37-r40 (Used to pass arguments to error handling routine)
//
//    Predicate Registers:      p6 - p10
//
//*********************************************************************
//
// IEEE Special Conditions:
//
//    All faults and exceptions should be raised correctly.
//    Overflow can occur.
//    hypot(Infinity and anything) = +Infinity
//    hypot(QNaN and anything) = QNaN
//    hypot(SNaN and anything ) = QNaN
//
//*********************************************************************
//
// Implementation:
//  x2 = x * x   in double-extended
//  y2 = y * y   in double-extended
//  temp = x2 + y2   in double-extended
//  sqrt(temp) rounded to double 
//
//*********************************************************************

GR_SAVE_PFS         = r33
GR_SAVE_B0          = r34
GR_SAVE_GP          = r35
GR_Parameter_X      = r36
GR_Parameter_Y      = r37
GR_Parameter_RESULT = r38
GR_Parameter_TAG    = r39

FR_X                = f32
FR_Y                = f33
FR_RESULT           = f8

.section .text
.proc _cabs#
.global _cabs#
_cabs: 
.endp _cabs
.proc _hypot#
.global _hypot#
.align 64 

_hypot: 
{.mfi
  alloc r32= ar.pfs,0,4,4,0
  // Compute x*x
  fma.s1 f10=f8,f8,f0
  // r2=bias-1
  mov r2=0xfffe 
}
{.mfi
  // 63/8
  mov r3=0x40fc //0000
  // y*y
  fma.s1 f11=f9,f9,f0
  // r29=429/16
  mov r29=0x41d68;; //000
}

{ .mfi
     nop.m 0
//   Check if x is an Inf - if so return Inf even
//   if y is a NaN (C9X)
     fclass.m.unc p7, p6 = f8, 0x023
     shl r3=r3,16
}
{.mfi
	nop.m 0
  // if possible overflow, copy f8 to f32
  // set Denormal, if necessary 
  // (p8) 
  fma.d.s0 f32=f8,f1,f0
  nop.i 0;;
}
{ .mfi
     nop.m 0
//   Check if y is an Inf - if so return Inf even
//   if x is a NaN (C9X)
     fclass.m.unc p8, p9 = f9, 0x023
     shl r29=r29,12
}
{ .mfb
	 // f7=0.5
	 setf.exp f7=r2
//   For x=inf, multiply y by 1 to raise invalid on y an SNaN
//   (p7) fma.s0 f9=f9,f1,f0
     // copy f9 to f33; set Denormal, if necessary
	 fma.d.s0 f33=f9,f1,f0
     nop.b 0;;
}
{.mfb
  // f13=63/8
  setf.s f13=r3
  // is y Zero ?
  (p6) fclass.m p6,p0=f9,0x7
  nop.b 0
}
{.mlx
  nop.m 0
  movl r2=0x408c0000;;
}

{.mfi
  // f34=429/16
  setf.s f34=r29
  // is x Zero ?
  (p9) fclass.m p9,p0=f8,0x7
  // 231/16
  mov r3=0x4167;; //0000
}
{.mfi
  nop.m 0
  // a=x2+y2
  fma.s1 f12=f10,f1,f11
  nop.i 0;;
}
{.mfi
  nop.m 0
  // y not NaN ?
  (p9) fclass.m p8,p0=f9,0x3f
  shl r3=r3,16
}
{.mfi
  nop.m 0
  // f6=2
  fma.s1 f6=f1,f1,f1
  nop.i 0;;
}


{.mfi
  nop.m 0
  // x not NaN ?
  (p6) fclass.m p7,p0=f8,0x3f
  nop.i 0;;
}
{.mfi
  // f9=35/8
  setf.s f9=r2
  nop.f 0
  // 2*emax-2
  mov r2=0x107fb;;
}

{.mfb
  nop.m 0
  // if f8=Infinity or f9=Zero, return |f8|
  (p7) fmerge.s f8=f0,f32
  (p7) br.ret.spnt b0
}
{.mfb
  nop.m 0
  // if f9=Infinity or f8=Zero, return |f9|
  (p8) fmerge.s f8=f0,f33
  (p8) br.ret.spnt b0;;
}


{.mfi
  // f10 =231/16
  setf.s f10=r3
  // z0=frsqrta(a)
  frsqrta.s1 f8,p6=f12
  nop.i 0;;
}

{ .mfi
	 nop.m 0
//   Identify Natvals, Infs, NaNs, and Zeros 
//   and return result
     fclass.m.unc p7, p0 = f12, 0x1E7
     nop.i 0;;
} 
{.mfb
  // get exponent of x^2+y^2
  getf.exp r3=f12
  // if special case, set f8
  (p7) mov f8=f12
  (p7) br.ret.spnt b0;;
}


{.mfi
  nop.m 0
  // S0=a*z0
  (p6) fma.s1 f14=f12,f8,f0
  nop.i 0
}
{.mfi
  nop.m 0
  // H0=0.5*z0
  (p6) fma.s1 f15=f8,f7,f0
  nop.i 0;;
} 


{.mfi
  nop.m 0
  // f6=5/2
  fma.s1 f6=f7,f1,f6
  nop.i 0
}
{.mfi
  nop.m 0
  // f11=3/2
  fma.s1 f11=f7,f1,f1
  nop.i 0;;
}

{.mfi
  nop.m 0
  // d=0.5-S0*H0
  (p6) fnma.s1 f7=f14,f15,f7
  nop.i 0;;
}

{.mfi
  nop.m 0
  // P67=231/16+429/16*d
  (p6) fma.s1 f10=f34,f7,f10
  nop.i 0
}
{.mfi
  nop.m 0
  // P45=63/8*d+35/8
  (p6) fma.s1 f9=f13,f7,f9
  nop.i 0;;
}
{.mfi
  nop.m 0
  // P23=5/2*d+3/2
  (p6) fma.s1 f11=f6,f7,f11
  nop.i 0
}
{.mfi
  nop.m 0
  // d2=d*d
  (p6) fma.s1 f13=f7,f7,f0
  nop.i 0;;
}

{.mfi
  nop.m 0
  // P47=d2*P67+P45
  (p6) fma.s1 f10=f10,f13,f9
  nop.i 0
}
{.mfi
  nop.m 0
  // P13=d*P23+1
  (p6) fma.s1 f11=f11,f7,f1
  nop.i 0;;
}
{.mfi
  nop.m 0
  // d3=d2*d
  (p6) fma.s1 f13=f13,f7,f0
  nop.i 0;;
}

{.mfi
  nop.m 0
  // T0=d*S0
  (p6) fma.s1 f15=f7,f14,f0
  nop.i 0
}
{.mfi
  // Is x^2 + y^2 well less than the overflow 
  // threshold?
  (p6) cmp.lt.unc p7, p8 =  r3,r2
  // P=P13+d3*P47
  (p6) fma.s1 f10=f13,f10,f11
  nop.i 0;;
}

{.mfb
  nop.m 0
  // S=P*T0+S0
  fma.d.s0 f8=f10,f15,f14
  // No overflow in this case
  (p7) br.ret.sptk b0;;
}

{ .mfi
     nop.m 0  
(p8) fsetc.s2 0x7F,0x42 
     // Possible overflow path, must detect by
     // Setting widest range exponent with prevailing
     // rounding mode.
     nop.i 0 ;;
}


{ .mfi
   // bias+0x400 (bias+EMAX+1)
   (p8) mov r2=0x103ff
   // S=P*T0+S0
   (p8) fma.d.s2 f12=f10,f15,f14
   nop.i 0 ;;
}
{ .mfi
(p8) setf.exp f11 = r2
(p8) fsetc.s2 0x7F,0x40
//   Restore Original Mode in S2
     nop.i 0 ;;
}
{ .mfi
     nop.m 0 
(p8) fcmp.lt.unc.s1 p9, p10 =  f12, f11
     nop.i 0 ;;
}
{ .mib
     nop.m 0
     mov GR_Parameter_TAG = 46
	 // No overflow
(p9) br.ret.sptk b0;; 
}
.endp

.proc __libm_error_region
__libm_error_region:
.prologue
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfd [GR_Parameter_Y] = FR_Y,16         // Save Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
};;
.body
{ .mib
        stfd [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
        nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfd [GR_Parameter_Y] = FR_RESULT      // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#  // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;
{ .mmi
        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;
.endp 
.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\isnanf.s ===
.file "isnanf.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version


.align 32
.global _isnanf#

.section .text
.proc  _isnanf#
.align 32

// API
//==============================================================
// int _isnanf  (float x)

// Overview of operation
//==============================================================
// returns 1 if x is a nan; 0 otherwise
// does check for special input; takes no exceptions

// Registers used
//==============================================================

// general registers used:        1
// r8 for return value

// floating-point registers used: 1
// f8

// qnan snan inf norm     unorm 0 -+
// 1    1    0   0        0     0 11

_isnanf: 
{ .mfi
      nop.m 999
      fclass.m.unc   p6,p7 = f8,0xc3           
      nop.i 999 ;;
}
{ .mib
(p6)  addl           r8 = 0x1,r0               
(p7)  addl           r8 = 0x0,r0               
(p0)  br.ret.sptk    b0 ;;                        
}

.endp _isnanf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\hypotf.s ===
.file "hypotf.asm"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Cristina Iordache, Ted Kubaska, 
// Bob Norin, Shane Story, and Ping Tak Peter Tang of the 
// Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
//*********************************************************************
//
// History: 
// 2/02/00  hand-optimized
// 4/04/00  Unwind support added
// 6/26/00  new version
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
//
//*********************************************************************
//                           ___________
// Function:   hypotf(x,y) = |(x^2 + y^2) = for single precision values
//             x and y
//             Also provides cabsf functionality.
//
//*********************************************************************
//
// Resources Used:
//
//    Floating-Point Registers: f8  (Input and Return Value)
//                              f9  (Input)
//                              f6 -f15
//
//    General Purpose Registers:
//      r2-r3   (Scratch)
//      r32-r36 (Locals)
//      r37-r40 (Used to pass arguments to error handling routine)
//
//    Predicate Registers:      p6 - p10
//
//*********************************************************************
//
// IEEE Special Conditions:
//
//    All faults and exceptions should be raised correctly.
//    Overflow can occur.
//    hypotf(Infinity and anything) = +Infinity
//    hypotf(QNaN and anything) = QNaN
//    hypotf(SNaN and anything ) = QNaN
//
//*********************************************************************
//
// Implementation:
//  x2 = x * x   in double-extended
//  y2 = y * y   in double-extended
//  temp = x2 + y2   in double-extended
//  sqrt(temp) rounded to single precision 
//
//*********************************************************************

GR_SAVE_PFS         = r33
GR_SAVE_B0          = r34
GR_SAVE_GP          = r35
GR_Parameter_X      = r36
GR_Parameter_Y      = r37
GR_Parameter_RESULT = r38
GR_Parameter_TAG    = r39

FR_X                = f14
FR_Y                = f15
FR_RESULT           = f8

.section .text
.proc _cabsf#
.global _cabsf#
_cabsf: 
.endp _cabsf
.proc _hypotf#
.global _hypotf#
.align 64 

_hypotf: 
{.mfi
  alloc r32= ar.pfs,0,4,4,0
  // Compute x*x
  fma.s1 f10=f8,f8,f0
  // r2=bias-1
  mov r2=0xfffe 
}
{.mfi
  nop.m 0
  // y*y
  fma.s1 f11=f9,f9,f0
  nop.i 0;;
}

{ .mfi
     nop.m 0
//   Check if x is an Inf - if so return Inf even
//   if y is a NaN (C9X)
     fclass.m.unc p7, p6 = f8, 0x023
     nop.i 0
}
{.mfi
  nop.m 0
  // if possible overflow, copy f8 to f14
  // set Denormal, if necessary 
  // (p8) 
  fma.s.s0 f14=f8,f1,f0
  nop.i 0;;
}

{ .mfi
     nop.m 0
//   Check if y is an Inf - if so return Inf even
//   if x is a NaN (C9X)
     fclass.m.unc p8, p9 = f9, 0x023
	 nop.i 0
}
{ .mfi
     nop.m 0
//   For x=inf, multiply y by 1 to raise invalid on y an SNaN
//   (p7) fma.s0 f9=f9,f1,f0
     // copy f9 to f15; set Denormal, if necessary
	 fma.s.s0 f15=f9,f1,f0
     nop.i 0;;
}
{.mfi
  nop.m 0
  // is y Zero ?
  (p6) fclass.m p6,p0=f9,0x7
  nop.i 0;;
}
{.mfi
  nop.m 0
  // is x Zero ?
  (p9) fclass.m p9,p0=f8,0x7
  nop.i 0;;
}

{.mfi
  // f7=0.5
  setf.exp f7=r2
  // a=x2+y2
  fma.s1 f12=f10,f1,f11
  nop.i 0;;
}

{.mfi
  nop.m 0
  // x not NaN ?
  (p6) fclass.m p7,p0=f8,0x3f
  nop.i 0
}
{.mfi
  // 2*emax-2
  mov r2=0x100fb
  // f6=2
  fma.s1 f6=f1,f1,f1
  nop.i 0;;
}

{.mfi
  nop.m 0
  // y not NaN ?
  (p9) fclass.m p8,p0=f9,0x3f
  nop.i 0;;
}

{.mfb
  nop.m 0
  // if f8=Infinity or f9=Zero, return |f8|
  (p7) fmerge.s f8=f0,f14
  (p7) br.ret.spnt b0
}
{.mfb
  nop.m 0
  // if f9=Infinity or f8=Zero, return |f9|
  (p8) fmerge.s f8=f0,f15
  (p8) br.ret.spnt b0;;
}

{ .mfi
	 nop.m 0
//   Identify Natvals, Infs, NaNs, and Zeros 
//   and return result
     fclass.m.unc p7, p0 = f12, 0x1E7
     nop.i 0
} 
{.mfi
  nop.m 0
  // z0=frsqrta(a)
  frsqrta.s1 f8,p6=f12
  nop.i 0;;
}

{.mfb
  // get exponent of x^2+y^2
  getf.exp r3=f12
  // if special case, set f8
  (p7) mov f8=f12
  (p7) br.ret.spnt b0;;
}


{.mfi
  nop.m 0
  // S0=a*z0
  (p6) fma.s1 f12=f12,f8,f0
  nop.i 0
}
{.mfi
  nop.m 0
  // H0=0.5*z0
  (p6) fma.s1 f10=f8,f7,f0
  nop.i 0;;
} 


{.mfi
  nop.m 0
  // f6=5/2
  fma.s1 f6=f7,f1,f6
  nop.i 0
}
{.mfi
  nop.m 0
  // f11=3/2
  fma.s1 f11=f7,f1,f1
  nop.i 0;;
}

{.mfi
  nop.m 0
  // d=0.5-S0*H0
  (p6) fnma.s1 f7=f12,f10,f7
  nop.i 0;;
}

{.mfi
  nop.m 0
  // P01=d+1
  (p6) fma.s1 f10=f1,f7,f1
  nop.i 0
}
{.mfi
  nop.m 0
  // P23=5/2*d+3/2
  (p6) fma.s1 f11=f6,f7,f11
  nop.i 0;;
}
{.mfi
  nop.m 0
  // d2=d*d
  (p6) fma.s1 f7=f7,f7,f0
  nop.i 0;;
}


{.mfi
  // Is x^2 + y^2 well less than the overflow 
  // threshold?
  (p6) cmp.lt.unc p7, p8 =  r3,r2
  // P=P01+d2*P23
  (p6) fma.s1 f10=f7,f11,f10
  nop.i 0;;
}

{.mfb
  nop.m 0
  // S=P*S0
  fma.s.s0 f8=f10,f12,f0
  // No overflow in this case
  (p7) br.ret.sptk b0;;
}

{ .mfi
     nop.m 0  
(p8) fsetc.s2 0x7F,0x42 
     // Possible overflow path, must detect by
     // Setting widest range exponent with prevailing
     // rounding mode.
     nop.i 0 ;;
}


{ .mfi
   // bias+0x400 (bias+EMAX+1)
   (p8) mov r2=0x1007f
   // S=P*S0
   (p8) fma.s.s2 f12=f10,f12,f0
   nop.i 0 ;;
}
{ .mfi
(p8) setf.exp f11 = r2
(p8) fsetc.s2 0x7F,0x40
//   Restore Original Mode in S2
     nop.i 0 ;;
}
{ .mfi
     nop.m 0 
(p8) fcmp.lt.unc.s1 p9, p10 =  f12, f11
     nop.i 0 ;;
}
{ .mib
     nop.m 0
     mov GR_Parameter_TAG = 47
	 // No overflow
(p9) br.ret.sptk b0;; 
}
.endp

.proc __libm_error_region
__libm_error_region:
.prologue
{ .mii
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
(p0)    mov   GR_Parameter_TAG = 47                   
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfs [GR_Parameter_Y] = FR_Y,16         // Store Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
};;
.body
{ .mib
        stfs [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
        nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfs [GR_Parameter_Y] = FR_RESULT       // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#   // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;
{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp 
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};; 

.endp __libm_error_region


.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\libm_atan2_reg.s ===
.file "libm_atan2_reg.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version
// 4/04/00  Unwind support added

.data

.align 64
Constants_atan:
data4   0x54442D18, 0x3FF921FB, 0x248D3132, 0x3E000000
// double pi/2, single lo_pi/2, two**(-3)
data4   0xAAAAAAA3, 0xAAAAAAAA, 0x0000BFFD, 0x00000000 // P_1
data4   0xCCCC54B2, 0xCCCCCCCC, 0x00003FFC, 0x00000000 // P_2
data4   0x47E4D0C2, 0x92492492, 0x0000BFFC, 0x00000000 // P_3
data4   0x58870889, 0xE38E38E0, 0x00003FFB, 0x00000000 // P_4
data4   0x290149F8, 0xBA2E895B, 0x0000BFFB, 0x00000000 // P_5
data4   0x250F733D, 0x9D88E6D4, 0x00003FFB, 0x00000000 // P_6
data4   0xFB8745A0, 0x884E51FF, 0x0000BFFB, 0x00000000 // P_7
data4   0x394396BD, 0xE1C7412B, 0x00003FFA, 0x00000000 // P_8
data4   0xAAAAA52F, 0xAAAAAAAA, 0x0000BFFD, 0x00000000 // Q_1
data4   0xC75B60D3, 0xCCCCCCCC, 0x00003FFC, 0x00000000 // Q_2
data4   0x011F1940, 0x924923AD, 0x0000BFFC, 0x00000000 // Q_3
data4   0x2A5F89BD, 0xE36F716D, 0x00003FFB, 0x00000000 // Q_4
//      Entries Tbl_hi  (double precision)
//      B = 1+Index/16+1/32  Index = 0
//      Entries Tbl_lo (single precision)
//      B = 1+Index/16+1/32  Index = 0
data4   0xA935BD8E, 0x3FE9A000, 0x23ACA08F, 0x00000000
// Entries Tbl_hi  (double precision) Index = 0,1,...,15
// B = 2^(-1)*(1+Index/16+1/32)
// Entries Tbl_lo (single precision)
// Index = 0,1,...,15  B = 2^(-1)*(1+Index/16+1/32)
data4   0x7F175A34, 0x3FDE77EB, 0x238729EE, 0x00000000
data4   0x73C1A40B, 0x3FE0039C, 0x249334DB, 0x00000000
data4   0x5B5B43DA, 0x3FE0C614, 0x22CBA7D1, 0x00000000
data4   0x88BE7C13, 0x3FE1835A, 0x246310E7, 0x00000000
data4   0xE2CC9E6A, 0x3FE23B71, 0x236210E5, 0x00000000
data4   0x8406CBCA, 0x3FE2EE62, 0x2462EAF5, 0x00000000
data4   0x1CD41719, 0x3FE39C39, 0x24B73EF3, 0x00000000
data4   0x5B795B55, 0x3FE44506, 0x24C11260, 0x00000000
data4   0x5BB6EC04, 0x3FE4E8DE, 0x242519EE, 0x00000000
data4   0x1F732FBA, 0x3FE587D8, 0x24D4346C, 0x00000000
data4   0x115D7B8D, 0x3FE6220D, 0x24ED487B, 0x00000000
data4   0x920B3D98, 0x3FE6B798, 0x2495FF1E, 0x00000000
data4   0x8FBA8E0F, 0x3FE74897, 0x223D9531, 0x00000000
data4   0x289FA093, 0x3FE7D528, 0x242B0411, 0x00000000
data4   0x576CC2C5, 0x3FE85D69, 0x2335B374, 0x00000000
data4   0xA99CC05D, 0x3FE8E17A, 0x24C27CFB, 0x00000000
//
//      Entries Tbl_hi  (double precision) Index = 0,1,...,15
//      B = 2^(-2)*(1+Index/16+1/32)
//      Entries Tbl_lo (single precision)
//      Index = 0,1,...,15  B = 2^(-2)*(1+Index/16+1/32)
//
data4   0x510665B5, 0x3FD025FA, 0x24263482, 0x00000000
data4   0x362431C9, 0x3FD1151A, 0x242C8DC9, 0x00000000
data4   0x67E47C95, 0x3FD20255, 0x245CF9BA, 0x00000000
data4   0x7A823CFE, 0x3FD2ED98, 0x235C892C, 0x00000000
data4   0x29271134, 0x3FD3D6D1, 0x2389BE52, 0x00000000
data4   0x586890E6, 0x3FD4BDEE, 0x24436471, 0x00000000
data4   0x175E0F4E, 0x3FD5A2E0, 0x2389DBD4, 0x00000000
data4   0x9F5FA6FD, 0x3FD68597, 0x2476D43F, 0x00000000
data4   0x52817501, 0x3FD76607, 0x24711774, 0x00000000
data4   0xB8DF95D7, 0x3FD84422, 0x23EBB501, 0x00000000
data4   0x7CD0C662, 0x3FD91FDE, 0x23883A0C, 0x00000000
data4   0x66168001, 0x3FD9F930, 0x240DF63F, 0x00000000
data4   0x5422058B, 0x3FDAD00F, 0x23FE261A, 0x00000000
data4   0x378624A5, 0x3FDBA473, 0x23A8CD0E, 0x00000000
data4   0x0AAD71F8, 0x3FDC7655, 0x2422D1D0, 0x00000000
data4   0xC9EC862B, 0x3FDD45AE, 0x2344A109, 0x00000000
//
//      Entries Tbl_hi  (double precision) Index = 0,1,...,15
//      B = 2^(-3)*(1+Index/16+1/32)
//      Entries Tbl_lo (single precision)
//      Index = 0,1,...,15  B = 2^(-3)*(1+Index/16+1/32)
//
data4   0x84212B3D, 0x3FC068D5, 0x239874B6, 0x00000000
data4   0x41060850, 0x3FC16465, 0x2335E774, 0x00000000
data4   0x171A535C, 0x3FC25F6E, 0x233E36BE, 0x00000000
data4   0xEDEB99A3, 0x3FC359E8, 0x239680A3, 0x00000000
data4   0xC6092A9E, 0x3FC453CE, 0x230FB29E, 0x00000000
data4   0xBA11570A, 0x3FC54D18, 0x230C1418, 0x00000000
data4   0xFFB3AA73, 0x3FC645BF, 0x23F0564A, 0x00000000
data4   0xE8A7D201, 0x3FC73DBD, 0x23D4A5E1, 0x00000000
data4   0xE398EBC7, 0x3FC8350B, 0x23D4ADDA, 0x00000000
data4   0x7D050271, 0x3FC92BA3, 0x23BCB085, 0x00000000
data4   0x601081A5, 0x3FCA217E, 0x23BC841D, 0x00000000
data4   0x574D780B, 0x3FCB1696, 0x23CF4A8E, 0x00000000
data4   0x4D768466, 0x3FCC0AE5, 0x23BECC90, 0x00000000
data4   0x4E1D5395, 0x3FCCFE65, 0x2323DCD2, 0x00000000
data4   0x864C9D9D, 0x3FCDF110, 0x23F53F3A, 0x00000000
data4   0x451D980C, 0x3FCEE2E1, 0x23CCB11F, 0x00000000
data4   0x54442D18, 0x400921FB, 0x33145C07, 0x3CA1A626 // I two doubles
data4   0x54442D18, 0x3FF921FB, 0x33145C07, 0x3C91A626 // I_by_2 two dbls
data4   0x54442D18, 0x3FE921FB, 0x33145C07, 0x3C81A626 // I_by_4 two dbls
data4   0x7F3321D2, 0x4002D97C, 0x4C9E8A0A, 0x3C9A7939 // 3I_by_4 two dbls
.section .text

.proc __libm_atan2_reg#
.global __libm_atan2_reg#
.align 64
__libm_atan2_reg:


{ .mfi
       alloc  r32 = ar.pfs,0,20,4,0
(p0)   mov f32 = f8
       nop.i 0
} 
{ .mmi
      nop.m 0
(p0)  addl           r39   = @ltoff(Constants_atan#), gp
      nop.i 999
}
;;

{ .mmi
      ld8 r39 = [r39]
      nop.m 999
      nop.i 999
}
;;

{ .mfi
       nop 999	// EMbo added ...
(p0)   mov f33 = f9
 nop.i 0
 } { .mfi
       nop 999	// EMbo added ...
(p0)   fclass.nm.unc p9,p0 = f32 ,0x1FF
       nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fclass.nm.unc p8,p0 = f33 ,0x1FF
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fclass.m.unc  p6,p0 = f33 ,0x103
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fclass.m.unc  p7,p0 = f32 ,0x103
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fclass.m.unc p12,p0 = f33 ,0x0C3
	nop 999;;	// EMbo added ...
 } { .mfb
	nop 999	// EMbo added ...
//
//     Check for NatVals.
//     Check for EM Unsupporteds
//     Check for NaNs.
//
(p0)   fclass.m.unc p13,p0 = f32 ,0x0C3
(p6)   br.cond.sptk ATAN_NATVAL;;
 } { .mbb
	nop 999	// EMbo added ...
(p7)   br.cond.sptk ATAN_NATVAL
(p8)   br.cond.sptk ATAN_UNSUPPORTED;;
 } { .mib
(p0)   add r40 = 96, r39
	nop 999	// EMbo added ...
(p9)   br.cond.sptk ATAN_UNSUPPORTED;;
 } { .mib
(p0)   ldfd  f50 = [r39],8
	nop 999	// EMbo added ...
(p12)  br.cond.sptk ATAN_NAN;;
 } { .mfb
	nop 999	// EMbo added ...
(p0)   fnorm.s1 f33 = f33
(p13)  br.cond.sptk ATAN_NAN;;
 } { .mfi
(p0)   ldfs  f51 = [r39],4
//
//     Remove sign bits from exponents
//     Load 2**(-3)
//     Normalize the input argument.
//
(p0)   fnorm.s1 f32 = f32
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   mov f82 = f1
	nop 999;;	// EMbo added ...
 } { .mmi
	nop 999;;	// EMbo added ...
(p0)   ldfs  f78 = [r39],180
	nop 999;;	// EMbo added ...
 } { .mmi
(p0)   getf.exp r36 = f33;;
//
//     Get exp and sign of ArgX
//     Get exp and sign of ArgY
//     Load 2**(-3) and increment ptr to Q_4.
//
(p0)   getf.exp r37 = f32
(p0)   shr.u r36 = r36,17;;
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fmerge.s f84 =  f1,f32
(p0)   shr.u r37 = r37,17;;
 } { .mfi
	nop 999	// EMbo added ...
//
//     ArgX_abs = |ArgX|
//     ArgY_abs = |ArgY|
//     sign_X is sign bit of ArgX
//     sign_Y is sign bit of ArgY
//
(p0)   fmerge.s f83 =  f1,f33
(p0)   cmp.eq.unc  p8,p9 = 0x00000, r37;;
 } { .mfi
	nop 999	// EMbo added ...
(p8)   fadd.s1 f34 = f0, f1
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p9)   fsub.s1 f34 = f0, f1
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fmin.s1 f36 = f83, f84
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fmax.s1 f35 = f83, f84
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     Is ArgX_abs >= ArgY_abs
//     Is sign_Y == 0?
//
(p0)   fcmp.ge.s1  p6,p7 = f83,f84
	nop 999;;	// EMbo added ...
 } { .mii
(p6)   cmp.eq.unc  p10, p11 =  0x00000, r36
(p6)   add r38 = r0, r0;;
//
//     U = max(ArgX_abs,ArgY_abs)
//     V = min(ArgX_abs,ArgY_abs)
//     if p6, swap = 0
//     if p7, swap = 1
//
//
//     Let M = 1.0
//     if p8, s_Y = 1.0
//     if p9, s_Y = -1.0
//
(p7)   add r38 = 1,r0;;
 } { .mfi
	nop 999	// EMbo added ...
(p0)   frcpa.s1 f37, p6 =  f36, f35
	nop 999;;	// EMbo added ...
 } { .mfb
	nop 999	// EMbo added ...
//
//     E = frcpa(V,U)
//
(p10)  fsub.s1 f82 = f82, f1
(p6)   br.cond.sptk ATAN_STEP2;;
 } { .mib
	nop 999	// EMbo added ...
	nop 999	// EMbo added ...
// /**************************************************/
// /********************* STEP2 **********************/
// /**************************************************/
(p0)   br.cond.spnt ATAN_SPECIAL_HANDLING;;
 }
ATAN_STEP2:
 { .mlx
	nop 999	// EMbo added ...
(p0)   movl r47 =  0x8400000000000000
 } { .mlx
	nop 999	// EMbo added ...
(p0)   movl r48 =  0x0000000000000100;;
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fmpy.s1 f38 = f37, f36
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fcmp.lt.unc.s0  p0,p9 = f9,f1
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fcmp.lt.unc.s0  p0,p8 = f8,f1
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     Q = E * V
//
(p11)  fadd.s1 f82 = f82, f1
	nop 999;;	// EMbo added ...
 } { .mfi
(p0)   getf.sig r46 = f38
(p0)   fcmp.lt.unc p6,p7 = f38,f78
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fmpy.s1 f38 = f37, f36
(p0)   extr.u r42 = r46, 59, 4;;
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fmpy.s1 f50 = f82, f50
(p0)   dep r47 = r42, r47, 59, 4
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fmpy.s1 f51 = f82, f51
	nop 999;;	// EMbo added ...
 } { .mmi
	nop 999;;	// EMbo added ...
//
//     Is Q < 2**(-3)?
//
//
//     Do fcmp to raise any denormal operand
//     exceptions.
//
(p0)   getf.exp r45 = f38
	nop 999;;	// EMbo added ...
 } { .mib
//
//     lookup = b_1 b_2 b_3 B_4
//
//
//     Generate 1.b_1 b_2 b_3 b_4 1 0 0 0 ... 0
//
(p0)   andcm r41 = 0x0003, r45
	nop 999	// EMbo added ...
//
//     We waited a few extra cycles so P_lo and P_hi could be calculated.
//     Load the constant 256 for loading up table entries.
//
//    /**************************************************/
//    /********************* STEP3 **********************/
//    /**************************************************/
(p6)   br.cond.spnt ATAN_POLY;;
 } { .mii
(p0)   setf.sig f39 = r47
(p0)   cmp.eq.unc  p8, p9 =  0x0000, r41
//
//     z_hi = s exp 1.b_1 b_2 b_3 b_4 1 0 0 0 ... 0
//     point to beginning of Tbl_hi entries - k = 0.
//
(p0)   add r40 = 16, r39
 } { .mmi
(p0)   ldfe f73 = [r39],-16;;
(p9)   sub r41 = r41,r0,1
(p9)   add r40 = 16,r40
 } { .mfi
(p8)   ldfd  f48 = [r40],8
(p0)   fmpy.s1 f50 = f34, f50
(p0)   xor r38 = r36,r38;;
 } { .mmi
(p0)   ldfe f71 = [r39],-16;;
(p8)   ldfs  f49 = [r40],8
(p9)   pmpy2.r r41 = r41,r48;;
 } { .mfi
(p0)   ldfe f69 = [r39],-16
//
//     Let z_hi have exponent and sign of original Q
//     Load the Tbl_hi(0) else, increment pointer.
//
(p0)   fmerge.se f39 =  f38,f39
(p9)   shladd r42 = r42,0x0004,r41;;
 } { .mmi
(p9)   add r40 = r40, r42;;
(p9)   ldfd  f48 = [r40],8
	nop 999;;	// EMbo added ...
 } { .mmi
(p0)   ldfe f67 = [r39],-16;;
(p9)   ldfs  f49 = [r40],8
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     U_prime_hi = U + V * z_hi
//     Load the Tbl_lo(0)
//
(p0)   fma.s1 f40 = f36, f39, f35
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fnma.s1 f42 = f35, f39, f36
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   mov f52 = f48
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   frcpa.s1 f43, p6 =  f1, f40
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     U_prime_lo = U - U_prime_hi
//     k = k * 256 - result can be 0, 256, or 512.
//
(p0)   fsub.s1 f41 = f35, f40
(p0)   cmp.eq.unc  p7, p6 =  0x00000, r38
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fmpy.s1 f52 = f34, f52
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p7)   fadd.s1 f54 = f0, f1
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p6)   fsub.s1 f54 = f0, f1
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fnma.s1 f80 = f43, f40, f1
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fadd.s1 f79 = f41, f40
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fma.s1 f41 = f36, f39, f41
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fma.s1 f56 = f54, f52, f50
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fma.s1 f43 = f80, f43, f43
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     U_prime_lo =  U - U_hold
//     lookup -> lookup * 16 + k
//
//
//     V_prime =  V - U * z_hi
//     U_prime_lo =  V * z_hi + U_prime_lo
//
(p0)   fsub.s1 f79 = f35, f79
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fnma.s1 f80 = f43, f40, f1
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     C_hi = frcpa(1,U_prime_hi)
//     U_prime_lo = U_prime_lo + U_hold
//
//
//     C_hi_hold = 1 - C_hi * U_prime_hi (1)
//
//
//     C_hi = C_hi + C_hi * C_hi_hold    (1)
//
//
//     C_hi_hold = 1 - C_hi * U_prime_hi (2)
//
(p0)   fadd.s1 f41 = f41, f79
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     C_hi = C_hi + C_hi * C_hi_hold    (2)
//
(p0)   fma.s1 f43 = f80, f43, f43
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     C_hi_hold = 1 - C_hi * U_prime_hi (3)
//
(p0)   fnma.s1 f80 = f43, f40, f1
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     C_hi = C_hi + C_hi * C_hi_hold    (3)
//
(p0)   fma.s1 f43 = f80, f43, f43
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     w_hi = V_prime * C_hi
//
(p0)   fmpy.s1 f44 = f42, f43
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fmpy.s1 f46 = f44, f44
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     wsq = w_hi * w_hi
//     w_lo =  = V_prime - w_hi * U_prime_hi
//
(p0)   fnma.s1 f45 = f44, f40, f42
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fma.s1 f47 = f46, f73, f71
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     poly = Q_3 + wsq * Q_4
//     w_lo =  = w_lo - w_hi * U_prime_lo
//
(p0)   fnma.s1 f45 = f44, f41, f45
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fma.s1 f47 = f46, f47, f69
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     poly = Q_2 + wsq * poly
//     w_lo =  = w_lo * C_hi
//
(p0)   fmpy.s1 f45 = f43, f45
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fma.s1 f47 = f46, f47, f67
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     poly = Q_1 + wsq * poly
//     A_lo = Tbl_lo + w_lo
//     swap = xor(swap,sign_X)
//
(p0)   fadd.s1 f53 = f49, f45
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     Is (swap) != 0 ?
//     poly = wsq * poly
//     A_hi = Tbl_hi
//
(p0)   fmpy.s1 f47 = f46, f47
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     poly = wsq * poly
//
//
//     if (p6) sigma = -1.0
//     if (p7) sigma =  1.0
//
(p0)   fmpy.s1 f47 = f44, f47
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     P_hi = s_Y * P_hi
//     A_lo = A_lo + poly
//
(p0)   fadd.s1 f53 = f53, f47
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     A_lo = A_lo + w_hi
//     A_hi = s_Y * A_hi
//
(p0)   fadd.s1 f53 = f53, f44
	nop 999;;	// EMbo added ...
 } { .mfb
	nop 999	// EMbo added ...
//
//     result_hi = P_hi + sigma * A_hi
//     result_lo = P_lo + sigma * A_lo
//
(p0)   fma.s1 f55 = f54, f53, f51
(p0)   br.cond.sptk RETURN_ATAN;;
} 
//
//     result  =  result_hi + result_lo * s_Y  (User Supplied Rounding Mode)
//
//     (p0)   fma.d.s0 f57 = f55, f34, f56
//
// /**************************************************/
// /********************* STEP4 **********************/
// /**************************************************/
//
ATAN_POLY:
{ .mmi
(p0)   xor r38 = r36,r38
(p0)  addl           r39   = @ltoff(Constants_atan#), gp
      nop.i 999
}
;;

{ .mmi
      ld8 r39 = [r39]
      nop.m 999
      nop.i 999
}
;;


{ .mlx
	nop 999	// EMbo added ...
(p0)   movl r47 =  0x24005;;
 } { .mfi
(p0)   add r39 = 128, r39
(p0)   fnma.s1 f81 = f37, f35, f1
(p0)   cmp.eq.unc  p7, p6 =  0x00000, r38;;
 } { .mmf
	nop 999	// EMbo added ...
(p0)   ldfe f77 = [r39],-16
//
//     Iterate 3 times E = E + E*(1.0 - E*U)
//     Also load P_8, P_7, P_6, P_5, P_4
//     E_hold = 1.0 - E * U     (1)
//     A_temp = Q
//
(p0)   mov f85 = f38;;
 } { .mmf
	nop 999	// EMbo added ...
(p0)   ldfe f76 = [r39],-16
(p6)   fsub.s1 f54 = f0, f1;;
 } { .mmf
	nop 999	// EMbo added ...
(p0)   ldfe f75 = [r39],-16
//
//     E = E + E_hold*E         (1)
//     Point to P_8.
//
(p0)   fma.s1 f37 = f37, f81, f37;;
 } { .mmf
	nop 999	// EMbo added ...
(p0)   ldfe f74 = [r39],-16
(p0)   fnma.s1 f64 = f85, f35, f36;;
 } { .mmf
	nop 999	// EMbo added ...
(p0)   ldfe f72 = [r39],-16
(p7)   fadd.s1 f54 = f0, f1;;
 } { .mmf
	nop 999	// EMbo added ...
(p0)   ldfe f70 = [r39],-16
//
//     E_hold = 1.0 - E * U     (2)
//
(p0)   fnma.s1 f81 = f37, f35, f1;;
 } { .mmf
	nop 999	// EMbo added ...
(p0)   ldfe f68 = [r39],-16
(p0)   fmpy.s1 f50 = f34, f50;;
 } { .mmf
	nop 999	// EMbo added ...
(p0)   ldfe f66 = [r39],-16
(p0)   fmpy.d.s0 f67 = f67, f67
 } { .mfi
	nop 999	// EMbo added ...
//
//     E = E + E_hold*E         (2)
//
(p0)   fma.s1 f37 = f37, f81, f37
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     E_hold = 1.0 - E * U     (3)
//
(p0)   fnma.s1 f81 = f37, f35, f1
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     E = E + E_hold*E         (3)
//     At this point E approximates 1/U to roughly working precision
//     z = V*E approximates V/U
//
(p0)   fma.s1 f37 = f37, f81, f37
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     z =   V * E
//
(p0)   fmpy.s1 f59 = f36, f37
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fmpy.s1 f64 = f64, f37
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     zsq = z * z
//     Also load P_3
//
(p0)   fmpy.s1 f60 = f59, f59
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fadd.s1 f52 = f85, f64
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fma.s1 f62 = f60, f77, f76
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fma.s1 f63 = f60, f70, f68
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     z8 = zsq * zsq
//     Also load P_2
//
(p0)   fmpy.s1 f61 = f60, f60
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fsub.s1 f85 = f85, f52
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fmerge.s  f65 = f52,f52
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fma.s1 f62 = f60, f62, f75
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fma.s1 f63 = f60, f63, f66
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     z8 = z8 * z8
//     Also load P_1
//     poly1 = _4 + zsq*(P_5 + zsq*(P_6 + zsq*(P_7 + zsq*P_8)))
//     poly2 = zsq*(P_1 + zsq*(P_2 + zsq*P_3))
//
//
//     poly1 = P_7 + zsq * P_8
//     poly2 = P_2 + zsq * P_3
//     poly1 = P_4 + zsq*(P_5 + zsq*(P_6 + zsq*poly1))
//     poly2 = zsq*(P_1 + zsq*poly2)
//
//
//     poly1 = P_6 + zsq * poly1
//     poly2 = P_1 + zsq * poly2
//     poly1 = P_4 + zsq*(P_5 + zsq*poly1)
//     poly2 = zsq*poly2
//
(p0)   fmpy.s1 f61 = f61, f61
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fadd.s1 f64 = f85, f64
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fma.s1 f62 = f60, f62, f74
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     poly1 = P_5 + zsq * poly1
//     poly2 = zsq * poly2
//     poly1 = P_4 + zsq*poly1
//
(p0)   fmpy.s1 f63 = f63, f60
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     poly1 = P_4 + zsq * poly1
//     swap = xor(swap,sign_X)
//
(p0)   fma.s1 f62 = f60, f62, f72
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     poly = z8*poly1 + poly2  (Typo in writeup)
//     Is (swap) != 0 ?
//
//
//     z_lo = V - A_temp * U
//     if (p7) sigma =  1.0
//     Writeup shows A_temp as A_hi
//
//
//     z_lo = z_lo * E
//     if (p6) sigma = -1.0
//     z_lo = (V - A_temp * U) *E
//
//
//     Fixup added to force inexact later -
//     A_hi = A_temp + z_lo
//     z_lo = (A_temp - A_hi) + z_lo
//     z_lo = A_hi - z_lo -A_hi + z_lo = about 0
//
(p0)   fma.s1 f47 = f61, f62, f63
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     A_lo = z * poly + z_lo
//
(p0)   fma.s1 f53 = f59, f47, f64
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fadd.s1  f52 = f65, f53
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fsub.s1  f65 = f65, f52
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fmpy.s1 f52 = f34, f52
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fadd.s1  f53 = f65, f53
	nop 999	// EMbo added ...
 } { .mfi
(p0)   setf.exp f65 = r47
(p0)   fma.s1 f56 = f54, f52, f50
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fclass.m.unc  p6,p0 = f53,0x007
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     P_hi = s_Y * P_hi
//     A_hi = s_Y * A_hi
//
//
//     result_hi = P_hi + sigma * A_hi
//
(p6)   mov f53 = f65
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     tmp = P_hi - result_hi
//
(p0)   fsub.s1 f65 = f50, f56
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fma.s1 f65 = f52, f54, f65
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     tmp   = sigma * A_hi  + tmp
//     sigma = A_lo * sigma  + P_lo
//
(p0)   fma.s1 f54 = f53, f54, f51
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     result_lo = s_Y * sigma + tmp
//
(p0)   fma.s1 f55 = f34, f54, f65
	nop 999;;	// EMbo added ...
 } { .mfb
       nop.m 0
       mov f34 = f1
(p0)   br.cond.sptk RETURN_ATAN;;
}
//
//     result  =  result_hi + result_lo  (User Supplied Rounding Mode)
//
//     (p0)   fadd.d.s0 f57 = f55, f56
ATAN_UNSUPPORTED:
ATAN_NATVAL:
 { .mfb
	nop 999	// EMbo added ...
//
//     Deal with the NatVal and unsupported cases.
//     Raise invalid if warrented.
//
(p0)   fmpy.d.s0 f57 = f8, f9
br.cond.sptk RETURN_ATAN;;
 }
ATAN_NAN:
 { .mfb
	nop 999	// EMbo added ...
//
//     If only one NaN, then generate the resulting
//     NaN and return - may raise invalid.
//
(p0)   fmpy.d.s0 f57 = f8, f9
(p0)   br.cond.sptk RETURN_ATAN;;
 }
ATAN_SPECIAL_HANDLING:

 { .mmf
(p0)   addl           r39   = @ltoff(Constants_atan#), gp
       nop.m 999
(p0)   fcmp.lt.s0 p0,p7 = f8,f1
 } 
;;

//
//     Raise denormal operand faults if necessary
//

{ .mfi
       ld8 r39 = [r39]
(p0)   fcmp.lt.s0 p0,p6 = f9,f1
	nop 999;;	// EMbo added ...
} 
;;



{ .mfi
	nop 999	// EMbo added ...
(p0)   fclass.m.unc p6,p7 = f32,0x007
	nop 999;;	// EMbo added ...
 } { .mlx
	nop 999	// EMbo added ...
(p0)   movl r47 = 992;;
 } { .mib
(p0)   add r39 = r39, r47
	nop 999	// EMbo added ...
(p7)   br.cond.sptk ATAN_ArgY_Not_ZERO;;
 } { .mfi
	nop 999	// EMbo added ...
(p6)   fclass.m.unc p14,p0 = f33,0x035
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p6)   fclass.m.unc p15,p0 = f33,0x036
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p6)   fclass.m.unc p13,p0 = f33,0x007
	nop 999	// EMbo added ...
 } { .mfi
(p0)   ldfd  f56 = [r39],8
	nop 999	// EMbo added ...
	nop 999;;	// EMbo added ...
 } { .mfi
(p0)   ldfd  f55 = [r39],-8
(p14)  fmerge.s f56 =  f32,f0
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     Return sign_Y * 0 when Y = +/-0 and X > 0
//
(p14)  fmerge.s f55 =  f32,f0
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p15)  fmerge.s f56 =  f32,f56
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     Return sign_Y * PI when X <  -0
//
//
(p15)  fmerge.s f55 =  f32,f55
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fadd.d.s0 f57 = f56,f55
      nop.i 0
 } { .bbb
//
//     Call error support function for atan(0,0)
//     - expected value already computed.
//
    nop.b 0
    nop.b 0
(p0)  br.cond.sptk RETURN_ATAN
 }
ATAN_ArgY_Not_ZERO:
 { .mfi
	nop 999	// EMbo added ...
(p0)   fclass.m.unc p9,p10 = f32,0x023
	nop 999;;	// EMbo added ...
 } { .mfb
	nop 999	// EMbo added ...
(p9)   fclass.m.unc p6,p0 = f33,0x017
(p10)  br.cond.sptk ATAN_ArgY_Not_INF;;
 } { .mfi
(p6)   add r39 = 16,r39
(p9)   fclass.m.unc p7,p0 = f33,0x021
	nop 999;;	// EMbo added ...
 } { .mmf
	nop 999	// EMbo added ...
(p0)   ldfd  f56 = [r39],8
(p9)   fclass.m.unc p8,p0 = f33,0x022;;
 } { .mbb
(p0)   ldfd  f55 = [r39],-8
	nop 999	// EMbo added ...
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p6)   fmerge.s f56 =  f32,f56
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p6)   fmerge.s f55 =  f32,f55
	nop 999;;	// EMbo added ...
 } { .mfb
	nop 999	// EMbo added ...
//
//     Load I/2 and adjust its sign.
//     Return +I/2 when ArgY = +Inf and ArgX = +/-0,normal
//     Return -I/2 when ArgY = -Inf and ArgX = +/-0,normal
//
(p6)   fadd.d.s0  f57 =   f56,  f55
(p6)   br.cond.sptk RETURN_ATAN;;
 } { .mmi
(p7)   add r39 = 32,r39;;
(p7)   ldfd  f56 = [r39],8
	nop 999;;	// EMbo added ...
 } { .mmi
	nop 999;;	// EMbo added ...
(p7)   ldfd  f55 = [r39],-8
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p7)   fmerge.s f56 =  f32,f56
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p7)   fmerge.s f55 =  f32,f55
	nop 999;;	// EMbo added ...
 } { .mfb
	nop 999	// EMbo added ...
//
//     Load PI/4 and adjust its sign.
//     Return +PI/4 when ArgY = +Inf and ArgX = +Inf
//     Return -PI/4 when ArgY = -Inf and ArgX = +Inf
//
(p7)   fadd.d.s0  f57 =   f56,  f55
(p7)   br.cond.sptk RETURN_ATAN;;
 } { .mmi
(p8)   add r39 = 48,r39;;
(p8)   ldfd f56 =[r39],8
	nop 999;;	// EMbo added ...
 } { .mmi
	nop 999;;	// EMbo added ...
(p8)   ldfd f55 =[r39],-8
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p8)   fmerge.s f56 =  f32,f56
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p8)   fmerge.s f55 =  f32,f55
	nop 999;;	// EMbo added ...
 } { .mfb
	nop 999	// EMbo added ...
//
//     Load I/4 and adjust its sign.
//     Return +3I/4 when ArgY = +Inf and ArgX = -Inf
//     Return -3I/4 when ArgY = -Inf and ArgX = -Inf
//
(p8)   fadd.d.s0  f57 =   f56,  f55
(p8)   br.cond.sptk RETURN_ATAN;;
 }
ATAN_ArgY_Not_INF:
 { .mfi
	nop 999	// EMbo added ...
(p0)   fclass.m.unc  p6,p0 = f33,0x007
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fclass.m.unc  p7,p0 = f33,0x021
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p0)   fclass.m.unc  p8,p0 = f33,0x022
(p6)   add r39 = 16,r39;;
 } { .mfi
(p6)   ldfd f56 =[r39],8
	nop 999	// EMbo added ...
	nop 999;;	// EMbo added ...
 } { .mmi
	nop 999;;	// EMbo added ...
(p6)   ldfd f55 =[r39],-8
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p6)   fmerge.s f56 =  f32,f56
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p6)   fmerge.s f55 =  f32,f55
	nop 999;;	// EMbo added ...
 } { .mfb
	nop 999	// EMbo added ...
//
//     return = sign_Y * I/2 when ArgX = +/-0
//
(p6)   fadd.d.s0 f57 = f56, f55
(p6)   br.cond.sptk RETURN_ATAN;;
 } { .mfi
	nop 999	// EMbo added ...
(p7)   fmerge.s f56 =  f32,f0
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p7)   fmerge.s f55 =  f32,f0
	nop 999;;	// EMbo added ...
 } { .mfb
	nop 999	// EMbo added ...
//
//     return = sign_Y * 0 when ArgX = Inf
//
(p7)   fadd.d.s0 f57 = f56, f55
(p7)   br.cond.sptk RETURN_ATAN;;
 } { .mfi
(p8)   ldfd f56 = [r39],8
	nop 999	// EMbo added ...
	nop 999;;	// EMbo added ...
 } { .mmi
	nop 999;;	// EMbo added ...
(p8)   ldfd f55 = [r39],-8
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p8)   fmerge.s f56 =  f32,f56
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p8)   fmerge.s f55 =  f32,f55
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     return = sign_Y * I when ArgX = -Inf
//
(p8)   fadd.d.s0  f57 =   f56,  f55
	nop 999	// EMbo added ...
 };;
RETURN_ATAN:
// mov    f8     = f57 ;;
// The answer is in f57.
// But Z_hi is f56
//     Z_lo is f55
//     s_Y  is f34
//     W is in f9 and untouched

{ .mfi
	nop 999	
mov    f8     = f56
        nop.i 0
};;

{ .mfi
	nop 999	
mov    f10    = f55
        nop.i 999
}
{ .mfb
	nop 999	
mov    f11    = f34
br.ret.sptk   b0
};;

.endp __libm_atan2_reg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\libm_reduce.s ===
.file "libm_reduce.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History:  02/02/00 Initial Version
//
//*********************************************************************
//*********************************************************************
//
// Function:   __libm_pi_by_two_reduce(x) return r, c, and N where
//             x = N * pi/4 + (r+c) , where |r+c| <= pi/4.
//             This function is not designed to be used by the
//             general user.
//
//*********************************************************************
//
// Accuracy:       Returns double-precision values
//
//*********************************************************************
//
// Resources Used:
//
//    Floating-Point Registers: f32-f70
//
//    General Purpose Registers:
//      r8  = return value N
//      r32 = Address of x
//      r33 = Address of where to place r and then c 
//      r34-r64
//
//    Predicate Registers:      p6-p14
//
//*********************************************************************
//
// IEEE Special Conditions:
//
//    No condions should be raised. 
//
//*********************************************************************
//
// I. Introduction
// ===============
//
// For the forward trigonometric functions sin, cos, sincos, and
// tan, the original algorithms for IA 64 handle arguments up to 
// 1 ulp less than 2^63 in magnitude. For double-extended arguments x,
// |x| >= 2^63, this routine returns CASE, N and r_hi, r_lo where
// 
//    x  is accurately approximated by
//    2*K*pi  +  N * pi/2  +  r_hi + r_lo,  |r_hi+r_lo| <= pi/4.
//    CASE = 1 or 2.
//    CASE is 1 unless |r_hi + r_lo| < 2^(-33).
// 
// The exact value of K is not determined, but that information is
// not required in trigonometric function computations.
// 
// We first assume the argument x in question satisfies x >= 2^(63). 
// In particular, it is positive. Negative x can be handled by symmetry:
// 
//   -x  is accurately approximated by
//         -2*K*pi  +  (-N) * pi/2  -  (r_hi + r_lo),  |r_hi+r_lo| <= pi/4.
// 
// The idea of the reduction is that
// 
// 	x  *  2/pi   =   N_big  +  N  +  f,	|f| <= 1/2
// 
// Moreover, for double extended x, |f| >= 2^(-75). (This is an
// non-obvious fact found by enumeration using a special algorithm
// involving continued fraction.) The algorithm described below 
// calculates N and an accurate approximation of f.
// 
// Roughly speaking, an appropriate 256-bit (4 X 64) portion of 
// 2/pi is multiplied with x to give the desired information.
// 
// II. Representation of 2/PI
// ==========================
// 
// The value of 2/pi in binary fixed-point is
// 
//            .101000101111100110......
// 
// We store 2/pi in a table, starting at the position corresponding
// to bit position 63 
// 
//   bit position  63 62 ... 0   -1 -2 -3 -4 -5 -6 -7  ....  -16576
// 
// 	 	0  0  ... 0  . 1  0  1  0  1  0  1  ....    X
//                 
//                              ^
// 	     	             |__ implied binary pt 
// 
// III. Algorithm
// ==============
// 
// This describes the algorithm in the most natural way using
// unsigned interger multiplication. The implementation section 
// describes how the integer arithmetic is simulated in Merced.
// 
// STEP 0. Initialization
// ----------------------
// 
// Let the input argument x be 
// 
//     x = 2^m * ( 1. b_1 b_2 b_3 ... b_63 ),  63 <= m <= 16383.
// 
// The first crucial step is to fetch four 64-bit portions of 2/pi. 
// To fulfill this goal, we calculate the bit position L of the
// beginning of these 256-bit quantity by
// 
//     L :=  62 - m.
// 
// Note that -16321 <= L <= -1 because 63 <= m <= 16383; and that 
// the storage of 2/pi is adequate.
// 
// Fetch P_1, P_2, P_3, P_4 beginning at bit position L thus:
// 
//      bit position  L  L-1  L-2    ...  L-63
// 
//      P_1    =      b   b    b     ...    b
// 
// each b can be 0 or 1. Also, let P_0 be the two bits correspoding to
// bit positions L+2 and L+1. So, when each of the P_j is interpreted
// with appropriate scaling, we have
//
//      2/pi  =  P_big  + P_0 + (P_1 + P_2 + P_3 + P_4)  +  P_small
// 
// Note that P_big and P_small can be ignored. The reasons are as follow.
// First, consider P_big. If P_big = 0, we can certainly ignore it.
// Otherwise, P_big >= 2^(L+3). Now, 
// 
//        P_big * ulp(x) >=  2^(L+3) * 2^(m-63)
// 		      >=  2^(65-m  +  m-63 )
// 		      >=  2^2
// 
// Thus, P_big * x is an integer of the form 4*K. So
// 
// 	x = 4*K * (pi/2) + x*(P_0 + P_1 + P_2 + P_3 + P_4)*(pi/2)
//                + x*P_small*(pi/2).
// 
// Hence, P_big*x corresponds to information that can be ignored for
// trigonometic function evaluation.
// 
// Next, we must estimate the effect of ignoring P_small. The absolute
// error made by ignoring P_small is bounded by
// 
//       |P_small * x|  <=  ulp(P_4) * x
// 		     <=  2^(L-255) * 2^(m+1)
// 		     <=  2^(62-m-255 + m + 1)
// 		     <=  2^(-192)
// 
// Since for double-extended precision, x * 2/pi = integer + f, 
// 0.5 >= |f| >= 2^(-75), the relative error introduced by ignoring
// P_small is bounded by 2^(-192+75) <= 2^(-117), which is acceptable.
// 
// Further note that if x is split into x_hi + x_lo where x_lo is the
// two bits corresponding to bit positions 2^(m-62) and 2^(m-63); then
// 
// 	P_0 * x_hi 
// 
// is also an integer of the form 4*K; and thus can also be ignored.
// Let M := P_0 * x_lo which is a small integer. The main part of the
// calculation is really the multiplication of x with the four pieces
// P_1, P_2, P_3, and P_4.
// 
// Unless the reduced argument is extremely small in magnitude, it
// suffices to carry out the multiplication of x with P_1, P_2, and
// P_3. x*P_4 will be carried out and added on as a correction only 
// when it is found to be needed. Note also that x*P_4 need not be
// computed exactly. A straightforward multiplication suffices since
// the rounding error thus produced would be bounded by 2^(-3*64),
// that is 2^(-192) which is small enough as the reduced argument
// is bounded from below by 2^(-75).
// 
// Now that we have four 64-bit data representing 2/pi and a
// 64-bit x. We first need to calculate a highly accurate product
// of x and P_1, P_2, P_3. This is best understood as integer
// multiplication.
// 
// 
// STEP 1. Multiplication
// ----------------------
// 
// 
//                     ---------   ---------   ---------
// 	             |  P_1  |   |  P_2  |   |  P_3  |
// 	             ---------   ---------   ---------
// 
//                                            ---------
// 	      X                              |   X   |
// 	                                     ---------
//      ----------------------------------------------------
//
//                                 ---------   ---------
//	                         |  A_hi |   |  A_lo |
//	                         ---------   ---------
//
//
//                    ---------   ---------
//	             |  B_hi |   |  B_lo |
//	             ---------   ---------
//
//
//        ---------   ---------  
//	 |  C_hi |   |  C_lo |  
//	 ---------   ---------  
//
//      ====================================================
//       ---------   ---------   ---------   ---------
//	 |  S_0  |   |  S_1  |   |  S_2  |   |  S_3  |
//	 ---------   ---------   ---------   ---------
//
//
//
// STEP 2. Get N and f
// -------------------
// 
// Conceptually, after the individual pieces S_0, S_1, ..., are obtained,
// we have to sum them and obtain an integer part, N, and a fraction, f.
// Here, |f| <= 1/2, and N is an integer. Note also that N need only to
// be known to module 2^k, k >= 2. In the case when |f| is small enough,
// we would need to add in the value x*P_4.
// 
// 
// STEP 3. Get reduced argument
// ----------------------------
// 
// The value f is not yet the reduced argument that we seek. The
// equation
// 
// 	x * 2/pi = 4K  + N  + f
// 
// says that
// 
//         x   =  2*K*pi  + N * pi/2  +  f * (pi/2).
// 
// Thus, the reduced argument is given by
// 
// 	reduced argument =  f * pi/2.
// 
// This multiplication must be performed to extra precision.
// 
// IV. Implementation
// ==================
// 
// Step 0. Initialization
// ----------------------
// 
// Set sgn_x := sign(x); x := |x|; x_lo := 2 lsb of x.
// 
// In memory, 2/pi is stored contigously as
// 
//  0x00000000 0x00000000 0xA2F....
//                       ^
//                       |__ implied binary bit
// 
// Given x = 2^m * 1.xxxx...xxx; we calculate L := 62 - m. Thus
// -1 <= L <= -16321. We fetch from memory 5 integer pieces of data.
// 
// P_0 is the two bits corresponding to bit positions L+2 and L+1
// P_1 is the 64-bit starting at bit position  L
// P_2 is the 64-bit starting at bit position  L-64
// P_3 is the 64-bit starting at bit position  L-128
// P_4 is the 64-bit starting at bit position  L-192
// 
// For example, if m = 63, P_0 would be 0 and P_1 would look like
// 0xA2F...
// 
// If m = 65, P_0 would be the two msb of 0xA, thus, P_0 is 10 in binary.
// P_1 in binary would be  1 0 0 0 1 0 1 1 1 1 .... 
//  
// Step 1. Multiplication
// ----------------------
// 
// At this point, P_1, P_2, P_3, P_4 are integers. They are
// supposed to be interpreted as
// 
//  2^(L-63)     * P_1;
//  2^(L-63-64)  * P_2;
//  2^(L-63-128) * P_3;
// 2^(L-63-192) * P_4;
// 
// Since each of them need to be multiplied to x, we would scale
// both x and the P_j's by some convenient factors: scale each
// of P_j's up by 2^(63-L), and scale x down by 2^(L-63).
// 
//   p_1 := fcvt.xf ( P_1 )
//   p_2 := fcvt.xf ( P_2 ) * 2^(-64)
//   p_3 := fcvt.xf ( P_3 ) * 2^(-128)
//   p_4 := fcvt.xf ( P_4 ) * 2^(-192)
//   x   := replace exponent of x by -1
//          because 2^m    * 1.xxxx...xxx  * 2^(L-63)
//          is      2^(-1) * 1.xxxx...xxx
// 
// We are now faced with the task of computing the following
// 
//                     ---------   ---------   ---------
// 	             |  P_1  |   |  P_2  |   |  P_3  |
// 	             ---------   ---------   ---------
// 
//                                             ---------
// 	      X                              |   X   |
// 	                                     ---------
//       ----------------------------------------------------
// 
//                                 ---------   ---------
// 	                         |  A_hi |   |  A_lo |
// 	                         ---------   ---------
// 
//                     ---------   ---------
// 	             |  B_hi |   |  B_lo |
// 	             ---------   ---------
// 
//         ---------   ---------  
// 	 |  C_hi |   |  C_lo |  
// 	 ---------   ---------  
// 
//      ====================================================
//       -----------   ---------   ---------   ---------
//       |    S_0  |   |  S_1  |   |  S_2  |   |  S_3  |
//       -----------   ---------   ---------   ---------
//        ^          ^
//        |          |___ binary point
//        |
//        |___ possibly one more bit
// 
// Let FPSR3 be set to round towards zero with widest precision
// and exponent range. Unless an explicit FPSR is given, 
// round-to-nearest with widest precision and exponent range is
// used.
// 
// Define sigma_C := 2^63; sigma_B := 2^(-1); sigma_C := 2^(-65).
// 
// Tmp_C := fmpy.fpsr3( x, p_1 );
// If Tmp_C >= sigma_C then
//    C_hi := Tmp_C;
//    C_lo := x*p_1 - C_hi ...fma, exact
// Else
//    C_hi := fadd.fpsr3(sigma_C, Tmp_C) - sigma_C
// 			...subtraction is exact, regardless
// 			...of rounding direction
//    C_lo := x*p_1 - C_hi ...fma, exact
// End If
// 
// Tmp_B := fmpy.fpsr3( x, p_2 );
// If Tmp_B >= sigma_B then
//    B_hi := Tmp_B;
//    B_lo := x*p_2 - B_hi ...fma, exact
// Else
//    B_hi := fadd.fpsr3(sigma_B, Tmp_B) - sigma_B
// 			...subtraction is exact, regardless
// 			...of rounding direction
//    B_lo := x*p_2 - B_hi ...fma, exact
// End If
// 
// Tmp_A := fmpy.fpsr3( x, p_3 );
// If Tmp_A >= sigma_A then
//    A_hi := Tmp_A;
//    A_lo := x*p_3 - A_hi ...fma, exact
// Else
//    A_hi := fadd.fpsr3(sigma_A, Tmp_A) - sigma_A
// 			...subtraction is exact, regardless
// 			...of rounding direction
//    A_lo := x*p_3 - A_hi ...fma, exact
// End If
// 
// ...Note that C_hi is of integer value. We need only the
// ...last few bits. Thus we can ensure C_hi is never a big 
// ...integer, freeing us from overflow worry.
// 
// Tmp_C := fadd.fpsr3( C_hi, 2^(70) ) - 2^(70);
// ...Tmp_C is the upper portion of C_hi
// C_hi := C_hi - Tmp_C
// ...0 <= C_hi < 2^7
// 
// Step 2. Get N and f
// -------------------
// 
// At this point, we have all the components to obtain 
// S_0, S_1, S_2, S_3 and thus N and f. We start by adding
// C_lo and B_hi. This sum together with C_hi gives a good
// estimation of N and f. 
// 
// A := fadd.fpsr3( B_hi, C_lo )
// B := max( B_hi, C_lo )
// b := min( B_hi, C_lo )
// 
// a := (B - A) + b	...exact. Note that a is either 0
// 			...or 2^(-64).
// 
// N := round_to_nearest_integer_value( A );
// f := A - N;		...exact because lsb(A) >= 2^(-64)
// 			...and |f| <= 1/2.
// 
// f := f + a		...exact because a is 0 or 2^(-64);
// 			...the msb of the sum is <= 1/2
// 			...lsb >= 2^(-64).
// 
// N := convert to integer format( C_hi + N );
// M := P_0 * x_lo;
// N := N + M;
// 
// If sgn_x == 1 (that is original x was negative)
// N := 2^10 - N
// ...this maintains N to be non-negative, but still
// ...equivalent to the (negated N) mod 4.
// End If
// 
// If |f| >= 2^(-33)
// 
// ...Case 1
// CASE := 1
// g := A_hi + B_lo;
// s_hi := f + g;
// s_lo := (f - s_hi) + g;
// 
// Else
// 
// ...Case 2
// CASE := 2
// A := fadd.fpsr3( A_hi, B_lo )
// B := max( A_hi, B_lo )
// b := min( A_hi, B_lo )
// 
// a := (B - A) + b	...exact. Note that a is either 0
// 			...or 2^(-128).
// 
// f_hi := A + f;
// f_lo := (f - f_hi) + A;
// ...this is exact.
// ...f-f_hi is exact because either |f| >= |A|, in which
// ...case f-f_hi is clearly exact; or otherwise, 0<|f|<|A|
// ...means msb(f) <= msb(A) = 2^(-64) => |f| = 2^(-64).
// ...If f = 2^(-64), f-f_hi involves cancellation and is
// ...exact. If f = -2^(-64), then A + f is exact. Hence
// ...f-f_hi is -A exactly, giving f_lo = 0.
// 
// f_lo := f_lo + a;
// 
// If |f| >= 2^(-50) then
//    s_hi := f_hi;
//    s_lo := f_lo;
// Else
//    f_lo := (f_lo + A_lo) + x*p_4
//    s_hi := f_hi + f_lo
//    s_lo := (f_hi - s_hi) + f_lo
// End If
// 
// End If
// 
// Step 3. Get reduced argument
// ----------------------------
// 
// If sgn_x == 0 (that is original x is positive)
// 
// D_hi := Pi_by_2_hi
// D_lo := Pi_by_2_lo
// ...load from table
// 
// Else
// 
// D_hi := neg_Pi_by_2_hi
// D_lo := neg_Pi_by_2_lo
// ...load from table
// End If
// 
// r_hi :=  s_hi*D_hi
// r_lo :=  s_hi*D_hi - r_hi   	...fma
// r_lo := (s_hi*D_lo + r_lo) + s_lo*D_hi
// 
// Return  CASE, N, r_hi, r_lo
// 
FR_X       = f32 
FR_N       = f33 
FR_p_1     = f34 
FR_TWOM33  = f35 
FR_TWOM50  = f36 
FR_g       = f37 
FR_p_2     = f38 
FR_f       = f39 
FR_s_lo    = f40 
FR_p_3     = f41 
FR_f_abs   = f42 
FR_D_lo    = f43 
FR_p_4     = f44 
FR_D_hi    = f45 
FR_Tmp2_C  = f46 
FR_s_hi    = f47 
FR_sigma_A = f48 
FR_A       = f49 
FR_sigma_B = f50 
FR_B       = f51 
FR_sigma_C = f52 
FR_b       = f53 
FR_ScaleP2 = f54 
FR_ScaleP3 = f55 
FR_ScaleP4 = f56 
FR_Tmp_A   = f57 
FR_Tmp_B   = f58 
FR_Tmp_C   = f59 
FR_A_hi    = f60 
FR_f_hi    = f61 
FR_r_hi    = f62 
FR_A_lo    = f63 
FR_B_hi    = f64 
FR_a       = f65 
FR_B_lo    = f66 
FR_f_lo    = f67
FR_r_lo    = f68 
FR_C_hi    = f69 
FR_C_lo    = f70 

GR_N       = r8
GR_Address_of_Input  = r32 
GR_Address_of_Outputs = r33 
GR_Exp_x   = r36 
GR_Temp    = r37 
GR_BIASL63 = r38 
GR_CASE    = r39
GR_x_lo    = r40 
GR_sgn_x   = r41 
GR_M       = r42
GR_BASE    = r43
GR_LENGTH1 = r44
GR_LENGTH2 = r45
GR_ASUB    = r46
GR_P_0     = r47
GR_P_1     = r48 
GR_P_2     = r49 
GR_P_3     = r50 
GR_P_4     = r51 
GR_START   = r52
GR_SEGMENT = r53
GR_A       = r54
GR_B       = r55 
GR_C       = r56
GR_D       = r57
GR_E       = r58
GR_TEMP1   = r59 
GR_TEMP2   = r60 
GR_TEMP3   = r61 
GR_TEMP4   = r62 
GR_TEMP5   = r63
GR_TEMP6   = r64

.align 64

.data

Constants_Bits_of_2_by_pi:
data8 0x0000000000000000,0xA2F9836E4E441529
data8 0xFC2757D1F534DDC0,0xDB6295993C439041
data8 0xFE5163ABDEBBC561,0xB7246E3A424DD2E0
data8 0x06492EEA09D1921C,0xFE1DEB1CB129A73E
data8 0xE88235F52EBB4484,0xE99C7026B45F7E41
data8 0x3991D639835339F4,0x9C845F8BBDF9283B
data8 0x1FF897FFDE05980F,0xEF2F118B5A0A6D1F
data8 0x6D367ECF27CB09B7,0x4F463F669E5FEA2D
data8 0x7527BAC7EBE5F17B,0x3D0739F78A5292EA
data8 0x6BFB5FB11F8D5D08,0x56033046FC7B6BAB
data8 0xF0CFBC209AF4361D,0xA9E391615EE61B08
data8 0x6599855F14A06840,0x8DFFD8804D732731
data8 0x06061556CA73A8C9,0x60E27BC08C6B47C4
data8 0x19C367CDDCE8092A,0x8359C4768B961CA6
data8 0xDDAF44D15719053E,0xA5FF07053F7E33E8
data8 0x32C2DE4F98327DBB,0xC33D26EF6B1E5EF8
data8 0x9F3A1F35CAF27F1D,0x87F121907C7C246A
data8 0xFA6ED5772D30433B,0x15C614B59D19C3C2
data8 0xC4AD414D2C5D000C,0x467D862D71E39AC6
data8 0x9B0062337CD2B497,0xA7B4D55537F63ED7
data8 0x1810A3FC764D2A9D,0x64ABD770F87C6357
data8 0xB07AE715175649C0,0xD9D63B3884A7CB23
data8 0x24778AD623545AB9,0x1F001B0AF1DFCE19
data8 0xFF319F6A1E666157,0x9947FBACD87F7EB7
data8 0x652289E83260BFE6,0xCDC4EF09366CD43F
data8 0x5DD7DE16DE3B5892,0x9BDE2822D2E88628
data8 0x4D58E232CAC616E3,0x08CB7DE050C017A7
data8 0x1DF35BE01834132E,0x6212830148835B8E
data8 0xF57FB0ADF2E91E43,0x4A48D36710D8DDAA
data8 0x425FAECE616AA428,0x0AB499D3F2A6067F
data8 0x775C83C2A3883C61,0x78738A5A8CAFBDD7
data8 0x6F63A62DCBBFF4EF,0x818D67C12645CA55
data8 0x36D9CAD2A8288D61,0xC277C9121426049B
data8 0x4612C459C444C5C8,0x91B24DF31700AD43
data8 0xD4E5492910D5FDFC,0xBE00CC941EEECE70
data8 0xF53E1380F1ECC3E7,0xB328F8C79405933E
data8 0x71C1B3092EF3450B,0x9C12887B20AB9FB5
data8 0x2EC292472F327B6D,0x550C90A7721FE76B
data8 0x96CB314A1679E279,0x4189DFF49794E884
data8 0xE6E29731996BED88,0x365F5F0EFDBBB49A
data8 0x486CA46742727132,0x5D8DB8159F09E5BC
data8 0x25318D3974F71C05,0x30010C0D68084B58
data8 0xEE2C90AA4702E774,0x24D6BDA67DF77248
data8 0x6EEF169FA6948EF6,0x91B45153D1F20ACF
data8 0x3398207E4BF56863,0xB25F3EDD035D407F
data8 0x8985295255C06437,0x10D86D324832754C
data8 0x5BD4714E6E5445C1,0x090B69F52AD56614
data8 0x9D072750045DDB3B,0xB4C576EA17F9877D
data8 0x6B49BA271D296996,0xACCCC65414AD6AE2
data8 0x9089D98850722CBE,0xA4049407777030F3
data8 0x27FC00A871EA49C2,0x663DE06483DD9797
data8 0x3FA3FD94438C860D,0xDE41319D39928C70
data8 0xDDE7B7173BDF082B,0x3715A0805C93805A
data8 0x921110D8E80FAF80,0x6C4BFFDB0F903876
data8 0x185915A562BBCB61,0xB989C7BD401004F2
data8 0xD2277549F6B6EBBB,0x22DBAA140A2F2689
data8 0x768364333B091A94,0x0EAA3A51C2A31DAE
data8 0xEDAF12265C4DC26D,0x9C7A2D9756C0833F
data8 0x03F6F0098C402B99,0x316D07B43915200C
data8 0x5BC3D8C492F54BAD,0xC6A5CA4ECD37A736
data8 0xA9E69492AB6842DD,0xDE6319EF8C76528B
data8 0x6837DBFCABA1AE31,0x15DFA1AE00DAFB0C
data8 0x664D64B705ED3065,0x29BF56573AFF47B9
data8 0xF96AF3BE75DF9328,0x3080ABF68C6615CB
data8 0x040622FA1DE4D9A4,0xB33D8F1B5709CD36
data8 0xE9424EA4BE13B523,0x331AAAF0A8654FA5
data8 0xC1D20F3F0BCD785B,0x76F923048B7B7217
data8 0x8953A6C6E26E6F00,0xEBEF584A9BB7DAC4
data8 0xBA66AACFCF761D02,0xD12DF1B1C1998C77
data8 0xADC3DA4886A05DF7,0xF480C62FF0AC9AEC
data8 0xDDBC5C3F6DDED01F,0xC790B6DB2A3A25A3
data8 0x9AAF009353AD0457,0xB6B42D297E804BA7
data8 0x07DA0EAA76A1597B,0x2A12162DB7DCFDE5
data8 0xFAFEDB89FDBE896C,0x76E4FCA90670803E
data8 0x156E85FF87FD073E,0x2833676186182AEA
data8 0xBD4DAFE7B36E6D8F,0x3967955BBF3148D7
data8 0x8416DF30432DC735,0x6125CE70C9B8CB30
data8 0xFD6CBFA200A4E46C,0x05A0DD5A476F21D2
data8 0x1262845CB9496170,0xE0566B0152993755
data8 0x50B7D51EC4F1335F,0x6E13E4305DA92E85
data8 0xC3B21D3632A1A4B7,0x08D4B1EA21F716E4
data8 0x698F77FF2780030C,0x2D408DA0CD4F99A5
data8 0x20D3A2B30A5D2F42,0xF9B4CBDA11D0BE7D
data8 0xC1DB9BBD17AB81A2,0xCA5C6A0817552E55
data8 0x0027F0147F8607E1,0x640B148D4196DEBE
data8 0x872AFDDAB6256B34,0x897BFEF3059EBFB9
data8 0x4F6A68A82A4A5AC4,0x4FBCF82D985AD795
data8 0xC7F48D4D0DA63A20,0x5F57A4B13F149538
data8 0x800120CC86DD71B6,0xDEC9F560BF11654D
data8 0x6B0701ACB08CD0C0,0xB24855510EFB1EC3
data8 0x72953B06A33540C0,0x7BDC06CC45E0FA29
data8 0x4EC8CAD641F3E8DE,0x647CD8649B31BED9
data8 0xC397A4D45877C5E3,0x6913DAF03C3ABA46
data8 0x18465F7555F5BDD2,0xC6926E5D2EACED44
data8 0x0E423E1C87C461E9,0xFD29F3D6E7CA7C22
data8 0x35916FC5E0088DD7,0xFFE26A6EC6FDB0C1
data8 0x0893745D7CB2AD6B,0x9D6ECD7B723E6A11
data8 0xC6A9CFF7DF7329BA,0xC9B55100B70DB2E2
data8 0x24BA74607DE58AD8,0x742C150D0C188194
data8 0x667E162901767A9F,0xBEFDFDEF4556367E
data8 0xD913D9ECB9BA8BFC,0x97C427A831C36EF1
data8 0x36C59456A8D8B5A8,0xB40ECCCF2D891234
data8 0x576F89562CE3CE99,0xB920D6AA5E6B9C2A
data8 0x3ECC5F114A0BFDFB,0xF4E16D3B8E2C86E2
data8 0x84D4E9A9B4FCD1EE,0xEFC9352E61392F44
data8 0x2138C8D91B0AFC81,0x6A4AFBD81C2F84B4
data8 0x538C994ECC2254DC,0x552AD6C6C096190B
data8 0xB8701A649569605A,0x26EE523F0F117F11
data8 0xB5F4F5CBFC2DBC34,0xEEBC34CC5DE8605E
data8 0xDD9B8E67EF3392B8,0x17C99B5861BC57E1
data8 0xC68351103ED84871,0xDDDD1C2DA118AF46
data8 0x2C21D7F359987AD9,0xC0549EFA864FFC06
data8 0x56AE79E536228922,0xAD38DC9367AAE855
data8 0x3826829BE7CAA40D,0x51B133990ED7A948
data8 0x0569F0B265A7887F,0x974C8836D1F9B392
data8 0x214A827B21CF98DC,0x9F405547DC3A74E1
data8 0x42EB67DF9DFE5FD4,0x5EA4677B7AACBAA2
data8 0xF65523882B55BA41,0x086E59862A218347
data8 0x39E6E389D49EE540,0xFB49E956FFCA0F1C
data8 0x8A59C52BFA94C5C1,0xD3CFC50FAE5ADB86
data8 0xC5476243853B8621,0x94792C8761107B4C
data8 0x2A1A2C8012BF4390,0x2688893C78E4C4A8
data8 0x7BDBE5C23AC4EAF4,0x268A67F7BF920D2B
data8 0xA365B1933D0B7CBD,0xDC51A463DD27DDE1
data8 0x6919949A9529A828,0xCE68B4ED09209F44
data8 0xCA984E638270237C,0x7E32B90F8EF5A7E7
data8 0x561408F1212A9DB5,0x4D7E6F5119A5ABF9
data8 0xB5D6DF8261DD9602,0x36169F3AC4A1A283
data8 0x6DED727A8D39A9B8,0x825C326B5B2746ED
data8 0x34007700D255F4FC,0x4D59018071E0E13F
data8 0x89B295F364A8F1AE,0xA74B38FC4CEAB2BB

Constants_Bits_of_pi_by_2:
data4 0x2168C234,0xC90FDAA2,0x00003FFF,0x00000000
data4 0x80DC1CD1,0xC4C6628B,0x00003FBF,0x00000000

.section .text
.proc __libm_pi_by_2_reduce#
.global __libm_pi_by_2_reduce#
.align 64 

__libm_pi_by_2_reduce: 

//    X is at the address in Address_of_Input
//    Place the two-piece result at the address in Address_of_Outputs
//    r followed by c
//    N is returned

{ .mmf
alloc  r34 = ar.pfs,2,34,0,0
(p0)  ldfe  FR_X = [GR_Address_of_Input]
(p0)  fsetc.s3 0x00,0x7F ;;
}
{ .mlx
	nop.m 999
(p0)  movl GR_BIASL63 = 0x1003E
}
;;


//    L         -1-2-3-4
//    0 0 0 0 0. 1 0 1 0
//    M          0 1 2 .... 63, 64 65 ... 127, 128
//     ---------------------------------------------
//    Segment 0.        1     ,      2       ,    3
//    START = M - 63                        M = 128 becomes 65
//    LENGTH1  = START & 0x3F               65 become position 1
//    SEGMENT  = shr(START,6) + 1      0 maps to 1,   64 maps to 2,
//    LENGTH2  = 64 - LENGTH1
//    Address_BASE = shladd(SEGMENT,3) + BASE



{ .mmi
      nop.m 999
(p0)  addl           GR_BASE   = @ltoff(Constants_Bits_of_2_by_pi#), gp
      nop.i 999
}
;;

{ .mmi
      ld8 GR_BASE = [GR_BASE]
      nop.m 999
      nop.i 999
}
;;


{ .mlx
	nop.m 999
(p0)  movl GR_TEMP5 = 0x000000000000FFFE
}
{ .mmi
	nop.m 999 ;;
(p0)  setf.exp FR_sigma_B = GR_TEMP5
	nop.i 999
}
{ .mlx
	nop.m 999
(p0)  movl GR_TEMP6 = 0x000000000000FFBE ;;
}
//    Define sigma_C := 2^63; sigma_B := 2^(-1); sigma_A := 2^(-65).
{ .mfi
(p0)  setf.exp FR_sigma_A = GR_TEMP6
	nop.f 999
	nop.i 999 ;;
}
//    Special Code for testing DE arguments 
//    (p0)  movl GR_BIASL63 = 0x0000000000013FFE
//    (p0)  movl GR_x_lo = 0xFFFFFFFFFFFFFFFF
//    (p0)  setf.exp FR_X = GR_BIASL63
//    (p0)  setf.sig FR_ScaleP3 = GR_x_lo
//    (p0)  fmerge.se FR_X = FR_X,FR_ScaleP3
//    Set sgn_x := sign(x); x := |x|; x_lo := 2 lsb of x.
//    2/pi is stored contigously as
//    0x00000000 0x00000000.0xA2F....
//    M = EXP - BIAS  ( M >= 63)
//    Given x = 2^m * 1.xxxx...xxx; we calculate L := 62 - m.
//    Thus -1 <= L <= -16321.
{ .mmf
(p0)  getf.exp GR_Exp_x = FR_X
(p0)  getf.sig GR_x_lo = FR_X
(p0)  fabs FR_X = FR_X ;;
}
{ .mii
(p0)  and  GR_x_lo = 0x03,GR_x_lo
(p0)  extr.u GR_M = GR_Exp_x,0,17 ;;
(p0)  sub  GR_START = GR_M,GR_BIASL63
}
{ .mmi
	nop.m 999 ;;
(p0)  and  GR_LENGTH1 = 0x3F,GR_START
(p0)  shr.u  GR_SEGMENT = GR_START,6
}
{ .mmi
	nop.m 999 ;;
(p0)  add  GR_SEGMENT = 0x1,GR_SEGMENT
(p0)  sub  GR_LENGTH2 = 0x40,GR_LENGTH1
}
//    P_0 is the two bits corresponding to bit positions L+2 and L+1
//    P_1 is the 64-bit starting at bit position  L
//    P_2 is the 64-bit starting at bit position  L-64
//    P_3 is the 64-bit starting at bit position  L-128
//    P_4 is the 64-bit starting at bit position  L-192
//    P_1 is made up of Alo and Bhi
//    P_1 = deposit Alo, position 0, length2  into P_1,position length1
//          deposit Bhi, position length2, length1 into P_1, position 0
//    P_2 is made up of Blo and Chi
//    P_2 = deposit Blo, position 0, length2  into P_2, position length1
//          deposit Chi, position length2, length1 into P_2, position 0
//    P_3 is made up of Clo and Dhi
//    P_3 = deposit Clo, position 0, length2  into P_3, position length1
//          deposit Dhi, position length2, length1 into P_3, position 0
//    P_4 is made up of Clo and Dhi
//    P_4 = deposit Dlo, position 0, length2  into P_4, position length1
//          deposit Ehi, position length2, length1 into P_4, position 0
{ .mmi
(p0)  cmp.le.unc p6,p7 = 0x2,GR_LENGTH1 ;;
(p0)  shladd GR_BASE = GR_SEGMENT,3,GR_BASE
(p7)  cmp.eq.unc p8,p9 = 0x1,GR_LENGTH1 ;;
}
{ .mmi
	nop.m 999
//    ld_64 A at Base and increment Base by 8
//    ld_64 B at Base and increment Base by 8
//    ld_64 C at Base and increment Base by 8
//    ld_64 D at Base and increment Base by 8
//    ld_64 E at Base and increment Base by 8
//                                          A/B/C/D
//                                    ---------------------
//    A, B, C, D, and E look like    | length1 | length2   |
//                                    ---------------------
//                                       hi        lo
(p0)  ld8 GR_A = [GR_BASE],8
(p0)  extr.u GR_sgn_x = GR_Exp_x,17,1 ;;
}
{ .mmf
	nop.m 999
(p0)  ld8 GR_B = [GR_BASE],8
(p0)  fmerge.se FR_X = FR_sigma_B,FR_X ;;
}
{ .mii
(p0)  ld8 GR_C = [GR_BASE],8
(p8)  extr.u GR_Temp = GR_A,63,1 ;;
(p0)  shl GR_TEMP1 = GR_A,GR_LENGTH1
}
{ .mii
(p0)  ld8 GR_D = [GR_BASE],8
//    If length1 >= 2,
//       P_0 = deposit Ahi, position length2, 2 bit into P_0 at position 0.
(p6)     shr.u GR_P_0 = GR_A,GR_LENGTH2 ;;
(p0)  shl GR_TEMP2 = GR_B,GR_LENGTH1
}
{ .mii
(p0)  ld8 GR_E = [GR_BASE],-40
(p0)  shr.u GR_P_1 = GR_B,GR_LENGTH2 ;;
(p0)  shr.u GR_P_2 = GR_C,GR_LENGTH2
}
//    Else
//       Load 16 bit of ASUB from (Base_Address_of_A - 2)
//       P_0 = ASUB & 0x3
//       If length1 == 0,
//          P_0 complete
//       Else
//          Deposit element 63 from Ahi and place in element 0 of P_0.
//       Endif
//    Endif
{ .mii
(p7)  ld2 GR_ASUB = [GR_BASE],8
(p0)  shl GR_TEMP3 = GR_C,GR_LENGTH1 ;;
(p0)  shl GR_TEMP4 = GR_D,GR_LENGTH1
}
{ .mii
	nop.m 999
(p0)  shr.u GR_P_3 = GR_D,GR_LENGTH2 ;;
(p0)  shr.u GR_P_4 = GR_E,GR_LENGTH2
}
{ .mii
(p7)  and GR_P_0 = 0x03,GR_ASUB
(p6)     and GR_P_0 = 0x03,GR_P_0 ;;
(p0)  or GR_P_1 = GR_P_1,GR_TEMP1
}
{ .mmi
(p8)  and GR_P_0 = 0x1,GR_P_0 ;;
(p0)  or GR_P_2 = GR_P_2,GR_TEMP2
(p8)  shl GR_P_0 = GR_P_0,0x1 ;;
}
{ .mii
	nop.m 999
(p0)  or GR_P_3 = GR_P_3,GR_TEMP3
(p8)  or GR_P_0 = GR_P_0,GR_Temp
}
{ .mmi
(p0)  setf.sig FR_p_1 = GR_P_1 ;;
(p0)  setf.sig FR_p_2 = GR_P_2
(p0)  or GR_P_4 = GR_P_4,GR_TEMP4 ;;
}
{ .mmi
	nop.m 999 ;;
(p0)  setf.sig FR_p_3 = GR_P_3
(p0)  pmpy2.r GR_M = GR_P_0,GR_x_lo
}
{ .mlx
(p0)  setf.sig FR_p_4 = GR_P_4
//    P_1, P_2, P_3, P_4 are integers. They should be
//    2^(L-63)     * P_1;
//    2^(L-63-64)  * P_2;
//    2^(L-63-128) * P_3;
//    2^(L-63-192) * P_4;
//    Since each of them need to be multiplied to x, we would scale
//    both x and the P_j's by some convenient factors: scale each
//    of P_j's up by 2^(63-L), and scale x down by 2^(L-63).
//    p_1 := fcvt.xf ( P_1 )
//    p_2 := fcvt.xf ( P_2 ) * 2^(-64)
//    p_3 := fcvt.xf ( P_3 ) * 2^(-128)
//    p_4 := fcvt.xf ( P_4 ) * 2^(-192)
//    x= Set x's exp to -1 because 2^m*1.x...x *2^(L-63)=2^(-1)*1.x...xxx
//             ---------   ---------   ---------
//             |  P_1  |   |  P_2  |   |  P_3  |
//             ---------   ---------   ---------
//                                           ---------
//	      X                              |   X   |
//	                                     ---------
//      ----------------------------------------------------
//                               ---------   ---------
//	                         |  A_hi |   |  A_lo |
//	                         ---------   ---------
//                   ---------   ---------
//	             |  B_hi |   |  B_lo |
//	             ---------   ---------
//       ---------   ---------
//	 |  C_hi |   |  C_lo |
//	 ---------   ---------
//     ====================================================
//    -----------   ---------   ---------   ---------
//    |    S_0  |   |  S_1  |   |  S_2  |   |  S_3  |
//    -----------   ---------   ---------   ---------
//    |            |___ binary point
//    |___ possibly one more bit
//
//    Let FPSR3 be set to round towards zero with widest precision
//    and exponent range. Unless an explicit FPSR is given,
//    round-to-nearest with widest precision and exponent range is
//    used.
(p0)  movl GR_TEMP1 = 0x000000000000FFBF
}
{ .mmi
	nop.m 999 ;;
(p0)  setf.exp FR_ScaleP2 = GR_TEMP1
	nop.i 999
}
{ .mlx
	nop.m 999
(p0)  movl GR_TEMP4 = 0x000000000001003E
}
{ .mmi
	nop.m 999 ;;
(p0)  setf.exp FR_sigma_C = GR_TEMP4
	nop.i 999
}
{ .mlx
	nop.m 999
(p0)  movl GR_TEMP2 = 0x000000000000FF7F ;;
}
{ .mmf
	nop.m 999
(p0)  setf.exp FR_ScaleP3 = GR_TEMP2
(p0)  fcvt.xuf.s1 FR_p_1 = FR_p_1 ;;
}
{ .mfi
	nop.m 999
(p0)  fcvt.xuf.s1 FR_p_2 = FR_p_2
	nop.i 999
}
{ .mlx
	nop.m 999
(p0)  movl GR_Temp = 0x000000000000FFDE ;;
}
{ .mmf
	nop.m 999
(p0)  setf.exp FR_TWOM33 = GR_Temp
(p0)  fcvt.xuf.s1 FR_p_3 = FR_p_3 ;;
}
{ .mfi
	nop.m 999
(p0)  fcvt.xuf.s1 FR_p_4 = FR_p_4
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
//    Tmp_C := fmpy.fpsr3( x, p_1 );
//    Tmp_B := fmpy.fpsr3( x, p_2 );
//    Tmp_A := fmpy.fpsr3( x, p_3 );
//    If Tmp_C >= sigma_C then
//      C_hi := Tmp_C;
//      C_lo := x*p_1 - C_hi ...fma, exact
//    Else
//      C_hi := fadd.fpsr3(sigma_C, Tmp_C) - sigma_C
//      C_lo := x*p_1 - C_hi ...fma, exact
//    End If
//    If Tmp_B >= sigma_B then
//      B_hi := Tmp_B;
//      B_lo := x*p_2 - B_hi ...fma, exact
//    Else
//      B_hi := fadd.fpsr3(sigma_B, Tmp_B) - sigma_B
//      B_lo := x*p_2 - B_hi ...fma, exact
//    End If
//    If Tmp_A >= sigma_A then
//      A_hi := Tmp_A;
//      A_lo := x*p_3 - A_hi ...fma, exact
//    Else
//      A_hi := fadd.fpsr3(sigma_A, Tmp_A) - sigma_A
//      Exact, regardless ...of rounding direction
//      A_lo := x*p_3 - A_hi ...fma, exact
//    Endif
(p0)  fmpy.s3 FR_Tmp_C = FR_X,FR_p_1
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p0)  fmpy.s1 FR_p_2 = FR_p_2,FR_ScaleP2
	nop.i 999
}
{ .mlx
	nop.m 999
(p0)  movl GR_Temp = 0x0000000000000400
}
{ .mlx
	nop.m 999
(p0)  movl GR_TEMP3 = 0x000000000000FF3F ;;
}
{ .mmf
	nop.m 999
(p0)  setf.exp FR_ScaleP4 = GR_TEMP3
(p0)  fmpy.s1 FR_p_3 = FR_p_3,FR_ScaleP3 ;;
}
{ .mlx
	nop.m 999
(p0)  movl GR_TEMP4 = 0x0000000000010045 ;;
}
{ .mmf
	nop.m 999
(p0)  setf.exp FR_Tmp2_C = GR_TEMP4
(p0)  fmpy.s3 FR_Tmp_B = FR_X,FR_p_2 ;;
}
{ .mfi
	nop.m 999
(p0)  fcmp.ge.unc.s1 p12,  p9 = FR_Tmp_C,FR_sigma_C
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p0)  fmpy.s3 FR_Tmp_A = FR_X,FR_p_3
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p12) mov FR_C_hi = FR_Tmp_C
	nop.i 999 ;;
}
{ .mfi
(p0)  addl           GR_BASE   = @ltoff(Constants_Bits_of_pi_by_2#), gp
(p9)  fadd.s3 FR_C_hi = FR_sigma_C,FR_Tmp_C
	nop.i 999
}
;;



//   End If
//   Step 3. Get reduced argument
//   If sgn_x == 0 (that is original x is positive)
//      D_hi := Pi_by_2_hi
//      D_lo := Pi_by_2_lo
//      Load from table
//   Else
//      D_hi := neg_Pi_by_2_hi
//      D_lo := neg_Pi_by_2_lo
//      Load from table
//   End If


{ .mmi
      ld8 GR_BASE = [GR_BASE]
      nop.m 999
      nop.i 999
}
;;


{ .mfi
(p0) ldfe FR_D_hi = [GR_BASE],16
(p0)  fmpy.s1 FR_p_4 = FR_p_4,FR_ScaleP4
	nop.i 999 ;;
}
{ .mfi
(p0) ldfe FR_D_lo = [GR_BASE],0
(p0)  fcmp.ge.unc.s1 p13, p10 = FR_Tmp_B,FR_sigma_B
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p13) mov FR_B_hi = FR_Tmp_B
	nop.i 999
}
{ .mfi
	nop.m 999
(p12) fms.s1 FR_C_lo = FR_X,FR_p_1,FR_C_hi
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p10) fadd.s3 FR_B_hi = FR_sigma_B,FR_Tmp_B
	nop.i 999
}
{ .mfi
	nop.m 999
(p9)  fsub.s1 FR_C_hi = FR_C_hi,FR_sigma_C
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p0)  fcmp.ge.unc.s1 p14, p11 = FR_Tmp_A,FR_sigma_A
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p14) mov FR_A_hi = FR_Tmp_A
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p11) fadd.s3 FR_A_hi = FR_sigma_A,FR_Tmp_A
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p9)  fms.s1 FR_C_lo = FR_X,FR_p_1,FR_C_hi
(p0)  cmp.eq.unc p12,p9 = 0x1,GR_sgn_x
}
{ .mfi
	nop.m 999
(p13) fms.s1 FR_B_lo = FR_X,FR_p_2,FR_B_hi
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p10) fsub.s1 FR_B_hi = FR_B_hi,FR_sigma_B
	nop.i 999
}
{ .mfi
	nop.m 999
//    Note that C_hi is of integer value. We need only the
//    last few bits. Thus we can ensure C_hi is never a big
//    integer, freeing us from overflow worry.
//    Tmp_C := fadd.fpsr3( C_hi, 2^(70) ) - 2^(70);
//    Tmp_C is the upper portion of C_hi
(p0)  fadd.s3 FR_Tmp_C = FR_C_hi,FR_Tmp2_C
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p14) fms.s1 FR_A_lo = FR_X,FR_p_3,FR_A_hi
	nop.i 999
}
{ .mfi
	nop.m 999
(p11) fsub.s1 FR_A_hi = FR_A_hi,FR_sigma_A
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
//    *******************
//    Step 2. Get N and f
//    *******************
//    We have all the components to obtain
//    S_0, S_1, S_2, S_3 and thus N and f. We start by adding
//    C_lo and B_hi. This sum together with C_hi estimates
//    N and f well.
//    A := fadd.fpsr3( B_hi, C_lo )
//    B := max( B_hi, C_lo )
//    b := min( B_hi, C_lo )
(p0)  fadd.s3 FR_A = FR_B_hi,FR_C_lo
	nop.i 999
}
{ .mfi
	nop.m 999
(p10) fms.s1 FR_B_lo = FR_X,FR_p_2,FR_B_hi
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p0)  fsub.s1 FR_Tmp_C = FR_Tmp_C,FR_Tmp2_C
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p0)  fmax.s1 FR_B = FR_B_hi,FR_C_lo
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p0)  fmin.s1 FR_b = FR_B_hi,FR_C_lo
	nop.i 999
}
{ .mfi
	nop.m 999
(p11) fms.s1 FR_A_lo = FR_X,FR_p_3,FR_A_hi
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
//    N := round_to_nearest_integer_value( A );
(p0)  fcvt.fx.s1 FR_N = FR_A
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
//    C_hi := C_hi - Tmp_C ...0 <= C_hi < 2^7
(p0)  fsub.s1 FR_C_hi = FR_C_hi,FR_Tmp_C
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
//    a := (B - A) + b: Exact - note that a is either 0 or 2^(-64).
(p0)  fsub.s1 FR_a = FR_B,FR_A
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
//    f := A - N; Exact because lsb(A) >= 2^(-64) and |f| <= 1/2.
(p0)  fnorm.s1 FR_N = FR_N
	nop.i 999
}
{ .mfi
	nop.m 999
(p0)  fadd.s1 FR_a = FR_a,FR_b
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p0)  fsub.s1 FR_f = FR_A,FR_N
	nop.i 999
}
{ .mfi
	nop.m 999
//    N := convert to integer format( C_hi + N );
//    M := P_0 * x_lo;
//    N := N + M;
(p0)  fadd.s1 FR_N = FR_N,FR_C_hi
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
//    f = f + a	Exact because a is 0 or 2^(-64);
//    the msb of the sum is <= 1/2 and lsb >= 2^(-64).
(p0)  fadd.s1 FR_f = FR_f,FR_a
	nop.i 999
}
{ .mfi
	nop.m 999
//
//    Create 2**(-33)
//
(p0)  fcvt.fx.s1 FR_N = FR_N
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p0)  fabs FR_f_abs = FR_f
	nop.i 999 ;;
}
{ .mfi
(p0)  getf.sig GR_N = FR_N
	nop.f 999
	nop.i 999 ;;
}
{ .mii
	nop.m 999
	nop.i 999 ;;
(p0)  add GR_N = GR_N,GR_M ;;
}
//    If sgn_x == 1 (that is original x was negative)
//       N := 2^10 - N
//       this maintains N to be non-negative, but still
//       equivalent to the (negated N) mod 4.
//    End If
{ .mii
(p12) sub GR_N = GR_Temp,GR_N
(p0) cmp.eq.unc p12,p9 = 0x0,GR_sgn_x ;;
	nop.i 999
}
{ .mfi
	nop.m 999
(p0)  fcmp.ge.unc.s1 p13, p10 = FR_f_abs,FR_TWOM33
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p9) fsub.s1 FR_D_hi = f0, FR_D_hi
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p10)    fadd.s3 FR_A = FR_A_hi,FR_B_lo
	nop.i 999
}
{ .mfi
	nop.m 999
(p13)    fadd.s1 FR_g = FR_A_hi,FR_B_lo
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p10)    fmax.s1 FR_B = FR_A_hi,FR_B_lo
	nop.i 999
}
{ .mfi
	nop.m 999
(p9) fsub.s1 FR_D_lo = f0, FR_D_lo
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p10)    fmin.s1 FR_b = FR_A_hi,FR_B_lo
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p0) fsetc.s3 0x7F,0x40
	nop.i 999
}
{ .mlx
	nop.m 999
(p10)    movl GR_Temp = 0x000000000000FFCD ;;
}
{ .mmf
	nop.m 999
(p10)    setf.exp FR_TWOM50 = GR_Temp
(p10)    fadd.s1 FR_f_hi = FR_A,FR_f ;;
}
{ .mfi
	nop.m 999
//       a := (B - A) + b	Exact.
//       Note that a is either 0 or 2^(-128).
//       f_hi := A + f;
//       f_lo := (f - f_hi) + A
//       f_lo=f-f_hi is exact because either |f| >= |A|, in which
//       case f-f_hi is clearly exact; or otherwise, 0<|f|<|A|
//       means msb(f) <= msb(A) = 2^(-64) => |f| = 2^(-64).
//       If f = 2^(-64), f-f_hi involves cancellation and is
//       exact. If f = -2^(-64), then A + f is exact. Hence
//       f-f_hi is -A exactly, giving f_lo = 0.
//       f_lo := f_lo + a;
(p10)    fsub.s1 FR_a = FR_B,FR_A
	nop.i 999
}
{ .mfi
	nop.m 999
(p13)    fadd.s1 FR_s_hi = FR_f,FR_g
	nop.i 999 ;;
}
{ .mlx
	nop.m 999
//    If |f| >= 2^(-33)
//       Case 1
//       CASE := 1
//       g := A_hi + B_lo;
//       s_hi := f + g;
//       s_lo := (f - s_hi) + g;
(p13)    movl GR_CASE = 0x1 ;;
}
{ .mlx
	nop.m 999
//   Else
//       Case 2
//       CASE := 2
//       A := fadd.fpsr3( A_hi, B_lo )
//       B := max( A_hi, B_lo )
//       b := min( A_hi, B_lo )
(p10)    movl GR_CASE = 0x2
}
{ .mfi
	nop.m 999
(p10)    fsub.s1 FR_f_lo = FR_f,FR_f_hi
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p10)    fadd.s1 FR_a = FR_a,FR_b
	nop.i 999
}
{ .mfi
	nop.m 999
(p13)    fsub.s1 FR_s_lo = FR_f,FR_s_hi
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p13)    fadd.s1 FR_s_lo = FR_s_lo,FR_g
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p10)    fcmp.ge.unc.s1 p14, p11 = FR_f_abs,FR_TWOM50
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
//
//       Create 2**(-50)
(p10)    fadd.s1 FR_f_lo = FR_f_lo,FR_A
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
//       If |f| >= 2^(-50) then
//          s_hi := f_hi;
//          s_lo := f_lo;
//       Else
//          f_lo := (f_lo + A_lo) + x*p_4
//          s_hi := f_hi + f_lo
//          s_lo := (f_hi - s_hi) + f_lo
//       End If
(p14)  mov FR_s_hi = FR_f_hi
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p10)    fadd.s1 FR_f_lo = FR_f_lo,FR_a
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p14)  mov FR_s_lo = FR_f_lo
	nop.i 999
}
{ .mfi
	nop.m 999
(p11)  fadd.s1 FR_f_lo = FR_f_lo,FR_A_lo
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p11)  fma.s1 FR_f_lo = FR_X,FR_p_4,FR_f_lo
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p11)  fadd.s1 FR_s_hi = FR_f_hi,FR_f_lo
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
//   r_hi :=  s_hi*D_hi
//   r_lo :=  s_hi*D_hi - r_hi  with fma
//   r_lo := (s_hi*D_lo + r_lo) + s_lo*D_hi
(p0) fmpy.s1 FR_r_hi = FR_s_hi,FR_D_hi
	nop.i 999
}
{ .mfi
	nop.m 999
(p11)  fsub.s1 FR_s_lo = FR_f_hi,FR_s_hi
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p0) fms.s1 FR_r_lo = FR_s_hi,FR_D_hi,FR_r_hi
	nop.i 999
}
{ .mfi
	nop.m 999
(p11)  fadd.s1 FR_s_lo = FR_s_lo,FR_f_lo
	nop.i 999 ;;
}
{ .mmi
	nop.m 999 ;;
//   Return  N, r_hi, r_lo
//   We do not return CASE
(p0) stfe [GR_Address_of_Outputs] = FR_r_hi,16
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p0) fma.s1 FR_r_lo = FR_s_hi,FR_D_lo,FR_r_lo
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p0) fma.s1 FR_r_lo = FR_s_lo,FR_D_hi,FR_r_lo
	nop.i 999 ;;
}
{ .mmi
	nop.m 999 ;;
(p0) stfe [GR_Address_of_Outputs] = FR_r_lo,-16
	nop.i 999
}
{ .mib
	nop.m 999
	nop.i 999
(p0) br.ret.sptk   b0 ;;
}

.endp __libm_pi_by_2_reduce
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\libm_support.h ===
//  
// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story, 
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.
//

// History: 02/02/2000 Initial version 
//          2/28/2000 added tags for logb and nextafter
//          3/22/2000 Changes to support _LIB_VERSION variable
//                    and filled some enum gaps. Added support for C99.  
//

#define SIZE_INT_32
#define __MS__

float __libm_frexp_4f( float x, int*  exp);
float __libm_frexp_8f( double x, int*  exp);
double __libm_frexp_4( double x, int*  exp);
double __libm_frexp_8( double x, int*  exp);
void __libm_sincos_pi4(double,double*,double*,int);
void __libm_y0y1(double , double *, double *);
void __libm_j0j1(double , double *, double *);
double __libm_lgamma_kernel(double,int*,int,int);
double __libm_j0(double);
double __libm_j1(double);
double __libm_jn(int,double);
double __libm_y0(double);
double __libm_y1(double);
double __libm_yn(int,double);

extern double rint(double);
extern double sqrt(double);
extern double fabs(double);
extern double log(double);
extern double sin(double);
extern double exp(double);
extern double modf(double, double *);
extern double asinh(double);
extern double acosh(double);
extern double atanh(double);
extern double tanh(double);
extern double erf(double);
extern double erfc(double);
extern double j0(double);
extern double j1(double);
extern double jn(int, double);
extern double y0(double);
extern double y1(double);
extern double yn(int, double);

extern float  fabsf(float);
extern float  asinhf(float);
extern float  acoshf(float);
extern float  atanhf(float);
extern float  tanhf(float);
extern float  erff(float);
extern float  erfcf(float);
extern float  j0f(float);
extern float  j1f(float);
extern float  jnf(int, float);
extern float  y0f(float);
extern float  y1f(float);
extern float  ynf(int, float);

#if !(defined(SIZE_INT_32) || defined(SIZE_INT_64))
    #error integer size not established; define SIZE_INT_32 or SIZE_INT_64
#endif

struct fp64 { /*/ sign:1 exponent:11 significand:52 (implied leading 1)*/
  unsigned lo_significand:32;
  unsigned hi_significand:20;
  unsigned exponent:11;
  unsigned sign:1;
};

#define HI_SIGNIFICAND_LESS(X, HI) ((X)->hi_significand < 0x ## HI)
#define f64abs(x) ((x) < 0.0 ? -(x) : (x))

typedef enum
{
  logl_zero=0,   logl_negative,                  /*  0,  1 */
  log_zero,      log_negative,                   /*  2,  3 */
  logf_zero,     logf_negative,                  /*  4,  5 */
  log10l_zero,   log10l_negative,                /*  6,  7 */
  log10_zero,    log10_negative,                 /*  8,  9 */
  log10f_zero,   log10f_negative,                /* 10, 11 */
  expl_overflow, expl_underflow,                 /* 12, 13 */
  exp_overflow,  exp_underflow,                  /* 14, 15 */
  expf_overflow, expf_underflow,                 /* 16, 17 */
  powl_overflow, powl_underflow,                 /* 18, 19 */
  powl_zero_to_zero,                             /* 20     */
  powl_zero_to_negative,                         /* 21     */
  powl_neg_to_non_integer,                       /* 22     */
  powl_nan_to_zero,                              /* 23     */
  pow_overflow,  pow_underflow,                  /* 24, 25 */
  pow_zero_to_zero,                              /* 26     */ 
  pow_zero_to_negative,                          /* 27     */
  pow_neg_to_non_integer,                        /* 28     */
  pow_nan_to_zero,                               /* 29     */
  powf_overflow, powf_underflow,                 /* 30, 31 */
  powf_zero_to_zero,                             /* 32     */
  powf_zero_to_negative,                         /* 33     */ 
  powf_neg_to_non_integer,                       /* 34     */ 
  powf_nan_to_zero,                              /* 35     */
  atan2l_zero,                                   /* 36     */
  atan2_zero,                                    /* 37     */
  atan2f_zero,                                   /* 38     */
  expm1l_overflow,                               /* 39     */
  expm1l_underflow,                              /* 40     */
  expm1_overflow,                                /* 41     */
  expm1_underflow,                               /* 42     */
  expm1f_overflow,                               /* 43     */
  expm1f_underflow,                              /* 44     */
  hypotl_overflow,                               /* 45     */
  hypot_overflow,                                /* 46     */
  hypotf_overflow,                               /* 47     */
  sqrtl_negative,                                /* 48     */
  sqrt_negative,                                 /* 49     */
  sqrtf_negative,                                /* 50     */
  scalbl_overflow, scalbl_underflow,             /* 51,52  */
  scalb_overflow,  scalb_underflow,              /* 53,54  */
  scalbf_overflow, scalbf_underflow,             /* 55,56  */
  acosl_gt_one, acos_gt_one, acosf_gt_one,       /* 57, 58, 59 */
  asinl_gt_one, asin_gt_one, asinf_gt_one,       /* 60, 61, 62 */
  coshl_overflow, cosh_overflow, coshf_overflow, /* 63, 64, 65 */
  y0l_zero, y0l_negative,y0l_gt_loss,            /* 66, 67, 68 */
  y0_zero, y0_negative,y0_gt_loss,               /* 69, 70, 71 */
  y0f_zero, y0f_negative,y0f_gt_loss,            /* 72, 73, 74 */
  y1l_zero, y1l_negative,y1l_gt_loss,            /* 75, 76, 77 */ 
  y1_zero, y1_negative,y1_gt_loss,               /* 78, 79, 80 */ 
  y1f_zero, y1f_negative,y1f_gt_loss,            /* 81, 82, 83 */ 
  ynl_zero, ynl_negative,ynl_gt_loss,            /* 84, 85, 86 */
  yn_zero, yn_negative,yn_gt_loss,               /* 87, 88, 89 */
  ynf_zero, ynf_negative,ynf_gt_loss,            /* 90, 91, 92 */
  j0l_gt_loss,                                   /* 93 */ 
  j0_gt_loss,                                    /* 94 */
  j0f_gt_loss,                                   /* 95 */
  j1l_gt_loss,                                   /* 96 */
  j1_gt_loss,                                    /* 97 */
  j1f_gt_loss,                                   /* 98 */
  jnl_gt_loss,                                   /* 99 */
  jn_gt_loss,                                    /* 100 */
  jnf_gt_loss,                                   /* 101 */
  lgammal_overflow, lgammal_negative,lgammal_reserve, /* 102, 103, 104 */
  lgamma_overflow, lgamma_negative,lgamma_reserve,    /* 105, 106, 107 */
  lgammaf_overflow, lgammaf_negative, lgammaf_reserve,/* 108, 109, 110 */
  gammal_overflow,gammal_negative, gammal_reserve,    /* 111, 112, 113 */
  gamma_overflow, gamma_negative, gamma_reserve,      /* 114, 115, 116 */
  gammaf_overflow,gammaf_negative,gammaf_reserve,     /* 117, 118, 119 */   
  fmodl_by_zero,                                 /* 120 */
  fmod_by_zero,                                  /* 121 */
  fmodf_by_zero,                                 /* 122 */
  remainderl_by_zero,                            /* 123 */
  remainder_by_zero,                             /* 124 */
  remainderf_by_zero,                            /* 125 */
  sinhl_overflow, sinh_overflow, sinhf_overflow, /* 126, 127, 128 */
  atanhl_gt_one, atanhl_eq_one,                  /* 129, 130 */
  atanh_gt_one, atanh_eq_one,                    /* 131, 132 */
  atanhf_gt_one, atanhf_eq_one,                  /* 133, 134 */
  acoshl_lt_one,                                 /* 135 */
  acosh_lt_one,                                  /* 136 */
  acoshf_lt_one,                                 /* 137 */
  log1pl_zero,   log1pl_negative,                /* 138, 139 */
  log1p_zero,    log1p_negative,                 /* 140, 141 */
  log1pf_zero,   log1pf_negative,                /* 142, 143 */
  ldexpl_overflow,   ldexpl_underflow,           /* 144, 145 */
  ldexp_overflow,    ldexp_underflow,            /* 146, 147 */
  ldexpf_overflow,   ldexpf_underflow,           /* 148, 149 */
  logbl_zero,   logb_zero, logbf_zero,            /* 150, 151,152 */
  nextafterl_overflow,   nextafter_overflow,  nextafterf_overflow            /* 153, 154,155 */
} error_types;

void __libm_error_support(void*,void*,void*,error_types);

#define BIAS_64  1023
#define EXPINF_64  2047

#define DOUBLE_HEX(HI, LO) 0x ## LO, 0x ## HI

static const unsigned INF[] = {
    DOUBLE_HEX(7ff00000, 00000000),
    DOUBLE_HEX(fff00000, 00000000)
};

static const double _zeroo = 0.0;
static const double _bigg = 1.0e300;
static const double _ponee = 1.0;
static const double _nonee = -1.0; 

#define INVALID    (_zeroo * *((double*)&INF[0]))
#define PINF       *((double*)&INF[0]) 
#define NINF       -PINF 
#define PINF_DZ    (_ponee/_zeroo) 
#define X_TLOSS    1.41484755040568800000e+16

# ifdef __cplusplus
struct __exception
{
  int type;
  char *name;
  double arg1, arg2, retval;
};
# else

struct exception
{
  int type;
  char *name;
  double arg1, arg2, retval;
};
#endif

#ifdef __MS__
#define exceptionf exception
#elif
struct exceptionf
{
  int type;
  char *name;
  float arg1, arg2, retval;
};

struct exceptionl
{
  int type;
  char *name;
  long double arg1, arg2, retval;
};

#endif


#ifdef __MS__
#define _matherrf _matherr
#else
extern int matherrf(struct exceptionf*);
#endif

# ifdef __cplusplus
#ifdef __MS__
extern int _matherr(struct __exception*);
#else
extern int matherr(struct __exception*);
#endif
# else 
#ifdef __MS__
extern int _matherr(struct exception*);
# else 
extern int matherr(struct exception*);
# endif
# endif

// exception is a reserved name in C++

extern int matherrl(struct exceptionl*);

/* Set these appropriately to make thread Safe */

#define ERRNO_RANGE  errno = ERANGE
#define ERRNO_DOMAIN errno = EDOM

// Add code to support _LIB_VERSION

typedef enum
{
    _IEEE_ = -1, // IEEE-like behavior
    _SVID_,      // SysV, Rel. 4 behavior
    _XOPEN_,     // Unix98
    __POSIX__,     // Posix
    _ISOC_,      // ISO C9X
    _MS_         // Microsoft version     
} _LIB_VERSION_TYPE;

extern _LIB_VERSION_TYPE _LIB_VERSION;

// This is a run-time variable and may effect
// floating point behavior of the libm functions
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\logb.s ===
.file "logb.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version
// 2/16/00  Modified to conform to C9X 
// 3/16/00  Improved speed
// 4/04/00  Unwind support added
// 5/30/00  Fixed bug when x double-extended denormal
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
//
// API
//==============================================================
// double _logb( double x);
//
// Overview of operation
//==============================================================
// The logb function extracts the exponent of x as an integer in 
// floating-point format. 
// logb computes log2 of x as a double
//
// logb is similar to ilogb but differs in the  following ways:
//         +-inf
//            ilogb: returns INT_MAX
//             logb: returns +inf
//         Nan  returns FP_LOGBNAN (which is either INT_MAX or INT_MIN)
//            ilogb: returns INT_MAX (7fffffff)
//             logb: returns QNAN (quietized SNAN)
//         0    returns FP_ILOGB0 (which is either INT_MIN or -INT_MAX)
//            ilogb: returns -INT_MAX (80000001)
//             logb: returns -inf, raises the divide-by-zero exception,
//                   and calls libm_error_support to set domain error
//
// Registers used
//==============================================================
// general registers used: 
// ar.pfs r32 
// r33 -> r37
// r38 -> r41 used as parameters to error path
//
// predicate registers used: 
// p6, p7, p8
// floating-point registers used: 
// f9, f10, f11
// f8, input

GR_SAVE_B0          = r34
GR_SAVE_GP          = r35
GR_SAVE_PFS         = r32

GR_Parameter_X      = r38
GR_Parameter_Y      = r39
GR_Parameter_RESULT = r40

.align 32
.global _logb#

.section .text
.proc  _logb#
.align 32


_logb: 

// qnan snan inf norm     unorm 0 -+
// 0    0    0   0        1     0 11
// 0                      b
{ .mfi
      alloc          r32=ar.pfs,1,5,4,0
(p0)  fclass.m.unc  p8,p0 = f8, 0x0b
      nop.i 999
}
// X NORMAL
// r37 = exp(f8) - - 0xffff
// sig(f8) = r37
// f8 = convert_to_fp (sig))
{ .mfi
(p0)  getf.exp      r35 = f8
(p0)  fnorm         f10=f8
      nop.i 999 ;;
}

// qnan snan inf norm     unorm 0 -+
// 1    1    1   0        0     0 11
// e                      3
{ .mmf
(p0)  mov      r33 = 0xffff
(p0)  mov      r34 = 0x1ffff
(p0)  fclass.m.unc  p6,p0 = f8, 0xe3 ;;
}

{ .mfb
(p0)  and           r36 = r35, r34
(p0)  fclass.m.unc  p7,p0 = f8, 0x07
(p8)  br.cond.spnt  LOGB_DENORM ;;
}

{ .mib
(p0)  sub           r37 = r36, r33
      nop.i 999
(p6)  br.cond.spnt  LOGB_NAN_INF ;;
}

{ .mib
(p0)  setf.sig      f9  = r37
      nop.i 999
(p7)  br.cond.spnt  LOGB_ZERO ;;
}

{ .mfi
      nop.m 999
(p0)  fcvt.xf       f10 = f9
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
(p0)  fnorm.d       f8 = f10
(p0)  br.ret.sptk    b0 ;;
}

LOGB_DENORM:
// Form signexp of 2^64 in case need to scale denormal
// Check to see if double-extended denormal
{ .mfi
(p0)  mov r38 = 0x1003f
(p0)  fclass.m.unc  p8,p0 = f10, 0x0b
      nop.i 999 ;;
}

// Form 2^64 in case need to scale denormal
{ .mfi
(p0)  setf.exp f11 = r38
      nop.f 999
      nop.i 999 ;;
}

// If double-extended denormal add 64 to exponent bias for scaling
// If double-extended denormal form x * 2^64 which is normal
{ .mfi
(p8)  add r33 = 64, r33
(p8)  fmpy f10 = f10, f11    
      nop.i 999 ;;
}

// Logic is the same as normal path but use normalized input
{ .mmi
(p0)  getf.exp      r35 = f10 ;;
      nop.m 999
      nop.i 999 ;;
}

{ .mmi
(p0)  and           r36 = r35, r34 ;;
(p0)  sub           r37 = r36, r33
      nop.i 999 ;;
}

{ .mmi
(p0)  setf.sig      f9  = r37
      nop.m 999
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fcvt.xf       f10 = f9
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
(p0)  fnorm.d       f8 = f10
(p0)  br.ret.sptk    b0 ;;
}

LOGB_NAN_INF: 

// X NAN or INFINITY, return f8 * f8
{ .mfb
      nop.m 999
(p0)  fma.d      f8= f8,f8,f0
(p0)  br.ret.sptk   b0 ;;
}

.endp _logb#

// Stack operations when calling error support.
//       (1)               (2)                          (3) (call)              (4)
//   sp   -> +          psp -> +                     psp -> +                   sp -> +
//           |                 |                            |                         |
//           |                 | <- GR_Y               R3 ->| <- GR_RESULT            | -> f8
//           |                 |                            |                         |
//           | <-GR_Y      Y2->|                       Y2 ->| <- GR_Y                 |
//           |                 |                            |                         |
//           |                 | <- GR_X               X1 ->|                         |
//           |                 |                            |                         |
//  sp-64 -> +          sp ->  +                     sp ->  +                         +
//    save ar.pfs          save b0                                               restore gp
//    save gp                                                                    restore ar.pfs



.proc __libm_error_region
__libm_error_region:
LOGB_ZERO: 
.prologue

// f9  = |f8|
// f10 = -f9 = -|f8|
// f9  = 1.0/f10 = -1.0/-|f8|

{ .mfi 
      mov           r41 = 151      // Error code
(p0)  fmerge.s      f9 = f0,f8
      nop.i 999
}
;;


{ .mfi
      nop.m 999
      fmerge.ns     f10 = f0,f9
      nop.i 999
}
;;

// (1)
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        frcpa         f9,p6 = f1,f10
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                          // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                      // Save gp
};;


// (2)
{ .mmi
        stfd [GR_Parameter_Y] = f0,16         // STORE Parameter 2 on stack
        add GR_Parameter_X    = 16,sp         // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                     // Save b0
};;

.body
// (3)
{ .mib
        stfd [GR_Parameter_X] = f8            // STORE Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y    // Parameter 3 address
        nop.b 0                                         
}
{ .mib
        stfd [GR_Parameter_Y] = f9            // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support# // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

// (4)
{ .mmi
        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk   b0
};;

.endp __libm_error_region


.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\log.s ===
.file "log.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version
// 4/04/00  Unwind support added
// 6/16/00  Updated table to be rounded correctly
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 8/17/00  Improved speed of main path by 5 cycles
//          Shortened path for x=1.0
//
//
// API
//==============================================================
// double log(double)
// double log10(double)
//
// Overview of operation
//==============================================================
// Background
//
// Consider  x = 2^N 1.f1 f2 f3 f4...f63
// Log(x) = log(frcpa(x) x/frcpa(x))
//        = log(1/frcpa(x)) + log(frcpa(x) x)
//        = -log(frcpa(x)) + log(frcpa(x) x)
//
// frcpa(x)       = 2^-N frcpa((1.f1 f2 ... f63)
//
// -log(frcpa(x)) = -log(C) 
//                = -log(2^-N) - log(frcpa(1.f1 f2 ... f63))
//
// -log(frcpa(x)) = -log(C) 
//                = +Nlog2 - log(frcpa(1.f1 f2 ... f63))
//
// -log(frcpa(x)) = -log(C) 
//                = +Nlog2 + log(frcpa(1.f1 f2 ... f63))
//
// Log(x) = log(1/frcpa(x)) + log(frcpa(x) x)

// Log(x) =  +Nlog2 + log(1./frcpa(1.f1 f2 ... f63)) + log(frcpa(x) x)
// Log(x) =  +Nlog2 - log(/frcpa(1.f1 f2 ... f63))   + log(frcpa(x) x)
// Log(x) =  +Nlog2 + T                              + log(frcpa(x) x)
//
// Log(x) =  +Nlog2 + T                     + log(C x)
//
// Cx = 1 + r
//
// Log(x) =  +Nlog2 + T  + log(1+r)
// Log(x) =  +Nlog2 + T  + Series( r - r^2/2 + r^3/3 - r^4/4 ....)
//
// 1.f1 f2 ... f8 has 256 entries.
// They are 1 + k/2^8, k = 0 ... 255
// These 256 values are the table entries.
//
// Implementation
//===============
// input = x
// C = frcpa(x)
// r = C * x - 1
//
// Form the series P1 + P2 * x + P_3 * x^2 + P_4 * X^3 + P_5 * x^4
// P_series = r(r(r(r * P5 +P4) + P3) + P2) + P1

// x = f * 2*n where f is 1.f_1f_2f_3....f_63
// Nfloat = float(n)  where n is the true unbiased exponent
// pre-index = f_1f_2....f_8
// index = pre_index * 16
// get the dxt table entry at index + offset = T

// Yhi = (T + Nfloat * log(2)) + r

// answer =  P_series * r*r + Yhi 

// The T table is calculated as follows
// Form x_k = 1 + k/2^8 where k goes from 0... 255
//      y_k = frcpa(x_k)
//      log(1/y_k)  in quad and round to double-extended

// Special values 
//==============================================================


// log(+0)    = -inf
// log(-0)    = -inf

// log(+qnan) = +qnan 
// log(-qnan) = -qnan 
// log(+snan) = +qnan 
// log(-snan) = -qnan 

// log(-n)    = QNAN Indefinite
// log(-inf)  = QNAN Idefinite 

// log(+inf)  = +inf

// Registers used
//==============================================================
// Floating Point registers used: 
// f8, input
// f9 -> f15,  f32 -> f68

// General registers used:  
// r32 -> r54

// Predicate registers used:
// p6 -> p14

// p8 log base e
// p6 log base e special
// p9 used in the frcpa
// p13 log base e large W
// p14 log base e small w

// p7 log base 10
// p10 log base 10 large W
// p11 log base 10 small w
// p12 log base 10 special

// Assembly macros
//==============================================================

log_int_Nfloat   = f9 
log_Nfloat       = f10 

log_P5           = f11 
log_P4           = f12 
log_P3           = f13 
log_P2           = f14 
log_P1           = f15 

log_log2         = f32 
log_T            = f33 

log_rp_p4        = f34 
log_rp_p3        = f35 
log_rp_p2        = f36 
log_pseries      = f37 

log_rsq          = f40 

log_T_plus_Nlog2 = f41 
log_Yhi          = f42 

log_r            = f43
log_C            = f44

log_w            = f45
log_Q8           = f46
log_Q7           = f47
log_Q3           = f48
log_Q4           = f49 
log_Q6           = f50 
log_Q2           = f51
log_Q5           = f52
log_Q1           = f53 

log_rp_q7        = f54 
log_rp_q6        = f55
log_Qlo          = f56

log_rp_q3        = f57
log_rp_q2        = f58
log_Qhi          = f59

log_wsq          = f60
log_w4           = f61
log_Q            = f62

log_inv_ln10     = f63
log_log10_hi     = f64
log_log10_lo     = f65

log_neg_one      = f66
log_NORM_f8      = f67
log_r2P_r        = f68 

// ===================================

log_GR_exp_17_ones               = r33
log_GR_exp_16_ones               = r34
log_GR_exp_f8                    = r35
log_GR_signexp_f8                = r36
log_GR_true_exp_f8               = r37

log_GR_significand_f8            = r38

log_GR_sig_no_explicit           = r39
log_GR_sig_f1f8                  = r39
log_GR_sig_f1f8_times_16         = r39

log_GR_AD_p_table                = r40

log_GR_signexp_w                 = r41
log_GR_fff9                      = r42

//////////////////////////////////////////////////////////////
log_GR_AD_q_table                = r43
log_GR_AD_inv_ln_10              = r44
// r45 unused
log_GR_exp_w                     = r46
// r47 is unused

GR_SAVE_B0                       = r48
GR_SAVE_GP                       = r49
GR_SAVE_PFS                      = r50

GR_Parameter_X                   = r51
GR_Parameter_Y                   = r52
GR_Parameter_RESULT              = r53
log_GR_tag                       = r54


// Data tables
//==============================================================

.data

.align 16

log_q_table:
data8 0x3FBC756AC654273B // Q8
data8 0xBFC001A42489AB4D // Q7
data8 0xBFD00000000019AC // Q3
data8 0x3FC99999999A169B // Q4
data8 0x3FC2492479AA0DF8 // Q6
data8 0x3FD5555555555555 // Q2
data8 0xBFC5555544986F52 // Q5
data8 0xBFE0000000000000 // Q1


log_p_table:
data8 0xBFC5555DA7212371 // P5
data8 0x3FC999A19EEF5826 // P4
data8 0xBFCFFFFFFFFEF009 // P3
data8 0x3FD555555554ECB2 // P2
data8 0xBFE0000000000000 // P1
data8 0x0000000000000000 // pad so that dxt values on on 16 byte boundaries

data8 0xde5bd8a937287195, 0x00003ffd  // double-extended 1/ln(10)
data8 0xb17217f7d1cf79ac, 0x00003ffe  // log2
//      b17217f7d1cf79ab c9e3b39803f2f6a


data8 0x80200aaeac44ef38 , 0x00003ff6 //   log(1/frcpa(1+  0/2^-8))

data8 0xc09090a2c35aa070 , 0x00003ff7 //   log(1/frcpa(1+  1/2^-8))
data8 0xa0c94fcb41977c75 , 0x00003ff8 //   log(1/frcpa(1+  2/2^-8))
data8 0xe18b9c263af83301 , 0x00003ff8 //   log(1/frcpa(1+  3/2^-8))
data8 0x8d35c8d6399c30ea , 0x00003ff9 //   log(1/frcpa(1+  4/2^-8))
data8 0xadd4d2ecd601cbb8 , 0x00003ff9 //   log(1/frcpa(1+  5/2^-8))

data8 0xce95403a192f9f01 , 0x00003ff9 //   log(1/frcpa(1+  6/2^-8))
data8 0xeb59392cbcc01096 , 0x00003ff9 //   log(1/frcpa(1+  7/2^-8))
data8 0x862c7d0cefd54c5d , 0x00003ffa //   log(1/frcpa(1+  8/2^-8))
data8 0x94aa63c65e70d499 , 0x00003ffa //   log(1/frcpa(1+  9/2^-8))
data8 0xa54a696d4b62b382 , 0x00003ffa //   log(1/frcpa(1+ 10/2^-8))

data8 0xb3e4a796a5dac208 , 0x00003ffa //   log(1/frcpa(1+ 11/2^-8))
data8 0xc28c45b1878340a9 , 0x00003ffa //   log(1/frcpa(1+ 12/2^-8))
data8 0xd35c55f39d7a6235 , 0x00003ffa //   log(1/frcpa(1+ 13/2^-8))
data8 0xe220f037b954f1f5 , 0x00003ffa //   log(1/frcpa(1+ 14/2^-8))
data8 0xf0f3389b036834f3 , 0x00003ffa //   log(1/frcpa(1+ 15/2^-8))

data8 0xffd3488d5c980465 , 0x00003ffa //   log(1/frcpa(1+ 16/2^-8))
data8 0x87609ce2ed300490 , 0x00003ffb //   log(1/frcpa(1+ 17/2^-8))
data8 0x8ede9321e8c85927 , 0x00003ffb //   log(1/frcpa(1+ 18/2^-8))
data8 0x96639427f2f8e2f4 , 0x00003ffb //   log(1/frcpa(1+ 19/2^-8))
data8 0x9defad3e8f73217b , 0x00003ffb //   log(1/frcpa(1+ 20/2^-8))

data8 0xa582ebd50097029c , 0x00003ffb //   log(1/frcpa(1+ 21/2^-8))
data8 0xac06dbe75ab80fee , 0x00003ffb //   log(1/frcpa(1+ 22/2^-8))
data8 0xb3a78449b2d3ccca , 0x00003ffb //   log(1/frcpa(1+ 23/2^-8))
data8 0xbb4f79635ab46bb2 , 0x00003ffb //   log(1/frcpa(1+ 24/2^-8))
data8 0xc2fec93a83523f3f , 0x00003ffb //   log(1/frcpa(1+ 25/2^-8))

data8 0xc99af2eaca4c4571 , 0x00003ffb //   log(1/frcpa(1+ 26/2^-8))
data8 0xd1581106472fa653 , 0x00003ffb //   log(1/frcpa(1+ 27/2^-8))
data8 0xd8002560d4355f2e , 0x00003ffb //   log(1/frcpa(1+ 28/2^-8))
data8 0xdfcb43b4fe508632 , 0x00003ffb //   log(1/frcpa(1+ 29/2^-8))
data8 0xe67f6dff709d4119 , 0x00003ffb //   log(1/frcpa(1+ 30/2^-8))

data8 0xed393b1c22351280 , 0x00003ffb //   log(1/frcpa(1+ 31/2^-8))
data8 0xf5192bff087bcc35 , 0x00003ffb //   log(1/frcpa(1+ 32/2^-8))
data8 0xfbdf4ff6dfef2fa3 , 0x00003ffb //   log(1/frcpa(1+ 33/2^-8))
data8 0x81559a97f92f9cc7 , 0x00003ffc //   log(1/frcpa(1+ 34/2^-8))
data8 0x84be72bce90266e8 , 0x00003ffc //   log(1/frcpa(1+ 35/2^-8))

data8 0x88bc74113f23def2 , 0x00003ffc //   log(1/frcpa(1+ 36/2^-8))
data8 0x8c2ba3edf6799d11 , 0x00003ffc //   log(1/frcpa(1+ 37/2^-8))
data8 0x8f9dc92f92ea08b1 , 0x00003ffc //   log(1/frcpa(1+ 38/2^-8))
data8 0x9312e8f36efab5a7 , 0x00003ffc //   log(1/frcpa(1+ 39/2^-8))
data8 0x968b08643409ceb6 , 0x00003ffc //   log(1/frcpa(1+ 40/2^-8))

data8 0x9a062cba08a1708c , 0x00003ffc //   log(1/frcpa(1+ 41/2^-8))
data8 0x9d845b3abf95485c , 0x00003ffc //   log(1/frcpa(1+ 42/2^-8))
data8 0xa06fd841bc001bb4 , 0x00003ffc //   log(1/frcpa(1+ 43/2^-8))
data8 0xa3f3a74652fbe0db , 0x00003ffc //   log(1/frcpa(1+ 44/2^-8))
data8 0xa77a8fb2336f20f5 , 0x00003ffc //   log(1/frcpa(1+ 45/2^-8))

data8 0xab0497015d28b0a0 , 0x00003ffc //   log(1/frcpa(1+ 46/2^-8))
data8 0xae91c2be6ba6a615 , 0x00003ffc //   log(1/frcpa(1+ 47/2^-8))
data8 0xb189d1b99aebb20b , 0x00003ffc //   log(1/frcpa(1+ 48/2^-8))
data8 0xb51cced5de9c1b2c , 0x00003ffc //   log(1/frcpa(1+ 49/2^-8))
data8 0xb819bee9e720d42f , 0x00003ffc //   log(1/frcpa(1+ 50/2^-8))

data8 0xbbb2a0947b093a5d , 0x00003ffc //   log(1/frcpa(1+ 51/2^-8))
data8 0xbf4ec1505811684a , 0x00003ffc //   log(1/frcpa(1+ 52/2^-8))
data8 0xc2535bacfa8975ff , 0x00003ffc //   log(1/frcpa(1+ 53/2^-8))
data8 0xc55a3eafad187eb8 , 0x00003ffc //   log(1/frcpa(1+ 54/2^-8))
data8 0xc8ff2484b2c0da74 , 0x00003ffc //   log(1/frcpa(1+ 55/2^-8))

data8 0xcc0b1a008d53ab76 , 0x00003ffc //   log(1/frcpa(1+ 56/2^-8))
data8 0xcfb6203844b3209b , 0x00003ffc //   log(1/frcpa(1+ 57/2^-8))
data8 0xd2c73949a47a19f5 , 0x00003ffc //   log(1/frcpa(1+ 58/2^-8))
data8 0xd5daae18b49d6695 , 0x00003ffc //   log(1/frcpa(1+ 59/2^-8))
data8 0xd8f08248cf7e8019 , 0x00003ffc //   log(1/frcpa(1+ 60/2^-8))

data8 0xdca7749f1b3e540e , 0x00003ffc //   log(1/frcpa(1+ 61/2^-8))
data8 0xdfc28e033aaaf7c7 , 0x00003ffc //   log(1/frcpa(1+ 62/2^-8))
data8 0xe2e012a5f91d2f55 , 0x00003ffc //   log(1/frcpa(1+ 63/2^-8))
data8 0xe600064ed9e292a8 , 0x00003ffc //   log(1/frcpa(1+ 64/2^-8))
data8 0xe9226cce42b39f60 , 0x00003ffc //   log(1/frcpa(1+ 65/2^-8))

data8 0xec4749fd97a28360 , 0x00003ffc //   log(1/frcpa(1+ 66/2^-8))
data8 0xef6ea1bf57780495 , 0x00003ffc //   log(1/frcpa(1+ 67/2^-8))
data8 0xf29877ff38809091 , 0x00003ffc //   log(1/frcpa(1+ 68/2^-8))
data8 0xf5c4d0b245cb89be , 0x00003ffc //   log(1/frcpa(1+ 69/2^-8))
data8 0xf8f3afd6fcdef3aa , 0x00003ffc //   log(1/frcpa(1+ 70/2^-8))

data8 0xfc2519756be1abc7 , 0x00003ffc //   log(1/frcpa(1+ 71/2^-8))
data8 0xff59119f503e6832 , 0x00003ffc //   log(1/frcpa(1+ 72/2^-8))
data8 0x8147ce381ae0e146 , 0x00003ffd //   log(1/frcpa(1+ 73/2^-8))
data8 0x82e45f06cb1ad0f2 , 0x00003ffd //   log(1/frcpa(1+ 74/2^-8))
data8 0x842f5c7c573cbaa2 , 0x00003ffd //   log(1/frcpa(1+ 75/2^-8))

data8 0x85ce471968c8893a , 0x00003ffd //   log(1/frcpa(1+ 76/2^-8))
data8 0x876e8305bc04066d , 0x00003ffd //   log(1/frcpa(1+ 77/2^-8))
data8 0x891012678031fbb3 , 0x00003ffd //   log(1/frcpa(1+ 78/2^-8))
data8 0x8a5f1493d766a05f , 0x00003ffd //   log(1/frcpa(1+ 79/2^-8))
data8 0x8c030c778c56fa00 , 0x00003ffd //   log(1/frcpa(1+ 80/2^-8))

data8 0x8da85df17e31d9ae , 0x00003ffd //   log(1/frcpa(1+ 81/2^-8))
data8 0x8efa663e7921687e , 0x00003ffd //   log(1/frcpa(1+ 82/2^-8))
data8 0x90a22b6875c6a1f8 , 0x00003ffd //   log(1/frcpa(1+ 83/2^-8))
data8 0x91f62cc8f5d24837 , 0x00003ffd //   log(1/frcpa(1+ 84/2^-8))
data8 0x93a06cfc3857d980 , 0x00003ffd //   log(1/frcpa(1+ 85/2^-8))

data8 0x94f66d5e6fd01ced , 0x00003ffd //   log(1/frcpa(1+ 86/2^-8))
data8 0x96a330156e6772f2 , 0x00003ffd //   log(1/frcpa(1+ 87/2^-8))
data8 0x97fb3582754ea25b , 0x00003ffd //   log(1/frcpa(1+ 88/2^-8))
data8 0x99aa8259aad1bbf2 , 0x00003ffd //   log(1/frcpa(1+ 89/2^-8))
data8 0x9b0492f6227ae4a8 , 0x00003ffd //   log(1/frcpa(1+ 90/2^-8))

data8 0x9c5f8e199bf3a7a5 , 0x00003ffd //   log(1/frcpa(1+ 91/2^-8))
data8 0x9e1293b9998c1daa , 0x00003ffd //   log(1/frcpa(1+ 92/2^-8))
data8 0x9f6fa31e0b41f308 , 0x00003ffd //   log(1/frcpa(1+ 93/2^-8))
data8 0xa0cda11eaf46390e , 0x00003ffd //   log(1/frcpa(1+ 94/2^-8))
data8 0xa22c8f029cfa45aa , 0x00003ffd //   log(1/frcpa(1+ 95/2^-8))

data8 0xa3e48badb7856b34 , 0x00003ffd //   log(1/frcpa(1+ 96/2^-8))
data8 0xa5459a0aa95849f9 , 0x00003ffd //   log(1/frcpa(1+ 97/2^-8))
data8 0xa6a79c84480cfebd , 0x00003ffd //   log(1/frcpa(1+ 98/2^-8))
data8 0xa80a946d0fcb3eb2 , 0x00003ffd //   log(1/frcpa(1+ 99/2^-8))
data8 0xa96e831a3ea7b314 , 0x00003ffd //   log(1/frcpa(1+100/2^-8))

data8 0xaad369e3dc544e3b , 0x00003ffd //   log(1/frcpa(1+101/2^-8))
data8 0xac92e9588952c815 , 0x00003ffd //   log(1/frcpa(1+102/2^-8))
data8 0xadfa035aa1ed8fdc , 0x00003ffd //   log(1/frcpa(1+103/2^-8))
data8 0xaf6219eae1ad6e34 , 0x00003ffd //   log(1/frcpa(1+104/2^-8))
data8 0xb0cb2e6d8160f753 , 0x00003ffd //   log(1/frcpa(1+105/2^-8))

data8 0xb2354249ad950f72 , 0x00003ffd //   log(1/frcpa(1+106/2^-8))
data8 0xb3a056e98ef4a3b4 , 0x00003ffd //   log(1/frcpa(1+107/2^-8))
data8 0xb50c6dba52c6292a , 0x00003ffd //   log(1/frcpa(1+108/2^-8))
data8 0xb679882c33876165 , 0x00003ffd //   log(1/frcpa(1+109/2^-8))
data8 0xb78c07429785cedc , 0x00003ffd //   log(1/frcpa(1+110/2^-8))

data8 0xb8faeb8dc4a77d24 , 0x00003ffd //   log(1/frcpa(1+111/2^-8))
data8 0xba6ad77eb36ae0d6 , 0x00003ffd //   log(1/frcpa(1+112/2^-8))
data8 0xbbdbcc915e9bee50 , 0x00003ffd //   log(1/frcpa(1+113/2^-8))
data8 0xbd4dcc44f8cf12ef , 0x00003ffd //   log(1/frcpa(1+114/2^-8))
data8 0xbec0d81bf5b531fa , 0x00003ffd //   log(1/frcpa(1+115/2^-8))

data8 0xc034f19c139186f4 , 0x00003ffd //   log(1/frcpa(1+116/2^-8))
data8 0xc14cb69f7c5e55ab , 0x00003ffd //   log(1/frcpa(1+117/2^-8))
data8 0xc2c2abbb6e5fd56f , 0x00003ffd //   log(1/frcpa(1+118/2^-8))
data8 0xc439b2c193e6771e , 0x00003ffd //   log(1/frcpa(1+119/2^-8))
data8 0xc553acb9d5c67733 , 0x00003ffd //   log(1/frcpa(1+120/2^-8))

data8 0xc6cc96e441272441 , 0x00003ffd //   log(1/frcpa(1+121/2^-8))
data8 0xc8469753eca88c30 , 0x00003ffd //   log(1/frcpa(1+122/2^-8))
data8 0xc962cf3ce072b05c , 0x00003ffd //   log(1/frcpa(1+123/2^-8))
data8 0xcadeba8771f694aa , 0x00003ffd //   log(1/frcpa(1+124/2^-8))
data8 0xcc5bc08d1f72da94 , 0x00003ffd //   log(1/frcpa(1+125/2^-8))

data8 0xcd7a3f99ea035c29 , 0x00003ffd //   log(1/frcpa(1+126/2^-8))
data8 0xcef93860c8a53c35 , 0x00003ffd //   log(1/frcpa(1+127/2^-8))
data8 0xd0192f68a7ed23df , 0x00003ffd //   log(1/frcpa(1+128/2^-8))
data8 0xd19a201127d3c645 , 0x00003ffd //   log(1/frcpa(1+129/2^-8))
data8 0xd2bb92f4061c172c , 0x00003ffd //   log(1/frcpa(1+130/2^-8))

data8 0xd43e80b2ee8cc8fc , 0x00003ffd //   log(1/frcpa(1+131/2^-8))
data8 0xd56173601fc4ade4 , 0x00003ffd //   log(1/frcpa(1+132/2^-8))
data8 0xd6e6637efb54086f , 0x00003ffd //   log(1/frcpa(1+133/2^-8))
data8 0xd80ad9f58f3c8193 , 0x00003ffd //   log(1/frcpa(1+134/2^-8))
data8 0xd991d1d31aca41f8 , 0x00003ffd //   log(1/frcpa(1+135/2^-8))

data8 0xdab7d02231484a93 , 0x00003ffd //   log(1/frcpa(1+136/2^-8))
data8 0xdc40d532cde49a54 , 0x00003ffd //   log(1/frcpa(1+137/2^-8))
data8 0xdd685f79ed8b265e , 0x00003ffd //   log(1/frcpa(1+138/2^-8))
data8 0xde9094bbc0e17b1d , 0x00003ffd //   log(1/frcpa(1+139/2^-8))
data8 0xe01c91b78440c425 , 0x00003ffd //   log(1/frcpa(1+140/2^-8))

data8 0xe14658f26997e729 , 0x00003ffd //   log(1/frcpa(1+141/2^-8))
data8 0xe270cdc2391e0d23 , 0x00003ffd //   log(1/frcpa(1+142/2^-8))
data8 0xe3ffce3a2aa64922 , 0x00003ffd //   log(1/frcpa(1+143/2^-8))
data8 0xe52bdb274ed82887 , 0x00003ffd //   log(1/frcpa(1+144/2^-8))
data8 0xe6589852e75d7df6 , 0x00003ffd //   log(1/frcpa(1+145/2^-8))

data8 0xe786068c79937a7d , 0x00003ffd //   log(1/frcpa(1+146/2^-8))
data8 0xe91903adad100911 , 0x00003ffd //   log(1/frcpa(1+147/2^-8))
data8 0xea481236f7d35bb0 , 0x00003ffd //   log(1/frcpa(1+148/2^-8))
data8 0xeb77d48c692e6b14 , 0x00003ffd //   log(1/frcpa(1+149/2^-8))
data8 0xeca84b83d7297b87 , 0x00003ffd //   log(1/frcpa(1+150/2^-8))

data8 0xedd977f4962aa158 , 0x00003ffd //   log(1/frcpa(1+151/2^-8))
data8 0xef7179a22f257754 , 0x00003ffd //   log(1/frcpa(1+152/2^-8))
data8 0xf0a450d139366ca7 , 0x00003ffd //   log(1/frcpa(1+153/2^-8))
data8 0xf1d7e0524ff9ffdb , 0x00003ffd //   log(1/frcpa(1+154/2^-8))
data8 0xf30c29036a8b6cae , 0x00003ffd //   log(1/frcpa(1+155/2^-8))

data8 0xf4412bc411ea8d92 , 0x00003ffd //   log(1/frcpa(1+156/2^-8))
data8 0xf576e97564c8619d , 0x00003ffd //   log(1/frcpa(1+157/2^-8))
data8 0xf6ad62fa1b5f172f , 0x00003ffd //   log(1/frcpa(1+158/2^-8))
data8 0xf7e499368b55c542 , 0x00003ffd //   log(1/frcpa(1+159/2^-8))
data8 0xf91c8d10abaffe22 , 0x00003ffd //   log(1/frcpa(1+160/2^-8))

data8 0xfa553f7018c966f3 , 0x00003ffd //   log(1/frcpa(1+161/2^-8))
data8 0xfb8eb13e185d802c , 0x00003ffd //   log(1/frcpa(1+162/2^-8))
data8 0xfcc8e3659d9bcbed , 0x00003ffd //   log(1/frcpa(1+163/2^-8))
data8 0xfe03d6d34d487fd2 , 0x00003ffd //   log(1/frcpa(1+164/2^-8))
data8 0xff3f8c7581e9f0ae , 0x00003ffd //   log(1/frcpa(1+165/2^-8))

data8 0x803e029e280173ae , 0x00003ffe //   log(1/frcpa(1+166/2^-8))
data8 0x80dca10cc52d0757 , 0x00003ffe //   log(1/frcpa(1+167/2^-8))
data8 0x817ba200632755a1 , 0x00003ffe //   log(1/frcpa(1+168/2^-8))
data8 0x821b05f3b01d6774 , 0x00003ffe //   log(1/frcpa(1+169/2^-8))
data8 0x82bacd623ff19d06 , 0x00003ffe //   log(1/frcpa(1+170/2^-8))

data8 0x835af8c88e7a8f47 , 0x00003ffe //   log(1/frcpa(1+171/2^-8))
data8 0x83c5f8299e2b4091 , 0x00003ffe //   log(1/frcpa(1+172/2^-8))
data8 0x8466cb43f3d87300 , 0x00003ffe //   log(1/frcpa(1+173/2^-8))
data8 0x850803a67c80ca4b , 0x00003ffe //   log(1/frcpa(1+174/2^-8))
data8 0x85a9a1d11a23b461 , 0x00003ffe //   log(1/frcpa(1+175/2^-8))

data8 0x864ba644a18e6e05 , 0x00003ffe //   log(1/frcpa(1+176/2^-8))
data8 0x86ee1182dcc432f7 , 0x00003ffe //   log(1/frcpa(1+177/2^-8))
data8 0x875a925d7e48c316 , 0x00003ffe //   log(1/frcpa(1+178/2^-8))
data8 0x87fdaa109d23aef7 , 0x00003ffe //   log(1/frcpa(1+179/2^-8))
data8 0x88a129ed4becfaf2 , 0x00003ffe //   log(1/frcpa(1+180/2^-8))

data8 0x89451278ecd7f9cf , 0x00003ffe //   log(1/frcpa(1+181/2^-8))
data8 0x89b29295f8432617 , 0x00003ffe //   log(1/frcpa(1+182/2^-8))
data8 0x8a572ac5a5496882 , 0x00003ffe //   log(1/frcpa(1+183/2^-8))
data8 0x8afc2d0ce3b2dadf , 0x00003ffe //   log(1/frcpa(1+184/2^-8))
data8 0x8b6a69c608cfd3af , 0x00003ffe //   log(1/frcpa(1+185/2^-8))

data8 0x8c101e106e899a83 , 0x00003ffe //   log(1/frcpa(1+186/2^-8))
data8 0x8cb63de258f9d626 , 0x00003ffe //   log(1/frcpa(1+187/2^-8))
data8 0x8d2539c5bd19e2b1 , 0x00003ffe //   log(1/frcpa(1+188/2^-8))
data8 0x8dcc0e064b29e6f1 , 0x00003ffe //   log(1/frcpa(1+189/2^-8))
data8 0x8e734f45d88357ae , 0x00003ffe //   log(1/frcpa(1+190/2^-8))

data8 0x8ee30cef034a20db , 0x00003ffe //   log(1/frcpa(1+191/2^-8))
data8 0x8f8b0515686d1d06 , 0x00003ffe //   log(1/frcpa(1+192/2^-8))
data8 0x90336bba039bf32f , 0x00003ffe //   log(1/frcpa(1+193/2^-8))
data8 0x90a3edd23d1c9d58 , 0x00003ffe //   log(1/frcpa(1+194/2^-8))
data8 0x914d0de2f5d61b32 , 0x00003ffe //   log(1/frcpa(1+195/2^-8))

data8 0x91be0c20d28173b5 , 0x00003ffe //   log(1/frcpa(1+196/2^-8))
data8 0x9267e737c06cd34a , 0x00003ffe //   log(1/frcpa(1+197/2^-8))
data8 0x92d962ae6abb1237 , 0x00003ffe //   log(1/frcpa(1+198/2^-8))
data8 0x9383fa6afbe2074c , 0x00003ffe //   log(1/frcpa(1+199/2^-8))
data8 0x942f0421651c1c4e , 0x00003ffe //   log(1/frcpa(1+200/2^-8))

data8 0x94a14a3845bb985e , 0x00003ffe //   log(1/frcpa(1+201/2^-8))
data8 0x954d133857f861e7 , 0x00003ffe //   log(1/frcpa(1+202/2^-8))
data8 0x95bfd96468e604c4 , 0x00003ffe //   log(1/frcpa(1+203/2^-8))
data8 0x9632d31cafafa858 , 0x00003ffe //   log(1/frcpa(1+204/2^-8))
data8 0x96dfaabd86fa1647 , 0x00003ffe //   log(1/frcpa(1+205/2^-8))

data8 0x9753261fcbb2a594 , 0x00003ffe //   log(1/frcpa(1+206/2^-8))
data8 0x9800c11b426b996d , 0x00003ffe //   log(1/frcpa(1+207/2^-8))
data8 0x9874bf4d45ae663c , 0x00003ffe //   log(1/frcpa(1+208/2^-8))
data8 0x99231f5ee9a74f79 , 0x00003ffe //   log(1/frcpa(1+209/2^-8))
data8 0x9997a18a56bcad28 , 0x00003ffe //   log(1/frcpa(1+210/2^-8))

data8 0x9a46c873a3267e79 , 0x00003ffe //   log(1/frcpa(1+211/2^-8))
data8 0x9abbcfc621eb6cb6 , 0x00003ffe //   log(1/frcpa(1+212/2^-8))
data8 0x9b310cb0d354c990 , 0x00003ffe //   log(1/frcpa(1+213/2^-8))
data8 0x9be14cf9e1b3515c , 0x00003ffe //   log(1/frcpa(1+214/2^-8))
data8 0x9c5710b8cbb73a43 , 0x00003ffe //   log(1/frcpa(1+215/2^-8))

data8 0x9ccd0abd301f399c , 0x00003ffe //   log(1/frcpa(1+216/2^-8))
data8 0x9d7e67f3bdce8888 , 0x00003ffe //   log(1/frcpa(1+217/2^-8))
data8 0x9df4ea81a99daa01 , 0x00003ffe //   log(1/frcpa(1+218/2^-8))
data8 0x9e6ba405a54514ba , 0x00003ffe //   log(1/frcpa(1+219/2^-8))
data8 0x9f1e21c8c7bb62b3 , 0x00003ffe //   log(1/frcpa(1+220/2^-8))

data8 0x9f956593f6b6355c , 0x00003ffe //   log(1/frcpa(1+221/2^-8))
data8 0xa00ce1092e5498c3 , 0x00003ffe //   log(1/frcpa(1+222/2^-8))
data8 0xa0c08309c4b912c1 , 0x00003ffe //   log(1/frcpa(1+223/2^-8))
data8 0xa1388a8c6faa2afa , 0x00003ffe //   log(1/frcpa(1+224/2^-8))
data8 0xa1b0ca7095b5f985 , 0x00003ffe //   log(1/frcpa(1+225/2^-8))

data8 0xa22942eb47534a00 , 0x00003ffe //   log(1/frcpa(1+226/2^-8))
data8 0xa2de62326449d0a3 , 0x00003ffe //   log(1/frcpa(1+227/2^-8))
data8 0xa357690f88bfe345 , 0x00003ffe //   log(1/frcpa(1+228/2^-8))
data8 0xa3d0a93f45169a4b , 0x00003ffe //   log(1/frcpa(1+229/2^-8))
data8 0xa44a22f7ffe65f30 , 0x00003ffe //   log(1/frcpa(1+230/2^-8))

data8 0xa500c5e5b4c1aa36 , 0x00003ffe //   log(1/frcpa(1+231/2^-8))
data8 0xa57ad064eb2ebbc2 , 0x00003ffe //   log(1/frcpa(1+232/2^-8))
data8 0xa5f5152dedf4384e , 0x00003ffe //   log(1/frcpa(1+233/2^-8))
data8 0xa66f9478856233ec , 0x00003ffe //   log(1/frcpa(1+234/2^-8))
data8 0xa6ea4e7cca02c32e , 0x00003ffe //   log(1/frcpa(1+235/2^-8))

data8 0xa765437325341ccf , 0x00003ffe //   log(1/frcpa(1+236/2^-8))
data8 0xa81e21e6c75b4020 , 0x00003ffe //   log(1/frcpa(1+237/2^-8))
data8 0xa899ab333fe2b9ca , 0x00003ffe //   log(1/frcpa(1+238/2^-8))
data8 0xa9157039c51ebe71 , 0x00003ffe //   log(1/frcpa(1+239/2^-8))
data8 0xa991713433c2b999 , 0x00003ffe //   log(1/frcpa(1+240/2^-8))

data8 0xaa0dae5cbcc048b3 , 0x00003ffe //   log(1/frcpa(1+241/2^-8))
data8 0xaa8a27ede5eb13ad , 0x00003ffe //   log(1/frcpa(1+242/2^-8))
data8 0xab06de228a9e3499 , 0x00003ffe //   log(1/frcpa(1+243/2^-8))
data8 0xab83d135dc633301 , 0x00003ffe //   log(1/frcpa(1+244/2^-8))
data8 0xac3fb076adc7fe7a , 0x00003ffe //   log(1/frcpa(1+245/2^-8))

data8 0xacbd3cbbe47988f1 , 0x00003ffe //   log(1/frcpa(1+246/2^-8))
data8 0xad3b06b1a5dc57c3 , 0x00003ffe //   log(1/frcpa(1+247/2^-8))
data8 0xadb90e94af887717 , 0x00003ffe //   log(1/frcpa(1+248/2^-8))
data8 0xae3754a218f7c816 , 0x00003ffe //   log(1/frcpa(1+249/2^-8))
data8 0xaeb5d9175437afa2 , 0x00003ffe //   log(1/frcpa(1+250/2^-8))

data8 0xaf349c322e9c7cee , 0x00003ffe //   log(1/frcpa(1+251/2^-8))
data8 0xafb39e30d1768d1c , 0x00003ffe //   log(1/frcpa(1+252/2^-8))
data8 0xb032df51c2c93116 , 0x00003ffe //   log(1/frcpa(1+253/2^-8))
data8 0xb0b25fd3e6035ad9 , 0x00003ffe //   log(1/frcpa(1+254/2^-8))
data8 0xb1321ff67cba178c , 0x00003ffe //   log(1/frcpa(1+255/2^-8))


   
.align 32
.global log#
.global log10#

// log10 has p7 true, p8 false
// log   has p8 true, p7 false

.section .text
.proc  log10#
.align 32

log10: 
{ .mfi
      alloc     r32=ar.pfs,1,18,4,0                    
(p0)  frcpa.s1  log_C,p9 = f1,f8                 
(p0)  cmp.eq.unc     p7,p8         = r0, r0 
}
{ .mfb
(p0)  addl           r40   = @ltoff(log_p_table), gp
(p0)  fnorm log_NORM_f8 = f8 
(p0)  br.sptk        LOG_LN_X 
}
;;

.endp log10



.section .text
.proc  log#
.align 32
log: 

{ .mfi
      alloc     r32=ar.pfs,1,18,4,0                    
(p0)  frcpa.s1  log_C,p9 = f1,f8                 
(p0)  cmp.eq.unc     p8,p7         = r0, r0 
}
{ .mfi
(p0)  addl           r40   = @ltoff(log_p_table), gp
(p0)  fnorm log_NORM_f8 = f8 
      nop.i 999
}
;;

LOG_LN_X:

{ .mmf
(p0)  addl           r43   = @ltoff(log_q_table), gp
      ld8 r40 = [r40]
(p0) fms.s1     log_w = f8,f1,f1              
}
;;

{ .mmi
      ld8 r43 = [r43]
(p0)  mov       log_GR_exp_16_ones = 0xffff
(p0)  mov       log_GR_exp_17_ones = 0x1ffff
}
;;

{.mfi
(p0) ldfpd      log_P5,log_P4 = [r40],16           
     nop.f 999
(p0) mov        log_GR_fff9 = 0xfff9 ;;
}

{ .mmi
(p0) ldfpd      log_Q8,log_Q7 = [r43],16           
        nop.m 999
        nop.i 999 ;;
}


{ .mmi
(p0) ldfpd      log_Q3,log_Q4 = [r43],16           
(p0) ldfd       log_P3 = [r40],8 
        nop.i 999 ;;
}


{ .mmf
(p0) ldfd       log_Q6 = [r43],8           
(p0) ldfd       log_P2 = [r40],8      
(p0) fms.s1     log_r = log_C,f8,f1 ;;
}


{ .mmf
(p0) ldfd       log_Q2 = [r43],8
(p0) ldfd       log_P1 = [r40],16 
(p0) fma.s1     log_wsq     = log_w, log_w, f0
;;
}
   

{ .mmi
(p0) getf.sig   log_GR_significand_f8 = log_NORM_f8 
(p0) ldfe       log_inv_ln10 = [r40],16      
        nop.i 999 ;;
}


{ .mmf
(p0) getf.exp   log_GR_signexp_f8 = log_NORM_f8                    
(p0) ldfd       log_Q5 = [r43],8 
(p0) fcmp.eq.s1 p10,p0 = log_NORM_f8, f1
;;
}

{ .mmf
(p0) getf.exp   log_GR_signexp_w = log_w
(p0) ldfe       log_log2 = [r40],16   
(p0) fclass.m.unc p6,p0 = f8, 0xa7 
;;
}
 

{ .mfi
(p0) ldfd       log_Q1 = [r43],16          
(p0) fclass.m.unc p12,p0 = f8, 0x1a 
(p0) shl        r39 = log_GR_significand_f8,1            
}
{ .mfi
          nop.m 999
(p0) fma.s1     log_rsq     = log_r, log_r, f0                   
(p0) and        log_GR_exp_f8 = log_GR_signexp_f8, log_GR_exp_17_ones  
;;
}

{ .mfi
(p0)  sub       log_GR_true_exp_f8 = log_GR_exp_f8, log_GR_exp_16_ones 
(p0)  fma.s1    log_rp_p4   = log_P5, log_r, log_P4                 // u1 
(p0)  shr.u     r39 = r39,56 
}
{ .mfi
         nop.m 999
(p0) fma.s1      log_w4      = log_wsq, log_wsq, f0
(p0)  and log_GR_exp_w = log_GR_exp_17_ones, log_GR_signexp_w 
;;
}




{ .mfi
         nop.m 999
(p0)  fma.s1    log_rp_q7   = log_Q8, log_w, log_Q7                 // v1 
      shl r39 = r39,4 
;;
}


//    p13 <== Large W ln
//    p14 <== small w ln
{ .mfi
(p0) setf.sig  log_int_Nfloat = log_GR_true_exp_f8
(p10) fmerge.s f8 = f0, f0
(p0) add       r40 = r39,r40 
}
{ .mfb
(p8)  cmp.ge.unc p13,p14 = log_GR_exp_w, log_GR_fff9
(p0) fma.s1    log_rp_q3   = log_Q4, log_w, log_Q3               // v2
(p10) br.ret.spnt b0                // Exit for x=1.0
;;
}

{ .mbb
       nop.m 999
(p6)  br.cond.spnt LOG_NAN_ZERO_INF_PN 
(p12) br.cond.spnt LOG_NAN_ZERO_INF_PN
;;
}

{ .mbb
(p0) ldfe       log_T = [r40]                                    
        nop.b 999
        nop.b 999
;;
}


{ .mfi
        nop.m 999
(p0) fma.s1        log_rp_p3   = log_rp_p4, log_r, log_P3          // u2
(p7)  cmp.ge.unc p10,p11 = log_GR_exp_w, log_GR_fff9     
;;
}

{ .mfi
        nop.m 999
(p0) fma.s1        log_rp_q6   = log_rp_q7, log_w, log_Q6           // v3
        nop.i 999 ;;
}

{ .mfi
        nop.m 999
(p0) fma.s1        log_rp_q2   = log_rp_q3, log_w, log_Q2         // v4
        nop.i 999 ;;
}


{ .mfi
        nop.m 999
(p0) fma.s1        log_rp_p2   = log_rp_p3, log_r, log_P2        // u3
        nop.i 999 ;;
}



{ .mfi
        nop.m 999
(p0) fma.s1        log_Qlo     = log_rp_q6, log_w, log_Q5           
        nop.i 999 
}
{ .mfi
        nop.m 999
(p0)  fcvt.xf   log_Nfloat = log_int_Nfloat 
        nop.i 999 ;;
}



{ .mfi
        nop.m 999
(p0) fma.s1        log_Qhi     = log_rp_q2, log_w, log_Q1           
        nop.i 999 ;;
}


{ .mfi
        nop.m 999
(p0) fma.s1        log_pseries = log_rp_p2, log_r, log_P1           
        nop.i 999 ;;
}


{ .mfi
        nop.m 999
(p0) fma.s1        log_T_plus_Nlog2 = log_Nfloat,log_log2, log_T    
        nop.i 999
}
{ .mfi
        nop.m 999
(p0) fma.s1        log_Q       = log_Qlo, log_w4, log_Qhi          
        nop.i 999 ;;
}


//    small w, ln    <== p13
//    small w, log10 <== p10
.pred.rel "mutex",p13,p10
{ .mfi
           nop.m 999
(p13)   fma.s1        log_r2P_r        = log_rsq, log_pseries, log_r 
           nop.i 999 
}
{ .mfi
           nop.m 999
(p10)   fma.s1        log_r2P_r        = log_rsq, log_pseries, log_r
           nop.i 999 ;;
}

//    small w, ln    <== p14
//    small w, log10 <== p11
.pred.rel "mutex",p14,p11
{ .mfi
           nop.m 999
(p14) fma.d      f8 = log_wsq, log_Q, log_w                      
           nop.i 999 
}
{ .mfi
           nop.m 999
(p11) fma.s1        f8 = log_wsq, log_Q, log_w                      
           nop.i 999 ;;
}

{ .mfi
           nop.m 999
(p10) fma.s1        log_log10_hi     = log_T_plus_Nlog2, log_inv_ln10,f0
           nop.i 999  ;;
}

//    large W,  ln  <== p13
//    large Ww, log <== p10
.pred.rel "mutex",p13,p10
{ .mfi
	nop.m 999
(p13) fadd.d        f8              = log_T_plus_Nlog2, log_r2P_r 
	nop.i 999 
}
{ .mfi
        nop.m 999
(p10)  fma.s1     log_log10_lo     = log_inv_ln10, log_r2P_r,f0
        nop.i 999  ;;
}


{ .mfi
	nop.m 999
(p11) fma.d      f8 = log_inv_ln10,f8,f0                         
(p0)  nop.i 999 
;;
}

{ .mfb
	nop.m 999
(p10) fma.d      f8                = log_log10_hi, f1, log_log10_lo 
(p0) br.ret.sptk     b0 
;;
}

LOG_NAN_ZERO_INF_PN: 

// qnan snan inf norm     unorm 0 -+
// 1    1    0   0        0     0 11      0xc3
// 0    0    0   0        0     1 11      0x7
// 0    0    1   1        1     0 10      0x3a
// 0    0    1   0        0     0 01      0x21

// Save x (f8) in f10



{ .mfi
	nop.m 999
(p0) fmerge.s f10 = f8,f8 
	nop.i 999
}

// p11 NAN
// p12 means log(+inf)

// Later p11, p12 used for frcpa
// p8 p9  means  ln(+-0)  = -inf
// p7 p10 means  log(+-0) = -inf

//    p13 means  ln(-)
//    p14 means  log(-)



// Log(+nan, -nan)
// At this point we know it is quiet
// So return


{ .mfi
	nop.m 999
(p0)  fclass.m.unc  p11,p0 = f8, 0xc3
	nop.i 999  
}
{ .mfi
	nop.m 999
(p0)  fmerge.ns   f6 = f1,f1                
	nop.i 999  ;;
}

{ .mfb
	nop.m 999
(p0)  fclass.m.unc  p12,p0 = f8, 0x21
        nop.b 999 ;;
}

{ .mbb
        nop.m 999
(p11)  br.ret.sptk     b0 
(p12)  br.ret.sptk     b0 ;;                                         
}


// We stay in ERROR RETURN.
// Input is not a NAN

// p9  means  ln(+-0)  = -inf
// p10 means  log(+-0) = -inf
// Log(+-0) = -inf 

{ .mfi
	nop.m 999
(p8)  fclass.m.unc  p9,p0 = f10, 0x07           
	nop.i 999
}
{ .mfi
	nop.m 999
(p7)  fclass.m.unc  p10,p0 = f10, 0x07           
	nop.i 999 ;;
}


// p13  ln(-)
// p14  log(-)

// Log(-inf, -normal, -unnormal) = QNAN indefinite
{ .mfi
	nop.m 999
(p8)  fclass.m.unc  p13,p0 = f10, 0x3a           
	nop.i 999 
}
{ .mfi
	nop.m 999
(p7)  fclass.m.unc  p14,p0 = f10, 0x3a           
	nop.i 999  ;;
}


.pred.rel "mutex",p9,p10
{ .mmi
(p9)     mov        log_GR_tag = 2       
(p10)    mov        log_GR_tag = 8       
            nop.i 999 ;;
}

.pred.rel "mutex",p13,p14
{ .mmi
(p13)    mov        log_GR_tag = 3       
(p14)    mov        log_GR_tag = 9       
            nop.i 999 ;;
}


.pred.rel "mutex",p9,p10
{ .mfi
            nop.m 999
(p9)    frcpa f8,p11 = f6,f0                   
            nop.i 999
}
{ .mfi
            nop.m 999
(p10)   frcpa f8,p12 = f6,f0                   
            nop.i 999 ;;
}

{ .mfi
            nop.m 999
(p13)    frcpa f8,p11 = f0,f0                   
            nop.i 999
}
{ .mfb
            nop.m 999
(p14)   frcpa f8,p12 = f0,f0                   
        br.cond.sptk __libm_error_region ;; 
}
.endp log


// Stack operations when calling error support.
//       (1)               (2)                          (3) (call)              (4)
//   sp   -> +          psp -> +                     psp -> +                   sp -> +
//           |                 |                            |                         |
//           |                 | <- GR_Y               R3 ->| <- GR_RESULT            | -> f8
//           |                 |                            |                         |
//           | <-GR_Y      Y2->|                       Y2 ->| <- GR_Y                 |
//           |                 |                            |                         |
//           |                 | <- GR_X               X1 ->|                         |
//           |                 |                            |                         |
//  sp-64 -> +          sp ->  +                     sp ->  +                         +
//    save ar.pfs          save b0                                               restore gp
//    save gp                                                                    restore ar.pfs



.proc __libm_error_region
__libm_error_region:
.prologue

// (1)
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                          // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                      // Save gp
};;


// (2)
{ .mmi
        stfd [GR_Parameter_Y] = f1,16         // STORE Parameter 2 on stack
        add GR_Parameter_X = 16,sp            // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                     // Save b0
};;

.body
// (3)
{ .mib
        stfd [GR_Parameter_X] = f10                   // STORE Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y  // Parameter 3 address
        nop.b 0                             
}
{ .mib
        stfd [GR_Parameter_Y] = f8                    // STORE Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#         // Call error handling function
};;

{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

// (4)
{ .mmi
        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region


.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\logbf.s ===
.file "logbf.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version
// 2/16/00  Modified to conform to C9X 
// 3/16/00  Improved speed
// 4/04/00  Unwind support added
// 5/30/00  Fixed bug when x double-extended denormal
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
//
// API
//==============================================================
// float _logbf( float x);
//
// Overview of operation
//==============================================================
// The logbf function extracts the exponent of x as an integer in 
// floating-point format. 
// logbf computes log2 of x as a float

// logbf is similar to ilogbf but differs in the  following ways:
//         +-inf
//            ilogbf: returns INT_MAX
//             logbf: returns +inf
//         Nan  returns FP_LOGBNAN (which is either INT_MAX or INT_MIN)
//            ilogbf: returns INT_MAX (7fffffff)
//             logbf: returns QNAN (quietized SNAN)
//         0    returns FP_ILOGB0 (which is either INT_MIN or -INT_MAX)
//            ilogbf: returns -INT_MAX (80000001)
//             logbf: returns -inf, raises the divide-by-zero exception,
//                   and calls libm_error_support to set domain error
//
// Registers used
//==============================================================
// general registers used: 
// ar.pfs r32 
// r33 -> r37
// r38 -> r41 used as parameters to error path
//
// predicate registers used: 
// p6, p7, p8
//
// floating-point registers used: 
// f9, f10, f11
// f8, input

GR_SAVE_B0                    = r34
// r40 is address of table of coefficients
GR_SAVE_PFS                   = r32
GR_SAVE_GP                    = r35 

GR_Parameter_X                = r38
GR_Parameter_Y                = r39
GR_Parameter_RESULT           = r40
GR_Parameter_TAG              = r41

FR_X             = f8
FR_Y             = f0
FR_RESULT        = f10


.align 32
.global _logbf#

.section .text
.proc  _logbf#
.align 32


_logbf: 

// qnan snan inf norm     unorm 0 -+
// 0    0    0   0        1     0 11
// 0                      b
{ .mfi
      alloc          r32=ar.pfs,1,5,4,0
(p0)  fclass.m.unc  p8,p0 = f8, 0x0b
      nop.i 999
}
// X NORMAL
// r37 = exp(f8) - - 0xffff
// sig(f8) = r37
// f8 = convert_to_fp (sig))
{ .mfi
(p0)  getf.exp      r35 = f8
(p0)  fnorm         f10=f8
      nop.i 999 ;;
}

// qnan snan inf norm     unorm 0 -+
// 1    1    1   0        0     0 11
// e                      3
{ .mmf
(p0)  mov      r33 = 0xffff
(p0)  mov      r34 = 0x1ffff
(p0)  fclass.m.unc  p6,p0 = f8, 0xe3 ;;
}

{ .mfb
(p0)  and           r36 = r35, r34
(p0)  fclass.m.unc  p7,p0 = f8, 0x07
(p8)  br.cond.spnt  LOGB_DENORM ;;
}

{ .mib
(p0)  sub           r37 = r36, r33
      nop.i 999
(p6)  br.cond.spnt  LOGB_NAN_INF ;;
}

{ .mib
(p0)  setf.sig      f9  = r37
      nop.i 999
(p7)  br.cond.spnt  LOGB_ZERO ;;
}

{ .mfi
      nop.m 999
(p0)  fcvt.xf       f10 = f9
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
(p0)  fnorm.s       f8 = f10
(p0)  br.ret.sptk    b0 ;;
}

LOGB_DENORM:
// Form signexp of 2^64 in case need to scale denormal
// Check to see if double-extended denormal
{ .mfi
(p0)  mov r38 = 0x1003f
(p0)  fclass.m.unc  p8,p0 = f10, 0x0b
      nop.i 999 ;;
}

// Form 2^64 in case need to scale denormal
{ .mfi
(p0)  setf.exp f11 = r38
      nop.f 999
      nop.i 999 ;;
}

// If double-extended denormal add 64 to exponent bias for scaling
// If double-extended denormal form x * 2^64 which is normal
{ .mfi
(p8)  add r33 = 64, r33
(p8)  fmpy f10 = f10, f11    
      nop.i 999 ;;
}

// Logic is the same as normal path but use normalized input
{ .mmi
(p0)  getf.exp      r35 = f10 ;;
      nop.m 999
      nop.i 999 ;;
}

{ .mmi
(p0)  and           r36 = r35, r34 ;;
(p0)  sub           r37 = r36, r33
      nop.i 999 ;;
}

{ .mmi
(p0)  setf.sig      f9  = r37
      nop.m 999
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fcvt.xf       f10 = f9
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
(p0)  fnorm.s       f8 = f10
(p0)  br.ret.sptk    b0 ;;
}

LOGB_NAN_INF: 

// X NAN or INFINITY, return f8 * f8
{ .mfb
      nop.m 999
(p0)  fma.s      f8= f8,f8,f0
(p0)  br.ret.sptk   b0 ;;
}

LOGB_ZERO: 

// X ZERO
// return -1.0/fabs(f8)=-inf, set divide-by-zero flag, call error support
{ .mfi
      nop.m 999
(p0)  fmerge.s      f9 = f0,f8
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fmerge.ns     f10 = f0,f9
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  frcpa         f10,p6 = f1,f10
      nop.i 999 ;;
}

.endp _logbf


.proc __libm_error_region
__libm_error_region:
.prologue
{ .mii
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
(p0)    mov   GR_Parameter_TAG = 152                   
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfs [GR_Parameter_Y] = FR_Y,16         // Store Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
};;
.body
{ .mib
        stfs [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
        nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfs [GR_Parameter_Y] = FR_RESULT       // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#   // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;
{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp 
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};; 

.endp __libm_error_region



.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\libm_error.c ===
//     
// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story, James
// Edwards, and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version
// 3/22/00: Updated to support flexible and dynamic error handling. 
//

#include <errno.h>
#include <stdio.h>
#include "libm_support.h"

_LIB_VERSION_TYPE
#if defined( __MS__ )
_LIB_VERSION = _MS_;
#elif defined( _POSIX_ )
_LIB_VERSION = __POSIX__;
#elif defined( __XOPEN__ )
_LIB_VERSION = _XOPEN_;
#elif defined( __SVID__ )
_LIB_VERSION = _SVID_;
#elif defined( __IEEE__ )
_LIB_VERSION = _IEEE_;
#else
_LIB_VERSION = _ISOC_;
#endif

void __libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
{


# ifdef __cplusplus
struct __exception exc;
# else 
struct exception  exc;
# endif 

struct exceptionf excf;

const char float_inf[4] = {0x00,0x00,0x80,0x7F};
const char float_huge[4] = {0xFF,0xFF,0x7F,0x7F};
const char float_zero[4] = {0x00,0x00,0x00,0x00};
const char float_neg_inf[4] = {0x00,0x00,0x80,0xFF};
const char float_neg_huge[4] = {0xFF,0xFF,0x7F,0xFF};
const char float_neg_zero[4] = {0x00,0x00,0x00,0x80};

const char double_inf[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x7F}; 
const char double_huge[8] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0x7F};
const char double_zero[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
const char double_neg_inf[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0xFF}; 
const char double_neg_huge[8] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0xFF};
const char double_neg_zero[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80};

const char long_double_inf[10] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xFF,0x7F}; 
const char long_double_huge[10] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0x7F};
const char long_double_zero[10] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
const char long_double_neg_inf[10] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xFF,0xFF}; 
const char long_double_neg_huge[10] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFF};
const char long_double_neg_zero[10] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80};

#define RETVAL_HUGE_VALD *(double *)retval = *(double *) double_inf
#define RETVAL_NEG_HUGE_VALD *(double *)retval = *(double *) double_neg_inf
#define RETVAL_HUGED *(double *)retval = (double) *(float *)float_huge
#define RETVAL_NEG_HUGED *(double *)retval = (double) *(float *) float_neg_huge 

#define RETVAL_HUGE_VALF *(float *)retval =  *(float *) float_inf
#define RETVAL_NEG_HUGE_VALF *(float *)retval = *(float *) float_neg_inf
#define RETVAL_HUGEF *(float *)retval = *(float *) float_huge
#define RETVAL_NEG_HUGEF *(double *)retval = *(float *) float_neg_huge 

#define RETVAL_ZEROD *(double *)retval = *(double *)double_zero 
#define RETVAL_ZEROF *(float *)retval = *(float *)float_zero 

#define RETVAL_NEG_ZEROD *(double *)retval = *(double *)double_neg_zero 
#define RETVAL_NEG_ZEROF *(float *)retval = *(float *)float_neg_zero 

#define RETVAL_ONED *(double *)retval = 1.0 
#define RETVAL_ONEF *(float *)retval = 1.0f 

#ifdef __MS__
#define NOT_MATHERRD exc.arg1=*(double *)arg1;exc.arg2=*(double *)arg2;exc.retval=*(double *)retval;if(!_matherr(&exc))
#define NOT_MATHERRF excf.arg1=*(float *)arg1;excf.arg2=*(float *)arg2;excf.retval=*(float *)retval;if(!_matherr(&excf))
#else
#define NOT_MATHERRD exc.arg1=*(double *)arg1;exc.arg2=*(double *)arg2;exc.retval=*(double *)retval;if(!matherr(&exc))
#define NOT_MATHERRF excf.arg1=*(float *)arg1;excf.arg2=*(float *)arg2;excf.retval=*(float *)retval;if(!matherrf(&excf))
#endif

#define ifSVID if(_LIB_VERSION==_SVID_)

#define NAMED exc.name  
#define NAMEF excf.name  

//
// These should work OK for MS because they are ints -
// leading underbars are not necessary.
//

#define DOMAIN          1
#define SING            2
#define OVERFLOW        3
#define UNDERFLOW       4
#define TLOSS           5
#define PLOSS           6

#define SINGD exc.type = SING
#define DOMAIND exc.type = DOMAIN 
#define OVERFLOWD exc.type = OVERFLOW 
#define UNDERFLOWD exc.type = UNDERFLOW 
#define TLOSSD exc.type = TLOSS 
#define SINGF excf.type = SING
#define DOMAINF excf.type = DOMAIN 
#define OVERFLOWF excf.type = OVERFLOW 
#define UNDERFLOWF excf.type = UNDERFLOW 
#define TLOSSF excf.type = TLOSS 

#define INPUT_XD (exc.arg1=*(double*)arg1)
#define INPUT_XF (excf.arg1=*(float*)arg1)
#define INPUT_YD (exc.arg1=*(double*)arg2)
#define INPUT_YF (excf.arg1=*(float*)arg2)
#define INPUT_RESD (*(double *)retval)
#define INPUT_RESF (*(float *)retval)

#if     defined( __MS__)
#define WRITEL_LOG_ZERO 
#define WRITED_LOG_ZERO 
#define WRITEF_LOG_ZERO 
#define WRITEL_LOG_NEGATIVE
#define WRITED_LOG_NEGATIVE
#define WRITEF_LOG_NEGATIVE
#define WRITEL_Y0_ZERO 
#define WRITED_Y0_ZERO 
#define WRITEF_Y0_ZERO 
#define WRITEL_Y0_NEGATIVE
#define WRITED_Y0_NEGATIVE
#define WRITEF_Y0_NEGATIVE
#define WRITEL_Y1_ZERO
#define WRITED_Y1_ZERO
#define WRITEF_Y1_ZERO
#define WRITEL_Y1_NEGATIVE
#define WRITED_Y1_NEGATIUE
#define WRITEF_Y1_NEGATIVE
#define WRITEL_YN_ZERO
#define WRITED_YN_ZERO
#define WRITEF_YN_ZERO
#define WRITEL_YN_NEGATIVE
#define WRITED_YN_NEGATIVE
#define WRITEF_YN_NEGATIVE
#define WRITEL_LOG1P_ZERO
#define WRITED_LOG1P_ZERO
#define WRITEF_LOG1P_ZERO
#define WRITEL_LOG1P_NEGATIVE
#define WRITED_LOG1P_NEGATIVE
#define WRITEF_LOG1P_NEGATIVE
#define WRITEL_LOG10_ZERO
#define WRITED_LOG10_ZERO
#define WRITEF_LOG10_ZERO
#define WRITEL_LOG10_NEGATIVE
#define WRITED_LOG10_NEGATIVE
#define WRITEF_LOG10_NEGATIVE
#define WRITEL_POW_ZERO_TO_ZERO
#define WRITED_POW_ZERO_TO_ZERO
#define WRITEF_POW_ZERO_TO_ZERO
#define WRITEL_POW_ZERO_TO_NEGATIVE
#define WRITED_POW_ZERO_TO_NEGATIVE
#define WRITEF_POW_ZERO_TO_NEGATIVE
#define WRITEL_POW_NEG_TO_NON_INTEGER
#define WRITED_POW_NEG_TO_NON_INTEGER
#define WRITEF_POW_NEG_TO_NON_INTEGER
#define WRITEL_ATAN2_ZERO_BY_ZERO
#define WRITED_ATAN2_ZERO_BY_ZERO
#define WRITEF_ATAN2_ZERO_BY_ZERO
#define WRITEL_SQRT
#define WRITED_SQRT
#define WRITEF_SQRT
#define WRITEL_FMOD
#define WRITED_FMOD
#define WRITEF_FMOD
#define WRITEL_REM 
#define WRITED_REM 
#define WRITEF_REM 
#define WRITEL_ACOS
#define WRITED_ACOS
#define WRITEF_ACOS
#define WRITEL_ASIN
#define WRITED_ASIN
#define WRITEF_ASIN
#define WRITEL_ACOSH
#define WRITED_ACOSH
#define WRITEF_ACOSH
#define WRITEL_ATANH_GT_ONE
#define WRITED_ATANH_GT_ONE
#define WRITEF_ATANH_GT_ONE
#define WRITEL_ATANH_EQ_ONE
#define WRITED_ATANH_EQ_ONE
#define WRITEF_ATANH_EQ_ONE
#define WRITEL_LGAMMA_NEGATIVE
#define WRITED_LGAMMA_NEGATIVE
#define WRITEF_LGAMMA_NEGATIVE
#define WRITEL_GAMMA_NEGATIVE
#define WRITED_GAMMA_NEGATIVE
#define WRITEF_GAMMA_NEGATIVE
#define WRITEL_J0_TLOSS
#define WRITEL_Y0_TLOSS
#define WRITEL_J1_TLOSS
#define WRITEL_Y1_TLOSS
#define WRITEL_JN_TLOSS
#define WRITEL_YN_TLOSS
#define WRITED_J0_TLOSS
#define WRITED_Y0_TLOSS
#define WRITED_J1_TLOSS
#define WRITED_Y1_TLOSS
#define WRITED_JN_TLOSS
#define WRITED_YN_TLOSS
#define WRITEF_J0_TLOSS
#define WRITEF_Y0_TLOSS
#define WRITEF_J1_TLOSS
#define WRITEF_Y1_TLOSS
#define WRITEF_JN_TLOSS
#define WRITEF_YN_TLOSS
#else
#define WRITEL_LOG_ZERO fputs("logl: SING error\n",stderr)
#define WRITED_LOG_ZERO fputs("log: SING error\n",stderr)
#define WRITEF_LOG_ZERO fputs("logf: SING error\n",stderr)
#define WRITEL_LOG_NEGATIVE fputs("logl: DOMAIN error\n",stderr)
#define WRITED_LOG_NEGATIVE fputs("log: DOMAIN error\n",stderr)
#define WRITEF_LOG_NEGATIVE fputs("logf: DOMAIN error\n",stderr)
#define WRITEL_Y0_ZERO fputs("y0l: DOMAIN error\n",stderr)
#define WRITED_Y0_ZERO fputs("y0: DOMAIN error\n",stderr)
#define WRITEF_Y0_ZERO fputs("y0f: DOMAIN error\n",stderr)
#define WRITEL_Y0_NEGATIVE fputs("y0l: DOMAIN error\n",stderr)
#define WRITED_Y0_NEGATIVE fputs("y0: DOMAIN error\n",stderr)
#define WRITEF_Y0_NEGATIVE fputs("y0f: DOMAIN error\n",stderr)
#define WRITEL_Y1_ZERO fputs("y1l: DOMAIN error\n",stderr)
#define WRITED_Y1_ZERO fputs("y1: DOMAIN error\n",stderr)
#define WRITEF_Y1_ZERO fputs("y1f: DOMAIN error\n",stderr)
#define WRITEL_Y1_NEGATIVE fputs("y1l: DOMAIN error\n",stderr)
#define WRITED_Y1_NEGATIUE fputs("y1: DOMAIN error\n",stderr)
#define WRITEF_Y1_NEGATIVE fputs("y1f: DOMAIN error\n",stderr)
#define WRITEL_YN_ZERO fputs("ynl: DOMAIN error\n",stderr)
#define WRITED_YN_ZERO fputs("yn: DOMAIN error\n",stderr)
#define WRITEF_YN_ZERO fputs("ynf: DOMAIN error\n",stderr)
#define WRITEL_YN_NEGATIVE fputs("ynl: DOMAIN error\n",stderr)
#define WRITED_YN_NEGATIVE fputs("yn: DOMAIN error\n",stderr)
#define WRITEF_YN_NEGATIVE fputs("ynf: DOMAIN error\n",stderr)
#define WRITEL_LOG1P_ZERO fputs("log1pl: SING error\n",stderr)
#define WRITED_LOG1P_ZERO fputs("log1p: SING error\n",stderr)
#define WRITEF_LOG1P_ZERO fputs("log1pf: SING error\n",stderr)
#define WRITEL_LOG1P_NEGATIVE fputs("log1pl: DOMAIN error\n",stderr)
#define WRITED_LOG1P_NEGATIVE fputs("log1p: DOMAIN error\n",stderr)
#define WRITEF_LOG1P_NEGATIVE fputs("log1pf: DOMAIN error\n",stderr)
#define WRITEL_LOG10_ZERO fputs("log10l: SING error\n",stderr)
#define WRITED_LOG10_ZERO fputs("log10: SING error\n",stderr) 
#define WRITEF_LOG10_ZERO fputs("log10f: SING error\n",stderr)
#define WRITEL_LOG10_NEGATIVE fputs("log10l: DOMAIN error\n",stderr)
#define WRITED_LOG10_NEGATIVE fputs("log10: DOMAIN error\n",stderr)
#define WRITEF_LOG10_NEGATIVE fputs("log10f: DOMAIN error\n",stderr)
#define WRITEL_POW_ZERO_TO_ZERO fputs("powl(0,0): DOMAIN error\n",stderr)
#define WRITED_POW_ZERO_TO_ZERO fputs("pow(0,0): DOMAIN error\n",stderr)
#define WRITEF_POW_ZERO_TO_ZERO fputs("powf(0,0): DOMAIN error\n",stderr)
#define WRITEL_POW_ZERO_TO_NEGATIVE fputs("powl(0,negative): DOMAIN error\n",stderr)
#define WRITED_POW_ZERO_TO_NEGATIVE fputs("pow(0,negative): DOMAIN error\n",stderr)
#define WRITEF_POW_ZERO_TO_NEGATIVE fputs("powf(0,negative): DOMAIN error\n",stderr)
#define WRITEL_POW_NEG_TO_NON_INTEGER fputs("powl(negative,non-integer): DOMAIN error\n",stderr)
#define WRITED_POW_NEG_TO_NON_INTEGER fputs("pow(negative,non-integer): DOMAIN error\n",stderr)
#define WRITEF_POW_NEG_TO_NON_INTEGER fputs("powf(negative,non-integer): DOMAIN error\n",stderr)
#define WRITEL_ATAN2_ZERO_BY_ZERO fputs("atan2l: DOMAIN error\n",stderr)
#define WRITED_ATAN2_ZERO_BY_ZERO fputs("atan2: DOMAIN error\n",stderr)
#define WRITEF_ATAN2_ZERO_BY_ZERO fputs("atan2f: DOMAIN error\n",stderr)
#define WRITEL_SQRT fputs("sqrtl: DOMAIN error\n",stderr)
#define WRITED_SQRT fputs("sqrt: DOMAIN error\n",stderr)
#define WRITEF_SQRT fputs("sqrtf: DOMAIN error\n",stderr)
#define WRITEL_FMOD fputs("fmodl: DOMAIN error\n",stderr)
#define WRITED_FMOD fputs("fmod: DOMAIN error\n",stderr)
#define WRITEF_FMOD fputs("fmodf: DOMAIN error\n",stderr)
#define WRITEL_REM fputs("remainderl: DOMAIN error\n",stderr)
#define WRITED_REM fputs("remainder: DOMAIN error\n",stderr)
#define WRITEF_REM fputs("remainderf: DOMAIN error\n",stderr)
#define WRITEL_ACOS fputs("acosl: DOMAIN error\n",stderr)
#define WRITED_ACOS fputs("acos: DOMAIN error\n",stderr)
#define WRITEF_ACOS fputs("acosf: DOMAIN error\n",stderr)
#define WRITEL_ASIN fputs("asinl: DOMAIN error\n",stderr)
#define WRITED_ASIN fputs("asin: DOMAIN error\n",stderr)
#define WRITEF_ASIN fputs("asinf: DOMAIN error\n",stderr)
#define WRITEL_ACOSH fputs("acoshl: DOMAIN error\n",stderr)
#define WRITED_ACOSH fputs("acosh: DOMAIN error\n",stderr)
#define WRITEF_ACOSH fputs("acoshf: DOMAIN error\n",stderr)
#define WRITEL_ATANH_GT_ONE fputs("atanhl: DOMAIN error\n",stderr)
#define WRITED_ATANH_GT_ONE fputs("atanh: DOMAIN error\n",stderr)
#define WRITEF_ATANH_GT_ONE fputs("atanhf: DOMAIN error\n",stderr)
#define WRITEL_ATANH_EQ_ONE fputs("atanhl: SING error\n",stderr)
#define WRITED_ATANH_EQ_ONE fputs("atanh: SING error\n",stderr)
#define WRITEF_ATANH_EQ_ONE fputs("atanhf: SING error\n",stderr)
#define WRITEL_LGAMMA_NEGATIVE fputs("lgammal: SING error\n",stderr)
#define WRITED_LGAMMA_NEGATIVE fputs("lgamma: SING error\n",stderr)
#define WRITEF_LGAMMA_NEGATIVE fputs("lgammaf: SING error\n",stderr)
#define WRITEL_GAMMA_NEGATIVE fputs("gammal: SING error\n",stderr)
#define WRITED_GAMMA_NEGATIVE fputs("gamma: SING error\n",stderr)
#define WRITEF_GAMMA_NEGATIVE fputs("gammaf: SING error\n",stderr)
#define WRITEL_J0_TLOSS  fputs("j0l: TLOSS error\n",stderr)
#define WRITEL_Y0_TLOSS  fputs("y0l: TLOSS error\n",stderr)
#define WRITEL_J1_TLOSS  fputs("j1l: TLOSS error\n",stderr)
#define WRITEL_Y1_TLOSS  fputs("y1l: TLOSS error\n",stderr)
#define WRITEL_JN_TLOSS  fputs("jnl: TLOSS error\n",stderr)
#define WRITEL_YN_TLOSS  fputs("ynl: TLOSS error\n",stderr)
#define WRITED_J0_TLOSS  fputs("j0: TLOSS error\n",stderr)
#define WRITED_Y0_TLOSS  fputs("y0: TLOSS error\n",stderr)
#define WRITED_J1_TLOSS  fputs("j1: TLOSS error\n",stderr)
#define WRITED_Y1_TLOSS  fputs("y1: TLOSS error\n",stderr)
#define WRITED_JN_TLOSS  fputs("jn: TLOSS error\n",stderr)
#define WRITED_YN_TLOSS  fputs("yn: TLOSS error\n",stderr)
#define WRITEF_J0_TLOSS  fputs("j0f: TLOSS error\n",stderr)
#define WRITEF_Y0_TLOSS  fputs("y0f: TLOSS error\n",stderr)
#define WRITEF_J1_TLOSS  fputs("j1f: TLOSS error\n",stderr)
#define WRITEF_Y1_TLOSS  fputs("y1f: TLOSS error\n",stderr)
#define WRITEF_JN_TLOSS  fputs("jnf: TLOSS error\n",stderr)
#define WRITEF_YN_TLOSS  fputs("ynf: TLOSS error\n",stderr)
#endif

/***********************/
/* IEEE Path           */
/***********************/
if(_LIB_VERSION==_IEEE_) return;

/***********************/
/* C9X Path           */
/***********************/
else if(_LIB_VERSION==_ISOC_) 
{
  switch(input_tag)
  {
    case log_zero:
    case logf_zero:
    case log10_zero:
    case log10f_zero:
    case exp_overflow:  
    case expf_overflow: 
    case expm1_overflow:  
    case expm1f_overflow: 
    case hypot_overflow:
    case hypotf_overflow:
    case sinh_overflow: 
    case sinhf_overflow: 
    case atanh_eq_one:  
    case atanhf_eq_one:  
    case scalb_overflow:
    case scalbf_overflow:
    case cosh_overflow:
    case coshf_overflow:
    case nextafter_overflow:
    case nextafterf_overflow:
    case ldexp_overflow:
    case ldexpf_overflow:
    case lgamma_overflow:
    case lgammaf_overflow:
    case lgamma_negative:
    case lgammaf_negative:
    case gamma_overflow:
    case gammaf_overflow:
    case gamma_negative:
    case gammaf_negative:
    {
         ERRNO_RANGE; break;
    }
    case log_negative:
    case logf_negative:
    case log10_negative:
    case log10f_negative:
    case log1p_negative:
    case log1pf_negative:
    case sqrt_negative:
    case sqrtf_negative:
    case atan2_zero:
    case atan2f_zero:
    case powl_zero_to_negative:
    case powl_neg_to_non_integer:
    case pow_zero_to_negative:
    case pow_neg_to_non_integer:
    case powf_zero_to_negative:
    case powf_neg_to_non_integer:
    case fmod_by_zero:
    case fmodf_by_zero:
    case atanh_gt_one:  
    case atanhf_gt_one:  
    case acos_gt_one: 
    case acosf_gt_one: 
    case asin_gt_one: 
    case asinf_gt_one: 
    case logb_zero: 
    case logbf_zero:
    case acosh_lt_one:
    case acoshf_lt_one:
    case y0l_zero:
    case y0_zero:
    case y0f_zero:
    case y1l_zero:
    case y1_zero:
    case y1f_zero:
    case ynl_zero:
    case yn_zero:
    case ynf_zero:
    case y0_negative:
    case y0f_negative:
    case y1_negative:
    case y1f_negative:
    case yn_negative:
    case ynf_negative:
    {
         ERRNO_DOMAIN; break;
    }
   }
   return;
}

/***********************/
/* _POSIX_ Path        */
/***********************/

else if(_LIB_VERSION==__POSIX__)
{
switch(input_tag)
  {
  case gamma_overflow:
  case lgamma_overflow:
  {
       RETVAL_HUGE_VALD; ERRNO_RANGE; break;
  }
  case gammaf_overflow:
  case lgammaf_overflow:
  {
       RETVAL_HUGE_VALF; ERRNO_RANGE; break;
  }
  case gamma_negative:
  case gammaf_negative:
  case lgamma_negative:
  case lgammaf_negative:
  {
       ERRNO_DOMAIN; break;
  }
  case ldexp_overflow:
  case ldexp_underflow:
  case ldexpf_overflow:
  case ldexpf_underflow:
  {
       ERRNO_RANGE; break;
  }
  case atanh_gt_one: 
  case atanh_eq_one: 
    /* atanh(|x| >= 1) */
    {
       ERRNO_DOMAIN; break;
    }
  case atanhf_gt_one: 
  case atanhf_eq_one: 
    /* atanhf(|x| >= 1) */
    {
       ERRNO_DOMAIN; break;
    }
  case sqrt_negative: 
    /* sqrt(x < 0) */
    {
       ERRNO_DOMAIN; break;
    }
  case sqrtf_negative: 
    /* sqrtf(x < 0) */
    {
       ERRNO_DOMAIN; break;
    }
  case y0_zero:
  case y1_zero:
  case yn_zero:
    /* y0(0) */
    /* y1(0) */
    /* yn(0) */
    {
       RETVAL_NEG_HUGE_VALD; ERRNO_DOMAIN; break;
    }
  case y0f_zero:
  case y1f_zero:
  case ynf_zero:
    /* y0f(0) */
    /* y1f(0) */
    /* ynf(0) */
    {
       RETVAL_NEG_HUGE_VALF; ERRNO_DOMAIN; break;
    }
  case y0_negative:
  case y1_negative:
  case yn_negative:
    /* y0(x < 0) */
    /* y1(x < 0) */
    /* yn(x < 0) */
    {
       RETVAL_NEG_HUGE_VALD; ERRNO_DOMAIN; break;
    } 
  case y0f_negative:
  case y1f_negative:
  case ynf_negative:
    /* y0f(x < 0) */
    /* y1f(x < 0) */
    /* ynf(x < 0) */
    {
       RETVAL_NEG_HUGE_VALF; ERRNO_DOMAIN; break;
    } 
  case log_zero:
  case log1p_zero:
  case log10_zero:
   /* log(0) */
   /* log1p(0) */
   /* log10(0) */
    {
       RETVAL_NEG_HUGE_VALD; ERRNO_RANGE; break;
    }
  case logf_zero:
  case log1pf_zero:
  case log10f_zero:
    /* logf(0) */
    /* log1pf(0) */
    /* log10f(0) */
    {
       RETVAL_NEG_HUGE_VALF; ERRNO_RANGE; break;
    }
  case log_negative:
  case log1p_negative:
  case log10_negative:
    /* log(x < 0) */
    /* log1p(x < 0) */
    /* log10(x < 0) */
    {
       RETVAL_NEG_HUGE_VALD; ERRNO_DOMAIN; break;
    } 
  case logf_negative:
  case log1pf_negative:
  case log10f_negative:
    /* logf(x < 0) */
    /* log1pf(x < 0) */
    /* log10f(x < 0) */
    {
       RETVAL_NEG_HUGE_VALF; ERRNO_DOMAIN; break;
    } 
  case exp_overflow:
    /* exp overflow */
    {
       RETVAL_HUGE_VALD; ERRNO_RANGE; break;
    }
  case expf_overflow:
    /* expf overflow */
    {
       RETVAL_HUGE_VALF; ERRNO_RANGE; break;
    }
  case exp_underflow:
    /* exp underflow */
    {
       RETVAL_ZEROD; ERRNO_RANGE; break;
    }
  case expf_underflow:
    /* expf underflow */
    {
       RETVAL_ZEROF; ERRNO_RANGE; break;
    }
  case j0_gt_loss:
  case y0_gt_loss:
  case j1_gt_loss:
  case y1_gt_loss:
  case jn_gt_loss:
  case yn_gt_loss:
    /* jn and yn double > XLOSS */
    {
       RETVAL_ZEROD; ERRNO_RANGE; break;
    }
  case j0f_gt_loss:
  case y0f_gt_loss:
  case j1f_gt_loss:
  case y1f_gt_loss:
  case jnf_gt_loss:
  case ynf_gt_loss:
    /* j0n and y0n > XLOSS */
    {
       RETVAL_ZEROF; ERRNO_RANGE; break;
    }
  case pow_zero_to_zero:
    /* pow 0**0 */
    {
       break;
    }
  case powf_zero_to_zero:
    /* powf 0**0 */
    {
       break;
    }
  case pow_overflow:
    /* pow(x,y) overflow */
    {
       if (INPUT_RESD < 0) RETVAL_NEG_HUGE_VALD;
       else RETVAL_HUGE_VALD;
       ERRNO_RANGE; break;
    }
  case powf_overflow:
    /* powf(x,y) overflow */
    {
       if (INPUT_RESF < 0) RETVAL_NEG_HUGE_VALF;
       else RETVAL_HUGE_VALF;
       ERRNO_RANGE; break;
    }
  case pow_underflow:
    /* pow(x,y) underflow */
    {
       RETVAL_ZEROD; ERRNO_RANGE; break;
    }
  case  powf_underflow:
    /* powf(x,y) underflow */
    {
       RETVAL_ZEROF; ERRNO_RANGE; break;
    }
  case pow_zero_to_negative:
    /* 0**neg */
    {
       ERRNO_DOMAIN; break;
    }
  case  powf_zero_to_negative:
    /* 0**neg */
    {
       ERRNO_DOMAIN; break;
    }
  case pow_neg_to_non_integer:
    /* neg**non_integral */
    {
       ERRNO_DOMAIN; break;
    }
  case  powf_neg_to_non_integer:
    /* neg**non-integral */
    {
       ERRNO_DOMAIN; break;
    }
  case  pow_nan_to_zero:
    /* pow(NaN,0.0) */
    {
       break;
    }
  case  powf_nan_to_zero:
    /* powf(NaN,0.0) */
    {
       break;
    }
  case atan2_zero:
    /* atan2(0,0) */
    {
       RETVAL_ZEROD; ERRNO_DOMAIN; break;
    }
  case
    atan2f_zero:
    /* atan2f(0,0) */
    {
       RETVAL_ZEROF; ERRNO_DOMAIN; break;
    }
  case expm1_overflow:
    /* expm1 overflow */
    {
       ERRNO_RANGE; break;
    }
  case expm1f_overflow:
    /* expm1f overflow */
    {
       ERRNO_RANGE; break;
    }
  case expm1_underflow:
    /* expm1 underflow */
    {
       ERRNO_RANGE; break;
    }
  case expm1f_underflow:
    /* expm1f underflow */
    {
       ERRNO_RANGE; break;
    }
  case hypot_overflow:
    /* hypot overflow */
    {
       RETVAL_HUGE_VALD; ERRNO_RANGE; break;
    }
  case hypotf_overflow:
    /* hypotf overflow */
    {
       RETVAL_HUGE_VALF; ERRNO_RANGE; break;
    }
  case scalb_underflow:
    /* scalb underflow */
    {
       if (INPUT_XD < 0) RETVAL_NEG_ZEROD; 
       else RETVAL_ZEROD;
       ERRNO_RANGE; break;
    }
  case scalbf_underflow:
    /* scalbf underflow */
    {
       if (INPUT_XF < 0) RETVAL_NEG_ZEROF; 
       else RETVAL_ZEROF;
       ERRNO_RANGE; break;
    }
  case scalb_overflow:
    /* scalb overflow */
    {
       if (INPUT_XD < 0) RETVAL_NEG_HUGE_VALD; 
       else RETVAL_HUGE_VALD;
       ERRNO_RANGE; break;
    }
  case scalbf_overflow:
    /* scalbf overflow */
    {
       if (INPUT_XF < 0) RETVAL_NEG_HUGE_VALF; 
       else RETVAL_HUGE_VALF;
       ERRNO_RANGE; break;
    }
  case acosh_lt_one:
    /* acosh(x < 1) */
    {
       ERRNO_DOMAIN; break;
    }
  case acoshf_lt_one:
    /* acoshf(x < 1) */
    {
        ERRNO_DOMAIN; break;
    }
  case acos_gt_one:
    /* acos(x > 1) */
    {
       RETVAL_ZEROD;ERRNO_DOMAIN; break;
    }
  case acosf_gt_one:
    /* acosf(x > 1) */
    {
       RETVAL_ZEROF;ERRNO_DOMAIN; break;
    }
  case asin_gt_one:
    /* asin(x > 1) */
    {
       RETVAL_ZEROD; ERRNO_DOMAIN; break;
    }
  case asinf_gt_one:
    /* asinf(x > 1) */
    {
       RETVAL_ZEROF; ERRNO_DOMAIN; break;
    }
  case remainder_by_zero:
  case fmod_by_zero:
    /* fmod(x,0) */
    {
       ERRNO_DOMAIN; break;
    }
  case remainderf_by_zero:
  case fmodf_by_zero:
    /* fmodf(x,0) */
    {
       ERRNO_DOMAIN; break;
    }
  case cosh_overflow:
    /* cosh overflows */
    {
       RETVAL_HUGE_VALD; ERRNO_RANGE; break;
    }
  case coshf_overflow:
    /* coshf overflows */
    {
       RETVAL_HUGE_VALF; ERRNO_RANGE; break;
    }
  case sinh_overflow:
    /* sinh overflows */
    {
       if (INPUT_XD > 0) RETVAL_HUGE_VALD;
       else RETVAL_NEG_HUGE_VALD;
       ERRNO_RANGE; break;
    }
  case sinhf_overflow:
    /* sinhf overflows */
    {
       if (INPUT_XF > 0) RETVAL_HUGE_VALF;
       else RETVAL_NEG_HUGE_VALF;
       ERRNO_RANGE; break;
    }
  case logb_zero:
   /* logb(0) */
   {
      ERRNO_DOMAIN; break;
   }
  case logbf_zero:
   /* logbf(0) */
   {
      ERRNO_DOMAIN; break;
   }
}
return;
/* _POSIX_ */
}

/***************************************/
/* __SVID__, __MS__ and __XOPEN__ Path */
/***************************************/
else 
{
  switch(input_tag)
  {
  case ldexp_overflow:
  case ldexp_underflow:
  case ldexpf_overflow:
  case ldexpf_underflow:
  {
       ERRNO_RANGE; break;
  }
  case sqrt_negative: 
    /* sqrt(x < 0) */
    {
       DOMAIND; NAMED = "sqrt";
       ifSVID 
       {
         
         RETVAL_ZEROD;
         NOT_MATHERRD 
         {
           WRITED_SQRT;
           ERRNO_DOMAIN;
         }
       }
       else
       { /* NaN already computed */
         NOT_MATHERRD {ERRNO_DOMAIN;}
       } 
       *(double *)retval = exc.retval;	
       break;
    }
  case sqrtf_negative: 
    /* sqrtf(x < 0) */
    {
       DOMAINF; NAMEF = "sqrtf"; 
       ifSVID 
       {
         RETVAL_ZEROF;
         NOT_MATHERRF 
         {
           WRITEF_SQRT;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case log_zero:
    /* log(0) */
    {
       SINGD; NAMED="log"; 
       ifSVID 
       {
         RETVAL_NEG_HUGED;
         NOT_MATHERRD 
         {
           WRITED_LOG_ZERO;
           ERRNO_DOMAIN;
         }  
       }
       else
       {
         RETVAL_NEG_HUGE_VALD;
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case logf_zero:
    /* logf(0) */
    {
       SINGF; NAMEF="logf"; 
       ifSVID 
       {
         RETVAL_NEG_HUGEF; 
         NOT_MATHERRF
         {
            WRITEF_LOG_ZERO;
            ERRNO_DOMAIN;
         }
       }
       else
       {
         RETVAL_NEG_HUGE_VALF; 
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }

  case log_negative:
    /* log(x < 0) */
    {
       DOMAIND; NAMED="log";
       ifSVID 
       {
         RETVAL_NEG_HUGED;
         NOT_MATHERRD 
         {
           WRITED_LOG_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALD;
#endif
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    } 
  case logf_negative:
    /* logf(x < 0) */
    {
       DOMAINF; NAMEF="logf";
       ifSVID 
       {
         RETVAL_NEG_HUGEF;
         NOT_MATHERRF 
         {
           WRITEF_LOG_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }  
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALF;
#endif
         NOT_MATHERRF{ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case log1p_zero:
    /* log1p(-1) */
    {
       SINGD; NAMED="log1p";
       ifSVID 
       {
         RETVAL_NEG_HUGED;
         NOT_MATHERRD
         {
           WRITED_LOG1P_ZERO;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         RETVAL_NEG_HUGE_VALD;
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;
       break;
    }
  case log1pf_zero:
    /* log1pf(-1) */
    {
       SINGF; NAMEF="log1pf";
       ifSVID 
       {
         RETVAL_NEG_HUGEF;
         NOT_MATHERRF
         {
           WRITEF_LOG1P_ZERO;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         RETVAL_NEG_HUGE_VALF;
         NOT_MATHERRF {}ERRNO_DOMAIN;
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    } 
 case log1p_negative:
   /* log1p(x < -1) */
   {
      DOMAIND; NAMED="log1p";
      ifSVID
      {
        RETVAL_NEG_HUGED;
        NOT_MATHERRD
        {
          WRITED_LOG1P_NEGATIVE;
          ERRNO_DOMAIN;
        }
      }
      else 
      {
#ifndef __MS__
        RETVAL_NEG_HUGE_VALD;
#endif
        NOT_MATHERRD {ERRNO_DOMAIN;}
      }
      *(double *)retval = exc.retval;
      break;
   }
 case log1pf_negative:
   /* log1pf(x < -1) */
   {
      DOMAINF; NAMEF="log1pf";
      ifSVID
      {
        RETVAL_NEG_HUGEF;
        NOT_MATHERRF
        {
          WRITEF_LOG1P_NEGATIVE;
          ERRNO_DOMAIN;
        }
      }
      else 
      {
#ifndef __MS__
        RETVAL_NEG_HUGE_VALF;
#endif
        NOT_MATHERRF {ERRNO_DOMAIN;}
      }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
      break;
   }
  case log10_zero:
    /* log10(0) */
    {
       SINGD; NAMED="log10";
       ifSVID 
       {
         RETVAL_NEG_HUGED;
         NOT_MATHERRD
         {
           WRITED_LOG10_ZERO;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         RETVAL_NEG_HUGE_VALD;
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case log10f_zero:
    /* log10f(0) */
    {
       SINGF; NAMEF="log10f";
       ifSVID 
       {
         RETVAL_NEG_HUGEF;
         NOT_MATHERRF
         {
          WRITEF_LOG10_ZERO;
          ERRNO_DOMAIN;
         }
       }
       else
       {
         RETVAL_NEG_HUGE_VALF;
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case log10_negative:
    /* log10(x < 0) */
    {
       DOMAIND; NAMED="log10";
       ifSVID 
       {
         RETVAL_NEG_HUGED;
         NOT_MATHERRD 
         {
           WRITED_LOG10_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }  
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALD;
#endif
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case log10f_negative:
    /* log10f(x < 0) */
    {
       DOMAINF; NAMEF="log10f";
       ifSVID 
       {
         RETVAL_NEG_HUGEF;
         NOT_MATHERRF 
         {
           WRITEF_LOG10_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALF;
#endif
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case exp_overflow:
    /* exp overflow */
    {
       OVERFLOWD; NAMED="exp";
       ifSVID 
       {
         RETVAL_HUGED;
       }
       else
       {
         RETVAL_HUGE_VALD;
       }
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;	
       break;
    }
  case expf_overflow:
    /* expf overflow */
    {
       OVERFLOWF; NAMEF="expf";
       ifSVID 
       {
         RETVAL_HUGEF;
       }
       else
       {
         RETVAL_HUGE_VALF;
       }
       NOT_MATHERRF {ERRNO_RANGE;}
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case exp_underflow:
    /* exp underflow */
    {
       UNDERFLOWD; NAMED="exp"; RETVAL_ZEROD;
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;	
       break;
    }
  case expf_underflow:
    /* expf underflow */
    {
       UNDERFLOWF; NAMEF="expf"; RETVAL_ZEROF;
       NOT_MATHERRF {ERRNO_RANGE;}
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case pow_zero_to_zero:
    /* pow 0**0 */
    {
       DOMAIND; NAMED="pow";
       ifSVID 
       {
         RETVAL_ZEROD;
         NOT_MATHERRD 
         {
            WRITED_POW_ZERO_TO_ZERO;
            ERRNO_RANGE;
         }
         *(double *)retval = exc.retval;	
       }
       else RETVAL_ONED;
       break;
    }
  case powf_zero_to_zero:
    /* powf 0**0 */
    {
       DOMAINF; NAMEF="powf";
       ifSVID 
       {
         RETVAL_ZEROF;
         NOT_MATHERRF 
         {
          WRITEF_POW_ZERO_TO_ZERO;
          ERRNO_RANGE;
         }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       }
       else RETVAL_ONEF;
       break;
    }
  case pow_overflow:
    /* pow(x,y) overflow */
    {
       OVERFLOWD; NAMED = "pow";
       ifSVID 
       {
         if (INPUT_XD < 0) RETVAL_NEG_HUGED;
         else RETVAL_HUGED;
       }
       else
       { 
         if (INPUT_XD < 0) RETVAL_NEG_HUGE_VALD;
         else RETVAL_HUGE_VALD;
       }
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;	
       break;
    }
  case powf_overflow:
    /* powf(x,y) overflow */
    {
       OVERFLOWF; NAMEF = "powf";
       ifSVID 
       {
         if (INPUT_XF < 0) RETVAL_NEG_HUGEF;
         else RETVAL_HUGEF; 
       }
       else
       { 
         if (INPUT_XF < 0) RETVAL_NEG_HUGE_VALF;
         else RETVAL_HUGE_VALF;
       }
       NOT_MATHERRF {ERRNO_RANGE;}
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case pow_underflow:
    /* pow(x,y) underflow */
    {
       UNDERFLOWD; NAMED = "pow"; RETVAL_ZEROD;
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;	
       break;
    }
  case powf_underflow:
    /* powf(x,y) underflow */
    {
       UNDERFLOWF; NAMEF = "powf"; RETVAL_ZEROF;
       NOT_MATHERRF {ERRNO_RANGE;}
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case pow_zero_to_negative:
    /* 0**neg */
    {
       DOMAIND; NAMED = "pow";
       ifSVID 
       { 
         RETVAL_ZEROD;
         NOT_MATHERRD 
         {
           WRITED_POW_ZERO_TO_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALD;
#endif
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case powf_zero_to_negative:
    /* 0**neg */
    {
       DOMAINF; NAMEF = "powf";
       RETVAL_NEG_HUGE_VALF;
       ifSVID 
       { 
         RETVAL_ZEROF;
         NOT_MATHERRF 
         {
            WRITEF_POW_ZERO_TO_NEGATIVE;
            ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALF;
#endif
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case pow_neg_to_non_integer:
    /* neg**non_integral */
    {
       DOMAIND; NAMED = "pow";
       ifSVID 
       { 
         RETVAL_ZEROD;
         NOT_MATHERRD 
         {
            WRITED_POW_NEG_TO_NON_INTEGER;
            ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case powf_neg_to_non_integer:
    /* neg**non-integral */
    {
       DOMAINF; NAMEF = "powf";
       ifSVID 
       { 
         RETVAL_ZEROF;
         NOT_MATHERRF 
         {
            WRITEF_POW_NEG_TO_NON_INTEGER;
            ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case pow_nan_to_zero:
    /* pow(NaN,0.0) */
    /* Special Error */
    {
       DOMAIND; NAMED = "pow"; INPUT_XD; INPUT_YD;
       exc.retval = *(double *)arg1; 
       if (!_matherr(&exc)) ERRNO_DOMAIN;
       *(double *)retval = exc.retval;	
       break;
    }
  case powf_nan_to_zero:
    /* powf(NaN,0.0) */
    /* Special Error */
    {
       DOMAINF; NAMEF = "powf"; INPUT_XF; INPUT_YF;
#ifdef __MS__
       excf.retval = *(double *)arg1; 
#elif
       excf.retval = *(float *)arg1; 
#endif
       if (!_matherrf(&excf)) ERRNO_DOMAIN;
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case atan2_zero:
    /* atan2(0.0,0.0) */
    {
       DOMAIND; NAMED = "atan2"; 
#ifndef __MS__
       RETVAL_ZEROD;
#endif
       NOT_MATHERRD 
       {
         ifSVID 
         { 
            WRITED_ATAN2_ZERO_BY_ZERO;
         }
         ERRNO_DOMAIN;
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case atan2f_zero:
    /* atan2f(0.0,0.0) */
    {
       DOMAINF; NAMEF = "atan2f"; 
#ifndef __MS__
       RETVAL_ZEROF;
#endif
       NOT_MATHERRF 
         ifSVID  
         {
            WRITEF_ATAN2_ZERO_BY_ZERO;
         }
       ERRNO_DOMAIN;
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case expm1_overflow:
    /* expm1(finite) overflow */
    /* Overflow is the only documented */
    /* special value. */
    {
      ERRNO_RANGE;
      break;
    }
  case expm1f_overflow:
    /* expm1f(finite) overflow */
    {
      ERRNO_RANGE;
      break;
    }
  case expm1_underflow:
    /* expm1(finite) underflow */
    /* Underflow is not documented */
    /* special value. */
    {
      ERRNO_RANGE;
      break;
    }
  case expm1f_underflow:
    /* expm1f(finite) underflow */
    {
      ERRNO_RANGE;
      break;
    }
  case scalb_underflow:
    /* scalb underflow */
    {
       UNDERFLOWD; NAMED = "scalb"; 
       if (INPUT_XD < 0.0) RETVAL_NEG_ZEROD;
       else  RETVAL_ZEROD;
       NOT_MATHERRD {ERRNO_RANGE;} 
       *(double *)retval = exc.retval;	
       break;
    }
  case scalbf_underflow:
    /* scalbf underflow */
    {
       UNDERFLOWF; NAMEF = "scalbf";
       if (INPUT_XF < 0.0) RETVAL_NEG_ZEROF;
       else  RETVAL_ZEROF;
       NOT_MATHERRF {ERRNO_RANGE;} 
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case scalb_overflow:
    /* scalb overflow */
    {
       OVERFLOWD; NAMED = "scalb"; 
       if (INPUT_XD < 0) RETVAL_NEG_HUGE_VALD;
       else RETVAL_HUGE_VALD;
       NOT_MATHERRD {ERRNO_RANGE;} 
       *(double *)retval = exc.retval;	
       break;
    }
  case scalbf_overflow:
    /* scalbf overflow */
    {
       OVERFLOWF; NAMEF = "scalbf"; 
       if (INPUT_XF < 0) RETVAL_NEG_HUGE_VALF;
       else RETVAL_HUGE_VALF;
       NOT_MATHERRF {ERRNO_RANGE;} 
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case hypot_overflow:
    /* hypot overflow */
    {
       OVERFLOWD; NAMED = "hypot";
       ifSVID
       { 
         RETVAL_HUGED;
       }
       else
       {
         RETVAL_HUGE_VALD;
       }
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;	
       break;
    }
  case hypotf_overflow:
    /* hypotf overflow */
    { 
       OVERFLOWF; NAMEF = "hypotf"; 
       ifSVID 
       {
         RETVAL_HUGEF;
       }
       else
       {
         RETVAL_HUGE_VALF;
       }
       NOT_MATHERRF {ERRNO_RANGE;}
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case acos_gt_one:
    /* acos(x > 1) */
    {
       DOMAIND; NAMED = "acos";
#ifndef __MS__
       RETVAL_ZEROD;
#endif
       ifSVID 
       {
         NOT_MATHERRD
         {
           WRITED_ACOS;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;
       break;
    }
  case acosf_gt_one:
    /* acosf(x > 1) */
    {
       DOMAINF; NAMEF = "acosf"; 
#ifndef __MS__
       RETVAL_ZEROF;
#endif
       ifSVID 
       {
         NOT_MATHERRF 
         {
           WRITEF_ACOS;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_DOMAIN;}
       } 
#ifdef __MS__
       *(float *)retval = (float)excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case asin_gt_one:
    /* asin(x > 1) */
    {
       DOMAIND; NAMED = "asin";
#ifndef __MS__
       RETVAL_ZEROD;
#endif
       ifSVID 
       {
         NOT_MATHERRD
         {
           WRITED_ASIN;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;
       break;
    }
  case asinf_gt_one:
    /* asinf(x > 1) */
    {
       DOMAINF; NAMEF = "asinf";
#ifndef __MS__
       RETVAL_ZEROF;
#endif
       ifSVID 
       {
         NOT_MATHERRF 
         {
            WRITEF_ASIN;
            ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_DOMAIN;}
       } 
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
 case cosh_overflow:
   /* cosh overflow */
   {
      OVERFLOWD; NAMED="cosh";
      ifSVID
      {
        RETVAL_HUGED;
      }
      else 
      {
        RETVAL_HUGE_VALD;
      }
      NOT_MATHERRD {ERRNO_RANGE;}
      *(double *)retval = exc.retval;
      break;
   }
 case coshf_overflow:
   /* coshf overflow */
   {
      OVERFLOWF; NAMEF="coshf";
      ifSVID
      {
        RETVAL_HUGEF;
      }
      else 
      {
        RETVAL_HUGE_VALF;
      }
      NOT_MATHERRF {ERRNO_RANGE;}
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
      break;
   }
 case sinh_overflow:
   /* sinh overflow */
   {
      OVERFLOWD; NAMED="sinh";
      ifSVID
      {
        if (INPUT_XD > 0.0) RETVAL_HUGED;
        else RETVAL_NEG_HUGED;
      }
      else 
      {
        if (INPUT_XD > 0.0) RETVAL_HUGE_VALD;
        else RETVAL_NEG_HUGE_VALD;
      }
      NOT_MATHERRD {ERRNO_RANGE;}
      *(double *)retval = exc.retval;
      break;
   }
 case sinhf_overflow:
   /* sinhf overflow */
   {
      OVERFLOWF; NAMEF="sinhf";
      ifSVID
      {
        if( INPUT_XF > 0.0) RETVAL_HUGEF;
        else RETVAL_NEG_HUGEF;
      }
      else 
      {
        if (INPUT_XF > 0.0) RETVAL_HUGE_VALF;
        else RETVAL_NEG_HUGE_VALF;
      }
      NOT_MATHERRF {ERRNO_RANGE;}
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
      break;
   }
  case acosh_lt_one:
    /* acosh(x < 1) */
    {
       DOMAIND; NAMED="acosh";
       ifSVID 
       {
         NOT_MATHERRD
         {
          WRITEL_ACOSH;
          ERRNO_DOMAIN;
         }
       }
       else NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case acoshf_lt_one:
    /* acoshf(x < 1) */
    {
       DOMAINF; NAMEF="acoshf";
       ifSVID 
       {
         NOT_MATHERRF
         {
           WRITEF_ACOSH;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       ERRNO_DOMAIN; break;
    }
  case atanh_gt_one:
    /* atanh(|x| > 1) */
    {
       DOMAIND; NAMED="atanh";
       ifSVID 
       {
         NOT_MATHERRD
         {
           WRITED_ATANH_GT_ONE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       break;
    }
  case atanhf_gt_one:
    /* atanhf(|x| > 1) */
    {
       DOMAINF; NAMEF="atanhf";
       ifSVID 
       {
         NOT_MATHERRF
         {
           WRITEF_ATANH_GT_ONE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
       break;
    }
  case atanh_eq_one:
    /* atanh(|x| == 1) */
    {
       SINGD; NAMED="atanh";
       ifSVID 
       {
         NOT_MATHERRD
         {
           WRITED_ATANH_EQ_ONE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
       NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       break;
    }
  case atanhf_eq_one:
    /* atanhf(|x| == 1) */
    {
       SINGF; NAMEF="atanhf";
       ifSVID 
       {
         NOT_MATHERRF
         {
           WRITEF_ATANH_EQ_ONE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
       break;
    }
  case gamma_overflow:
    /* gamma overflow */
    {
       OVERFLOWD; NAMED="gamma";
       ifSVID 
       {
         RETVAL_HUGED;
       }
         else
       {
         RETVAL_HUGE_VALD;
       }
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;
       break;
    }
  case gammaf_overflow:
    /* gammaf overflow */
    {
       OVERFLOWF; NAMEF="gammaf";
       ifSVID 
       {
         RETVAL_HUGEF;
       }
       else
       {
         RETVAL_HUGE_VALF;
       }
       NOT_MATHERRF {ERRNO_RANGE;}
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case lgamma_overflow:
    /* lgamma overflow */
    {
       OVERFLOWD; NAMED="lgamma";
       ifSVID 
       {
         RETVAL_HUGED;
       }
       else
       {
         RETVAL_HUGE_VALD;
       }
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;
       break;
    }
  case lgammaf_overflow:
    /* lgammaf overflow */
    {
       OVERFLOWF; NAMEF="lgammaf";
       ifSVID 
       {
         RETVAL_HUGEF;
       }
       else
       {
         RETVAL_HUGE_VALF;
       }
       NOT_MATHERRF {ERRNO_RANGE;}
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case lgamma_negative:
    /* lgamma -int or 0 */
    {
       SINGD; NAMED="lgamma";
       ifSVID 
       {
         RETVAL_HUGED;
         NOT_MATHERRD
         {
           WRITED_LGAMMA_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         RETVAL_HUGE_VALD;
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case lgammaf_negative:
    /* lgammaf -int or 0 */
    {
       SINGF; NAMEF="lgammaf";
       ifSVID 
       {
         RETVAL_HUGEF;
         NOT_MATHERRF
         {
           WRITEF_LGAMMA_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         RETVAL_HUGE_VALF;
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case gamma_negative:
    /* gamma -int or 0 */
    {
       SINGD; NAMED="gamma";
       ifSVID 
       {
         RETVAL_HUGED;
         NOT_MATHERRD
         {
            WRITED_GAMMA_NEGATIVE;
            ERRNO_DOMAIN;
         }
       }
       else
       {
         RETVAL_HUGE_VALD;
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case gammaf_negative:
    /* gammaf -int or 0 */
    {
       SINGF; NAMEF="gammaf";
       ifSVID 
       {
         RETVAL_HUGEF;
         NOT_MATHERRF
         {
            WRITEF_GAMMA_NEGATIVE;
            ERRNO_DOMAIN;
         }
       }
       else
       {
         RETVAL_HUGE_VALF;
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case j0_gt_loss:
    /* j0 > loss */
    {
       TLOSSD; NAMED="j0";
       RETVAL_ZEROD;
       ifSVID 
       {
         NOT_MATHERRD
         {
            WRITED_J0_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRD {ERRNO_RANGE;}
       }
       *(double*)retval = exc.retval;	
       break;
    }
  case j0f_gt_loss:
    /* j0f > loss */
    {
       TLOSSF; NAMEF="j0f";
       RETVAL_ZEROF;
       ifSVID 
       {
         NOT_MATHERRF
         {
            WRITEF_J0_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_RANGE;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case j1_gt_loss:
    /* j1 > loss */
    {
       TLOSSD; NAMED="j1";
       RETVAL_ZEROD;
       ifSVID 
       {
         NOT_MATHERRD
         {
            WRITED_J1_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRD {ERRNO_RANGE;}
       }
       *(double*)retval = exc.retval;	
       break;
    }
  case j1f_gt_loss:
    /* j1f > loss */
    {
       TLOSSF; NAMEF="j1f";
       RETVAL_ZEROF;
       ifSVID 
       {
         NOT_MATHERRF
         {
            WRITEF_J1_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_RANGE;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case jn_gt_loss:
    /* jn > loss */
    {
       TLOSSD; NAMED="jn";
       RETVAL_ZEROD;
       ifSVID 
       {
         NOT_MATHERRD
         {
            WRITED_JN_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRD {ERRNO_RANGE;}
       }
       *(double*)retval = exc.retval;	
       break;
    }
  case jnf_gt_loss:
    /* jnf > loss */
    {
       TLOSSF; NAMEF="jnf";
       RETVAL_ZEROF;
       ifSVID 
       {
         NOT_MATHERRF
         {
            WRITEF_JN_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_RANGE;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case y0_gt_loss:
    /* y0 > loss */
    {
       TLOSSD; NAMED="y0";
       RETVAL_ZEROD;
       ifSVID 
       {
         NOT_MATHERRD
         {
            WRITED_Y0_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRD {ERRNO_RANGE;}
       }
       *(double*)retval = exc.retval;
       break;
    }
  case y0f_gt_loss:
    /* y0f > loss */
    {
       TLOSSF; NAMEF="y0f";
       RETVAL_ZEROF;
       ifSVID 
       {
         NOT_MATHERRF
         {
            WRITEF_Y0_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_RANGE;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case y0_zero:
    /* y0(0) */
    {
       DOMAIND; NAMED="y0";
       ifSVID 
       {
         RETVAL_NEG_HUGED;
         NOT_MATHERRD 
         {
           WRITED_Y0_ZERO;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALD; 
#endif
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case y0f_zero:
    /* y0f(0) */
    {
       DOMAINF; NAMEF="y0f";
       ifSVID 
       {
         RETVAL_NEG_HUGEF;
         NOT_MATHERRF 
         {
           WRITEF_Y0_ZERO;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALF;
#endif
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case y1_gt_loss:
    /* y1 > loss */
    {
       TLOSSD; NAMED="y1";
       RETVAL_ZEROD;
       ifSVID 
       {
         NOT_MATHERRD
         {
            WRITED_Y1_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRD {ERRNO_RANGE;}
       }
       *(double*)retval = exc.retval;
       break;
    }
  case y1f_gt_loss:
    /* y1f > loss */
    {
       TLOSSF; NAMEF="y1f";
       RETVAL_ZEROF;
       ifSVID 
       {
         NOT_MATHERRF
         {
            WRITEF_Y1_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_RANGE;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case y1_zero:
    /* y1(0) */
    {
       DOMAIND; NAMED="y1";
       ifSVID 
       {
         RETVAL_NEG_HUGED;
         NOT_MATHERRD 
         {
           WRITED_Y1_ZERO;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALD;
#endif
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case y1f_zero:
    /* y1f(0) */
    {
       DOMAINF; NAMEF="y1f";
       ifSVID 
       {
         RETVAL_NEG_HUGEF;
         NOT_MATHERRF 
         {
           WRITEF_Y1_ZERO;
           ERRNO_DOMAIN;
         }
       }else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALF;
#endif
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case yn_gt_loss:
    /* yn > loss */
    {
       TLOSSD; NAMED="yn";
       RETVAL_ZEROD;
       ifSVID 
       {
         NOT_MATHERRD
         {
            WRITED_YN_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRD {ERRNO_RANGE;}
       }
       *(double*)retval = exc.retval;
       break;
    }
  case ynf_gt_loss:
    /* ynf > loss */
    {
       TLOSSF; NAMEF="ynf";
       RETVAL_ZEROF;
       ifSVID 
       {
         NOT_MATHERRF
         {
            WRITEF_YN_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_RANGE;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case yn_zero:
    /* yn(0) */
    {
       DOMAIND; NAMED="yn";
       ifSVID 
       {
         RETVAL_NEG_HUGED;
         NOT_MATHERRD 
         {
           WRITED_YN_ZERO;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALD;
#endif
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case ynf_zero:
    /* ynf(0) */
    {
       DOMAINF; NAMEF="ynf";
       ifSVID 
       {
         RETVAL_NEG_HUGEF;
         NOT_MATHERRF 
         {
           WRITEF_YN_ZERO;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALF; 
#endif
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case y0_negative:
    /* y0(x<0) */
    {
       DOMAIND; NAMED="y0";
       ifSVID 
       {
         RETVAL_NEG_HUGED;
         NOT_MATHERRD 
         {
           WRITED_Y0_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALD; 
#endif
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case y0f_negative:
    /* y0f(x<0) */
    {
       DOMAINF; NAMEF="y0f";
       ifSVID 
       {
         RETVAL_NEG_HUGEF;
         NOT_MATHERRF 
         {
           WRITEF_Y0_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALF; 
#endif
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case y1_negative:
    /* y1(x<0) */
    {
       DOMAIND; NAMED="y1";
       ifSVID 
       {
         RETVAL_NEG_HUGED;
         NOT_MATHERRD 
         {
           WRITED_Y1_NEGATIUE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALD; 
#endif
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case y1f_negative:
    /* y1f(x<0) */
    {
       DOMAINF; NAMEF="y1f";
       ifSVID 
       {
         RETVAL_NEG_HUGEF;
         NOT_MATHERRF 
         {
           WRITEF_Y1_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALF; 
#endif
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case yn_negative:
    /* yn(x<0) */
    {
       DOMAIND; NAMED="yn";
       ifSVID 
       {
         RETVAL_NEG_HUGED;
         NOT_MATHERRD 
         {
           WRITED_YN_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALD; 
#endif
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case ynf_negative:
    /* ynf(x<0) */
    {
       DOMAINF; NAMEF="ynf";
       ifSVID 
       {
         RETVAL_NEG_HUGEF;
         NOT_MATHERRF 
         {
           WRITEF_YN_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALF; 
#endif
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case fmod_by_zero: 
    /* fmod(x,0) */
    {
       DOMAIND; NAMED = "fmod";
       ifSVID 
       {
         *(double *)retval = *(double *)arg1;
         NOT_MATHERRD 
         {
           WRITED_FMOD;
           ERRNO_DOMAIN;
         }
       }
       else
       { /* NaN already computed */
         NOT_MATHERRD {ERRNO_DOMAIN;}
       } 
       *(double *)retval = exc.retval;	
       break;
    }
  case fmodf_by_zero: 
    /* fmodf(x,0) */
    {
       DOMAINF; NAMEF = "fmodf"; 
       ifSVID 
       {
#ifdef __MS__
         *(double *)retval = *(double *)arg1;
#elif
         *(float *)retval = *(float *)arg1;
#endif
         NOT_MATHERRF 
         {
           WRITEF_FMOD;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_DOMAIN;}
       } 
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case remainder_by_zero: 
    /* remainder(x,0) */
    {
       DOMAIND; NAMED = "remainder";
       ifSVID 
       {
         NOT_MATHERRD 
         {
           WRITED_REM;
           ERRNO_DOMAIN;
         }
       }
       else
       { /* NaN already computed */
         NOT_MATHERRD {ERRNO_DOMAIN;}
       } 
       *(double *)retval = exc.retval;	
       break;
    }
  case remainderf_by_zero: 
    /* remainderf(x,0) */
    {
       DOMAINF; NAMEF = "remainderf"; 
       ifSVID 
       {
         NOT_MATHERRF 
         {
           WRITEF_REM;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_DOMAIN;}
       } 
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
   }
   return;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\fpw32\tran\ia64\libm_tan.s ===
.file "libm_tan.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
//*********************************************************************
//
// History:  
// 02/02/00 Initial Version 
// 4/04/00  Unwind support added
//
//*********************************************************************
//
// Function:   tan(x) = tangent(x), for double precision x values
//
//*********************************************************************
//
// Accuracy:       Very accurate for double-precision values  
//
//*********************************************************************
//
// Resources Used:
//
//    Floating-Point Registers: f8 (Input and Return Value)
//                              f9-f15
//                              f32-f112
//
//    General Purpose Registers:
//      r32-r48
//      r49-r50 (Used to pass arguments to pi_by_2 reduce routine)
//
//    Predicate Registers:      p6-p15
//
//*********************************************************************
//
// IEEE Special Conditions:
//
//    Denormal  fault raised on denormal inputs
//    Overflow exceptions do not occur
//    Underflow exceptions raised when appropriate for tan 
//    (No specialized error handling for this routine)
//    Inexact raised when appropriate by algorithm
//
//    tan(SNaN) = QNaN
//    tan(QNaN) = QNaN
//    tan(inf) = QNaN
//    tan(+/-0) = +/-0
//
//*********************************************************************
//
// Mathematical Description
//
// We consider the computation of FPTAN of Arg. Now, given
//
//      Arg = N pi/2  + alpha,          |alpha| <= pi/4,
//
// basic mathematical relationship shows that
//
//      tan( Arg ) =  tan( alpha )     if N is even;
//                 = -cot( alpha )      otherwise.
//
// The value of alpha is obtained by argument reduction and
// represented by two working precision numbers r and c where
//
//      alpha =  r  +  c     accurately.
//
// The reduction method is described in a previous write up.
// The argument reduction scheme identifies 4 cases. For Cases 2
// and 4, because |alpha| is small, tan(r+c) and -cot(r+c) can be
// computed very easily by 2 or 3 terms of the Taylor series
// expansion as follows:
//
// Case 2:
// -------
//
//      tan(r + c) = r + c + r^3/3          ...accurately
//        -cot(r + c) = -1/(r+c) + r/3          ...accurately
//
// Case 4:
// -------
//
//      tan(r + c) = r + c + r^3/3 + 2r^5/15     ...accurately
//        -cot(r + c) = -1/(r+c) + r/3 + r^3/45     ...accurately
//
//
// The only cases left are Cases 1 and 3 of the argument reduction
// procedure. These two cases will be merged since after the
// argument is reduced in either cases, we have the reduced argument
// represented as r + c and that the magnitude |r + c| is not small
// enough to allow the usage of a very short approximation.
//
// The greatest challenge of this task is that the second terms of
// the Taylor series for tan(r) and -cot(r)
//
//      r + r^3/3 + 2 r^5/15 + ...
//
// and
//
//      -1/r + r/3 + r^3/45 + ...
//
// are not very small when |r| is close to pi/4 and the rounding
// errors will be a concern if simple polynomial accumulation is
// used. When |r| < 2^(-2), however, the second terms will be small
// enough (5 bits or so of right shift) that a normal Horner
// recurrence suffices. Hence there are two cases that we consider
// in the accurate computation of tan(r) and cot(r), |r| <= pi/4.
//
// Case small_r: |r| < 2^(-2)
// --------------------------
//
// Since Arg = N pi/4 + r + c accurately, we have
//
//      tan(Arg) =  tan(r+c)            for N even,
//            = -cot(r+c)          otherwise.
//
// Here for this case, both tan(r) and -cot(r) can be approximated
// by simple polynomials:
//
//      tan(r) =    r + P1_1 r^3 + P1_2 r^5 + ... + P1_9 r^19
//        -cot(r) = -1/r + Q1_1 r   + Q1_2 r^3 + ... + Q1_7 r^13
//
// accurately. Since |r| is relatively small, tan(r+c) and
// -cot(r+c) can be accurately approximated by replacing r with
// r+c only in the first two terms of the corresponding polynomials.
//
// Note that P1_1 (and Q1_1 for that matter) approximates 1/3 to
// almost 64 sig. bits, thus
//
//      P1_1 (r+c)^3 =  P1_1 r^3 + c * r^2     accurately.
//
// Hence,
//
//      tan(r+c) =    r + P1_1 r^3 + P1_2 r^5 + ... + P1_9 r^19
//                     + c*(1 + r^2)
//
//        -cot(r+c) = -1/(r+c) + Q1_1 r   + Q1_2 r^3 + ... + Q1_7 r^13
//               + Q1_1*c
//
//
// Case normal_r: 2^(-2) <= |r| <= pi/4
// ------------------------------------
//
// This case is more likely than the previous one if one considers
// r to be uniformly distributed in [-pi/4 pi/4].
//
// The required calculation is either
//
//      tan(r + c)  =  tan(r)  +  correction,  or
//        -cot(r + c)  = -cot(r)  +  correction.
//
// Specifically,
//
//      tan(r + c) =  tan(r) + c tan'(r)  + O(c^2)
//              =  tan(r) + c sec^2(r) + O(c^2)
//              =  tan(r) + c SEC_sq     ...accurately
//                as long as SEC_sq approximates sec^2(r)
//                to, say, 5 bits or so.
//
// Similarly,
//
//        -cot(r + c) = -cot(r) - c cot'(r)  + O(c^2)
//              = -cot(r) + c csc^2(r) + O(c^2)
//              = -cot(r) + c CSC_sq     ...accurately
//                as long as CSC_sq approximates csc^2(r)
//                to, say, 5 bits or so.
//
// We therefore concentrate on accurately calculating tan(r) and
// cot(r) for a working-precision number r, |r| <= pi/4 to within
// 0.1% or so.
//
// We will employ a table-driven approach. Let
//
//      r = sgn_r * 2^k * 1.b_1 b_2 ... b_5 ... b_63
//        = sgn_r * ( B + x )
//
// where
//
//      B = 2^k * 1.b_1 b_2 ... b_5 1
//         x = |r| - B
//
// Now,
//                   tan(B)  +   tan(x)
//      tan( B + x ) =  ------------------------
//                   1 -  tan(B)*tan(x)
//
//               /                         \
//               |   tan(B)  +   tan(x)          |

//      = tan(B) +  | ------------------------ - tan(B) |
//               |     1 -  tan(B)*tan(x)          |
//               \                         /
//
//                 sec^2(B) * tan(x)
//      = tan(B) + ------------------------
//                 1 -  tan(B)*tan(x)
//
//                (1/[sin(B)*cos(B)]) * tan(x)
//      = tan(B) + --------------------------------
//                      cot(B)  -  tan(x)
//
//
// Clearly, the values of tan(B), cot(B) and 1/(sin(B)*cos(B)) are
// calculated beforehand and stored in a table. Since
//
//      |x| <= 2^k * 2^(-6)  <= 2^(-7)  (because k = -1, -2)
//
// a very short polynomial will be sufficient to approximate tan(x)
// accurately. The details involved in computing the last expression
// will be given in the next section on algorithm description.
//
//
// Now, we turn to the case where cot( B + x ) is needed.
//
//
//                   1 - tan(B)*tan(x)
//      cot( B + x ) =  ------------------------
//                   tan(B)  +  tan(x)
//
//               /                           \
//               |   1 - tan(B)*tan(x)              |

//      = cot(B) +  | ----------------------- - cot(B) |
//               |     tan(B)  +  tan(x)            |
//               \                           /
//
//               [tan(B) + cot(B)] * tan(x)
//      = cot(B) - ----------------------------
//                   tan(B)  +  tan(x)
//
//                (1/[sin(B)*cos(B)]) * tan(x)
//      = cot(B) - --------------------------------
//                      tan(B)  +  tan(x)
//
//
// Note that the values of tan(B), cot(B) and 1/(sin(B)*cos(B)) that
// are needed are the same set of values needed in the previous
// case.
//
// Finally, we can put all the ingredients together as follows:
//
//      Arg = N * pi/2 +  r + c          ...accurately
//
//      tan(Arg) =  tan(r) + correction    if N is even;
//            = -cot(r) + correction    otherwise.
//
// For Cases 2 and 4,
//
//     Case 2:
//     tan(Arg) =  tan(r + c) = r + c + r^3/3           N even
//              = -cot(r + c) = -1/(r+c) + r/3           N odd
//     Case 4:
//     tan(Arg) =  tan(r + c) = r + c + r^3/3 + 2r^5/15  N even
//              = -cot(r + c) = -1/(r+c) + r/3 + r^3/45  N odd
//
//
// For Cases 1 and 3,
//
//     Case small_r: |r| < 2^(-2)
//
//      tan(Arg) =  r + P1_1 r^3 + P1_2 r^5 + ... + P1_9 r^19
//                     + c*(1 + r^2)               N even
//
//                  = -1/(r+c) + Q1_1 r   + Q1_2 r^3 + ... + Q1_7 r^13
//               + Q1_1*c                    N odd
//
//     Case normal_r: 2^(-2) <= |r| <= pi/4
//
//      tan(Arg) =  tan(r) + c * sec^2(r)     N even
//               = -cot(r) + c * csc^2(r)     otherwise
//
//     For N even,
//
//      tan(Arg) = tan(r) + c*sec^2(r)
//               = tan( sgn_r * (B+x) ) + c * sec^2(|r|)
//                  = sgn_r * ( tan(B+x)  + sgn_r*c*sec^2(|r|) )
//                  = sgn_r * ( tan(B+x)  + sgn_r*c*sec^2(B) )
//
// since B approximates |r| to 2^(-6) in relative accuracy.
//
//                 /            (1/[sin(B)*cos(B)]) * tan(x)
//    tan(Arg) = sgn_r * | tan(B) + --------------------------------
//                 \                     cot(B)  -  tan(x)
//                                        \
//                       + CORR  |

//                                     /
// where
//
//    CORR = sgn_r*c*tan(B)*SC_inv(B);  SC_inv(B) = 1/(sin(B)*cos(B)).
//
// For N odd,
//
//      tan(Arg) = -cot(r) + c*csc^2(r)
//               = -cot( sgn_r * (B+x) ) + c * csc^2(|r|)
//                  = sgn_r * ( -cot(B+x)  + sgn_r*c*csc^2(|r|) )
//                  = sgn_r * ( -cot(B+x)  + sgn_r*c*csc^2(B) )
//
// since B approximates |r| to 2^(-6) in relative accuracy.
//
//                 /            (1/[sin(B)*cos(B)]) * tan(x)
//    tan(Arg) = sgn_r * | -cot(B) + --------------------------------
//                 \                     tan(B)  +  tan(x)
//                                        \
//                       + CORR  |

//                                     /
// where
//
//    CORR = sgn_r*c*cot(B)*SC_inv(B);  SC_inv(B) = 1/(sin(B)*cos(B)).
//
//
// The actual algorithm prescribes how all the mathematical formulas
// are calculated.
//
//
// 2. Algorithmic Description
// ==========================
//
// 2.1 Computation for Cases 2 and 4.
// ----------------------------------
//
// For Case 2, we use two-term polynomials.
//
//    For N even,
//
//    rsq := r * r
//    Result := c + r * rsq * P1_1
//    Result := r + Result          ...in user-defined rounding
//
//    For N odd,
//    S_hi  := -frcpa(r)               ...8 bits
//    S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...16 bits
//    S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...32 bits
//    S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...64 bits
//    S_lo  := S_hi*( (1 + S_hi*r) + S_hi*c )
//    ...S_hi + S_lo is -1/(r+c) to extra precision
//    S_lo  := S_lo + Q1_1*r
//
//    Result := S_hi + S_lo     ...in user-defined rounding
//
// For Case 4, we use three-term polynomials
//
//    For N even,
//
//    rsq := r * r
//    Result := c + r * rsq * (P1_1 + rsq * P1_2)
//    Result := r + Result          ...in user-defined rounding
//
//    For N odd,
//    S_hi  := -frcpa(r)               ...8 bits
//    S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...16 bits
//    S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...32 bits
//    S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...64 bits
//    S_lo  := S_hi*( (1 + S_hi*r) + S_hi*c )
//    ...S_hi + S_lo is -1/(r+c) to extra precision
//    rsq   := r * r
//    P      := Q1_1 + rsq*Q1_2
//    S_lo  := S_lo + r*P
//
//    Result := S_hi + S_lo     ...in user-defined rounding
//
//
// Note that the coefficients P1_1, P1_2, Q1_1, and Q1_2 are
// the same as those used in the small_r case of Cases 1 and 3
// below.
//
//
// 2.2 Computation for Cases 1 and 3.
// ----------------------------------
// This is further divided into the case of small_r,
// where |r| < 2^(-2), and the case of normal_r, where |r| lies between
// 2^(-2) and pi/4.
//
// Algorithm for the case of small_r
// ---------------------------------
//
// For N even,
//      rsq   := r * r
//      Poly1 := rsq*(P1_1 + rsq*(P1_2 + rsq*P1_3))
//      r_to_the_8    := rsq * rsq
//      r_to_the_8    := r_to_the_8 * r_to_the_8
//      Poly2 := P1_4 + rsq*(P1_5 + rsq*(P1_6 + ... rsq*P1_9))
//      CORR  := c * ( 1 + rsq )
//      Poly  := Poly1 + r_to_the_8*Poly2
//      Result := r*Poly + CORR
//      Result := r + Result     ...in user-defined rounding
//      ...note that Poly1 and r_to_the_8 can be computed in parallel
//      ...with Poly2 (Poly1 is intentionally set to be much
//      ...shorter than Poly2 so that r_to_the_8 and CORR can be hidden)
//
// For N odd,
//      S_hi  := -frcpa(r)               ...8 bits
//      S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...16 bits
//      S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...32 bits
//      S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...64 bits
//      S_lo  := S_hi*( (1 + S_hi*r) + S_hi*c )
//      ...S_hi + S_lo is -1/(r+c) to extra precision
//      S_lo  := S_lo + Q1_1*c
//
//      ...S_hi and S_lo are computed in parallel with
//      ...the following
//      rsq := r*r
//      P   := Q1_1 + rsq*(Q1_2 + rsq*(Q1_3 + ... + rsq*Q1_7))
//
//      Result :=  r*P + S_lo
//      Result :=  S_hi  +  Result      ...in user-defined rounding
//
//
// Algorithm for the case of normal_r
// ----------------------------------
//
// Here, we first consider the computation of tan( r + c ). As
// presented in the previous section,
//
//      tan( r + c )  =  tan(r) + c * sec^2(r)
//                 =  sgn_r * [ tan(B+x) + CORR ]
//      CORR = sgn_r * c * tan(B) * 1/[sin(B)*cos(B)]
//
// because sec^2(r) = sec^(|r|), and B approximate |r| to 6.5 bits.
//
//      tan( r + c ) =
//           /           (1/[sin(B)*cos(B)]) * tan(x)
//      sgn_r * | tan(B) + --------------------------------  +
//           \                     cot(B)  -  tan(x)
//                                \
//                          CORR  |

//                                /
//
// The values of tan(B), cot(B) and 1/(sin(B)*cos(B)) are
// calculated beforehand and stored in a table. Specifically,
// the table values are
//
//      tan(B)                as  T_hi  +  T_lo;
//      cot(B)             as  C_hi  +  C_lo;
//      1/[sin(B)*cos(B)]  as  SC_inv
//
// T_hi, C_hi are in  double-precision  memory format;
// T_lo, C_lo are in  single-precision  memory format;
// SC_inv     is  in extended-precision memory format.
//
// The value of tan(x) will be approximated by a short polynomial of
// the form
//
//      tan(x)  as  x  +  x * P, where
//           P  =   x^2 * (P2_1 + x^2 * (P2_2 + x^2 * P2_3))
//
// Because |x| <= 2^(-7), cot(B) - x approximates cot(B) - tan(x)
// to a relative accuracy better than 2^(-20). Thus, a good
// initial guess of 1/( cot(B) - tan(x) ) to initiate the iterative
// division is:
//
//      1/(cot(B) - tan(x))      is approximately
//      1/(cot(B) -   x)         is
//      tan(B)/(1 - x*tan(B))    is approximately
//      T_hi / ( 1 - T_hi * x )  is approximately
//
//      T_hi * [ 1 + (Thi * x) + (T_hi * x)^2 ]
//
// The calculation of tan(r+c) therefore proceed as follows:
//
//      Tx     := T_hi * x
//      xsq     := x * x
//
//      V_hi     := T_hi*(1 + Tx*(1 + Tx))
//      P     := xsq * (P1_1 + xsq*(P1_2 + xsq*P1_3))
//      ...V_hi serves as an initial guess of 1/(cot(B) - tan(x))
//         ...good to about 20 bits of accuracy
//
//      tanx     := x + x*P
//      D     := C_hi - tanx
//      ...D is a double precision denominator: cot(B) - tan(x)
//
//      V_hi     := V_hi + V_hi*(1 - V_hi*D)
//      ....V_hi approximates 1/(cot(B)-tan(x)) to 40 bits
//
//      V_lo     := V_hi * ( [ (1 - V_hi*C_hi) + V_hi*tanx ]
//                           - V_hi*C_lo )   ...observe all order
//         ...V_hi + V_lo approximates 1/(cot(B) - tan(x))
//      ...to extra accuracy
//
//      ...               SC_inv(B) * (x + x*P)
//      ...   tan(B) +      ------------------------- + CORR
//         ...                cot(B) - (x + x*P)
//      ...
//      ... = tan(B) + SC_inv(B)*(x + x*P)*(V_hi + V_lo) + CORR
//      ...
//
//      Sx     := SC_inv * x
//      CORR     := sgn_r * c * SC_inv * T_hi
//
//      ...put the ingredients together to compute
//      ...               SC_inv(B) * (x + x*P)
//      ...   tan(B) +      ------------------------- + CORR
//         ...                cot(B) - (x + x*P)
//      ...
//      ... = tan(B) + SC_inv(B)*(x + x*P)*(V_hi + V_lo) + CORR
//      ...
//      ... = T_hi + T_lo + CORR +
//      ...    Sx * V_hi + Sx * V_lo + Sx * P *(V_hi + V_lo)
//
//      CORR := CORR + T_lo
//      tail := V_lo + P*(V_hi + V_lo)
//         tail := Sx * tail  +  CORR
//      tail := Sx * V_hi  +  tail
//         T_hi := sgn_r * T_hi
//
//         ...T_hi + sgn_r*tail  now approximate
//      ...sgn_r*(tan(B+x) + CORR) accurately
//
//      Result :=  T_hi + sgn_r*tail  ...in user-defined
//                           ...rounding control
//      ...It is crucial that independent paths be fully
//      ...exploited for performance's sake.
//
//
// Next, we consider the computation of -cot( r + c ). As
// presented in the previous section,
//
//        -cot( r + c )  =  -cot(r) + c * csc^2(r)
//                 =  sgn_r * [ -cot(B+x) + CORR ]
//      CORR = sgn_r * c * cot(B) * 1/[sin(B)*cos(B)]
//
// because csc^2(r) = csc^(|r|), and B approximate |r| to 6.5 bits.
//
//        -cot( r + c ) =
//           /             (1/[sin(B)*cos(B)]) * tan(x)
//      sgn_r * | -cot(B) + --------------------------------  +
//           \                     tan(B)  +  tan(x)
//                                \
//                          CORR  |

//                                /
//
// The values of tan(B), cot(B) and 1/(sin(B)*cos(B)) are
// calculated beforehand and stored in a table. Specifically,
// the table values are
//
//      tan(B)                as  T_hi  +  T_lo;
//      cot(B)             as  C_hi  +  C_lo;
//      1/[sin(B)*cos(B)]  as  SC_inv
//
// T_hi, C_hi are in  double-precision  memory format;
// T_lo, C_lo are in  single-precision  memory format;
// SC_inv     is  in extended-precision memory format.
//
// The value of tan(x) will be approximated by a short polynomial of
// the form
//
//      tan(x)  as  x  +  x * P, where
//           P  =   x^2 * (P2_1 + x^2 * (P2_2 + x^2 * P2_3))
//
// Because |x| <= 2^(-7), tan(B) + x approximates tan(B) + tan(x)
// to a relative accuracy better than 2^(-18). Thus, a good
// initial guess of 1/( tan(B) + tan(x) ) to initiate the iterative
// division is:
//
//      1/(tan(B) + tan(x))      is approximately
//      1/(tan(B) +   x)         is
//      cot(B)/(1 + x*cot(B))    is approximately
//      C_hi / ( 1 + C_hi * x )  is approximately
//
//      C_hi * [ 1 - (C_hi * x) + (C_hi * x)^2 ]
//
// The calculation of -cot(r+c) therefore proceed as follows:
//
//      Cx     := C_hi * x
//      xsq     := x * x
//
//      V_hi     := C_hi*(1 - Cx*(1 - Cx))
//      P     := xsq * (P1_1 + xsq*(P1_2 + xsq*P1_3))
//      ...V_hi serves as an initial guess of 1/(tan(B) + tan(x))
//         ...good to about 18 bits of accuracy
//
//      tanx     := x + x*P
//      D     := T_hi + tanx
//      ...D is a double precision denominator: tan(B) + tan(x)
//
//      V_hi     := V_hi + V_hi*(1 - V_hi*D)
//      ....V_hi approximates 1/(tan(B)+tan(x)) to 40 bits
//
//      V_lo     := V_hi * ( [ (1 - V_hi*T_hi) - V_hi*tanx ]
//                           - V_hi*T_lo )   ...observe all order
//         ...V_hi + V_lo approximates 1/(tan(B) + tan(x))
//      ...to extra accuracy
//
//      ...               SC_inv(B) * (x + x*P)
//      ...  -cot(B) +      ------------------------- + CORR
//         ...                tan(B) + (x + x*P)
//      ...
//      ... =-cot(B) + SC_inv(B)*(x + x*P)*(V_hi + V_lo) + CORR
//      ...
//
//      Sx     := SC_inv * x
//      CORR     := sgn_r * c * SC_inv * C_hi
//
//      ...put the ingredients together to compute
//      ...               SC_inv(B) * (x + x*P)
//      ...  -cot(B) +      ------------------------- + CORR
//         ...                tan(B) + (x + x*P)
//      ...
//      ... =-cot(B) + SC_inv(B)*(x + x*P)*(V_hi + V_lo) + CORR
//      ...
//      ... =-C_hi - C_lo + CORR +
//      ...    Sx * V_hi + Sx * V_lo + Sx * P *(V_hi + V_lo)
//
//      CORR := CORR - C_lo
//      tail := V_lo + P*(V_hi + V_lo)
//         tail := Sx * tail  +  CORR
//      tail := Sx * V_hi  +  tail
//         C_hi := -sgn_r * C_hi
//
//         ...C_hi + sgn_r*tail now approximates
//      ...sgn_r*(-cot(B+x) + CORR) accurately
//
//      Result :=  C_hi + sgn_r*tail   in user-defined rounding control
//      ...It is crucial that independent paths be fully
//      ...exploited for performance's sake.
//
// 3. Implementation Notes
// =======================
//
//   Table entries T_hi, T_lo; C_hi, C_lo; SC_inv
//
//   Recall that 2^(-2) <= |r| <= pi/4;
//
//      r = sgn_r * 2^k * 1.b_1 b_2 ... b_63
//
//   and
//
//        B = 2^k * 1.b_1 b_2 b_3 b_4 b_5 1
//
//   Thus, for k = -2, possible values of B are
//
//          B = 2^(-2) * ( 1 + index/32  +  1/64 ),
//      index ranges from 0 to 31
//
//   For k = -1, however, since |r| <= pi/4 = 0.78...
//   possible values of B are
//
//        B = 2^(-1) * ( 1 + index/32  +  1/64 )
//      index ranges from 0 to 19.
//
//

.data

.align 128

TAN_BASE_CONSTANTS:
data4    0x4B800000, 0xCB800000, 0x38800000, 0xB8800000 // two**24, -two**24
                                                        // two**-14, -two**-14
data4    0x4E44152A, 0xA2F9836E, 0x00003FFE, 0x00000000 // two_by_pi
data4    0xCE81B9F1, 0xC84D32B0, 0x00004016, 0x00000000 // P_0
data4    0x2168C235, 0xC90FDAA2, 0x00003FFF, 0x00000000 // P_1
data4    0xFC8F8CBB, 0xECE675D1, 0x0000BFBD, 0x00000000 // P_2
data4    0xACC19C60, 0xB7ED8FBB, 0x0000BF7C, 0x00000000 // P_3
data4    0x5F000000, 0xDF000000, 0x00000000, 0x00000000 // two_to_63, -two_to_63
data4    0x6EC6B45A, 0xA397E504, 0x00003FE7, 0x00000000 // Inv_P_0
data4    0xDBD171A1, 0x8D848E89, 0x0000BFBF, 0x00000000 // d_1
data4    0x18A66F8E, 0xD5394C36, 0x0000BF7C, 0x00000000 // d_2
data4    0x2168C234, 0xC90FDAA2, 0x00003FFE, 0x00000000 // PI_BY_4
data4    0x2168C234, 0xC90FDAA2, 0x0000BFFE, 0x00000000 // MPI_BY_4
data4    0x3E800000, 0xBE800000, 0x00000000, 0x00000000 // two**-2, -two**-2
data4    0x2F000000, 0xAF000000, 0x00000000, 0x00000000 // two**-33, -two**-33
data4    0xAAAAAABD, 0xAAAAAAAA, 0x00003FFD, 0x00000000 // P1_1
data4    0x88882E6A, 0x88888888, 0x00003FFC, 0x00000000 // P1_2
data4    0x0F0177B6, 0xDD0DD0DD, 0x00003FFA, 0x00000000 // P1_3
data4    0x646B8C6D, 0xB327A440, 0x00003FF9, 0x00000000 // P1_4
data4    0x1D5F7D20, 0x91371B25, 0x00003FF8, 0x00000000 // P1_5
data4    0x61C67914, 0xEB69A5F1, 0x00003FF6, 0x00000000 // P1_6
data4    0x019318D2, 0xBEDD37BE, 0x00003FF5, 0x00000000 // P1_7
data4    0x3C794015, 0x9979B146, 0x00003FF4, 0x00000000 // P1_8
data4    0x8C6EB58A, 0x8EBD21A3, 0x00003FF3, 0x00000000 // P1_9
data4    0xAAAAAAB4, 0xAAAAAAAA, 0x00003FFD, 0x00000000 // Q1_1
data4    0x0B5FC93E, 0xB60B60B6, 0x00003FF9, 0x00000000 // Q1_2
data4    0x0C9BBFBF, 0x8AB355E0, 0x00003FF6, 0x00000000 // Q1_3
data4    0xCBEE3D4C, 0xDDEBBC89, 0x00003FF2, 0x00000000 // Q1_4
data4    0x5F80BBB6, 0xB3548A68, 0x00003FEF, 0x00000000 // Q1_5
data4    0x4CED5BF1, 0x91362560, 0x00003FEC, 0x00000000 // Q1_6
data4    0x8EE92A83, 0xF189D95A, 0x00003FE8, 0x00000000 // Q1_7
data4    0xAAAB362F, 0xAAAAAAAA, 0x00003FFD, 0x00000000 // P2_1
data4    0xE97A6097, 0x88888886, 0x00003FFC, 0x00000000 // P2_2
data4    0x25E716A1, 0xDD108EE0, 0x00003FFA, 0x00000000 // P2_3
//
//  Entries T_hi   double-precision memory format
//  Index = 0,1,...,31  B = 2^(-2)*(1+Index/32+1/64)
//  Entries T_lo  single-precision memory format
//  Index = 0,1,...,31  B = 2^(-2)*(1+Index/32+1/64)
//
data4    0x62400794, 0x3FD09BC3, 0x23A05C32, 0x00000000
data4    0xDFFBC074, 0x3FD124A9, 0x240078B2, 0x00000000
data4    0x5BD4920F, 0x3FD1AE23, 0x23826B8E, 0x00000000
data4    0x15E2701D, 0x3FD23835, 0x22D31154, 0x00000000
data4    0x63739C2D, 0x3FD2C2E4, 0x2265C9E2, 0x00000000
data4    0xAFEEA48B, 0x3FD34E36, 0x245C05EB, 0x00000000
data4    0x7DBB35D1, 0x3FD3DA31, 0x24749F2D, 0x00000000
data4    0x67321619, 0x3FD466DA, 0x2462CECE, 0x00000000
data4    0x1F94A4D5, 0x3FD4F437, 0x246D0DF1, 0x00000000
data4    0x740C3E6D, 0x3FD5824D, 0x240A85B5, 0x00000000
data4    0x4CB1E73D, 0x3FD61123, 0x23F96E33, 0x00000000
data4    0xAD9EA64B, 0x3FD6A0BE, 0x247C5393, 0x00000000
data4    0xB804FD01, 0x3FD73125, 0x241F3B29, 0x00000000
data4    0xAB53EE83, 0x3FD7C25E, 0x2479989B, 0x00000000
data4    0xE6640EED, 0x3FD8546F, 0x23B343BC, 0x00000000
data4    0xE8AF1892, 0x3FD8E75F, 0x241454D1, 0x00000000
data4    0x53928BDA, 0x3FD97B35, 0x238613D9, 0x00000000
data4    0xEB9DE4DE, 0x3FDA0FF6, 0x22859FA7, 0x00000000
data4    0x99ECF92D, 0x3FDAA5AB, 0x237A6D06, 0x00000000
data4    0x6D8F1796, 0x3FDB3C5A, 0x23952F6C, 0x00000000
data4    0x9CFB8BE4, 0x3FDBD40A, 0x2280FC95, 0x00000000
data4    0x87943100, 0x3FDC6CC3, 0x245D2EC0, 0x00000000
data4    0xB736C500, 0x3FDD068C, 0x23C4AD7D, 0x00000000
data4    0xE1DDBC31, 0x3FDDA16D, 0x23D076E6, 0x00000000
data4    0xEB515A93, 0x3FDE3D6E, 0x244809A6, 0x00000000
data4    0xE6E9E5F1, 0x3FDEDA97, 0x220856C8, 0x00000000
data4    0x1963CE69, 0x3FDF78F1, 0x244BE993, 0x00000000
data4    0x7D635BCE, 0x3FE00C41, 0x23D21799, 0x00000000
data4    0x1C302CD3, 0x3FE05CAB, 0x248A1B1D, 0x00000000
data4    0xDB6A1FA0, 0x3FE0ADB9, 0x23D53E33, 0x00000000
data4    0x4A20BA81, 0x3FE0FF72, 0x24DB9ED5, 0x00000000
data4    0x153FA6F5, 0x3FE151D9, 0x24E9E451, 0x00000000
//
//  Entries T_hi   double-precision memory format
//  Index = 0,1,...,19  B = 2^(-1)*(1+Index/32+1/64)
//  Entries T_lo  single-precision memory format
//  Index = 0,1,...,19  B = 2^(-1)*(1+Index/32+1/64)
//
data4    0xBA1BE39E, 0x3FE1CEC4, 0x24B60F9E, 0x00000000
data4    0x5ABD9B2D, 0x3FE277E4, 0x248C2474, 0x00000000
data4    0x0272B110, 0x3FE32418, 0x247B8311, 0x00000000
data4    0x890E2DF0, 0x3FE3D38B, 0x24C55751, 0x00000000
data4    0x46236871, 0x3FE4866D, 0x24E5BC34, 0x00000000
data4    0x45E044B0, 0x3FE53CEE, 0x24001BA4, 0x00000000
data4    0x82EC06E4, 0x3FE5F742, 0x24B973DC, 0x00000000
data4    0x25DF43F9, 0x3FE6B5A1, 0x24895440, 0x00000000
data4    0xCAFD348C, 0x3FE77844, 0x240021CA, 0x00000000
data4    0xCEED6B92, 0x3FE83F6B, 0x24C45372, 0x00000000
data4    0xA34F3665, 0x3FE90B58, 0x240DAD33, 0x00000000
data4    0x2C1E56B4, 0x3FE9DC52, 0x24F846CE, 0x00000000
data4    0x27041578, 0x3FEAB2A4, 0x2323FB6E, 0x00000000
data4    0x9DD8C373, 0x3FEB8E9F, 0x24B3090B, 0x00000000
data4    0x65C9AA7B, 0x3FEC